leObject, &Offset, Length, MdlChain, IoStatus );
        }

    } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                    ? EXCEPTION_EXECUTE_HANDLER
                                    : EXCEPTION_CONTINUE_SEARCH ) {

        Status = FALSE;
    }

    PsGetCurrentThread()->TopLevelIrp = 0;

    //
    //  If we succeeded, see if we have to update FileSize or ValidDataLength.
    //

    if (Status) {

        //
        // In the case of ValidDataLength, we really have to check again
        // since we did not do this when we acquired the resource exclusive.
        //

        if ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart ) {

            //
            //  Deal with an extremely rare pathalogical case here the
            //  ValidDataLength wraps.
            //

            if ( (Header->ValidDataLength.HighPart != NewFileSize.HighPart) &&
                 (Header->PagingIoResource != NULL) ) {

                (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                Header->ValidDataLength = NewFileSize;
                ExReleaseResourceLite( Header->PagingIoResource );

            } else {

                Header->ValidDataLength = NewFileSize;
            }
        }

        //
        //  Set this handle as having modified the file
        //

        FileObject->Flags |= FO_FILE_MODIFIED;

        if (FileSizeChanged) {

            *CcGetFileSizePointer(FileObject) = NewFileSize;

            FileObject->Flags |= FO_FILE_SIZE_CHANGED;
        }

    //
    //  If we did not succeed, then we must restore the original FileSize
    //  and release the resource.  In the success path, the cache manager
    //  will release the resource.
    //

    } else {

        if (FileSizeChanged) {

            if ( Header->PagingIoResource != NULL ) {

                (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                Header->FileSize = OldFileSize;
                Header->ValidDataLength = OldValidDataLength;
                ExReleaseResourceLite( Header->PagingIoResource );

            } else {

                Header->FileSize = OldFileSize;
                Header->ValidDataLength = OldValidDataLength;
            }
        }
    }

    //
    //  Now we can release the resource.
    //

    ExReleaseResourceLite( Header->Resource );

    FsRtlExitFileSystem();

    return Status;
}


//
//  The old routine will either dispatch or call FsRtlPrepareMdlWriteDev
//

BOOLEAN
FsRtlPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    This routine does a fast cached mdl read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcMdlRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    MdlChain - On output it returns a pointer to an MDL chain describing
        the desired data.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if the data was not written, or if there is an I/O error.

    TRUE - if the data is being written

--*/

{
    PDEVICE_OBJECT DeviceObject, VolumeDeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    //
    //  See if the (top-level) FileSystem has a FastIo routine, and if so, call it.
    //

    if ((FastIoDispatch != NULL) &&
        (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, PrepareMdlWrite)) &&
        (FastIoDispatch->PrepareMdlWrite != NULL)) {

        return FastIoDispatch->PrepareMdlWrite( FileObject, FileOffset, Length, LockKey, MdlChain, IoStatus, DeviceObject );

    } else {

        //
        //  Get the DeviceObject for the volume.  If that DeviceObject is different, and
        //  it specifies the FastIo routine, then we have to return FALSE here and cause
        //  an Irp to get generated.
        //

        VolumeDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );
        if ((VolumeDeviceObject != DeviceObject) &&
            (FastIoDispatch = VolumeDeviceObject->DriverObject->FastIoDispatch) &&
            (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, PrepareMdlWrite)) &&
            (FastIoDispatch->PrepareMdlWrite != NULL)) {

            return FALSE;

        //
        //  Otherwise, call the default routine.
        //

        } else {

            return FsRtlPrepareMdlWriteDev( FileObject, FileOffset, Length, LockKey, MdlChain, IoStatus, DeviceObject );
        }
    }
}


//
//  The old routine will either dispatch or call FsRtlMdlWriteCompleteDev
//

BOOLEAN
FsRtlMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain
    )

/*++

Routine Description:

    This routine completes an Mdl write.

Arguments:

    FileObject - Pointer to the file object being read.

    MdlChain - Supplies a pointer to an MDL chain returned from CcMdlPrepareMdlWrite.

Return Value:



--*/

{
    PDEVICE_OBJECT DeviceObject, VolumeDeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;

    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    //
    //  See if the (top-level) FileSystem has a FastIo routine, and if so, call it.
    //

    if ((FastIoDispatch != NULL) &&
        (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlWriteComplete)) &&
        (FastIoDispatch->MdlWriteComplete != NULL)) {

        return FastIoDispatch->MdlWriteComplete( FileObject, FileOffset, MdlChain, DeviceObject );

    } else {

        //
        //  Get the DeviceObject for the volume.  If that DeviceObject is different, and
        //  it specifies the FastIo routine, then we have to return FALSE here and cause
        //  an Irp to get generated.
        //

        VolumeDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );
        if ((VolumeDeviceObject != DeviceObject) &&
            (FastIoDispatch = VolumeDeviceObject->DriverObject->FastIoDispatch) &&
            (FastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET(FAST_IO_DISPATCH, MdlWriteComplete)) &&
            (FastIoDispatch->MdlWriteComplete != NULL)) {

            return FALSE;

        //
        //  Otherwise, call the default routine.
        //

        } else {

            return FsRtlMdlWriteCompleteDev( FileObject, FileOffset, MdlChain, DeviceObject );
        }
    }
}


BOOLEAN
FsRtlMdlWriteCompleteDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine completes an Mdl write.

Arguments:

    FileObject - Pointer to the file object being read.

    MdlChain - Supplies a pointer to an MDL chain returned from CcMdlPrepareMdlWrite.

    DeviceObject - Supplies the DeviceObject for the callee.

Return Value:



--*/


{
    //
    //  Do not support WRITE_THROUGH in the fast path call.
    //

    if (FlagOn( FileObject->Flags, FO_WRITE_THROUGH )) {
        return FALSE;
    }

    CcMdlWriteComplete2( FileObject, FileOffset, MdlChain );
    return TRUE;
}


NTKERNELAPI
NTSTATUS
FsRtlRegisterFileSystemFilterCallbacks (
    IN PDRIVER_OBJECT FilterDriverObject,
    IN PFS_FILTER_CALLBACKS Callbacks
    )

/*++

Routine Description:

    This routine registers the FilterDriverObject to receive the
    notifications specified in Callbacks at the appropriate times
    for the devices to which this driver is attached.

    This should only be called by a file system filter during
    its DriverEntry routine.

Arguments:

    FileObject - Pointer to the file object being written.

    EndingOffset - The offset of the last byte being written + 1.

    ByteCount - Length of data in bytes.

    ResourceToRelease - Returns the resource to release.  Not defined if
        FALSE is returned.

Return Value:

    STATUS_SUCCESS - The callbacks were successfully registered 
        for this driver.

    STATUS_INSUFFICIENT_RESOURCES - There wasn't enough memory to
        store these callbacks for the driver.

    STATUS_INVALID_PARAMETER - Returned in any of the parameters
        are invalid.
        
--*/

{
    PDRIVER_EXTENSION DriverExt;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;

    PAGED_CODE();

    if (!(ARGUMENT_PRESENT( FilterDriverObject ) && 
          ARGUMENT_PRESENT( Callbacks ))) {

        return STATUS_INVALID_PARAMETER;
    }
    
    DriverExt = FilterDriverObject->DriverExtension;

    FsFilterCallbacks = ExAllocatePoolWithTag( NonPagedPool, 
                                               Callbacks->SizeOfFsFilterCallbacks,
                                               FSRTL_FILTER_MEMORY_TAG ); 

    if (FsFilterCallbacks == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory( FsFilterCallbacks,
                   Callbacks,
                   Callbacks->SizeOfFsFilterCallbacks );
                   
    DriverExt->FsFilterCallbacks = FsFilterCallbacks;

    return STATUS_SUCCESS;
}


NTKERNELAPI
BOOLEAN
FsRtlAcquireFileForModWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease
    )

/*++

Routine Description:

    This routine decides which file system resource the modified page
    writer should acquire and acquires it if possible.  Wait is always
    specified as FALSE.  We pass back the resource Mm has to release
    when the write completes.

    This routine is obsolete --- should call FsRtlAcquireFileForModWriteEx
    instead.

Arguments:

    FileObject - Pointer to the file object being written.

    EndingOffset - The offset of the last byte being written + 1.

    ByteCount - Length of data in bytes.

    ResourceToRelease - Returns the resource to release.  Not defined if
        FALSE is returned.

Return Value:

    FALSE - The resource could not be acquired without waiting.

    TRUE - The returned resource has been acquired.

--*/

{
    NTSTATUS Status;
    
    //
    //  Just call the new version of this routine and process
    //  the NTSTATUS returned into TRUE for success and FALSE 
    //  for failure.
    //
    
    Status = FsRtlAcquireFileForModWriteEx( FileObject,
                                            EndingOffset,
                                            ResourceToRelease );

    if (!NT_SUCCESS( Status )) {

        return FALSE;

    }

    return TRUE;
}


NTKERNELAPI
NTSTATUS
FsRtlAcquireFileForModWriteEx (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease
    )
/*++

Routine Description:

    This routine decides which file system resource the modified page
    writer should acquire and acquires it if possible.  Wait is always
    specified as FALSE.  We pass back the resource Mm has to release
    when the write completes.

    The operation is presented to any file system filters attached to this 
    volume before and after the file system is asked to acquire this resource.

Arguments:

    FileObject - Pointer to the file object being written.

    EndingOffset - The offset of the last byte being written + 1.

    ByteCount - Length of data in bytes.

    ResourceToRelease - Returns the resource to release.  Not defined if
        FALSE is returned.

Return Value:

    FALSE - The resource could not be acquired without waiting.

    TRUE - The returned resource has been acquired.

--*/
{

    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT BaseFsDeviceObject;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CALLBACK_DATA CallbackData;
    PFSRTL_COMMON_FCB_HEADER Header;
    PERESOURCE ResourceAcquired;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    BOOLEAN AcquireExclusive;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseFsDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //
    
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireForModWrite ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForModifiedPageWriter ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForModifiedPageWriter ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForModifiedPageWriter ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForModifiedPageWriter )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }
    
    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //

        CallFilters = NULL;
    }

    if (CallFilters) {

        //
        //  Call routine to initialize the control structure.
        //

        Status = FsFilterCtrlInit( &FsFilterCtrl,
                                   FS_FILTER_ACQUIRE_FOR_MOD_WRITE,
                                   DeviceObject,
                                   BaseFsDeviceObject,
                                   FileObject,
                                   TRUE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        //
        // Initialize the operation-specific parameters in the callback data.
        //

        CallbackData = &(FsFilterCtrl.Data);
        CallbackData->Parameters.AcquireForModifiedPageWriter.EndingOffset = EndingOffset;

        Status = FsFilterPerformCallbacks( &FsFilterCtrl, 
                                           TRUE, 
                                           TRUE, 
                                           &BaseFsFailedOperation );
    }

    if (NT_SUCCESS( Status )) {

        if (CallFilters && FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

            BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
            ReleaseBaseFsDeviceReference = TRUE;
            FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
            FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            FileObject = FsFilterCtrl.Data.FileObject;
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForModifiedPageWriter ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForModifiedPageWriter ))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireForModWrite )) {

                Status = FastIoDispatch->AcquireForModWrite( FileObject,
                                                             EndingOffset,
                                                             ResourceToRelease,
                                                             BaseFsDeviceObject );
            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //
            
            BaseFsFailedOperation = TRUE;
        }

        if (ReleaseBaseFsDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) || 
            (Status == STATUS_CANT_WAIT) || 
            (Status == STATUS_INVALID_DEVICE_REQUEST) );

    //
    //  If the base file system didn't have an AcquireForModWrite handler
    //  or couldn't return STATUS_SUCCESS or STATUS_CANT_WAIT, 
    //  we need to perform the default actions here.
    //

    if ((Status != STATUS_SUCCESS) && 
        (Status != STATUS_CANT_WAIT) && 
        BaseFsFailedOperation) {

        //
        //  We follow the following rules to determine which resource
        //  to acquire.  We use the flags in the common header.  These
        //  flags can't change once we have acquired any resource.
        //  This means we can do an unsafe test and optimisticly
        //  acquire a resource.  At that point we can test the bits
        //  to see if we have what we want.
        //
        //  0 - If there is no main resource, acquire nothing.
        //
        //  1 - Acquire the main resource exclusively if the
        //      ACQUIRE_MAIN_RSRC_EX flag is set or we are extending
        //      valid data.
        //
        //  2 - Acquire the main resource shared if there is
        //      no paging io resource or the
        //      ACQUIRE_MAIN_RSRC_SH flag is set.
        //
        //  3 - Otherwise acquire the paging io resource shared.
        //
    
        Header = (PFSRTL_COMMON_FCB_HEADER) FileObject->FsContext;

        if (Header->Resource == NULL) {

            *ResourceToRelease = NULL;

            Status = STATUS_SUCCESS;
            goto FsRtlAcquireFileForModWrite_CallCompletionCallbacks;
        }

        if (FlagOn( Header->Flags, FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX ) ||
            (EndingOffset->QuadPart > Header->ValidDataLength.QuadPart &&
             Header->ValidDataLength.QuadPart != Header->FileSize.QuadPart)) {

            ResourceAcquired = Header->Resource;
            AcquireExclusive = TRUE;

        } else if (FlagOn( Header->Flags, FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH ) ||
                   Header->PagingIoResource == NULL) {

            ResourceAcquired = Header->Resource;
            AcquireExclusive = FALSE;

        } else {

            ResourceAcquired = Header->PagingIoResource;
            AcquireExclusive = FALSE;
        }

        //
        //  Perform the following in a loop in case we need to back and
        //  check the state of the resource acquisition.  In most cases
        //  the initial checks will succeed and we can proceed immediately.
        //  We have to worry about the two FsRtl bits changing but
        //  if there is no paging io resource before there won't ever be
        //  one.
        //

        while (TRUE) {

            //
            //  Now acquire the desired resource.
            //

            if (AcquireExclusive) {

                if (!ExAcquireResourceExclusiveLite( ResourceAcquired, FALSE )) {

                    Status = STATUS_CANT_WAIT;
                    goto FsRtlAcquireFileForModWrite_CallCompletionCallbacks;
                }

            } else if (!ExAcquireSharedWaitForExclusive( ResourceAcquired, FALSE )) {

                Status = STATUS_CANT_WAIT;
                goto FsRtlAcquireFileForModWrite_CallCompletionCallbacks;
            }

            //
            //  If the valid data length is changing or the exclusive bit is
            //  set and we don't have the main resource exclusive then
            //  release the current resource and acquire the main resource
            //  exclusively and move to the top of the loop.
            //
            //  We must get it exclusive in all cases where the ending offset
            //  is beyond vdl.  It used to be allowed shared if vdl == fs, but
            //  this neglected the possibility that the file could be extended
            //  under our shared (pagingio) access.
            //

            if (FlagOn( Header->Flags, FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX ) ||
                EndingOffset->QuadPart > Header->ValidDataLength.QuadPart) {

                //
                //  If we don't have the main resource exclusively then
                //  release the current resource and attempt to acquire
                //  the main resource exclusively.
                //

                if (!AcquireExclusive) {

                    ExReleaseResourceLite( ResourceAcquired );
                    AcquireExclusive = TRUE;
                    ResourceAcquired = Header->Resource;
                    continue;
                }

                //
                //  We have the correct resource.  Exit the loop.
                //

            //
            //  If we should be acquiring the main resource shared then move
            //  to acquire the correct resource and proceed to the top of the loop.
            //

            } else if (FlagOn( Header->Flags, FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH )) {

                //
                //  If we have the main resource exclusively then downgrade to
                //  shared and exit the loop.
                //

                if (AcquireExclusive) {

                    ExConvertExclusiveToSharedLite( ResourceAcquired );

                //
                //  If we have the paging io resource then give up this resource
                //  and acquire the main resource exclusively.  This is going
                //  at it with a large hammer but is guaranteed to be resolved
                //  in the next pass through the loop.
                //

                } else if (ResourceAcquired != Header->Resource) {

                    ExReleaseResourceLite( ResourceAcquired );
                    ResourceAcquired = Header->Resource;
                    AcquireExclusive = TRUE;
                    continue;
                }

                //
                //  We have the correct resource.  Exit the loop.
                //

            //
            //  At this point we should have the paging Io resource shared
            //  if it exists.  If not then acquire it shared and release the
            //  other resource and exit the loop.
            //

            } else if (Header->PagingIoResource != NULL
                       && ResourceAcquired != Header->PagingIoResource) {

                ResourceAcquired = NULL;

                if (ExAcquireSharedWaitForExclusive( Header->PagingIoResource, FALSE )) {

                    ResourceAcquired = Header->PagingIoResource;
                }

                ExReleaseResourceLite( Header->Resource );

                if (ResourceAcquired == NULL) {

                    Status = STATUS_CANT_WAIT;
                    goto FsRtlAcquireFileForModWrite_CallCompletionCallbacks;
                }

                //
                //  We now have the correct resource.  Exit the loop.
                //

            //
            //  We should have the main resource shared.  If we don't then
            //  degrade our lock to shared access.
            //

            } else if (AcquireExclusive) {

                ExConvertExclusiveToSharedLite( ResourceAcquired );

                //
                //  We now have the correct resource.  Exit the loop.
                //
            }

            //
            //  We have the correct resource.  Exit the loop.
            //

            break;
        }

        *ResourceToRelease = ResourceAcquired;

        Status = STATUS_SUCCESS;
    }

FsRtlAcquireFileForModWrite_CallCompletionCallbacks:

    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //
    
    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }
        
        FsFilterCtrlFree( &FsFilterCtrl );
    }

#if DBG

    if (NT_SUCCESS( Status )) {

        gCounter.AcquireFileForModWriteEx_Succeed ++;

    } else {

        gCounter.AcquireFileForModWriteEx_Fail ++;
    }

#endif
    
    return Status;          
}


NTKERNELAPI
VOID
FsRtlReleaseFileForModWrite (
    IN PFILE_OBJECT FileObject,
    IN PERESOURCE ResourceToRelease
    )

/*++

Routine Description:

    This routine releases a file system resource previously acquired for
    the modified page writer.

Arguments:

    FileObject - Pointer to the file object being written.

    ResourceToRelease - Supplies the resource to release.  Not defined if
        FALSE is returned.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT BaseFsDeviceObject, DeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CALLBACK_DATA CallbackData;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

#if DBG
    gCounter.ReleaseFileForModWrite ++;
#endif

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //
    
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, ReleaseForModWrite ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForModifiedPageWriter ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForModifiedPageWriter ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForModifiedPageWriter ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForModifiedPageWriter )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }

    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //

        CallFilters = NULL;
    }

    if (CallFilters) {
    
        FsFilterCtrlInit( &FsFilterCtrl,
                          FS_FILTER_RELEASE_FOR_MOD_WRITE,
                          DeviceObject,
                          BaseFsDeviceObject,
                          FileObject,
                          FALSE );

        //
        // Initialize the operation-specific parameters in the callback data.
        //

        CallbackData = &(FsFilterCtrl.Data);
        CallbackData->Parameters.ReleaseForModifiedPageWriter.ResourceToRelease = ResourceToRelease;

        Status = FsFilterPerformCallbacks( &FsFilterCtrl, 
                                           FALSE, 
                                           TRUE, 
                                           &BaseFsFailedOperation );
    }                                           

    if (NT_SUCCESS( Status )) {

        if (CallFilters && FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

            BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
            ReleaseBaseDeviceReference = TRUE;
            FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
            FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            FileObject = FsFilterCtrl.Data.FileObject;
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForModifiedPageWriter ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForModifiedPageWriter ))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, ReleaseForModWrite )) {

                Status = FastIoDispatch->ReleaseForModWrite( FileObject, 
                                                             ResourceToRelease, 
                                                             BaseFsDeviceObject );

            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //
            
            BaseFsFailedOperation = TRUE;
        }

        if (ReleaseBaseDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) || (Status == STATUS_INVALID_DEVICE_REQUEST) );

    //
    //  If the base file system doesn't provide a handler for this
    //  operation or the handler couldn't release the lock, perform the 
    //  default action, which is releasing the ResourceToRelease.
    //
    
    if (Status == STATUS_INVALID_DEVICE_REQUEST &&
        BaseFsFailedOperation) {
        
        ExReleaseResourceLite( ResourceToRelease );
        Status = STATUS_SUCCESS;
    }
    
    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //
    
    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }
        
        FsFilterCtrlFree( &FsFilterCtrl );
    }
}


NTKERNELAPI
VOID
FsRtlAcquireFileForCcFlush (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine acquires a file system resource prior to a call to CcFlush.

    This routine is obsolete --- FsRtlAcquireFileForCcFlushEx should
    be used instead.

Arguments:

    FileObject - Pointer to the file object being written.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Just call the new version of this routine and ignore
    //  the return value.  In the debug version, we will assert
    //  if we see a failure here to encourage people to call the
    //  FsRtlAcquireFileForCcFlushEx.
    //

    Status = FsRtlAcquireFileForCcFlushEx( FileObject );

    ASSERT( NT_SUCCESS( Status ) );
}


NTKERNELAPI
NTSTATUS
FsRtlAcquireFileForCcFlushEx (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine acquires a file system resource prior to a call to CcFlush.
    This operation is presented to all the file system filters in the
    filter stack for this volume.  If all filters success the operation,
    the base file system is requested to acquire the file system resource
    for CcFlush.

Arguments:

    FileObject - Pointer to the file object being written.

Return Value:

    None.

--*/

{

    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT BaseFsDeviceObject;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseFsDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

    PAGED_CODE();

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //
    
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireForCcFlush ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForCcFlush ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForCcFlush ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForCcFlush ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForCcFlush )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }
    
    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //

        CallFilters = NULL;
    }

    if (CallFilters) {

        //
        //  Call routine to initialize the control structure.
        //

        Status = FsFilterCtrlInit( &FsFilterCtrl,
                                   FS_FILTER_ACQUIRE_FOR_CC_FLUSH,
                                   DeviceObject,
                                   BaseFsDeviceObject,
                                   FileObject,
                                   TRUE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        //
        //  There are no operation specific parameters for this
        //  operation, so just perform the pre-callbacks.
        //

        FsRtlEnterFileSystem();

        Status = FsFilterPerformCallbacks( &FsFilterCtrl, 
                                           TRUE, 
                                           TRUE, 
                                           &BaseFsFailedOperation );
                                           
    } else {

        //
        //  We don't have any filters to call, but we still need
        //  to disable APCs.
        //

        FsRtlEnterFileSystem();
    }

    if (NT_SUCCESS( Status )) {

        if (CallFilters && FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

            BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
            ReleaseBaseFsDeviceReference = TRUE;
            FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
            FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            FileObject = FsFilterCtrl.Data.FileObject;
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForCcFlush ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForCcFlush))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireForCcFlush )) {

                Status = FastIoDispatch->AcquireForCcFlush( FileObject, 
                                                            BaseFsDeviceObject );

            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //
            
            BaseFsFailedOperation = TRUE;
        }

        if (ReleaseBaseFsDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) || (Status == STATUS_INVALID_DEVICE_REQUEST) );
    
    //
    //  If the file system doesn't have a dispatch handler or failed this
    //  this operation, try to acquire the appropriate resources ourself.
    //

    if (Status == STATUS_INVALID_DEVICE_REQUEST &&
        BaseFsFailedOperation) {

        PFSRTL_COMMON_FCB_HEADER Header = FileObject->FsContext;

        //
        //  If not already owned get the main resource exclusive because we may
        //  extend ValidDataLength.  Otherwise acquire it one more time recursively.
        //
        
        if (Header->Resource != NULL) {

            if (!ExIsResourceAcquiredSharedLite( Header->Resource )) {

                ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

            } else {

                ExAcquireResourceSharedLite( Header->Resource, TRUE );
            }
        }

        //
        //  Also get the paging I/O resource ahead of any MM resources.
        //

        if (Header->PagingIoResource != NULL) {
        
            ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );
        }

        Status = STATUS_SUCCESS;
    }
            
    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //
    
    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }
        
        FsFilterCtrlFree( &FsFilterCtrl );
    }

    //
    //  If this lock was not successfully acquired, then the lock
    //  will not need to be released.  Therefore, we need to call
    //  FsRtlExitFileSystem now.
    //

    if (!NT_SUCCESS( Status )) {

        FsRtlExitFileSystem();
    }

#if DBG

    if (NT_SUCCESS( Status )) {

        gCounter.AcquireFileForCcFlushEx_Succeed ++;

    } else {

        gCounter.AcquireFileForCcFlushEx_Fail ++;
    }

#endif

    return Status;
}


NTKERNELAPI
VOID
FsRtlReleaseFileForCcFlush (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine releases a file system resource previously acquired for
    the CcFlush.

Arguments:

    FileObject - Pointer to the file object being written.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT BaseFsDeviceObject, DeviceObject;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseFsDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

    PAGED_CODE();

#if DBG
    gCounter.ReleaseFileForCcFlush ++;
#endif

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //
    
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, ReleaseForCcFlush ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForCcFlush ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForCcFlush ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForCcFlush ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForCcFlush )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }
    
    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //

        
        CallFilters = NULL;
    }

    if (CallFilters) {
    
        FsFilterCtrlInit( &FsFilterCtrl,
                          FS_FILTER_RELEASE_FOR_CC_FLUSH,
                          DeviceObject,
                          BaseFsDeviceObject,
                          FileObject,
                          FALSE );

        //
        //  There are no operation-specific parameters to initialize,
        //  so perform the preoperation callbacks.
        //

        Status = FsFilterPerformCallbacks( &FsFilterCtrl, 
                                           FALSE, 
                                           TRUE, 
                                           &BaseFsFailedOperation );
    }

    if (NT_SUCCESS( Status )) {

        if (CallFilters && FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

            BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
            ReleaseBaseFsDeviceReference= TRUE;
            FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
            FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            FileObject = FsFilterCtrl.Data.FileObject;
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForCcFlush ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForCcFlush ))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, ReleaseForCcFlush )) {

                Status = FastIoDispatch->ReleaseForCcFlush( FileObject, BaseFsDeviceObject );
                
            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //
            
            BaseFsFailedOperation = TRUE;
        }
        
        if (ReleaseBaseFsDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) || (Status == STATUS_INVALID_DEVICE_REQUEST) );

    if (Status == STATUS_INVALID_DEVICE_REQUEST &&
        BaseFsFailedOperation) {

        PFSRTL_COMMON_FCB_HEADER Header = FileObject->FsContext;

        //
        //  The base file system doesn't provide a handler for this
        //  operation, so perform the default actions.
        //

        //
        //  Free whatever we could have acquired.
        //

        if (Header->PagingIoResource != NULL) {

            ExReleaseResourceLite( Header->PagingIoResource );
        }

        if (Header->Resource != NULL) {

            ExReleaseResourceLite( Header->Resource );
        }

        Status = STATUS_SUCCESS;
    }

    ASSERT( Status == STATUS_SUCCESS );

    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //
    
    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }
        
        FsFilterCtrlFree( &FsFilterCtrl );
    }

    FsRtlExitFileSystem();
}


NTKERNELAPI
VOID
FsRtlAcquireFileExclusive (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is used by NtCreateSection to pre-acquire file system
    resources in order to avoid deadlocks.  If there is a FastIo entry
    for AcquireFileForNtCreateSection then that routine will be called.
    Otherwise, we will simply acquire the main file resource exclusive.
    If there is no main resource then we acquire nothing and return
    FALSE.  In the cases that we acquire a resource, we also set the
    TopLevelIrp field in the thread local storage to indicate to file
    systems beneath us that we have acquired file system resources.

Arguments:

    FileObject - Pointer to the file object being written.

Return Value:

    NONE

--*/

{
    NTSTATUS Status;
    
    PAGED_CODE();

    //
    //  Just call the common version of this function, 
    //  FsRtlAcquireFileExclusiveCommon.
    //

    Status = FsRtlAcquireFileExclusiveCommon( FileObject, SyncTypeOther, 0 );

    //
    //  This should always be STATUS_SUCCESS since we are not
    //  allowing failures and the file system cannot fail
    //  this operation...
    //
    
    ASSERT( NT_SUCCESS( Status ) );
}


NTKERNELAPI
NTSTATUS
FsRtlAcquireToCreateMappedSection (
    IN PFILE_OBJECT FileObject,
    IN ULONG SectionPageProtection
    )

/*++

Routine Description:

    This routine is meant to replace FsRtlAcquireFileExclusive for
    the memory manager.  Mm calls this routine to synchronize
    for a mapped section create, but filters are allowed
    to fail this operation.  Other components that want to 
    synchronize with section creation should call 
    FsRtlAcquireFileExclusive.

    This routine calls FsRtlAcquireFileExclusiveCommon to do
    all the work.

    This routine is used by NtCreateSection to pre-acquire file system
    resources in order to avoid deadlocks.  If there is a FastIo entry
    for AcquireFileForNtCreateSection then that routine will be called.
    Otherwise, we will simply acquire the main file resource exclusive.
    If there is no main resource then we acquire nothing and return
    FALSE.  In the cases that we acquire a resource, we also set the
    TopLevelIrp field in the thread local storage to indicate to file
    systems beneath us that we have acquired file system resources.

Arguments:

    FileObject - Pointer to the file object being written.
    SectionPageProtection - The access requested for the section being
        created.

Return Value:

    The status of the operation.

--*/

{

    PAGED_CODE();

    return FsRtlAcquireFileExclusiveCommon( FileObject, SyncTypeCreateSection, SectionPageProtection );

}


NTKERNELAPI
NTSTATUS
FsRtlAcquireFileExclusiveCommon (
    IN PFILE_OBJECT FileObject,
    IN FS_FILTER_SECTION_SYNC_TYPE SyncType,
    IN ULONG SectionPageProtection
    )

/*++

Routine Description:

    This routine is used to pre-acquire file system resources in order 
    to avoid deadlocks.  The file system filters for this volume
    will be notified about this operation, then, if there is a FastIo 
    entry for AcquireFileForNtCreateSection, that routine will be called.
    Otherwise, we will simply acquire the main file resource exclusive.
    If there is no main resource then we acquire nothing and return
    STATUS_SUCCESS.  Finally, the file system filters will be notified 
    whether or not this resource has been acquired.

Arguments:

    FileObject - Pointer to the file object being written.
    CreatingMappedSection - TRUE if this lock is being acquired so that
        a mapped section can be created.  Filters are allowed
        to fail this operation.  FALSE otherwise.

Return Value:

    NONE

--*/

{

    PDEVICE_OBJECT DeviceObject, BaseFsDeviceObject;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AllowFilterToFailOperation;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseFsDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

    PAGED_CODE();

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //
    
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireFileForNtCreateSection ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForSectionSynchronization ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForSectionSynchronization ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForSectionSynchronization ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForSectionSynchronization )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }
    
    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //

        CallFilters = NULL;
    }

    if (CallFilters) {
    
        //
        //  Initialize operation specific parameters for this
        //  operation.
        //

        FsFilterCtrl.Data.Parameters.AcquireForSectionSynchronization.SyncType = 
            SyncType;
        FsFilterCtrl.Data.Parameters.AcquireForSectionSynchronization.PageProtection = 
            SectionPageProtection;

        switch (SyncType) {
        case SyncTypeCreateSection:
            AllowFilterToFailOperation = TRUE;
            break;
        
        case SyncTypeOther:
        default:
            AllowFilterToFailOperation = FALSE;
        }

        //
        //  Call routine to initialize the control structure.
        //

        Status = FsFilterCtrlInit( &FsFilterCtrl,
                                   FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION,
                                   DeviceObject,
                                   BaseFsDeviceObject,
                                   FileObject,
                                   AllowFilterToFailOperation );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        //
        //  There are no operation specific parameters for this
        //  operation, so just perform the pre-callbacks.
        //
        
        FsRtlEnterFileSystem();

        //
        //  Note: If the filter is allowed to fail the operation, so is the
        //  base file system, so we will just use that variable for both
        //  parameters to FsFilterPerformCallbacks.
        //

        Status = FsFilterPerformCallbacks( &FsFilterCtrl,
                                           AllowFilterToFailOperation,
                                           AllowFilterToFailOperation,
                                           &BaseFsFailedOperation );

    } else {

        //
        //  We don't have any filters to call, but we still need
        //  to disable APCs.
        //

        FsRtlEnterFileSystem();
    }

    if (NT_SUCCESS( Status )) {

        if (CallFilters && FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

            BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
            ReleaseBaseFsDeviceReference = TRUE;
            FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
            FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            FileObject = FsFilterCtrl.Data.FileObject;
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreAcquireForSectionSynchronization ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostAcquireForSectionSynchronization ))) {
                  
            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, AcquireFileForNtCreateSection )) {

                FastIoDispatch->AcquireFileForNtCreateSection( FileObject );

                //
                //  The status should already be STATUS_SUCCESS if we come down
                //  this path.  Since the FastIo handler doesn't return a value
                //  the status should remain STATUS_SUCCESS.
                //
                
                //  Status = STATUS_SUCCESS;

            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //
            
            BaseFsFailedOperation = TRUE;
        }        
        
        if (ReleaseBaseFsDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) || (Status == STATUS_INVALID_DEVICE_REQUEST) );

    if (Status == STATUS_INVALID_DEVICE_REQUEST &&
        BaseFsFailedOperation) {
        
        PFSRTL_COMMON_FCB_HEADER Header;

        //
        //  The file system doesn't have a dispatch handler for this
        //  operation, so try to acquire the appropriate resources
        //  ourself.
        //

        //
        //  If there is a main file resource, acquire that.
        //

        Header = FileObject->FsContext;

        if ((Header != NULL) &&
            (Header->Resource != NULL)) {

            ExAcquireResourceExclusiveLite( Header->Resource, TRUE );
        }

        Status = STATUS_SUCCESS;
    }

    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //
    
    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }
        
        FsFilterCtrlFree( &FsFilterCtrl );
    }

    //
    //  If this lock was not successfully acquired, then the lock
    //  will not need to be released.  Therefore, we need to call
    //  FsRtlExitFileSystem now.
    //

    if (!NT_SUCCESS( Status )) {

        FsRtlExitFileSystem();
    }
    
#if DBG

    if (NT_SUCCESS( Status )) {

        gCounter.AcquireFileExclusiveEx_Succeed ++;

    } else {

        gCounter.AcquireFileExclusiveEx_Fail ++;
    }
    
#endif
                                       
    return Status;
}


NTKERNELAPI
VOID
FsRtlReleaseFile (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine releases resources acquired by FsRtlAcquireFileExclusive.

Arguments:

    FileObject - Pointer to the file object being written.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT BaseFsDeviceObject, DeviceObject;
    FS_FILTER_CTRL FsFilterCtrl;
    PFS_FILTER_CTRL CallFilters = &FsFilterCtrl;
    NTSTATUS Status = STATUS_SUCCESS;
    PFAST_IO_DISPATCH FastIoDispatch;
    PFS_FILTER_CALLBACKS FsFilterCallbacks;
    BOOLEAN BaseFsGetsFsFilterCallbacks = FALSE;
    BOOLEAN ReleaseBaseFsDeviceReference = FALSE;
    BOOLEAN BaseFsFailedOperation = FALSE;

    PAGED_CODE();

#if DBG
    gCounter.ReleaseFile ++;
#endif

    //
    //  There are cases when the device that is the base fs device for
    //  this file object will register for the FsFilter callbacks instead of
    //  the legacy FastIo interfaces (DFS does this).  It then can redirect
    //  these operations to another stack that could possibly have file system
    //  filter drivers correctly.
    //
    
    DeviceObject = IoGetRelatedDeviceObject( FileObject );
    BaseFsDeviceObject = IoGetBaseFileSystemDeviceObject( FileObject );

    FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
    FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );

    //
    //  The BaseFsDeviceObject should only support one of these interfaces --
    //  either the FastIoDispatch interface for the FsFilterCallbacks interface.
    //  If a device provides support for both interfaces, we will only use
    //  the FsFilterCallback interface.
    //

    ASSERT( !(VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, ReleaseFileForNtCreateSection ) &&
              (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForSectionSynchronization ) ||
               VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForSectionSynchronization ))) );

    if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForSectionSynchronization ) ||
        VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForSectionSynchronization )) {

        BaseFsGetsFsFilterCallbacks = TRUE;
    }
    
    if (DeviceObject == BaseFsDeviceObject &&
        !BaseFsGetsFsFilterCallbacks) {

        //
        //  There are no filters attached to this device and the base file system
        //  does not want these callbacks. This quick check allows us to bypass the
        //  logic to see if any filters are interested.
        //


        CallFilters = NULL;
    }
    
    if (CallFilters) {

        FsFilterCtrlInit( &FsFilterCtrl,
                          FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION,
                          DeviceObject,
                          BaseFsDeviceObject,
                          FileObject,
                          FALSE );

        //
        //  There are no operation-specific parameters to initialize,
        //  so perform the preoperation callbacks.
        //

        Status = FsFilterPerformCallbacks( &FsFilterCtrl, 
                                           FALSE,
                                           FALSE,
                                           &BaseFsFailedOperation );
    }

    if (NT_SUCCESS( Status )) {

        if (CallFilters && FlagOn( FsFilterCtrl.Flags, FS_FILTER_CHANGED_DEVICE_STACKS )) {

            BaseFsDeviceObject = IoGetDeviceAttachmentBaseRef( FsFilterCtrl.Data.DeviceObject );
            ReleaseBaseFsDeviceReference = TRUE;
            FastIoDispatch = GET_FAST_IO_DISPATCH( BaseFsDeviceObject );
            FsFilterCallbacks = GET_FS_FILTER_CALLBACKS( BaseFsDeviceObject );
            FileObject = FsFilterCtrl.Data.FileObject;
        }

        if (!(VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PreReleaseForSectionSynchronization ) ||
              VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks, PostReleaseForSectionSynchronization ))) {

            //
            //  Call the base file system.
            //

            if (VALID_FAST_IO_DISPATCH_HANDLER( FastIoDispatch, 
                                                ReleaseFileForNtCreateSection )) {

                FastIoDispatch->ReleaseFileForNtCreateSection( FileObject );

                //
                //  The status should already be STATUS_SUCCESS if we come down
                //  this path.  Since the FastIo handler doesn't return a value
                //  the status should remain STATUS_SUCCESS.
                //
                
                //  Status = STATUS_SUCCESS;

            } else {

                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            //
            //  If there is a failure at this point, we know that the failure
            //  was caused by the base file system.
            //
            
            BaseFsFailedOperation = TRUE;
        }        
        
        if (ReleaseBaseFsDeviceReference) {

            ObDereferenceObject( BaseFsDeviceObject );
        }
    }

    ASSERT( (Status == STATUS_SUCCESS) || (Status == STATUS_INVALID_DEVICE_REQUEST ) );
    
    if (Status == STATUS_INVALID_DEVICE_REQUEST &&
        BaseFsFailedOperation) {

        PFSRTL_COMMON_FCB_HEADER Header = FileObject->FsContext;

        //
        //  The base file system doesn't provide a handler for this
        //  operation, so perform the default actions.
        //

        //
        //  If there is a main file resource, release that.
        //

        if ((Header != NULL) && (Header->Resource != NULL)) {

            ExReleaseResourceLite( Header->Resource );
        }

        Status = STATUS_SUCCESS;
    }
        
    //
    //  Again, we only want to call try to do completion callbacks
    //  if there are any filters attached to this device that have
    //  completion callbacks.  In any case, if we called down to the filters
    //  we need to free the FsFilterCtrl.
    //
    
    if (CallFilters) {

        if (FS_FILTER_HAVE_COMPLETIONS( CallFilters )) {

            FsFilterPerformCompletionCallbacks( &FsFilterCtrl, Status );
        }
        
        FsFilterCtrlFree( &FsFilterCtrl );
    }

    FsRtlExitFileSystem();

    return;
}


NTSTATUS
FsRtlGetFileSize(
    IN PFILE_OBJECT FileObject,
    IN OUT PLARGE_INTEGER FileSize
    )

/*++

Routine Description:

    This routine is used to call the File System to get the FileSize
    for a file.

    It does this without acquiring the file object lock on synchronous file
    objects.  This routine is therefore safe to call if you already own
    file system resources, while IoQueryFileInformation could (and does)
    lead to deadlocks.

Arguments:

    FileObject - The file to query
    FileSize - Receives the file size.

Return Value:

    NTSTATUS - The final I/O status of the operation.  If the FileObject
        refers to a directory, STATUS_FILE_IS_A_DIRECTORY is returned.

--*/
{
    IO_STATUS_BLOCK IoStatus;
    PDEVICE_OBJECT DeviceObject;
    PFAST_IO_DISPATCH FastIoDispatch;
    FILE_STANDARD_INFORMATION FileInformation;

    PAGED_CODE();

    //
    // Get the address of the target device object.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Try the fast query call if it exists.
    //

    FastIoDispatch = DeviceObject->DriverObject->FastIoDispatch;

    if (FastIoDispatch &&
        FastIoDispatch->FastIoQueryStandardInfo &&
        FastIoDispatch->FastIoQueryStandardInfo( FileObject,
                                                 TRUE,
                                                 &FileInformation,
                                                 &IoStatus,
                                                 DeviceObject )) {
        //
        //  Cool, it worked.
        //

    } else {

        //
        //  Life's tough, take the long path.
        //

        PIRP Irp;
        KEVENT Event;
        NTSTATUS Status;
        PIO_STACK_LOCATION IrpSp;
        BOOLEAN HardErrorState;

        //
        //  Initialize the event.
        //

        KeInitializeEvent( &Event, NotificationEvent, FALSE );

        //
        //  Allocate an I/O Request Packet (IRP) for this in-page operation.
        //

        Irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
        if (Irp == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Disable hard errors over this call. Caller owns resources, is in a critical
        //  region and cannot complete hard error APCs.
        //

        HardErrorState = IoSetThreadHardErrorMode( FALSE );

        //
        //  Get a pointer to the first stack location in the packet.  This location
        //  will be used to pass the function codes and parameters to the first
        //  driver.
        //

        IrpSp = IoGetNextIrpStackLocation( Irp );

        //
        //  Fill in the IRP according to this request, setting the flags to
        //  just cause IO to set the event and deallocate the Irp.
        //

        Irp->Flags = IRP_PAGING_IO | IRP_SYNCHRONOUS_PAGING_IO;
        Irp->RequestorMode = KernelMode;
        Irp->UserIosb = &IoStatus;
        Irp->UserEvent = &Event;
        Irp->Tail.Overlay.OriginalFileObject = FileObject;
        Irp->Tail.Overlay.Thread = PsGetCurrentThread();
        Irp->AssociatedIrp.SystemBuffer = &FileInformation;

        //
        //  Fill in the normal query parameters.
        //

        IrpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
        IrpSp->FileObject = FileObject;
        IrpSp->DeviceObject = DeviceObject;
        IrpSp->Parameters.SetFile.Length = sizeof(FILE_STANDARD_INFORMATION);
        IrpSp->Parameters.SetFile.FileInformationClass = FileStandardInformation;

        //
        //  Queue the packet to the appropriate driver based.  This routine
        //  should not raise.
        //

        Status = IoCallDriver( DeviceObject, Irp );

        //
        //  If pending is returned (which is a successful status),
        //  we must wait for the request to complete.
        //

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject( &Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER)NULL);
        }

        //
        //  If we got an error back in Status, then the Iosb
        //  was not written, so we will just copy the status
        //  there, then test the final status after that.
        //

        if (!NT_SUCCESS(Status)) {
            IoStatus.Status = Status;
        }

        //
        //  Reset the hard error state.
        //

        IoSetThreadHardErrorMode( HardErrorState );
    }

    //
    //  If the call worked, check to make sure it wasn't a directory and
    //  if not, fill in the FileSize parameter.
    //

    if (NT_SUCCESS(IoStatus.Status)) {

        if (FileInformation.Directory) {

            //
            // Can't get file size for a directory. Return error.
            //

            IoStatus.Status = STATUS_FILE_IS_A_DIRECTORY;

        } else {

            *FileSize = FileInformation.EndOfFile;
        }
    }

    return IoStatus.Status;
}


NTSTATUS
FsRtlSetFileSize(
    IN PFILE_OBJECT FileObject,
    IN OUT PLARGE_INTEGER FileSize
    )

/*++

Routine Description:

    This routine is used to call the File System to update FileSize
    for a file.

    It does this without acquiring the file object lock on synchronous file
    objects.  This routine is therefore safe to call if you already own
    file system resources, while IoSetInformation could (and does) lead
    to deadlocks.

Arguments:

    FileObject - A pointer to a referenced file object.

    ValidDataLength - Pointer to new FileSize.

Return Value:

    Status of operation.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    FILE_END_OF_FILE_INFORMATION Buffer;
    IO_STATUS_BLOCK IoStatus;
    KEVENT Event;
    PIRP Irp;
    BOOLEAN HardErrorState;

    PAGED_CODE();
    
    //
    //  Copy FileSize to our buffer.
    //

    Buffer.EndOfFile = *FileSize;

    //
    //  Initialize the event.
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Begin by getting a pointer to the device object that the file resides
    //  on.
    //

    DeviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    //  Allocate an I/O Request Packet (IRP) for this in-page operation.
    //

    Irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (Irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Disable hard errors over this call. Caller owns resources, is in a critical
    //  region and cannot complete hard error APCs.
    //

    HardErrorState = IoSetThreadHardErrorMode( FALSE );

    //
    //  Get a pointer to the first stack location in the packet.  This location
    //  will be used to pass the function codes and parameters to the first
    //  driver.
    //

    IrpSp = IoGetNextIrpStackLocation( Irp );

    //
    //  Fill in the IRP according to this request, setting the flags to
    //  just cause IO to set the event and deallocate the Irp.
    //

    Irp->Flags = IRP_PAGING_IO | IRP_SYNCHRONOUS_PAGING_IO;
    Irp->RequestorMode = KernelMode;
    Irp->UserIosb = &IoStatus;
    Irp->UserEvent = &Event;
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    Irp->AssociatedIrp.SystemBuffer = &Buffer;

    //
    //  Fill in the normal set file parameters.
    //

    IrpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    IrpSp->FileObject = FileObject;
    IrpSp->DeviceObject = DeviceObject;
    IrpSp->Parameters.SetFile.Length = sizeof(FILE_END_OF_FILE_INFORMATION);
    IrpSp->Parameters.SetFile.FileInformationClass = FileEndOfFileInformation;

    //
    //  Queue the packet to the appropriate driver based on whether or not there
    //  is a VPB associated with the device.  This routine should not raise.
    //

    Status = IoCallDriver( DeviceObject, Irp );

    //
    //  If pending is returned (which is a successful status),
    //  we must wait for the request to complete.
    //

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER)NULL);
    }

    //
    //  If we got an error back in Status, then the Iosb
    //  was not written, so we will just copy the status
    //  there, then test the final status after that.
    //

    if (!NT_SUCCESS(Status)) {
        IoStatus.Status = Status;
    }

    //
    //  Reset the hard error state.
    //

    IoSetThreadHardErrorMode( HardErrorState );

    return IoStatus.Status;
}


VOID 
FsRtlIncrementCcFastReadNotPossible( VOID )

/*++

Routine Description:

    This routine increments the CcFastReadNotPossible counter in the PRCB

Arguments:

Return Value:

--*/

{
    HOT_STATISTIC( CcFastReadNotPossible ) += 1;
}


VOID 
FsRtlIncrementCcFastReadWait( VOID )

/*++

Routine Description:

    This routine increments the CcFastReadWait counter in the PRCB

Arguments:

Return Value:

--*/

{

    HOT_STATISTIC(CcFastReadWait) += 1;
}


VOID 
FsRtlIncrementCcFastReadNoWait( VOID )

/*++

Routine Description:

    This routine increments the CcFastReadNoWait counter in the PRCB

Arguments:

Return Value:

--*/

{

    HOT_STATISTIC(CcFastReadNoWait) += 1;
}


VOID 
FsRtlIncrementCcFastReadResourceMiss( VOID )

/*++

Routine Description:

    This routine increments the CcFastReadResourceMiss

Arguments:

Return Value:

--*/

{

    CcFastReadResourceMiss += 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\filter.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Filter.c

Abstract:

    The Exception filter is used by the file system and cache manager
    to handle error recovery.  The basic idea is to have the top level
    file system entry points (i.e., the FSD entry points and FSP dispatch
    loop) have a try-except around their code, and then whenever the
    file system or cache manager reach an error case they raise an
    appropriate status.  Then the exception handler catches the exception
    and can either complete the request, send it off to the fsp, verify the
    volume, or bugcheck.  We only bugcheck if the raised exception is
    unexpected (i.e., unhandled).

    This module provides two routines for filtering out exceptions.  The
    first routine is used to normalize status values to be one of the
    value handled by the filter.  That way if we get an exception not handled
    by the filter then we know that the system is in real trouble and we
    just bugcheck the machine.  The second routine is used to ask if
    a status value is within the set of values handled by the filter.

    The value of status handled by this filter are listed in the routine
    FsRtlIsNtstatusExpected.

Author:

    Gary Kimura     [GaryKi]    4-Jan-1991

Revision History:

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x80000000)


NTSTATUS
FsRtlNormalizeNtstatus (
    IN NTSTATUS Exception,
    IN NTSTATUS GenericException
    )

/*++

Routine Description:

    This routine is used to normalize an NTSTATUS into a status
    that is handled by the file system's top level exception handlers.

Arguments:

    Exception - Supplies the exception being normalized

    GenericException - Supplies a second exception to translate to
        if the first exception is not within the set of exceptions
        handled by the filter

Return Value:

    NTSTATUS - Returns Exception if the value is already handled
        by the filter, and GenericException otherwise.

--*/

{
    return (FsRtlIsNtstatusExpected(Exception) ? Exception : GenericException);
}


BOOLEAN
FsRtlIsNtstatusExpected (
    IN NTSTATUS Exception
    )

/*++

Routine Description:

    This routine is used to decide if a status is within the set of values
    handled by the exception filter.

Arguments:

    Exception - Supplies the exception being queried

Return Value:

    BOOLEAN - Returns TRUE if the value is handled by the filter, and
        FALSE otherwise.

--*/

{
    switch (Exception) {

    case STATUS_DATATYPE_MISALIGNMENT:
    case STATUS_ACCESS_VIOLATION:
    case STATUS_ILLEGAL_INSTRUCTION:
    case STATUS_INSTRUCTION_MISALIGNMENT:

        return FALSE;

    default:

        return TRUE;
    }
}


#undef FsRtlAllocatePool

PVOID
FsRtlAllocatePool (
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    This routine is used to allocate executive level pool.  It either
    returns a non null pointer to the newly allocated pool or it raises
    a status of insufficient resources.

Arguments:

    PoolType - Supplies the type of executive pool to allocate

    NumberOfBytes - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a non null pointer to the newly allocated pool.

--*/

{
    PVOID p;

    //
    //  Allocate executive pool and if we get back null then raise
    //  a status of insufficient resources
    //

    if ((p = ExAllocatePoolWithTag( PoolType, NumberOfBytes, 'trSF')) == NULL) {

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    return p;
}

#undef FsRtlAllocatePoolWithQuota


PVOID
FsRtlAllocatePoolWithQuota (
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    This routine is used to allocate executive level pool with quota.  It
    either returns a non null pointer to the newly allocated pool or it raises
    a status of insufficient resources.

Arguments:

    PoolType - Supplies the type of executive pool to allocate

    NumberOfBytes - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a non null pointer to the newly allocated pool.

--*/

{
    PVOID p;

    //
    //  Allocate executive pool and if we get back null then raise
    //  a status of insufficient resources
    //

    if ((p = ExAllocatePoolWithQuotaTag ( PoolType, NumberOfBytes, 'trSF')) == NULL) {

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    return p;
}


#undef FsRtlAllocatePoolWithTag

PVOID
FsRtlAllocatePoolWithTag (
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This routine is used to allocate executive level pool with a tag.

Arguments:

    PoolType - Supplies the type of executive pool to allocate

    NumberOfBytes - Supplies the number of bytes to allocate

    Tag - Supplies the tag for the pool block

Return Value:

    PVOID - Returns a non null pointer to the newly allocated pool.

--*/

{
    PVOID p;

    //
    //  Allocate executive pool and if we get back null then raise
    //  a status of insufficient resources
    //

    if ((p = ExAllocatePoolWithTag( PoolType, NumberOfBytes, Tag)) == NULL) {

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    return p;
}


#undef FsRtlAllocatePoolWithQuotaTag

PVOID
FsRtlAllocatePoolWithQuotaTag (
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    This routine is used to allocate executive level pool with a quota tag.

Arguments:

    PoolType - Supplies the type of executive pool to allocate

    NumberOfBytes - Supplies the number of bytes to allocate

    Tag - Supplies the tag for the pool block

Return Value:

    PVOID - Returns a non null pointer to the newly allocated pool.

--*/

{
    PVOID p;

    //
    //  Allocate executive pool and if we get back null then raise
    //  a status of insufficient resources
    //

    if ((p = ExAllocatePoolWithQuotaTag( PoolType, NumberOfBytes, Tag)) == NULL) {

        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
    }

    return p;
}


BOOLEAN
FsRtlIsTotalDeviceFailure(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine is given an NTSTATUS value and make a determination as to
    if this value indicates that the complete device has failed and therefore
    should no longer be used, or if the failure is one that indicates that
    continued use of the device is ok (i.e. a sector failure).

Arguments:

    Status - the NTSTATUS value to test.

Return Value:

    TRUE  - The status value given is believed to be a fatal device error.
    FALSE - The status value given is believed to be a sector failure, but not
            a complete device failure.
--*/

{
    if (NT_SUCCESS(Status)) {

        //
        // All warning and informational errors will be resolved here.
        //

        return FALSE;
    }

    switch (Status) {
    case STATUS_CRC_ERROR:
    case STATUS_DEVICE_DATA_ERROR:
        return FALSE;
    default:
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\filtrctx.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    FiltrCtx.c

Abstract:

    This module provides three routines that allow filesystem filter drivers
    to associate state with FILE_OBJECTs -- for filesystems which support
    an extended FSRTL_COMMON_HEADER with FsContext.

    These routines depend on fields (FastMutext and FilterContexts)
    added at the end of FSRTL_COMMON_HEADER in NT 5.0.

    Filesystems should set FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS if
    these new fields are supported.  They must also initialize the mutex
    and list head.

    Filter drivers must use a common header for the context they wish to
    associate with a file object:

        FSRTL_FILTER_CONTEXT:
                LIST_ENTRY  Links;
                PVOID       OwnerId;
                PVOID       InstanceId;

    The OwnerId is a bit pattern unique to each filter driver
    (e.g. the device object).

    The InstanceId is used to specify a particular instance of the context
    data owned by a filter driver (e.g. the file object).

Author:

    Dave Probert      [DavePr]    30-May-1997

Revision History:

    Neal Christiansen [nealch]    12-Jan-2001   Changed APIs to take 
                                                PFSRTL_ADVANCED_FCB_HEADER
                                                structures instead of
                                                FileObjects.

    Neal Christiansen [nealch]    19-Jan-2001   Added mutex lock to FsRtlTeardownFilterContexts
                                                because you can get filters
                                                trying to delete at the same 
                                                time the file system is trying
                                                to delete.

    Neal Christiansen [nealch]    25-Apr-2001   Added FileObject context routines
    Neal Christiansen [nealch]    25-Apr-2001   Marked all of this code as pageable
--*/

#include "FsRtlP.h"

#define MySearchList(pHdr, Ptr) \
    for ( Ptr = (pHdr)->Flink;  Ptr != (pHdr);  Ptr = Ptr->Flink )


//
//  The rest of the routines are not marked pageable so they can be called
//  during the paging path
//

NTKERNELAPI
VOID
FsRtlTeardownFilterContexts (
  IN PFSRTL_ADVANCED_FCB_HEADER AdvFcbHeader
  );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlTeardownPerStreamContexts)
#pragma alloc_text(PAGE, FsRtlTeardownFilterContexts)
#pragma alloc_text(PAGE, FsRtlPTeardownPerFileObjectContexts)
#endif


//===========================================================================
//                  Handles Stream Contexts
//===========================================================================

NTKERNELAPI
NTSTATUS
FsRtlInsertPerStreamContext (
  IN PFSRTL_ADVANCED_FCB_HEADER AdvFcbHeader,
  IN PFSRTL_PER_STREAM_CONTEXT Ptr
  )
/*++

Routine Description:

    This routine associates filter driver context with a stream.

Arguments:

    AdvFcbHeader - Advanced FCB Header for stream of interest.

    Ptr - Pointer to the filter-specific context structure.
        The common header fields OwnerId and InstanceId should
        be filled in by the filter driver before calling.

Return Value:

    STATUS_SUCCESS - operation succeeded.

    STATUS_INVALID_DEVICE_REQUEST - underlying filesystem does not support
        filter contexts.

--*/

{
    if (!AdvFcbHeader || 
        !FlagOn(AdvFcbHeader->Flags2,FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS))
    {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ExAcquireFastMutex(AdvFcbHeader->FastMutex);

    InsertHeadList(&AdvFcbHeader->FilterContexts, &Ptr->Links);

    ExReleaseFastMutex(AdvFcbHeader->FastMutex);
    return STATUS_SUCCESS;
}


NTKERNELAPI
PFSRTL_PER_STREAM_CONTEXT
FsRtlLookupPerStreamContextInternal (
  IN PFSRTL_ADVANCED_FCB_HEADER AdvFcbHeader,
  IN PVOID         OwnerId     OPTIONAL,
  IN PVOID         InstanceId  OPTIONAL
  )
/*++

Routine Description:

    This routine lookups filter driver context associated with a stream.

    The macro FsRtlLookupFilterContext should be used instead of calling
    this routine directly.  The macro optimizes for the common case
    of an empty list.

Arguments:

    AdvFcbHeader - Advanced FCB Header for stream of interest.

    OwnerId - Used to identify context information belonging to a particular
        filter driver.

    InstanceId - Used to search for a particular instance of a filter driver
        context.  If not provided, any of the contexts owned by the filter
        driver is returned.

    If neither the OwnerId nor the InstanceId is provided, any associated
    filter context will be returned.

Return Value:

    A pointer to the filter context, or NULL if no match found.

--*/

{
    PFSRTL_PER_STREAM_CONTEXT ctx;
    PFSRTL_PER_STREAM_CONTEXT rtnCtx;
    PLIST_ENTRY list;

    ASSERT(AdvFcbHeader);
    ASSERT(FlagOn(AdvFcbHeader->Flags2,FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS));

    ExAcquireFastMutex(AdvFcbHeader->FastMutex);
    rtnCtx = NULL;

    //
    // Use different loops depending on whether we are comparing both Ids or not.
    //

    if ( ARGUMENT_PRESENT(InstanceId) ) {

        MySearchList (&AdvFcbHeader->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_STREAM_CONTEXT, Links);
            if (ctx->OwnerId == OwnerId && ctx->InstanceId == InstanceId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if ( ARGUMENT_PRESENT(OwnerId) ) {

        MySearchList (&AdvFcbHeader->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_STREAM_CONTEXT, Links);
            if (ctx->OwnerId == OwnerId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if (!IsListEmpty(&AdvFcbHeader->FilterContexts)) {

        rtnCtx = (PFSRTL_PER_STREAM_CONTEXT)AdvFcbHeader->FilterContexts.Flink;
    }

    ExReleaseFastMutex(AdvFcbHeader->FastMutex);
    return rtnCtx;
}


NTKERNELAPI
PFSRTL_PER_STREAM_CONTEXT
FsRtlRemovePerStreamContext (
  IN PFSRTL_ADVANCED_FCB_HEADER AdvFcbHeader,
  IN PVOID         OwnerId     OPTIONAL,
  IN PVOID         InstanceId  OPTIONAL
  )
/*++

Routine Description:

    This routine deletes filter driver context associated with a stream.

    FsRtlRemoveFilterContext functions identically to FsRtlLookupFilterContext,
    except that the returned context has been removed from the list.

Arguments:

    AdvFcbHeader - Advanced FCB Header for stream of interest.

    OwnerId - Used to identify context information belonging to a particular
        filter driver.

    InstanceId - Used to search for a particular instance of a filter driver
        context.  If not provided, any of the contexts owned by the filter
        driver is removed and returned.

    If neither the OwnerId nor the InstanceId is provided, any associated
    filter context will be removed and returned.

Return Value:

    A pointer to the filter context, or NULL if no match found.

--*/

{
    PFSRTL_PER_STREAM_CONTEXT ctx;
    PFSRTL_PER_STREAM_CONTEXT rtnCtx;
    PLIST_ENTRY list;

    if (!AdvFcbHeader ||
        !FlagOn(AdvFcbHeader->Flags2,FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS))
    {

        return NULL;
    }

    ExAcquireFastMutex(AdvFcbHeader->FastMutex);
    rtnCtx = NULL;

  // Use different loops depending on whether we are comparing both Ids or not.
    if ( ARGUMENT_PRESENT(InstanceId) ) {

        MySearchList (&AdvFcbHeader->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_STREAM_CONTEXT, Links);
            if (ctx->OwnerId == OwnerId && ctx->InstanceId == InstanceId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if ( ARGUMENT_PRESENT(OwnerId) ) {

        MySearchList (&AdvFcbHeader->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_STREAM_CONTEXT, Links);
            if (ctx->OwnerId == OwnerId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if (!IsListEmpty(&AdvFcbHeader->FilterContexts)) {

        rtnCtx = (PFSRTL_PER_STREAM_CONTEXT)AdvFcbHeader->FilterContexts.Flink;
    }

    if (rtnCtx) {
        RemoveEntryList(&rtnCtx->Links);   // remove the matched entry
    }

    ExReleaseFastMutex(AdvFcbHeader->FastMutex);
    return rtnCtx;
}


NTKERNELAPI
VOID
FsRtlTeardownPerStreamContexts (
  IN PFSRTL_ADVANCED_FCB_HEADER AdvFcbHeader
  )
/*++

Routine Description:

    This routine is called by filesystems to free the filter contexts
    associated with an FSRTL_COMMON_FCB_HEADER by calling the FreeCallback
    routine for each FilterContext.

Arguments:

    FilterContexts - the address of the FilterContexts field within
        the FSRTL_COMMON_FCB_HEADER of the structure being torn down
        by the filesystem.

Return Value:

    None.

--*/

{
    PFSRTL_PER_STREAM_CONTEXT ctx;
    PLIST_ENTRY ptr;
    BOOLEAN lockHeld;

    //
    //  Acquire the lock because someone could be trying to free this
    //  entry while we are trying to free it.
    //

    ExAcquireFastMutex( AdvFcbHeader->FastMutex );
    lockHeld = TRUE;

    try {

        while (!IsListEmpty( &AdvFcbHeader->FilterContexts )) {

            //
            //  Unlink the top entry then release the lock.  We must
            //  release the lock before calling the use or their could
            //  be potential locking order deadlocks.
            //

            ptr = RemoveHeadList( &AdvFcbHeader->FilterContexts );

            ExReleaseFastMutex(AdvFcbHeader->FastMutex);
            lockHeld = FALSE;

            //
            //  Call filter to free this entry
            //

            ctx = CONTAINING_RECORD( ptr, FSRTL_PER_STREAM_CONTEXT, Links );
            ASSERT(ctx->FreeCallback);

            (*ctx->FreeCallback)( ctx );

            //
            //  re-get the lock
            //

            ExAcquireFastMutex( AdvFcbHeader->FastMutex );
            lockHeld = TRUE;
        }

    } finally {

        if (lockHeld) {

            ExReleaseFastMutex( AdvFcbHeader->FastMutex );
        }
    }
}


//===========================================================================
//                  Handles FileObject Contexts
//===========================================================================

//
//  Internal structure used to manage the Per FileObject Contexts.
//

typedef struct _PER_FILEOBJECT_CTXCTRL {

    //
    //  This is a pointer to a Fast Mutex which may be used to
    //  properly synchronize access to the FsRtl header.  The
    //  Fast Mutex must be nonpaged.
    //

    FAST_MUTEX FastMutex;

    //
    // This is a pointer to a list of context structures belonging to
    // filesystem filter drivers that are linked above the filesystem.
    // Each structure is headed by FSRTL_FILTER_CONTEXT.
    //

    LIST_ENTRY FilterContexts;

} PER_FILEOBJECT_CTXCTRL, *PPER_FILEOBJECT_CTXCTRL;


NTKERNELAPI
NTSTATUS
FsRtlInsertPerFileObjectContext (
  IN PFILE_OBJECT FileObject,
  IN PFSRTL_PER_FILEOBJECT_CONTEXT Ptr
  )
/*++

Routine Description:

    This routine associates a context with a file object.

Arguments:

    FileObject - Specifies the file object of interest.

    Ptr - Pointer to the filter-specific context structure.
        The common header fields OwnerId and InstanceId should
        be filled in by the filter driver before calling.

Return Value:

    STATUS_SUCCESS - operation succeeded.

    STATUS_INVALID_DEVICE_REQUEST - underlying filesystem does not support
        filter contexts.

--*/

{
    PPER_FILEOBJECT_CTXCTRL ctxCtrl;
    NTSTATUS status;

    //
    //  Return if no file object
    //

    if (NULL == FileObject) {

        return STATUS_INVALID_PARAMETER;
    }

    if (!FsRtlSupportsPerFileObjectContexts(FileObject)) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Get the context control structure out of the file object extension
    //

    ctxCtrl = IoGetFileObjectFilterContext( FileObject );

    if (NULL == ctxCtrl) {

        //
        //  There is not a control structure, allocate and initialize one
        //

        ctxCtrl = ExAllocatePoolWithTag( NonPagedPool,
                                         sizeof(PER_FILEOBJECT_CTXCTRL),
                                         'XCOF' );
        if (NULL == ctxCtrl) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ExInitializeFastMutex( &ctxCtrl->FastMutex );
        InitializeListHead( &ctxCtrl->FilterContexts );

        //
        //  Insert into the file object extension
        //

        status = IoChangeFileObjectFilterContext( FileObject,
                                                  ctxCtrl,
                                                  TRUE );

        if (!NT_SUCCESS(status)) {

            //
            //  If this operation fails it is because someone else inserted the
            //  entry at the same time.  In this case free the memory we
            //  allocated and re-get the current value.
            //

            ExFreePool( ctxCtrl );

            ctxCtrl = IoGetFileObjectFilterContext( FileObject );

            if (NULL == ctxCtrl) {

                //
                //  This should never actually happen.  If it does it means
                //  someone allocated and then freed a context very quickly.
                //

                ASSERT(!"This operation should not have failed");
                return STATUS_UNSUCCESSFUL;
            }
        }
    }

    ExAcquireFastMutex( &ctxCtrl->FastMutex );

    InsertHeadList( &ctxCtrl->FilterContexts, &Ptr->Links );

    ExReleaseFastMutex( &ctxCtrl->FastMutex );

    return STATUS_SUCCESS;
}


NTKERNELAPI
PFSRTL_PER_FILEOBJECT_CONTEXT
FsRtlLookupPerFileObjectContext (
  IN PFILE_OBJECT FileObject,
  IN PVOID OwnerId OPTIONAL,
  IN PVOID InstanceId OPTIONAL
  )
/*++

Routine Description:

    This routine lookups contexts associated with a file object.

Arguments:

    FileObject - Specifies the file object of interest.

    OwnerId - Used to identify context information belonging to a particular
        filter driver.

    InstanceId - Used to search for a particular instance of a filter driver
        context.  If not provided, any of the contexts owned by the filter
        driver is returned.

    If neither the OwnerId nor the InstanceId is provided, any associated
        filter context will be returned.

Return Value:

    A pointer to the filter context, or NULL if no match found.

--*/

{
    PPER_FILEOBJECT_CTXCTRL ctxCtrl;
    PFSRTL_PER_FILEOBJECT_CONTEXT ctx;
    PFSRTL_PER_FILEOBJECT_CONTEXT rtnCtx;
    PLIST_ENTRY list;

    //
    //  Return if no FileObjecty
    //

    if (NULL == FileObject) {

        return NULL;
    }

    //
    //  Get the context control structure out of the file object extension
    //

    ctxCtrl = IoGetFileObjectFilterContext( FileObject );

    if (NULL == ctxCtrl) {

        return NULL;
    }

    rtnCtx = NULL;
    ExAcquireFastMutex( &ctxCtrl->FastMutex );

    //
    //  Use different loops depending on whether we are comparing both Ids or not.
    //

    if ( ARGUMENT_PRESENT(InstanceId) ) {

        MySearchList (&ctxCtrl->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_FILEOBJECT_CONTEXT, Links);

            if ((ctx->OwnerId == OwnerId) && (ctx->InstanceId == InstanceId)) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if ( ARGUMENT_PRESENT(OwnerId) ) {

        MySearchList (&ctxCtrl->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_FILEOBJECT_CONTEXT, Links);

            if (ctx->OwnerId == OwnerId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if (!IsListEmpty(&ctxCtrl->FilterContexts)) {

        rtnCtx = (PFSRTL_PER_FILEOBJECT_CONTEXT) ctxCtrl->FilterContexts.Flink;
    }

    ExReleaseFastMutex(&ctxCtrl->FastMutex);

    return rtnCtx;
}


NTKERNELAPI
PFSRTL_PER_FILEOBJECT_CONTEXT
FsRtlRemovePerFileObjectContext (
  IN PFILE_OBJECT FileObject,
  IN PVOID OwnerId OPTIONAL,
  IN PVOID InstanceId OPTIONAL
  )
/*++

Routine Description:

    This routine deletes contexts associated with a file object

    Filter drivers must explicitly remove all context they associate with
    a file object (otherwise the underlying filesystem will BugCheck at close).
    This should be done at IRP_CLOSE time.

    FsRtlRemoveFilterContext functions identically to FsRtlLookupFilterContext,
    except that the returned context has been removed from the list.

Arguments:

    FileObject - Specifies the file object of interest.

    OwnerId - Used to identify context information belonging to a particular
        filter driver.

    InstanceId - Used to search for a particular instance of a filter driver
        context.  If not provided, any of the contexts owned by the filter
        driver is removed and returned.

    If neither the OwnerId nor the InstanceId is provided, any associated
        filter context will be removed and returned.

Return Value:

    A pointer to the filter context, or NULL if no match found.

--*/

{
    PPER_FILEOBJECT_CTXCTRL ctxCtrl;
    PFSRTL_PER_FILEOBJECT_CONTEXT ctx;
    PFSRTL_PER_FILEOBJECT_CONTEXT rtnCtx;
    PLIST_ENTRY list;

    //
    //  Return if no file object
    //

    if (NULL == FileObject) {

        return NULL;
    }

    //
    //  Get the context control structure out of the file object extension
    //

    ctxCtrl = IoGetFileObjectFilterContext( FileObject );

    if (NULL == ctxCtrl) {

        return NULL;
    }

    rtnCtx = NULL;

    ExAcquireFastMutex( &ctxCtrl->FastMutex );

  // Use different loops depending on whether we are comparing both Ids or not.
    if ( ARGUMENT_PRESENT(InstanceId) ) {

        MySearchList (&ctxCtrl->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_FILEOBJECT_CONTEXT, Links);

            if ((ctx->OwnerId == OwnerId) && (ctx->InstanceId == InstanceId)) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if ( ARGUMENT_PRESENT(OwnerId) ) {

        MySearchList (&ctxCtrl->FilterContexts, list) {

            ctx  = CONTAINING_RECORD(list, FSRTL_PER_FILEOBJECT_CONTEXT, Links);

            if (ctx->OwnerId == OwnerId) {

                rtnCtx = ctx;
                break;
            }
        }

    } else if (!IsListEmpty(&ctxCtrl->FilterContexts)) {

        rtnCtx = (PFSRTL_PER_FILEOBJECT_CONTEXT)ctxCtrl->FilterContexts.Flink;
    }

    if (rtnCtx) {

        RemoveEntryList(&rtnCtx->Links);   // remove the matched entry
    }

    ExReleaseFastMutex( &ctxCtrl->FastMutex );
    return rtnCtx;
}


VOID
FsRtlPTeardownPerFileObjectContexts (
  IN PFILE_OBJECT FileObject
  )
/*++

Routine Description:

    This routine is called by filesystems to free the filter contexts
    associated with an FSRTL_COMMON_FCB_HEADER by calling the FreeCallback
    routine for each FilterContext.

Arguments:

    FilterContexts - the address of the FilterContexts field within
        the FSRTL_COMMON_FCB_HEADER of the structure being torn down
        by the filesystem.

Return Value:

    None.

--*/

{
    PPER_FILEOBJECT_CTXCTRL ctxCtrl;
    NTSTATUS status;

    ASSERT(FileObject != NULL);

    ctxCtrl = IoGetFileObjectFilterContext( FileObject );

    if (NULL != ctxCtrl) {

        status = IoChangeFileObjectFilterContext( FileObject,
                                                  ctxCtrl,
                                                  FALSE );

        ASSERT(STATUS_SUCCESS == status);
        ASSERT(IsListEmpty( &ctxCtrl->FilterContexts));

        ExFreePool( ctxCtrl );
    }
}


LOGICAL
FsRtlIsPagingFile (
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine will return TRUE if the give file object is for a
    paging file.  It returns FALSE otherwise

Arguments:

    FileObject - The file object to test

Return Value:

    TRUE - if paging file
    FALSE - if not

--*/

{
    return MmIsFileObjectAPagingFile( FileObject );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\faulttol.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    FaultTol.c

Abstract:

    The routines in this module help the file systems perform fault
    tolerance operation to the FT device drivers.

Author:

    David Goebel    [DavidGoe]  30-Mar-1993

Revision History:

--*/

#include "FsRtlP.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlBalanceReads)
#pragma alloc_text(PAGE, FsRtlSyncVolumes)
#endif


NTSTATUS
FsRtlBalanceReads (
    IN PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine signals a device driver that it is now OK to start
    balancing reads from a mirrored drive.  This is typically called
    after the file system determines that a volume is clean.

Arguments:

    TargetDevice - Supplies the device to start balanced read from.

Return Value:

    NTSTATUS - The result of the operation.  This will be
        STATUS_INVALID_DEVICE_REQUEST is the volume is not a mirror.

--*/

{
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( FT_BALANCED_READ_MODE,
                                         TargetDevice,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         &Event,
                                         &Iosb );

    if ( Irp == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = IoCallDriver( TargetDevice, Irp );


    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL );

        ASSERT( Status == STATUS_SUCCESS );

        Status = Iosb.Status;
    }

    return Status;
}

NTSTATUS
FsRtlSyncVolumes (
    IN PDEVICE_OBJECT TargetDevice,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PLARGE_INTEGER ByteCount
    )

/*++

Routine Description:

    This routine signals a device driver that it must sync redundant
    members of a mirror from the primary member.  This is typically
    called after the file system determines that a volume is dirty.

Arguments:

    TargetDevice - Supplies the device to sync.

    ByteOffset - If specified, gives the location to start syncing

    ByteCount - Gives the byte count to sync.  Ignored if StartingOffset
        not specified.

Return Value:

    NTSTATUS - The result of the operation.  This will be
        STATUS_INVALID_DEVICE_REQUEST is the volume is not a mirror.

--*/

{

#if 0  // Mike Glass says we no longer need to do this.  3/3/94

    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;
    BOOLEAN RangeSpecified;
    FT_SYNC_INFORMATION SyncInfo;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  If the user specified a range, capture it.
    //

    if (ARGUMENT_PRESENT(ByteOffset)) {

        SyncInfo.ByteOffset = *ByteOffset;
        SyncInfo.ByteCount = *ByteCount;

        RangeSpecified = TRUE;

    } else {

        RangeSpecified = FALSE;
    }

    Irp = IoBuildDeviceIoControlRequest( FT_SYNC_REDUNDANT_COPY,
                                         TargetDevice,
                                         RangeSpecified ? &SyncInfo : NULL,
                                         RangeSpecified ?
                                         sizeof(FT_SYNC_INFORMATION) : 0,
                                         NULL,
                                         0,
                                         FALSE,
                                         &Event,
                                         &Iosb );

    if ( Irp == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = IoCallDriver( TargetDevice, Irp );


    if (Status == STATUS_PENDING) {
        Status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL );

        ASSERT( Status == STATUS_SUCCESS );

        Status = Iosb.Status;
    }

    return Status;
#else
    return STATUS_SUCCESS;

#endif //0
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\filelock.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FileLock.c

Abstract:

    The file lock package provides a set of routines that allow the
    caller to handle byte range file lock requests.  A variable of
    type FILE_LOCK is needed for every file with byte range locking.
    The package provides routines to set and clear locks, and to
    test for read or write access to a file with byte range locks.

    The main idea of the package is to have the file system initialize
    a FILE_LOCK variable for every data file as its opened, and then
    to simply call a file lock processing routine to handle all IRP's
    with a major function code of LOCK_CONTROL.  The package is responsible
    for keeping track of locks and for completing the LOCK_CONTROL IRPS.
    When processing a read or write request the file system can then call
    two query routines to check for access.

    Most of the code for processing IRPS and checking for access use
    paged pool and can encounter a page fault, therefore the check routines
    cannot be called at DPC level.  To help servers that do call the file
    system to do read/write operations at DPC level there is a additional
    routine that simply checks for the existence of a lock on a file and
    can be run at DPC level.

    Concurrent access to the FILE_LOCK variable must be controlled by the
    caller.

    The functions provided in this package are as follows:

      o  FsRtlInitializeFileLock - Initialize a new FILE_LOCK structure.

      o  FsRtlUninitializeFileLock - Uninitialize an existing FILE_LOCK
         structure.

      o  FsRtlProcessFileLock - Process an IRP whose major function code
         is LOCK_CONTROL.

      o  FsRtlCheckLockForReadAccess - Check for read access to a range
         of bytes in a file given an IRP.

      o  FsRtlCheckLockForWriteAccess - Check for write access to a range
         of bytes in a file given an IRP.

      o  FsRtlAreThereCurrentFileLocks - Check if there are any locks
         currently assigned to a file.

      o  FsRtlGetNextFileLock - This procedure enumerates the current locks
         of a file lock variable.

      o  FsRtlFastCheckLockForRead - Check for read access to a range of
         bytes in a file given separate parameters.

      o  FsRtlFastCheckLockForWrite - Check for write access to a range of
         bytes in a file given separate parameters.

      o  FsRtlFastLock - A fast non-Irp based way to get a lock

      o  FsRtlFastUnlockSingle - A fast non-Irp based way to release a single
         lock

      o  FsRtlFastUnlockAll - A fast non-Irp based way to release all locks
         held by a file object.

      o  FsRtlFastUnlockAllByKey - A fast non-Irp based way to release all
         locks held by a file object that match a key.


Authors:

    Gary Kimura     [GaryKi]    24-Apr-1990
    Dan Lovinger    [DanLo]     22-Sep-1995

Revision History:

--*/

#include "FsRtlP.h"

//
//  Local constants
//

//
//  Local debug trace level
//

#define Dbg                 (0x20000000)

//
//  YA definition of INLINE
//

#ifndef INLINE
#define INLINE __inline
#endif

#define TAG_EXCLUSIVE_LOCK  'xeLF'
#define TAG_FILE_LOCK       'lfLF'
#define TAG_LOCK_INFO       'ilLF'
#define TAG_LOCKTREE_NODE   'nlLF'
#define TAG_SHARED_LOCK     'hsLF'
#define TAG_WAITING_LOCK    'lwLF'

//
//  Globals
//

//
//  This mutex synchronizes threads competing to initialize file lock structures.
//

FAST_MUTEX FsRtlCreateLockInfo;

//
//  This spinlock resolves the race between teardown of a file's lock info and
//  cancellation of waiting locks for that file.  We must always be able to save
//  a cancelled IRP for the cancelling thread.
//

KSPIN_LOCK FsRtlFileLockCancelCollideLock;

SINGLE_LIST_ENTRY FsRtlFileLockCancelCollideList;

//
//  Lookaside lists
//
//  Here is a good place to note why this is still nonpaged.  We need to be able
//  to cancel lock IRPs at DPC, and the ripple effects of this (esp. granting waiting
//  locks and synchronizing the waiting list) implies some unfortunate realities.
//
//  This should be reinvestigated post NT 5.0.
//

NPAGED_LOOKASIDE_LIST FsRtlSharedLockLookasideList;
NPAGED_LOOKASIDE_LIST FsRtlExclusiveLockLookasideList;
NPAGED_LOOKASIDE_LIST FsRtlWaitingLockLookasideList;
NPAGED_LOOKASIDE_LIST FsRtlLockTreeNodeLookasideList;
NPAGED_LOOKASIDE_LIST FsRtlLockInfoLookasideList;

PAGED_LOOKASIDE_LIST FsRtlFileLockLookasideList;


//
//  Local structures
//

/*++

    Some of the decisions made regarding the internal datastructres may not be clear,
    so I should discuss the evolution of this design.

    The original file lock implementation was a single linked list, extended in the MP
    case to a set of linked lists which each held locks in page-aligned segments of the
    file. If locks spilled over these page-aligned segments the code fell back to the
    UP single linked list. There are clearly peformance implications with substantial
    usage of file locks, since these are mandatory locks.

    This implementation goes for O(lgn) search performance by using splay trees. In order to
    apply simple trees to this problem no node of the tree can overlap, so since shared
    locks can in fact overlap something must be done. The solution used here is to have
    a meta-structure contain all locks which do overlap and have the tree operations
    split and merge these nodes of (potentially) multiple locks. This is the LOCKTREE_NODE.
    It should be noted that the worst case add/delete lock times are still linear.

    Exclusive locks pose a problem because of an asymmetry in the semantics of applying
    locks to a file. If a process applies a shared lock to a section of a file, no application
    of an exclusive lock to bytes in that section can succeed. However, if a process
    applies an exclusive lock, that same process can get a shared lock as well. This
    behavior conflicts with the mergeable node since by applying locks in a given order
    we can get a node to have many shared locks and "rogue" exclusive locks which are
    hidden except to a linear search, which is what we're designing out. So exclusive locks
    must be seperated from the shared locks. This is the reason we have two lock trees.

    Since we have two lock trees, the average case search is now O(lgm + lgn) for m exlcusive
    and n shared. Also, since no exclusive locks can ever overlap each other it is now
    unreasonable to have them use LOCKTREE_NODES - this would impose a memory penalty on code
    which was weighted toward exclusive locks. This means that the exclusive locks should
    be wired into the splay tree directly. So we need an RTL_SPLAY_LINKS, but this is 64 bits
    bigger than the SINGLE_LIST_ENTRY which shared locks need (to be threaded off of a
    LOCKTREE_NODE), which dictates seperate shared and exclusive lock structures to avoid
    penalizing code which was weighted toward shared locks by having that wasted 64 bits per
    lock. Hence EX_LOCK and SH_LOCK (they actually occupy different pool block sizes).

    Zero length locks are a bizzare creation, and there is some errata relating to them. It
    used to be the case that zero length locks would be granted without exception. This is
    flat out bogus, and has been changed (NT 4.0). They are now subject to failure if they
    occupy a point interior to a lock of a type that can cause an access failure. A particular
    case that was previously allowed was a zero length exclusive lock interior to another
    exclusive lock.

    Zero length locks cannot conflict with zero length locks. This is the subject of some
    special code throughout the module. Note especially that zero length exclusive locks can
    "overlap". Zero length locks also cannot conflict at the starting byte and ending byte of a
    range - they are points on the line.

--*/

typedef struct _LOCKTREE_NODE {

    //
    //  List of locks under this node
    //

    SINGLE_LIST_ENTRY Locks;

    //
    //  Flag whether this node is holey as a result of a failed allocation
    //  during a node split.  During deletion of shared locks, we may
    //  discover that the locks in the node no longer have total overlap
    //  but cannot allocate resources to create the new nodes in the tree.
    //
    //  Any insert into the region occupied by a holey node will finish by
    //  trying to split a holey node up.  Any split or access check in a
    //  holey node must completely traverse the locks at the node.
    //

    BOOLEAN HoleyNode;

    //
    //  Maximum byte offset affected by locks in this node.
    //  Note: minimum offset is the starting offset of the
    //  first lock at this node.
    //

    ULONGLONG Extent;

    //
    //  Splay tree links to parent, lock groups strictly less than
    //  and lock groups strictly greater than locks in this node.
    //

    RTL_SPLAY_LINKS Links;

    //
    //  Last lock in the list (useful for node collapse under insert)
    //

    SINGLE_LIST_ENTRY Tail;

} LOCKTREE_NODE, *PLOCKTREE_NODE;

//
//  Define the threading wrappers for lock information
//

//
//  Each shared lock record corresponds to a current granted lock and is
//  maintained in a queue off of a LOCKTREE_NODE's Locks list.  The list
//  of current locks is ordered according to the starting byte of the lock.
//

typedef struct _SH_LOCK {

    //
    //  The link structures for the list of shared locks.
    //

    SINGLE_LIST_ENTRY   Link;

    //
    //  The actual locked range
    //

    FILE_LOCK_INFO LockInfo;

} SH_LOCK, *PSH_LOCK;

//
//  Each exclusive lock record corresponds to a current granted lock and is
//  threaded into the exclusive lock tree.
//

typedef struct _EX_LOCK {

    //
    //  The link structures for the list of current locks.
    //

    RTL_SPLAY_LINKS     Links;

    //
    //  The actual locked range
    //

    FILE_LOCK_INFO LockInfo;

} EX_LOCK, *PEX_LOCK;

//
//  Each Waiting lock record corresponds to a IRP that is waiting for a
//  lock to be granted and is maintained in a queue off of the FILE_LOCK's
//  WaitingLockQueue list.
//

typedef struct _WAITING_LOCK {

    //
    //  The link structures for the list of waiting locks
    //

    SINGLE_LIST_ENTRY   Link;

    //
    //  The optional procedure to call to complete a request.  We require this
    //  in the individual waiters so that we can heal the race between cancellation
    //  and teardown of a lock structure.
    //

    PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;

    //
    //  The context field to use when completing the irp via the alternate
    //  routine
    //

    PVOID Context;

    //
    //  A pointer to the IRP that is waiting for a lock
    //

    PIRP Irp;

} WAITING_LOCK, *PWAITING_LOCK;


//
//  Each lock or waiting onto some lock queue.
//

typedef struct _LOCK_QUEUE {

    //
    // Sync to guard queue access.
    //

    KSPIN_LOCK  QueueSpinLock;

    //
    //  The items contain locktrees of the current granted
    //  locks and a list of the waiting locks
    //

    PRTL_SPLAY_LINKS SharedLockTree;
    PRTL_SPLAY_LINKS ExclusiveLockTree;
    SINGLE_LIST_ENTRY WaitingLocks;
    SINGLE_LIST_ENTRY WaitingLocksTail;

} LOCK_QUEUE, *PLOCK_QUEUE;


//
//  Any file_lock which has had a lock applied gets a non-paged pool
//  structure which tracks the current locks applied to the file
//

typedef struct _LOCK_INFO {

    //
    //  LowestLockOffset retains the offset of the lowest existing
    //  lock.  This facilitates a quick check to see if a read or
    //  write can proceed without locking the lock database.  This is
    //  helpful for applications that use mirrored locks -- all locks
    //  are higher than file data.
    //
    //  If the lowest lock has an offset > 0xffffffff, LowestLockOffset
    //  is set to 0xffffffff.
    //

    ULONG LowestLockOffset;

    //
    //  The optional procedure to call to complete a request
    //

    PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;

    //
    //  The optional procedure to call when unlocking a byte range
    //

    PUNLOCK_ROUTINE UnlockRoutine;

    //
    // The locked ranges
    //

    LOCK_QUEUE  LockQueue;

} LOCK_INFO, *PLOCK_INFO;

//
//  Local Macros
//

//
//  The following macros sort out the allocation of internal structures.
//

INLINE
PSH_LOCK
FsRtlAllocateSharedLock (
    VOID
    )
{
    return (PSH_LOCK) ExAllocateFromNPagedLookasideList( &FsRtlSharedLockLookasideList );
}

INLINE
PEX_LOCK
FsRtlAllocateExclusiveLock (
    VOID
    )
{
    return (PEX_LOCK) ExAllocateFromNPagedLookasideList( &FsRtlExclusiveLockLookasideList );
}

INLINE
PWAITING_LOCK
FsRtlAllocateWaitingLock (
    VOID
    )
{
    return (PWAITING_LOCK) ExAllocateFromNPagedLookasideList( &FsRtlWaitingLockLookasideList );
}

INLINE
PLOCKTREE_NODE
FsRtlAllocateLockTreeNode (
    VOID
    )
{
    return (PLOCKTREE_NODE) ExAllocateFromNPagedLookasideList( &FsRtlLockTreeNodeLookasideList );
}

INLINE
PLOCK_INFO
FsRtlAllocateLockInfo (
    VOID
    )
{
    return (PLOCK_INFO) ExAllocateFromNPagedLookasideList( &FsRtlLockInfoLookasideList );
}


INLINE
VOID
FsRtlFreeSharedLock (
    IN PSH_LOCK C
    )
{
    ExFreeToNPagedLookasideList( &FsRtlSharedLockLookasideList, (PVOID)C );
}

INLINE
VOID
FsRtlFreeExclusiveLock (
    IN PEX_LOCK C
    )
{
    ExFreeToNPagedLookasideList( &FsRtlExclusiveLockLookasideList, (PVOID)C );
}

INLINE
VOID
FsRtlFreeWaitingLock (
    IN PWAITING_LOCK C
    )
{
    ExFreeToNPagedLookasideList( &FsRtlWaitingLockLookasideList, (PVOID)C );
}

INLINE
VOID
FsRtlFreeLockTreeNode (
    IN PLOCKTREE_NODE C
    )
{
    ExFreeToNPagedLookasideList( &FsRtlLockTreeNodeLookasideList, (PVOID)C );
}

INLINE
VOID
FsRtlFreeLockInfo (
    IN PLOCK_INFO C
    )
{
    ExFreeToNPagedLookasideList( &FsRtlLockInfoLookasideList, (PVOID)C );
}

#define FsRtlAcquireLockQueue(a,b)          ExAcquireSpinLock(&(a)->QueueSpinLock, b)
#define FsRtlReleaseLockQueue(a,b)          ExReleaseSpinLock(&(a)->QueueSpinLock, b)
#define FsRtlAcquireLockQueueAtDpc(a)       ExAcquireSpinLockAtDpcLevel(&(a)->QueueSpinLock)
#define FsRtlReleaseLockQueueFromDpc(a)     ExReleaseSpinLockFromDpcLevel(&(a)->QueueSpinLock)

#define FsRtlAcquireCancelCollide(a)        ExAcquireSpinLock(&FsRtlFileLockCancelCollideLock, a)
#define FsRtlReleaseCancelCollide(a)        ExReleaseSpinLock(&FsRtlFileLockCancelCollideLock, a)
#define FsRtlAcquireCancelCollideAtDpc(a)   ExAcquireSpinLockAtDpcLevel(&FsRtlFileLockCancelCollideLock)
#define FsRtlReleaseCancelCollideFromDpc(a) ExReleaseSpinLockFromDpcLevel(&FsRtlFileLockCancelCollideLock)

//
//  Generic way to complete a lock IRP.  We like to treat this as an overloaded
//  function so it can be used with LOCK_INFO, FILE_LOCK and WAITING_LOCK
//  structures, as appropriate using paged/nonpaged pool to discover the completion
//  routine.
//

#define FsRtlCompleteLockIrp( A, B, C, D, E, F )                \
        FsRtlCompleteLockIrpReal( (A)->CompleteLockIrpRoutine,  \
                                  B,                            \
                                  C,                            \
                                  D,                            \
                                  E,                            \
                                  F )

INLINE
VOID
FsRtlCompleteLockIrpReal (
    IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine,
    IN PVOID Context,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN PNTSTATUS NewStatus,
    IN PFILE_OBJECT FileObject
    )
{
    //
    //  This fools the compiler into generating the Status only once
    //  if it is calculated from an expression.
    //

    NTSTATUS LocalStatus = Status;

    if (CompleteLockIrpRoutine != NULL) {

        if (FileObject != NULL) {

            FileObject->LastLock = NULL;
        }

        Irp->IoStatus.Status = LocalStatus;
        *NewStatus = CompleteLockIrpRoutine( Context, Irp );

    } else {

        FsRtlCompleteRequest( Irp, LocalStatus );
        *NewStatus = LocalStatus;
    }
}

//
//  The following routines are private to this module
//

VOID
FsRtlSplitLocks (
    IN PLOCKTREE_NODE ParentNode,
    IN PSINGLE_LIST_ENTRY *pStartLink,
    IN PLARGE_INTEGER LastShadowedByte,
    IN PLARGE_INTEGER GlueOffset
    );

PRTL_SPLAY_LINKS
FsRtlFindFirstOverlappingSharedNode (
    IN PRTL_SPLAY_LINKS        Tree,
    IN PLARGE_INTEGER          StartingByte,
    IN PLARGE_INTEGER          EndingByte,
    IN OUT PRTL_SPLAY_LINKS    *LastEdgeNode,
    IN OUT PBOOLEAN            GreaterThan
    );

PRTL_SPLAY_LINKS
FsRtlFindFirstOverlappingExclusiveNode (
    IN PRTL_SPLAY_LINKS        Tree,
    IN PLARGE_INTEGER          StartingByte,
    IN PLARGE_INTEGER          EndingByte,
    IN OUT PRTL_SPLAY_LINKS    *LastEdgeNode,
    IN OUT PBOOLEAN            GreaterThan
    );

PSH_LOCK
FsRtlFindFirstOverlapInNode (
    IN PLOCKTREE_NODE Node,
    IN PLARGE_INTEGER StartingByte,
    IN PLARGE_INTEGER EndingByte
    );

BOOLEAN
FsRtlPrivateInsertLock (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN PFILE_LOCK_INFO FileLockInfo
    );

BOOLEAN
FsRtlPrivateInsertSharedLock (
    IN PLOCK_QUEUE LockQueue,
    IN PSH_LOCK NewLock
    );

VOID
FsRtlPrivateInsertExclusiveLock (
    IN PLOCK_QUEUE LockQueue,
    IN PEX_LOCK NewLock
    );

VOID
FsRtlPrivateCheckWaitingLocks (
    IN PLOCK_INFO   LockInfo,
    IN PLOCK_QUEUE  LockQueue,
    IN KIRQL        OldIrql
    );

VOID
FsRtlPrivateCancelFileLockIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
FsRtlPrivateCheckForExclusiveLockAccess (
    IN PLOCK_QUEUE LockInfo,
    IN PFILE_LOCK_INFO FileLockInfo
    );

BOOLEAN
FsRtlPrivateCheckForSharedLockAccess (
    IN PLOCK_QUEUE LockInfo,
    IN PFILE_LOCK_INFO FileLockInfo
    );

NTSTATUS
FsRtlPrivateFastUnlockAll (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN MatchKey,
    IN PVOID Context OPTIONAL
    );

BOOLEAN
FsRtlPrivateInitializeFileLock (
    IN PFILE_LOCK   FileLock,
    IN BOOLEAN ViaFastCall
    );

VOID
FsRtlPrivateRemoveLock (
    IN PLOCK_INFO LockInfo,
    IN PFILE_LOCK_INFO,
    IN BOOLEAN CheckForWaiters
    );

BOOLEAN
FsRtlCheckNoSharedConflict (
   IN PLOCK_QUEUE LockQueue,
   IN PLARGE_INTEGER Starting,
   IN PLARGE_INTEGER Ending
   );

BOOLEAN
FsRtlCheckNoExclusiveConflict (
    IN PLOCK_QUEUE LockQueue,
    IN PLARGE_INTEGER Starting,
    IN PLARGE_INTEGER Ending,
    IN ULONG Key,
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId
    );

VOID
FsRtlPrivateResetLowestLockOffset (
    PLOCK_INFO LockInfo
    );

NTSTATUS
FsRtlFastUnlockSingleShared (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN LARGE_INTEGER UNALIGNED *FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL,
    IN BOOLEAN IgnoreUnlockRoutine,
    IN BOOLEAN CheckForWaiters
    );

NTSTATUS
FsRtlFastUnlockSingleExclusive (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN LARGE_INTEGER UNALIGNED *FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL,
    IN BOOLEAN IgnoreUnlockRoutine,
    IN BOOLEAN CheckForWaiters
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, FsRtlInitializeFileLocks)
#endif


VOID
FsRtlInitializeFileLocks (
    VOID
    )
/*++

Routine Description:

    Initializes the global portion of the filelock package.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    //  Build the lookaside lists for our internal structures.
    //

    ExInitializeNPagedLookasideList( &FsRtlSharedLockLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(SH_LOCK),
                                     TAG_SHARED_LOCK,
                                     16 );

    ExInitializeNPagedLookasideList( &FsRtlExclusiveLockLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(EX_LOCK),
                                     TAG_EXCLUSIVE_LOCK,
                                     16 );

    ExInitializeNPagedLookasideList( &FsRtlWaitingLockLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(WAITING_LOCK),
                                     TAG_WAITING_LOCK,
                                     16 );

    ExInitializeNPagedLookasideList( &FsRtlLockTreeNodeLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(LOCKTREE_NODE),
                                     TAG_LOCKTREE_NODE,
                                     16 );

    ExInitializeNPagedLookasideList( &FsRtlLockInfoLookasideList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof(LOCK_INFO),
                                     TAG_LOCK_INFO,
                                     8 );

    ExInitializePagedLookasideList( &FsRtlFileLockLookasideList,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(FILE_LOCK),
                                    TAG_FILE_LOCK,
                                    8 );

    //
    //  Initialize the LockInfo creation mutex
    //

    ExInitializeFastMutex(&FsRtlCreateLockInfo);

    //
    //  Initialize the cancel collision lock
    //

    KeInitializeSpinLock( &FsRtlFileLockCancelCollideLock );
    FsRtlFileLockCancelCollideList.Next = NULL;
}


VOID
FsRtlInitializeFileLock (
    IN PFILE_LOCK FileLock,
    IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine OPTIONAL,
    IN PUNLOCK_ROUTINE UnlockRoutine OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a new FILE_LOCK structure.  The caller must
    supply the memory for the structure.  This call must precede all other
    calls that utilize the FILE_LOCK variable.

Arguments:

    FileLock - Supplies a pointer to the FILE_LOCK structure to
        initialize.

    CompleteLockIrpRoutine - Optionally supplies an alternate routine to
        call for completing IRPs.  FsRtlProcessFileLock by default will
        call IoCompleteRequest to finish up an IRP; however if the caller
        want to process the completion itself then it needs to specify
        a completion routine here.  This routine will then be called in
        place of IoCompleteRequest.

    UnlockRoutine - Optionally supplies a routine to call when removing
        a lock.

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FsRtlInitializeFileLock, FileLock = %08lx\n", FileLock);

    //
    // Clear non-paged pool pointer
    //

    FileLock->LockInformation = NULL;
    FileLock->CompleteLockIrpRoutine = CompleteLockIrpRoutine;
    FileLock->UnlockRoutine = UnlockRoutine;

    FileLock->FastIoIsQuestionable = FALSE;

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlInitializeFileLock -> VOID\n", 0 );

    return;
}


BOOLEAN
FsRtlPrivateInitializeFileLock (
    IN PFILE_LOCK   FileLock,
    IN BOOLEAN ViaFastCall
    )
/*++

Routine Description:

    This routine initializes a new LOCK_INFO structure in non-paged
    pool for the FILE_LOCK.  This routines only occurs once for a given
    FILE_LOCK and it only occurs if any locks are applied to that file.

Arguments:

    FileLock - Supplies a pointer to the FILE_LOCK structure to
        initialize.

    ViaFastCall - Indicates if we are being invoked via a fast call or
        via the slow irp based method.

Return Value:

    TRUE - If LockInfo structure was allocated and initialized

--*/
{
    PLOCK_INFO  LockInfo;
    BOOLEAN     Results = FALSE;

    ExAcquireFastMutex( &FsRtlCreateLockInfo );

    try {

        if (FileLock->LockInformation != NULL) {

            //
            // Structure is already allocated, just return
            //

            try_return( Results = TRUE );
        }

        //
        //  Allocate pool for lock structures.  If we fail then we will either return false or
        //  raise based on if we know the caller has an try-except to handle a raise.
        //

        LockInfo = FsRtlAllocateLockInfo();

        if (LockInfo == NULL) {

            if (ViaFastCall) {

                try_return( Results = FALSE );

            } else {

                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }
        }

        //
        //  Allocate and initialize the waiting lock queue
        //  spinlock, and initialize the queues
        //

        LockInfo->LowestLockOffset = 0xffffffff;

        KeInitializeSpinLock( &LockInfo->LockQueue.QueueSpinLock );
        LockInfo->LockQueue.SharedLockTree = NULL;
        LockInfo->LockQueue.ExclusiveLockTree = NULL;
        LockInfo->LockQueue.WaitingLocks.Next = NULL;
        LockInfo->LockQueue.WaitingLocksTail.Next = NULL;

        //
        // Copy Irp & Unlock routines from pagable FileLock structure
        // to non-pagable LockInfo structure
        //

        LockInfo->CompleteLockIrpRoutine = FileLock->CompleteLockIrpRoutine;
        LockInfo->UnlockRoutine = FileLock->UnlockRoutine;

        //
        // Clear continuation info for enum routine
        //

        FileLock->LastReturnedLockInfo.FileObject = NULL;
        FileLock->LastReturnedLock = NULL;

        //
        // Link LockInfo into FileLock
        //

        FileLock->LockInformation = (PVOID) LockInfo;
        Results = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( &FsRtlCreateLockInfo );
    }

    return Results;
}


VOID
FsRtlUninitializeFileLock (
    IN PFILE_LOCK FileLock
    )

/*++

Routine Description:

    This routine uninitializes a FILE_LOCK structure.  After calling this
    routine the File lock must be reinitialized before being used again.

    This routine will free all files locks and completes any outstanding
    lock requests as a result of cleaning itself up.

Arguments:

    FileLock - Supplies a pointer to the FILE_LOCK struture being
        decommissioned.

Return Value:

    None.

--*/

{
    PLOCK_INFO          LockInfo;
    PSH_LOCK            ShLock;
    PEX_LOCK            ExLock;
    PSINGLE_LIST_ENTRY  Link;
    PWAITING_LOCK       WaitingLock;
    PLOCKTREE_NODE      LockTreeNode;
    PIRP                Irp;
    NTSTATUS            NewStatus;
    KIRQL               OldIrql;
    PKPRCB              Prcb;

    DebugTrace(+1, Dbg, "FsRtlUninitializeFileLock, FileLock = %08lx\n", FileLock);

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {
        return ;
    }

    //
    //  Lock vs. cancels and lock the queue.
    //

    FsRtlAcquireCancelCollide( &OldIrql );
    FsRtlAcquireLockQueueAtDpc( &LockInfo->LockQueue );

    //
    //  Free lock trees
    //

    while (LockInfo->LockQueue.SharedLockTree != NULL) {

        LockTreeNode = CONTAINING_RECORD(LockInfo->LockQueue.SharedLockTree, LOCKTREE_NODE, Links);

        //
        //  Remove all locks associated with the root node
        //

        while (LockTreeNode->Locks.Next != NULL) {
            Link = PopEntryList (&LockTreeNode->Locks);
            ShLock = CONTAINING_RECORD( Link, SH_LOCK, Link );

            FsRtlFreeSharedLock(ShLock);
        }

        //
        //  Slice off the root node of the tree
        //

        RtlDeleteNoSplay(&LockTreeNode->Links, &LockInfo->LockQueue.SharedLockTree);

        FsRtlFreeLockTreeNode(LockTreeNode);
    }

    while (LockInfo->LockQueue.ExclusiveLockTree != NULL) {

        ExLock = CONTAINING_RECORD(LockInfo->LockQueue.ExclusiveLockTree, EX_LOCK, Links);

        RtlDeleteNoSplay(&ExLock->Links, &LockInfo->LockQueue.ExclusiveLockTree);

        FsRtlFreeExclusiveLock(ExLock);
    }

    //
    //  Free WaitingLockQueue.
    //
    //  This will be incredibly rare, requiring a cancel to be pending in an async thread
    //  while cleanup/close occurs in the owning filesystem, triggering teardown.
    //

    while (LockInfo->LockQueue.WaitingLocks.Next != NULL) {

        Link = PopEntryList( &LockInfo->LockQueue.WaitingLocks );
        WaitingLock = CONTAINING_RECORD( Link, WAITING_LOCK, Link );

        Irp = WaitingLock->Irp;

        //
        //  To complete an irp in the waiting queue we need to
        //  void the cancel routine (protected by a spinlock so
        //  we can know that we beat cancellation) before
        //  we completing the irp.
        //

        FsRtlReleaseLockQueueFromDpc( &LockInfo->LockQueue );

        IoAcquireCancelSpinLock( &Irp->CancelIrql );
        IoSetCancelRoutine( Irp, NULL );
        
        //
        //  If it got cancelled, the cancel routine is now waiting on the other
        //  side of the cancel collide for us to push it onto the collide list.
        //  It'll get the IRP there as opposed to the shortly-to-be-axed lock
        //  structure.
        //
        
        if (Irp->Cancel) {
            
            IoReleaseCancelSpinLock( Irp->CancelIrql );
            PushEntryList( &FsRtlFileLockCancelCollideList,
                           &WaitingLock->Link );
            Irp = NULL;
        
        } else {
            
            IoReleaseCancelSpinLock( Irp->CancelIrql );
        }

        //
        //  If we got the ownership of the IRP, release the collide and complete
        //  it, otherwise spin back around for more.
        //
        
        if (Irp) {
            
            FsRtlReleaseCancelCollide( OldIrql );

            Irp->IoStatus.Information = 0;

            FsRtlCompleteLockIrp(
                 LockInfo,
                 WaitingLock->Context,
                 Irp,
                 STATUS_RANGE_NOT_LOCKED,
                 &NewStatus,
                 NULL );

            FsRtlFreeWaitingLock( WaitingLock );
            
            FsRtlAcquireCancelCollide( &OldIrql );
        }
        
        FsRtlAcquireLockQueueAtDpc( &LockInfo->LockQueue );
    }

    //
    // Release locks and free pool used to track the lock info on this file.
    //

    FsRtlReleaseLockQueueFromDpc( &LockInfo->LockQueue );
    FsRtlReleaseCancelCollide( OldIrql );
    FsRtlFreeLockInfo( LockInfo );

    //
    // Unlink LockInfo from FileLock
    //

    FileLock->LockInformation = NULL;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlUninitializeFileLock -> VOID\n", 0 );
    return;
}


PFILE_LOCK
FsRtlAllocateFileLock (
    IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine OPTIONAL,
    IN PUNLOCK_ROUTINE UnlockRoutine OPTIONAL

    )
{
    PFILE_LOCK FileLock;

    FileLock = ExAllocateFromPagedLookasideList( &FsRtlFileLockLookasideList );

    if (FileLock != NULL) {

        FsRtlInitializeFileLock( FileLock,
                                 CompleteLockIrpRoutine,
                                 UnlockRoutine );
    }

    return FileLock;
}

VOID
FsRtlFreeFileLock (
    IN PFILE_LOCK FileLock
    )
{
    FsRtlUninitializeFileLock( FileLock );

    ExFreeToPagedLookasideList( &FsRtlFileLockLookasideList, FileLock );
}


NTSTATUS
FsRtlProcessFileLock (
    IN PFILE_LOCK FileLock,
    IN PIRP Irp,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This routine processes a file lock IRP it does either a lock request,
    or an unlock request.  It also completes the IRP.  Once called the user
    (i.e., File System) has relinquished control of the input IRP.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

Arguments:

    FileLock - Supplies the File lock being modified/queried.

    Irp - Supplies the Irp being processed.

    Context - Optionally supplies a context to use when calling the user
        alternate IRP completion routine.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    IO_STATUS_BLOCK Iosb;
    NTSTATUS        Status;
    LARGE_INTEGER   ByteOffset;

    DebugTrace(+1, Dbg, "FsRtlProcessFileLock, FileLock = %08lx\n", FileLock);

    Iosb.Information = 0;

    //
    //  Get a pointer to the current Irp stack location and assert that
    //  the major function code is for a lock operation
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ASSERT( IrpSp->MajorFunction == IRP_MJ_LOCK_CONTROL );

    //
    //  Now process the different minor lock operations
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_LOCK:

        ByteOffset = IrpSp->Parameters.LockControl.ByteOffset;

        (VOID) FsRtlPrivateLock( FileLock,
                                 IrpSp->FileObject,
                                 &ByteOffset,
                                 IrpSp->Parameters.LockControl.Length,
                                 IoGetRequestorProcess(Irp),
                                 IrpSp->Parameters.LockControl.Key,
                                 BooleanFlagOn(IrpSp->Flags, SL_FAIL_IMMEDIATELY),
                                 BooleanFlagOn(IrpSp->Flags, SL_EXCLUSIVE_LOCK),
                                 &Iosb,
                                 Irp,
                                 Context,
                                 FALSE );

        break;

    case IRP_MN_UNLOCK_SINGLE:

        ByteOffset = IrpSp->Parameters.LockControl.ByteOffset;

        Iosb.Status = FsRtlFastUnlockSingle( FileLock,
                                             IrpSp->FileObject,
                                             &ByteOffset,
                                             IrpSp->Parameters.LockControl.Length,
                                             IoGetRequestorProcess(Irp),
                                             IrpSp->Parameters.LockControl.Key,
                                             Context,
                                             FALSE );

        FsRtlCompleteLockIrp( FileLock, Context, Irp, Iosb.Status, &Status, NULL );
        break;

    case IRP_MN_UNLOCK_ALL:

        Iosb.Status = FsRtlFastUnlockAll( FileLock,
                                          IrpSp->FileObject,
                                          IoGetRequestorProcess(Irp),
                                          Context );

        FsRtlCompleteLockIrp( FileLock, Context, Irp, Iosb.Status, &Status, NULL );
        break;

    case IRP_MN_UNLOCK_ALL_BY_KEY:

        Iosb.Status = FsRtlFastUnlockAllByKey( FileLock,
                                               IrpSp->FileObject,
                                               IoGetRequestorProcess(Irp),
                                               IrpSp->Parameters.LockControl.Key,
                                               Context );

        FsRtlCompleteLockIrp( FileLock, Context, Irp, Iosb.Status, &Status, NULL );
        break;

    default:

        //
        //  For all other minor function codes we say they're invalid and
        //  complete the request.  Note that the IRP has not been marked
        //  pending so this error will be returned directly to the caller.
        //

        DebugTrace(0, 1, "Invalid LockFile Minor Function Code %08lx\n", IrpSp->MinorFunction);


        FsRtlCompleteRequest( Irp, STATUS_INVALID_DEVICE_REQUEST );

        Iosb.Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlProcessFileLock -> %08lx\n", Iosb.Status);

    return Iosb.Status;
}


BOOLEAN
FsRtlCheckLockForReadAccess (
    IN PFILE_LOCK FileLock,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine checks to see if the caller has read access to the
    range indicated in the IRP due to file locks.  This call does not
    complete the Irp it only uses it to get the lock information and read
    information.  The IRP must be for a read operation.

Arguments:

    FileLock - Supplies the File Lock to check.

    Irp - Supplies the Irp being processed.

Return Value:

    BOOLEAN - TRUE if the indicated user/request has read access to the
        entire specified byte range, and FALSE otherwise

--*/

{
    BOOLEAN Result;

    PIO_STACK_LOCATION IrpSp;

    PLOCK_INFO     LockInfo;
    LARGE_INTEGER  StartingByte;
    LARGE_INTEGER  Length;
    ULONG          Key;
    PFILE_OBJECT   FileObject;
    PVOID          ProcessId;
    LARGE_INTEGER  BeyondLastByte;

    DebugTrace(+1, Dbg, "FsRtlCheckLockForReadAccess, FileLock = %08lx\n", FileLock);

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForReadAccess (No current lock info) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Do a really fast test to see if there are any exclusive locks to start with
    //

    if (LockInfo->LockQueue.ExclusiveLockTree == NULL) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForReadAccess (No current locks) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Get the read offset and compare it to the lowest existing lock.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    StartingByte  = IrpSp->Parameters.Read.ByteOffset;
    (ULONGLONG)Length.QuadPart = (ULONGLONG)IrpSp->Parameters.Read.Length;

    (ULONGLONG)BeyondLastByte.QuadPart = (ULONGLONG)StartingByte.QuadPart + Length.LowPart;
    if ( (ULONGLONG)BeyondLastByte.QuadPart <= (ULONGLONG)LockInfo->LowestLockOffset ) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForReadAccess (Below lowest lock) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Get remaining parameters.
    //

    Key           = IrpSp->Parameters.Read.Key;
    FileObject    = IrpSp->FileObject;
    ProcessId     = IoGetRequestorProcess( Irp );

    //
    //  Call our private work routine to do the real check
    //

    Result = FsRtlFastCheckLockForRead( FileLock,
                                        &StartingByte,
                                        &Length,
                                        Key,
                                        FileObject,
                                        ProcessId );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlCheckLockForReadAccess -> %08lx\n", Result);

    return Result;
}


BOOLEAN
FsRtlCheckLockForWriteAccess (
    IN PFILE_LOCK FileLock,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine checks to see if the caller has write access to the
    indicated range due to file locks.  This call does not complete the
    Irp it only uses it to get the lock information and write information.
    The IRP must be for a write operation.

Arguments:

    FileLock - Supplies the File Lock to check.

    Irp - Supplies the Irp being processed.

Return Value:

    BOOLEAN - TRUE if the indicated user/request has write access to the
        entire specified byte range, and FALSE otherwise

--*/

{
    BOOLEAN Result;

    PIO_STACK_LOCATION IrpSp;

    PLOCK_INFO      LockInfo;
    LARGE_INTEGER   StartingByte;
    LARGE_INTEGER   Length;
    ULONG           Key;
    PFILE_OBJECT    FileObject;
    PVOID           ProcessId;
    LARGE_INTEGER   BeyondLastByte;

    DebugTrace(+1, Dbg, "FsRtlCheckLockForWriteAccess, FileLock = %08lx\n", FileLock);

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForWriteAccess (No current lock info) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Do a really fast test to see if there are any locks to start with
    //

    if (LockInfo->LockQueue.ExclusiveLockTree == NULL && LockInfo->LockQueue.SharedLockTree == NULL) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForWriteAccess (No current locks) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Get the write offset and compare it to the lowest existing lock.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    StartingByte  = IrpSp->Parameters.Write.ByteOffset;
    (ULONGLONG)Length.QuadPart = (ULONGLONG)IrpSp->Parameters.Write.Length;

    (ULONGLONG)BeyondLastByte.QuadPart = (ULONGLONG)StartingByte.QuadPart + Length.LowPart;
    if ( (ULONGLONG)BeyondLastByte.QuadPart <= (ULONGLONG)LockInfo->LowestLockOffset ) {
        DebugTrace(-1, Dbg, "FsRtlCheckLockForWriteAccess (Below lowest lock) -> TRUE\n", 0);
        return TRUE;
    }

    //
    //  Get remaining parameters.
    //

    Key           = IrpSp->Parameters.Write.Key;
    FileObject    = IrpSp->FileObject;
    ProcessId     = IoGetRequestorProcess( Irp );

    //
    //  Call our private work routine to do the real work
    //

    Result = FsRtlFastCheckLockForWrite( FileLock,
                                         &StartingByte,
                                         &Length,
                                         Key,
                                         FileObject,
                                         ProcessId );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlCheckLockForWriteAccess -> %08lx\n", Result);

    return Result;
}


PRTL_SPLAY_LINKS
FsRtlFindFirstOverlappingSharedNode (
    IN PRTL_SPLAY_LINKS         Tree,
    IN PLARGE_INTEGER           StartingByte,
    IN PLARGE_INTEGER           EndingByte,
    IN OUT PRTL_SPLAY_LINKS     *LastEdgeNode,
    IN OUT PBOOLEAN             GreaterThan
    )
/*++

Routine Description:

    This routine returns the first node in the shared lock tree which
    overlaps with the range given. No nodes given by RtlRealPredecessor()
    on the result overlap the range.

Arguments:

    Tree - supplies the splay links of the root node of the shared tree
        to search

    StartingByte - supplies the first byte offset of the range to check

    EndingByte - supplies the last byte offset of the range to check

    LastEdgeNode - optional, will be set to the last node searched in the
        not including returned node (presumeably where a new node will
        be inserted if return is NULL).

    GreaterThan - optional, set according to whether LastEdgeNode is covering
        a range greater than the queried range. !GreaterThan == LessThan, since
        we would have returned this node in the "Equals" (overlap) case.

Return Value:

    The splay links of the node, if such a node exists, NULL otherwise

--*/
{
    PLOCKTREE_NODE        Node, LastOverlapNode;
    PRTL_SPLAY_LINKS      SplayLinks;
    PSH_LOCK              Lock;

    if (LastEdgeNode) *LastEdgeNode = NULL;
    if (GreaterThan) *GreaterThan = FALSE;

    LastOverlapNode = NULL;
    SplayLinks = Tree;

    while (SplayLinks) {

        Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );

        //
        //  Pull up the first lock on the chain at this node to check
        //  the starting byte offset of locks at this node
        //

        Lock = CONTAINING_RECORD( Node->Locks.Next, SH_LOCK, Link );

        //
        //  We may have to go right in the tree if this lock covers a range before the start of this
        //  range we are looking for overlap on or this lock is [0, 0).  This is important since a lock
        //  on [0, 0) will look like the extent is from [0, ~0], which is the only case where the zero
        //  length lock relation of End < Start does not hold.
        //

        if (Node->Extent < (ULONGLONG)StartingByte->QuadPart ||
            (Lock->LockInfo.StartingByte.QuadPart == 0 && Lock->LockInfo.Length.QuadPart == 0)) {

            if ((ULONGLONG)Lock->LockInfo.EndingByte.QuadPart == (ULONGLONG)EndingByte->QuadPart &&
                (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart == (ULONGLONG)StartingByte->QuadPart) {

                //
                //  The extent of the node is less than the starting position of the
                //  range we are checking and the first lock on this node is equal to
                //  the range, which implies that the range and the lock are zero
                //  length.
                //
                //  This is a zero length lock node and we are searching for zero
                //  length overlap. This makes multiple zero length shared locks
                //  occupy the same node, which is a win, but makes application of
                //  zero length exclusive locks check the length of the overlapping
                //  lock to see if they really conflict.
                //

                break;
            }

            //
            //  All locks at this node are strictly less than this
            //  byterange, so go right in the tree.
            //

            if (LastEdgeNode) *LastEdgeNode = SplayLinks;
            if (GreaterThan) *GreaterThan = FALSE;

            SplayLinks = RtlRightChild(SplayLinks);
            continue;
        }

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart <= (ULONGLONG)EndingByte->QuadPart) {

            //
            //  We have an overlap, but we need to see if the byterange starts
            //  before this node so that there is the guarantee that we start
            //  the search at the correct point. There may be still be predecessor
            //  nodes covering the byterange.
            //

            if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart <= (ULONGLONG)StartingByte->QuadPart) {

                //
                //  This node begins at a byte offset prior to the byterange we
                //  are checking, so it must be the correct starting position.
                //

                break;
            }

            //
            //  Drop a marker at this node so that we can come back if it turns out
            //  that the left subtree does not cover the range of bytes before this
            //  node in the byterange.
            //

            LastOverlapNode = Node;
        }

        //
        //  It must now be the case that all locks at this node are strictly greater
        //  than the byterange, or we have the candidate overlap case above,
        //  so go left in the tree.
        //

        if (LastEdgeNode) *LastEdgeNode = SplayLinks;
        if (GreaterThan) *GreaterThan = TRUE;

        SplayLinks = RtlLeftChild(SplayLinks);
    }

    if (SplayLinks == NULL) {

        //
        //  We hit the edge of the tree. If the LastOverlapNode is set, it means that
        //  we had kept searching left in the tree for a node that covered the starting
        //  byte of the byterange, but didn't find it. If it isn't set, we'll do the
        //  right thing anyway since Node <- NULL.
        //

        Node = LastOverlapNode;
    }

    if (Node == NULL) {

        //
        // No overlapping node existed
        //

        return NULL;
    }

    //
    // Return the splay links of the first overlapping node
    //

    return &Node->Links;
}


PRTL_SPLAY_LINKS
FsRtlFindFirstOverlappingExclusiveNode (
    IN PRTL_SPLAY_LINKS        Tree,
    IN PLARGE_INTEGER          StartingByte,
    IN PLARGE_INTEGER          EndingByte,
    IN OUT PRTL_SPLAY_LINKS    *LastEdgeNode,
    IN OUT PBOOLEAN            GreaterThan
    )
/*++

Routine Description:

    This routine returns the first node in the exclusive lock tree which
    overlaps with the range given. No nodes given by RtlRealPredecessor()
    on the result overlap the range.

Arguments:

    Tree - supplies the splay links of the root node of the exclusive tree
        to search

    StartingByte - supplies the first byte offset of the range to check

    EndingByte - supplies the last byte offset of the range to check

    LastEdgeNode - optional, will be set to the last node searched
        not including returned node (presumeably where a new node will
        be inserted if return is NULL).

    GreaterThan - optional, set according to whether LastEdgeNode is covering
        a range greater than the queried range. !GreaterThan == LessThan, since
        we would have returned this node in the "Equals" (overlap) case.

Return Value:

    The splay links of the node, if such a node exists, NULL otherwise

--*/
{
    PRTL_SPLAY_LINKS    SplayLinks;
    PEX_LOCK            Lock, LastOverlapNode;

    if (LastEdgeNode) *LastEdgeNode = NULL;
    if (GreaterThan) *GreaterThan = FALSE;

    LastOverlapNode = NULL;
    SplayLinks = Tree;

    while (SplayLinks) {

        Lock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

        //
        //  We may have to go right in the tree if this lock covers a range before the start of this
        //  range we are looking for overlap on or this lock is [0, 0).  This is important since a lock
        //  on [0, 0) will look like the extent is from [0, ~0], which is the only case where the zero
        //  length lock relation of End < Start does not hold.
        //

        if ((ULONGLONG)Lock->LockInfo.EndingByte.QuadPart < (ULONGLONG)StartingByte->QuadPart ||
            (Lock->LockInfo.StartingByte.QuadPart == 0 && Lock->LockInfo.Length.QuadPart == 0)) {

            if ((ULONGLONG)Lock->LockInfo.EndingByte.QuadPart == (ULONGLONG)EndingByte->QuadPart &&
                (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart == (ULONGLONG)StartingByte->QuadPart) {

                //
                //  The extent of the lock is less than the starting position of the
                //  range we are checking and the lock is equal to the range, which
                //  implies that the range and the lock are zero length.
                //
                //  This is a zero length lock node and we are searching for zero
                //  length overlap. Since the exclusive tree is one lock per node,
                //  we are in the potential middle of a run of zero length locks in
                //  the tree. Go left to find the first zero length lock.
                //
                //  This is actually the same logic we'd use for equivalent locks,
                //  but the only time that can happen in this tree is for zero length
                //  locks.
                //

                LastOverlapNode = Lock;

                if (LastEdgeNode) *LastEdgeNode = SplayLinks;
                if (GreaterThan) *GreaterThan = FALSE;

                SplayLinks = RtlLeftChild(SplayLinks);
                continue;
            }

            //
            //  This lock is strictly less than this byterange, so go
            //  right in the tree.
            //

            if (LastEdgeNode) *LastEdgeNode = SplayLinks;
            if (GreaterThan) *GreaterThan = FALSE;

            SplayLinks = RtlRightChild(SplayLinks);
            continue;
        }

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart <= (ULONGLONG)EndingByte->QuadPart) {

            //
            //  We have an overlap, but we need to see if the byterange starts
            //  before this node so that there is the guarantee that we start
            //  the search at the correct point. There may be still be predecessor
            //  nodes covering the byterange.
            //

            if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart <= (ULONGLONG)StartingByte->QuadPart) {

                //
                //  This node begins at a byte offset prior to the byterange we
                //  are checking, so it must be the correct starting position.
                //

                break;
            }

            //
            //  Drop a marker at this node so that we can come back if it turns out
            //  that the left subtree does not cover the range of bytes before this
            //  node in the byterange.
            //

            LastOverlapNode = Lock;
        }

        //
        //  It must now be the case this lock is strictly greater than the byterange,
        //  or we have the candidate overlap case above, so go left in the tree.
        //

        if (LastEdgeNode) *LastEdgeNode = SplayLinks;
        if (GreaterThan) *GreaterThan = TRUE;

        SplayLinks = RtlLeftChild(SplayLinks);
    }

    if (SplayLinks == NULL) {

        //
        //  We hit the edge of the tree. If the LastOverlapNode is set, it means that
        //  we had kept searching left in the tree for a node that covered the starting
        //  byte of the byterange, but didn't find it. If it isn't set, we'll do the
        //  right thing anyway since Node <- NULL.
        //

        Lock = LastOverlapNode;
    }

    if (Lock == NULL) {

        //
        // No overlapping lock existed
        //

        return NULL;
    }

    //
    // Return the splay links of the first overlapping lock
    //

    return &Lock->Links;
}


PSH_LOCK
FsRtlFindFirstOverlapInNode (
    IN PLOCKTREE_NODE Node,
    IN PLARGE_INTEGER StartingByte,
    IN PLARGE_INTEGER EndingByte
    )

/*++

Routine Description:

    This routine examines a shared lock node, usually a node which is known to be composed
    of several non-overlapping lock segments (holey), for true overlap with the indicated
    range.  This is not handled in the normal overlap check (..FindFirstOverlappingSharedLock)
    since the needs for holey checks are rather different than the full node check.

Arguments:

    Node - the lock tree node to be examined for overlap

    StartingByte - supplies the first byte offset of the range to check

    EndingByte - supplies the last byte offset of the range to check

Return Value:

    PSH_LOCK - the first lock which overlaps with the specified range.

--*/
{
    PSH_LOCK Lock;
    PSINGLE_LIST_ENTRY Link;

    for (Link = Node->Locks.Next;
         Link;
         Link = Link->Next) {

        Lock = CONTAINING_RECORD( Link, SH_LOCK, Link );

        //
        //  Logic is the same as above checkers.  If the ending byte of the lock is less than the
        //  starting byte of the range, OR we have the weird [0, 0) case, then the lock is almost
        //  certainly less than the range.
        //

        if ((ULONGLONG)Lock->LockInfo.EndingByte.QuadPart < (ULONGLONG)StartingByte->QuadPart ||
            (Lock->LockInfo.StartingByte.QuadPart == 0 && Lock->LockInfo.Length.QuadPart == 0)) {

            //
            //  ... except if the lock and range are equivalent, in which case we have discovered
            //  zero lock/range overlap.
            //

            if ((ULONGLONG)Lock->LockInfo.EndingByte.QuadPart == (ULONGLONG)EndingByte->QuadPart &&
                (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart == (ULONGLONG)StartingByte->QuadPart) {

                return Lock;
            }

            //
            //  Look forward in the node.
            //

            continue;
        }

        //
        //  No overlap at all if the lock begins at a higher byte than the last of the range.
        //  We already covered zero length locks (where this is true, and overlap could still
        //  occur).
        //

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)EndingByte->QuadPart) {

            return NULL;
        }

        //
        //  Regular overlap has occured.  Return this lock.
        //

        return Lock;
    }

    //
    //  If we invoke this check and wander off the end of the node without determining what is
    //  going on, something is terribly wrong.
    //

    ASSERT( FALSE );

    return NULL;
}


PFILE_LOCK_INFO
FsRtlGetNextFileLock (
    IN PFILE_LOCK FileLock,
    IN BOOLEAN Restart
    )

/*++

Routine Description:

    This routine enumerates the individual file locks denoted by the input file lock
    variable. It returns a pointer to the file lock information stored for each lock.
    The caller is responsible for synchronizing call to this procedure and for not
    altering any of the data returned by this procedure. If the caller does not
    synchronize the enumeration will not be reliably complete.

    The way a programmer will use this procedure to enumerate all of the locks
    is as follows:

    for (p = FsRtlGetNextFileLock( FileLock, TRUE );
         p != NULL;
         p = FsRtlGetNextFileLock( FileLock, FALSE )) {

            // Process the lock information referenced by p
    }

    Order is *not* guaranteed.

Arguments:

    FileLock - Supplies the File Lock to enumerate.  The current
        enumeration state is stored in the file lock variable so if multiple
        threads are enumerating the lock at the same time the results will
        be unpredictable.

    Restart - Indicates if the enumeration is to start at the beginning of the
        file lock tree or if we are continuing from a previous call.

Return Value:

    PFILE_LOCK_INFO - Either it returns a pointer to the next file lock
        record for the input file lock or it returns NULL if there
        are not more locks.

--*/

{
    FILE_LOCK_INFO      FileLockInfo;
    PVOID               ContinuationPointer;
    PLOCK_INFO          LockInfo;
    PLOCKTREE_NODE      Node;
    PSINGLE_LIST_ENTRY  Link;
    PRTL_SPLAY_LINKS    SplayLinks, LastSplayLinks;
    PSH_LOCK            ShLock;
    PEX_LOCK            ExLock;
    BOOLEAN             FoundReturnable, GreaterThan;
    KIRQL               OldIrql;

    DebugTrace(+1, Dbg, "FsRtlGetNextFileLock, FileLock = %08lx\n", FileLock);

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {
        //
        //  No lock information on this FileLock
        //

        return NULL;
    }

    FoundReturnable = FALSE;

    //
    //  Before getting the spinlock, copy pagable info onto stack
    //

    FileLockInfo = FileLock->LastReturnedLockInfo;
    ContinuationPointer = FileLock->LastReturnedLock;

    FsRtlAcquireLockQueue (&LockInfo->LockQueue, &OldIrql);

    if (!Restart) {
        //
        //  Given the last returned lock, find its current successor in the tree.
        //  Previous implementations would reset the enumeration if the last returned
        //  lock had been removed from the tree but I think we can be better in that
        //  case since every other structure modifying event (add new locks, delete
        //  other locks) would *not* have caused the reset. Possible minor performance
        //  enhancement.
        //

        //
        //  Find the node which could contain the last returned lock. We enumerate the
        //  exclusive lock tree, then the shared lock tree. Find the one we're enumerating.
        //

        if (FileLockInfo.ExclusiveLock) {

            //
            //  Continue enumeration in the exclusive lock tree
            //

            ExLock = NULL;

            SplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockInfo->LockQueue.ExclusiveLockTree,
                                                                 &FileLockInfo.StartingByte,
                                                                 &FileLockInfo.EndingByte,
                                                                 &LastSplayLinks,
                                                                 &GreaterThan );

            if (SplayLinks == NULL) {

                //
                //  No overlapping nodes were found, try to find successor
                //

                if (GreaterThan) {

                    //
                    //  Last node looked at was greater than the lock so it is
                    //  the place to pick up the enumeration
                    //

                    SplayLinks = LastSplayLinks;

                } else {

                    //
                    // Last node looked at was less than the lock so grab its successor
                    //

                    if (LastSplayLinks) {

                        SplayLinks = RtlRealSuccessor(LastSplayLinks);
                    }
                }

            } else {

                //
                //  Found an overlapping lock, see if it is the last returned
                //

                for (;
                    SplayLinks;
                    SplayLinks = RtlRealSuccessor(SplayLinks)) {

                    ExLock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

                    if (ContinuationPointer == ExLock &&
                        (ULONGLONG)FileLockInfo.StartingByte.QuadPart == (ULONGLONG)ExLock->LockInfo.StartingByte.QuadPart &&
                        (ULONGLONG)FileLockInfo.Length.QuadPart == (ULONGLONG)ExLock->LockInfo.Length.QuadPart &&
                        FileLockInfo.Key == ExLock->LockInfo.Key &&
                        FileLockInfo.FileObject == ExLock->LockInfo.FileObject &&
                        FileLockInfo.ProcessId == ExLock->LockInfo.ProcessId) {

                        //
                        //  Found last returned, dig up its successor
                        //

                        SplayLinks = RtlRealSuccessor(SplayLinks);

                        //
                        //  Got the node cold, so we're done
                        //

                        break;
                    }

                    //
                    //  This lock overlapped and was not the last returned. In fact, since this lock would
                    //  have conflicted with the last returned we know it could not have been returned
                    //  before, so this should be returned to the caller.
                    //
                    //  However, if it is a zero length lock we are looking for and a zero length lock we hit,
                    //  we are at the beginning of a run we need to inspect. If we cannot find the last lock
                    //  we returned, resume the enumeration at the beginning of the run.
                    //

                    if (ExLock->LockInfo.Length.QuadPart != 0 || FileLockInfo.Length.QuadPart != 0) {

                        break;
                    }

                    //
                    //  Keep wandering down the run
                    //
                }
            }

            //
            //  Were we able to find a lock to return?
            //

            if (SplayLinks == NULL) {

                //
                //  There aren't any more exclusive locks, fall over to the shared tree
                //

                SplayLinks = LockInfo->LockQueue.SharedLockTree;

                if (SplayLinks) {

                    while (RtlLeftChild(SplayLinks)) {

                        SplayLinks = RtlLeftChild(SplayLinks);
                    }

                    Node = CONTAINING_RECORD(SplayLinks, LOCKTREE_NODE, Links);
                    ShLock = CONTAINING_RECORD(Node->Locks.Next, SH_LOCK, Link);

                    FileLockInfo = ShLock->LockInfo;
                    ContinuationPointer = ShLock;
                    FoundReturnable = TRUE;
                }

            } else {

                //
                //  This is the lock to return
                //

                ExLock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

                FileLockInfo = ExLock->LockInfo;
                ContinuationPointer = ExLock;
                FoundReturnable = TRUE;
            }

        } else {

            //
            //  Continue enumeration in the shared lock tree
            //

            Node = NULL;

            SplayLinks = FsRtlFindFirstOverlappingSharedNode( LockInfo->LockQueue.SharedLockTree,
                                                              &FileLockInfo.StartingByte,
                                                              &FileLockInfo.EndingByte,
                                                              &LastSplayLinks,
                                                              &GreaterThan );

            if (SplayLinks == NULL) {

                //
                //  No overlapping nodes were found
                //

                if (GreaterThan) {

                    //
                    //  Last node looked at was greater than the lock so it is
                    //  the place to pick up the enumeration
                    //

                    if (LastSplayLinks) {

                        SplayLinks = LastSplayLinks;
                        Node = CONTAINING_RECORD( LastSplayLinks, LOCKTREE_NODE, Links );
                    }

                } else {

                    //
                    // Last node looked at was less than the lock so grab its successor
                    //

                    if (LastSplayLinks) {

                        SplayLinks = RtlRealSuccessor(LastSplayLinks);

                        if (SplayLinks) {

                            Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );
                        }
                    }
                }

            } else {

                //
                //  Grab the node we found
                //

                Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );
            }

            //
            //  If we have a node to look at, it may still not contain the the last returned lock
            //  if this isn't synchronized.
            //

            if (Node != NULL) {

                //
                //    Walk down the locks at this node looking for the last returned lock
                //

                for (Link = Node->Locks.Next;
                     Link;
                     Link = Link->Next) {

                    //
                    //  Get a pointer to the current lock record
                    //

                    ShLock = CONTAINING_RECORD( Link, SH_LOCK, Link );

                    //
                    // See if it's a match
                    //

                    if (ContinuationPointer == ShLock &&
                        (ULONGLONG)FileLockInfo.StartingByte.QuadPart == (ULONGLONG)ShLock->LockInfo.StartingByte.QuadPart &&
                        (ULONGLONG)FileLockInfo.Length.QuadPart == (ULONGLONG)ShLock->LockInfo.Length.QuadPart &&
                        FileLockInfo.Key == ShLock->LockInfo.Key &&
                        FileLockInfo.FileObject == ShLock->LockInfo.FileObject &&
                        FileLockInfo.ProcessId == ShLock->LockInfo.ProcessId) {

                        Link = Link->Next;
                        break;
                    }

                    //
                    // See if we passed by its slot
                    //

                    if ((ULONGLONG)FileLockInfo.StartingByte.QuadPart < (ULONGLONG)ShLock->LockInfo.StartingByte.QuadPart) {

                        break;
                    }
                }

                if (Link == NULL) {

                    //
                    //  This node doesn't contain the successor, so move
                    //  up to the successor node in the tree and return the
                    //  first lock. If we're actually at the end of the tree
                    //  we just fall off the end correctly.
                    //

                    SplayLinks = RtlRealSuccessor(SplayLinks);

                    if (SplayLinks) {

                        Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );

                        Link = Node->Locks.Next;
                    }
                }

                if (Link) {

                    //
                    //  Found a Lock to return, copy it to the stack
                    //

                    ShLock = CONTAINING_RECORD( Link, SH_LOCK, Link );

                    FileLockInfo = ShLock->LockInfo;
                    ContinuationPointer = ShLock;
                    FoundReturnable = TRUE;
                }

            }
        }

    } else {

        //
        //  Restarting the enumeration. Find leftmost node in the exclusive tree and hand back
        //  the first lock, falling over to the shared if no exlcusive locks are applied
        //

        if (LockInfo->LockQueue.ExclusiveLockTree) {

            SplayLinks = LockInfo->LockQueue.ExclusiveLockTree;

            while (RtlLeftChild(SplayLinks) != NULL) {

                SplayLinks = RtlLeftChild(SplayLinks);
            }

            ExLock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

            FileLockInfo = ExLock->LockInfo;
            ContinuationPointer = ExLock;
            FoundReturnable = TRUE;

        } else {

            if (LockInfo->LockQueue.SharedLockTree) {

                SplayLinks = LockInfo->LockQueue.SharedLockTree;

                while (RtlLeftChild(SplayLinks) != NULL) {

                    SplayLinks = RtlLeftChild(SplayLinks);
                }

                Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );
                ShLock = CONTAINING_RECORD( Node->Locks.Next, SH_LOCK, Link );

                FileLockInfo = ShLock->LockInfo;
                ContinuationPointer = ShLock;
                FoundReturnable = TRUE;
            }
        }
    }

    //
    //  Release all the lock queues
    //

    FsRtlReleaseLockQueue (&LockInfo->LockQueue, OldIrql);

    if (!FoundReturnable) {

        //
        //  No returnable lock was found, end of list
        //

        return NULL;
    }

    //
    // Update current enum location information
    //

    FileLock->LastReturnedLockInfo = FileLockInfo;
    FileLock->LastReturnedLock = ContinuationPointer;

    //
    // Return lock record to caller
    //

    return &FileLock->LastReturnedLockInfo;
}


BOOLEAN
FsRtlCheckNoSharedConflict (
   IN PLOCK_QUEUE LockQueue,
   IN PLARGE_INTEGER Starting,
   IN PLARGE_INTEGER Ending
   )
/*++

Routine Description:

    This routine checks to see if there is overlap in the shared locks with
    the given range. It is intended for use in the write access check path
    so that a rebalance will occur.

Arguments:

    FileLock - Supplies the File Lock to check

    StartingByte - Supplies the first byte (zero based) to check

    Length - Supplies the length, in bytes, to check

    Key - Supplies the key to use in the check

    FileObject - Supplies the file object to use in the check

    ProcessId - Supplies the Process Id to use in the check

Return Value:

    BOOLEAN - TRUE if the indicated user/request doesn't conflict in
        entire specified byte range, and FALSE otherwise

--*/
{
    PRTL_SPLAY_LINKS SplayLinks, BeginLinks;
    PLOCKTREE_NODE Node;

    SplayLinks = FsRtlFindFirstOverlappingSharedNode( LockQueue->SharedLockTree,
                                                      Starting,
                                                      Ending,
                                                      &BeginLinks,
                                                      NULL);

    if (BeginLinks) {

        LockQueue->SharedLockTree = RtlSplay(BeginLinks);
    }

    //
    //  If this node is holey, we'll have to walk the whole thing.
    //

    if (SplayLinks) {

        Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );

        if (Node->HoleyNode) {

            return (BOOLEAN)(FsRtlFindFirstOverlapInNode( Node, Starting, Ending ) == NULL);
        }

        //
        //  Overlapping non-holey node, so we do have shared lock conflict.
        //

        return FALSE;
    }

    //
    //  No node overlaps.
    //

    return TRUE;
}


BOOLEAN
FsRtlCheckNoExclusiveConflict (
    IN PLOCK_QUEUE LockQueue,
    IN PLARGE_INTEGER Starting,
    IN PLARGE_INTEGER Ending,
    IN ULONG Key,
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId
    )
/*++

Routine Description:

    This routine checks to see if there is conflict in the exclusive locks with
    a given range and identifying tuple of key, fileobject and process. This is
    for part of the read access path.

Arguments:

    FileLock - Supplies the File Lock to check

    StartingByte - Supplies the first byte (zero based) to check

    Length - Supplies the length, in bytes, to check

    Key - Supplies the key to use in the check

    FileObject - Supplies the file object to use in the check

    ProcessId - Supplies the Process Id to use in the check

Return Value:

    BOOLEAN - TRUE if the indicated user/request doesn't conflict in
        entire specified byte range, and FALSE otherwise

--*/
{
    PRTL_SPLAY_LINKS SplayLinks, BeginLinks;
    PEX_LOCK Lock;
    BOOLEAN Status = TRUE;

    //
    //  Find the node to begin the search at and go
    //

    for (SplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockQueue->ExclusiveLockTree,
                                                              Starting,
                                                              Ending,
                                                              &BeginLinks,
                                                              NULL);
         SplayLinks;
         SplayLinks = RtlRealSuccessor(SplayLinks)) {

        Lock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

        //
        //  If the current lock is greater than the end of the range we're
        //  looking for then the the user doesn't conflict
        //
        //  if (Ending < Lock->StartingByte) ...
        //

        if ((ULONGLONG)Ending->QuadPart < (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart) {

            DebugTrace(0, Dbg, "FsRtlCheckForExclusiveConflict, Ending < Lock->StartingByte\n", 0);

            break;
        }

        //
        //  Check for any overlap with the request. The test for
        //  overlap is that starting byte is less than or equal to the locks
        //  ending byte, and the ending byte is greater than or equal to the
        //  locks starting byte.  We already tested for this latter case in
        //  the preceding statement.
        //
        //  if (Starting <= Lock->StartingByte + Lock->Length - 1) ...
        //

        if ((ULONGLONG)Starting->QuadPart <= (ULONGLONG)Lock->LockInfo.EndingByte.QuadPart) {

            //
            //  This request overlaps the lock. We cannot grant the request
            //  if the file object, process id, and key do not match. Otherwise
            //  we'll continue looping looking at locks
            //

            if ((Lock->LockInfo.FileObject != FileObject) ||
                (Lock->LockInfo.ProcessId != ProcessId) ||
                (Lock->LockInfo.Key != Key)) {

                DebugTrace(0, Dbg, "FsRtlCheckForExclusiveConflict, Range locked already\n", 0);

                Status = FALSE;
                break;
            }
        }
    }

    if (BeginLinks) {

        LockQueue->ExclusiveLockTree = RtlSplay(BeginLinks);
    }

    //
    //  We searched the entire range without a conflict so we'll note no conflict
    //

    return Status;
}


BOOLEAN
FsRtlFastCheckLockForRead (
    IN PFILE_LOCK FileLock,
    IN PLARGE_INTEGER StartingByte,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId
    )

/*++

Routine Description:

    This routine checks to see if the caller has read access to the
    indicated range due to file locks.

Arguments:

    FileLock - Supplies the File Lock to check

    StartingByte - Supplies the first byte (zero based) to check

    Length - Supplies the length, in bytes, to check

    Key - Supplies the to use in the check

    FileObject - Supplies the file object to use in the check

    ProcessId - Supplies the Process Id to use in the check

Return Value:

    BOOLEAN - TRUE if the indicated user/request has read access to the
        entire specified byte range, and FALSE otherwise

--*/

{
    LARGE_INTEGER Starting;
    LARGE_INTEGER Ending;

    PLOCK_INFO            LockInfo;
    PLOCK_QUEUE           LockQueue;
    KIRQL                 OldIrql;
    PFILE_LOCK_INFO       LastLock;
    BOOLEAN               Status;

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {

        //
        // No lock information on this FileLock
        //

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForRead, No lock info\n", 0);
        return TRUE;
    }

    //
    // If there isn't an exclusive lock then we can immediately grant access
    //

    if (LockInfo->LockQueue.ExclusiveLockTree == NULL) {
        DebugTrace(0, Dbg, "FsRtlFastCheckLockForRead, No exlocks present\n", 0);
        return TRUE;
    }

    //
    // If length is zero then automatically give grant access
    //

    if ((ULONGLONG)Length->QuadPart == 0) {

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForRead, Length == 0\n", 0);
        return TRUE;
    }

    //
    //  Get our starting and ending byte position
    //

    Starting = *StartingByte;
    (ULONGLONG)Ending.QuadPart = (ULONGLONG)Starting.QuadPart + (ULONGLONG)Length->QuadPart - 1;

    //
    // Now check lock queue
    //

    LockQueue = &LockInfo->LockQueue;

    //
    //  Grab the waiting lock queue spinlock to exclude anyone from messing
    //  with the queue while we're using it
    //

    FsRtlAcquireLockQueue(LockQueue, &OldIrql);

    //
    //  If the range ends below the lowest existing lock, this read is OK.
    //

    if ( ((ULONGLONG)Ending.QuadPart < (ULONGLONG)LockInfo->LowestLockOffset) ) {
        DebugTrace(0, Dbg, "FsRtlFastCheckLockForRead (below lowest lock)\n", 0);

        FsRtlReleaseLockQueue(LockQueue, OldIrql);
        return TRUE;
    }

    //
    //  If the caller just locked this range, he can read it.
    //

    LastLock = (PFILE_LOCK_INFO)FileObject->LastLock;
    if ((LastLock != NULL) &&
        ((ULONGLONG)Starting.QuadPart >= (ULONGLONG)LastLock->StartingByte.QuadPart) &&
        ((ULONGLONG)Ending.QuadPart <= (ULONGLONG)LastLock->EndingByte.QuadPart) &&
        (LastLock->Key == Key) &&
        (LastLock->ProcessId == ProcessId)) {

        FsRtlReleaseLockQueue(LockQueue, OldIrql);
        return TRUE;
    }

    //
    //  Check the exclusive locks for a conflict. It is impossible to have
    //  a read conflict with any shared lock.
    //

    Status = FsRtlCheckNoExclusiveConflict(LockQueue, &Starting, &Ending, Key, FileObject, ProcessId);

    FsRtlReleaseLockQueue(LockQueue, OldIrql);

    return Status;
}


BOOLEAN
FsRtlFastCheckLockForWrite (
    IN PFILE_LOCK FileLock,
    IN PLARGE_INTEGER StartingByte,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN PVOID FileObject,
    IN PVOID ProcessId
    )

/*++

Routine Description:

    This routine checks to see if the caller has write access to the
    indicated range due to file locks

Arguments:

    FileLock - Supplies the File Lock to check

    StartingByte - Supplies the first byte (zero based) to check

    Length - Supplies the length, in bytes, to check

    Key - Supplies the to use in the check

    FileObject - Supplies the file object to use in the check

    ProcessId - Supplies the Process Id to use in the check

Return Value:

    BOOLEAN - TRUE if the indicated user/request has write access to the
        entire specified byte range, and FALSE otherwise

--*/

{
    LARGE_INTEGER Starting;
    LARGE_INTEGER Ending;

    PLOCK_INFO              LockInfo;
    PLOCK_QUEUE             LockQueue;
    KIRQL                   OldIrql;
    PFILE_LOCK_INFO         LastLock;
    BOOLEAN                 Status;

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {

        //
        // No lock information on this FileLock
        //

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForRead, No lock info\n", 0);
        return TRUE;
    }

    //
    //  If there isn't a lock then we can immediately grant access
    //

    if (LockInfo->LockQueue.SharedLockTree == NULL && LockInfo->LockQueue.ExclusiveLockTree == NULL) {

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForWrite, No locks present\n", 0);
        return TRUE;
    }

    //
    //  If length is zero then automatically grant access
    //

    if ((ULONGLONG)Length->QuadPart == 0) {

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForWrite, Length == 0\n", 0);
        return TRUE;
    }

    //
    //  Get our starting and ending byte position
    //

    Starting = *StartingByte;
    (ULONGLONG)Ending.QuadPart = (ULONGLONG)Starting.QuadPart + (ULONGLONG)Length->QuadPart - 1;

    //
    //  Now check lock queue
    //

    LockQueue = &LockInfo->LockQueue;

    //
    //  Grab the waiting lock queue spinlock to exclude anyone from messing
    //  with the queue while we're using it
    //

    FsRtlAcquireLockQueue(LockQueue, &OldIrql);

    //
    //  If the range ends below the lowest existing lock, this write is OK.
    //

    if ( ((ULONGLONG)Ending.QuadPart < (ULONGLONG)LockInfo->LowestLockOffset) ) {

        DebugTrace(0, Dbg, "FsRtlFastCheckLockForWrite (below lowest lock)\n", 0);

        FsRtlReleaseLockQueue(LockQueue, OldIrql);
        return TRUE;
    }

    //
    //  If the caller just locked this range exclusively, he can write it.
    //

    LastLock = (PFILE_LOCK_INFO)((PFILE_OBJECT)FileObject)->LastLock;
    if ((LastLock != NULL) &&
        ((ULONGLONG)Starting.QuadPart >= (ULONGLONG)LastLock->StartingByte.QuadPart) &&
        ((ULONGLONG)Ending.QuadPart <= (ULONGLONG)LastLock->EndingByte.QuadPart) &&
        (LastLock->Key == Key) &&
        (LastLock->ProcessId == ProcessId) &&
        LastLock->ExclusiveLock) {

        FsRtlReleaseLockQueue(LockQueue, OldIrql);
        return TRUE;
    }

    //
    //  Check the shared locks for overlap. Any overlap in the shared locks is fatal.
    //

    Status = FsRtlCheckNoSharedConflict(LockQueue, &Starting, &Ending);

    if (Status == TRUE) {

        //
        //  No overlap in the shared locks, so check the exclusive locks for overlap.
        //

        Status = FsRtlCheckNoExclusiveConflict(LockQueue, &Starting, &Ending, Key, FileObject, ProcessId);
    }

    FsRtlReleaseLockQueue(LockQueue, OldIrql);

    return Status;
}


VOID
FsRtlSplitLocks (
    IN PLOCKTREE_NODE ParentNode,
    IN PSINGLE_LIST_ENTRY *pStartLink,
    IN PLARGE_INTEGER LastShadowedByte,
    IN PLARGE_INTEGER GlueOffset
    )

/*++

Routine Description:

    This routine examines and possibly splits off shared locks associated
    with a node into new nodes of the lock tree. Called from routines that
    have just deleted locks.

    The arguments that supply the initial conditions for the operation are
    optional if the node is known to be holey.

Arguments:

    ParentNode- Supplies the node the locks are coming from

    pStartLink - Supplies the pointer to the link address of the start of the
        range of locks in the ParentNode's locklist that need to be checked

    LastShadowedByte - Supplies the last byte offset that needs to be checked

    GlueOffset - Supplies the maximum offset affected by locks prior to this
        point in the list

Return Value:

    BOOLEAN - True if the split was successful, False otherwise.  The node will
        be marked as Holey if the split could not occur.

--*/

{
    PSH_LOCK                Lock;
    PLOCKTREE_NODE          NewNode;
    PSINGLE_LIST_ENTRY      Link, *pLink, *NextpLink;
    LARGE_INTEGER           MaxOffset, StartOffset, HaltOffset;

    BOOLEAN                 ExtentValid;
    BOOLEAN                 FailedHoleySplit = FALSE;

    //
    //  There are two cases: the node is holey or not.  If the node is holey, at some
    //  point we failed to get resources to complete a split, so despite our caller's
    //  good intentions we need to go over the entire node.
    //

    if (ParentNode->HoleyNode) {

        //
        //  Just move the starting link back to the front.  The maximum offset and
        //  starting offset of the node will be initialized in the loop.  We also turn
        //  off the holey flag, which will be turned on again as appropriate.
        //

        pStartLink = &ParentNode->Locks.Next;
        ParentNode->HoleyNode = FALSE;

        HaltOffset.QuadPart = ParentNode->Extent;

    } else {

        HaltOffset = *LastShadowedByte;
        MaxOffset = *GlueOffset;
        StartOffset.QuadPart = 0;

        if (!ParentNode->Locks.Next ||
            (ULONGLONG)HaltOffset.QuadPart <= (ULONGLONG)MaxOffset.QuadPart) {

            //
            //  The parent node is not there, doesn't have links associated, or the
            //  last possible byte that is affected by the operation our caller made
            //  is interior to the max extent of all locks still in this node - in
            //  which case there is nothing that needs to be done.
            //

            return;
        }
    }

    //
    //  If the extent of the node is past the last byte affected by whatever
    //  operations were done to this node, we can avoid the linear scan of
    //  the list past that last affected byte since we already know the
    //  extent of the entire list! If it is not (note that it would have to
    //  be equal - by defintion) then we need to recalculate the extents of
    //  all nodes we touch in this operation.
    //

    ExtentValid = (ParentNode->Extent > (ULONGLONG)HaltOffset.QuadPart);

    for (pLink = pStartLink;
         (Link = *pLink) != NULL;
         pLink = NextpLink) {

        NextpLink = &Link->Next;

        Lock = CONTAINING_RECORD( Link, SH_LOCK, Link );

        if (ParentNode->Locks.Next == *pLink) {

            //
            //  We're at the first lock in the node, and we know that we're going to leave
            //  at least one lock here. Skip over that lock. We also know that the max
            //  offset must be that locks's ending byte - make sure it is. Note that this
            //  code is *exactly* the same as the update MaxOffset code at the bottom of
            //  the loop.
            //

            MaxOffset.QuadPart = Lock->LockInfo.EndingByte.QuadPart;

            //
            //  Set the starting offset of the node.  This is only an issue for zero length
            //  locks, so that we can figure out what is going on if we split a node and wind
            //  up with some number of "overlapped" zero length locks at the front of the new
            //  node.  We must be able to notice this case, and not think that each needs to
            //  be in a seperate node.
            //

            StartOffset.QuadPart = Lock->LockInfo.StartingByte.QuadPart;

            //
            //  If extents are invalid we also need to set it in case this turns out to
            //  be the only lock at this node.
            //

            if (!ExtentValid) {

                ParentNode->Extent = (ULONGLONG)MaxOffset.QuadPart;
            }

            continue;
        }

        //
        //  If the lock begins at a byte offset greater than the maximum offset seen to this
        //  point, AND this is not a zero length node starting at the beginning of this node,
        //  break the node.  The second half of the test keeps co-incident zero length locks
        //  in the same node. (zero length lock ---> starting = ending + 1).
        //

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)MaxOffset.QuadPart &&
            !(Lock->LockInfo.Length.QuadPart == 0 &&
              Lock->LockInfo.StartingByte.QuadPart == StartOffset.QuadPart)) {

            //
            //  Break the node up here
            //

            NewNode = FsRtlAllocateLockTreeNode();

            if (NewNode == NULL) {

                //
                //  If we are out of resources, this node is now holey - we know that the locks at
                //  this node do not completely cover the indicated range.  Keep splitting for two
                //  reasons: more resources may become avaliable, and we must keep updating the
                //  node's extent if it is known to be invalid.
                //

                //
                //  Now if this node was already holey it is not possible to state that, if we
                //  manage to split if further as we keep walking, that the resulting "left" node
                //  is not holey.  See below.
                //

                if (ParentNode->HoleyNode) {

                    FailedHoleySplit = TRUE;
                }

                ParentNode->HoleyNode = TRUE;

            } else {

                //
                //  Initialize the node.
                //

                RtlInitializeSplayLinks(&NewNode->Links);
                NewNode->HoleyNode = FALSE;

                //
                //  Find the spot in the tree to take the new node(s). If the current node has
                //  a free right child, we use it, else find the successor node and use its
                //  left child. One of these cases must be avaliable since we know there are
                //  no nodes between this node and its successor.
                //

                if (RtlRightChild(&ParentNode->Links) == NULL) {

                    RtlInsertAsRightChild(&ParentNode->Links, &NewNode->Links);

                } else {

                    ASSERT(RtlLeftChild(RtlRealSuccessor(&ParentNode->Links)) == NULL);
                    RtlInsertAsLeftChild(RtlRealSuccessor(&ParentNode->Links), &NewNode->Links);
                }

                //
                //  Move the remaining locks over to the new node and fix up extents
                //

                NewNode->Locks.Next = *pLink;
                *pLink = NULL;

                NewNode->Tail.Next = ParentNode->Tail.Next;
                ParentNode->Tail.Next = CONTAINING_RECORD( pLink, SINGLE_LIST_ENTRY, Next );

                //
                //  This will cause us to fall into the first-lock clause above on the next pass
                //

                NextpLink = &NewNode->Locks.Next;

                //
                // The new node's extent is now copied from the parent. The old node's extent must be
                // the maximum offset we have seen to this point.
                //
                // Note that if ExtentValid is true, that must mean that the lock ending at that extent
                // is in the new node since if it was in the old node we wouldn't have been able to split.
                //

                NewNode->Extent = ParentNode->Extent;
                ParentNode->Extent = (ULONGLONG)MaxOffset.QuadPart;

                //
                //  The parent node can no longer be holey if we have not failed a split in this node.
                //

                if (!FailedHoleySplit) {

                    ParentNode->HoleyNode = FALSE;

                } else {

                    //
                    //  So reset the failure flag for the new node.
                    //

                    FailedHoleySplit = FALSE;
                }

                //
                //  Move over to the new node.
                //

                ParentNode = NewNode;

                continue;
            }
        }

        if (ExtentValid &&
            (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)HaltOffset.QuadPart) {

            //
            //  Our extents are good and this lock is past the shadow, so we can stop
            //

            return;
        }

        if ((ULONGLONG)MaxOffset.QuadPart < (ULONGLONG)Lock->LockInfo.EndingByte.QuadPart) {

            //
            //  Update maximum offset
            //

            MaxOffset.QuadPart = Lock->LockInfo.EndingByte.QuadPart;

            if (!ExtentValid) {

                //
                //  Extents are not good so we must update the extent
                //

                ParentNode->Extent = (ULONGLONG)MaxOffset.QuadPart;
            }
        }
    }

    //
    //  Reached the end of the list, so update the extent (case of all subsequent locks
    //  having been interior to GlueOffset)
    //

    ParentNode->Extent = (ULONGLONG)MaxOffset.QuadPart;

    return;
}


VOID
FsRtlPrivateRemoveLock (
    IN PLOCK_INFO LockInfo,
    IN PFILE_LOCK_INFO FileLockInfo,
    IN BOOLEAN CheckForWaiters
    )

/*++

Routine Description:

    General purpose cleanup routine.  Finds the given lock structure
    and removes it from the file lock list. Differs from UnlockSingle
    only in that it disables the UnlockRoutine of the FileLock and
    optionalizes walking the waiting locks list.

Arguments:

    FileLock - Supplies the file's lock structure supposedly containing a stale lock

    FileLockInfo - Supplies file lock data being freed

    CheckForWaiters - If true check for possible waiting locks, caused
        by freeing the locked range

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    if (FileLockInfo->ExclusiveLock) {

        //
        //  We must find it in the exclusive lock tree
        //

        Status = FsRtlFastUnlockSingleExclusive( LockInfo,

                                                 FileLockInfo->FileObject,
                                                 &FileLockInfo->StartingByte,
                                                 &FileLockInfo->Length,
                                                 FileLockInfo->ProcessId,
                                                 FileLockInfo->Key,

                                                 NULL,
                                                 TRUE,
                                                 CheckForWaiters );

        ASSERT( Status == STATUS_SUCCESS);

    } else {

        //
        //  We must find it in the shared lock tree
        //

        Status = FsRtlFastUnlockSingleShared( LockInfo,

                                              FileLockInfo->FileObject,
                                              &FileLockInfo->StartingByte,
                                              &FileLockInfo->Length,
                                              FileLockInfo->ProcessId,
                                              FileLockInfo->Key,

                                              NULL,
                                              TRUE,
                                              CheckForWaiters );

        ASSERT( Status == STATUS_SUCCESS);
    }

    return;
}


NTSTATUS
FsRtlFastUnlockSingle (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN LARGE_INTEGER UNALIGNED *FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL,
    IN BOOLEAN AlreadySynchronized
    )

/*++

Routine Description:

    This routine performs an Unlock Single operation on the current locks
    associated with the specified file lock.  Only the lock with a matching
    file object, process id, key, and range is freed.

Arguments:

    FileLock - Supplies the file lock being freed.

    FileObject - Supplies the file object holding the locks

    FileOffset - Supplies the offset to be unlocked

    Length - Supplies the length in bytes to be unlocked

    ProcessId - Supplies the process Id to use in this operation

    Key - Supplies the key to use in this operation

    Context - Optionally supplies context to use when completing Irps

    AlreadySynchronized - Indicates that the caller has already synchronized
        access to the file lock so the fields in the file lock and
        be updated without further locking, but not the queues.

Return Value:

    NTSTATUS - The completion status for this operation

--*/

{
    NTSTATUS Status;

    //
    //  XXX AlreadySynchronized is obsolete. It was apparently added for the dead
    //  XXX SoloLock code.
    //

    if (FileLock->LockInformation == NULL) {

        //
        //  Fast exit - no locks are applied
        //

        return STATUS_RANGE_NOT_LOCKED;
    }

    Status = FsRtlFastUnlockSingleExclusive( FileLock->LockInformation,
                                             FileObject,
                                             FileOffset,
                                             Length,
                                             ProcessId,
                                             Key,
                                             Context,
                                             FALSE,
                                             TRUE );

    if (Status == STATUS_SUCCESS) {

        //
        //  Found and unlocked in the exclusive tree, so we're done
        //

        return Status;
    }

    Status = FsRtlFastUnlockSingleShared( FileLock->LockInformation,
                                          FileObject,
                                          FileOffset,
                                          Length,
                                          ProcessId,
                                          Key,
                                          Context,
                                          FALSE,
                                          TRUE );

    return Status;
}


NTSTATUS
FsRtlFastUnlockSingleShared (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN LARGE_INTEGER UNALIGNED *FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL,
    IN BOOLEAN IgnoreUnlockRoutine,
    IN BOOLEAN CheckForWaiters
    )

/*++

Routine Description:

    This routine performs an Unlock Single operation on the current locks
    associated with the specified file lock.  Only the lock with a matching
    file object, process id, key, and range is freed.

Arguments:

    LockInfo - Supplies the lock data being operated on

    FileObject - Supplies the file object holding the locks

    FileOffset - Supplies the offset to be unlocked

    Length - Supplies the length in bytes to be unlocked

    ProcessId - Supplies the process Id to use in this operation

    Key - Supplies the key to use in this operation

    Context - Optionally supplies context to use when completing Irps

    IgnoreUnlockRoutine - inidicates that the filelock's unlock routine
        should not be called on lock removal (for removal of aborted
        locks)

    CheckForWaiters - If true check for possible waiting locks, caused
        by freeing the locked range

Return Value:

    NTSTATUS - The completion status for this operation

--*/

{
    PSINGLE_LIST_ENTRY      *pLink, Link;
    KIRQL                   OldIrql;

    PLOCK_QUEUE             LockQueue;
    PRTL_SPLAY_LINKS        SplayLinks;
    LARGE_INTEGER           EndingOffset, MaxOffset;
    PLOCKTREE_NODE          Node;
    LARGE_INTEGER           AlignedFileOffset;

    //
    //  General case - search the outstanding lock queue for this lock
    //

    AlignedFileOffset = *FileOffset;

    LockQueue = &LockInfo->LockQueue;

    FsRtlAcquireLockQueue(LockQueue, &OldIrql);

    //
    //  Check for the no locks currently held
    //

    if (LockQueue->SharedLockTree == NULL) {

        FsRtlReleaseLockQueue( LockQueue, OldIrql );

        return STATUS_RANGE_NOT_LOCKED;
    }

    //
    //  Find the overlapping node, if it exists, to search. Note that
    //  we don't have to go through more than one node in the tree
    //  since we are assuming this is an existing lock.
    //

    EndingOffset.QuadPart = (ULONGLONG)AlignedFileOffset.QuadPart + (ULONGLONG)Length->QuadPart - 1;

    SplayLinks = FsRtlFindFirstOverlappingSharedNode( LockQueue->SharedLockTree,
                                                      &AlignedFileOffset,
                                                      &EndingOffset,
                                                      NULL,
                                                      NULL );

    if (SplayLinks == NULL) {

        //
        //  No node in the tree overlaps this range, so we're done
        //

        FsRtlReleaseLockQueue(LockQueue, OldIrql);

        return STATUS_RANGE_NOT_LOCKED;
    }

    Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );
    MaxOffset.QuadPart = 0;

    for (pLink = &Node->Locks.Next;
         (Link = *pLink) != NULL;
         pLink = &Link->Next) {

        PSH_LOCK Lock;

        Lock = CONTAINING_RECORD( Link, SH_LOCK, Link );

        DebugTrace(0, Dbg, "Sh Top of Loop, Lock = %08lx\n", Lock );

        if ((Lock->LockInfo.FileObject == FileObject) &&
            (Lock->LockInfo.ProcessId == ProcessId) &&
            (Lock->LockInfo.Key == Key) &&
            ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart == (ULONGLONG)AlignedFileOffset.QuadPart) &&
            ((ULONGLONG)Lock->LockInfo.Length.QuadPart == (ULONGLONG)Length->QuadPart)) {

            DebugTrace(0, Dbg, "Sh Found one to unlock\n", 0);

            //
            //  We have an exact match so now is the time to delete this
            //  lock.  Remove the lock from the list, then call the
            //  optional unlock routine, then delete the lock.
            //

            if (FileObject->LastLock == &Lock->LockInfo) {

                FileObject->LastLock = NULL;
            }

            if (*pLink == Node->Tail.Next) {

                //
                //  Deleting the tail node of the list. Safe even if deleting the
                //  first node since this implies we're also deleting the last node
                //  in the node which means we'll delete the node ...
                //

                Node->Tail.Next = CONTAINING_RECORD( pLink, SINGLE_LIST_ENTRY, Next );
            }

            //
            //  Snip the deleted lock
            //

            *pLink = Link->Next;

            if (pLink == &Node->Locks.Next) {

                //
                //  Deleted first lock in node
                //

                if (Node->Locks.Next == NULL) {

                    //
                    // Just deleted last lock on this node, so free it
                    //

                    LockQueue->SharedLockTree = RtlDelete(SplayLinks);

                    FsRtlFreeLockTreeNode(Node);

                    Node = NULL;
                }

                if (LockInfo->LowestLockOffset != 0xffffffff &&
                    LockInfo->LowestLockOffset == Lock->LockInfo.StartingByte.LowPart) {

                    //
                    //  This was the lowest lock in the trees, reset the lowest lock offset
                    //

                    FsRtlPrivateResetLowestLockOffset(LockInfo);
                }
            }

            //
            //  Now the fun begins. It may be the case that the lock just snipped from
            //  the chain was gluing locks at this node together, so we need to
            //  inspect the chain.
            //

            if (Node) {

                FsRtlSplitLocks(Node, pLink, &Lock->LockInfo.EndingByte, &MaxOffset);
            }

            if (!IgnoreUnlockRoutine && LockInfo->UnlockRoutine != NULL) {

                FsRtlReleaseLockQueue( LockQueue, OldIrql );

                LockInfo->UnlockRoutine( Context, &Lock->LockInfo );

                FsRtlAcquireLockQueue( LockQueue, &OldIrql );

            }

            FsRtlFreeSharedLock( Lock );

            //
            //  See if there are additional waiting locks that we can
            //  now release.
            //

            if (CheckForWaiters && LockQueue->WaitingLocks.Next) {

                FsRtlPrivateCheckWaitingLocks( LockInfo, LockQueue, OldIrql );
            }

            FsRtlReleaseLockQueue( LockQueue, OldIrql );

            return STATUS_SUCCESS;
        }

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)AlignedFileOffset.QuadPart) {

            //
            //  The current lock begins at a byte offset greater than the range we are seeking
            //  to unlock. This range must therefore not be locked.
            //

            break;
        }

        if ((ULONGLONG)MaxOffset.QuadPart < (ULONGLONG)Lock->LockInfo.EndingByte.QuadPart) {

            //
            // Maintain the maximum offset affected by locks up to this point.
            //

            MaxOffset.QuadPart = Lock->LockInfo.EndingByte.QuadPart;
        }
    }

    //
    //  Lock was not found, return to our caller
    //

    FsRtlReleaseLockQueue(LockQueue, OldIrql);
    return STATUS_RANGE_NOT_LOCKED;
}


NTSTATUS
FsRtlFastUnlockSingleExclusive (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN LARGE_INTEGER UNALIGNED *FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL,
    IN BOOLEAN IgnoreUnlockRoutine,
    IN BOOLEAN CheckForWaiters
    )

/*++

Routine Description:

    This routine performs an Unlock Single operation on the exclusive locks
    associated with the specified lock data.  Only the lock with a matching
    file object, process id, key, and range is freed.

Arguments:

    LockInfo - Supplies the lock data being operated on

    FileObject - Supplies the file object holding the locks

    FileOffset - Supplies the offset to be unlocked

    Length - Supplies the length in bytes to be unlocked

    ProcessId - Supplies the process Id to use in this operation

    Key - Supplies the key to use in this operation

    Context - Optionally supplies context to use when completing Irps

    IgnoreUnlockRoutine - inidicates that the filelock's unlock routine
        should not be called on lock removal (for removal of aborted
        locks)

    CheckForWaiters - If true check for possible waiting locks, caused
        by freeing the locked range

Return Value:

    NTSTATUS - The completion status for this operation

--*/

{
    KIRQL                   OldIrql;
    PLOCK_QUEUE             LockQueue;
    PRTL_SPLAY_LINKS        SplayLinks;
    LARGE_INTEGER           EndingOffset;
    PEX_LOCK                Lock;
    LARGE_INTEGER           AlignedFileOffset;

    //
    //  General case - search the outstanding lock queue for this lock
    //

    AlignedFileOffset = *FileOffset;

    LockQueue = &LockInfo->LockQueue;

    FsRtlAcquireLockQueue(LockQueue, &OldIrql);

    //
    //  Check for the no locks currently held
    //

    if (LockQueue->ExclusiveLockTree == NULL) {

        FsRtlReleaseLockQueue( LockQueue, OldIrql );

        return STATUS_RANGE_NOT_LOCKED;
    }

    //
    //  Find the overlapping lock, if it exists. Note that this is usually
    //  the only lock we need to check since we are assuming this is an
    //  existing lock. However, if the lock is a zero length lock we will
    //  have a run of locks to check.
    //

    EndingOffset.QuadPart = (ULONGLONG)AlignedFileOffset.QuadPart + (ULONGLONG)Length->QuadPart - 1;

    for (SplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockQueue->ExclusiveLockTree,
                                                              &AlignedFileOffset,
                                                              &EndingOffset,
                                                              NULL,
                                                              NULL );
         SplayLinks;
         SplayLinks = RtlRealSuccessor(SplayLinks)) {

        Lock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

        if ((Lock->LockInfo.FileObject == FileObject) &&
            (Lock->LockInfo.ProcessId == ProcessId) &&
            (Lock->LockInfo.Key == Key) &&
            ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart == (ULONGLONG)AlignedFileOffset.QuadPart) &&
            ((ULONGLONG)Lock->LockInfo.Length.QuadPart == (ULONGLONG)Length->QuadPart)) {

            DebugTrace(0, Dbg, "Ex Found one to unlock\n", 0);

            //
            //  We have an exact match so now is the time to delete this
            //  lock.  Remove the lock from the list, then call the
            //  optional unlock routine, then delete the lock.
            //

            if (FileObject->LastLock == &Lock->LockInfo) {

                FileObject->LastLock = NULL;
            }

            //
            //  Snip the deleted lock
            //

            LockQueue->ExclusiveLockTree = RtlDelete(&Lock->Links);

            if (LockInfo->LowestLockOffset != 0xffffffff &&
                LockInfo->LowestLockOffset == Lock->LockInfo.StartingByte.LowPart) {

                //
                //  This was the lowest lock in the tree, so reset the lowest lock
                //  offset
                //

                FsRtlPrivateResetLowestLockOffset(LockInfo);
            }

            if (!IgnoreUnlockRoutine && LockInfo->UnlockRoutine != NULL) {

                FsRtlReleaseLockQueue( LockQueue, OldIrql );

                LockInfo->UnlockRoutine( Context, &Lock->LockInfo );

                FsRtlAcquireLockQueue( LockQueue, &OldIrql );

            }

            FsRtlFreeExclusiveLock( Lock );

            //
            //  See if there are additional waiting locks that we can
            //  now release.
            //

            if (CheckForWaiters && LockQueue->WaitingLocks.Next) {

                FsRtlPrivateCheckWaitingLocks( LockInfo, LockQueue, OldIrql );
            }

            FsRtlReleaseLockQueue( LockQueue, OldIrql );

            return STATUS_SUCCESS;
        }

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)AlignedFileOffset.QuadPart) {

            //
            //  The current lock begins at a byte offset greater than the range we are seeking
            //  to unlock. This range must therefore not be locked.
            //

            break;
        }
    }

    //
    //  Lock was not found, return to our caller
    //

    FsRtlReleaseLockQueue(LockQueue, OldIrql);
    return STATUS_RANGE_NOT_LOCKED;
}


NTSTATUS
FsRtlFastUnlockAll (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This routine performs an Unlock all operation on the current locks
    associated with the specified file lock.  Only those locks with
    a matching file object and process id are freed.

Arguments:

    FileLock - Supplies the file lock being freed.

    FileObject - Supplies the file object associated with the file lock

    ProcessId - Supplies the Process Id assoicated with the locks to be
        freed

    Context - Supplies an optional context to use when completing waiting
        lock irps.

Return Value:

    None

--*/

{
    return FsRtlPrivateFastUnlockAll(
                FileLock,
                FileObject,
                ProcessId,
                0, FALSE,           // No Key
                Context );
}


NTSTATUS
FsRtlFastUnlockAllByKey (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This routine performs an Unlock All by Key operation on the current locks
    associated with the specified file lock.  Only those locks with
    a matching file object, process id, and key are freed.  The input Irp
    is completed by this procedure

Arguments:

    FileLock - Supplies the file lock being freed.

    FileObject - Supplies the file object associated with the file lock

    ProcessId - Supplies the Process Id assoicated with the locks to be
        freed

    Key - Supplies the Key to use in this operation

    Context - Supplies an optional context to use when completing waiting
        lock irps.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    return FsRtlPrivateFastUnlockAll(
                FileLock,
                FileObject,
                ProcessId,
                Key, TRUE,
                Context );

}


//
//  Local Support Routine
//

BOOLEAN
FsRtlPrivateLock (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK Iosb,
    IN PIRP Irp OPTIONAL,
    IN PVOID Context,
    IN BOOLEAN AlreadySynchronized
    )

/*++

Routine Description:

    This routine preforms a lock operation request.  This handles both the fast
    get lock and the Irp based get lock.  If the Irp is supplied then
    this routine will either complete the Irp or enqueue it as a waiting
    lock request.

Arguments:

    FileLock - Supplies the File Lock to work against

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    FailImmediately - Indicates if the request should fail immediately
        if the lock cannot be granted.

    ExclusiveLock - Indicates if this is a request for an exclusive or
        shared lock

    Iosb - Receives the Status if this operation is successful

    Context - Supplies the context with which to complete Irp with

    AlreadySynchronized - Indicates that the caller has already synchronized
        access to the file lock so the fields in the file lock and
        be updated without further locking, but not the queues.

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE otherwise.

--*/

{
    BOOLEAN Results;
    BOOLEAN AccessGranted;
    BOOLEAN ViaFastCall;
    BOOLEAN ReleaseQueue = FALSE;

    PLOCK_INFO  LockInfo;
    PLOCK_QUEUE LockQueue;
    KIRQL       OldIrql;
    FILE_LOCK_INFO FileLockInfo;

    DebugTrace(+1, Dbg, "FsRtlPrivateLock, FileLock = %08lx\n", FileLock);

    //
    //  If the irp is null then this is being called via the fast call method.
    //

    ViaFastCall = (BOOLEAN) !ARGUMENT_PRESENT( Irp );

    if ((LockInfo = (PLOCK_INFO) FileLock->LockInformation) == NULL) {
        DebugTrace(+2, Dbg, "FsRtlPrivateLock, New LockInfo required\n", 0);

        //
        // No lock information on this FileLock, create the structure.
        //
        //

        if (!FsRtlPrivateInitializeFileLock (FileLock, ViaFastCall)) {

            return FALSE;
        }

        //
        // Set flag so file locks will be checked on the fast io
        // code paths
        //

        FileLock->FastIoIsQuestionable = TRUE;

        //
        // Pickup allocated lockinfo structure
        //

        LockInfo = (PLOCK_INFO) FileLock->LockInformation;
    }

    //
    // Assume success and build LockData structure prior to acquiring
    // the lock queue spinlock.  (mp perf enhancement)
    //

    FileLockInfo.StartingByte = *FileOffset;
    FileLockInfo.Length = *Length;
    (ULONGLONG)FileLockInfo.EndingByte.QuadPart =
            (ULONGLONG)FileLockInfo.StartingByte.QuadPart + (ULONGLONG)FileLockInfo.Length.QuadPart - 1;

    FileLockInfo.Key = Key;
    FileLockInfo.FileObject = FileObject;
    FileLockInfo.ProcessId = ProcessId;
    FileLockInfo.ExclusiveLock = ExclusiveLock;

    LockQueue = &LockInfo->LockQueue;

    //
    //  Now we need to actually run through our current lock queue.
    //

    FsRtlAcquireLockQueue(LockQueue, &OldIrql);
    ReleaseQueue = TRUE;

    try {

        //
        //  Case on whether we're trying to take out an exclusive lock or
        //  a shared lock.  And in both cases try to get appropriate access.
        //

        if (ExclusiveLock) {

            DebugTrace(0, Dbg, "Check for write access\n", 0);

            AccessGranted = FsRtlPrivateCheckForExclusiveLockAccess(
                                LockQueue,
                                &FileLockInfo );

        } else {

            DebugTrace(0, Dbg, "Check for read access\n", 0);

            AccessGranted = FsRtlPrivateCheckForSharedLockAccess(
                                LockQueue,
                                &FileLockInfo );
        }

        //
        //  Now AccessGranted tells us whether we can really get the access
        //  for the range we want
        //

        if (!AccessGranted) {

            DebugTrace(0, Dbg, "We do not have access\n", 0);

            //
            //  We cannot read/write to the range, so we cannot take out
            //  the lock.  Now if the user wanted to fail immediately then
            //  we'll complete the Irp, otherwise we'll enqueue this Irp
            //  to the waiting lock queue
            //

            if (FailImmediately) {

                //
                //  Set our status and return, the finally clause will
                //  complete the request
                //

                DebugTrace(0, Dbg, "And we fail immediately\n", 0);

                Iosb->Status = STATUS_LOCK_NOT_GRANTED;
                try_return( Results = TRUE );

            } else if (ARGUMENT_PRESENT(Irp)) {

                PWAITING_LOCK WaitingLock;

                DebugTrace(0, Dbg, "And we enqueue the Irp for later\n", 0);

                //
                //  Allocate a new waiting record, set it to point to the
                //  waiting Irp, and insert it in the tail of the waiting
                //  locks queue
                //

                WaitingLock = FsRtlAllocateWaitingLock();

                //
                //  Simply raise out if we can't allocate.
                //

                if (WaitingLock == NULL) {

                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

                WaitingLock->Irp = Irp;
                WaitingLock->Context = Context;
                WaitingLock->CompleteLockIrpRoutine = LockInfo->CompleteLockIrpRoutine;
                IoMarkIrpPending( Irp );

                //
                // Add WaitingLock WaitingLockQueue
                //

                WaitingLock->Link.Next = NULL;
                if (LockQueue->WaitingLocks.Next == NULL) {

                    //
                    // Create new list
                    //

                    LockQueue->WaitingLocks.Next = &WaitingLock->Link;
                    LockQueue->WaitingLocksTail.Next = &WaitingLock->Link;

                } else {

                    //
                    // Add waiter to tail of list
                    //

                    LockQueue->WaitingLocksTail.Next->Next = &WaitingLock->Link;
                    LockQueue->WaitingLocksTail.Next = &WaitingLock->Link;
                }


                //
                //  Setup IRP in case it's canceled - then set the
                //  IRP's cancel routine
                //

                Irp->IoStatus.Information = (ULONG_PTR)LockInfo;
                IoSetCancelRoutine( Irp, FsRtlPrivateCancelFileLockIrp );

                if (Irp->Cancel) {

                    //
                    // Pull the cancel routine off of the IRP - if it is not
                    // NULL, this means we won the race with IoCancelIrp and
                    // will be responsible for cancelling the IRP synchronously.
                    // If NULL, we lost and our cancel routine is already being
                    // called for us.
                    //
                    // This must be done while holding the lock queue down since
                    // this is how we synchronize with the cancel.
                    //

                    if (IoSetCancelRoutine( Irp, NULL )) {

                        //
                        // Irp's cancel routine was not called, do it ourselves.
                        // Indicate to the cancel routine that he does not need
                        // to release the cancel spinlock by passing a NULL DO.
                        //
                        // The queue will be dropped in order to complete the Irp.
                        // We communicate the previous IRQL through the Irp itself.
                        //

                        Irp->CancelIrql = OldIrql;
                        FsRtlPrivateCancelFileLockIrp( NULL, Irp );
                        ReleaseQueue = FALSE;
                    }
                }

                Iosb->Status = STATUS_PENDING;
                try_return( Results = TRUE );

            } else {

                try_return( Results = FALSE );
            }
        }

        DebugTrace(0, Dbg, "We have access\n", 0);

        if (!FsRtlPrivateInsertLock( LockInfo, FileObject, &FileLockInfo )) {

            //
            //  Resource exhaustion will cause us to fail here.  Via the fast call, indicate
            //  that it may be worthwhile to go around again via the Irp based path.  If we
            //  are already there, simply raise out.
            //

            if (ViaFastCall) {

                try_return( Results = FALSE );

            } else {

                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

        } else {

            Iosb->Status = STATUS_SUCCESS;
        }

        //
        //  At long last, we're done.
        //

        Results = TRUE;

    try_exit: NOTHING;
    } finally {

        if (ReleaseQueue) {
            
            FsRtlReleaseLockQueue(LockQueue, OldIrql);
        }

        //
        //  Complete the request provided we were given one and it is not a pending status
        //

        if (!AbnormalTermination() && ARGUMENT_PRESENT(Irp) && (Iosb->Status != STATUS_PENDING)) {

            NTSTATUS NewStatus;

            //
            //  We must reference the fileobject for the case that the IRP completion
            //  fails and we need to lift the lock.  Although the only reason we have
            //  to touch the fileobject in the remove case is to unset the LastLock field,
            //  we have no way of knowing if we will race with a reference count drop
            //  and lose.
            //

            ObReferenceObject( FileObject );

            //
            //  Complete the request, if the don't get back success then
            //  we need to possibly remove the lock that we just
            //  inserted.
            //

            FsRtlCompleteLockIrp(
                LockInfo,
                Context,
                Irp,
                Iosb->Status,
                &NewStatus,
                FileObject );

            if (!NT_SUCCESS(NewStatus) && NT_SUCCESS(Iosb->Status) ) {

                //
                // Irp failed, remove the lock which was added
                //

                FsRtlPrivateRemoveLock (
                    LockInfo,
                    &FileLockInfo,
                    TRUE );
            }

            //
            //  Lift our private reference to the fileobject. This may induce deletion.
            //

            ObDereferenceObject( FileObject );

            Iosb->Status = NewStatus;
        }

        DebugTrace(-1, Dbg, "FsRtlPrivateLock -> %08lx\n", Results);
    }

    //
    //  and return to our caller
    //

    return Results;
}


//
//  Internal Support Routine
//

BOOLEAN
FsRtlPrivateInsertLock (
    IN PLOCK_INFO LockInfo,
    IN PFILE_OBJECT FileObject,
    IN PFILE_LOCK_INFO FileLockInfo
    )

/*++

Routine Description:

    This routine fills in a new lock record of the appropriate type and inserts
    it into the lock information.

Arguments:

    LockInfo - Supplies the lock being modified

    FileObject - The associated file object to update hints in

    FileLockInfo - Supplies the new lock data to add to the lock queue

Return Value:

    BOOLEAN - True if the insert was successful, False if no resources were avaliable
        to complete the operation.

--*/

{
    //
    //  Now add the lock to the appropriate tree.
    //

    if (FileLockInfo->ExclusiveLock) {

        PEX_LOCK ExLock;

        ExLock = FsRtlAllocateExclusiveLock();

        if (ExLock == NULL) {

            return FALSE;
        }

        ExLock->LockInfo = *FileLockInfo;

        FsRtlPrivateInsertExclusiveLock( &LockInfo->LockQueue, ExLock );

        FileObject->LastLock = &ExLock->LockInfo;

    } else {

        PSH_LOCK ShLock;

        ShLock = FsRtlAllocateSharedLock();

        if (ShLock == NULL) {

            return FALSE;
        }

        ShLock->LockInfo = *FileLockInfo;

        if (!FsRtlPrivateInsertSharedLock( &LockInfo->LockQueue, ShLock )) {

            return FALSE;
        }

        FileObject->LastLock = &ShLock->LockInfo;
    }

    //
    //  Fix up the lowest lock offset if need be
    //

    if ((ULONGLONG)FileLockInfo->StartingByte.QuadPart < (ULONGLONG)LockInfo->LowestLockOffset) {

        ASSERT( FileLockInfo->StartingByte.HighPart == 0 );
        LockInfo->LowestLockOffset = FileLockInfo->StartingByte.LowPart;
    }

    return TRUE;
}


//
//  Internal Support Routine
//

BOOLEAN
FsRtlPrivateInsertSharedLock (
    IN PLOCK_QUEUE LockQueue,
    IN PSH_LOCK NewLock
    )

/*++

Routine Description:

    This routine adds a new shared lock record to the File lock's current
    lock queue. Locks are inserted into nodes ordered by their starting byte.

Arguments:

    LockQueue - Supplies the lock queue being modified

    NewLock - Supplies the new shared lock to add to the lock queue

Return Value:

    BOOLEAN - True if the insert was successful, False if no resources were avaliable
        to complete the operation.

--*/
{
    PSINGLE_LIST_ENTRY pLink, Link;
    PRTL_SPLAY_LINKS OverlappedSplayLinks, ParentSplayLinks;
    PLOCKTREE_NODE Node, NextNode;
    PSH_LOCK NextLock;
    BOOLEAN GreaterThan;

    OverlappedSplayLinks = FsRtlFindFirstOverlappingSharedNode( LockQueue->SharedLockTree,
                                                                &NewLock->LockInfo.StartingByte,
                                                                &NewLock->LockInfo.EndingByte,
                                                                &ParentSplayLinks,
                                                                &GreaterThan );

    if (OverlappedSplayLinks == NULL) {

        //
        //  Simple insert case, build a new node
        //

        NextNode = FsRtlAllocateLockTreeNode();

        //
        //  If no resources are avaliable, simply fail now.
        //

        if (NextNode == NULL) {

            return FALSE;
        }

        RtlInitializeSplayLinks(&NextNode->Links);
        NextNode->HoleyNode = FALSE;

        NextNode->Locks.Next = NextNode->Tail.Next = &NewLock->Link;
        NextNode->Extent = (ULONGLONG)NewLock->LockInfo.EndingByte.QuadPart;
        NewLock->Link.Next = NULL;

        if (ParentSplayLinks) {

            //
            //  We have a real parent node in the tree
            //

            if (GreaterThan) {

                ASSERT(RtlLeftChild(ParentSplayLinks) == NULL);
                RtlInsertAsLeftChild(ParentSplayLinks, &NextNode->Links);

            } else {

                ASSERT(RtlRightChild(ParentSplayLinks) == NULL);
                RtlInsertAsRightChild(ParentSplayLinks, &NextNode->Links);
            }

            //
            //  Splay all new nodes in the tree
            //

            LockQueue->SharedLockTree = RtlSplay(&NextNode->Links);

        } else {

            //
            //  First node in the tree
            //

            LockQueue->SharedLockTree = &NextNode->Links;
        }

        return TRUE;
    }

    //
    //  Now we examine the node to see if it is holey as a result of a resource-failed split.
    //  If it is, we must complete the split before adding the new lock.
    //

    Node = CONTAINING_RECORD( OverlappedSplayLinks, LOCKTREE_NODE, Links );

    //
    //  Search down the overlapped node finding the position for the new lock
    //

    for (pLink = &Node->Locks;
         (Link = pLink->Next) != NULL;
         pLink = Link) {

        PSH_LOCK Lock;

        Lock = CONTAINING_RECORD( Link, SH_LOCK, Link );

        //
        //  We sort locks on this list first by starting byte, then by whether the length is zero or not.
        //  This is important so that zero length locks appear prior to non-zero length locks, so that
        //  they are split out of nodes into the tree in the correct order.
        //
        //  if (NewLock->StartingByte <= Lock->StartingByte) ...
        //

        if (((ULONGLONG)NewLock->LockInfo.StartingByte.QuadPart < (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart) ||

            ((ULONGLONG)NewLock->LockInfo.StartingByte.QuadPart == (ULONGLONG)Lock->LockInfo.StartingByte.QuadPart &&
             (NewLock->LockInfo.Length.QuadPart == 0 || Lock->LockInfo.Length.QuadPart != 0))) {

            break;
        }
    }

    //
    //  At this point pLink points to the record that comes right after
    //  the new lock that we're inserting so we can simply push the
    //  newlock into the entrylist
    //

    DebugTrace(0, Dbg, "InsertSharedLock, Insert Before = %08lx\n", Link);

    if (pLink->Next == NULL) {

        //
        //    Adding onto the tail of the list
        //

        Node->Tail.Next = &NewLock->Link;
    }

    NewLock->Link.Next = pLink->Next;
    pLink->Next = &NewLock->Link;

    //
    //  And splay the node we inserted into
    //

    LockQueue->SharedLockTree = RtlSplay(OverlappedSplayLinks);

    if ((ULONGLONG)NewLock->LockInfo.EndingByte.QuadPart > Node->Extent) {

        //
        //  The new lock extends the range of this node, so fix up the extent
        //

        Node->Extent = NewLock->LockInfo.EndingByte.QuadPart;

        //
        //  Walk across the remainder of the tree integrating newly overlapping
        //  nodes into the node we just inserted the new lock into.  Note that
        //  this isn't so much a walk as a repeated examination of our successor's
        //  until one does not overlap (or we hit the end).
        //

        ParentSplayLinks = OverlappedSplayLinks;

        for (OverlappedSplayLinks = RtlRealSuccessor(ParentSplayLinks);
             OverlappedSplayLinks;
             OverlappedSplayLinks = RtlRealSuccessor(ParentSplayLinks)) {

            NextNode = CONTAINING_RECORD( OverlappedSplayLinks, LOCKTREE_NODE, Links );
            NextLock = CONTAINING_RECORD( NextNode->Locks.Next, SH_LOCK, Link );

            if ((ULONGLONG)NextLock->LockInfo.StartingByte.QuadPart > Node->Extent) {

                //
                //  This node is not overlapped, so stop
                //

                break;
            }

            //
            //  If we are intergrating a holey node into a non-holey node, try to split
            //  the node first.  It will be better to get this done with a smaller node
            //  than a big, fully integrated one.  Note that we are guaranteed that the
            //  node will remain a candidate for integration since the first lock on the
            //  node will still be there, and overlaps.
            //

            if (!Node->HoleyNode && NextNode->HoleyNode) {

                FsRtlSplitLocks( NextNode, NULL, NULL, NULL );
            }

            //
            //  Integrate the locks in this node into our list
            //

            Node->Tail.Next->Next = NextNode->Locks.Next;
            Node->Tail.Next = NextNode->Tail.Next;

            if (NextNode->Extent > Node->Extent) {

                //
                //  If the node we just swallowed was (still!) holey, we perhaps made this
                //  node holey too.  The resolution of this is left to the lock split we will
                //  perform after integration is complete.
                //
                //  Note that if the extent of the node we are swallowing is interior
                //  to the current node, we just covered whatever holes it contained.
                //

                if (NextNode->HoleyNode) {

                    Node->HoleyNode = TRUE;
                }

                Node->Extent = NextNode->Extent;
            }

            //
            //  Free the now empty node.
            //

            RtlDeleteNoSplay( OverlappedSplayLinks, &LockQueue->SharedLockTree );
            FsRtlFreeLockTreeNode( NextNode );
        }
    }

    //
    //  Now, perhaps this node is still holey.  For grins lets try one more time to split
    //  this thing apart.
    //

    if (Node->HoleyNode) {

        FsRtlSplitLocks( Node, NULL, NULL, NULL );
    }

    //
    //  And return to our caller
    //

    return TRUE;
}


//
//  Internal Support Routine
//

VOID
FsRtlPrivateInsertExclusiveLock (
    IN PLOCK_QUEUE LockQueue,
    IN PEX_LOCK NewLock
    )

/*++

Routine Description:

    This routine adds a new exclusive lock record to the File lock's current
    lock queue.

Arguments:

    LockQueue - Supplies the lock queue being modified

    NewLock - Supplies the new exclusive lock to add to the lock queue

Return Value:

    None.

--*/

{
    PRTL_SPLAY_LINKS OverlappedSplayLinks, ParentSplayLinks;
    BOOLEAN GreaterThan;

    OverlappedSplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockQueue->ExclusiveLockTree,
                                                                   &NewLock->LockInfo.StartingByte,
                                                                   &NewLock->LockInfo.EndingByte,
                                                                   &ParentSplayLinks,
                                                                   &GreaterThan );

    //
    //  This is the exclusive tree. Nothing can overlap (caller is supposed to insure this) unless
    //  the lock is a zero length lock, in which case we just insert it - still.
    //

    ASSERT(!OverlappedSplayLinks || NewLock->LockInfo.Length.QuadPart == 0);

    //
    //  Simple insert ...
    //

    RtlInitializeSplayLinks(&NewLock->Links);

    if (OverlappedSplayLinks) {

        //
        //  With zero length locks we have OverlappedSplayLinks at the starting point
        //  of a run of zero length locks, so we have to e flexible about where the new
        //  node is inserted.
        //

        if (RtlRightChild(OverlappedSplayLinks)) {

            //
            //  Right slot taken. We can use the left slot or go to the sucessor's left slot
            //

            if (RtlLeftChild(OverlappedSplayLinks)) {

                ASSERT(RtlLeftChild(RtlRealSuccessor(OverlappedSplayLinks)) == NULL);
                RtlInsertAsLeftChild(RtlRealSuccessor(OverlappedSplayLinks), &NewLock->Links);

            } else {

                RtlInsertAsLeftChild(OverlappedSplayLinks, &NewLock->Links);
            }


        } else {

            RtlInsertAsRightChild(OverlappedSplayLinks, &NewLock->Links);
        }

    } else if (ParentSplayLinks) {

        //
        //  We have a real parent node in the tree, and must be at a leaf since
        //  there was no overlap
        //

        if (GreaterThan) {

            ASSERT(RtlLeftChild(ParentSplayLinks) == NULL);
            RtlInsertAsLeftChild(ParentSplayLinks, &NewLock->Links);

        } else {

            ASSERT(RtlRightChild(ParentSplayLinks) == NULL);
            RtlInsertAsRightChild(ParentSplayLinks, &NewLock->Links);
        }

    } else {

        //
        //  First node in the tree
        //

        LockQueue->ExclusiveLockTree = &NewLock->Links;
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Internal Support Routine
//

VOID
FsRtlPrivateCheckWaitingLocks (
    IN PLOCK_INFO   LockInfo,
    IN PLOCK_QUEUE  LockQueue,
    IN KIRQL        OldIrql
    )

/*++

Routine Description:

    This routine checks to see if any of the current waiting locks are now
    be satisfied, and if so it completes their IRPs.

Arguments:

    LockInfo - LockInfo which LockQueue is member of

    LockQueue - Supplies queue which needs to be checked

    OldIrql - Irql to restore when LockQueue is released

Return Value:

    None.

--*/

{
    PSINGLE_LIST_ENTRY *pLink, Link;
    NTSTATUS NewStatus;
    BOOLEAN Result;

    pLink = &LockQueue->WaitingLocks.Next;
    while ((Link = *pLink) != NULL) {

        PWAITING_LOCK WaitingLock;

        PIRP Irp;
        PIO_STACK_LOCATION IrpSp;

        BOOLEAN AccessGranted;

        FILE_LOCK_INFO FileLockInfo;

        //
        //  Get a pointer to the waiting lock record
        //

        WaitingLock = CONTAINING_RECORD( Link, WAITING_LOCK, Link );

        DebugTrace(0, Dbg, "FsRtlCheckWaitingLocks, Loop top, WaitingLock = %08lx\n", WaitingLock);

        //
        //  Get a local copy of the necessary fields we'll need to use
        //

        Irp = WaitingLock->Irp;
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        FileLockInfo.StartingByte  = IrpSp->Parameters.LockControl.ByteOffset;
        FileLockInfo.Length        = *IrpSp->Parameters.LockControl.Length;
        (ULONGLONG)FileLockInfo.EndingByte.QuadPart =
            (ULONGLONG)FileLockInfo.StartingByte.QuadPart + (ULONGLONG)FileLockInfo.Length.QuadPart - 1;

        FileLockInfo.FileObject    = IrpSp->FileObject;
        FileLockInfo.ProcessId     = IoGetRequestorProcess( Irp );
        FileLockInfo.Key           = IrpSp->Parameters.LockControl.Key;
        FileLockInfo.ExclusiveLock = BooleanFlagOn(IrpSp->Flags, SL_EXCLUSIVE_LOCK);

        //
        //  Now case on whether we're trying to take out an exclusive lock or
        //  a shared lock.  And in both cases try to get the appropriate access
        //  For the exclusive case we send in a NULL file object and process
        //  id, this will ensure that the lookup does not give us write
        //  access through an exclusive lock.
        //

        if (FileLockInfo.ExclusiveLock) {

            DebugTrace(0, Dbg, "FsRtlCheckWaitingLocks do we have write access?\n", 0);

            AccessGranted = FsRtlPrivateCheckForExclusiveLockAccess(
                                LockQueue,
                                &FileLockInfo );
        } else {

            DebugTrace(0, Dbg, "FsRtlCheckWaitingLocks do we have read access?\n", 0);

            AccessGranted = FsRtlPrivateCheckForSharedLockAccess(
                                LockQueue,
                                &FileLockInfo );

        }

        //
        //  Now AccessGranted tells us whether we can really get the access for
        //  the range we want.
        //
        //  No matter what happens, this Irp must be completed now - even if we
        //  are resource starved.  User mode deadlock could be induced since there
        //  may no longer be a pending unlock to cause a rescan of the waiting
        //  list.
        //

        if (AccessGranted) {

            DebugTrace(0, Dbg, "FsRtlCheckWaitingLocks now has access\n", 0);

            //
            //  Clear the cancel routine
            //

            IoAcquireCancelSpinLock( &Irp->CancelIrql );
            IoSetCancelRoutine( Irp, NULL );

            //
            //  If the IRP got itself cancelled, it is cancelled and we won't grant it.
            //  The canceller is waiting for the queue spinlock right now.
            //
            
            if (Irp->Cancel) {
                
                AccessGranted = FALSE;
            }
            
            IoReleaseCancelSpinLock( Irp->CancelIrql );

            if (AccessGranted) {
                
                Result = FsRtlPrivateInsertLock( LockInfo, IrpSp->FileObject, &FileLockInfo );

                //
                //  Now we need to remove this granted waiter and complete
                //  it's irp.
                //

                *pLink = Link->Next;
                if (Link == LockQueue->WaitingLocksTail.Next) {
                    LockQueue->WaitingLocksTail.Next = (PSINGLE_LIST_ENTRY) pLink;
                }

                //
                // Release LockQueue and complete this waiter
                //

                FsRtlReleaseLockQueue( LockQueue, OldIrql );

                //
                //  Reference the fileobject over the completion attempt so we can have a
                //  chance to cleanup safely if we fail
                //

                ObReferenceObject( FileLockInfo.FileObject );

                //
                //  Now we can complete the IRP, if we don't get back success
                //  from the completion routine then we remove the lock we just
                //  inserted.
                //

                FsRtlCompleteLockIrp( LockInfo,
                                      WaitingLock->Context,
                                      Irp,
                                      (Result? STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES),
                                      &NewStatus,
                                      FileLockInfo.FileObject );

                if (Result && !NT_SUCCESS(NewStatus)) {

                    //
                    // Irp was not sucessfull, remove lock if it was added.
                    //

                    FsRtlPrivateRemoveLock (
                        LockInfo,
                        &FileLockInfo,
                        FALSE );
                }

                //
                //  Drop our private reference to the fileobject
                //

                ObDereferenceObject( FileLockInfo.FileObject );

                //
                // Re-acquire queue lock
                //

                FsRtlAcquireLockQueue( LockQueue, &OldIrql );

                //
                // Start scan over from begining
                //

                pLink = &LockQueue->WaitingLocks.Next;


                //
                //  Free up pool
                //

                FsRtlFreeWaitingLock( WaitingLock );

                continue;
            }
        }

        DebugTrace( 0, Dbg, "FsRtlCheckWaitingLocks still no access\n", 0);

        //
        // Move to next lock
        //

        pLink = &Link->Next;
    }

    //
    //  And return to our caller
    //

    return;
}


BOOLEAN
FsRtlPrivateCheckForExclusiveLockAccess (
    IN PLOCK_QUEUE LockQueue,
    IN PFILE_LOCK_INFO FileLockInfo
    )
/*++

Routine Description:

    This routine checks to see if the caller can get an exclusive lock on
    the indicated range due to file locks in the passed in lock queue.

    Assumes Lock queue is held by caller

Arguments:

    LockQueue - Queue which needs to be checked for collision

    FileLockInfo - Lock which is being checked


Return Value:

    BOOLEAN - TRUE if the indicated user can place the exclusive lock over the
        entire specified byte range, and FALSE otherwise

--*/

{
    PRTL_SPLAY_LINKS SplayLinks, LastSplayLinks = NULL;
    PLOCKTREE_NODE Node;
    PSH_LOCK ShLock;
    PEX_LOCK ExLock;

    if (LockQueue->SharedLockTree &&
        (SplayLinks = FsRtlFindFirstOverlappingSharedNode( LockQueue->SharedLockTree,
                                                           &FileLockInfo->StartingByte,
                                                           &FileLockInfo->EndingByte,
                                                           &LastSplayLinks, NULL))) {

        Node = CONTAINING_RECORD(SplayLinks, LOCKTREE_NODE, Links);

        //
        //  If this node is holey, we'll have to walk the whole thing.
        //

        if (Node->HoleyNode) {

            ShLock = FsRtlFindFirstOverlapInNode( Node,
                                                  &FileLockInfo->StartingByte,
                                                  &FileLockInfo->EndingByte );

        } else {

            ShLock = CONTAINING_RECORD(Node->Locks.Next, SH_LOCK, Link);
        }

        //
        //  Look for overlap that we care about.  Perhaps no overlap existed in the holey case.
        //

        if (ShLock &&
            (FileLockInfo->Length.QuadPart || ShLock->LockInfo.Length.QuadPart)) {

            //
            //  If we are checking a nonzero extent and overlapped, it is fatal. If we
            //  are checking a zero extent and overlapped a nonzero extent, it is fatal.
            //

            return FALSE;
        }
    }

    if (LastSplayLinks) {

        LockQueue->SharedLockTree = RtlSplay(LastSplayLinks);
        LastSplayLinks = NULL;
    }

    if (LockQueue->ExclusiveLockTree &&
        (SplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockQueue->ExclusiveLockTree,
                                                              &FileLockInfo->StartingByte,
                                                              &FileLockInfo->EndingByte,
                                                              &LastSplayLinks, NULL))) {

        ExLock = CONTAINING_RECORD(SplayLinks, EX_LOCK, Links);

        if (FileLockInfo->Length.QuadPart || ExLock->LockInfo.Length.QuadPart) {

            //
            //  If we are checking a nonzero extent and overlapped, it is fatal. If we
            //  are checking a zero extent and overlapped a nonzero extent, it is fatal.
            //

            return FALSE;
        }
    }

    if (LastSplayLinks) {

        LockQueue->ExclusiveLockTree = RtlSplay(LastSplayLinks);
    }

    //
    //  We searched the entire range without a conflict so we can grant
    //  the exclusive lock
    //

    return TRUE;
}


BOOLEAN
FsRtlPrivateCheckForSharedLockAccess (
    IN PLOCK_QUEUE LockQueue,
    IN PFILE_LOCK_INFO FileLockInfo
    )
/*++

Routine Description:

    This routine checks to see if the caller can get a shared lock on
    the indicated range due to file locks in the passed in lock queue.

    Assumes Lock queue is held by caller

Arguments:

    LockQueue - Queue which needs to be checked for collision

    FileLockInfo - Lock which is being checked

Arguments:

Return Value:

    BOOLEAN - TRUE if the indicated user can place the shared lock over
        entire specified byte range, and FALSE otherwise

--*/

{
    PEX_LOCK Lock;
    PRTL_SPLAY_LINKS SplayLinks, LastSplayLinks;
    BOOLEAN Status = TRUE;

    //
    // If there are no exclusive locks, this is quick ...
    //

    if (LockQueue->ExclusiveLockTree == NULL) {

        return TRUE;
    }

    //
    //  No lock in the shared lock tree can prevent access, so just search the exclusive
    //  tree for conflict.
    //

    for (SplayLinks = FsRtlFindFirstOverlappingExclusiveNode( LockQueue->ExclusiveLockTree,
                                                              &FileLockInfo->StartingByte,
                                                              &FileLockInfo->EndingByte,
                                                              &LastSplayLinks, NULL);
         SplayLinks;
         SplayLinks = RtlRealSuccessor(SplayLinks)) {

        Lock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

        if ((ULONGLONG)Lock->LockInfo.StartingByte.QuadPart > (ULONGLONG)FileLockInfo->EndingByte.QuadPart) {

            //
            //  This node is covering a range greater than the range we care about,
            //  so we're done
            //

            break;
        }

        //
        //  We may not be able to grant the request if the fileobject, processid,
        //  and key do not match.
        //

        if ((Lock->LockInfo.FileObject != FileLockInfo->FileObject) ||
             (Lock->LockInfo.ProcessId != FileLockInfo->ProcessId) ||
             (Lock->LockInfo.Key != FileLockInfo->Key)) {

            //
            //  We have a mismatch between caller and owner. It is ok not to conflict
            //  if the caller and owner will have/have zero length locks (zero length
            //  locks cannot conflict).
            //

            if (FileLockInfo->Length.QuadPart || Lock->LockInfo.Length.QuadPart) {

                Status = FALSE;
                break;
            }
        }
    }

    if (LastSplayLinks) {

        LockQueue->ExclusiveLockTree = RtlSplay(LastSplayLinks);
    }

    //
    //  We searched the entire range without a conflict so we can grant
    //  the shared lock
    //

    return Status;
}


VOID
FsRtlPrivateResetLowestLockOffset (
    PLOCK_INFO LockInfo
    )

/*++

Routine Description:

    This routine resets the lowest lock offset hint in a LOCK_INFO to
    the lowest lock offset currently held by a lock inside of the LOCK_INFO.

Arguments:

    LockInfo - the lock data to operate on

Return Value:

    None

--*/

{
    PEX_LOCK ExLock = NULL;
    PSH_LOCK ShLock = NULL;
    PFILE_LOCK_INFO LowestLockInfo = NULL;
    PRTL_SPLAY_LINKS SplayLinks;
    PLOCKTREE_NODE Node;

    //
    //  Fix up the lowest lock offset if we have non-empty trees and there was
    //  a lock in the low 32 bit region
    //

    if (LockInfo->LowestLockOffset != 0xffffffff &&
        (LockInfo->LockQueue.SharedLockTree != NULL ||
         LockInfo->LockQueue.ExclusiveLockTree != NULL)) {

        //
        //  Grab the lowest nodes in the trees
        //

        if (LockInfo->LockQueue.SharedLockTree) {

            SplayLinks = LockInfo->LockQueue.SharedLockTree;

            while (RtlLeftChild(SplayLinks) != NULL) {

                SplayLinks = RtlLeftChild(SplayLinks);
            }

            Node = CONTAINING_RECORD( SplayLinks, LOCKTREE_NODE, Links );
            ShLock = CONTAINING_RECORD( Node->Locks.Next, SH_LOCK, Link );
        }

        if (LockInfo->LockQueue.ExclusiveLockTree) {

            SplayLinks = LockInfo->LockQueue.ExclusiveLockTree;

            while (RtlLeftChild(SplayLinks) != NULL) {

                SplayLinks = RtlLeftChild(SplayLinks);
            }

            ExLock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );
        }

        //
        //  Figure out which of the lowest locks is actually lowest. We know that one of the lock
        //  trees at least has a lock, so if we have don't have exclusive locks then we do know
        //  we have shared locks ...
        //

        if (ExLock &&
            (!ShLock ||
             (ULONGLONG)ExLock->LockInfo.StartingByte.QuadPart < (ULONGLONG)ShLock->LockInfo.StartingByte.QuadPart)) {

            LowestLockInfo = &ExLock->LockInfo;

        } else {

            LowestLockInfo = &ShLock->LockInfo;
        }

        if (LowestLockInfo->StartingByte.HighPart == 0) {

            LockInfo->LowestLockOffset = LowestLockInfo->StartingByte.LowPart;

        } else {

            LockInfo->LowestLockOffset = 0xffffffff;
        }

    } else {

        //
        //  If there are no locks, set the lock offset high
        //

        LockInfo->LowestLockOffset = 0xffffffff;
    }
}


NTSTATUS
FsRtlPrivateFastUnlockAll (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN MatchKey,
    IN PVOID Context OPTIONAL
    )

/*++

Routine Description:

    This routine performs an Unlock all operation on the current locks
    associated with the specified file lock.  Only those locks with
    a matching file object and process id are freed.  Additionally,
    it is possible to free only those locks which also match a given
    key.

Arguments:

    FileLock - Supplies the file lock being freed.

    FileObject - Supplies the file object associated with the file lock

    ProcessId - Supplies the Process Id assoicated with the locks to be
        freed

    Key - Supplies the Key to use in this operation

    MatchKey - Whether or not the Key must also match for lock to be freed.

    Context - Supplies an optional context to use when completing waiting
        lock irps.

Return Value:

    None

--*/

{
    PLOCK_INFO              LockInfo;
    PLOCK_QUEUE             LockQueue;
    PSINGLE_LIST_ENTRY      *pLink, *SavepLink, Link;
    NTSTATUS                NewStatus;
    KIRQL                   OldIrql;
    LARGE_INTEGER           GlueOffset, EndingDeletedByte;
    BOOLEAN                 UnlockRoutine;
    PSH_LOCK                ShLock;
    PEX_LOCK                ExLock;
    PRTL_SPLAY_LINKS        SplayLinks, SuccessorLinks;
    PLOCKTREE_NODE          Node;


    DebugTrace(+1, Dbg, "FsRtlPrivateFastUnlockAll, FileLock = %08lx\n", FileLock);

    if ((LockInfo = FileLock->LockInformation) == NULL) {

        //
        // No lock information on this FileLock
        //

        DebugTrace(+1, Dbg, "FsRtlPrivateFastUnlockAll, No LockInfo\n", FileLock);
        return STATUS_RANGE_NOT_LOCKED;
    }

    FileObject->LastLock = NULL;

    LockQueue = &LockInfo->LockQueue;

    //
    //  Grab the waiting lock queue spinlock to exclude anyone from messing
    //  with the queue while we're using it
    //

    FsRtlAcquireLockQueue( LockQueue, &OldIrql );

    if (LockQueue->SharedLockTree == NULL && LockQueue->ExclusiveLockTree == NULL) {

        //
        // No locks on this FileLock
        //

        DebugTrace(+1, Dbg, "FsRtlPrivateFastUnlockAll, No LockTrees\n", FileLock);
        FsRtlReleaseLockQueue( LockQueue, OldIrql );

        return STATUS_RANGE_NOT_LOCKED;
    }

    //
    //  Remove all matching locks in the shared lock tree
    //

    if (LockQueue->SharedLockTree != NULL) {

        //
        //  Grab the lowest node in the tree
        //

        SplayLinks = LockQueue->SharedLockTree;

        while (RtlLeftChild(SplayLinks) != NULL) {

            SplayLinks = RtlLeftChild(SplayLinks);
        }

        //
        //  Walk all nodes in the tree
        //

        UnlockRoutine = FALSE;

        for (;
             SplayLinks;
             SplayLinks = SuccessorLinks) {

            Node = CONTAINING_RECORD(SplayLinks, LOCKTREE_NODE, Links );

            //
            //  Save the next node because we may split this node apart in the process
            //  of deleting locks. It would be a waste of time to traverse those split
            //  nodes. The only case in which we will not have traversed the entire list
            //  before doing the split will be if there is an unlock routine attached
            //  to this FileLock in which case we will be restarting the entire scan
            //  anyway.
            //

            SuccessorLinks = RtlRealSuccessor(SplayLinks);

            //
            //  Search down the current lock queue looking for a match on
            //  the file object and process id
            //

            SavepLink = NULL;
            EndingDeletedByte.QuadPart = 0;
            GlueOffset.QuadPart = 0;

            pLink = &Node->Locks.Next;
            while ((Link = *pLink) != NULL) {

                ShLock = CONTAINING_RECORD( Link, SH_LOCK, Link );

                DebugTrace(0, Dbg, "Top of ShLock Loop, Lock = %08lx\n", ShLock );

                if ((ShLock->LockInfo.FileObject == FileObject) &&
                    (ShLock->LockInfo.ProcessId == ProcessId) &&
                    (!MatchKey || ShLock->LockInfo.Key == Key)) {

                    DebugTrace(0, Dbg, "Found one to unlock\n", 0);

                    //
                    //  We have a match so now is the time to delete this lock.
                    //  Save the neccesary information to do the split node check.
                    //  Remove the lock from the list, then call the
                    //  optional unlock routine, then delete the lock.
                    //

                    if (SavepLink == NULL) {

                        //
                        //  Need to remember where the first lock was deleted
                        //

                        SavepLink = pLink;
                    }

                    if ((ULONGLONG)ShLock->LockInfo.EndingByte.QuadPart > (ULONGLONG)EndingDeletedByte.QuadPart) {

                        //
                        //  Need to remember where the last offset affected by deleted locks is
                        //

                        EndingDeletedByte.QuadPart = ShLock->LockInfo.EndingByte.QuadPart;
                    }

                    if (*pLink == Node->Tail.Next) {

                        //
                        //  Deleting the tail node of the list. Safe even if deleting the
                        //  first node since this implies we're also deleting the last node
                        //  in the node which means we'll delete the node ...
                        //

                        Node->Tail.Next = CONTAINING_RECORD( pLink, SINGLE_LIST_ENTRY, Next );
                    }

                    *pLink = Link->Next;

                    if (LockInfo->UnlockRoutine != NULL) {

                        //
                        //  Signal a lock that needs to have a special unlock routine
                        //  called on it. This is complex to deal with since we'll have
                        //  to release the queue, call it, and reacquire - meaning we
                        //  also have to restart. But we still need to reorder the node
                        //  first ...
                        //

                        UnlockRoutine = TRUE;

                        break;
                    }

                    FsRtlFreeSharedLock( ShLock );

                } else {

                    //
                    // Move to next lock
                    //

                    pLink = &Link->Next;
                }

                if (SavepLink == NULL && (ULONGLONG)ShLock->LockInfo.EndingByte.QuadPart > (ULONGLONG)GlueOffset.QuadPart) {

                    //
                    //  Save the max offset until we have deleted our first node
                    //

                    GlueOffset.QuadPart = ShLock->LockInfo.EndingByte.QuadPart;
                }
            }

            if (SavepLink) {

                //
                //  Locks were actually deleted here, so we have to check the state of the node
                //

                if (Node->Locks.Next == NULL) {

                    //
                    //  We have just deleted everything at this node
                    //

                    LockQueue->SharedLockTree = RtlDelete( SplayLinks );

                    FsRtlFreeLockTreeNode( Node );

                } else {

                    //
                    //  Now that we have deleted all matching locks in this node, we do the
                    //  check on the node to split out any now non-overlapping locks. Conceptually,
                    //  we have deleted just one big lock that starts at the starting byte of the
                    //  first deleted lock and extends to the last byte of the last deleted lock.
                    //

                    FsRtlSplitLocks(Node, SavepLink, &EndingDeletedByte, &GlueOffset);
                }
            }

            if (UnlockRoutine) {

                //
                //  We dropped out of the node scan because we had a lock that needs extra
                //  processing during unlock. Do it.
                //

                FsRtlReleaseLockQueue( LockQueue, OldIrql );

                LockInfo->UnlockRoutine( Context, &ShLock->LockInfo );

                FsRtlAcquireLockQueue( LockQueue, &OldIrql );

                FsRtlFreeSharedLock( ShLock );

                UnlockRoutine = FALSE;

                //
                //  We have to restart the scan, because the list may have changed while
                //  we were in the unlock routine. Careful, because the tree may be empty.
                //

                if (SuccessorLinks = LockQueue->SharedLockTree) {

                    while (RtlLeftChild(SuccessorLinks) != NULL) {

                        SuccessorLinks = RtlLeftChild(SuccessorLinks);
                    }
                }
            }
        }
    }

    //
    //  Remove all matching locks in the exclusive lock tree
    //

    if (LockQueue->ExclusiveLockTree != NULL) {

        SplayLinks = LockQueue->ExclusiveLockTree;

        while (RtlLeftChild(SplayLinks) != NULL) {

            SplayLinks = RtlLeftChild(SplayLinks);
        }

        //
        //  Walk all nodes in the tree
        //

        UnlockRoutine = FALSE;

        for (; SplayLinks;
               SplayLinks = SuccessorLinks ) {

            SuccessorLinks = RtlRealSuccessor( SplayLinks );

            ExLock = CONTAINING_RECORD( SplayLinks, EX_LOCK, Links );

            DebugTrace(0, Dbg, "Top of ExLock Loop, Lock = %08lx\n", ExLock );

            if ((ExLock->LockInfo.FileObject == FileObject) &&
                (ExLock->LockInfo.ProcessId == ProcessId) &&
                (!MatchKey || ExLock->LockInfo.Key == Key)) {

                LockQueue->ExclusiveLockTree = RtlDelete( &ExLock->Links );

                if (LockInfo->UnlockRoutine != NULL) {

                    //
                    //  We're dropping out of the node scan because we have a lock
                    //  that needs extra processing during unlock. Do it.
                    //

                    FsRtlReleaseLockQueue( LockQueue, OldIrql );

                    LockInfo->UnlockRoutine( Context, &ExLock->LockInfo );

                    FsRtlAcquireLockQueue( LockQueue, &OldIrql );

                    //
                    //  We have to restart the scan, because the list may have changed while
                    //  we were in the unlock routine. Careful, because the tree may be empty.
                    //

                    if (SuccessorLinks = LockQueue->ExclusiveLockTree) {

                        while (RtlLeftChild( SuccessorLinks ) != NULL) {

                            SuccessorLinks = RtlLeftChild( SuccessorLinks );
                        }
                    }
                }

                FsRtlFreeExclusiveLock( ExLock );
            }
        }
    }

    //
    //  Search down the waiting lock queue looking for a match on the
    //  file object and process id.
    //

    pLink = &LockQueue->WaitingLocks.Next;
    while ((Link = *pLink) != NULL) {

        PWAITING_LOCK WaitingLock;
        PIRP WaitingIrp;
        PIO_STACK_LOCATION WaitingIrpSp;

        WaitingLock = CONTAINING_RECORD( Link, WAITING_LOCK, Link );

        DebugTrace(0, Dbg, "Top of Waiting Loop, WaitingLock = %08lx\n", WaitingLock);

        //
        //  Get a copy of the necessary fields we'll need to use
        //

        WaitingIrp = WaitingLock->Irp;
        WaitingIrpSp = IoGetCurrentIrpStackLocation( WaitingIrp );

        if ((FileObject == WaitingIrpSp->FileObject) &&
            (ProcessId == IoGetRequestorProcess( WaitingIrp )) &&
            (!MatchKey || Key == WaitingIrpSp->Parameters.LockControl.Key)) {

            DebugTrace(0, Dbg, "Found a waiting lock to abort\n", 0);

            //
            //  We now void the cancel routine in the irp
            //

            IoAcquireCancelSpinLock( &WaitingIrp->CancelIrql );
            IoSetCancelRoutine( WaitingIrp, NULL );

            //
            //  If this IRP got itself cancelled, it is cancelled.
            //
            
            if (WaitingIrp->Cancel) {
                
                WaitingIrp = NULL;
            }

            IoReleaseCancelSpinLock( WaitingIrp->CancelIrql );

            if (WaitingIrp) {

                WaitingIrp->IoStatus.Information = 0;

                //
                //  We have a match and the IRP, so now is the time to delete
                //  this waiter. But we must not mess up our link iteration
                //  variable.  We do this by simply starting the iteration over
                //  again, after we delete ourselves.  We also will deallocate
                //  the lock after we delete it.
                //

                *pLink = Link->Next;
                if (Link == LockQueue->WaitingLocksTail.Next) {
                    LockQueue->WaitingLocksTail.Next = (PSINGLE_LIST_ENTRY) pLink;
                }

                FsRtlReleaseLockQueue(LockQueue, OldIrql);

                //
                //  And complete this lock request Irp
                //

                FsRtlCompleteLockIrp( LockInfo,
                                      WaitingLock->Context,
                                      WaitingIrp,
                                      STATUS_RANGE_NOT_LOCKED,
                                      &NewStatus,
                                      NULL );

                //
                // Reaqcuire lock queue spinlock and start over
                //

                FsRtlAcquireLockQueue( LockQueue, &OldIrql );

                //
                // Start over
                //

                pLink = &LockQueue->WaitingLocks.Next;

                //
                // Put memory onto free list
                //

                FsRtlFreeWaitingLock( WaitingLock );
                continue;

            }
        }

        //
        // Move to next lock
        //

        pLink = &Link->Next;
    }

    //
    //  At this point we've gone through unlocking everything. So
    //  now try and release any waiting locks.
    //

    FsRtlPrivateCheckWaitingLocks( LockInfo, LockQueue, OldIrql );

    //
    //  We deleted a (possible) bunch of locks, go repair the lowest lock offset
    //

    FsRtlPrivateResetLowestLockOffset( LockInfo );

    FsRtlReleaseLockQueue( LockQueue, OldIrql );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlFastUnlockAll -> VOID\n", 0);
    return STATUS_SUCCESS;
}


VOID
FsRtlPrivateCancelFileLockIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an irp saved in a
    waiting lock queue

Arguments:

    DeviceObject - Ignored

    Irp - Supplies the Irp being cancelled.  A pointer to the FileLock
        structure for the lock is stored in the information field of the
        irp's iosb.

Return Value:

    none.

--*/

{
    PSINGLE_LIST_ENTRY *pLink, Link;
    PLOCK_INFO  LockInfo;
    PLOCK_QUEUE LockQueue;
    KIRQL       OldIrql;
    NTSTATUS    NewStatus;
    BOOLEAN     CollideCheck = FALSE;


    UNREFERENCED_PARAMETER( DeviceObject );

    //
    //  The information field is used to store a pointer to the file lock
    //  containing the irp
    //

    LockInfo = (PLOCK_INFO) (Irp->IoStatus.Information);

    //
    //  Iterate through the lock queue.
    //

    LockQueue = &LockInfo->LockQueue;

    //
    //  Release the cancel spinlock and lock cancel collide if this is initiated by Io.
    //
    //  We already have the lock queue if this is the race fixup from ourselves,
    //  and the cancel Irql is in the Irp.
    //

    if (DeviceObject) {
        
        IoReleaseCancelSpinLock( Irp->CancelIrql );
        FsRtlAcquireCancelCollide( &OldIrql );

        //
        //  Indicate we will check the collide list first, as the lockqueue itself
        //  may be deallocated in a race with lock teardown.
        //
        
        CollideCheck = TRUE;
        pLink = &FsRtlFileLockCancelCollideList.Next;
    
    } else {

        OldIrql = Irp->CancelIrql;

        //
        //  We will iterate only the locks off of this specific queue.
        //

        pLink = &LockQueue->WaitingLocks.Next;
    }

    while (TRUE) {
        
        //
        //  Iterate through the waiting locks looking for the canceled one.
        //

        while ((Link = *pLink) != NULL) {

            PWAITING_LOCK WaitingLock;

            //
            //  Get a pointer to the waiting lock record
            //

            WaitingLock = CONTAINING_RECORD( Link, WAITING_LOCK, Link );

            DebugTrace(0, Dbg, "FsRtlPrivateCancelFileLockIrp, Loop top, WaitingLock = %08lx\n", WaitingLock);

            if( WaitingLock->Irp != Irp ) {

                pLink = &Link->Next;
                continue;
            }

            //
            //  We've found it -- remove it from the list
            //

            *pLink = Link->Next;
            if (!CollideCheck && Link == LockQueue->WaitingLocksTail.Next) {

                LockQueue->WaitingLocksTail.Next = (PSINGLE_LIST_ENTRY) pLink;
            }

            Irp->IoStatus.Information = 0;

            //
            //  Release the right lock and complete this waiter
            //

            if (CollideCheck) {
                
                FsRtlReleaseCancelCollide( OldIrql );
            
            } else {
                
                FsRtlReleaseLockQueue( LockQueue, OldIrql );
            }

            //
            //  Complete this waiter.  Note we pick the completion routine out
            //  of the waiting lock structure so we can surf over the collided
            //  cancel case.
            //

            FsRtlCompleteLockIrp( WaitingLock,
                                  WaitingLock->Context,
                                  Irp,
                                  STATUS_CANCELLED,
                                  &NewStatus,
                                  NULL );

            //
            //  Free up pool
            //

            FsRtlFreeWaitingLock( WaitingLock );

            //
            // Our job is done!
            //

            return;
        }

        //
        //  Flip over to the lock queue if we didn't find it on the collided list.
        //
        
        if (CollideCheck) {

            CollideCheck = FALSE;
            FsRtlAcquireLockQueueAtDpc( LockQueue );
            FsRtlReleaseCancelCollideFromDpc( OldIrql );
            pLink = &LockQueue->WaitingLocks.Next;

            continue;
        }

        break;
    }

    //
    //  Release lock queue.  This must actually not happen or we will have the
    //  potential to have had the IRP we were looking for come back unaware
    //  we wanted to cancel it.
    //

    ASSERT( FALSE );

    FsRtlReleaseLockQueue(LockQueue, OldIrql);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\fsrtlp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsRtlP.h

Abstract:

    This module defines private part of the File System Rtl component

Author:

    Gary Kimura     [GaryKi]    30-Jul-1990

Revision History:

--*/

#ifndef _FSRTLP_
#define _FSRTLP_

#include <ntos.h>
#include <FsRtl.h>
#include <NtDdFt.h>
#include <zwapi.h>

#define FsRtlAllocatePool(PoolType, NumberOfBytes )                \
    ExAllocatePoolWithTag((POOL_TYPE)((PoolType) | POOL_RAISE_IF_ALLOCATION_FAILURE), \
                          NumberOfBytes,                                      \
                          'trSF')


#define FsRtlAllocatePoolWithQuota(PoolType, NumberOfBytes )           \
    ExAllocatePoolWithQuotaTag((POOL_TYPE)((PoolType) | POOL_RAISE_IF_ALLOCATION_FAILURE), \
                               NumberOfBytes,                                 \
                               'trSF')

#define FsRtlpAllocatePool(a,b)  FsRtlAllocatePoolWithTag((a),(b),MODULE_POOL_TAG)

//
//  The global FsRtl debug level variable, its values are:
//
//      0x00000000      Always gets printed (used when about to bug check)
//
//      0x00000001      Error conditions
//      0x00000002      Debug hooks
//      0x00000004
//      0x00000008
//
//      0x00000010
//      0x00000020
//      0x00000040
//      0x00000080
//
//      0x00000100
//      0x00000200
//      0x00000400
//      0x00000800
//
//      0x00001000
//      0x00002000
//      0x00004000
//      0x00008000
//
//      0x00010000
//      0x00020000
//      0x00040000
//      0x00080000
//
//      0x00100000
//      0x00200000
//      0x00400000
//      0x00800000
//
//      0x01000000
//      0x02000000
//      0x04000000      NotifyChange routines
//      0x08000000      Oplock routines
//
//      0x10000000      Name routines
//      0x20000000      FileLock routines
//      0x40000000      Vmcb routines
//      0x80000000      Mcb routines
//

//
//  Debug trace support
//

#ifdef FSRTLDBG

extern LONG FsRtlDebugTraceLevel;
extern LONG FsRtlDebugTraceIndent;

#define DebugTrace(INDENT,LEVEL,X,Y) {                        \
    LONG _i;                                                  \
    if (((LEVEL) == 0) || (FsRtlDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                     \
        DbgPrint("%08lx:",_i);                                 \
        if ((INDENT) < 0) {                                   \
            FsRtlDebugTraceIndent += (INDENT);                \
        }                                                     \
        if (FsRtlDebugTraceIndent < 0) {                      \
            FsRtlDebugTraceIndent = 0;                        \
        }                                                     \
        for (_i=0; _i<FsRtlDebugTraceIndent; _i+=1) {         \
            DbgPrint(" ");                                     \
        }                                                     \
        DbgPrint(X,Y);                                         \
        if ((INDENT) > 0) {                                   \
            FsRtlDebugTraceIndent += (INDENT);                \
        }                                                     \
    }                                                         \
}

#define DebugDump(STR,LEVEL,PTR) {                            \
    ULONG _i;                                                 \
    VOID FsRtlDump();                                         \
    if (((LEVEL) == 0) || (FsRtlDebugTraceLevel & (LEVEL))) { \
        _i = (ULONG)PsGetCurrentThread();                     \
        DbgPrint("%08lx:",_i);                                 \
        DbgPrint(STR);                                         \
        if (PTR != NULL) {FsRtlDump(PTR);}                    \
        DbgBreakPoint();                                      \
    }                                                         \
}

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}

#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}

#endif // FSRTLDBG


//
//  Miscellaneous support routines
//

VOID
FsRtlInitializeFileLocks (
    VOID
    );

VOID
FsRtlInitializeLargeMcbs (
    VOID
    );

VOID
FsRtlInitializeTunnels(
    VOID
    );

NTSTATUS
FsRtlInitializeWorkerThread (
    VOID
    );

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))

#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)(((Flags) & (SingleFlag)) != 0))

#define SetFlag(F,SF) { \
    (F) |= (SF);        \
}

#define ClearFlag(F,SF) { \
    (F) &= ~(SF);         \
}

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG_PTR)(Ptr)) + 1) & -2) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG_PTR)(Ptr)) + 3) & -4) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG_PTR)(Ptr)) + 7) & -8) \
    )

//
//  This macro takes a ulong and returns its value rounded up to a sector
//  boundary
//

#define SectorAlign(Ptr) (                \
    ((((ULONG_PTR)(Ptr)) + 511) & -512) \
    )

//
//  This macro takes a number of bytes and returns the number of sectors
//  required to contain that many bytes, i.e., it sector aligns and divides
//  by the size of a sector.
//

#define SectorsFromBytes(bytes) ( \
    ((bytes) + 511) / 512         \
    )

//
//  This macro takes a number of sectors and returns the number of bytes
//  contained in that many sectors.
//

#define BytesFromSectors(sectors) ( \
    (sectors) * 512                 \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

#define GET_FAST_IO_DISPATCH(DevObj) \
    ((DevObj)->DriverObject->FastIoDispatch)

#define GET_FS_FILTER_CALLBACKS(DevObj) \
    ((DevObj)->DriverObject->DriverExtension->FsFilterCallbacks)
    
//
//  Macro for validating the FastIo dispatch routines before calling
//  them in the FastIo pass through functions.
//

#define VALID_FAST_IO_DISPATCH_HANDLER(FastIoDispatchPtr, FieldName) \
    (((FastIoDispatchPtr) != NULL) && \
     (((FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
      (FIELD_OFFSET(FAST_IO_DISPATCH, FieldName) + sizeof(VOID *))) && \
     ((FastIoDispatchPtr)->FieldName != NULL))

#define VALID_FS_FILTER_CALLBACK_HANDLER(FsFilterCallbackPtr, FieldName) \
    (((FsFilterCallbackPtr) != NULL) && \
     (((FsFilterCallbackPtr)->SizeOfFsFilterCallbacks) >= \
      (FIELD_OFFSET(FS_FILTER_CALLBACKS, FieldName) + sizeof(VOID *))) && \
     ((FsFilterCallbackPtr)->FieldName != NULL))

#define FSRTL_FILTER_MEMORY_TAG    'gmSF'

typedef struct _FS_FILTER_COMPLETION_NODE {

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;
    PVOID CompletionContext;
    PFS_FILTER_COMPLETION_CALLBACK CompletionCallback;
    
} FS_FILTER_COMPLETION_NODE, *PFS_FILTER_COMPLETION_NODE;

#define FS_FILTER_DEFAULT_STACK_SIZE    15

typedef struct _FS_FILTER_COMPLETION_STACK {

    USHORT StackLength;
    USHORT NextStackPosition;
    PFS_FILTER_COMPLETION_NODE Stack;
    FS_FILTER_COMPLETION_NODE DefaultStack[FS_FILTER_DEFAULT_STACK_SIZE];
    
} FS_FILTER_COMPLETION_STACK, *PFS_FILTER_COMPLETION_STACK;

typedef struct _FS_FILTER_CTRL {

    FS_FILTER_CALLBACK_DATA Data;
    
    ULONG Flags;
    ULONG Reserved;
    
    FS_FILTER_COMPLETION_STACK CompletionStack;
    
} FS_FILTER_CTRL, *PFS_FILTER_CTRL;

//
//  Flag values for FS_FILTER_CTRL
//

#define FS_FILTER_ALLOCATED_COMPLETION_STACK    0x00000001
#define FS_FILTER_USED_RESERVE_POOL             0x00000002
#define FS_FILTER_CHANGED_DEVICE_STACKS         0x00000004

NTSTATUS
FsFilterInit(
    );

NTSTATUS
FsFilterAllocateCompletionStack (
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN BOOLEAN CanFail,
    OUT PULONG AllocationSize
    );

VOID
FsFilterFreeCompletionStack (
    IN PFS_FILTER_CTRL FsFilterCtrl
    );

NTSTATUS
FsFilterCtrlInit (
    IN OUT PFS_FILTER_CTRL FsFilterCtrl,
    IN UCHAR Operation,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT BaseFsDeviceObject,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN CanFail
    );

VOID
FsFilterCtrlFree (
    IN PFS_FILTER_CTRL FsFilterCtrl
    );

#define PUSH_COMPLETION_NODE( completionStack ) \
    (((completionStack)->NextStackPosition < (completionStack)->StackLength ) ? \
        &(completionStack)->Stack[(completionStack)->NextStackPosition++] : \
        (ASSERT( FALSE ), NULL) )

#define POP_COMPLETION_NODE( completionStack ) \
    (ASSERT((completionStack)->NextStackPosition > 0), \
     ((completionStack)->NextStackPosition--))

#define GET_COMPLETION_NODE( completionStack ) \
    (ASSERT((completionStack)->NextStackPosition > 0),\
     (&(completionStack)->Stack[(completionStack)->NextStackPosition-1]))

#define FS_FILTER_HAVE_COMPLETIONS( fsFilterCtrl ) \
    ((fsFilterCtrl)->CompletionStack.NextStackPosition > 0)

VOID
FsFilterGetCallbacks (
    IN UCHAR Operation,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PFS_FILTER_CALLBACK *PreOperationCallback,
    OUT PFS_FILTER_COMPLETION_CALLBACK *PostOperationCallback
    );

NTSTATUS
FsFilterPerformCallbacks (
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN BOOLEAN AllowFilterToFail,
    IN BOOLEAN AllowBaseFsToFail,
    OUT BOOLEAN *BaseFsFailedOp
    );

VOID
FsFilterPerformCompletionCallbacks(
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN NTSTATUS OperationStatus
    );
    

#endif // _FSRTLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\fsrtlpc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsRtlP.c

Abstract:

    This module declares the global data used by the FsRtl Module

Author:

    Gary Kimura     [GaryKi]    30-Jul-1990

Revision History:

--*/

#include "FsRtlP.h"

#define COMPATIBILITY_MODE_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem"
#define COMPATIBILITY_MODE_VALUE_NAME L"Win95TruncatedExtensions"

#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + \
                        sizeof(ULONG)) + 64)

#ifdef FSRTLDBG

LONG FsRtlDebugTraceLevel = 0x0000000f;
LONG FsRtlDebugTraceIndent = 0;

#endif // FSRTLDBG

//
//  Local Support routine
//

NTSTATUS
FsRtlGetCompatibilityModeValue (
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG Value
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlAllocateResource)
#pragma alloc_text(INIT, FsRtlInitSystem)
#pragma alloc_text(INIT, FsRtlGetCompatibilityModeValue)
#endif

//
//  Define the number of resources, a pointer to them and a counter for
//  resource selection.
//

#define FSRTL_NUMBER_OF_RESOURCES (16)

PERESOURCE FsRtlPagingIoResources;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG FsRtlPagingIoResourceSelector = 0;
BOOLEAN FsRtlSafeExtensions = TRUE;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
//  The global static legal ANSI character array.  Wild characters
//  are not considered legal, they should be checked seperately if
//  allowed.
//

#define _FAT_  FSRTL_FAT_LEGAL
#define _HPFS_ FSRTL_HPFS_LEGAL
#define _NTFS_ FSRTL_NTFS_LEGAL
#define _OLE_  FSRTL_OLE_LEGAL
#define _WILD_ FSRTL_WILD_CHARACTER

static const UCHAR LocalLegalAnsiCharacterArray[128] = {

    0                                   ,   // 0x00 ^@
                                   _OLE_,   // 0x01 ^A
                                   _OLE_,   // 0x02 ^B
                                   _OLE_,   // 0x03 ^C
                                   _OLE_,   // 0x04 ^D
                                   _OLE_,   // 0x05 ^E
                                   _OLE_,   // 0x06 ^F
                                   _OLE_,   // 0x07 ^G
                                   _OLE_,   // 0x08 ^H
                                   _OLE_,   // 0x09 ^I
                                   _OLE_,   // 0x0A ^J
                                   _OLE_,   // 0x0B ^K
                                   _OLE_,   // 0x0C ^L
                                   _OLE_,   // 0x0D ^M
                                   _OLE_,   // 0x0E ^N
                                   _OLE_,   // 0x0F ^O
                                   _OLE_,   // 0x10 ^P
                                   _OLE_,   // 0x11 ^Q
                                   _OLE_,   // 0x12 ^R
                                   _OLE_,   // 0x13 ^S
                                   _OLE_,   // 0x14 ^T
                                   _OLE_,   // 0x15 ^U
                                   _OLE_,   // 0x16 ^V
                                   _OLE_,   // 0x17 ^W
                                   _OLE_,   // 0x18 ^X
                                   _OLE_,   // 0x19 ^Y
                                   _OLE_,   // 0x1A ^Z
                                   _OLE_,   // 0x1B ESC
                                   _OLE_,   // 0x1C FS
                                   _OLE_,   // 0x1D GS
                                   _OLE_,   // 0x1E RS
                                   _OLE_,   // 0x1F US
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x20 space
    _FAT_ | _HPFS_ | _NTFS_              ,  // 0x21 !
                            _WILD_| _OLE_,  // 0x22 "
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x23 #
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x24 $
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x25 %
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x26 &
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x27 '
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x28 (
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x29 )
                            _WILD_| _OLE_,  // 0x2A *
            _HPFS_ | _NTFS_       | _OLE_,  // 0x2B +
            _HPFS_ | _NTFS_       | _OLE_,  // 0x2C ,
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x2D -
    _FAT_ | _HPFS_ | _NTFS_              ,  // 0x2E .
    0                                    ,  // 0x2F /
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x30 0
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x31 1
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x32 2
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x33 3
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x34 4
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x35 5
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x36 6
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x37 7
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x38 8
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x39 9
                     _NTFS_              ,  // 0x3A :
            _HPFS_ | _NTFS_       | _OLE_,  // 0x3B ;
                            _WILD_| _OLE_,  // 0x3C <
            _HPFS_ | _NTFS_       | _OLE_,  // 0x3D =
                            _WILD_| _OLE_,  // 0x3E >
                            _WILD_| _OLE_,  // 0x3F ?
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x40 @
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x41 A
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x42 B
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x43 C
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x44 D
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x45 E
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x46 F
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x47 G
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x48 H
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x49 I
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4A J
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4B K
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4C L
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4D M
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4E N
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x4F O
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x50 P
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x51 Q
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x52 R
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x53 S
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x54 T
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x55 U
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x56 V
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x57 W
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x58 X
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x59 Y
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5A Z
            _HPFS_ | _NTFS_       | _OLE_,  // 0x5B [
    0                                    ,  // 0x5C backslash
            _HPFS_ | _NTFS_       | _OLE_,  // 0x5D ]
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5E ^
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x5F _
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x60 `
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x61 a
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x62 b
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x63 c
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x64 d
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x65 e
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x66 f
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x67 g
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x68 h
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x69 i
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6A j
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6B k
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6C l
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6D m
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6E n
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x6F o
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x70 p
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x71 q
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x72 r
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x73 s
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x74 t
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x75 u
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x76 v
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x77 w
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x78 x
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x79 y
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7A z
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7B {
    0                             | _OLE_,  // 0x7C |
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7D }
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7E ~
    _FAT_ | _HPFS_ | _NTFS_       | _OLE_,  // 0x7F 
};

UCHAR const* const FsRtlLegalAnsiCharacterArray = &LocalLegalAnsiCharacterArray[0];

//
//  This routine is called during phase one initialization.
//

BOOLEAN
FsRtlInitSystem (
    )
{
    ULONG i;

    ULONG Value;
    UNICODE_STRING ValueName;

    extern KSEMAPHORE FsRtlpUncSemaphore;

    PAGED_CODE();

    //
    //  Allocate and initialize all the paging Io resources
    //

    FsRtlPagingIoResources = FsRtlAllocatePool( NonPagedPool,
                                                FSRTL_NUMBER_OF_RESOURCES *
                                                sizeof(ERESOURCE) );

    for (i=0; i < FSRTL_NUMBER_OF_RESOURCES; i++) {

        ExInitializeResourceLite( &FsRtlPagingIoResources[i] );
    }

    //
    //  Initialize the global tunneling structures.
    //

    FsRtlInitializeTunnels();

    //
    //  Initialize the global filelock structures.
    //

    FsRtlInitializeFileLocks();

    //
    //  Initialize the global largemcb structures.
    //

    FsRtlInitializeLargeMcbs();

    //
    // Initialize the semaphore used to guard loading of the MUP
    //

    KeInitializeSemaphore( &FsRtlpUncSemaphore, 1, MAXLONG );

    //
    // Pull the bit from the registry telling us whether to do a safe
    // or dangerous extension truncation.
    //

    ValueName.Buffer = COMPATIBILITY_MODE_VALUE_NAME;
    ValueName.Length = sizeof(COMPATIBILITY_MODE_VALUE_NAME) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(COMPATIBILITY_MODE_VALUE_NAME);

    if (NT_SUCCESS(FsRtlGetCompatibilityModeValue( &ValueName, &Value )) &&
        (Value != 0)) {

        FsRtlSafeExtensions = FALSE;
    }

    //
    // Initialize the FsRtl stack overflow work QueueObject and thread.
    //

    if (!NT_SUCCESS(FsRtlInitializeWorkerThread())) {

        return FALSE;
    }

    //
    // Initialize the FsFilter component of FsRtl.
    //

    if (!NT_SUCCESS(FsFilterInit())) {

        return FALSE;
    }
    
    return TRUE;
}


PERESOURCE
FsRtlAllocateResource (
    )

/*++

Routine Description:

    This routine is used to allocate a resource from the FsRtl pool.

Arguments:

Return Value:

    PERESOURCE - A pointer to the provided resource.

--*/

{
    PAGED_CODE();

    return &FsRtlPagingIoResources[ FsRtlPagingIoResourceSelector++ %
                                    FSRTL_NUMBER_OF_RESOURCES];
}


//
//  Local Support routine
//

NTSTATUS
FsRtlGetCompatibilityModeValue (
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG Value
    )

/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the Chicago compatibilitymode information and get the
    value.

Arguments:

    ValueName - the unicode name for the registry value located in the
                double space configuration location of the registry.
    Value   - a pointer to the ULONG for the result.

Return Value:

    NTSTATUS

    If STATUS_SUCCESSFUL is returned, the location *Value will be
    updated with the DWORD value from the registry.  If any failing
    status is returned, this value is untouched.

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    UCHAR Buffer[KEY_WORK_AREA];
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;

    KeyName.Buffer = COMPATIBILITY_MODE_KEY_NAME;
    KeyName.Length = sizeof(COMPATIBILITY_MODE_KEY_NAME) - sizeof(WCHAR);
    KeyName.MaximumLength = sizeof(COMPATIBILITY_MODE_KEY_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Handle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    RequestLength = KEY_WORK_AREA;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

    while (1) {

        Status = ZwQueryValueKey(Handle,
                                 ValueName,
                                 KeyValueFullInformation,
                                 KeyValueInformation,
                                 RequestLength,
                                 &ResultLength);

        ASSERT( Status != STATUS_BUFFER_OVERFLOW );

        if (Status == STATUS_BUFFER_OVERFLOW) {

            //
            // Try to get a buffer big enough.
            //

            if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

                ExFreePool(KeyValueInformation);
            }

            RequestLength += 256;

            KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                  ExAllocatePoolWithTag(PagedPool,
                                                        RequestLength,
                                                        ' taF');

            if (!KeyValueInformation) {
                return STATUS_NO_MEMORY;
            }

        } else {

            break;
        }
    }

    ZwClose(Handle);

    if (NT_SUCCESS(Status)) {

        if (KeyValueInformation->DataLength != 0) {

            PULONG DataPtr;

            //
            // Return contents to the caller.
            //

            DataPtr = (PULONG)
              ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
            *Value = *DataPtr;

        } else {

            //
            // Treat as if no value was found
            //

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

        ExFreePool(KeyValueInformation);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\fsfilter.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FsFilter.c

Abstract:

    This file contains the routines that show certain file system operations
    to file system filters.  File system filters were initially bypassed
    for these operations.
    
Author:

    Molly Brown     [MollyBro]    19-May-2000

Revision History:

--*/

#include "FsRtlP.h"

#define FS_FILTER_MAX_COMPLETION_STACK_SIZE    30

typedef struct _FS_FILTER_RESERVE {

    //
    //  The thread that currently owns the memory.
    //
    
    PETHREAD Owner; 

    //
    //  A stack of completion node bigger than anyone should ever need.
    //

    FS_FILTER_COMPLETION_NODE Stack [FS_FILTER_MAX_COMPLETION_STACK_SIZE];

} FS_FILTER_RESERVE, *PFS_FILTER_RESERVE;

//
//  Note: Events are used to synchronize access to the reserved pool here
//  because using a faster synchronization mechanism (like a FAST_MUTEX)
//  would cause us to raise IRQL to APC_LEVEL while we hold the lock.  This is
//  not acceptable because we call out to the filters while holding this lock
//  and we wouldn't want to be at APC_LEVEL during these calls.
//

KEVENT AcquireOpsEvent;
PFS_FILTER_RESERVE AcquireOpsReservePool;

KEVENT ReleaseOpsEvent;
PFS_FILTER_RESERVE ReleaseOpsReservePool;

NTSTATUS
FsFilterInit(
    )

/*++

Routine Description:

    This routine initializes the reserve pool the FsFilter routine need to use
    when the system is in low memory conditions.
    
Arguments:

    None.

Return Value:

    Returns STATUS_SUCCESS if the initialization was successful, or 
    STATUS_INSUFFICIENT_RESOURCES otherwise.
    
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    
    AcquireOpsReservePool = ExAllocatePoolWithTag( NonPagedPool,
                                                   sizeof( FS_FILTER_RESERVE ),
                                                   FSRTL_FILTER_MEMORY_TAG );

    if (AcquireOpsReservePool == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ReleaseOpsReservePool = ExAllocatePoolWithTag( NonPagedPool,
                                                   sizeof( FS_FILTER_RESERVE ),
                                                   FSRTL_FILTER_MEMORY_TAG );

    if (ReleaseOpsReservePool == NULL) {

        ExFreePoolWithTag( AcquireOpsReservePool,
                           FSRTL_FILTER_MEMORY_TAG );
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    KeInitializeEvent( &AcquireOpsEvent, SynchronizationEvent, TRUE );
    KeInitializeEvent( &ReleaseOpsEvent, SynchronizationEvent, TRUE );

    return Status;    
}

NTSTATUS
FsFilterAllocateCompletionStack (
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN BOOLEAN CanFail,
    OUT PULONG AllocationSize
    )

/*++

Routine Description:

    This routine allocates a completion stack for the given FsFilterCtrl.  If
    this allocation cannot fail, then this routine will wait to allocation
    the memory from the FsFilter reserved pool.

    This routine initialized the appropriate CompletionStack parameters and 
    FsFilterCtrl flags to reflect the allocation made.
    
Arguments:

    FsFilterCtrl - The FsFilterCtrl structure for which the completion stack
        must be allocated.
    CanFail - TRUE if the allocation is allowed to fail, FALSE otherwise.
    AllocationSize - Set to the nuber of bytes of memory allocated for the 
        completion stack for this FsFilterCtrl.
        
Return Value:

    Returns STATUS_SUCCESS if the memory was successfully allocated for the 
    completion stack, or STATUS_INSUFFICIENT_RESOURCES otherwise.
    
--*/

{
    PFS_FILTER_COMPLETION_NODE Stack = NULL;
    PFS_FILTER_RESERVE ReserveBlock = NULL;
    PKEVENT Event = NULL;

    ASSERT( FsFilterCtrl != NULL );
    ASSERT( AllocationSize != NULL );

    *AllocationSize = FsFilterCtrl->CompletionStack.StackLength * 
                      sizeof( FS_FILTER_COMPLETION_NODE );

    Stack = ExAllocatePoolWithTag( NonPagedPool,
                                   *AllocationSize,
                                   FSRTL_FILTER_MEMORY_TAG );
    
    if (Stack == NULL) {

        if (CanFail) {

            return STATUS_INSUFFICIENT_RESOURCES;
            
        } else {

            //
            //  This allocation cannot fail, so get the needed memory from our
            //  private stash of pool.
            //

            switch (FsFilterCtrl->Data.Operation) {
                
            case FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:
            case FS_FILTER_ACQUIRE_FOR_MOD_WRITE:
            case FS_FILTER_ACQUIRE_FOR_CC_FLUSH:

                ReserveBlock = AcquireOpsReservePool;
                Event = &AcquireOpsEvent;
                break;
                
            case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:
            case FS_FILTER_RELEASE_FOR_MOD_WRITE:
            case FS_FILTER_RELEASE_FOR_CC_FLUSH:

                ReserveBlock = ReleaseOpsReservePool;
                Event = &ReleaseOpsEvent;
                break;

            default:

                //
                //  This shouldn't happen since we should always cover all 
                //  possible types of operations in the above cases.
                //
                
                ASSERTMSG( "FsFilterAllocateMemory: Unknown operation type\n", 
                           FALSE );
            }

            //
            //  Wait to get on the appropriate event so that we know the reserve
            //  memory is available for use.
            //
            
            KeWaitForSingleObject( Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            
            //
            //  We've been signaled, so the reserved block is available.
            //

            ReserveBlock->Owner = PsGetCurrentThread();
            Stack = ReserveBlock->Stack;
            SetFlag( FsFilterCtrl->Flags, FS_FILTER_USED_RESERVE_POOL );
        }
    }

    ASSERT( Stack != NULL );

    //
    //  We've now got our block of memory, so initialize the completion stack.
    //

    SetFlag( FsFilterCtrl->Flags, FS_FILTER_ALLOCATED_COMPLETION_STACK );
    FsFilterCtrl->CompletionStack.Stack = Stack;

    return STATUS_SUCCESS;
}

VOID
FsFilterFreeCompletionStack (
    IN PFS_FILTER_CTRL FsFilterCtrl
    )

/*++

Routine Description:

    This routine frees the allocated completion stack in the FsFilterCtrl
    parameter.

Arguments:

    FsFilterCtrl - The FsFilterCtrl structure for which the completion stack
        must be freed.

Return Value:

    None.
    
--*/

{
    PKEVENT Event = NULL;
    PFS_FILTER_RESERVE ReserveBlock = NULL;

    ASSERT( FsFilterCtrl != NULL );
    ASSERT( FlagOn( FsFilterCtrl->Flags, FS_FILTER_ALLOCATED_COMPLETION_STACK ) );

    if (!FlagOn( FsFilterCtrl->Flags, FS_FILTER_USED_RESERVE_POOL )) {

        //
        //  We were able to allocate this from the generate pool of memory,
        //  so just free the memory block used for the completion stack.
        //

        ExFreePoolWithTag( FsFilterCtrl->CompletionStack.Stack,
                           FSRTL_FILTER_MEMORY_TAG );
        
    } else {

        //
        //  This allocation from our private pool stash, so use the operation
        //  to figure out which private stash.
        //

        switch (FsFilterCtrl->Data.Operation) {
        case FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:
        case FS_FILTER_ACQUIRE_FOR_MOD_WRITE:
        case FS_FILTER_ACQUIRE_FOR_CC_FLUSH:

            Event = &AcquireOpsEvent;
            break;
            
        case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:
        case FS_FILTER_RELEASE_FOR_MOD_WRITE:
        case FS_FILTER_RELEASE_FOR_CC_FLUSH:

            Event = &ReleaseOpsEvent;
            break;

        default:

            //
            //  This shouldn't happen since we should always cover all 
            //  possible types of operations in the above cases.
            //
            
            ASSERTMSG( "FsFilterAllocateMemory: Unknown operation type\n", 
                       FALSE );
        }

        ASSERT( Event != NULL );

        //
        //  Clear out the owner of the reserve block before setting the event.
        //
        
        ReserveBlock = CONTAINING_RECORD( FsFilterCtrl->CompletionStack.Stack,
                                          FS_FILTER_RESERVE,
                                          Stack );
        ReserveBlock->Owner = NULL;

        //
        //  Now we are ready to release the reserved block to the next thread
        //  that needs it.
        //
        
        KeSetEvent( Event, IO_NO_INCREMENT, FALSE );
    }
}

NTSTATUS
FsFilterCtrlInit (
    IN OUT PFS_FILTER_CTRL FsFilterCtrl,
    IN UCHAR Operation,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT BaseFsDeviceObject,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN CanFail
    )

/*++

Routine Description:

    This routine initializes the FsFilterCtrl structure used to store the
    contexts and post-operation callbacks for this operation.  If the
    default completion stack is not large enough, this routine will need to
    allocate a completion stack of sufficient size to store all the possible
    contexts and post-operation callbacks.

Arguments:

    FsFilterCtrl - The FsFilterCtrl to initialize.
    Operation - The operation this FsFilterCtrl is going to be used for.
    DeviceObject - The device object to which this operation will be targeted.
    BaseFsDeviceObject - The device object for the base file system at the
        bottom on this filter stack.
    FileObject - The file object to which this operaiton will be targeted.
    CanFail - TRUE if the call can deal with memory allocations failing,
        FALSE otherwise.
        
Return Value:

    STATUS_SUCCESS if the FsFilterCtrl structure could be initialized,
    STATUS_INSUFFICIENT_RESOURCES if the routine cannot allocate the needed
    memory to initialize this structure.

--*/

{
    PFS_FILTER_CALLBACK_DATA Data;
    ULONG AllocationSize;
    NTSTATUS Status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( BaseFsDeviceObject );

    ASSERT( FsFilterCtrl != NULL );
    ASSERT( DeviceObject != NULL );

    FsFilterCtrl->Flags = 0;
    
    Data = &(FsFilterCtrl->Data);
    
    Data->SizeOfFsFilterCallbackData = sizeof( FS_FILTER_CALLBACK_DATA );
    Data->Operation = Operation;
    Data->DeviceObject = DeviceObject;
    Data->FileObject = FileObject;

    //
    //  Since it is possible for a filter to redirect this operation to another
    //  stack, we must assume that the stack size of their device object is
    //  large enough to account for the large stack they would need in the
    //  redirection.  It is the stack size of the top device object that we 
    //  will use to determine the size of our completion stack.
    //
    
    FsFilterCtrl->CompletionStack.StackLength = DeviceObject->StackSize;
    FsFilterCtrl->CompletionStack.NextStackPosition = 0;

    if (FsFilterCtrl->CompletionStack.StackLength > FS_FILTER_DEFAULT_STACK_SIZE) {

        //
        //  The stack isn't big enough, so we must dynamically allocate
        //  the completion stack.  This should happen VERY rarely.
        //

        Status = FsFilterAllocateCompletionStack( FsFilterCtrl,
                                                  CanFail,
                                                  &AllocationSize );

        //
        //  If the above allocation failed and we cannot fail this allocation,
        //  use our private pool stash.
        //

        if (!NT_SUCCESS( Status )) {
            
            ASSERT( CanFail );
            return Status;
        }
            
        ASSERT( FsFilterCtrl->CompletionStack.Stack );
        
    } else {

        //
        //  The default completion noded array allocated for the stack
        //  is large enough, so set Stack to point to that array.
        //

        FsFilterCtrl->CompletionStack.Stack = &(FsFilterCtrl->CompletionStack.DefaultStack[0]);
        AllocationSize = sizeof( FS_FILTER_COMPLETION_NODE ) * FS_FILTER_DEFAULT_STACK_SIZE;
        FsFilterCtrl->CompletionStack.StackLength = FS_FILTER_DEFAULT_STACK_SIZE;
    }
    
    RtlZeroMemory( FsFilterCtrl->CompletionStack.Stack, AllocationSize );

    return Status;
}

VOID
FsFilterCtrlFree (
    IN PFS_FILTER_CTRL FsFilterCtrl
    )

/*++

Routine Description:

    This routine frees any memory associated FsFilterCtrl.  It is possible
    that we had to allocate more memory to deal with a stack that is larger
    than the FS_FILTER_DEFAULT_STACK_SIZE.

Arguments:

    FsFilterCtrl - The FsFilterCtrl structure to free.
    
Return Value:

    NONE

--*/

{
    ASSERT( FsFilterCtrl != NULL );

    ASSERT( FsFilterCtrl->CompletionStack.Stack != NULL );

    if (FlagOn( FsFilterCtrl->Flags, FS_FILTER_ALLOCATED_COMPLETION_STACK )) {
    
        FsFilterFreeCompletionStack( FsFilterCtrl );
    }
}

VOID
FsFilterGetCallbacks (
    IN UCHAR Operation,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PFS_FILTER_CALLBACK *PreOperationCallback,
    OUT PFS_FILTER_COMPLETION_CALLBACK *PostOperationCallback
    )

/*++

Routine Description:

    This routine looks up the PreOperationCallback and the PostOperationCallback
    that the filter has registered for this operation if it has registered one.
Arguments:

    Operation - The current operation of interest.
    DeviceObject - The device object that the filter attached to the file system
        filter stack.
    PreOperationCallback - Set to the PreOperationCallback that the filter
        registered for this operation if one was registered.  Otherwise, this
        is set to NULL.
    PostOperationCallback - Set to the PostOperationCallback that the filter
        registered for this operation if one was registered.  Otherwise, this
        is set to NULL.
        
Return Value:

    NONE

--*/

{

    PFS_FILTER_CALLBACKS FsFilterCallbacks;

    //
    //  Initialize the pre and post callbacks to NULL.  If
    //  we have valid callbacks, these output parameters will
    //  get set to the appropriate function pointers.
    //

    *PreOperationCallback = NULL;
    *PostOperationCallback = NULL;
    
    FsFilterCallbacks = 
        DeviceObject->DriverObject->DriverExtension->FsFilterCallbacks;

    if (FsFilterCallbacks == NULL) {

        //
        //  This filter didn't register any callbacks,
        //  so just return and save switch logic that follows.
        //

        return;
    }

    //
    //  This device did register at least some callbacks, so see 
    //  if there are callbacks for the current operation.
    //

    switch (Operation) {

    case FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreAcquireForSectionSynchronization )) {

            *PreOperationCallback = FsFilterCallbacks->PreAcquireForSectionSynchronization;
            
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostAcquireForSectionSynchronization)) {

            *PostOperationCallback = FsFilterCallbacks->PostAcquireForSectionSynchronization;
            
        }
        
        break;
        
    case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreReleaseForSectionSynchronization )) {

            *PreOperationCallback = FsFilterCallbacks->PreReleaseForSectionSynchronization;
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostReleaseForSectionSynchronization )) {

            *PostOperationCallback = FsFilterCallbacks->PostReleaseForSectionSynchronization;
        }

        break;
        
    case FS_FILTER_ACQUIRE_FOR_MOD_WRITE:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreAcquireForModifiedPageWriter )) {

            *PreOperationCallback = FsFilterCallbacks->PreAcquireForModifiedPageWriter;
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostAcquireForModifiedPageWriter )) {

            *PostOperationCallback = FsFilterCallbacks->PostAcquireForModifiedPageWriter;
        }
        
        break;
        
    case FS_FILTER_RELEASE_FOR_MOD_WRITE:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreReleaseForModifiedPageWriter )) {

            *PreOperationCallback = FsFilterCallbacks->PreReleaseForModifiedPageWriter;
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostReleaseForModifiedPageWriter )) {

            *PostOperationCallback = FsFilterCallbacks->PostReleaseForModifiedPageWriter;
        }
        
        break;
        
    case FS_FILTER_ACQUIRE_FOR_CC_FLUSH:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreAcquireForCcFlush )) {

            *PreOperationCallback = FsFilterCallbacks->PreAcquireForCcFlush;
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostAcquireForCcFlush )) {

            *PostOperationCallback = FsFilterCallbacks->PostAcquireForCcFlush;
        }
        
         break;

    case FS_FILTER_RELEASE_FOR_CC_FLUSH:

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PreReleaseForCcFlush )) {

            *PreOperationCallback = FsFilterCallbacks->PreReleaseForCcFlush;
        }

        if (VALID_FS_FILTER_CALLBACK_HANDLER( FsFilterCallbacks,
                                              PostReleaseForCcFlush )) {

            *PostOperationCallback = FsFilterCallbacks->PostReleaseForCcFlush;
        }
        
        break;

    default:

        ASSERT( FALSE );
        *PreOperationCallback = NULL;
        *PostOperationCallback = NULL;
    }
}

NTSTATUS
FsFilterPerformCallbacks (
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN BOOLEAN AllowFilterToFail,
    IN BOOLEAN AllowBaseFsToFail,
    OUT BOOLEAN *BaseFsFailedOp
    )

/*++

Routine Description:

    This routine calls all the file system filters that have registered
    to see the operation described by the FsFilterCtrl.  If this 
    routine returns a successful Status, the operation should be 
    passed onto the base file system.  If an error Status is returned,
    the caller is responsible for call FsFilterPerformCompletionCallbacks
    to unwind any post-operations that need to be called.

Arguments:

    FsFilterCtrl - The structure describing the control information
        needed to pass this operation to each filter registered to 
        see this operation.

    AllowFilterToFail - TRUE if the filter is allowed to fail this
        operation, FALSE otherwise.

    AllowBaseFsToFail - TRUE if the base file system is allowed to fail this
        operation, FALSE otherwise.

    BaseFsFailedOp - Set to TRUE if the base file system failed
        this operation, FALSE, otherwise.

Return Value:

    STATUS_SUCCESS - All filters that are interested saw the operation
        and none failed this operation.

    STATUS_INSUFFICIENT_RESOURCES - There is not enough memory
        to allocate the completion node, so this operation
        is failing.

    Other error Status - Could be returned from a filter's
        preoperation callback if it wants to fail this operation.
*/

{
    PFS_FILTER_CALLBACK_DATA Data = &(FsFilterCtrl->Data);
    PFS_FILTER_COMPLETION_STACK CompletionStack = &(FsFilterCtrl->CompletionStack);
    PFS_FILTER_CALLBACK PreOperationCallback;
    PFS_FILTER_COMPLETION_CALLBACK PostOperationCallback;
    PFS_FILTER_COMPLETION_NODE CompletionNode;
    PDEVICE_OBJECT CurrentDeviceObject;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN isFilter = TRUE;

    //
    //  We should never be in the scenario where a filter can fail the operation
    //  but the base file system cannot.
    //
    
    ASSERT( !(AllowFilterToFail && !AllowBaseFsToFail) );

    //
    //  Initialize output parameters if present.
    //

    *BaseFsFailedOp = FALSE;
    
    //
    //  As we iterate through the device objects, we use the local
    //  CurrentDeviceObject to iterate through the list because we want
    //  Data->DeviceObject to be set to the last device object when we are
    //  finished iterating.
    //

    CurrentDeviceObject = Data->DeviceObject;

    while (CurrentDeviceObject != NULL) {

        //
        //  First remember if this device object represents a filter or a file 
        //  system.
        //

        if (CurrentDeviceObject->DeviceObjectExtension->AttachedTo != NULL) {

            isFilter = TRUE;

        } else {

            isFilter = FALSE;
        }

        //
        //  Now get the callbacks for this device object
        //
        
        Data->DeviceObject = CurrentDeviceObject;

        FsFilterGetCallbacks( Data->Operation,
                              Data->DeviceObject,
                              &PreOperationCallback,
                              &PostOperationCallback );
        
        //
        //  If this device object has either a callback or completion callback
        //  for this operation, allocate a CompletionNode for it.
        //

        if ((PreOperationCallback == NULL) && (PostOperationCallback == NULL)) {

            //
            //  This device object does not have any clalbacks for this operation
            //  so move onto the next device.
            //

            CurrentDeviceObject = Data->DeviceObject->DeviceObjectExtension->AttachedTo;
            CompletionNode = NULL;
            continue;
            
        } else if (PostOperationCallback != NULL) {

            //
            //  Since there is a PostOperationCallback, we will need to allocate
            //  a CompletionNode for this device.
            //

            CompletionNode = PUSH_COMPLETION_NODE( CompletionStack );
            
            if (CompletionNode == NULL) {

                //
                //  This case shouldn't happen since we should ensure
                //  that our completion stack is large enough when
                //  we first saw this operation.
                //

                if (!AllowFilterToFail) {

                    //
                    //  We cannot fail this operation, so bugcheck.
                    //

                    KeBugCheckEx( FILE_SYSTEM, 0, 0, 0, 0 );
                }
                
                return STATUS_INSUFFICIENT_RESOURCES;
                
            } else {

                CompletionNode->DeviceObject = Data->DeviceObject;
                CompletionNode->FileObject = Data->FileObject;
                CompletionNode->CompletionContext = NULL;
                CompletionNode->CompletionCallback = PostOperationCallback;
            }
            
        } else {

            //
            //  We just have a preoperation, so just set the CompletionNode to
            //  NULL.
            //

            CompletionNode = NULL;
        }

        if (PreOperationCallback != NULL) {

            if (CompletionNode == NULL) {

                Status = PreOperationCallback( Data,
                                               NULL );

            } else {

                Status = PreOperationCallback( Data,
                                               &(CompletionNode->CompletionContext) );
            }
           
            if (!NT_SUCCESS( Status )) {

                //
                //  We hit an error, see if it is allowable to fail.
                //

                if (!AllowFilterToFail && isFilter) {

                    //
                    //  This device object represents a filter and filters
                    //  are not allowed to fail this operation.  Mask the
                    //  error and continue processing.
                    //
                    //  In DBG builds, we will print out an error message to
                    //  notify the filter writer.
                    //
                    
                    KdPrint(( "FS FILTER: FsFilterPerformPrecallbacks -- filter failed operation but this operation is marked to disallow failure, so ignoring.\n" ));
                    
                    Status = STATUS_SUCCESS;
                    
                } else if (!AllowBaseFsToFail && !isFilter) {
                           
                    //
                    //  This device object represents a base file system and 
                    //  base file systems are not allowed to fail this 
                    //  operation.  Mask the error and continue processing.
                    //
                    //  In DBG builds, we will print out an error message to
                    //  notify the file system writer.
                    //
                    
                    KdPrint(( "FS FILTER: FsFilterPerformPrecallbacks -- base file system failed operation but this operation is marked to disallow failure, so ignoring.\n" ));
                    
                    Status = STATUS_SUCCESS;
                    
                } else {

                    //
                    //  This device is allowed to fail this operation, therefore
                    //  return the error.
                    //

                    if (!isFilter) {

                        *BaseFsFailedOp = TRUE;

                    }

                    //
                    //  If we allocated a completion node for this device, 
                    //  pop it now since we don't want to call it when we 
                    //  process the completions.
                    //
                    
                    if (CompletionNode != NULL) {

                        POP_COMPLETION_NODE( CompletionStack );
                    }

                    return Status;
                }
            }
            
        } else {

            //
            //  Don't have to do anything here because the completionNode
            //  is already initialize appropriately.  We will process
            //  the PostOperationCallback later in this routine.
            //

            NOTHING;
        }

        if (CurrentDeviceObject != Data->DeviceObject) {

            //
            //  We change device stacks, therefore we need to mark this FsFilterCtrl
            //  structure so that we reevaluate the base file system parameters
            //  when calling through the legacy FastIO path.
            //

            SetFlag( FsFilterCtrl->Flags, FS_FILTER_CHANGED_DEVICE_STACKS );
            CurrentDeviceObject = Data->DeviceObject;
            
        } else {

            //
            //  We didn't change stacks.
            //

            //
            //  See if this is the base file system.  If it is, we want to make
            //  sure that we don't call the base file system's post-operation
            //  callback because this like the base file system is completing
            //  this operation.  In this case, we will pop the completion node
            //  if one was allocated.
            //

            if (!isFilter && CompletionNode != NULL) {

                POP_COMPLETION_NODE( CompletionStack );
            }

            //
            //  Now, iterate down the device object chain.
            //

            CurrentDeviceObject = CurrentDeviceObject->DeviceObjectExtension->AttachedTo;
        }
    }

    return Status;
}

VOID
FsFilterPerformCompletionCallbacks(
    IN PFS_FILTER_CTRL FsFilterCtrl,
    IN NTSTATUS OperationStatus
    )
{
    PFS_FILTER_CALLBACK_DATA Data = &(FsFilterCtrl->Data);
    PFS_FILTER_COMPLETION_STACK CompletionStack = &(FsFilterCtrl->CompletionStack);
    PFS_FILTER_COMPLETION_NODE CompletionNode;

    while (CompletionStack->NextStackPosition > 0) {

        CompletionNode = GET_COMPLETION_NODE( CompletionStack );
        
        ASSERT( CompletionNode != NULL );

        //
        //  Call the completion callback that the device object registered.
        //

        Data->DeviceObject = CompletionNode->DeviceObject;
        Data->FileObject = CompletionNode->FileObject;

        (CompletionNode->CompletionCallback)( Data,
                                              OperationStatus,
                                              CompletionNode->CompletionContext );

        //
        // Move onto the next CompletionNode.
        //
        
        POP_COMPLETION_NODE( CompletionStack );                                              
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=FsRtl

TARGETNAME=FsRtl
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;..\..\inc

SOURCES=..\DbcsName.c \
        ..\FastIo.c   \
        ..\FaultTol.c \
        ..\FileLock.c \
        ..\Filter.c   \
        ..\FiltrCtx.c \
        ..\FsFilter.c \
        ..\FsRtlPc.c  \
        ..\LargeMcb.c \
        ..\Name.c     \
        ..\Notify.c   \
        ..\Oplock.c   \
        ..\PnP.c      \
        ..\Unc.c      \
        ..\Tunnel.c   \
        ..\StackOvf.c

PRECOMPILED_INCLUDE=..\fsrtlp.h
PRECOMPILED_PCH=fsrtlp.pch
PRECOMPILED_OBJ=fsrtlp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\largemcb.c ===
//depot/Lab01_N/Base/ntos/fsrtl/largemcb.c#5 - edit change 5743 (text)
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LargeMcb.c

Abstract:

    The MCB routines provide support for maintaining an in-memory copy of
    the retrieval mapping information for a file.  The general idea is to
    have the file system lookup the retrieval mapping for a VBN once from
    the disk, add the mapping to the MCB structure, and then utilize the
    MCB to retrieve the mapping for subsequent accesses to the file.  A
    variable of type MCB is used to store the mapping information.

    The routines provided here allow the user to incrementally store some
    or all of the retrieval mapping for a file and to do so in any order.
    That is, the mapping can be inserted to the MCB structure all at once
    starting from the beginning and working to the end of the file, or it
    can be randomly scattered throughout the file.

    The package identifies each contiguous run of sectors mapping VBNs
    and LBNs indenpendent of the order they are added to the MCB
    structure.  For example a user can define a mapping between VBN
    sector 0 and LBN sector 107, and between VBN sector 2 and LBN sector
    109.  The mapping now contains two runs each one sector in length.
    Now if the user adds an additional mapping between VBN sector 1 and
    LBN sector 106 the MCB structure will contain only one run 3 sectors
    in length.

    Concurrent access to the MCB structure is control by this package.

    The following routines are provided by this package:

      o  FsRtlInitializeMcb - Initialize a new MCB structure.  There
         should be one MCB for every opened file.  Each MCB structure
         must be initialized before it can be used by the system.

      o  FsRtlUninitializeMcb - Uninitialize an MCB structure.  This call
         is used to cleanup any anciallary structures allocated and
         maintained by the MCB.  After being uninitialized the MCB must
         again be initialized before it can be used by the system.

      o  FsRtlAddMcbEntry - This routine adds a new range of mappings
         between LBNs and VBNs to the MCB structure.

      o  FsRtlRemoveMcbEntry - This routines removes an existing range of
         mappings between LBNs and VBNs from the MCB structure.

      o  FsRtlLookupMcbEntry - This routine returns the LBN mapped to by
         a VBN, and indicates, in sectors, the length of the run.

      o  FsRtlLookupLastMcbEntry - This routine returns the mapping for
         the largest VBN stored in the structure.

      o  FsRtlLookupLastMcbEntryAndIndex - This routine returns the mapping
         for the largest VBN stored in the structure as well as its index
         Note that calling LookupLastMcbEntry and NumberOfRunsInMcb cannot
         be synchronized except by the caller.

      o  FsRtlNumberOfRunsInMcb - This routine tells the caller total
         number of discontiguous sectors runs stored in the MCB
         structure.

      o  FsRtlGetNextMcbEntry - This routine returns the the caller the
         starting VBN and LBN of a given run stored in the MCB structure.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x80000000)


//
//  Retrieval mapping data structures.  The following two structure together
//  are used to map a Vbn to an Lbn.  It is layed out as follows:
//
//
//  MCB:
//      +----------------+----------------+
//      |    PairCount   |MaximumPairCount|
//      +----------------+----------------+
//      |     Mapping    |    PoolType    |
//      +----------------+----------------+
//
//
//  MAPPING:
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     | : 0
//      +----------------+----------------+
//      |                                 |
//      /                                 /
//      /                                 /
//      |                                 |
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     | : PairCount
//      +----------------+----------------+
//      |                                 |
//      /                                 /
//      /                                 /
//      |                                 |
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     |
//      +----------------+----------------+
//
//                                          : MaximumPairCount
//
//  The pairs from 0 to PairCount - 1 are valid.  Given an index between
//  0 and PairCount - 1 (inclusive) it represents the following Vbn
//  to Lbn mapping information
//
//
//                     { if Index == 0 then 0
//      StartingVbn   {
//                     { if Index <> 0 then NextVbn[i-1]
//
//
//      EndingVbn      = NextVbn[i] - 1
//
//
//      StartingLbn    = Lbn[i]
//
//
//  To compute the mapping of a Vbn to an Lbn the following algorithm
//  is used
//
//      1. search through the pairs until we find the slot "i" that contains
//         the Vbn we after.  Report an error if none if found.
//
//      2. Lbn = StartingLbn + (Vbn - StartingVbn);
//
//  A hole in the allocation (i.e., a sparse allocation) is represented by
//  an Lbn value of -1 (note that is is different than Mcb.c).
//

#define UNUSED_LBN                       (-1)

typedef struct _MAPPING {
    VBN NextVbn;
    LBN Lbn;
} MAPPING;
typedef MAPPING *PMAPPING;

typedef struct _NONOPAQUE_MCB {
    PFAST_MUTEX FastMutex;
    ULONG MaximumPairCount;
    ULONG PairCount;
    POOL_TYPE PoolType;
    PMAPPING Mapping;
} NONOPAQUE_MCB;
typedef NONOPAQUE_MCB *PNONOPAQUE_MCB;

//
//  A macro to return the size, in bytes, of a retrieval mapping structure
//

#define SizeOfMapping(MCB) ((sizeof(MAPPING) * (MCB)->MaximumPairCount))

//
//  The parts of a run can be computed as follows:
//
//
//                StartingVbn(MCB,I)           Mapping[I].NextVbn
//                       |                             |
//                       V                             V
//
//        Run-(I-1)---+ +---------Run-(I)-----------+ +---Run-(I+1)
//
//                       A                         A
//                       |                         |
//                 Mapping[I].Lbn            EndingLbn(MCB,I)
//

#define PreviousEndingVbn(MCB,I) (                      \
    (VBN)((I) == 0 ? 0xffffffff : EndingVbn(MCB,(I)-1)) \
)

#define StartingVbn(MCB,I) (                                \
    (VBN)((I) == 0 ? 0 : (((MCB)->Mapping))[(I)-1].NextVbn) \
)

#define EndingVbn(MCB,I) (                     \
    (VBN)((((MCB)->Mapping)[(I)].NextVbn) - 1) \
)

#define NextStartingVbn(MCB,I) (                                \
    (VBN)((I) >= (MCB)->PairCount ? 0 : StartingVbn(MCB,(I)+1)) \
)




#define PreviousEndingLbn(MCB,I) (                      \
    (LBN)((I) == 0 ? UNUSED_LBN : EndingLbn(MCB,(I)-1)) \
)

#define StartingLbn(MCB,I) (         \
    (LBN)(((MCB)->Mapping)[(I)].Lbn) \
)

#define EndingLbn(MCB,I) (                                       \
    (LBN)(StartingLbn(MCB,I) == UNUSED_LBN ?                     \
          UNUSED_LBN :                                           \
          ((MCB)->Mapping[(I)].Lbn +                             \
           (MCB)->Mapping[(I)].NextVbn - StartingVbn(MCB,I) - 1) \
         )                                                       \
)

#define NextStartingLbn(MCB,I) (                                             \
    (LBN)((I) >= (MCB)->PairCount - 1 ? UNUSED_LBN : StartingLbn(MCB,(I)+1)) \
)

#if 0
LBN
NextStartingLbn(
    PNONOPAQUE_MCB Mcb,
    ULONG I
    )
{
    if ( I >= Mcb->PairCount - 1 ) {
        return (LBN)UNUSED_LBN;
        }
    else {
        return StartingLbn(Mcb,I+1);
        }
}
#endif

#define SectorsWithinRun(MCB,I) (                      \
    (ULONG)(EndingVbn(MCB,I) - StartingVbn(MCB,I) + 1) \
)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('mrSF')

VOID
FsRtlRemoveMcbEntryPrivate (
    IN PNONOPAQUE_MCB OpaqueMcb,
    IN ULONG Vbn,
    IN ULONG SectorCount
    );

//
//  A private routine to search a mapping structure for a Vbn
//

BOOLEAN
FsRtlFindLargeIndex (
    IN PNONOPAQUE_MCB Mcb,
    IN VBN Vbn,
    OUT PULONG Index
    );

VOID
FsRtlAddLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToAddIndex,
    IN ULONG AmountToAdd
    );

VOID
FsRtlRemoveLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToRemoveIndex,
    IN ULONG AmountToRemove
    );

//
//  Some private routines to handle common allocations.
//

#define FsRtlAllocateFirstMapping() \
    (PVOID)ExAllocateFromPagedLookasideList( &FsRtlFirstMappingLookasideList )

#define FsRtlFreeFirstMapping(Mapping) \
    ExFreeToPagedLookasideList( &FsRtlFirstMappingLookasideList, (Mapping) )

#define FsRtlAllocateFastMutex()      \
    (PFAST_MUTEX)ExAllocateFromNPagedLookasideList( &FsRtlFastMutexLookasideList )

#define FsRtlFreeFastMutex(FastMutex) \
    ExFreeToNPagedLookasideList( &FsRtlFastMutexLookasideList, (FastMutex) )

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, FsRtlInitializeLargeMcbs)
#pragma alloc_text(PAGE, FsRtlInitializeMcb)
#pragma alloc_text(PAGE, FsRtlUninitializeMcb)
#endif


//
//  Define a small cache of free mapping pairs structures and also the
//  initial size of the mapping pair
//

#define INITIAL_MAXIMUM_PAIR_COUNT       (15)

PAGED_LOOKASIDE_LIST FsRtlFirstMappingLookasideList;

//
//  The following lookaside is used to keep all the Fast Mutexes we will need to
//  boot contiguous.
//

NPAGED_LOOKASIDE_LIST FsRtlFastMutexLookasideList;


//
//  The following few routines define the small mcb package which is
//  implemented behind everyones back as large mcbs.  The only funny
//  thing we really need to do here is to make sure that unused Lbns
//  get returned as 0 and not -1.  This is the result of an historical
//  difference between the original Mcb and LargeMcb packages.
//

VOID
FsRtlInitializeMcb (
    IN PMCB Mcb,
    IN POOL_TYPE PoolType
    )
{
    PAGED_CODE();

    FsRtlInitializeLargeMcb( (PLARGE_MCB)Mcb,
                             PoolType );

    return;
}

VOID
FsRtlUninitializeMcb (
    IN PMCB Mcb
    )

{
    PAGED_CODE();

    FsRtlUninitializeLargeMcb( (PLARGE_MCB)Mcb );

    return;
}

VOID
FsRtlTruncateMcb (
    IN PMCB Mcb,
    IN VBN Vbn
    )
{
   PAGED_CODE();

   FsRtlTruncateLargeMcb( (PLARGE_MCB)Mcb,
                          (LONGLONG)(Vbn) );

   return;
}

BOOLEAN
FsRtlAddMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    IN LBN Lbn,
    IN ULONG SectorCount
    )

{
    PAGED_CODE();

    return FsRtlAddLargeMcbEntry( (PLARGE_MCB)Mcb,
                                  (LONGLONG)(Vbn),
                                  (LONGLONG)(Lbn),
                                  (LONGLONG)(SectorCount) );
}

VOID
FsRtlRemoveMcbEntry (
    IN PMCB OpaqueMcb,
    IN VBN Vbn,
    IN ULONG SectorCount
    )

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlRemoveMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        FsRtlRemoveMcbEntryPrivate( Mcb,
                                    Vbn,
                                    SectorCount );

    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlRemoveMcbEntry -> VOID\n", 0 );
    }

    return;
}

BOOLEAN
FsRtlLookupMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index OPTIONAL
    )

{
    BOOLEAN Result;
    LONGLONG LiLbn;
    LONGLONG LiSectorCount;

    Result = FsRtlLookupLargeMcbEntry( (PLARGE_MCB)Mcb,
                                        (LONGLONG)(Vbn),
                                        &LiLbn,
                                        ARGUMENT_PRESENT(SectorCount) ? &LiSectorCount : NULL,
                                        NULL,
                                        NULL,
                                        Index );

    if (Result) {
        *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
        if (ARGUMENT_PRESENT(SectorCount)) { 
            *SectorCount = ((ULONG)LiSectorCount); 
        }
    }
    
    return Result;
}

BOOLEAN
FsRtlLookupLastMcbEntry (
    IN PMCB Mcb,
    OUT PVBN Vbn,
    OUT PLBN Lbn
    )

{
    BOOLEAN Result;
    LONGLONG LiVbn;
    LONGLONG LiLbn;

    PAGED_CODE();

    Result = FsRtlLookupLastLargeMcbEntry( (PLARGE_MCB)Mcb,
                                            &LiVbn,
                                            &LiLbn );

    if (Result) {
        *Vbn = ((ULONG)LiVbn);
        *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
    }

    return Result;
}

ULONG
FsRtlNumberOfRunsInMcb (
    IN PMCB Mcb
    )

{
    PAGED_CODE();

    return FsRtlNumberOfRunsInLargeMcb( (PLARGE_MCB)Mcb );
}

BOOLEAN
FsRtlGetNextMcbEntry (
    IN PMCB Mcb,
    IN ULONG RunIndex,
    OUT PVBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount
    )

{
    BOOLEAN Result;
    LONGLONG LiVbn;
    LONGLONG LiLbn;
    LONGLONG LiSectorCount;

    PAGED_CODE();

    Result = FsRtlGetNextLargeMcbEntry( (PLARGE_MCB)Mcb,
                                         RunIndex,
                                         &LiVbn,
                                         &LiLbn,
                                         &LiSectorCount );

    if (Result) {
        *Vbn = ((ULONG)LiVbn);
        *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
        *SectorCount = ((ULONG)LiSectorCount);
    }
    
    return Result;
}


VOID
FsRtlInitializeLargeMcbs (
    VOID
    )

/*++

Routine Description:

    This routine initializes the global portion of the large mcb package
    at system initialization time.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    //  Initialize the lookaside of paged initial mapping arrays.
    //

    ExInitializePagedLookasideList( &FsRtlFirstMappingLookasideList,
                                    NULL,
                                    NULL,
                                    POOL_RAISE_IF_ALLOCATION_FAILURE,
                                    sizeof( MAPPING ) * INITIAL_MAXIMUM_PAIR_COUNT,
                                    'miSF',
                                    4 );

    //
    //  Initialize the Fast Mutex lookaside list.
    //

    ExInitializeNPagedLookasideList( &FsRtlFastMutexLookasideList,
                                     NULL,
                                     NULL,
                                     POOL_RAISE_IF_ALLOCATION_FAILURE,
                                     sizeof( FAST_MUTEX),
                                     'mfSF',
                                     32 );


}


VOID
FsRtlInitializeLargeMcb (
    IN PLARGE_MCB OpaqueMcb,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine initializes a new Mcb structure.  The caller must
    supply the memory for the Mcb structure.  This call must precede all
    other calls that set/query the Mcb structure.

    If pool is not available this routine will raise a status value
    indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to initialize.

    PoolType - Supplies the pool type to use when allocating additional
        internal Mcb memory.

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    DebugTrace(+1, Dbg, "FsRtlInitializeLargeMcb, Mcb = %08lx\n", Mcb );

    //
    //  Preset the following fields to null so we know to deallocate them
    //  during an abnormal termination
    //

    Mcb->FastMutex = NULL;
    Mcb->Mapping = NULL;

    try {

        //
        //  Initialize the fields in the Mcb
        //

        Mcb->FastMutex = FsRtlAllocateFastMutex();

        ExInitializeFastMutex( Mcb->FastMutex );

        Mcb->PairCount = 0;
        Mcb->PoolType = PoolType;

        //
        //  Allocate a new buffer an initial size is one that will hold
        //  16 runs
        //

        if (PoolType == PagedPool) {

            Mcb->Mapping = FsRtlAllocateFirstMapping();

        } else {

            Mcb->Mapping = FsRtlpAllocatePool( Mcb->PoolType, sizeof(MAPPING) * INITIAL_MAXIMUM_PAIR_COUNT );
        }

        //**** RtlZeroMemory( Mcb->Mapping, sizeof(MAPPING) * INITIAL_MAXIMUM_PAIR_COUNT );

        Mcb->MaximumPairCount = INITIAL_MAXIMUM_PAIR_COUNT;

    } finally {

        //
        //  If this is an abnormal termination then we need to deallocate
        //  the FastMutex and/or mapping (but once the mapping is allocated,
        //  we can't raise).
        //

        if (AbnormalTermination()) {

            if (Mcb->FastMutex != NULL) { FsRtlFreeFastMutex( Mcb->FastMutex ); }
        }

        DebugTrace(-1, Dbg, "FsRtlInitializeLargeMcb -> VOID\n", 0 );
    }

    //
    //  And return to our caller
    //

    return;
}


VOID
FsRtlUninitializeLargeMcb (
    IN PLARGE_MCB OpaqueMcb
    )

/*++

Routine Description:

    This routine uninitializes an Mcb structure.  After calling this routine
    the input Mcb structure must be re-initialized before being used again.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to uninitialize.

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    DebugTrace(+1, Dbg, "FsRtlUninitializeLargeMcb, Mcb = %08lx\n", Mcb );

    //
    //  Protect against some user calling us to uninitialize an mcb twice
    //

    if (Mcb->FastMutex == NULL) {

        // ASSERTMSG("Being called to uninitialize an Mcb that is already Uninitialized ", FALSE);

        return;
    }

    //
    //  Deallocate the FastMutex and mapping buffer
    //

    FsRtlFreeFastMutex( Mcb->FastMutex );

    Mcb->FastMutex = NULL;

    if ((Mcb->PoolType == PagedPool) && (Mcb->MaximumPairCount == INITIAL_MAXIMUM_PAIR_COUNT)) {

        FsRtlFreeFirstMapping( Mcb->Mapping );

    } else {

        ExFreePool( Mcb->Mapping );
    }

    //
    //  Now zero our all of the fields in the Mcb
    //

    //**** Mcb->MaximumPairCount = 0;
    //**** Mcb->PairCount = 0;
    //**** Mcb->Mapping = NULL;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlUninitializeLargeMcb -> VOID\n", 0 );

    return;
}


VOID
FsRtlTruncateLargeMcb (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn
    )

/*++

Routine Description:

    This routine truncates an Mcb structure to the specified Vbn.
    After calling this routine the Mcb will only contain mappings
    up to and not including the input vbn.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to truncate.

    LargeVbn - Specifies the last Vbn at which is no longer to be
      mapped.

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);
    ULONG Index;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlTruncateLargeMcb, Mcb = %08lx\n", Mcb );

    ExAcquireFastMutex( Mcb->FastMutex );

    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0) ||
                                                  (Mcb->PairCount == 0) ||
                                                  ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0x7FFFFFFF) &&
                                                   (((ULONG)LargeVbn) == 0xFFFFFFFF))));

    try {

        //
        //  Do a quick test to see if we are truncating the entire Mcb.
        //

        if (Vbn == 0) {

            Mcb->PairCount = 0;

        } else if (Mcb->PairCount > 0) {

            //
            //  Find the index for the entry with the last Vcn we want to keep.
            //  There is nothing to do if the Mcb already ends prior to
            //  this point.
            //

            if (FsRtlFindLargeIndex(Mcb, Vbn - 1, &Index)) {

                //
                //  If this entry currently describes a hole then
                //  truncate to the previous entry.
                //

                if (StartingLbn(Mcb, Index) == UNUSED_LBN) {

                    Mcb->PairCount = Index;

                //
                //  Otherwise we will truncate the Mcb to this point.  Truncate
                //  the number of Vbns of this run if necessary.
                //

                } else {

                    Mcb->PairCount = Index + 1;

                    if (NextStartingVbn(Mcb, Index) > Vbn) {

                        (Mcb->Mapping)[Index].NextVbn = Vbn;
                    }
                }
            }
        }

        //
        //  Now see if we can shrink the allocation for the mapping pairs.
        //  We'll shrink the mapping pair buffer if the new pair count will
        //  fit within a quarter of the current maximum pair count and the
        //  current maximum is greater than the initial pair count.
        //

        if ((Mcb->PairCount < (Mcb->MaximumPairCount / 4)) &&
            (Mcb->MaximumPairCount > INITIAL_MAXIMUM_PAIR_COUNT)) {

            ULONG NewMax;
            PMAPPING Mapping;

            //
            //  We need to allocate a new mapping so compute a new maximum pair
            //  count.  We'll allocate double the current pair count, but never
            //  less than the initial pair count.
            //

            NewMax = Mcb->PairCount * 2;

            if (NewMax < INITIAL_MAXIMUM_PAIR_COUNT) {
                NewMax = INITIAL_MAXIMUM_PAIR_COUNT;
            }

            //
            //  Be careful to trap failures due to resource exhaustion.
            //
                
            try {
                    
                if (NewMax == INITIAL_MAXIMUM_PAIR_COUNT && Mcb->PoolType == PagedPool) {

                    Mapping = FsRtlAllocateFirstMapping();

                } else {
            
                    Mapping = FsRtlpAllocatePool( Mcb->PoolType, sizeof(MAPPING) * NewMax );
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {

                  Mapping = NULL;
            }

            //
            //  Now check if we really got a new buffer
            //

            if (Mapping != NULL) {

                //
                //  Now copy over the old mapping to the new buffer
                //

                RtlCopyMemory( Mapping, Mcb->Mapping, sizeof(MAPPING) * Mcb->PairCount );

                //
                //  Deallocate the old buffer.  This should never be the size of an
                //  initial mapping ...
                //

                ExFreePool( Mcb->Mapping );

                //
                //  And set up the new buffer in the Mcb
                //

                Mcb->Mapping = Mapping;
                Mcb->MaximumPairCount = NewMax;
            }
        }

    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlTruncateLargeMcb -> VOID\n", 0 );

    return;
}


NTKERNELAPI
VOID
FsRtlResetLargeMcb (
    IN PLARGE_MCB OpaqueMcb,
    IN BOOLEAN SelfSynchronized
    )

/*++

Routine Description:

    This routine truncates an Mcb structure to contain zero mapping
    pairs.  It does not shrink the mapping pairs array.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to truncate.

    SelfSynchronized - Indicates whether the caller is already synchronized
        with respect to the Mcb.

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    if (SelfSynchronized) {
        
        //
        //  If we are self-synchronized, then all we do is clear out the 
        //  current mapping pair count.
        //
        
        Mcb->PairCount = 0;
    
    } else {
        
        //
        //  Since we are not self-synchronized, we must serialize access to
        //  the Mcb before clearing the pair count
        //
        
        ExAcquireFastMutex( Mcb->FastMutex );
        Mcb->PairCount = 0;
        ExReleaseFastMutex( Mcb->FastMutex );
    
    }

    return;
}


BOOLEAN
FsRtlAddLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    IN LONGLONG LargeLbn,
    IN LONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine is used to add a new mapping of VBNs to LBNs to an existing
    Mcb. The information added will map

        Vbn to Lbn,

        Vbn+1 to Lbn+1,...

        Vbn+(SectorCount-1) to Lbn+(SectorCount-1).

    The mapping for the VBNs must not already exist in the Mcb.  If the
    mapping continues a previous run, then this routine will actually coalesce
    them into 1 run.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

    An input Lbn value of zero is illegal (i.e., the Mcb structure will never
    map a Vbn to a zero Lbn value).

Arguments:

    OpaqueMcb - Supplies the Mcb in which to add the new mapping.

    Vbn - Supplies the starting Vbn of the new mapping run to add to the Mcb.

    Lbn - Supplies the starting Lbn of the new mapping run to add to the Mcb.

    SectorCount - Supplies the size of the new mapping run (in sectors).

Return Value:

    BOOLEAN - TRUE if the mapping was added successfully (i.e., the new
        Vbns did not collide with existing Vbns), and FALSE otherwise.  If
        FALSE is returned then the Mcb is not changed.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);
    LBN Lbn = ((ULONG)LargeLbn);
    ULONG SectorCount = ((ULONG)LargeSectorCount);

    ULONG Index;

    VBN LastVbn;

    BOOLEAN Result;

    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeVbn)->HighPart == 0);
    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeLbn)->HighPart == 0);
    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeSectorCount)->HighPart == 0);

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlAddLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " Lbn         = %08lx\n", Lbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        if (FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

            ULONG EndVbn = Vbn + SectorCount - 1;
            ULONG EndIndex;

            //
            //  First check the case where we are adding to an existing mcb run
            //  and if so then we will modify the insertion to complete the run
            //
            //      --ExistingRun--|      ==becomes==>  --ExistingRun--|
            //              |--NewRun--|                               |---|
            //
            //      --ExistingRun----|    ==becomes==> a noop
            //          |--NewRun--|
            //

            if (StartingLbn(Mcb, Index) != UNUSED_LBN) {

                //
                //  Check that the Lbn's line up between the new and existing run
                //

                if (Lbn != (StartingLbn(Mcb, Index) + (Vbn - StartingVbn(Mcb, Index)))) {

                    //
                    //  Let our caller know we couldn't insert the run.
                    //

                    try_return(Result = FALSE);
                }

                //
                //  Check if the new run is contained in the existing run
                //

                if (EndVbn <= EndingVbn(Mcb, Index)) {

                    //
                    //  Do nothing because the run is contained within the existing run
                    //

                    try_return(Result = TRUE);
                }

                //
                //  Otherwise we will simply trim off the request for the new run
                //  to not overlap with the existing run
                //

                Vbn = NextStartingVbn(Mcb, Index);
                Lbn = EndingLbn(Mcb, Index) + 1;

                ASSERT(EndVbn >= Vbn);

                SectorCount = EndVbn - Vbn + 1;

            //
            //  At this point the new run start in a hole, now check that if
            //  crosses into a non hole and if so then adjust new run to fit
            //  in the hole
            //
            //
            //            |--ExistingRun--  ==becomes==>        |--ExistingRun--
            //      |--NewRun--|                          |--New|
            //

            } else if (FsRtlFindLargeIndex(Mcb, EndVbn, &EndIndex) && (Index == (EndIndex-1))) {

                //
                //  Check that the Lbn's line up in the overlap
                //

                if (StartingLbn(Mcb, EndIndex) != Lbn + (StartingVbn(Mcb, EndIndex) - Vbn)) {

                    //
                    //  Let our caller know we couldn't insert the run.
                    //

                    try_return(Result = FALSE);
                }

                //
                //  Truncate the sector count to go up to but not include
                //  the existing run
                //

                SectorCount = StartingVbn(Mcb, EndIndex) - Vbn;
            }
        }

        //
        //  Find the index for the starting Vbn of our new run, if there isn't
        //  a hole found then index will be set to paircount.
        //

        if (((Index = Mcb->PairCount) == 0) ||
            (PreviousEndingVbn(Mcb,Index)+1 <= Vbn) ||
            !FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

            //
            //  We didn't find a mapping, therefore this new mapping must
            //  go on at the end of the current mapping.
            //
            //  See if we can just grow the last mapping in the current mcb.
            //  We can grow the last entry if (1) the Vbns follow on, and (2)
            //  the Lbns follow on.  We can only grow the last mapping if the
            //  index is not 0.
            //

            if ((Index != 0) &&
                (PreviousEndingVbn(Mcb,Index) + 1 == Vbn) &&
                (PreviousEndingLbn(Mcb,Index) + 1 == Lbn)) {

                //
                //      --LastRun--|---NewRun--|
                //

                //
                //  Extend the last run in the mcb
                //

                DebugTrace( 0, Dbg, "Continuing last run\n", 0);

                (Mcb->Mapping)[Mcb->PairCount-1].NextVbn += SectorCount;

                try_return (Result = TRUE);
            }

            //
            //  We couldn't grow the last mapping, now check to see if
            //  this is a continuation of the last Vbn (i.e., there isn't
            //  going to be a hole in the mapping).  Or if this is the first
            //  run in the mapping
            //

            if ((Vbn == 0) ||
                (PreviousEndingVbn(Mcb,Index) + 1 == Vbn)) {

                //
                //      --LastRun--||---NewRun--|
                //
                //      0:|--NewRun--|
                //

                //
                //  We only need to add one more run to the mcb, so make sure
                //  there is enough room for one.
                //

                DebugTrace( 0, Dbg, "Adding new contiguous last run\n", 0);

                FsRtlAddLargeEntry( Mcb, Index, 1 );

                //
                //  Add the new mapping
                //

                (Mcb->Mapping)[Index].Lbn = Lbn;
                (Mcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

                try_return (Result = TRUE);
            }

            //
            //  If we reach this point then there is going to be a hole in the
            //  mapping. and the mapping gets appended to the end of the current
            //  allocation.  So need to make room for two more runs in the mcb.
            //

            //
            //      --LastRun--|   hole   |---NewRun--|
            //
            //      0:  hole  |--NewRun--|
            //

            DebugTrace( 0, Dbg, "Adding new noncontiguous last run\n", 0);

            FsRtlAddLargeEntry( Mcb, Index, 2 );

            //
            //  Add the hole
            //

            (Mcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;
            (Mcb->Mapping)[Index].NextVbn = Vbn;

            //
            //  Add the new mapping
            //

            (Mcb->Mapping)[Index+1].Lbn = Lbn;
            (Mcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

            try_return (Result = TRUE);
        }

        //
        //  We found an index for the Vbn therefore we must be trying
        //  to fill up a hole in the mcb.  So first we need to check to make
        //  sure there really is a hole to be filled
        //

        LastVbn = Vbn + SectorCount - 1;

        if ((StartingLbn(Mcb,Index) == UNUSED_LBN) &&
            (StartingVbn(Mcb,Index) <= Vbn) && (LastVbn <= EndingVbn(Mcb,Index))) {

            //
            //  The mapping fits in this hole, but now here are the following
            //  cases we must consider for the new mapping
            //

            if ((StartingVbn(Mcb,Index) < Vbn) && (LastVbn < EndingVbn(Mcb,Index))) {

                //  Leaves a hole are both ends
                //
                //  --PreviousRun--|  hole  |--NewRun--|  hole  |--FollowingRun--
                //
                //  0:  hole  |--NewRun--|  hole  |--FollowingRun--
                //

                DebugTrace( 0, Dbg, "Hole at both ends\n", 0);

                //
                //  Make room for two more entries.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 2 );

                //
                //  Add the first hole
                //

                (Mcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;
                (Mcb->Mapping)[Index].NextVbn = Vbn;

                //
                //  Add the new mapping
                //

                (Mcb->Mapping)[Index+1].Lbn = Lbn;
                (Mcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

                //
                //  The second hole is already set up by the add entry call, because
                //  that call just shift over the original hole to that slot
                //

                try_return (Result = TRUE);
            }

            if ((StartingVbn(Mcb,Index) == Vbn) && (LastVbn < EndingVbn(Mcb,Index))) {

                if (PreviousEndingLbn(Mcb,Index) + 1 == Lbn) {

                    //
                    //  Leaves a hole at the rear, and continues the earlier run
                    //
                    //  --PreviousRun--|--NewRun--|  hole  |--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at rear and continue\n", 0);

                    //
                    //  We just need to extend the previous run
                    //

                    (Mcb->Mapping)[Index-1].NextVbn += SectorCount;

                    try_return (Result = TRUE);

                } else {

                    //
                    //  Leaves a hole at the rear, and does not continue the
                    //  earlier run.  As occurs if index is zero.
                    //
                    //  --PreviousRun--||--NewRun--|  hole  |--FollowingRun--
                    //
                    //  0:|--NewRun--|  hole  |--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at rear and not continue\n", 0);

                    //
                    //  Make room for one more entry.  The NextVbn field of the
                    //  one we're shifting remains valid.
                    //

                    FsRtlAddLargeEntry( Mcb, Index, 1 );

                    //
                    //  Add the new mapping
                    //

                    (Mcb->Mapping)[Index].Lbn = Lbn;
                    (Mcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

                    //
                    //  The hole is already set up by the add entry call, because
                    //  that call just shift over the original hole to that slot
                    //

                    try_return (Result = TRUE);
                }
            }

            if ((StartingVbn(Mcb,Index) < Vbn) && (LastVbn == EndingVbn(Mcb,Index))) {

                if (NextStartingLbn(Mcb,Index) == Lbn + SectorCount) {

                    //
                    //  Leaves a hole at the front, and continues the following run
                    //
                    //  --PreviousRun--|  hole  |--NewRun--|--FollowingRun--
                    //
                    //  0:  hole  |--NewRun--|--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at front and continue\n", 0);

                    //
                    //  We just need to extend the following run
                    //

                    (Mcb->Mapping)[Index].NextVbn = Vbn;
                    (Mcb->Mapping)[Index+1].Lbn = Lbn;

                    try_return (Result = TRUE);

                } else {

                    //
                    //  Leaves a hole at the front, and does not continue the following
                    //  run
                    //
                    //  --PreviousRun--|  hole  |--NewRun--||--FollowingRun--
                    //
                    //  0:  hole  |--NewRun--||--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at front and not continue\n", 0);

                    //
                    //  Make room for one more entry.  The NextVbn field of the
                    //  one we're shifting remains valid.
                    //

                    FsRtlAddLargeEntry( Mcb, Index, 1 );

                    //
                    //  Add the hole
                    //

                    (Mcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;
                    (Mcb->Mapping)[Index].NextVbn = Vbn;

                    //
                    //  Add the new mapping
                    //

                    (Mcb->Mapping)[Index+1].Lbn = Lbn;

                    try_return (Result = TRUE);
                }

            }

            if ((PreviousEndingLbn(Mcb,Index) + 1 == Lbn) &&
                (NextStartingLbn(Mcb,Index) == Lbn + SectorCount)) {

                //
                //  Leaves no holes, and continues both runs
                //
                //  --PreviousRun--|--NewRun--|--FollowingRun--
                //

                DebugTrace( 0, Dbg, "No holes, and continues both runs\n", 0);

                //
                //  We need to collapse the current index and the following index
                //  but first we copy the NextVbn of the follwing run into
                //  the NextVbn field of the previous run to so it all becomes
                //  one run
                //

                (Mcb->Mapping)[Index-1].NextVbn = (Mcb->Mapping)[Index+1].NextVbn;

                FsRtlRemoveLargeEntry( Mcb, Index, 2 );

                try_return (Result = TRUE);
            }

            if (NextStartingLbn(Mcb,Index) == Lbn + SectorCount) {

                //
                //  Leaves no holes, and continues only following run
                //
                //  --PreviousRun--||--NewRun--|--FollowingRun--
                //
                //  0:|--NewRun--|--FollowingRun--
                //

                DebugTrace( 0, Dbg, "No holes, and continues following\n", 0);

                //
                //  This index is going away so we need to stretch the
                //  following run to meet up with the previous run
                //

                (Mcb->Mapping)[Index+1].Lbn = Lbn;

                FsRtlRemoveLargeEntry( Mcb, Index, 1 );

                try_return (Result = TRUE);
            }

            if (PreviousEndingLbn(Mcb,Index) + 1 == Lbn) {

                //
                //  Leaves no holes, and continues only earlier run
                //
                //  --PreviousRun--|--NewRun--||--FollowingRun--
                //

                DebugTrace( 0, Dbg, "No holes, and continues earlier\n", 0);

                //
                //  This index is going away so we need to stretch the
                //  previous run to meet up with the following run
                //

                (Mcb->Mapping)[Index-1].NextVbn = (Mcb->Mapping)[Index].NextVbn;

                FsRtlRemoveLargeEntry( Mcb, Index, 1 );

                try_return (Result = TRUE);
            }

            //
            //  Leaves no holes, and continues neither run
            //
            //      --PreviousRun--||--NewRun--||--FollowingRun--
            //
            //      0:|--NewRun--||--FollowingRun--
            //

            DebugTrace( 0, Dbg, "No holes, and continues none\n", 0);

            (Mcb->Mapping)[Index].Lbn = Lbn;

            try_return (Result = TRUE);
        }

        //
        //  We tried to overwrite an existing mapping so we'll have to
        //  tell our caller that it's not possible
        //

        Result = FALSE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlAddLargeMcbEntry -> %08lx\n", Result );
    }

    return Result;
}


VOID
FsRtlRemoveLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    IN LONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine removes a mapping of VBNs to LBNs from an Mcb.  The mappings
    removed are for

        Vbn,

        Vbn+1, to

        Vbn+(SectorCount-1).

    The operation works even if the mapping for a Vbn in the specified range
    does not already exist in the Mcb.  If the specified range of Vbn includes
    the last mapped Vbn in the Mcb then the Mcb mapping shrinks accordingly.

    If pool is not available to store the information this routine will raise
    a status value indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies the Mcb from which to remove the mapping.

    Vbn - Supplies the starting Vbn of the mappings to remove.

    SectorCount - Supplies the size of the mappings to remove (in sectors).

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);
    ULONG SectorCount = ((ULONG)LargeSectorCount);

    PAGED_CODE();

    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeVbn)->HighPart == 0);

    DebugTrace(+1, Dbg, "FsRtlRemoveLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        FsRtlRemoveMcbEntryPrivate( Mcb, Vbn, SectorCount );

    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlRemoveLargeMcbEntry -> VOID\n", 0 );
    }

    return;
}


BOOLEAN
FsRtlLookupLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn OPTIONAL,
    OUT PLONGLONG LargeSectorCount OPTIONAL,
    OUT PLONGLONG LargeStartingLbn OPTIONAL,
    OUT PLONGLONG LargeCountFromStartingLbn OPTIONAL,
    OUT PULONG Index OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves the mapping of a Vbn to an Lbn from an Mcb.
    It indicates if the mapping exists and the size of the run.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Supplies the Vbn to lookup.

    Lbn - Receives the Lbn corresponding to the Vbn.  A value of -1 is
        returned if the Vbn does not have a corresponding Lbn.

    SectorCount - Receives the number of sectors that map from the Vbn to
        contiguous Lbn values beginning with the input Vbn.

    Index - Receives the index of the run found.

Return Value:

    BOOLEAN - TRUE if the Vbn is within the range of VBNs mapped by the
        MCB (even if it corresponds to a hole in the mapping), and FALSE
        if the Vbn is beyond the range of the MCB's mapping.

        For example, if an MCB has a mapping for VBNs 5 and 7 but not for
        6, then a lookup on Vbn 5 or 7 will yield a non zero Lbn and a sector
        count of 1.  A lookup for Vbn 6 will return TRUE with an Lbn value of
        0, and lookup for Vbn 8 or above will return FALSE.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    BOOLEAN Result;

    ULONG LocalIndex;

    DebugTrace(+1, Dbg, "FsRtlLookupLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, "  LargeVbn.LowPart = %08lx\n", LargeVbn.LowPart );

    ExAcquireFastMutex( Mcb->FastMutex );

    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0) ||
                                                  (Mcb->PairCount == 0) ||
                                                  ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0x7FFFFFFF) &&
                                                   (((ULONG)LargeVbn) == 0xFFFFFFFF))));

    try {

        if (!FsRtlFindLargeIndex(Mcb, ((ULONG)LargeVbn), &LocalIndex)) {

            try_return (Result = FALSE);
        }

        //
        //  Compute the lbn for corresponding to the vbn, the value is the
        //  starting lbn of the run plus the number of sectors offset into the
        //  run.  But if it's a hole then the sector Lbn is zero.
        //

        if (ARGUMENT_PRESENT(LargeLbn)) {

            if (StartingLbn(Mcb,LocalIndex) == UNUSED_LBN) {

                *LargeLbn = UNUSED_LBN;

            } else {

                *LargeLbn = StartingLbn(Mcb,LocalIndex) + (((ULONG)LargeVbn) - StartingVbn(Mcb,LocalIndex));
            }
        }

        //
        //  If there sector count argument is present then we'll return the number
        //  of sectors remaing in the run.
        //

        if (ARGUMENT_PRESENT(LargeSectorCount)) {

            *LargeSectorCount = EndingVbn(Mcb,LocalIndex) - ((ULONG)LargeVbn) + 1;
        }

        //
        //  Compute the starting lbn for corresponding to the start of the run, the value is the
        //  starting lbn of the run.  But if it's a hole then the sector Lbn is zero.
        //

        if (ARGUMENT_PRESENT(LargeStartingLbn)) {

            if (StartingLbn(Mcb,LocalIndex) == UNUSED_LBN) {

                *LargeStartingLbn = UNUSED_LBN;

            } else {

                *LargeStartingLbn = StartingLbn(Mcb,LocalIndex);
            }
        }

        //
        //  If there sector count argument is present then we'll return the number
        //  of sectors in the run.
        //

        if (ARGUMENT_PRESENT(LargeCountFromStartingLbn)) {

            *LargeCountFromStartingLbn = EndingVbn(Mcb,LocalIndex) - StartingVbn(Mcb,LocalIndex) + 1;
        }

        //
        //  If the caller want to know the Index number, fill it in.
        //

        if (ARGUMENT_PRESENT(Index)) {

            *Index = LocalIndex;
        }

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlLookupLargeMcbEntry -> %08lx\n", Result );
    }

    return Result;
}


BOOLEAN
FsRtlLookupLastLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    OUT PLONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn
    )

/*++

Routine Description:

    This routine retrieves the last Vbn to Lbn mapping stored in the Mcb.
    It returns the mapping for the last sector or the last run in the
    Mcb.  The results of this function is useful when extending an existing
    file and needing to a hint on where to try and allocate sectors on the
    disk.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Receives the last Vbn value mapped.

    Lbn - Receives the Lbn corresponding to the Vbn.

Return Value:

    BOOLEAN - TRUE if there is a mapping within the Mcb and FALSE otherwise
        (i.e., the Mcb does not contain any mapping).

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    BOOLEAN Result;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlLookupLastLargeMcbEntry, Mcb = %08lx\n", Mcb );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  Check to make sure there is at least one run in the mcb
        //

        if (Mcb->PairCount <= 0) {

            try_return (Result = FALSE);
        }

        //
        //  Return the last mapping of the last run
        //

        *LargeLbn = EndingLbn(Mcb,Mcb->PairCount-1);
        *LargeVbn = EndingVbn(Mcb,Mcb->PairCount-1);

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlLookupLastLargeMcbEntry -> %08lx\n", Result );
    }

    return Result;
}


BOOLEAN
FsRtlLookupLastLargeMcbEntryAndIndex (
    IN PLARGE_MCB OpaqueMcb,
    OUT PLONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn,
    OUT PULONG Index
    )

/*++

Routine Description:

    This routine retrieves the last Vbn to Lbn mapping stored in the Mcb.
    It returns the mapping for the last sector or the last run in the
    Mcb.  The results of this function is useful when extending an existing
    file and needing to a hint on where to try and allocate sectors on the
    disk.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Receives the last Vbn value mapped.

    Lbn - Receives the Lbn corresponding to the Vbn.
    
    Index - Receives the index of the last run.

Return Value:

    BOOLEAN - TRUE if there is a mapping within the Mcb and FALSE otherwise
        (i.e., the Mcb does not contain any mapping).

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    BOOLEAN Result;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlLookupLastLargeMcbEntryAndIndex, Mcb = %08lx\n", Mcb );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  Check to make sure there is at least one run in the mcb
        //

        if (Mcb->PairCount <= 0) {

            try_return (Result = FALSE);
        }

        //
        //  Return the last mapping of the last run
        //

        *((PULONG)LargeLbn) = EndingLbn(Mcb,Mcb->PairCount-1);
        *((PULONG)LargeVbn) = EndingVbn(Mcb,Mcb->PairCount-1);

        *Index = Mcb->PairCount - 1;

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlLookupLastLargeMcbEntryAndIndex -> %08lx\n", Result );
    }

    ((PLARGE_INTEGER)LargeVbn)->HighPart = (*((PULONG)LargeVbn) == UNUSED_LBN ? UNUSED_LBN : 0);
    ((PLARGE_INTEGER)LargeLbn)->HighPart = (*((PULONG)LargeLbn) == UNUSED_LBN ? UNUSED_LBN : 0);

    return Result;
}


ULONG
FsRtlNumberOfRunsInLargeMcb (
    IN PLARGE_MCB OpaqueMcb
    )

/*++

Routine Description:

    This routine returns to the its caller the number of distinct runs
    mapped by an Mcb.  Holes (i.e., Vbns that map to Lbn=UNUSED_LBN) are counted
    as runs.  For example, an Mcb containing a mapping for only Vbns 0 and 3
    will have 3 runs, one for the first mapped sector, a second for the
    hole covering Vbns 1 and 2, and a third for Vbn 3.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

Return Value:

    ULONG - Returns the number of distinct runs mapped by the input Mcb.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    ULONG Count;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlNumberOfRunsInLargeMcb, Mcb = %08lx\n", Mcb );

    ExAcquireFastMutex( Mcb->FastMutex );

    Count = Mcb->PairCount;

    ExReleaseFastMutex( Mcb->FastMutex );

    DebugTrace(-1, Dbg, "FsRtlNumberOfRunsInLargeMcb -> %08lx\n", Count );

    return Count;
}


BOOLEAN
FsRtlGetNextLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN ULONG RunIndex,
    OUT PLONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn,
    OUT PLONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine returns to its caller the Vbn, Lbn, and SectorCount for
    distinct runs mapped by an Mcb.  Holes are counted as runs.  For example,
    to construct to print out all of the runs in a a file is:

//. .   for (i = 0; FsRtlGetNextLargeMcbEntry(Mcb,i,&Vbn,&Lbn,&Count); i++) {
//
//. .       // print out vbn, lbn, and count
//
//. .       }

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    RunIndex - Supplies the index of the run (zero based) to return to the
        caller.

    Vbn - Receives the starting Vbn of the returned run, or zero if the
        run does not exist.

    Lbn - Recieves the starting Lbn of the returned run, or zero if the
        run does not exist.

    SectorCount - Receives the number of sectors within the returned run,
        or zero if the run does not exist.

Return Value:

    BOOLEAN - TRUE if the specified run (i.e., RunIndex) exists in the Mcb,
        and FALSE otherwise.  If FALSE is returned then the Vbn, Lbn, and
        SectorCount parameters receive zero.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    BOOLEAN Result;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlGetNextLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " RunIndex = %08lx\n", RunIndex );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  Make sure the run index is within range
        //

        if (RunIndex >= Mcb->PairCount) {

            try_return (Result = FALSE);
        }

        //
        //  Set the return variables
        //

        *((PULONG)LargeVbn) = StartingVbn(Mcb,RunIndex);
        ((PLARGE_INTEGER)LargeVbn)->HighPart = (*((PULONG)LargeVbn) == UNUSED_LBN ? UNUSED_LBN : 0);
        *((PULONG)LargeLbn) = StartingLbn(Mcb,RunIndex);
        ((PLARGE_INTEGER)LargeLbn)->HighPart = (*((PULONG)LargeLbn) == UNUSED_LBN ? UNUSED_LBN : 0);
        *LargeSectorCount = SectorsWithinRun(Mcb,RunIndex);

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlGetNextLargeMcbEntry -> %08lx\n", Result );
    }

    return Result;
}


BOOLEAN
FsRtlSplitLargeMcb (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    IN LONGLONG LargeAmount
    )

/*++

Routine Description:

    This routine is used to create a hole within an MCB, by shifting the
    mapping of Vbns.  All mappings above the input vbn are shifted by the
    amount specified and while keeping their current lbn value.  Pictorially
    we have as input the following MCB

        VBN :       LargeVbn-1 LargeVbn         N
            +-----------------+------------------+
        LBN :             X        Y

    And after the split we have

        VBN :       LargeVbn-1               LargeVbn+Amount    N+Amount
            +-----------------+.............+---------------------------+
        LBN :             X      UnusedLbn       Y

    When doing the split we have a few cases to consider.  They are:

    1. The input Vbn is beyond the last run.  In this case this operation
       is a noop.

    2. The input Vbn is within or adjacent to a existing run of unused Lbns.
       In this case we simply need to extend the size of the existing hole
       and shift succeeding runs.

    3. The input Vbn is between two existing runs, including the an input vbn
       value of zero.  In this case we need to add a new entry for the hole
       and shift succeeding runs.

    4. The input Vbn is within an existing run.  In this case we need to add
       two new entries to contain the split run and the hole.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies the Mcb in which to add the new mapping.

    Vbn - Supplies the starting Vbn that is to be shifted.

    Amount - Supplies the amount to shift by.

Return Value:

    BOOLEAN - TRUE if the mapping was successfully shifted, and FALSE otherwise.
        If FALSE is returned then the Mcb is not changed.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);
    ULONG Amount = ((ULONG)LargeAmount);

    ULONG Index;

    BOOLEAN Result;

    ULONG i;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlSplitLargeMcb, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn    = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " Amount = %08lx\n", Amount );

    ExAcquireFastMutex( Mcb->FastMutex );

    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0) ||
                                                  (Mcb->PairCount == 0)));
    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeAmount)->HighPart == 0) ||
                                                  (Mcb->PairCount == 0)));

    try {

        //
        //  First lookup the index for the entry that we are going to split.
        //  If we can't find the entry then there is nothing to split.  This
        //  takes care of the case where the input vbn is beyond the last run
        //  in the mcb
        //

        if (!FsRtlFindLargeIndex( Mcb, Vbn, &Index)) {

            try_return(Result = FALSE);
        }

        //
        //  Now check if the input Vbn is within a hole
        //

        if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

            //
            //  Before: --PreviousRun--||--IndexHole--||--FollowingRun--
            //  After:  --PreviousRun--||----IndexHole----||--FollowingRun--
            //
            //      In this case the vbn is somewhere within the hole and we
            //      simply need to added the amount of each existing run
            //      beyond the hole.
            //

            //
            //  In this case there is really nothing to do here because the
            //  ending code will already shift the runs by proper amount
            //  starting at index
            //

            NOTHING;

        //
        //  Now check if the input vbn is between a hole and an existing run.
        //

        } else if ((StartingVbn(Mcb,Index) == Vbn) && (Index != 0) && (PreviousEndingLbn(Mcb,Index) == UNUSED_LBN)) {

            //
            //  Before: --Hole--||--IndexRun--
            //  After:  --Hole------||--IndexRun--
            //
            //      In this case the vbn points to the start of the existing
            //      run and we need to do the split between the hole and the
            //      existing run by simply adding the amount to each existing
            //      run beyond the hole.
            //

            //
            //  In this case we need to decement the index by 1 and then
            //  fall to the bottom code which will do the shifting for us
            //

            Index -= 1;

        //
        //  Now check if the input vbn is between two existing runs
        //

        } else if (StartingVbn(Mcb,Index) == Vbn) {

            //
            //  Before: --PreviousRun--||--IndexRun--
            //  After:  --PreviousRun--||--NewHole--||--IndexRun--
            //
            //  Before: 0:|--IndexRun--
            //  After:  0:|--NewHole--||--IndexRun--
            //
            //      In this case the vbn points to the start of an existing
            //      run and the preceeding is either a real run or the start
            //      of mapping pairs We simply add a new entry for the hole
            //      and shift succeeding runs.
            //

            FsRtlAddLargeEntry( Mcb, Index, 1 );

            (Mcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;
            (Mcb->Mapping)[Index].NextVbn = Vbn + Amount;

            Index += 1;

        //
        //  Otherwise the input vbn is inside an existing run
        //

        } else {

            //
            //  Before: --IndexRun--
            //  After:  --SplitRun--||--NewHole--||--SplitRun--
            //
            //      In this case the vbn points within an existing run
            //      we need to add two new extries for hole and split
            //      run and shift succeeding runs
            //

            FsRtlAddLargeEntry( Mcb, Index, 2 );

            (Mcb->Mapping)[Index].Lbn = (Mcb->Mapping)[Index+2].Lbn;
            (Mcb->Mapping)[Index].NextVbn = Vbn;

            (Mcb->Mapping)[Index+1].Lbn = (LBN)UNUSED_LBN;
            (Mcb->Mapping)[Index+1].NextVbn = Vbn + Amount;

            (Mcb->Mapping)[Index+2].Lbn = (Mcb->Mapping)[Index+2].Lbn +
                                          StartingVbn(Mcb, Index+1) -
                                          StartingVbn(Mcb, Index);

            Index += 2;

        }

        //
        //  At this point we have completed most of the work we now need to
        //  shift existing runs from the index to the end of the mappings
        //  by the specified amount
        //

        for (i = Index; i < Mcb->PairCount; i += 1) {

            (Mcb->Mapping)[i].NextVbn += Amount;
        }

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlSplitLargeMcb -> %08lx\n", Result );
    }

    return Result;
}


//
//  Private support routine
//

VOID
FsRtlRemoveMcbEntryPrivate (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG Vbn,
    IN ULONG SectorCount
    )

/*++

Routine Description:

    This is the work routine for remove large mcb entry.  It does the work
    without taking out the mcb FastMutex.

Arguments:

    Mcb - Supplies the Mcb from which to remove the mapping.

    Vbn - Supplies the starting Vbn of the mappings to remove.

    SectorCount - Supplies the size of the mappings to remove (in sectors).

Return Value:

    None.

--*/

{
    ULONG Index;

    PAGED_CODE();

    //
    //  Do a quick test to see if we are wiping out the entire MCB.
    //

    if ((Vbn == 0) && (Mcb->PairCount > 0) && (SectorCount >= Mcb->Mapping[Mcb->PairCount-1].NextVbn)) {

        Mcb->PairCount = 0;

        return;
    }

    //
    //  While there is some more mapping to remove we'll continue
    //  with our main loop
    //

    while (SectorCount > 0) {

        //
        //  Locate the mapping for the vbn
        //

        if (!FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

            DebugTrace( 0, Dbg, "FsRtlRemoveLargeMcbEntry, Cannot remove an unmapped Vbn = %08lx\n", Vbn );

            return;
        }

        //
        //  Now that we some something to remove the following cases must
        //  be considered
        //

        if ((StartingVbn(Mcb,Index) == Vbn) &&
            (EndingVbn(Mcb,Index) < Vbn + SectorCount)) {

            ULONG i;

            //
            //  Removes the entire run
            //

            //
            //  Update the amount to remove
            //

            i = SectorsWithinRun(Mcb,Index);
            Vbn += i;
            SectorCount -= i;

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            //
            //  Test for last run
            //

            } else if (Index == Mcb->PairCount - 1) {

                if ((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) ||
                    (Index == 0)) {

                    //
                    //  Previous is not hole, index is last run
                    //
                    //  --Previous--|  Hole
                    //
                    //  0:  Hole
                    //

                    DebugTrace( 0, Dbg, "Entire run, Previous not hole, index is last run\n", 0);

                    //
                    //  Just remove this entry
                    //

                    FsRtlRemoveLargeEntry( Mcb, Index, 1);

                } else {

                    //
                    //  Previous is hole, index is last run
                    //
                    //  --Hole--|  Hole
                    //

                    DebugTrace( 0, Dbg, "Entire run, Previous hole, index is last run\n", 0);

                    //
                    //  Just remove this entry, and preceding entry
                    //

                    FsRtlRemoveLargeEntry( Mcb, Index-1, 2);
                }

            } else if (((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) || (Index == 0)) &&
                       (NextStartingLbn(Mcb,Index) != UNUSED_LBN)) {

                //
                //  Previous and following are not holes
                //
                //  --Previous--|  Hole  |--Following--
                //
                //  0:  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous & Following not holes\n", 0);

                //
                //  Make this index a hole
                //

                (Mcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;

            } else if (((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) || (Index == 0)) &&
                       (NextStartingLbn(Mcb,Index) == UNUSED_LBN)) {

                //
                //  Following is hole
                //
                //  --Previous--|  Hole  |--Hole--
                //
                //  0:  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "Entire run, Following is hole\n", 0);

                //
                //  Simply remove this entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index, 1 );

            } else if ((PreviousEndingLbn(Mcb,Index) == UNUSED_LBN) &&
                       (NextStartingLbn(Mcb,Index) != UNUSED_LBN)) {

                //
                //  Previous is hole
                //
                //  --Hole--|  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous is hole\n", 0);

                //
                //  Mark current entry a hole
                //

                (Mcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;

                //
                //  Remove previous entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index - 1, 1 );

            } else {

                //
                //  Previous and following are holes
                //
                //  --Hole--|  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous & following are holes\n", 0);

                //
                //  Remove previous and this entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index - 1, 2 );
            }

        } else if (StartingVbn(Mcb,Index) == Vbn) {

            //
            //  Removes first part of run
            //

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else if ((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) || (Index == 0)) {

                //
                //  Previous is not hole
                //
                //  --Previous--|  Hole  |--Index--||--Following--
                //
                //  0:  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "1st part, Previous is not hole\n", 0);

                //
                //  Make room for one more entry.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 1 );

                //
                //  Set the hole
                //

                (Mcb->Mapping)[Index].Lbn = (LBN)UNUSED_LBN;
                (Mcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

                //
                //  Set the new Lbn for the remaining run
                //

                (Mcb->Mapping)[Index+1].Lbn += SectorCount;

            } else {

                //
                //  Previous is hole
                //
                //  --Hole--|  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "1st part, Previous is hole\n", 0);

                //
                //  Expand the preceding hole
                //

                (Mcb->Mapping)[Index-1].NextVbn += SectorCount;

                //
                //  Set the new Lbn for the remaining run
                //

                (Mcb->Mapping)[Index].Lbn += SectorCount;
            }

            //
            //  Update the amount to remove
            //

            Vbn += SectorCount;
            SectorCount = 0;

        } else if (EndingVbn(Mcb,Index) < Vbn + SectorCount) {

            ULONG AmountToRemove;

            AmountToRemove = EndingVbn(Mcb,Index) - Vbn + 1;

            //
            //  Removes last part of run
            //

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else if (Index == Mcb->PairCount - 1) {

                //
                //  Index is last run
                //
                //  --Previous--||--Index--|  Hole
                //
                //  0:|--Index--|  Hole
                //

                DebugTrace( 0, Dbg, "last part, Index is last run\n", 0);

                //
                //  Shrink back the size of the current index
                //

                (Mcb->Mapping)[Index].NextVbn -= AmountToRemove;

            } else if (NextStartingLbn(Mcb,Index) == UNUSED_LBN) {

                //
                //  Following is hole
                //
                //  --Previous--||--Index--|  Hole  |--Hole--
                //
                //  0:|--Index--|  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "last part, Following is hole\n", 0);

                //
                //  Shrink back the size of the current index
                //

                (Mcb->Mapping)[Index].NextVbn -= AmountToRemove;

            } else {

                //
                //  Following is not hole
                //
                //  --Previous--||--Index--|  Hole  |--Following--
                //
                //
                //  0:|--Index--|  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "last part, Following is not hole\n", 0);

                //
                //  Make room for one more entry.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index+1, 1 );

                //
                //  Set the new hole
                //

                (Mcb->Mapping)[Index+1].Lbn = (LBN)UNUSED_LBN;
                (Mcb->Mapping)[Index+1].NextVbn = (Mcb->Mapping)[Index].NextVbn;

                //
                //  Shrink back the size of the current index
                //

                (Mcb->Mapping)[Index].NextVbn -= AmountToRemove;
            }

            //
            //  Update amount to remove
            //

            Vbn += AmountToRemove;
            SectorCount -= AmountToRemove;

        } else {

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else {

                //
                //  Remove middle of run
                //
                //  --Previous--||--Index--|  Hole  |--Index--||--Following--
                //
                //  0:|--Index--|  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "Middle of run\n", 0);

                //
                //  Make room for two more entries.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 2 );

                //
                //  Set up the first remaining run
                //

                (Mcb->Mapping)[Index].Lbn = (Mcb->Mapping)[Index+2].Lbn;
                (Mcb->Mapping)[Index].NextVbn = Vbn;

                //
                //  Set up the hole
                //

                (Mcb->Mapping)[Index+1].Lbn = (LBN)UNUSED_LBN;
                (Mcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

                //
                //  Set up the second remaining run
                //

                (Mcb->Mapping)[Index+2].Lbn += SectorsWithinRun(Mcb,Index) +
                                               SectorsWithinRun(Mcb,Index+1);
            }

            //
            //  Update amount to remove
            //

            Vbn += SectorCount;
            SectorCount = 0;
        }
    }

    return;
}


//
//  Private routine
//

BOOLEAN
FsRtlFindLargeIndex (
    IN PNONOPAQUE_MCB Mcb,
    IN VBN Vbn,
    OUT PULONG Index
    )

/*++

Routine Description:

    This is a private routine that locates a mapping for a Vbn
    in a given mapping array

Arguments:

    Mcb - Supplies the mapping array to examine

    Vbn - Supplies the Vbn to look up

    Index - Receives the index within the mapping array of the mapping
        containing the Vbn.  If none if found then the index is set to
        PairCount.

Return Value:

    BOOLEAN - TRUE if Vbn is found and FALSE otherwise

--*/

{
    LONG MinIndex;
    LONG MaxIndex;
    LONG MidIndex;

    //
    //  We'll just do a binary search for the mapping entry.  Min and max
    //  are our search boundaries
    //

    MinIndex = 0;
    MaxIndex = Mcb->PairCount - 1;

    while (MinIndex <= MaxIndex) {

        //
        //  Compute the middle index to look at
        //

        MidIndex = ((MaxIndex + MinIndex) / 2);

        //
        //  check if the Vbn is less than the mapping at the mid index
        //

        if (Vbn < StartingVbn(Mcb, MidIndex)) {

            //
            //  Vbn is less than the middle index so we need to drop
            //  the max down
            //

            MaxIndex = MidIndex - 1;

        //
        //  check if the Vbn is greater than the mapping at the mid index
        //

        } else if (Vbn > EndingVbn(Mcb, MidIndex)) {

            //
            //  Vbn is greater than the middle index so we need to bring
            //  up the min
            //

            MinIndex = MidIndex + 1;

        //
        //  Otherwise we've found the index containing the Vbn so set the
        //  index and return TRUE.
        //

        } else {

            *Index = MidIndex;

            return TRUE;
        }
    }

    //
    //  A match wasn't found so set index to PairCount and return FALSE
    //

    *Index = Mcb->PairCount;

    return FALSE;
}


//
//  Private Routine
//

VOID
FsRtlAddLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToAddIndex,
    IN ULONG AmountToAdd
    )

/*++

Routine Description:

    This routine takes a current Mcb and detemines if there is enough
    room to add the new mapping entries.  If there is not enough room
    it reallocates a new mcb buffer and copies over the current mapping.
    If also will spread out the current mappings to leave the specified
    index slots in the mapping unfilled.  For example, if WhereToAddIndex
    is equal to the current pair count then we don't need to make a hole
    in the mapping, but if the index is less than the current pair count
    then we'll need to slide some of the mappings down to make room
    at the specified index.

Arguments:

    Mcb - Supplies the mcb being checked and modified

    WhereToAddIndex - Supplies the index of where the additional entries
        need to be made

    AmountToAdd - Supplies the number of additional entries needed in the
        mcb

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check to see if the current buffer is large enough to hold
    //  the additional entries
    //

    if (Mcb->PairCount + AmountToAdd > Mcb->MaximumPairCount) {

        ULONG NewMax;
        PMAPPING Mapping;

        //
        //  We need to allocate a new mapping so compute a new maximum pair
        //  count.  We'll only be asked to grow by at most 2 at a time, so
        //  doubling will definitely make us large enough for the new amount.
        //  But we won't double without bounds we'll stop doubling if the
        //  pair count gets too high.
        //

        if (Mcb->MaximumPairCount < 2048) {

            NewMax = Mcb->MaximumPairCount * 2;

        } else {

            NewMax = Mcb->MaximumPairCount + 2048;
        }

        Mapping = FsRtlpAllocatePool( Mcb->PoolType, sizeof(MAPPING) * NewMax );

        //**** RtlZeroMemory( Mapping, sizeof(MAPPING) * NewMax );

        //
        //  Now copy over the old mapping to the new buffer
        //

        RtlCopyMemory( Mapping, Mcb->Mapping, sizeof(MAPPING) * Mcb->PairCount );

        //
        //  Deallocate the old buffer
        //

        if ((Mcb->PoolType == PagedPool) && (Mcb->MaximumPairCount == INITIAL_MAXIMUM_PAIR_COUNT)) {

            FsRtlFreeFirstMapping( Mcb->Mapping );

        } else {

            ExFreePool( Mcb->Mapping );
        }

        //
        //  And set up the new buffer in the Mcb
        //

        Mcb->Mapping = Mapping;
        Mcb->MaximumPairCount = NewMax;
    }

    //
    //  Now see if we need to shift some entries over according to the
    //  WhereToAddIndex value
    //

    if (WhereToAddIndex < Mcb->PairCount) {

        RtlMoveMemory( &((Mcb->Mapping)[WhereToAddIndex + AmountToAdd]),
                       &((Mcb->Mapping)[WhereToAddIndex]),
                       (Mcb->PairCount - WhereToAddIndex) * sizeof(MAPPING) );
    }

    //
    //  Now zero out the new additions
    //

    //**** RtlZeroMemory( &((Mcb->Mapping)[WhereToAddIndex]), sizeof(MAPPING) * AmountToAdd );

    //
    //  Now increment the PairCount
    //

    Mcb->PairCount += AmountToAdd;

    //
    //  And return to our caller
    //

    return;
}


//
//  Private Routine
//

VOID
FsRtlRemoveLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToRemoveIndex,
    IN ULONG AmountToRemove
    )

/*++

Routine Description:

    This routine takes a current Mcb and removes one or more entries.

Arguments:

    Mcb - Supplies the mcb being checked and modified

    WhereToRemoveIndex - Supplies the index of the entries to remove

    AmountToRemove - Supplies the number of entries to remove

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check to see if we need to shift everything down because the
    //  entries to remove do not include the last entry in the mcb
    //

    if (WhereToRemoveIndex + AmountToRemove < Mcb->PairCount) {

        RtlMoveMemory( &((Mcb->Mapping)[WhereToRemoveIndex]),
                      &((Mcb->Mapping)[WhereToRemoveIndex + AmountToRemove]),
                      (Mcb->PairCount - (WhereToRemoveIndex + AmountToRemove))
                                                           * sizeof(MAPPING) );
    }

    //
    //  Now zero out the entries beyond the part we just shifted down
    //

    //**** RtlZeroMemory( &((Mcb->Mapping)[Mcb->PairCount - AmountToRemove]), AmountToRemove * sizeof(MAPPING) );

    //
    //  Now decrement the PairCount
    //

    Mcb->PairCount -= AmountToRemove;

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\notify.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Notify.c

Abstract:

    The Notify package provides support to filesystems which implement
    NotifyChangeDirectory.  This package will manage a queue of notify
    blocks which are attached to some filesystem structure (i.e. Vcb
    in Fat, HPFS).  The filesystems will allocate a fast mutex to be used
    by this package to synchronize access to the notify queue.

    The following routines are provided by this package:

        o  FsRtlNotifyInitializeSync - Create and initializes the
           synchronization object.

        o  FsrtlNotifyUninitializeSync - Deallocates the synchronization
           object.

        o  FsRtlNotifyChangeDirectory - This routine is called whenever the
           filesystems receive a NotifyChangeDirectoryFile call.  This
           routine allocates any neccessary structures and places the
           Irp in the NotifyQueue (or possibly completes or cancels it
           immediately).

        o  FsRtlNotifyFullChangeDirectory - This routine is called whenever the
           filesystems receive a NotifyChangeDirectoryFile call.  This differs
           from the FsRtlNotifyChangeDirectory in that it expects to return
           the notify information in the user's buffer.

        o  FsRtlNotifyFilterChangeDirectory - This routine is called whenever the
           filesystems receive a NotifyChangeDirectoryFile call.  This differs
           from the FsRtlNotifyFullChangeDirectory in that it accepts a
           FilterRoutine Callback.

        o  FsRtlNotifyReportChange - This routine is called by the
           filesystems whenever they perform some operation that could
           cause the completion of a notify operation.  This routine will
           walk through the notify queue to see if any Irps are affected
           by the indicated operation.

        o  FsRtlNotifyFullReportChange - This routine is called by the
           filesystems whenever they perform some operation that could
           cause the completion of a notify operation.  This routine differs
           from the FsRtlNotifyReportChange call in that it returns more
           detailed information in the caller's buffer if present.

        o  FsRtlNotifyFilterReportChange - This routine is called by the
           filesystems whenever they perform some operation that could
           cause the completion of a notify operation.  This routine differs
           from the FsRtlNotifyFullReportChange call in that it accepts a
           FilterContext parameter for notifyees who specified a FilterRoutine.

        o  FsRtlNotifyCleanup - This routine is called to remove any
           references to a particular FsContext structure from the notify
           queue.  If the matching FsContext structure is found in the
           queue, then all associated Irps are completed.

Author:

    Brian Andrew    [BrianAn]   9-19-1991

Revision History:

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x04000000)

//
//  This is the synchronization object for the notify package.  The caller
//  given a pointer to this structure.
//

typedef struct _REAL_NOTIFY_SYNC {

    FAST_MUTEX FastMutex;
    ERESOURCE_THREAD OwningThread;
    ULONG OwnerCount;

} REAL_NOTIFY_SYNC, *PREAL_NOTIFY_SYNC;

//
//  A list of the following structures is used to store the NotifyChange
//  requests.  They are linked to a filesystem-defined list head.
//

typedef struct _NOTIFY_CHANGE {

    //
    //  Fast Mutex.  This fast mutex is used to access the list containing this
    //  structure.
    //

    PREAL_NOTIFY_SYNC NotifySync;

    //
    //  FsContext.  This value is given by the filesystems to uniquely
    //  identify this structure.  The identification is on a
    //  per-user file object basis.  The expected value is the Ccb address
    //  for this user file object.
    //

    PVOID FsContext;

    //
    //  StreamID.  This value matches the FsContext field in the file object for
    //  the directory being watched.  This is used to identify the directory stream
    //  when the directory is being deleted.
    //

    PVOID StreamID;

    //
    //  TraverseAccessCallback.  This is the filesystem-supplied routine used
    //  to call back into the filesystem to check whether the caller has traverse
    //  access when watching a sub-directory.  Only applies when watching a
    //  sub-directory.
    //

    PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback;

    //
    //  SubjectContext.  If the caller specifies a traverse callback routine
    //  we will need to pass the Security Context from the thread which
    //  originated this call.  The notify package will free this structure
    //  on tearing down the notify package.  We don't expect to need this
    //  structure often.
    //

    PSECURITY_SUBJECT_CONTEXT SubjectContext;

    //
    //  Full Directory Name.  The following string is the full directory
    //  name of the directory being watched.  It is used during watch tree
    //  operations to check whether this directory is an ancestor of
    //  the modified file.  The string could be in ANSI or UNICODE form.
    //

    PSTRING FullDirectoryName;

    //
    //  Notify List.  The following field links the notify structures for
    //  a particular volume.
    //

    LIST_ENTRY NotifyList;

    //
    //  Notify Irps.  The following field links the Irps associated with
    //
    //

    LIST_ENTRY NotifyIrps;

    //
    //  FilterCallback.  This is the filesystem-supplied routine used
    //  to call back into the filesystem to check whether a Notify block
    //  should see the change.  (Initially added for TxfNtfs development
    //  as part of a strategy to control when, not if, transactions see
    //  changes from other transactions.)
    //

    PFILTER_REPORT_CHANGE FilterCallback;

    //
    //  Flags.  State of the notify for this volume.
    //

    USHORT Flags;

    //
    //  Character size.  Larger size indicates unicode characters.
    //  unicode names.
    //

    UCHAR CharacterSize;

    //
    //  Completion Filter.  This field is used to mask the modification
    //  actions to determine whether to complete the notify irp.
    //

    ULONG CompletionFilter;

    //
    //  The following values are used to manage a buffer if there is no current
    //  Irp to complete. The fields have the following meaning:
    //
    //      AllocatedBuffer     - Buffer we need to allocate
    //      Buffer              - Buffer to store data in
    //      BufferLength        - Length of original user buffer
    //      ThisBufferLength    - Length of the buffer we are using
    //      DataLength          - Current length of the data in the buffer
    //      LastEntry           - Offset of previous entry in the buffer
    //

    PVOID AllocatedBuffer;
    PVOID Buffer;
    ULONG BufferLength;
    ULONG ThisBufferLength;
    ULONG DataLength;
    ULONG LastEntry;

    //
    //  Reference count which keeps the notify structure around.  Such references include
    //
    //      - Lifetime reference.  Count set to one initially and removed on cleanup
    //      - Cancel reference.  Reference the notify struct when storing the cancel routine
    //          in the Irp.  The routine which actually clears the routine will decrement
    //          this value.
    //

    ULONG ReferenceCount;

    //
    //  This is the process on whose behalf the structure was allocated.  We
    //  charge any quota to this process.
    //

    PEPROCESS OwningProcess;

} NOTIFY_CHANGE, *PNOTIFY_CHANGE;

#define NOTIFY_WATCH_TREE               (0x0001)
#define NOTIFY_IMMEDIATE_NOTIFY         (0x0002)
#define NOTIFY_CLEANUP_CALLED           (0x0004)
#define NOTIFY_DEFER_NOTIFY             (0x0008)
#define NOTIFY_DIR_IS_ROOT              (0x0010)
#define NOTIFY_STREAM_IS_DELETED        (0x0020)

//
//      CAST
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          IN (CAST)
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define Add2Ptr(PTR,INC,CAST) ((CAST)((PUCHAR)(PTR) + (INC)))

#define PtrOffset(BASE,OFFSET) ((ULONG)((PCHAR)(OFFSET) - (PCHAR)(BASE)))

//
//      VOID
//      SetFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//
//      VOID
//      ClearFlag (
//          IN ULONG Flags,
//          IN ULONG SingleFlag
//          );
//

#define SetFlag(F,SF) {     \
    (F) |= (SF);            \
}

#define ClearFlag(F,SF) {   \
    (F) &= ~(SF);           \
}

//
//  VOID
//  AcquireNotifySync (
//      IN PREAL_NOTIFY_SYNC NotifySync
//      );
//
//  VOID
//  ReleaseNotifySync (
//      IN PREAL_NOTIFY_SYNC NotifySync
//      );
//

#define AcquireNotifySync(NS) {                                             \
    ERESOURCE_THREAD _CurrentThread;                                        \
    _CurrentThread = (ERESOURCE_THREAD) PsGetCurrentThread();               \
    if (_CurrentThread != ((PREAL_NOTIFY_SYNC) (NS))->OwningThread) {       \
        ExAcquireFastMutexUnsafe( &((PREAL_NOTIFY_SYNC) (NS))->FastMutex ); \
        ((PREAL_NOTIFY_SYNC) (NS))->OwningThread = _CurrentThread;          \
    }                                                                       \
    ((PREAL_NOTIFY_SYNC) (NS))->OwnerCount += 1;                            \
}

#define ReleaseNotifySync(NS) {                                             \
    ((PREAL_NOTIFY_SYNC) (NS))->OwnerCount -= 1;                            \
    if (((PREAL_NOTIFY_SYNC) (NS))->OwnerCount == 0) {                      \
        ((PREAL_NOTIFY_SYNC) (NS))->OwningThread = (ERESOURCE_THREAD) 0;    \
        ExReleaseFastMutexUnsafe(&((PREAL_NOTIFY_SYNC) (NS))->FastMutex);   \
    }                                                                       \
}

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('NrSF')


//
//  Local support routines
//

PNOTIFY_CHANGE
FsRtlIsNotifyOnList (
    IN PLIST_ENTRY NotifyListHead,
    IN PVOID FsContext
    );

VOID
FsRtlNotifyCompleteIrp (
    IN PIRP NotifyIrp,
    IN PNOTIFY_CHANGE Notify,
    IN ULONG DataLength,
    IN NTSTATUS Status,
    IN ULONG CheckCancel
    );

BOOLEAN
FsRtlNotifySetCancelRoutine (
    IN PIRP NotifyIrp,
    IN PNOTIFY_CHANGE Notify OPTIONAL
    );

BOOLEAN
FsRtlNotifyUpdateBuffer (
    IN PFILE_NOTIFY_INFORMATION NotifyInfo,
    IN ULONG FileAction,
    IN PSTRING ParentName,
    IN PSTRING TargetName,
    IN PSTRING StreamName OPTIONAL,
    IN BOOLEAN UnicodeName,
    IN ULONG SizeOfEntry
    );

VOID
FsRtlNotifyCompleteIrpList (
    IN PNOTIFY_CHANGE Notify,
    IN NTSTATUS Status
    );

VOID
FsRtlCancelNotify (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP ThisIrp
    );

VOID
FsRtlCheckNotifyForDelete (
    IN PLIST_ENTRY NotifyListHead,
    IN PVOID FsContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlNotifyInitializeSync)
#pragma alloc_text(PAGE, FsRtlNotifyUninitializeSync)
#pragma alloc_text(PAGE, FsRtlNotifyFullChangeDirectory)
#pragma alloc_text(PAGE, FsRtlNotifyFullReportChange)
#pragma alloc_text(PAGE, FsRtlNotifyFilterChangeDirectory)
#pragma alloc_text(PAGE, FsRtlNotifyFilterReportChange)
#pragma alloc_text(PAGE, FsRtlIsNotifyOnList)
#pragma alloc_text(PAGE, FsRtlNotifyChangeDirectory)
#pragma alloc_text(PAGE, FsRtlNotifyCleanup)
#pragma alloc_text(PAGE, FsRtlNotifyCompleteIrp)
#pragma alloc_text(PAGE, FsRtlNotifyReportChange)
#pragma alloc_text(PAGE, FsRtlNotifyUpdateBuffer)
#pragma alloc_text(PAGE, FsRtlCheckNotifyForDelete)
#pragma alloc_text(PAGE, FsRtlNotifyCompleteIrpList)
#endif


NTKERNELAPI
VOID
FsRtlNotifyInitializeSync (
    IN PNOTIFY_SYNC *NotifySync
    )

/*++

Routine Description:

    This routine is called to allocate and initialize the synchronization object
    for this notify list.

Arguments:

    NotifySync  -  This is the address to store the structure we allocate.

Return Value:

    None.

--*/

{
    PREAL_NOTIFY_SYNC RealSync;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyInitializeSync:  Entered\n", 0 );

    //
    //  Clear the pointer and then attempt to allocate a non-paged
    //  structure.
    //

    *NotifySync = NULL;

    RealSync = (PREAL_NOTIFY_SYNC) FsRtlpAllocatePool( NonPagedPool,
                                                       sizeof( REAL_NOTIFY_SYNC ));

    //
    //  Initialize the structure.
    //

    ExInitializeFastMutex( &RealSync->FastMutex );
    RealSync->OwningThread = (ERESOURCE_THREAD) 0;
    RealSync->OwnerCount = 0;

    *NotifySync = (PNOTIFY_SYNC) RealSync;

    DebugTrace( -1, Dbg, "FsRtlNotifyInitializeSync:  Exit\n", 0 );
    return;
}


NTKERNELAPI
VOID
FsRtlNotifyUninitializeSync (
    IN PNOTIFY_SYNC *NotifySync
    )

/*++

Routine Description:

    This routine is called to uninitialize the synchronization object
    for this notify list.

Arguments:

    NotifySync  -  This is the address containing the pointer to our synchronization
        object.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyUninitializeSync:  Entered\n", 0 );

    //
    //  Free the structure if present and clear the pointer.
    //

    if (*NotifySync != NULL) {

        ExFreePool( *NotifySync );
        *NotifySync = NULL;
    }

    DebugTrace( -1, Dbg, "FsRtlNotifyUninitializeSync:  Exit\n", 0 );
    return;
}


VOID
FsRtlNotifyChangeDirectory (
    IN PNOTIFY_SYNC NotifySync,
    IN PVOID FsContext,
    IN PSTRING FullDirectoryName,
    IN PLIST_ENTRY NotifyList,
    IN BOOLEAN WatchTree,
    IN ULONG CompletionFilter,
    IN PIRP NotifyIrp
    )

/*++

Routine Description:

    This routine is called by a file system which has received a NotifyChange
    request.  This routine checks if there is already a notify structure and
    inserts one if not present.  With a notify structure in hand, we check
    whether we already have a pending notify and report it if so.  If there
    is no pending notify, we check if this Irp has already been cancelled and
    completes it if so.  Otherwise we add this to the list of Irps waiting
    for notification.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    FsContext  -  This is supplied by the file system so that this notify
                  structure can be uniquely identified.

    FullDirectoryName  -  Points to the full name for the directory associated
                          with this notify structure.

    NotifyList  -  This is the start of the notify list to add this
                   structure to.

    WatchTree  -  This indicates whether all subdirectories for this directory
                  should be watched, or just the directory itself.

    CompletionFilter  -  This provides the mask to determine which operations
                         will trigger the notify operations.

    NotifyIrp  -  This is the Irp to complete on notify change.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyChangeDirectory:  Entered\n", 0 );

    //
    //  We will simply call the full notify routine to do the real work.
    //

    FsRtlNotifyFilterChangeDirectory( NotifySync,
                                      NotifyList,
                                      FsContext,
                                      FullDirectoryName,
                                      WatchTree,
                                      TRUE,
                                      CompletionFilter,
                                      NotifyIrp,
                                      NULL,
                                      NULL,
                                      NULL );

    DebugTrace( -1, Dbg, "FsRtlNotifyChangeDirectory:  Exit\n", 0 );

    return;
}


VOID
FsRtlNotifyFullChangeDirectory (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PVOID FsContext,
    IN PSTRING FullDirectoryName,
    IN BOOLEAN WatchTree,
    IN BOOLEAN IgnoreBuffer,
    IN ULONG CompletionFilter,
    IN PIRP NotifyIrp,
    IN PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback OPTIONAL,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext OPTIONAL
    )

/*++

Routine Description:

    This routine is called by a file system which has received a NotifyChange
    request.  This routine checks if there is already a notify structure and
    inserts one if not present.  With a notify structure in hand, we check
    whether we already have a pending notify and report it if so.  If there
    is no pending notify, we check if this Irp has already been cancelled and
    completes it if so.  Otherwise we add this to the list of Irps waiting
    for notification.

    This is the version of this routine which understands about the user's
    buffer and will fill it in on a reported change.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
        structure to.

    FsContext  -  This is supplied by the file system so that this notify
        structure can be uniquely identified.  If the NotifyIrp is not specified
        then this is used to identify the stream and it will match the FsContext
        field in the file object of a stream being deleted.

    FullDirectoryName  -  Points to the full name for the directory associated
        with this notify structure.  Ignored if the NotifyIrp is not specified.

    WatchTree  -  This indicates whether all subdirectories for this directory
        should be watched, or just the directory itself.  Ignored if the
        NotifyIrp is not specified.

    IgnoreBuffer  -  Indicates whether we will always ignore any user buffer
        and force the directory to be reenumerated.  This will speed up the
        operation.  Ignored if the NotifyIrp is not specified.

    CompletionFilter  -  This provides the mask to determine which operations
        will trigger the notify operations.  Ignored if the NotifyIrp is not
        specified.

    NotifyIrp  -  This is the Irp to complete on notify change.  If this irp is
        not specified it means that the stream represented by this file object
        is being deleted.

    TraverseCallback  -  If specified we must call this routine when a change
        has occurred in a subdirectory being watched in a tree.  This will
        let the filesystem check if the watcher has traverse access to that
        directory.  Ignored if the NotifyIrp is not specified.

    SubjectContext - If there is a traverse callback routine then we will
        pass this subject context as a parameter to the call.  We will release
        the context and free the structure when done with it.  Ignored if the
        NotifyIrp is not specified, NULL in these cases.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyFullChangeDirectory:  Entered\n", 0 );

    //
    //  We will simply call the full notify routine to do the real work.
    //

    FsRtlNotifyFilterChangeDirectory( NotifySync,
                                      NotifyList,
                                      FsContext,
                                      FullDirectoryName,
                                      WatchTree,
                                      IgnoreBuffer,
                                      CompletionFilter,
                                      NotifyIrp,
                                      TraverseCallback,
                                      SubjectContext,
                                      NULL );

    DebugTrace( -1, Dbg, "FsRtlNotifyFullChangeDirectory:  Exit\n", 0 );

    return;
}


VOID
FsRtlNotifyFilterChangeDirectory (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PVOID FsContext,
    IN PSTRING FullDirectoryName,
    IN BOOLEAN WatchTree,
    IN BOOLEAN IgnoreBuffer,
    IN ULONG CompletionFilter,
    IN PIRP NotifyIrp,
    IN PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback OPTIONAL,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext OPTIONAL,
    IN PFILTER_REPORT_CHANGE FilterCallback OPTIONAL
    )

/*++

Routine Description:

    This routine is called by a file system which has received a NotifyChange
    request.  This routine checks if there is already a notify structure and
    inserts one if not present.  With a notify structure in hand, we check
    whether we already have a pending notify and report it if so.  If there
    is no pending notify, we check if this Irp has already been cancelled and
    completes it if so.  Otherwise we add this to the list of Irps waiting
    for notification.

    This is the version of this routine which understands about the user's
    buffer and will fill it in on a reported change.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
        structure to.

    FsContext  -  This is supplied by the file system so that this notify
        structure can be uniquely identified.  If the NotifyIrp is not specified
        then this is used to identify the stream and it will match the FsContext
        field in the file object of a stream being deleted.

    FullDirectoryName  -  Points to the full name for the directory associated
        with this notify structure.  Ignored if the NotifyIrp is not specified.

    WatchTree  -  This indicates whether all subdirectories for this directory
        should be watched, or just the directory itself.  Ignored if the
        NotifyIrp is not specified.

    IgnoreBuffer  -  Indicates whether we will always ignore any user buffer
        and force the directory to be reenumerated.  This will speed up the
        operation.  Ignored if the NotifyIrp is not specified.

    CompletionFilter  -  This provides the mask to determine which operations
        will trigger the notify operations.  Ignored if the NotifyIrp is not
        specified.

    NotifyIrp  -  This is the Irp to complete on notify change.  If this irp is
        not specified it means that the stream represented by this file object
        is being deleted.

    TraverseCallback  -  If specified we must call this routine when a change
        has occurred in a subdirectory being watched in a tree.  This will
        let the filesystem check if the watcher has traverse access to that
        directory.  Ignored if the NotifyIrp is not specified.

    SubjectContext - If there is a traverse callback routine then we will
        pass this subject context as a parameter to the call.  We will release
        the context and free the structure when done with it.  Ignored if the
        NotifyIrp is not specified.

    FilterCallback - This is the filesystem-supplied routine used
        to call back into the filesystem to check whether this Notify block
        should see the change.  (Initially added for TxfNtfs development
        as part of a strategy to control when, not if, transactions see
        changes from other transactions.)

Return Value:

    None.

--*/

{
    PNOTIFY_CHANGE Notify = NULL;
    PIO_STACK_LOCATION IrpSp;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyFullChangeDirectory:  Entered\n", 0 );

    //
    //  Acquire exclusive access to the list by acquiring the mutex.
    //

    AcquireNotifySync( NotifySync );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there is no Irp then find all of the pending Irps whose file objects
        //  refer to the same stream and complete them with STATUS_DELETE_PENDING.
        //

        if (NotifyIrp == NULL) {

            FsRtlCheckNotifyForDelete( NotifyList, FsContext );
            try_return( NOTHING );
        }

        //
        //  Get the current Stack location
        //

        IrpSp = IoGetCurrentIrpStackLocation( NotifyIrp );

        //
        //  Clear the Iosb in the Irp.
        //

        NotifyIrp->IoStatus.Status = STATUS_SUCCESS;
        NotifyIrp->IoStatus.Information = 0;

        //
        //  If the file object has already gone through cleanup, then complete
        //  the request immediately.
        //

        if (FlagOn( IrpSp->FileObject->Flags, FO_CLEANUP_COMPLETE )) {

            //
            //  Always mark this Irp as pending returned.
            //

            IoMarkIrpPending( NotifyIrp );

            FsRtlCompleteRequest( NotifyIrp, STATUS_NOTIFY_CLEANUP );
            try_return( NOTHING );
        }

        //
        //  If the notify structure is not already in the list, add it
        //  now.
        //

        Notify = FsRtlIsNotifyOnList( NotifyList, FsContext );

        if (Notify == NULL) {

            //
            //  Allocate and initialize the structure.
            //

            Notify = FsRtlpAllocatePool( PagedPool, sizeof( NOTIFY_CHANGE ));
            RtlZeroMemory( Notify, sizeof( NOTIFY_CHANGE ));

            Notify->NotifySync = (PREAL_NOTIFY_SYNC) NotifySync;
            Notify->FsContext = FsContext;
            Notify->StreamID = IrpSp->FileObject->FsContext;

            Notify->TraverseCallback = TraverseCallback;
            Notify->SubjectContext = SubjectContext;
            SubjectContext = NULL;
            Notify->FilterCallback = FilterCallback;

            Notify->FullDirectoryName = FullDirectoryName;

            InitializeListHead( &Notify->NotifyIrps );

            if (WatchTree) {

                SetFlag( Notify->Flags, NOTIFY_WATCH_TREE );
            }

            if (FullDirectoryName == NULL) {

                //
                //  In the view index we aren't using this buffer to hold a
                //  unicode string.
                //

                Notify->CharacterSize = sizeof( CHAR );

            } else {

                //
                //  We look at the directory name to decide if we have a unicode
                //  name.
                //

                if (FullDirectoryName->Length >= 2
                    && FullDirectoryName->Buffer[1] == '\0') {

                    Notify->CharacterSize = sizeof( WCHAR );

                } else {

                    Notify->CharacterSize = sizeof( CHAR );
                }

                if (FullDirectoryName->Length == Notify->CharacterSize) {

                    SetFlag( Notify->Flags, NOTIFY_DIR_IS_ROOT );
                }
            }

            Notify->CompletionFilter = CompletionFilter;

            //
            //  If we are to return data to the user then look for the length
            //  of the original buffer in the IrpSp.
            //

            if (!IgnoreBuffer) {

                Notify->BufferLength = IrpSp->Parameters.NotifyDirectory.Length;
            }

            Notify->OwningProcess = THREAD_TO_PROCESS( NotifyIrp->Tail.Overlay.Thread );
            InsertTailList( NotifyList, &Notify->NotifyList );

            Notify->ReferenceCount = 1;

        //
        //  If we have already been called with cleanup then complete
        //  the request immediately.
        //

        } else if (FlagOn( Notify->Flags, NOTIFY_CLEANUP_CALLED )) {

            //
            //  Always mark this Irp as pending returned.
            //

            IoMarkIrpPending( NotifyIrp );

            FsRtlCompleteRequest( NotifyIrp, STATUS_NOTIFY_CLEANUP );
            try_return( NOTHING );

        //
        //  If this file has been deleted then complete with STATUS_DELETE_PENDING.
        //

        } else if (FlagOn( Notify->Flags, NOTIFY_STREAM_IS_DELETED )) {

            //
            //  Always mark this Irp as pending returned.
            //

            IoMarkIrpPending( NotifyIrp );

            FsRtlCompleteRequest( NotifyIrp, STATUS_DELETE_PENDING );
            try_return( NOTHING );

        //
        //  If the notify pending flag is set or there is data in an internal buffer
        //  we complete this Irp immediately and exit.
        //

        } else if (FlagOn( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY )
                   && !FlagOn( Notify->Flags, NOTIFY_DEFER_NOTIFY )) {

            DebugTrace( 0, Dbg, "Notify has been pending\n", 0 );

            //
            //  Clear the flag in our notify structure before completing the
            //  Irp.  This will prevent a caller who reposts in his completion
            //  routine from looping in the completion routine.
            //

            ClearFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );

            //
            //  Always mark this Irp as pending returned.
            //

            IoMarkIrpPending( NotifyIrp );

            FsRtlCompleteRequest( NotifyIrp, STATUS_NOTIFY_ENUM_DIR );
            try_return( NOTHING );

        } else if (Notify->DataLength != 0
                   && !FlagOn( Notify->Flags, NOTIFY_DEFER_NOTIFY )) {

            ULONG ThisDataLength = Notify->DataLength;

            //
            //  Now set our buffer pointers back to indicate an empty buffer.
            //

            Notify->DataLength = 0;
            Notify->LastEntry = 0;

            FsRtlNotifyCompleteIrp( NotifyIrp,
                                    Notify,
                                    ThisDataLength,
                                    STATUS_SUCCESS,
                                    FALSE );

            try_return( NOTHING );
        }

        //
        //  Add the Irp to the tail of the notify queue.
        //

        NotifyIrp->IoStatus.Information = (ULONG_PTR) Notify;
        IoMarkIrpPending( NotifyIrp );
        InsertTailList( &Notify->NotifyIrps, &NotifyIrp->Tail.Overlay.ListEntry );

        //
        //  Increment the reference count to indicate that Irp might go through cancel.
        //

        InterlockedIncrement( &Notify->ReferenceCount );

        //
        //  Call the routine to set the cancel routine.
        //

        FsRtlNotifySetCancelRoutine( NotifyIrp, NULL );

    try_exit:  NOTHING;
    } finally {

        //
        //  Release the mutex.
        //

        ReleaseNotifySync( NotifySync );

        //
        //  If there is still a subject context then release it and deallocate
        //  the structure.  Remember that if FullDirectoryName is null, it means
        //  this is a view index, not a directory index, and the SubjectContext
        //  is really a piece of file system context information.
        //

        if ((SubjectContext != NULL) &&
            ((Notify == NULL) ||
             (Notify->FullDirectoryName != NULL))) {

            SeReleaseSubjectContext( SubjectContext );
            ExFreePool( SubjectContext );
        }

        DebugTrace( -1, Dbg, "FsRtlNotifyFullChangeDirectory:  Exit\n", 0 );
    }

    return;
}


VOID
FsRtlNotifyReportChange (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PSTRING FullTargetName,
    IN PSTRING TargetName,
    IN ULONG FilterMatch
    )

/*++

Routine Description:

    This routine is called by a file system when a file has been modified in
    such a way that it will cause a notify change Irp to complete.  We walk
    through all the notify structures looking for those structures which
    would be associated with an ancestor directory of the target file name.

    We look for all the notify structures which have a filter match and
    then check that the directory name in the notify structure is a
    proper prefix of the full target name.

    If we find a notify structure which matches the above conditions, we
    complete all the Irps for the notify structure.  If the structure has
    no Irps, we mark the notify pending field.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
                   structure to.

    FullTargetName  -  This is the full name of the file which has been
                       changed.

    TargetName  -  This is the final component of the modified file.

    FilterMatch  -  This flag field is compared with the completion filter
                    in the notify structure.  If any of the corresponding
                    bits in the completion filter are set, then a notify
                    condition exists.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyReportChange:  Entered\n", 0 );

    //
    //  Call the full notify routine to do the actual work.
    //

    FsRtlNotifyFilterReportChange( NotifySync,
                                   NotifyList,
                                   FullTargetName,
                                   (USHORT) (FullTargetName->Length - TargetName->Length),
                                   NULL,
                                   NULL,
                                   FilterMatch,
                                   0,
                                   NULL,
                                   NULL );

    DebugTrace( -1, Dbg, "FsRtlNotifyReportChange:  Exit\n", 0 );

    return;
}


VOID
FsRtlNotifyFullReportChange (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PSTRING FullTargetName,
    IN USHORT TargetNameOffset,
    IN PSTRING StreamName OPTIONAL,
    IN PSTRING NormalizedParentName OPTIONAL,
    IN ULONG FilterMatch,
    IN ULONG Action,
    IN PVOID TargetContext
    )

/*++

Routine Description:

    This routine is called by a file system when a file has been modified in
    such a way that it will cause a notify change Irp to complete.  We walk
    through all the notify structures looking for those structures which
    would be associated with an ancestor directory of the target file name.

    We look for all the notify structures which have a filter match and
    then check that the directory name in the notify structure is a
    proper prefix of the full target name.

    If we find a notify structure which matches the above conditions, we
    complete all the Irps for the notify structure.  If the structure has
    no Irps, we mark the notify pending field.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
        structure to.

    FullTargetName - This is the full name of the file from the root of the volume.

    TargetNameOffset - This is the offset in the full name of the final component
        of the name.

    StreamName  -  If present then this is the stream name to store with
        the filename.

    NormalizedParentName  -  If present this is the same path as the parent name
        but the DOS-ONLY names have been replaced with the associated long name.

    FilterMatch  -  This flag field is compared with the completion filter
        in the notify structure.  If any of the corresponding bits in the
        completion filter are set, then a notify condition exists.

    Action  -  This is the action code to store in the user's buffer if
        present.

    TargetContext  -  This is one of the context pointers to pass to the file
        system if performing a traverse check in the case of a tree being
        watched.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyReportChange:  Entered\n", 0 );

    //
    //  Call the full notify routine to do the actual work.
    //

    FsRtlNotifyFilterReportChange( NotifySync,
                                   NotifyList,
                                   FullTargetName,
                                   TargetNameOffset,
                                   StreamName,
                                   NormalizedParentName,
                                   FilterMatch,
                                   Action,
                                   TargetContext,
                                   NULL );

    DebugTrace( -1, Dbg, "FsRtlNotifyReportChange:  Exit\n", 0 );

    return;
}


VOID
FsRtlNotifyFilterReportChange (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PSTRING FullTargetName,
    IN USHORT TargetNameOffset,
    IN PSTRING StreamName OPTIONAL,
    IN PSTRING NormalizedParentName OPTIONAL,
    IN ULONG FilterMatch,
    IN ULONG Action,
    IN PVOID TargetContext,
    IN PVOID FilterContext
    )

/*++

Routine Description:

    This routine is called by a file system when a file has been modified in
    such a way that it will cause a notify change Irp to complete.  We walk
    through all the notify structures looking for those structures which
    would be associated with an ancestor directory of the target file name.

    We look for all the notify structures which have a filter match and
    then check that the directory name in the notify structure is a
    proper prefix of the full target name.

    If we find a notify structure which matches the above conditions, we
    complete all the Irps for the notify structure.  If the structure has
    no Irps, we mark the notify pending field.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
        structure to.

    FullTargetName - This is the full name of the file from the root of the volume.

    TargetNameOffset - This is the offset in the full name of the final component
        of the name.

    StreamName  -  If present then this is the stream name to store with
        the filename.

    NormalizedParentName  -  If present this is the same path as the parent name
        but the DOS-ONLY names have been replaced with the associated long name.

    FilterMatch  -  This flag field is compared with the completion filter
        in the notify structure.  If any of the corresponding bits in the
        completion filter are set, then a notify condition exists.

    Action  -  This is the action code to store in the user's buffer if
        present.

    TargetContext  -  This is one of the context pointers to pass to the file
        system if performing a traverse check in the case of a tree being
        watched.

    FilterContext - This is the filesystem-supplied routine used
        to call back into the filesystem to check whether each Notify block
        should see the change.  (Initially added for TxfNtfs development
        as part of a strategy to control when, not if, transactions see
        changes from other transactions.)

Return Value:

    None.

--*/

{
    PLIST_ENTRY NotifyLinks;

    STRING NormalizedParent;
    STRING ParentName;
    STRING TargetName;

    PNOTIFY_CHANGE Notify;
    STRING TargetParent;
    PIRP NotifyIrp;

    BOOLEAN NotifyIsParent;
    BOOLEAN ViewIndex = FALSE;
    UCHAR ComponentCount;
    ULONG SizeOfEntry;
    ULONG CurrentOffset;
    ULONG NextEntryOffset;
    ULONG ExceptionCode;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyFullReportChange:  Entered\n", 0 );

    //
    //  If this is a change to the root directory then return immediately.
    //

    if ((TargetNameOffset == 0) && (FullTargetName != NULL)) {

        DebugTrace( -1, Dbg, "FsRtlNotifyFullReportChange:  Exit\n", 0 );
        return;
    }

    ParentName.Buffer = NULL;
    TargetName.Buffer = NULL;

    //
    //  Acquire exclusive access to the list by acquiring the mutex.
    //

    AcquireNotifySync( NotifySync );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Walk through all the notify blocks.
        //

        for (NotifyLinks = NotifyList->Flink;
             NotifyLinks != NotifyList;
             NotifyLinks = NotifyLinks->Flink) {

            //
            //  Obtain the Notify structure from the list entry.
            //

            Notify = CONTAINING_RECORD( NotifyLinks, NOTIFY_CHANGE, NotifyList );

            //
            //  The rules for deciding whether this notification applies are
            //  different for view indices versus file name indices (directories).
            //

            if (FullTargetName == NULL) {

                ASSERTMSG( "Directory notify handle in view index notify list!", Notify->FullDirectoryName == NULL);

                //
                //  Make sure this is the Fcb being watched.
                //

                if (TargetContext != Notify->SubjectContext) {

                    continue;
                }

                TargetParent.Buffer = NULL;
                TargetParent.Length = 0;

                ViewIndex = TRUE;
                NotifyIsParent = FALSE;

            //
            //  Handle the directory case.
            //

            } else {

                ASSERTMSG( "View index notify handle in directory notify list!", Notify->FullDirectoryName != NULL);

                //
                //  If the length of the name in the notify block is currently zero then
                //  someone is doing a rename and we can skip this block.
                //

                if (Notify->FullDirectoryName->Length == 0) {

                    continue;
                }

                //
                //  If this filter match is not part of the completion filter then continue.
                //

                if (!(FilterMatch & Notify->CompletionFilter)) {

                    continue;
                }

                //
                //  If there is no normalized name then set its value from the full
                //  file name.
                //

                if (!ARGUMENT_PRESENT( NormalizedParentName )) {
                    NormalizedParent.Buffer = FullTargetName->Buffer;
                    NormalizedParent.Length = TargetNameOffset;

                    if (NormalizedParent.Length != Notify->CharacterSize) {

                        NormalizedParent.Length -= Notify->CharacterSize;
                    }

                    NormalizedParent.MaximumLength = NormalizedParent.Length;

                    NormalizedParentName = &NormalizedParent;
                }

                //
                //  If the length of the directory being watched is longer than the
                //  parent of the modified file then it can't be an ancestor of the
                //  modified file.
                //

                if (Notify->FullDirectoryName->Length > NormalizedParentName->Length) {

                    continue;
                }

                //
                //  If the lengths match exactly then this can only be the parent of
                //  the modified file.
                //

                if (NormalizedParentName->Length == Notify->FullDirectoryName->Length) {

                    NotifyIsParent = TRUE;

                //
                //  If we are not watching the subtree of this directory then continue.
                //

                } else if (!FlagOn( Notify->Flags, NOTIFY_WATCH_TREE )) {

                    continue;

                //
                //  The watched directory can only be an ancestor of the modified
                //  file.  Make sure that there is legal pathname separator immediately
                //  after the end of the watched directory name within the normalized name.
                //  If the watched directory is the root then we know this condition is TRUE.
                //

                } else {

                    if (!FlagOn( Notify->Flags, NOTIFY_DIR_IS_ROOT )) {

                        //
                        //  Check for the character size.
                        //

                        if (Notify->CharacterSize == sizeof( CHAR )) {

                            if (*(Add2Ptr( NormalizedParentName->Buffer,
                                           Notify->FullDirectoryName->Length,
                                           PCHAR )) != '\\') {

                                continue;
                            }

                        } else if (*(Add2Ptr( NormalizedParentName->Buffer,
                                              Notify->FullDirectoryName->Length,
                                              PWCHAR )) != L'\\') {

                            continue;
                        }
                    }

                    NotifyIsParent = FALSE;
                }

                //
                //  We now have a correct match of the name lengths.  Now verify that the
                //  characters match exactly.
                //

                if (!RtlEqualMemory( Notify->FullDirectoryName->Buffer,
                                     NormalizedParentName->Buffer,
                                     Notify->FullDirectoryName->Length )) {

                    continue;
                }

                //
                //  The characters are correct.  Now check in the case of a non-parent
                //  notify that we have traverse callback.
                //

                if (!NotifyIsParent &&
                    Notify->TraverseCallback != NULL &&
                    !Notify->TraverseCallback( Notify->FsContext,
                                               TargetContext,
                                               Notify->SubjectContext )) {

                    continue;
                }

                //
                //  Finally, if Notify block has a FilterRoutine *and* the caller specified
                //  a FilterContext, then we must finally call the filter routine.
                //

                if ((Notify->FilterCallback != NULL) &&
                    ARGUMENT_PRESENT( FilterContext ) &&
                    !Notify->FilterCallback( Notify->FsContext, FilterContext )) {

                    continue;
                }
            }

            //
            //  If this entry is going into a buffer then check that
            //  it will fit.
            //

            if (!FlagOn( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY )
                && Notify->BufferLength != 0) {

                ULONG AllocationLength;

                AllocationLength = 0;
                NotifyIrp = NULL;

                //
                //  If we don't already have a buffer then check to see
                //  if we have any Irps in the list and use the buffer
                //  length in the Irp.
                //

                if (Notify->ThisBufferLength == 0) {

                    //
                    //  If there is an entry in the list then get the length.
                    //

                    if (!IsListEmpty( &Notify->NotifyIrps )) {

                        PIO_STACK_LOCATION IrpSp;

                        NotifyIrp = CONTAINING_RECORD( Notify->NotifyIrps.Flink,
                                                       IRP,
                                                       Tail.Overlay.ListEntry );

                        IrpSp = IoGetCurrentIrpStackLocation( NotifyIrp );

                        AllocationLength = IrpSp->Parameters.NotifyDirectory.Length;

                    //
                    //  Otherwise use the caller's last buffer size.
                    //

                    } else {

                        AllocationLength = Notify->BufferLength;
                    }

                //
                //  Otherwise use the length of the current buffer.
                //

                } else {

                    AllocationLength = Notify->ThisBufferLength;
                }

                //
                //  Build the strings for the relative name.  This includes
                //  the strings for the parent name, file name and stream
                //  name.
                //

                if (!NotifyIsParent) {

                    //
                    //  We need to find the string for the ancestor of this
                    //  file from the watched directory.  If the normalized parent
                    //  name is the same as the parent name then we can use
                    //  the tail of the parent directly.  Otherwise we need to
                    //  count the matching name components and capture the
                    //  final components.
                    //

                    if (!ViewIndex) {

                        //
                        //  If the watched directory is the root then we just use the full
                        //  parent name.
                        //

                        if (FlagOn( Notify->Flags, NOTIFY_DIR_IS_ROOT ) ||
                            NormalizedParentName->Buffer != FullTargetName->Buffer) {

                            //
                            //  If we don't have a string for the parent then construct
                            //  it now.
                            //

                            if (ParentName.Buffer == NULL) {

                                ParentName.Buffer = FullTargetName->Buffer;
                                ParentName.Length = TargetNameOffset;

                                if (ParentName.Length != Notify->CharacterSize) {

                                    ParentName.Length -= Notify->CharacterSize;
                                }

                                ParentName.MaximumLength = ParentName.Length;
                            }

                            //
                            //  Count through the components of the parent until we have
                            //  swallowed the same number of name components as in the
                            //  watched directory name.  We have the unicode version and
                            //  the Ansi version to watch for.
                            //

                            ComponentCount = 0;
                            CurrentOffset = 0;

                            //
                            //  If this is the root then there is no more to do.
                            //

                            if (FlagOn( Notify->Flags, NOTIFY_DIR_IS_ROOT )) {

                                NOTHING;

                            } else {

                                ULONG ParentComponentCount;
                                ULONG ParentOffset;

                                ParentComponentCount = 1;
                                ParentOffset = 0;

                                if (Notify->CharacterSize == sizeof( CHAR )) {

                                    //
                                    //  Find the number of components in the parent.  We
                                    //  have to do this for each one because this name and
                                    //  the number of components could have changed.
                                    //

                                    while (ParentOffset < Notify->FullDirectoryName->Length) {

                                        if (*((PCHAR) Notify->FullDirectoryName->Buffer + ParentOffset) == '\\') {

                                            ParentComponentCount += 1;
                                        }

                                        ParentOffset += 1;
                                    }

                                    while (TRUE) {

                                        if (*((PCHAR) ParentName.Buffer + CurrentOffset) == '\\') {

                                            ComponentCount += 1;

                                            if (ComponentCount == ParentComponentCount) {

                                                break;
                                            }

                                        }

                                        CurrentOffset += 1;
                                    }

                                } else {

                                    //
                                    //  Find the number of components in the parent.  We
                                    //  have to do this for each one because this name and
                                    //  the number of components could have changed.
                                    //

                                    while (ParentOffset < Notify->FullDirectoryName->Length / sizeof( WCHAR )) {

                                        if (*((PWCHAR) Notify->FullDirectoryName->Buffer + ParentOffset) == '\\') {

                                            ParentComponentCount += 1;
                                        }

                                        ParentOffset += 1;
                                    }

                                    while (TRUE) {

                                        if (*((PWCHAR) ParentName.Buffer + CurrentOffset) == L'\\') {

                                            ComponentCount += 1;

                                            if (ComponentCount == ParentComponentCount) {

                                                break;
                                            }
                                        }

                                        CurrentOffset += 1;
                                    }

                                    //
                                    //  Convert characters to bytes.
                                    //

                                    CurrentOffset *= Notify->CharacterSize;
                                }
                            }

                            //
                            //  We now know the offset into the parent name of the separator
                            //  immediately preceding the relative parent name.  Construct the
                            //  target parent name for the buffer.
                            //

                            CurrentOffset += Notify->CharacterSize;

                            TargetParent.Buffer = Add2Ptr( ParentName.Buffer,
                                                           CurrentOffset,
                                                           PCHAR );
                            TargetParent.MaximumLength =
                            TargetParent.Length = ParentName.Length - (USHORT) CurrentOffset;

                        //
                        //  If the normalized is the same as the parent name use the portion
                        //  after the match with the watched directory.
                        //

                        } else {

                            TargetParent.Buffer = Add2Ptr( NormalizedParentName->Buffer,
                                                           (Notify->FullDirectoryName->Length +
                                                            Notify->CharacterSize),
                                                           PCHAR );

                            TargetParent.MaximumLength =
                            TargetParent.Length = NormalizedParentName->Length -
                                                  Notify->FullDirectoryName->Length -
                                                  Notify->CharacterSize;

                        }
                    }

                } else {

                    //
                    //  The length of the target parent is zero.
                    //

                    TargetParent.Length = 0;
                }

                //
                //  Compute how much buffer space this report will take.
                //

                SizeOfEntry = FIELD_OFFSET( FILE_NOTIFY_INFORMATION, FileName );

                if (ViewIndex) {

                    //
                    //  In the view index case, the information to copy to the
                    //  buffer comes to us in the stream name, and that is all
                    //  the room we need to worry about having.
                    //

                    ASSERT(ARGUMENT_PRESENT( StreamName ));

                    SizeOfEntry += StreamName->Length;

                } else {

                    //
                    //  If there is a parent to report, find the size and include a separator
                    //  character.
                    //

                    if (!NotifyIsParent) {

                        if (Notify->CharacterSize == sizeof( CHAR )) {

                            SizeOfEntry += RtlOemStringToCountedUnicodeSize( &TargetParent );

                        } else {

                            SizeOfEntry += TargetParent.Length;
                        }

                        //
                        //  Include the separator.  This is always a unicode character.
                        //

                        SizeOfEntry += sizeof( WCHAR );
                    }

                    //
                    //  If we don't have the string for the target then construct it now.
                    //

                    if (TargetName.Buffer == NULL) {

                        TargetName.Buffer = Add2Ptr( FullTargetName->Buffer, TargetNameOffset, PCHAR );
                        TargetName.MaximumLength =
                        TargetName.Length = FullTargetName->Length - TargetNameOffset;
                    }

                    if (Notify->CharacterSize == sizeof( CHAR )) {

                        SizeOfEntry += RtlOemStringToCountedUnicodeSize( &TargetName );

                    } else {

                        SizeOfEntry += TargetName.Length;
                    }

                    //
                    //  If there is a stream name then add the bytes needed
                    //  for that.
                    //

                    if (ARGUMENT_PRESENT( StreamName )) {

                        //
                        //  Add the space needed for the ':' separator.
                        //

                        if (Notify->CharacterSize == sizeof( WCHAR )) {

                            SizeOfEntry += (StreamName->Length + sizeof( WCHAR ));

                        } else {

                            SizeOfEntry += (RtlOemStringToCountedUnicodeSize( StreamName )
                                            + sizeof( CHAR ));
                        }
                    }
                }

                //
                //  Remember if this report would overflow the buffer.
                //

                NextEntryOffset = (ULONG)LongAlign( Notify->DataLength );

                if (SizeOfEntry <= AllocationLength
                    && (NextEntryOffset + SizeOfEntry) <= AllocationLength) {

                    PFILE_NOTIFY_INFORMATION NotifyInfo = NULL;

                    //
                    //  If there is already a notify buffer, we append this
                    //  data to it.
                    //

                    if (Notify->Buffer != NULL) {

                        NotifyInfo = Add2Ptr( Notify->Buffer,
                                              Notify->LastEntry,
                                              PFILE_NOTIFY_INFORMATION );

                        NotifyInfo->NextEntryOffset = NextEntryOffset - Notify->LastEntry;

                        Notify->LastEntry = NextEntryOffset;

                        NotifyInfo = Add2Ptr( Notify->Buffer,
                                              Notify->LastEntry,
                                              PFILE_NOTIFY_INFORMATION );

                    //
                    //  If there is an Irp list we check whether we will need
                    //  to allocate a new buffer.
                    //

                    } else if (NotifyIrp != NULL) {

                        if (NotifyIrp->AssociatedIrp.SystemBuffer != NULL) {

                            Notify->Buffer =
                            NotifyInfo = NotifyIrp->AssociatedIrp.SystemBuffer;

                            Notify->ThisBufferLength = AllocationLength;

                        } else if (NotifyIrp->MdlAddress != NULL) {

                            Notify->Buffer =
                            NotifyInfo = MmGetSystemAddressForMdl( NotifyIrp->MdlAddress );

                            Notify->ThisBufferLength = AllocationLength;
                        }
                    }

                    //
                    //  If we need to allocate a buffer, we will charge quota
                    //  to the original process and allocate paged pool.
                    //

                    if (Notify->Buffer == NULL) {

                        BOOLEAN ChargedQuota = FALSE;

                        try {

                            PsChargePoolQuota( Notify->OwningProcess,
                                               PagedPool,
                                               AllocationLength );

                            ChargedQuota = TRUE;

                            Notify->AllocatedBuffer =
                            Notify->Buffer = FsRtlpAllocatePool( PagedPool,
                                                                 AllocationLength );

                            Notify->ThisBufferLength = AllocationLength;

                            NotifyInfo = Notify->Buffer;

                        } except(( ExceptionCode = GetExceptionCode(), FsRtlIsNtstatusExpected(ExceptionCode))
                                  ? EXCEPTION_EXECUTE_HANDLER
                                  : EXCEPTION_CONTINUE_SEARCH ) {


                            ASSERT( (ExceptionCode == STATUS_INSUFFICIENT_RESOURCES) ||
                                    (ExceptionCode == STATUS_QUOTA_EXCEEDED) );

                            //
                            //  Return quota if we allocated the buffer.
                            //

                            if (ChargedQuota) {

                                PsReturnProcessPagedPoolQuota( Notify->OwningProcess,
                                                               AllocationLength );

                            }

                            //
                            //  Forget any current buffer and resort to immediate
                            //  notify.
                            //

                            SetFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
                        }
                    }

                    //
                    //  If we have a buffer then fill in the results
                    //  from this operation.  Otherwise we remember
                    //  to simply alert the caller.
                    //

                    if (NotifyInfo != NULL) {

                        //
                        //  Update the buffer with the current data.
                        //

                        if (FsRtlNotifyUpdateBuffer( NotifyInfo,
                                                     Action,
                                                     &TargetParent,
                                                     &TargetName,
                                                     StreamName,
                                                     (BOOLEAN) (Notify->CharacterSize == sizeof( WCHAR )),
                                                     SizeOfEntry )) {

                            //
                            //  Update the buffer data length.
                            //

                            Notify->DataLength = NextEntryOffset + SizeOfEntry;

                        //
                        //  We couldn't copy the data into the buffer.  Just
                        //  notify without any additional information.
                        //

                        } else {

                            SetFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
                        }
                    }

                } else {

                    SetFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
                }

                //
                //  If we have a buffer but can't use it then clear all of the
                //  buffer related fields.  Also deallocate any buffer allocated
                //  by us.
                //

                if (FlagOn( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY )
                    && Notify->Buffer != NULL) {

                    if (Notify->AllocatedBuffer != NULL) {

                        PsReturnProcessPagedPoolQuota( Notify->OwningProcess,
                                                       Notify->ThisBufferLength );

                        ExFreePool( Notify->AllocatedBuffer );
                    }

                    Notify->AllocatedBuffer = Notify->Buffer = NULL;

                    Notify->ThisBufferLength = Notify->DataLength = Notify->LastEntry = 0;
                }
            }

            //
            //  Complete the next entry on the list if we aren't holding
            //  up notification.
            //

            if (Action == FILE_ACTION_RENAMED_OLD_NAME) {

                SetFlag( Notify->Flags, NOTIFY_DEFER_NOTIFY );

            } else {

                ClearFlag( Notify->Flags, NOTIFY_DEFER_NOTIFY );

                if (!IsListEmpty( &Notify->NotifyIrps )) {

                    FsRtlNotifyCompleteIrpList( Notify, STATUS_SUCCESS );
                }
            }
        }

    } finally {

        ReleaseNotifySync( NotifySync );

        DebugTrace( -1, Dbg, "FsRtlNotifyFullReportChange:  Exit\n", 0 );
    }

    return;
}


VOID
FsRtlNotifyCleanup (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PVOID FsContext
    )

/*++

Routine Description:

    This routine is called for a cleanup of a user directory handle.  We
    walk through our notify structures looking for a matching context field.
    We complete all the pending notify Irps for this Notify structure, remove
    the notify structure and deallocate it.

Arguments:

    NotifySync  -  This is the controlling fast mutex for this notify list.
        It is stored here so that it can be found for an Irp which is being
        cancelled.

    NotifyList  -  This is the start of the notify list to add this
                   structure to.

    FsContext  -  This is a unique value assigned by the file system to
                  identify a particular notify structure.

Return Value:

    None.

--*/

{
    PNOTIFY_CHANGE Notify;
    PSECURITY_SUBJECT_CONTEXT SubjectContext = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyCleanup:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Mutex             -> %08lx\n", Mutex );
    DebugTrace(  0, Dbg, "Notify List       -> %08lx\n", NotifyList );
    DebugTrace(  0, Dbg, "FsContext         -> %08lx\n", FsContext );

    //
    //  Acquire exclusive access to the list by acquiring the mutex.
    //

    AcquireNotifySync( NotifySync );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Search for a match on the list.
        //

        Notify = FsRtlIsNotifyOnList( NotifyList, FsContext );

        //
        //  If found, then complete all the Irps with STATUS_NOTIFY_CLEANUP
        //

        if (Notify != NULL) {

            //
            //  Set the flag to indicate that we have been called with cleanup.
            //

            SetFlag( Notify->Flags, NOTIFY_CLEANUP_CALLED );

            if (!IsListEmpty( &Notify->NotifyIrps )) {

                FsRtlNotifyCompleteIrpList( Notify, STATUS_NOTIFY_CLEANUP );
            }

            //
            //  Cleanup can only occur once, and will always remove the notify from
            //  the list.  Cancel will defer this work to cleanup, and cannot free
            //  a notify which has not gone through cleanup since we have a ref
            //  to ensure it.
            //

            RemoveEntryList( &Notify->NotifyList );

            //
            //  We assert this in cancel routine.
            //

#if DBG
            Notify->NotifyList.Flink = NULL;
#endif

            InterlockedDecrement( &Notify->ReferenceCount );

            if (Notify->ReferenceCount == 0) {

                if (Notify->AllocatedBuffer != NULL) {

                    PsReturnProcessPagedPoolQuota( Notify->OwningProcess,
                                                   Notify->ThisBufferLength );

                    ExFreePool( Notify->AllocatedBuffer );
                }

                if (Notify->FullDirectoryName != NULL) {

                    SubjectContext = Notify->SubjectContext;
                }

                ExFreePool( Notify );
            }
        }

    } finally {

        ReleaseNotifySync( NotifySync );

        if (SubjectContext != NULL) {

            SeReleaseSubjectContext( SubjectContext );
            ExFreePool( SubjectContext );
        }

        DebugTrace( -1, Dbg, "FsRtlNotifyCleanup:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine
//

PNOTIFY_CHANGE
FsRtlIsNotifyOnList (
    IN PLIST_ENTRY NotifyListHead,
    IN PVOID FsContext
    )

/*++

Routine Description:

    This routine is called to walk through a notify list searching for
    a member associated with the FsContext value.

Arguments:

    NotifyListHead  -  This is the start of the notify list.

    FsContext  -  This is supplied by the file system so that this notify
                  structure can be uniquely identified.

Return Value:

    PNOTIFY_CHANGE - A pointer to the matching structure is returned.  NULL
                     is returned if the structure isn't present.

--*/

{
    PLIST_ENTRY Link;

    PNOTIFY_CHANGE ThisNotify;
    PNOTIFY_CHANGE Notify;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlIsNotifyOnList:  Entered\n", 0 );

    //
    //  Assume we won't have a match.
    //

    Notify = NULL;

    //
    //  Walk through all the entries on the list looking for a match.
    //

    for (Link = NotifyListHead->Flink;
         Link != NotifyListHead;
         Link = Link->Flink) {

        //
        //  Obtain the notify structure from the link.
        //

        ThisNotify = CONTAINING_RECORD( Link, NOTIFY_CHANGE, NotifyList );

        //
        //  If the context field matches, remember this structure and
        //  exit.
        //

        if (ThisNotify->FsContext == FsContext) {

            Notify = ThisNotify;
            break;
        }
    }

    DebugTrace(  0, Dbg, "Notify Structure  -> %08lx\n", Notify );
    DebugTrace( -1, Dbg, "FsRtlIsNotifyOnList:  Exit\n", 0 );

    return Notify;
}


//
//  Local support routine
//

VOID
FsRtlNotifyCompleteIrp (
    IN PIRP NotifyIrp,
    IN PNOTIFY_CHANGE Notify,
    IN ULONG DataLength,
    IN NTSTATUS Status,
    IN ULONG CheckCancel
    )

/*++

Routine Description:

    This routine is called to complete an Irp with the data in the NOTIFY_CHANGE
    structure.

Arguments:

    NotifyIrp  -  Irp to complete.

    Notify  -  Notify structure which contains the data.

    DataLength  -  This is the length of the data in the buffer in the notify
        structure.  A value of zero indicates that we should complete the
        request with STATUS_NOTIFY_ENUM_DIR.

    Status  -  Indicates the status to complete the Irp with.

    CheckCancel - Indicates if we should only complete the irp if we clear the cancel routine
        ourselves.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlIsNotifyCompleteIrp:  Entered\n", 0 );

    //
    //  Attempt to clear the cancel routine.  If this routine owns the cancel
    //  routine then it can complete the irp.  Otherwise there is a cancel underway
    //  on this.
    //

    if (FsRtlNotifySetCancelRoutine( NotifyIrp, Notify ) || !CheckCancel) {

        //
        //  We only process the buffer if the status is STATUS_SUCCESS.
        //

        if (Status == STATUS_SUCCESS) {

            //
            //  Get the current Stack location
            //

            IrpSp = IoGetCurrentIrpStackLocation( NotifyIrp );

            //
            //  If the data won't fit in the user's buffer or there was already a
            //  buffer overflow then return the alternate status code.  If the data
            //  was already stored in the Irp buffer then we know that we won't
            //  take this path.  Otherwise we wouldn't be cleaning up the Irp
            //  correctly.
            //

            if (DataLength == 0
                || IrpSp->Parameters.NotifyDirectory.Length < DataLength) {

                Status = STATUS_NOTIFY_ENUM_DIR;

            //
            //  We have to carefully return the buffer to the user and handle all
            //  of the different buffer cases.  If there is no allocated buffer
            //  in the notify structure it means that we have already used the
            //  caller's buffer.
            //
            //  1 - If the system allocated an associated system buffer we
            //      can simply fill that in.
            //
            //  2 - If there is an Mdl then we get a system address for the Mdl
            //      and copy the data into it.
            //
            //  3 - If there is only a user's buffer and pending has not been
            //      returned, we can fill the user's buffer in directly.
            //
            //  4 - If there is only a user's buffer and pending has been returned
            //      then we are not in the user's address space.  We dress up
            //      the Irp with our system buffer and let the Io system
            //      copy the data in.
            //

            } else {

                if (Notify->AllocatedBuffer != NULL) {

                    //
                    //  Protect the copy with a try-except and ignore the buffer
                    //  if we have some error in copying it to the buffer.
                    //

                    try {

                        if (NotifyIrp->AssociatedIrp.SystemBuffer != NULL) {

                            RtlCopyMemory( NotifyIrp->AssociatedIrp.SystemBuffer,
                                           Notify->AllocatedBuffer,
                                           DataLength );

                        } else if (NotifyIrp->MdlAddress != NULL) {

                            RtlCopyMemory( MmGetSystemAddressForMdl( NotifyIrp->MdlAddress ),
                                           Notify->AllocatedBuffer,
                                           DataLength );

                        } else if (!FlagOn( IrpSp->Control, SL_PENDING_RETURNED )) {

                            RtlCopyMemory( NotifyIrp->UserBuffer,
                                           Notify->AllocatedBuffer,
                                           DataLength );

                        } else {

                            NotifyIrp->Flags |= (IRP_BUFFERED_IO | IRP_INPUT_OPERATION | IRP_DEALLOCATE_BUFFER);
                            NotifyIrp->AssociatedIrp.SystemBuffer = Notify->AllocatedBuffer;

                        }

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        Status = STATUS_NOTIFY_ENUM_DIR;
                        DataLength = 0;
                    }

                    //
                    //  Return the quota and deallocate the buffer if we didn't pass it
                    //  back via the irp.
                    //

                    PsReturnProcessPagedPoolQuota( Notify->OwningProcess, Notify->ThisBufferLength );

                    if (Notify->AllocatedBuffer != NotifyIrp->AssociatedIrp.SystemBuffer
                        && Notify->AllocatedBuffer != NULL) {

                        ExFreePool( Notify->AllocatedBuffer );
                    }

                    Notify->AllocatedBuffer = NULL;
                    Notify->ThisBufferLength = 0;
                }

                //
                //  Update the data length in the Irp.
                //

                NotifyIrp->IoStatus.Information = DataLength;

                //
                //  Show that there is no buffer in the notify package
                //  anymore.
                //

                Notify->Buffer = NULL;
            }
        }

        //
        //  Make sure the Irp is marked as pending returned.
        //

        IoMarkIrpPending( NotifyIrp );

        //
        //  Now complete the request.
        //

        FsRtlCompleteRequest( NotifyIrp, Status );
    }

    DebugTrace( -1, Dbg, "FsRtlIsNotifyCompleteIrp:  Exit\n", 0 );

    return;
}


//
//  Local support routine
//

BOOLEAN
FsRtlNotifySetCancelRoutine (
    IN PIRP NotifyIrp,
    IN PNOTIFY_CHANGE Notify OPTIONAL
    )

/*++

Routine Description:

    This is a separate routine because it cannot be paged.

Arguments:

    NotifyIrp  -  Set the cancel routine in this Irp.

    Notify - If NULL then we are setting the cancel routine.  If not-NULL then we
        are clearing the cancel routine.  If the cancel routine is not-null then
        we need to decrement the reference count on this Notify structure

Return Value:

    BOOLEAN - Only meaningfull if Notify is specified.  It indicates if this
        routine cleared the cancel routine.  FALSE indicates that the cancel
        routine is processing the Irp.

--*/

{
    BOOLEAN ClearedCancel = FALSE;
    PDRIVER_CANCEL CurrentCancel;

    //
    //  Grab the cancel spinlock and set our cancel routine in the Irp.
    //

    IoAcquireCancelSpinLock( &NotifyIrp->CancelIrql );

    //
    //  If we are completing an Irp then clear the cancel routine and
    //  the information field.
    //

    if (ARGUMENT_PRESENT( Notify )) {

        CurrentCancel = IoSetCancelRoutine( NotifyIrp, NULL );
        NotifyIrp->IoStatus.Information = 0;

        IoReleaseCancelSpinLock( NotifyIrp->CancelIrql );

        //
        //  If the current cancel routine is non-NULL then decrement the reference count
        //  in the Notify.
        //

        if (CurrentCancel != NULL) {

            InterlockedDecrement( &Notify->ReferenceCount );
            ClearedCancel = TRUE;
        }

    //
    //  If the cancel flag is set, we complete the Irp with cancelled
    //  status and exit.
    //

    } else if (NotifyIrp->Cancel) {

            DebugTrace( 0, Dbg, "Irp has been cancelled\n", 0 );

            FsRtlCancelNotify( NULL, NotifyIrp );

    } else {

        //
        //  Set our cancel routine in the Irp.
        //

        IoSetCancelRoutine( NotifyIrp, FsRtlCancelNotify );

        IoReleaseCancelSpinLock( NotifyIrp->CancelIrql );
    }

    return ClearedCancel;
}


//
//  Local support routine
//

BOOLEAN
FsRtlNotifyUpdateBuffer (
    IN PFILE_NOTIFY_INFORMATION NotifyInfo,
    IN ULONG FileAction,
    IN PSTRING ParentName,
    IN PSTRING TargetName,
    IN PSTRING StreamName OPTIONAL,
    IN BOOLEAN UnicodeName,
    IN ULONG SizeOfEntry
    )

/*++

Routine Description:

    This routine is called to fill in a FILE_NOTIFY_INFORMATION structure for a
    notify change event.  The main work is in converting an OEM string to Unicode.

Arguments:

    NotifyInfo  -  Information structure to complete.

    FileAction  -  Action which triggered the notification event.

    ParentName  -  Relative path to the parent of the changed file from the
        directory being watched.  The length for this will be zero if the modified
        file is in the watched directory.

    TargetName  -  This is the name of the modified file.

    StreamName  -  If present there is a stream name to append to the filename.

    UnicodeName  -  Indicates if the above name is Unicode or Oem.

    SizeOfEntry  -  Indicates the number of bytes to be used in the buffer.

Return Value:

    BOOLEAN - TRUE if we were able to update the buffer, FALSE otherwise.

--*/

{
    BOOLEAN CopiedToBuffer;
    ULONG BufferOffset = 0;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyUpdateBuffer:  Entered\n", 0 );

    //
    //  Protect the entire call with a try-except.  If we had an error
    //  we will assume that we have a bad buffer and we won't return
    //  the data in the buffer.
    //

    try {

        //
        //  Update the common fields in the notify information.
        //

        NotifyInfo->NextEntryOffset = 0;
        NotifyInfo->Action = FileAction;

        NotifyInfo->FileNameLength = SizeOfEntry - FIELD_OFFSET( FILE_NOTIFY_INFORMATION, FileName );

        //
        //  If we have a unicode name, then copy the data directly into the output buffer.
        //

        if (UnicodeName) {

            if (ParentName->Length != 0) {

                RtlCopyMemory( NotifyInfo->FileName,
                               ParentName->Buffer,
                               ParentName->Length );

                *(Add2Ptr( NotifyInfo->FileName, ParentName->Length, PWCHAR )) = L'\\';
                BufferOffset = ParentName->Length + sizeof( WCHAR );
            }

            RtlCopyMemory( Add2Ptr( NotifyInfo->FileName,
                                    BufferOffset,
                                    PVOID ),
                           TargetName->Buffer,
                           TargetName->Length );

            if (ARGUMENT_PRESENT( StreamName )) {

                BufferOffset += TargetName->Length;

                *(Add2Ptr( NotifyInfo->FileName, BufferOffset, PWCHAR )) = L':';

                RtlCopyMemory( Add2Ptr( NotifyInfo->FileName,
                                        BufferOffset + sizeof( WCHAR ),
                                        PVOID ),
                               StreamName->Buffer,
                               StreamName->Length );
            }

        //
        //  For a non-unicode name, use the conversion routines.
        //

        } else {

            ULONG BufferLength;

            if (ParentName->Length != 0) {

                RtlOemToUnicodeN( NotifyInfo->FileName,
                                  NotifyInfo->FileNameLength,
                                  &BufferLength,
                                  ParentName->Buffer,
                                  ParentName->Length );

                *(Add2Ptr( NotifyInfo->FileName, BufferLength, PWCHAR )) = L'\\';

                BufferOffset = BufferLength + sizeof( WCHAR );
            }

            //
            //  For view indices, we do not have a parent name.
            //

            if (ParentName->Length == 0) {

                ASSERT(ARGUMENT_PRESENT( StreamName ));

                RtlCopyMemory( Add2Ptr( NotifyInfo->FileName,
                                           BufferOffset,
                                           PCHAR ),
                               StreamName->Buffer,
                               StreamName->Length );

            } else {

                RtlOemToUnicodeN( Add2Ptr( NotifyInfo->FileName,
                                           BufferOffset,
                                           PWCHAR ),
                                  NotifyInfo->FileNameLength,
                                  &BufferLength,
                                  TargetName->Buffer,
                                  TargetName->Length );

                if (ARGUMENT_PRESENT( StreamName )) {

                    BufferOffset += BufferLength;

                    *(Add2Ptr( NotifyInfo->FileName, BufferOffset, PWCHAR )) = L':';

                    RtlOemToUnicodeN( Add2Ptr( NotifyInfo->FileName,
                                               BufferOffset + sizeof( WCHAR ),
                                               PWCHAR ),
                                      NotifyInfo->FileNameLength,
                                      &BufferLength,
                                      StreamName->Buffer,
                                      StreamName->Length );
                }
            }
        }

        CopiedToBuffer = TRUE;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        CopiedToBuffer = FALSE;
    }

    DebugTrace( -1, Dbg, "FsRtlNotifyUpdateBuffer:  Exit\n", 0 );

    return CopiedToBuffer;
}


//
//  Local support routine
//

VOID
FsRtlNotifyCompleteIrpList (
    IN OUT PNOTIFY_CHANGE Notify,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine walks through the Irps for a particular notify structure
    and completes the Irps with the indicated status.  If the status is
    STATUS_SUCCESS then we are completing an Irp because of a notification event.
    In that case we look at the notify structure to decide if we can return the
    data to the user.

Arguments:

    Notify  -  This is the notify change structure.

    Status  -  Indicates the status used to complete the request.  If this status
        is STATUS_SUCCESS then we only want to complete one Irp.  Otherwise we
        want complete all the Irps in the list.

Return Value:

    None.

--*/

{
    PIRP Irp;
    ULONG DataLength;

    DebugTrace( +1, Dbg, "FsRtlNotifyCompleteIrpList:  Entered\n", 0 );

    DataLength = Notify->DataLength;

    //
    //  Clear the fields to indicate that there is no more data to return.
    //

    ClearFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
    Notify->DataLength = 0;
    Notify->LastEntry = 0;

    //
    //  Walk through all the Irps in the list.  We are never called unless
    //  there is at least one irp.
    //

    do {

        Irp = CONTAINING_RECORD( Notify->NotifyIrps.Flink, IRP, Tail.Overlay.ListEntry );

        RemoveHeadList( &Notify->NotifyIrps );

        //
        //  Call our completion routine to complete the request.
        //

        FsRtlNotifyCompleteIrp( Irp,
                                Notify,
                                DataLength,
                                Status,
                                TRUE );

        //
        //  If we were only to complete one Irp then break now.
        //

        if (Status == STATUS_SUCCESS) {

            break;
        }

    } while (!IsListEmpty( &Notify->NotifyIrps ));

    DebugTrace( -1, Dbg, "FsRtlNotifyCompleteIrpList:  Exit\n", 0 );

    return;
}


//
//  Local support routine
//

VOID
FsRtlCancelNotify (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP ThisIrp
    )

/*++

Routine Description:

    This routine is for an Irp which is being cancelled.  We Null the cancel
    routine and then walk through the Irps for this notify structure and
    complete all cancelled Irps.  It is possible there is pending notify
    stored in the buffer for this Irp.  In this case we want to copy the
    data to a system buffer if possible.

Arguments:

    DeviceObject - Ignored.

    ThisIrp  -  This is the Irp to cancel.

Return Value:

    None.

--*/

{
    PSECURITY_SUBJECT_CONTEXT SubjectContext = NULL;

    PNOTIFY_CHANGE Notify;
    PNOTIFY_SYNC NotifySync;
    LONG ExceptionCode;

    UNREFERENCED_PARAMETER( DeviceObject );

    DebugTrace( +1, Dbg, "FsRtlCancelNotify:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Irp   -> %08lx\n", Irp );

    //
    //  Capture the notify structure.
    //

    Notify = (PNOTIFY_CHANGE) ThisIrp->IoStatus.Information;

    //
    //  Void the cancel routine and release the cancel spinlock.
    //

    IoSetCancelRoutine( ThisIrp, NULL );
    ThisIrp->IoStatus.Information = 0;
    IoReleaseCancelSpinLock( ThisIrp->CancelIrql );

    FsRtlEnterFileSystem();

    //
    //  Grab the mutex for this structure.
    //

    NotifySync = Notify->NotifySync;
    AcquireNotifySync( NotifySync );

    //
    //  Use a try finally to faciltate cleanup.
    //

    try {

        //
        //  Remove the Irp from the queue.
        //

        RemoveEntryList( &ThisIrp->Tail.Overlay.ListEntry );

        IoMarkIrpPending( ThisIrp );

        //
        //  We now have the Irp.  Check to see if there is data stored
        //  in the buffer for this Irp.
        //

        if (Notify->Buffer != NULL
            && Notify->AllocatedBuffer == NULL

            && ((ThisIrp->MdlAddress != NULL
                 && MmGetSystemAddressForMdl( ThisIrp->MdlAddress ) == Notify->Buffer)

                || (Notify->Buffer == ThisIrp->AssociatedIrp.SystemBuffer))) {

            PIRP NextIrp;
            PVOID NewBuffer;
            ULONG NewBufferLength;
            PIO_STACK_LOCATION  IrpSp;

            //
            //  Initialize the above values.
            //

            NewBuffer = NULL;
            NewBufferLength = 0;

            //
            //  Remember the next Irp on the list.  Find the length of any
            //  buffer it might have.  Also keep a pointer to the buffer
            //  if present.
            //

            if (!IsListEmpty( &Notify->NotifyIrps )) {

                NextIrp = CONTAINING_RECORD( Notify->NotifyIrps.Flink,
                                             IRP,
                                             Tail.Overlay.ListEntry );

                IrpSp = IoGetCurrentIrpStackLocation( NextIrp );

                //
                //  If the buffer here is large enough to hold the data we
                //  can use that buffer.
                //

                if (IrpSp->Parameters.NotifyDirectory.Length >= Notify->DataLength) {

                    //
                    //  If there is a system buffer or Mdl then get a new
                    //  buffer there.
                    //

                    if (NextIrp->AssociatedIrp.SystemBuffer != NULL) {

                        NewBuffer = NextIrp->AssociatedIrp.SystemBuffer;

                    } else if (NextIrp->MdlAddress != NULL) {

                        NewBuffer = MmGetSystemAddressForMdl( NextIrp->MdlAddress );
                    }

                    NewBufferLength = IrpSp->Parameters.NotifyDirectory.Length;

                    if (NewBufferLength > Notify->BufferLength) {

                        NewBufferLength = Notify->BufferLength;
                    }
                }

            //
            //  Otherwise check if the user's original buffer is larger than
            //  the current buffer.
            //

            } else if (Notify->BufferLength >= Notify->DataLength) {

                NewBufferLength = Notify->BufferLength;
            }

            //
            //  If we have a new buffer length then we either have a new
            //  buffer or need to allocate one.  We will do this under
            //  the protection of a try-except in order to continue in the
            //  event of a failure.
            //

            if (NewBufferLength != 0) {

                BOOLEAN ChargedQuota;

                try {

                    ChargedQuota = FALSE;

                    if (NewBuffer == NULL) {

                        PsChargePoolQuota( Notify->OwningProcess,
                                           PagedPool,
                                           NewBufferLength );

                        ChargedQuota = TRUE;

                        //
                        //  If we didn't get an error then attempt to
                        //  allocate the pool.  If there is an error
                        //  don't forget to release the quota.
                        //

                        NewBuffer = FsRtlpAllocatePool( PagedPool,
                                                        NewBufferLength );

                        Notify->AllocatedBuffer = NewBuffer;
                    }

                    //
                    //  Now copy the data over to the new buffer.
                    //

                    RtlCopyMemory( NewBuffer,
                                   Notify->Buffer,
                                   Notify->DataLength );

                    //
                    //  It is possible that the buffer size changed.
                    //

                    Notify->ThisBufferLength = NewBufferLength;
                    Notify->Buffer = NewBuffer;

                } except( FsRtlIsNtstatusExpected( ExceptionCode = GetExceptionCode()) ?
                          EXCEPTION_EXECUTE_HANDLER :
                          EXCEPTION_CONTINUE_SEARCH ) {

                    ASSERT( (ExceptionCode == STATUS_INSUFFICIENT_RESOURCES) ||
                            (ExceptionCode == STATUS_QUOTA_EXCEEDED) );

                    //
                    //  Return quota if we allocated the buffer.
                    //

                    if (ChargedQuota) {

                        PsReturnProcessPagedPoolQuota( Notify->OwningProcess,
                                                       NewBufferLength );
                    }

                    //
                    //  Forget any current buffer and resort to immediate
                    //  notify.
                    //

                    SetFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
                }

            //
            //  Otherwise set the immediate notify flag.
            //

            } else {

                SetFlag( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY );
            }

            //
            //  If the immediate notify flag is set then clear the other
            //  values in the notify structures.
            //

            if (FlagOn( Notify->Flags, NOTIFY_IMMEDIATE_NOTIFY )) {

                //
                //  Forget any current buffer and resort to immediate
                //  notify.
                //

                Notify->AllocatedBuffer = Notify->Buffer = NULL;

                Notify->ThisBufferLength =
                Notify->DataLength = Notify->LastEntry = 0;
            }
        }

        //
        //  Complete the Irp with status cancelled.
        //

        FsRtlCompleteRequest( ThisIrp, STATUS_CANCELLED );

        //
        //  Decrement the count of Irps that might go through the cancel path.
        //

        InterlockedDecrement( &Notify->ReferenceCount );

        if (Notify->ReferenceCount == 0) {

            if (Notify->AllocatedBuffer != NULL) {

                PsReturnProcessPagedPoolQuota( Notify->OwningProcess,
                                               Notify->ThisBufferLength );

                ExFreePool( Notify->AllocatedBuffer );
            }

            if (Notify->FullDirectoryName != NULL) {

                SubjectContext = Notify->SubjectContext;
            }

            //
            //  Cleanup owned one of the refcounts, and must have removed this from
            //  the notify list.  If not, we are freeing pool with live links.
            //

            ASSERT( Notify->NotifyList.Flink == NULL );

            ExFreePool( Notify );
            Notify = NULL;
        }

    } finally {

        //
        //  No matter how we exit, we release the mutex.
        //

        ReleaseNotifySync( NotifySync );

        if (SubjectContext != NULL) {

            SeReleaseSubjectContext( SubjectContext );
            ExFreePool( SubjectContext );
        }

        FsRtlExitFileSystem();

        DebugTrace( -1, Dbg, "FsRtlCancelNotify:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine
//

VOID
FsRtlCheckNotifyForDelete (
    IN PLIST_ENTRY NotifyListHead,
    IN PVOID StreamID
    )

/*++

Routine Description:

    This routine is called when a stream is being marked for delete.  We will
    walk through the notify structures looking for an Irp for the same stream.
    We will complete these Irps with STATUS_DELETE_PENDING.

Arguments:

    NotifyListHead  -  This is the start of the notify list.

    StreamID  -  This is the Context ID used to identify the stream.

Return Value:

    None.

--*/

{
    PLIST_ENTRY Link;

    PNOTIFY_CHANGE ThisNotify;

    PAGED_CODE();

    //
    //  Walk through all the entries on the list looking for a match.
    //

    for (Link = NotifyListHead->Flink;
         Link != NotifyListHead;
         Link = Link->Flink) {

        //
        //  Obtain the notify structure from the link.
        //

        ThisNotify = CONTAINING_RECORD( Link, NOTIFY_CHANGE, NotifyList );

        //
        //  If the context field matches, then complete any waiting Irps.
        //

        if (ThisNotify->StreamID == StreamID) {

            //
            //  Start by marking the notify structure as file deleted.
            //

            SetFlag( ThisNotify->Flags, NOTIFY_STREAM_IS_DELETED );

            //
            //  Now complete all of the Irps on this list.
            //

            if (!IsListEmpty( &ThisNotify->NotifyIrps )) {

                FsRtlNotifyCompleteIrpList( ThisNotify, STATUS_DELETE_PENDING );
            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\pnp.c ===
/*++

Copyright (c) 1989-1998 Microsoft Corporation

Module Name:

    PnP.c

Abstract:

    The PnP package provides a method for file systems to 
    notify applications and services that a volume is being
    locked or unlocked, so handles to it can be closed and
    reopened.
    
    This module exports routines which help file systems
    do this notification.

Author:

    Keith Kaplan     [KeithKa]    01-Apr-1998

Revision History:

--*/

#include "FsRtlP.h"

#ifndef FAR
#define FAR
#endif
#include <IoEvent.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlNotifyVolumeEvent)
#endif


NTKERNELAPI
NTSTATUS
FsRtlNotifyVolumeEvent (
    IN PFILE_OBJECT FileObject,
    IN ULONG EventCode
    )

/*++

Routine Description:

    This routine notifies any registered applications that a 
    volume is being locked, unlocked, etc.  

Arguments:

    FileeObject - Supplies a file object for the volume being
        locked.

    EventCode - Which event is occuring -- e.g. FSRTL_VOLUME_LOCK
        
Return Value:

    Status of the notification.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    TARGET_DEVICE_CUSTOM_NOTIFICATION Event;
    PDEVICE_OBJECT Pdo;

    //
    //  Retrieve the device object associated with this file object.
    //

    Status = IoGetRelatedTargetDevice( FileObject, &Pdo );

    if (NT_SUCCESS( Status )) {

        ASSERT(Pdo != NULL);

        Event.Version = 1;
        Event.FileObject = NULL;
        Event.NameBufferOffset = -1;
        Event.Size = (USHORT)FIELD_OFFSET( TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer );

        switch (EventCode) {

        case FSRTL_VOLUME_DISMOUNT:
            
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_DISMOUNT, sizeof( GUID ));
            break;
            
        case FSRTL_VOLUME_DISMOUNT_FAILED:
            
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_DISMOUNT_FAILED, sizeof( GUID ));
            break;            

        case FSRTL_VOLUME_LOCK:
        
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_LOCK, sizeof( GUID ));
            break;

        case FSRTL_VOLUME_LOCK_FAILED:
        
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_LOCK_FAILED, sizeof( GUID ));
            break;
        
        case FSRTL_VOLUME_MOUNT:
            
            //
            //  Mount notification is asynchronous to avoid deadlocks when someone 
            //  unwittingly causes a mount in the course of handling some other
            //  PnP notification, e.g. MountMgr's device arrival code.
            //
            
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_MOUNT, sizeof( GUID ));
            IoReportTargetDeviceChangeAsynchronous( Pdo, &Event, NULL, NULL );
            ObDereferenceObject( Pdo );
            return STATUS_SUCCESS;
            break;

        case FSRTL_VOLUME_UNLOCK:
        
            RtlCopyMemory( &Event.Event, &GUID_IO_VOLUME_UNLOCK, sizeof( GUID ));
            break;
            
        default:

            ObDereferenceObject( Pdo );
            return STATUS_INVALID_PARAMETER;
        }
        
        IoReportTargetDeviceChange( Pdo, &Event );
        ObDereferenceObject( Pdo );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\name.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Name.c

Abstract:

    The unicode name support package is for manipulating unicode strings
    The routines allow the caller to dissect and compare strings.

    This package uses the same FSRTL_COMPARISON_RESULT typedef used by name.c

    The following routines are provided by this package:

      o  FsRtlDissectName - This routine takes a path name string and breaks
         into two parts.  The first name in the string and the remainder.
         It also checks that the first name is valid for an NT file.

      o  FsRtlColateNames - This routine is used to colate directories
         according to lexical ordering.  Lexical ordering is strict unicode
         numerical oerdering.

      o  FsRtlDoesNameContainsWildCards - This routine tells the caller if
         a string contains any wildcard characters.

      o  FsRtlIsNameInExpression - This routine is used to compare a string
         against a template (possibly containing wildcards) to sees if the
         string is in the language denoted by the template.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x10000000)

//
//  Some special debugging stuff
//

#if DBG

extern ULONG DaveDebug;
#define DavePrint if (DaveDebug) DbgPrint

#else

#define DavePrint NOTHING

#endif

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('nrSF')

//
//  Local support routine prototypes
//

BOOLEAN
FsRtlIsNameInExpressionPrivate (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlAreNamesEqual)
#pragma alloc_text(PAGE, FsRtlDissectName)
#pragma alloc_text(PAGE, FsRtlDoesNameContainWildCards)
#pragma alloc_text(PAGE, FsRtlIsNameInExpression)
#pragma alloc_text(PAGE, FsRtlIsNameInExpressionPrivate)
#endif


VOID
FsRtlDissectName (
    IN UNICODE_STRING Path,
    OUT PUNICODE_STRING FirstName,
    OUT PUNICODE_STRING RemainingName
    )

/*++

Routine Description:

    This routine cracks a path.  It picks off the first element in the
    given path name and provides both it and the remaining part.  A path
    is a set of file names separated by backslashes.  If a name begins
    with a backslash, the FirstName is the string immediately following
    the backslash.  Here are some examples:

        Path           FirstName    RemainingName
        ----           ---------    -------------
        empty          empty        empty

        \              empty        empty

        A              A            empty

        \A             A            empty

        A\B\C\D\E      A            B\C\D\E

        *A?            *A?          empty


    Note that both output strings use the same string buffer memory of the
    input string, and are not necessarily null terminated.

    Also, this routine makes no judgement as to the legality of each
    file name componant.  This must be done separatly when each file name
    is extracted.

Arguments:

    Path - The full path name to crack.

    FirstName - The first name in the path.  Don't allocate a buffer for
        this string.

    RemainingName - The rest of the path.  Don't allocate a buffer for this
        string.

Return Value:

    None.

--*/

{
    ULONG i = 0;
    ULONG PathLength;
    ULONG FirstNameStart;

    PAGED_CODE();

    //
    //  Make both output strings empty for now
    //

    FirstName->Length = 0;
    FirstName->MaximumLength = 0;
    FirstName->Buffer = NULL;

    RemainingName->Length = 0;
    RemainingName->MaximumLength = 0;
    RemainingName->Buffer = NULL;

    PathLength = Path.Length / sizeof(WCHAR);

    //
    //  Check for an empty input string
    //

    if (PathLength == 0) {

        return;
    }

    //
    //  Skip over a starting backslash, and make sure there is more.
    //

    if ( Path.Buffer[0] == L'\\' ) {

        i = 1;
    }

    //
    //  Now run down the input string until we hit a backslash or the end
    //  of the string, remembering where we started;
    //

    for ( FirstNameStart = i;
          (i < PathLength) && (Path.Buffer[i] != L'\\');
          i += 1 ) {

        NOTHING;
    }

    //
    //  At this point all characters up to (but not including) i are
    //  in the first part.   So setup the first name
    //

    FirstName->Length = (USHORT)((i - FirstNameStart) * sizeof(WCHAR));
    FirstName->MaximumLength = FirstName->Length;
    FirstName->Buffer = &Path.Buffer[FirstNameStart];

    //
    //  Now the remaining part needs a string only if the first part didn't
    //  exhaust the entire input string.  We know that if anything is left
    //  that is must start with a backslash.  Note that if there is only
    //  a trailing backslash, the length will get correctly set to zero.
    //

    if (i < PathLength) {

        RemainingName->Length = (USHORT)((PathLength - (i + 1)) * sizeof(WCHAR));
        RemainingName->MaximumLength = RemainingName->Length;
        RemainingName->Buffer = &Path.Buffer[i + 1];
    }

    //
    //  And return to our caller
    //

    return;
}

BOOLEAN
FsRtlDoesNameContainWildCards (
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine simply scans the input Name string looking for any Nt
    wild card characters.

Arguments:

    Name - The string to check.

Return Value:

    BOOLEAN - TRUE if one or more wild card characters was found.

--*/
{
    PUSHORT p;

    PAGED_CODE();

    //
    //  Check each character in the name to see if it's a wildcard
    //  character.
    //

    if( Name->Length ) {
        for( p = Name->Buffer + (Name->Length / sizeof(WCHAR)) - 1;
             p >= Name->Buffer && *p != L'\\' ;
             p-- ) {

            //
            //  check for a wild card character
            //

            if (FsRtlIsUnicodeCharacterWild( *p )) {

                //
                //  Tell caller that this name contains wild cards
                //

                return TRUE;
            }
        }
    }

    //
    //  No wildcard characters were found, so return to our caller
    //

    return FALSE;
}


BOOLEAN
FsRtlAreNamesEqual (
    PCUNICODE_STRING ConstantNameA,
    PCUNICODE_STRING ConstantNameB,
    IN BOOLEAN IgnoreCase,
    IN PCWCH UpcaseTable OPTIONAL
    )

/*++

Routine Description:

    This routine simple returns whether the two names are exactly equal.
    If the two names are known to be constant, this routine is much
    faster than FsRtlIsNameInExpression.

Arguments:

    ConstantNameA - Constant name.

    ConstantNameB - Constant name.

    IgnoreCase - TRUE if the Names should be Upcased before comparing.

    UpcaseTable - If supplied, use this table for case insensitive compares,
        otherwise, use the default system upcase table.

Return Value:

    BOOLEAN - TRUE if the two names are lexically equal.

--*/

{
    ULONG Index;
    ULONG NameLength;
    BOOLEAN FreeStrings = FALSE;

    UNICODE_STRING LocalNameA;
    UNICODE_STRING LocalNameB;

    PAGED_CODE();

    //
    // If the names aren't even the same size, then return FALSE right away.
    //

    if ( ConstantNameA->Length != ConstantNameB->Length ) {

        return FALSE;
    }

    NameLength = ConstantNameA->Length / sizeof(WCHAR);

    //
    //  If we weren't given an upcase table, we have to upcase the names
    //  ourselves.
    //

    if ( IgnoreCase && !ARGUMENT_PRESENT(UpcaseTable) ) {

        NTSTATUS Status;

        Status = RtlUpcaseUnicodeString( &LocalNameA, ConstantNameA, TRUE );

        if ( !NT_SUCCESS(Status) ) {

            ExRaiseStatus( Status );
        }

        Status = RtlUpcaseUnicodeString( &LocalNameB, ConstantNameB, TRUE );

        if ( !NT_SUCCESS(Status) ) {

            RtlFreeUnicodeString( &LocalNameA );

            ExRaiseStatus( Status );
        }

        ConstantNameA = &LocalNameA;
        ConstantNameB = &LocalNameB;

        IgnoreCase = FALSE;
        FreeStrings = TRUE;
    }

    //
    //  Do either case sensitive or insensitive compare.
    //

    if ( !IgnoreCase ) {

        BOOLEAN BytesEqual;

        BytesEqual = (BOOLEAN) RtlEqualMemory( ConstantNameA->Buffer,
                                               ConstantNameB->Buffer,
                                               ConstantNameA->Length );

        if ( FreeStrings ) {

            RtlFreeUnicodeString( &LocalNameA );
            RtlFreeUnicodeString( &LocalNameB );
        }

        return BytesEqual;

    } else {

        for (Index = 0; Index < NameLength; Index += 1) {

            if ( UpcaseTable[ConstantNameA->Buffer[Index]] !=
                 UpcaseTable[ConstantNameB->Buffer[Index]] ) {

                return FALSE;
            }
        }

        return TRUE;
    }
}


//
//  The following routine is just a wrapper around
//  FsRtlIsNameInExpressionPrivate to make a last minute fix a bit safer.
//

BOOLEAN
FsRtlIsNameInExpression (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable OPTIONAL
    )

{
    BOOLEAN Result;
    UNICODE_STRING LocalName;

    //
    //  If we weren't given an upcase table, we have to upcase the names
    //  ourselves.
    //

    if ( IgnoreCase && !ARGUMENT_PRESENT(UpcaseTable) ) {

        NTSTATUS Status;

        Status = RtlUpcaseUnicodeString( &LocalName, Name, TRUE );

        if ( !NT_SUCCESS(Status) ) {

            ExRaiseStatus( Status );
        }

        Name = &LocalName;

        IgnoreCase = FALSE;

    } else {

        LocalName.Buffer = NULL;
    }

    //
    //  Now call the main routine, remembering to free the upcased string
    //  if we allocated one.
    //

    try {

        Result = FsRtlIsNameInExpressionPrivate( Expression,
                                                 Name,
                                                 IgnoreCase,
                                                 UpcaseTable );

    } finally {

        if (LocalName.Buffer != NULL) {

            RtlFreeUnicodeString( &LocalName );
        }
    }

    return Result;
}


#define MATCHES_ARRAY_SIZE 16

//
//  Local support routine prototypes
//

BOOLEAN
FsRtlIsNameInExpressionPrivate (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable
    )

/*++

Routine Description:

    This routine compares a Dbcs name and an expression and tells the caller
    if the name is in the language defined by the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

    Expression wild cards are evaluated as shown in the nondeterministic
    finite automatons below.  Note that ~* and ~? are DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except the final .

               e is a null character transition

               EOF is the end of the name string

    In words:

        * matches 0 or more characters.

        ? matches exactly 1 character.

        DOS_STAR matches 0 or more characters until encountering and matching
            the final . in the name.

        DOS_QM matches any single character, or upon encountering a period or
            end of name string, advances the expression to the end of the
            set of contiguous DOS_QMs.

        DOS_DOT matches either a . or zero characters beyond name string.

Arguments:

    Expression - Supplies the input expression to check against
        (Caller must already upcase if passing CaseInsensitive TRUE.)

    Name - Supplies the input name to check for.

    CaseInsensitive - TRUE if Name should be Upcased before comparing.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    USHORT NameOffset;
    USHORT ExprOffset;

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;

    WCHAR NameChar, ExprChar;

    USHORT LocalBuffer[MATCHES_ARRAY_SIZE * 2];

    USHORT *AuxBuffer = NULL;
    USHORT *PreviousMatches;
    USHORT *CurrentMatches;

    USHORT MaxState;
    USHORT CurrentState;

    BOOLEAN NameFinished = FALSE;

    //
    //  The idea behind the algorithm is pretty simple.  We keep track of
    //  all possible locations in the regular expression that are matching
    //  the name.  If when the name has been exhausted one of the locations
    //  in the expression is also just exhausted, the name is in the language
    //  defined by the regular expression.
    //

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlIsNameInExpression\n", 0);
    DebugTrace( 0, Dbg, " Expression      = %Z\n", Expression );
    DebugTrace( 0, Dbg, " Name            = %Z\n", Name );
    DebugTrace( 0, Dbg, " CaseInsensitive = %08lx\n", CaseInsensitive );

    //
    //  If one string is empty return FALSE.  If both are empty return TRUE.
    //

    if ( (Name->Length == 0) || (Expression->Length == 0) ) {

        return (BOOLEAN)(!(Name->Length + Expression->Length));
    }

    //
    //  Special case by far the most common wild card search of *
    //

    if ((Expression->Length == 2) && (Expression->Buffer[0] == L'*')) {

        return TRUE;
    }

    ASSERT( !IgnoreCase || ARGUMENT_PRESENT(UpcaseTable) );

    //
    //  Also special case expressions of the form *X.  With this and the prior
    //  case we have covered virtually all normal queries.
    //

    if (Expression->Buffer[0] == L'*') {

        UNICODE_STRING LocalExpression;

        LocalExpression = *Expression;

        LocalExpression.Buffer += 1;
        LocalExpression.Length -= 2;

        //
        //  Only special case an expression with a single *
        //

        if ( !FsRtlDoesNameContainWildCards( &LocalExpression ) ) {

            ULONG StartingNameOffset;

            if (Name->Length < (USHORT)(Expression->Length - sizeof(WCHAR))) {

                return FALSE;
            }

            StartingNameOffset = ( Name->Length -
                                   LocalExpression.Length ) / sizeof(WCHAR);

            //
            //  Do a simple memory compare if case sensitive, otherwise
            //  we have got to check this one character at a time.
            //

            if ( !IgnoreCase ) {

                return (BOOLEAN) RtlEqualMemory( LocalExpression.Buffer,
                                                 Name->Buffer + StartingNameOffset,
                                                 LocalExpression.Length );

            } else {

                for ( ExprOffset = 0;
                      ExprOffset < (USHORT)(LocalExpression.Length / sizeof(WCHAR));
                      ExprOffset += 1 ) {

                    NameChar = Name->Buffer[StartingNameOffset + ExprOffset];
                    NameChar = UpcaseTable[NameChar];

                    ExprChar = LocalExpression.Buffer[ExprOffset];

                    ASSERT( ExprChar == UpcaseTable[ExprChar] );

                    if ( NameChar != ExprChar ) {

                        return FALSE;
                    }
                }

                return TRUE;
            }
        }
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  - The offset of the current name char being processed.
    //
    //  ExprOffset  - The offset of the current expression char being processed.
    //
    //  SrcCount    - Prior match being investigated with current name char
    //
    //  DestCount   - Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more itteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication, see coment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    //
    //  Set up the initial variables
    //

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches = &LocalBuffer[MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount = 1;

    NameOffset = 0;

    MaxState = (USHORT)(Expression->Length * 2);

    while ( !NameFinished ) {

        if ( NameOffset < Name->Length ) {

            NameChar = Name->Buffer[NameOffset / sizeof(WCHAR)];

            NameOffset += sizeof(WCHAR);;

        } else {

            NameFinished = TRUE;

            //
            //  if we have already exhasted the expression, cool.  Don't
            //  continue.
            //

            if ( PreviousMatches[MatchesCount-1] == MaxState ) {

                break;
            }
        }


        //
        //  Now, for each of the previous stored expression matches, see what
        //  we can do with this name character.
        //

        SrcCount = 0;
        DestCount = 0;
        PreviousDestCount = 0;

        while ( SrcCount < MatchesCount ) {

            USHORT Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (USHORT)((PreviousMatches[SrcCount++] + 1) / 2);


            Length = 0;

            while ( TRUE ) {

                if ( ExprOffset == Expression->Length ) {

                    break;
                }

                //
                //  The first time through the loop we don't want
                //  to increment ExprOffset.
                //

                ExprOffset += Length;
                Length = sizeof(WCHAR);

                CurrentState = (USHORT)(ExprOffset * 2);

                if ( ExprOffset == Expression->Length ) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = Expression->Buffer[ExprOffset / sizeof(WCHAR)];

                ASSERT( !IgnoreCase || !((ExprChar >= L'a') && (ExprChar <= L'z')) );

                //
                //  Before we get started, we have to check for something
                //  really gross.  We may be about to exhaust the local
                //  space for ExpressionMatches[][], so we have to allocate
                //  some pool if this is the case.  Yuk!
                //

                if ( (DestCount >= MATCHES_ARRAY_SIZE - 2) &&
                     (AuxBuffer == NULL) ) {

                    ULONG ExpressionChars;

                    ExpressionChars = Expression->Length / sizeof(WCHAR);

                    AuxBuffer = FsRtlpAllocatePool( PagedPool,
                                                    (ExpressionChars+1) *
                                                    sizeof(USHORT)*2*2 );

                    RtlCopyMemory( AuxBuffer,
                                   CurrentMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    CurrentMatches = AuxBuffer;

                    RtlCopyMemory( AuxBuffer + (ExpressionChars+1)*2,
                                   PreviousMatches,
                                   MATCHES_ARRAY_SIZE * sizeof(USHORT) );

                    PreviousMatches = AuxBuffer + (ExpressionChars+1)*2;
                }

                //
                //  * matches any character zero or more times.
                //

                if (ExprChar == L'*') {

                    CurrentMatches[DestCount++] = CurrentState;
                    CurrentMatches[DestCount++] = CurrentState + 3;
                    continue;
                }

                //
                //  DOS_STAR matches any character except . zero or more times.
                //

                if (ExprChar == DOS_STAR) {

                    BOOLEAN ICanEatADot = FALSE;

                    //
                    //  If we are at a period, determine if we are allowed to
                    //  consume it, ie. make sure it is not the last one.
                    //

                    if ( !NameFinished && (NameChar == '.') ) {

                        USHORT Offset;

                        for ( Offset = NameOffset;
                              Offset < Name->Length;
                              Offset += Length ) {

                            if (Name->Buffer[Offset / sizeof(WCHAR)] == L'.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        }
                    }

                    if (NameFinished || (NameChar != L'.') || ICanEatADot) {

                        CurrentMatches[DestCount++] = CurrentState;
                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;

                    } else {

                        //
                        //  We are at a period.  We can only match zero
                        //  characters (ie. the epsilon transition).
                        //

                        CurrentMatches[DestCount++] = CurrentState + 3;
                        continue;
                    }
                }

                //
                //  The following expreesion characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  forward.
                //

                CurrentState += (USHORT)(sizeof(WCHAR) * 2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == DOS_QM ) {

                    if ( NameFinished || (NameChar == L'.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  A DOS_DOT can match either a period, or zero characters
                //  beyond the end of name.
                //

                if (ExprChar == DOS_DOT) {

                    if ( NameFinished ) {

                        continue;
                    }

                    if (NameChar == L'.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                //  From this point on a name character is required to even
                //  continue, let alone make a match.
                //

                if ( NameFinished ) {

                    break;
                }

                //
                //  If this expression was a '?' we can match it once.
                //

                if (ExprChar == L'?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  Finally, check if the expression char matches the name char
                //

                if (ExprChar == (WCHAR)(IgnoreCase ?
                                        UpcaseTable[NameChar] : NameChar)) {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  The expression didn't match so go look at the next
                //  previous match.
                //

                break;
            }


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            while ((SrcCount < MatchesCount) &&
                   (PreviousDestCount < DestCount)) {

                while ((SrcCount < MatchesCount) &&
                       (PreviousMatches[SrcCount] <
                        CurrentMatches[PreviousDestCount])) {

                    SrcCount += 1;
                }

                PreviousDestCount += 1;
            }
        }

        //
        //  If we found no matches in the just finished itteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) { ExFreePool( AuxBuffer ); }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            USHORT *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;
    }


    CurrentState = PreviousMatches[MatchesCount-1];

    if (AuxBuffer != NULL) { ExFreePool( AuxBuffer ); }


    return (BOOLEAN)(CurrentState == MaxState);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\oplock.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    Oplock.c

Abstract:

    The OPLOCK routines provide support to filesystems which implement
    opporuntistics locks.  The specific actions needed are based on
    the current oplocked state of the file (maintained in the OPLOCK
    structure) and the Irp the Io system provides to the file systems.
    Rather than define separate entry points for each oplock operation
    a single generic entry point is defined.

    The file systems will maintain a variable of type OPLOCK for
    each open file in the system.  This variable is initialized
    when an unopened file is opened.  It is uninitialized when the
    last reference to the file is cleared when the Io system calls
    the file system with a close call.

    The following routines are provided by this package:

      o  FsRtlInitializeOplock - Initialize a new OPLOCK structure.  There
         should be one OPLOCK for every opened file.  Each OPLOCK structure
         must be initialized before it can be used by the system.

      o  FsRtlUninitializeOplock - Uninitialize an OPLOCK structure.  This
         call is used to cleanup any anciallary structures allocated and
         maintained by the OPLOCK.  After being uninitialized the OPLOCK
         must again be initialized before it can be used by the system.

Author:

    Brian Andrew    [BrianAn]   10-Dec-1990

Revision History:

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x08000000)

//
//  Define the compatible filter oplock desired access flags.  We won't break
//  a filter oplock when these flags are the only flags specified.
//

#define FILTER_OPLOCK_VALID_FLAGS (     \
    FILE_READ_ATTRIBUTES            |   \
    FILE_WRITE_ATTRIBUTES           |   \
    FILE_READ_DATA                  |   \
    FILE_READ_EA                    |   \
    FILE_EXECUTE                    |   \
    SYNCHRONIZE                     |   \
    READ_CONTROL                        \
)


//
//  We encode the different bits so we can test without having to enumerate
//  all of the possible states.
//
//  NOTE - The LEVEL_1, BATCH_OPLOCK and FILTER_OPLOCK must be in this order.
//  We assume later on that they are in this order.
//

#define NO_OPLOCK               (0x00000001)
#define LEVEL_I_OPLOCK          (0x00000002)
#define BATCH_OPLOCK            (0x00000004)
#define FILTER_OPLOCK           (0x00000008)
#define LEVEL_II_OPLOCK         (0x00000010)

#define OPLOCK_TYPE_MASK        (0x0000001f)

#define EXCLUSIVE               (0x00000040)
#define PENDING                 (0x00000080)

#define OPLOCK_HELD_MASK        (0x000000c0)

#define BREAK_TO_II             (0x00000100)
#define BREAK_TO_NONE           (0x00000200)
#define BREAK_TO_II_TO_NONE     (0x00000400)
#define CLOSE_PENDING           (0x00000800)

#define OPLOCK_BREAK_MASK       (0x00000f00)

//
//  The oplock types consist of the appropriate flags.
//

#define NoOplocksHeld           (NO_OPLOCK)

#define OplockIGranted          (LEVEL_I_OPLOCK | EXCLUSIVE)
#define OpBatchGranted          (BATCH_OPLOCK   | EXCLUSIVE)
#define OpFilterGranted         (FILTER_OPLOCK  | EXCLUSIVE)
#define OpFilterReqPending      (FILTER_OPLOCK  | EXCLUSIVE | PENDING )

#define OplockBreakItoII        (LEVEL_I_OPLOCK | EXCLUSIVE | BREAK_TO_II)
#define OpBatchBreaktoII        (BATCH_OPLOCK   | EXCLUSIVE | BREAK_TO_II)
#define OpFilterBreaktoII       (FILTER_OPLOCK  | EXCLUSIVE | BREAK_TO_II)

#define OplockBreakItoNone      (LEVEL_I_OPLOCK | EXCLUSIVE | BREAK_TO_NONE)
#define OpBatchBreaktoNone      (BATCH_OPLOCK   | EXCLUSIVE | BREAK_TO_NONE)
#define OpFilterBreaktoNone     (FILTER_OPLOCK  | EXCLUSIVE | BREAK_TO_NONE)

#define OplockBreakItoIItoNone  (LEVEL_I_OPLOCK | EXCLUSIVE | BREAK_TO_II_NONE)
#define OpBatchBreaktoIItoNone  (BATCH_OPLOCK   | EXCLUSIVE | BREAK_TO_II_NONE)
#define OpFilterBreaktoIItoNone (FILTER_OPLOCK  | EXCLUSIVE | BREAK_TO_II_NONE)

#define OpBatchClosePending     (BATCH_OPLOCK   | EXCLUSIVE | CLOSE_PENDING)
#define OpFilterClosePending    (FILTER_OPLOCK  | EXCLUSIVE | CLOSE_PENDING)

#define OplockIIGranted         (LEVEL_II_OPLOCK)

//
//  The oplock state is now just a ULONG.
//

typedef ULONG OPLOCK_STATE;

//
//  The non-opaque definition of an OPLOCK is a pointer to a privately
//  defined structure.
//

typedef struct _NONOPAQUE_OPLOCK {

    //
    //  This is the Irp used to successfully request a level I oplock or
    //  batch oplock.  It is completed to initiate the Oplock I break
    //  procedure.
    //

    PIRP IrpExclusiveOplock;

    //
    //  This is a pointer to the original file object used when granting
    //  an Oplock I or batch oplock.
    //

    PFILE_OBJECT FileObject;

    //
    //  The start of a linked list of Irps used to successfully request
    //  a level II oplock.
    //

    LIST_ENTRY IrpOplocksII;

    //
    //  The following links the Irps waiting to be completed on a queue
    //  of Irps.
    //

    LIST_ENTRY WaitingIrps;

    //
    //  Oplock state.  This indicates the current oplock state.
    //

    OPLOCK_STATE OplockState;

    //
    //  This FastMutex is used to control access to this structure.
    //

    PFAST_MUTEX FastMutex;

} NONOPAQUE_OPLOCK, *PNONOPAQUE_OPLOCK;

//
//  Each Waiting Irp record corresponds to an Irp that is waiting for an
//  oplock break to be acknowledged and is maintained in a queue off of the
//  Oplock's WaitingIrps list.
//

typedef struct _WAITING_IRP {

    //
    //  The link structures for the list of waiting irps.
    //

    LIST_ENTRY Links;

    //
    //  This is the Irp attached to this structure.
    //

    PIRP Irp;

    //
    //  This is the routine to call when we are done with an Irp we
    //  held on a waiting queue.  (We originally returned STATUS_PENDING).
    //

    POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine;

    //
    //  The context field to use when we are done with the Irp.
    //

    PVOID Context;

    //
    //  This points to an event object used when we do not want to
    //  give up this thread.
    //

    PKEVENT Event;

    //
    //  This field contains a copy of the Irp Iosb.Information field.
    //  We copy it here so that we can store the Oplock address in the
    //  Irp.
    //

    ULONG Information;

} WAITING_IRP, *PWAITING_IRP;

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('orSF')


//
//  Local support routines
//

PNONOPAQUE_OPLOCK
FsRtlAllocateOplock (
    );

NTSTATUS
FsRtlRequestExclusiveOplock (
    IN OUT PNONOPAQUE_OPLOCK *Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp OPTIONAL,
    IN OPLOCK_STATE NextOplockState
    );

NTSTATUS
FsRtlRequestOplockII (
    IN OUT PNONOPAQUE_OPLOCK *Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    );

NTSTATUS
FsRtlAcknowledgeOplockBreak (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN BOOLEAN GrantLevelII
    );

NTSTATUS
FsRtlOpBatchBreakClosePending (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    );

NTSTATUS
FsRtlOplockBreakNotify (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    );

VOID
FsRtlOplockCleanup (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FsRtlOplockBreakToII (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL
    );

NTSTATUS
FsRtlOplockBreakToNone (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL
    );

VOID
FsRtlRemoveAndCompleteIrp (
    IN PLIST_ENTRY Link
    );

NTSTATUS
FsRtlWaitOnIrp (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL,
    IN PKEVENT Event
    );

VOID
FsRtlCompletionRoutinePriv (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
FsRtlCancelWaitIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FsRtlCancelOplockIIIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FsRtlCancelExclusiveIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FsRtlRemoveAndCompleteWaitIrp (
    IN PWAITING_IRP WaitingIrp
    );

VOID
FsRtlNotifyCompletion (
    IN PVOID Context,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlAllocateOplock)
#pragma alloc_text(PAGE, FsRtlCompletionRoutinePriv)
#pragma alloc_text(PAGE, FsRtlCurrentBatchOplock)
#pragma alloc_text(PAGE, FsRtlInitializeOplock)
#pragma alloc_text(PAGE, FsRtlNotifyCompletion)
#pragma alloc_text(PAGE, FsRtlOpBatchBreakClosePending)
#pragma alloc_text(PAGE, FsRtlOplockBreakNotify)
#pragma alloc_text(PAGE, FsRtlOplockFsctrl)
#pragma alloc_text(PAGE, FsRtlOplockIsFastIoPossible)
#endif


VOID
FsRtlInitializeOplock (
    IN OUT POPLOCK Oplock
    )

/*++

Routine Description:

    This routine initializes a new OPLOCK structure.  This call must
    precede any other call to this entry point with this OPLOCK
    structure.  In addition, this routine will have exclusive access
    to the Oplock structure.

Arguments:

    Oplock - Supplies the address of an opaque OPLOCK structure.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( Oplock );

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlInitializeOplock:  Oplock -> %08lx\n", *Oplock );

    //
    //  No action is taken at this time.
    //

    DebugTrace(-1, Dbg, "FsRtlInitializeOplock:  Exit\n", 0);
    return;
}


VOID
FsRtlUninitializeOplock (
    IN OUT POPLOCK Oplock
    )

/*++

Routine Description:

    This routine uninitializes an OPLOCK structure.  After calling this
    routine, the OPLOCK structure must be reinitialized before being
    used again.

Arguments:

    Oplock - Supplies the address of an opaque OPLOCK structure.

Return Value:

    None.

--*/


{
    PNONOPAQUE_OPLOCK ThisOplock;

    DebugTrace(+1, Dbg, "FsRtlUninitializeOplock:  Oplock -> %08lx\n", *Oplock );

    //
    //  If the Oplock structure has not been allocated, there is no action
    //  to take.
    //

    if (*Oplock != NULL) {

        //
        //  Remove this from the user's structure.
        //

        ThisOplock = (PNONOPAQUE_OPLOCK) *Oplock;

        *Oplock = NULL;

        //
        //  Grab the waiting lock queue mutex to exclude anyone from messing
        //  with the queue while we're using it
        //

        ExAcquireFastMutexUnsafe( ThisOplock->FastMutex );

        try {

            PIRP Irp;

            //
            //  Release any waiting Irps held.
            //

            while (!IsListEmpty( &ThisOplock->WaitingIrps )) {

                PWAITING_IRP WaitingIrp;
                PIRP ThisIrp;

                WaitingIrp = CONTAINING_RECORD( ThisOplock->WaitingIrps.Flink,
                                                WAITING_IRP,
                                                Links );

                RemoveHeadList( &ThisOplock->WaitingIrps );

                ThisIrp = WaitingIrp->Irp;

                IoAcquireCancelSpinLock( &ThisIrp->CancelIrql );

                IoSetCancelRoutine( ThisIrp, NULL );
                IoReleaseCancelSpinLock( ThisIrp->CancelIrql );

                ThisIrp->IoStatus.Information = 0;

                //
                //  Call the completion routine in the Waiting Irp.
                //

                WaitingIrp->CompletionRoutine( WaitingIrp->Context,
                                               WaitingIrp->Irp );

                ExFreePool( WaitingIrp );
            }

            //
            //  Release any oplock II irps held.
            //

            while (!IsListEmpty( &ThisOplock->IrpOplocksII )) {

                Irp = CONTAINING_RECORD( ThisOplock->IrpOplocksII.Flink,
                                         IRP,
                                         Tail.Overlay.ListEntry );

                RemoveHeadList( &ThisOplock->IrpOplocksII );

                IoAcquireCancelSpinLock( &Irp->CancelIrql );

                IoSetCancelRoutine( Irp, NULL );
                IoReleaseCancelSpinLock( Irp->CancelIrql );

                //
                //  Complete the oplock II Irp.
                //

                ObDereferenceObject( IoGetCurrentIrpStackLocation( Irp )->FileObject );

                Irp->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
                FsRtlCompleteRequest( Irp, STATUS_SUCCESS );
            }

            //
            //  Release any exclusive oplock held.
            //

            if (ThisOplock->IrpExclusiveOplock != NULL) {

                Irp = ThisOplock->IrpExclusiveOplock;

                IoAcquireCancelSpinLock( &Irp->CancelIrql );

                IoSetCancelRoutine( Irp, NULL );
                IoReleaseCancelSpinLock( Irp->CancelIrql );

                Irp->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
                FsRtlCompleteRequest( Irp, STATUS_SUCCESS );

                ThisOplock->IrpExclusiveOplock = NULL;

                if (ThisOplock->FileObject != NULL) {

                    ObDereferenceObject( ThisOplock->FileObject );
                }
            }

        } finally {

            //
            //  No matter how we complete the preceding statements we will
            //  now release the waiting lock queue mutex
            //

            ExReleaseFastMutexUnsafe( ThisOplock->FastMutex );
        }

        //
        //  Deallocate the mutex.
        //

        ExFreePool( ThisOplock->FastMutex );

        //
        //  Deallocate the Oplock structure.
        //

        ExFreePool( ThisOplock );
    }

    DebugTrace( -1, Dbg, "FsRtlUninitializeOplock:  Exit\n", 0 );
    return;
}


NTSTATUS
FsRtlOplockFsctrl (
    IN POPLOCK Oplock,
    IN PIRP Irp,
    IN ULONG OpenCount
    )

/*++

Routine Description:

    This is the interface with the filesystems for Fsctl calls, it handles
    oplock requests, break acknowledgement and break notify.

Arguments:

    Oplock - Supplies the address of the opaque OPLOCK structure.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    OpenCount - This is the number of user handles on the file if we are requsting
        an exclusive oplock.  A non-zero value for a level II request indicates
        that there are locks on the file.

Return Value:

    NTSTATUS - Returns the result of this operation.  If this is an Oplock
               request which is granted, then STATUS_PENDING is returned.
               If the Oplock isn't granted then STATUS_OPLOCK_NOT_GRANTED
               is returned.  If this is an Oplock I break to no oplock,
               then STATUS_SUCCESS.  If this is an Oplock I break to
               Oplock II then STATUS_PENDING is returned.  Other
               error codes returned depend on the nature of the error.

               STATUS_CANCELLED is returned if the Irp is cancelled during
               this operation.

               STATUS_SUCCESS is returned if this is a create asking for
               a filter oplock.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    OPLOCK_STATE OplockState;

    PAGED_CODE();

    //
    //  Get the current IRP stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FsRtlOplockFsctrl:  Entered\n", 0);
    DebugTrace( 0, Dbg, "FsRtlOplockFsctrl:  Oplock      -> %08lx\n", *Oplock );
    DebugTrace( 0, Dbg, "FsRtlOplockFsctrl:  Irp         -> %08lx\n", Irp );

    //
    //  Check if this is the create case where the user is requesting a pending
    //  filter oplock.
    //

    if (IrpSp->MajorFunction == IRP_MJ_CREATE) {

        //
        //  Check that all the conditions hold to grant this oplock.
        //  The conditions that must hold are:
        //
        //      - This is the only opener of the file.
        //      - Desired Access must be exactly FILE_READ_ATTRIBUTES.
        //          This will insure an asynch open since the SYNCHRONIZE
        //          flag can't be set.
        //      - Share access is precisely
        //          (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)
        //

        if ((OpenCount != 1) ||
            (FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                     ~(FILE_READ_ATTRIBUTES))) ||
            ((IrpSp->Parameters.Create.ShareAccess &
              (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)) !=
             (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE))) {

            Status = STATUS_OPLOCK_NOT_GRANTED;

        } else {

            Status = FsRtlRequestExclusiveOplock( (PNONOPAQUE_OPLOCK *) Oplock,
                                                  IrpSp,
                                                  NULL,
                                                  OpFilterReqPending );
        }

    //
    //  Case on the FsControlFile code control code.
    //

    } else {

        //
        //  Assume this is an OplockLevel I.
        //
        //  NOTE - This code depends on the defined bits for these oplock types.
        //      FILTER_OPLOCK = 4 * LEVEL_I_OPLOCK
        //      BATCH_OPLOCK = 2 * LEVEL_I_OPLOCK
        //

        OplockState = LEVEL_I_OPLOCK;

        switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_REQUEST_FILTER_OPLOCK :

            OplockState *= 2;

        case FSCTL_REQUEST_BATCH_OPLOCK :

            OplockState *= 2;

        case FSCTL_REQUEST_OPLOCK_LEVEL_1 :

            //
            //  Set the other flags for an exclusive oplock.
            //

            SetFlag( OplockState, EXCLUSIVE );

            //
            //  We short circuit the request if this request is treated
            //  synchronously or the open count is not 1.  Otherwise the Io system
            //  will hold the return code until the Irp is completed.
            //
            //  Also fail this if the flag is set which indicates that
            //  the IO system should copy data back to a user's buffer.
            //
            //  If cleanup has occurrred on this file, then we refuse
            //  the oplock request.
            //

            if ((OpenCount != 1) ||
                IoIsOperationSynchronous( Irp ) ||
                FlagOn( Irp->Flags, IRP_INPUT_OPERATION ) ||
                FlagOn( IrpSp->FileObject->Flags, FO_CLEANUP_COMPLETE )) {

                FsRtlCompleteRequest( Irp, STATUS_OPLOCK_NOT_GRANTED );
                Status = STATUS_OPLOCK_NOT_GRANTED;

            } else {

                Status = FsRtlRequestExclusiveOplock( (PNONOPAQUE_OPLOCK *) Oplock,
                                                      IrpSp,
                                                      Irp,
                                                      OplockState );
            }

            break;

        case FSCTL_REQUEST_OPLOCK_LEVEL_2 :

            //
            //  We short circuit the request if this request is treated
            //  synchronously.  Otherwise the Io system will hold the return
            //  code until the Irp is completed.
            //
            //  If cleanup has occurrred on this file, then we refuse
            //  the oplock request.
            //
            //  Also fail this if the flag is set which indicates that
            //  the IO system should copy data back to a user's buffer.
            //
            //  A non-zero open count in this case indicates that there are
            //  file locks on the file.  We will also fail the request in
            //  this case.
            //

            if ((OpenCount != 0) ||
                IoIsOperationSynchronous( Irp ) ||
                FlagOn( Irp->Flags, IRP_INPUT_OPERATION ) ||
                FlagOn( IrpSp->FileObject->Flags, FO_CLEANUP_COMPLETE )) {

                FsRtlCompleteRequest( Irp, STATUS_OPLOCK_NOT_GRANTED );
                Status = STATUS_OPLOCK_NOT_GRANTED;

            } else {

                Status = FsRtlRequestOplockII( (PNONOPAQUE_OPLOCK *) Oplock,
                                               IrpSp,
                                               Irp );
            }

            break;

        case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :

            Status = FsRtlAcknowledgeOplockBreak( (PNONOPAQUE_OPLOCK) *Oplock,
                                                  IrpSp,
                                                  Irp,
                                                  TRUE );
            break;

        case FSCTL_OPLOCK_BREAK_ACK_NO_2 :

            Status = FsRtlAcknowledgeOplockBreak( (PNONOPAQUE_OPLOCK) *Oplock,
                                                  IrpSp,
                                                  Irp,
                                                  FALSE );
            break;

        case FSCTL_OPBATCH_ACK_CLOSE_PENDING :

            Status = FsRtlOpBatchBreakClosePending( (PNONOPAQUE_OPLOCK) *Oplock,
                                                    IrpSp,
                                                    Irp );
            break;

        case FSCTL_OPLOCK_BREAK_NOTIFY :

            Status = FsRtlOplockBreakNotify( (PNONOPAQUE_OPLOCK) *Oplock,
                                             IrpSp,
                                             Irp );
            break;

        default :

            DebugTrace( 0,
                        Dbg,
                        "Invalid Control Code\n",
                        0);

            FsRtlCompleteRequest( Irp, STATUS_INVALID_PARAMETER );
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    DebugTrace(-1, Dbg, "FsRtlOplockFsctrl:  Exit -> %08lx\n", Status );
    return Status;
}


NTSTATUS
FsRtlCheckOplock (
    IN POPLOCK Oplock,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL
    )

/*++

Routine Description:

    This routine is called as a support routine from a file system.
    It is used to synchronize I/O requests with the current Oplock
    state of a file.  If the I/O operation will cause the Oplock to
    break, that action is initiated.  If the operation cannot continue
    until the Oplock break is complete, STATUS_PENDING is returned and
    the caller supplied routine is called.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    Context - This value is passed as a parameter to the completion routine.

    CompletionRoutine - This is the routine which is called if this
                        Irp must wait for an Oplock to break.  This
                        is a synchronous operation if not specified
                        and we block in this thread waiting on
                        an event.

    PostIrpRoutine - This is the routine to call before we put anything
                     on our waiting Irp queue.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_PENDING if we return here but hold the Irp.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PNONOPAQUE_OPLOCK ThisOplock = *Oplock;

    PIO_STACK_LOCATION IrpSp;

    DebugTrace( +1, Dbg, "FsRtlCheckOplock:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  If there is no oplock structure or this is system I/O, we allow
    //  the operation to continue.  Otherwise we check the major function code.
    //

    if ((ThisOplock != NULL) &&
        !FlagOn( Irp->Flags, IRP_PAGING_IO )) {

        OPLOCK_STATE OplockState;
        PFILE_OBJECT OplockFileObject;

        BOOLEAN BreakToII;
        BOOLEAN BreakToNone;

        ULONG CreateDisposition;

        //
        //  Capture the file object first and then the oplock state to perform
        //  the unsafe checks below.  We capture the file object first in case
        //  there is an exclusive oplock break in progress.  Otherwise the oplock
        //  state may indicate break in progress but it could complete by
        //  the time we snap the file object.
        //

        OplockFileObject = ThisOplock->FileObject;
        OplockState = ThisOplock->OplockState;

        //
        //  Examine the Irp for the appropriate action provided there are
        //  current oplocks on the file.
        //

        if (OplockState != NoOplocksHeld) {

            BreakToII = FALSE;
            BreakToNone = FALSE;

            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Determine whether we are going to BreakToII or BreakToNone.
            //

            switch (IrpSp->MajorFunction) {

            case IRP_MJ_CREATE :

                //
                //  If we are opening for attribute access only, we
                //  return status success.  Always break the oplock if this caller
                //  wants a filter oplock.
                //

                if (!FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                             ~(FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE) ) &&
                    !FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER )) {

                    break;
                }

                //
                //  If there is a filter oplock granted and this create iS reading
                //  the file then don't break the oplock as long as we share
                //  for reads.
                //

                if (FlagOn( OplockState, FILTER_OPLOCK ) &&
                    !FlagOn( IrpSp->Parameters.Create.SecurityContext->DesiredAccess,
                             ~FILTER_OPLOCK_VALID_FLAGS ) &&
                    FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ )) {

                    break;
                }

                //
                //  We we are superseding or overwriting, then break to none.
                //

                CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

                if ((CreateDisposition == FILE_SUPERSEDE) ||
                    (CreateDisposition == FILE_OVERWRITE) ||
                    (CreateDisposition == FILE_OVERWRITE_IF) ||
                    FlagOn( IrpSp->Parameters.Create.Options, FILE_RESERVE_OPFILTER )) {

                    BreakToNone = TRUE;

                } else {

                    BreakToII = TRUE;
                }

                break;

            case IRP_MJ_READ :

                //
                //  If a filter oplock has been granted then do nothing.
                //  We will assume the oplock will have been broken
                //  if this create needed to do that.
                //

                if (!FlagOn( OplockState, FILTER_OPLOCK )) {

                    BreakToII = TRUE;
                }

                break;

            case IRP_MJ_FLUSH_BUFFERS :

                BreakToII = TRUE;
                break;

            case IRP_MJ_CLEANUP :

                FsRtlOplockCleanup( (PNONOPAQUE_OPLOCK) *Oplock,
                                    IrpSp );

                break;

            case IRP_MJ_LOCK_CONTROL :

                //
                //  If a filter oplock has been granted then do nothing.
                //  We will assume the oplock will have been broken
                //  if this create needed to do that.
                //

                if (FlagOn( OplockState, FILTER_OPLOCK )) {

                    break;
                }

            case IRP_MJ_WRITE :

                BreakToNone = TRUE;
                break;

            case IRP_MJ_SET_INFORMATION :

                //
                //  We are only interested in calls that shrink the file size
                //  or breaking batch oplocks for the rename case.
                //

                switch (IrpSp->Parameters.SetFile.FileInformationClass) {

                case FileEndOfFileInformation :

                    //
                    //  Break immediately if this is the lazy writer callback.
                    //

                    if (IrpSp->Parameters.SetFile.AdvanceOnly) {

                        break;
                    }

                case FileAllocationInformation :

                    BreakToNone = TRUE;
                    break;

                case FileRenameInformation :
                case FileLinkInformation :
                case FileShortNameInformation :

                    if (FlagOn( OplockState, BATCH_OPLOCK | FILTER_OPLOCK )) {

                        BreakToNone = TRUE;
                    }

                    break;
                }

            case IRP_MJ_FILE_SYSTEM_CONTROL :

                //
                //  We need to break to none if this is a zeroing operation.
                //

                if (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_SET_ZERO_DATA) {

                    BreakToNone = TRUE;
                }
            }

            if (BreakToII) {

                //
                //  If there are no outstanding oplocks or level II oplocks are held,
                //  we can return immediately.  If the first two tests fail then there
                //  is an exclusive oplock.  If the file objects match we allow the
                //  operation to continue.
                //

                if ((OplockState != OplockIIGranted) &&
                    (OplockFileObject != IrpSp->FileObject)) {

                    Status = FsRtlOplockBreakToII( (PNONOPAQUE_OPLOCK) *Oplock,
                                                    IrpSp,
                                                    Irp,
                                                    Context,
                                                    CompletionRoutine,
                                                    PostIrpRoutine );
                }

            } else if (BreakToNone) {

                //
                //  If there are no oplocks, we can return immediately.
                //  Otherwise if there is no level 2 oplock and this file
                //  object matches the owning file object then this write is
                //  on behalf of the owner of the oplock.
                //

                if ((OplockState == OplockIIGranted) ||
                    (OplockFileObject != IrpSp->FileObject)) {

                    Status = FsRtlOplockBreakToNone( (PNONOPAQUE_OPLOCK) *Oplock,
                                                      IrpSp,
                                                      Irp,
                                                      Context,
                                                      CompletionRoutine,
                                                      PostIrpRoutine );
                }
            }
        }
    }

    DebugTrace( -1, Dbg, "FsRtlCheckOplock:  Exit -> %08lx\n", Status );

    return Status;
}


BOOLEAN
FsRtlOplockIsFastIoPossible (
    IN POPLOCK Oplock
    )

/*++

Routine Description:

    This routine indicates to the caller where there are any outstanding
    oplocks which prevent fast Io from happening.

Arguments:

    OpLock - Supplies the oplock being queried

Return Value:

    BOOLEAN - TRUE if there are outstanding oplocks and FALSE otherwise

--*/

{
    BOOLEAN FastIoPossible = TRUE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlOplockIsFastIoPossible: Oplock -> %08lx\n", *Oplock);

    //
    //  There are not any current oplocks if the variable is null or
    //  the state is no oplocks held.  If an exclusive oplock was granted
    //  but no break is in progress then allow the Fast IO.
    //

    if (*Oplock != NULL) {

        OPLOCK_STATE OplockState;

        OplockState = ((PNONOPAQUE_OPLOCK) *Oplock)->OplockState;

        if (FlagOn( OplockState, LEVEL_II_OPLOCK | OPLOCK_BREAK_MASK )) {

            FastIoPossible = FALSE;
        }
    }

    DebugTrace(-1, Dbg, "FsRtlOplockIsFastIoPossible: Exit -> %08lx\n", FastIoPossible);

    return FastIoPossible;
}


BOOLEAN
FsRtlCurrentBatchOplock (
    IN POPLOCK Oplock
    )

/*++

Routine Description:

    This routines indicates whether there are current outstanding
    batch oplocks.

Arguments:

    OpLock - Supplies the oplock being queried

Return Value:

    BOOLEAN - TRUE if there are outstanding batch oplocks and FALSE otherwise

--*/

{
    BOOLEAN BatchOplocks = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlCurrentBatchOplock: Oplock -> %08lx\n", *Oplock);

    //
    //  There are not any current oplocks if the variable is null or
    //  the state is no oplocks held.  We check whether there are batch
    //  oplocks or filter oplocks which have not been broken.
    //

    if ((*Oplock != NULL) &&
        FlagOn( ((PNONOPAQUE_OPLOCK) *Oplock)->OplockState,
                BATCH_OPLOCK | FILTER_OPLOCK )) {

        BatchOplocks = TRUE;
    }

    DebugTrace(-1, Dbg, "FsRtlCurrentBatchOplock: Exit -> %08lx\n", BatchOplocks);

    return BatchOplocks;
}


//
//  Local support routine.
//

PNONOPAQUE_OPLOCK
FsRtlAllocateOplock (
    )

/*++

Routine Description:

    This routine is called to initialize and allocate an opaque oplock
    structure.  After allocation, the two events are set to the signalled
    state.  The oplock state is set to NoOplocksHeld and the other
    fields are filled with zeroes.

    If the allocation fails, the appropriate status is raised.

Arguments:

    None.

Return Value:

    PNONOPAQUE_OPLOCK - A pointer to the allocated structure.

--*/

{
    PNONOPAQUE_OPLOCK NewOplock = NULL;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlAllocateOplock:  Entered\n", 0);

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Raise an error status if the allocation is unsuccessful.
        //  The structure is allocated out of non-paged pool.
        //

        NewOplock = FsRtlpAllocatePool( PagedPool|POOL_COLD_ALLOCATION, sizeof( NONOPAQUE_OPLOCK ));

        RtlZeroMemory( NewOplock, sizeof( NONOPAQUE_OPLOCK ));

        NewOplock->FastMutex = FsRtlpAllocatePool( NonPagedPool, sizeof( FAST_MUTEX ));

        ExInitializeFastMutex( NewOplock->FastMutex );

        InitializeListHead( &NewOplock->IrpOplocksII );
        InitializeListHead( &NewOplock->WaitingIrps );

        NewOplock->OplockState = NoOplocksHeld;

    } finally {

        //
        //  Cleanup the oplock if abnormal termination.
        //

        if (AbnormalTermination() && NewOplock != NULL) {

            ExFreePool( NewOplock );
        }

        DebugTrace(-1, Dbg, "GetOplockStructure:  Exit -> %08lx\n", NewOplock);
    }

    return NewOplock;
}


//
//  Local support routine.
//

NTSTATUS
FsRtlRequestExclusiveOplock (
    IN OUT PNONOPAQUE_OPLOCK *Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp OPTIONAL,
    IN OPLOCK_STATE NextOplockState
    )

/*++

Routine Description:

    This routine is called whenever a user is requesting either a batch/filter
    oplock or a level I oplock.  The request is granted if there are currently
    no oplocks on the file or we are completing the filter oplock request.

    NOTE - We already know that the open count on this file is exactly one.
        If the caller is requesting a PendingFilter Oplock then the state
        must be NoOplockHeld.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.  This is not specified if we are granting a pending
          filter oplock (during a create).

    NextOplockState - Indicates the type of oplock being requested.

Return Value:

    STATUS_PENDING if the oplock is granted (although it may be immediately cancelled).
    STATUS_SUCCESS if a pending filter oplock is requested and tentatively granted.
    STATUS_OPLOCK_NOT_GRANTED if the request is denied.

--*/

{
    NTSTATUS Status;

    PNONOPAQUE_OPLOCK ThisOplock;

    BOOLEAN AcquiredMutex;
    BOOLEAN BreakOpFilter = FALSE;

    PLIST_ENTRY Link;

    DebugTrace( +1, Dbg, "FsRtlRequestExclusiveOplock:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock        -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp         -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp           -> %08lx\n", Irp );
    DebugTrace(  0, Dbg, "BatchOplock   -> %01x\n",  BatchOplock );

    //
    //  We can grant the oplock if no one else owns a level I or level II
    //  oplock on this file.  If the oplock pointer is NULL then there
    //  are no oplocks on the file.  Otherwise we need to check the
    //  oplock state in an existing oplock structure.
    //

    if (*Oplock == NULL) {

        DebugTrace( 0,
                    Dbg,
                    "Oplock currently not allocated\n",
                    0);

        ThisOplock = FsRtlAllocateOplock();
        *Oplock = ThisOplock;

    } else {

        ThisOplock = *Oplock;
    }

    //
    //  Grab the synchronization object for the oplock.
    //

    ExAcquireFastMutexUnsafe( ThisOplock->FastMutex );

    AcquiredMutex = TRUE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If we are requesting a PendingFilter Oplock then it must be
        //  safe to grant.  There is only one open handle and we are in
        //  the process of opening it.
        //

        if (NextOplockState == OpFilterReqPending) {

            ASSERT( FlagOn( ThisOplock->OplockState, NO_OPLOCK | PENDING ));

            ThisOplock->IrpExclusiveOplock = Irp;
            ThisOplock->FileObject = IrpSp->FileObject;

            ThisOplock->OplockState = OpFilterReqPending;
            Status = STATUS_SUCCESS;

        //
        //  If the current oplock state is no oplocks held then we
        //  will grant the oplock to this requestor.  If the state is
        //  either of the OpFilter states then also grant the request.
        //  We won't check for a matching file object because there can
        //  only be one file object.  Grant the request anyway.
        //
        //  If the current state is OplockII granted then it must
        //  be owned by this request.  Break the oplock II and grant
        //  the exclusive lock.
        //

        } else if (FlagOn( ThisOplock->OplockState,
                           LEVEL_II_OPLOCK | NO_OPLOCK | PENDING )) {

            PFAST_MUTEX OplockFastMutex;

            if (ThisOplock->OplockState == OplockIIGranted) {

                ASSERT( ThisOplock->IrpOplocksII.Flink == ThisOplock->IrpOplocksII.Blink );

                FsRtlRemoveAndCompleteIrp( ThisOplock->IrpOplocksII.Flink );
            }

            //
            //  Put the address of the fast mutex on the stack.
            //

            OplockFastMutex = ThisOplock->FastMutex;

            //
            //  We store this Irp in the Oplocks structure.
            //  We set the oplock state to the correct exclusive oplock.
            //

            ThisOplock->IrpExclusiveOplock = Irp;
            ThisOplock->FileObject = IrpSp->FileObject;
            ThisOplock->OplockState = NextOplockState;

            IoMarkIrpPending( Irp );

            ObReferenceObject( IrpSp->FileObject );

            Irp->IoStatus.Information = (ULONG_PTR) ThisOplock;

            IoAcquireCancelSpinLock( &Irp->CancelIrql );

            //
            //  Now if the irp is cancelled then we'll call the cancel
            //  routine right now to do away with the irp, otherwise
            //  we set the cancel routine
            //

            if (Irp->Cancel) {

                AcquiredMutex = FALSE;

                ExReleaseFastMutexUnsafe( OplockFastMutex );

                FsRtlCancelExclusiveIrp( NULL, Irp );

            } else {

                IoSetCancelRoutine( Irp, FsRtlCancelExclusiveIrp );
                IoReleaseCancelSpinLock( Irp->CancelIrql );
            }

            Status = STATUS_PENDING;

        } else {

            //
            //  We'll complete the Irp with the Oplock not granted message
            //  and return that value as a status.
            //

            if (ARGUMENT_PRESENT( Irp )) {

                FsRtlCompleteRequest( Irp, STATUS_OPLOCK_NOT_GRANTED );
            }

            Status = STATUS_OPLOCK_NOT_GRANTED;
        }

    } finally {

        //
        //  Give up the oplock synchronization object.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( ThisOplock->FastMutex );
        }

        DebugTrace( +1, Dbg, "FsRtlRequestExclusiveOplock:  Exit\n", 0 );
    }

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
FsRtlRequestOplockII (
    IN OUT PNONOPAQUE_OPLOCK *Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when a user is requesting an Oplock II on an
    open file.  The request is granted if there are currently no
    level 1 oplocks on the file and an oplock break is not in progress.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

Return Value:

    STATUS_PENDING if the oplock is granted.
    STATUS_OPLOCK_NOT_GRANTED if the request is denied.

--*/

{
    NTSTATUS Status;

    PNONOPAQUE_OPLOCK ThisOplock;

    BOOLEAN AcquiredMutex;

    DebugTrace( +1, Dbg, "FsRtlRequestOplockII:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  We can grant the oplock if no one else owns a level I
    //  oplock on this file.  If the oplock pointer is NULL then there
    //  are no oplocks on the file.  Otherwise we need to check the
    //  oplock state in an existing oplock structure.
    //

    if (*Oplock == NULL) {

        DebugTrace( 0,
                    Dbg,
                    "Oplock currently not allocated\n",
                    0);

        ThisOplock = FsRtlAllocateOplock();
        *Oplock = ThisOplock;

    } else {

        ThisOplock = *Oplock;
    }

    //
    //  Grab the synchronization object for the oplock.
    //

    ExAcquireFastMutexUnsafe( ThisOplock->FastMutex );

    AcquiredMutex = TRUE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the current oplock state is no oplocks held or OplockIIGranted
        //  then we will grant the oplock to this requestor.
        //

        if (FlagOn( ThisOplock->OplockState, NO_OPLOCK | LEVEL_II_OPLOCK )) {

            PFAST_MUTEX OplockFastMutex = ThisOplock->FastMutex;

            //
            //  We store this Irp in the Oplocks structure.
            //  We set the oplock state to 'OplockIIGranted'.
            //

            IoMarkIrpPending( Irp );

            Irp->IoStatus.Status = STATUS_SUCCESS;

            InsertHeadList( &ThisOplock->IrpOplocksII,
                            &Irp->Tail.Overlay.ListEntry );

            Irp->IoStatus.Information = (ULONG_PTR) ThisOplock;

            ThisOplock->OplockState = OplockIIGranted;

            ObReferenceObject( IrpSp->FileObject );

            IoAcquireCancelSpinLock( &Irp->CancelIrql );

            //
            //  Now if the irp is cancelled then we'll call the cancel
            //  routine right now to do away with the irp, otherwise
            //  we set the cancel routine
            //

            if (Irp->Cancel) {

                AcquiredMutex = FALSE;

                ExReleaseFastMutexUnsafe( OplockFastMutex );

                FsRtlCancelOplockIIIrp( NULL, Irp );

            } else {

                IoSetCancelRoutine( Irp, FsRtlCancelOplockIIIrp );
                IoReleaseCancelSpinLock( Irp->CancelIrql );
            }

            Status = STATUS_PENDING;

        } else {

            //
            //  We'll complete the Irp with the Oplock not granted message
            //  and return that value as a status.
            //

            FsRtlCompleteRequest( Irp, STATUS_OPLOCK_NOT_GRANTED );
            Status = STATUS_OPLOCK_NOT_GRANTED;
        }

    } finally {

        //
        //  Give up the oplock synchronization object.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( ThisOplock->FastMutex );
        }

        DebugTrace( +1, Dbg, "FsRtlRequestOplockII:  Exit\n", 0 );
    }

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
FsRtlAcknowledgeOplockBreak (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN BOOLEAN GrantLevelII
    )

/*++

Routine Description:

    This routine is called when a user is acknowledging an Oplock I
    break.  If the level 1 oplock was being broken to level 2, then
    a check is made to insure that the level 2 has not been broken
    in the meantime.

    If an oplock 1 break is not in progress then this will be treated
    as an asynchronous break request.  If this is an asynchronous break
    request and the file object owns an outstanding level 1 oplock, then
    the oplock will be broken at this point.

    A spurious break request via a file object which does not (or did not)
    own the level 1 oplock will generate a warning but will not affect
    the oplock state.

    At the end of an Oplock I break, all of the waiting irps are completed.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    GrantLevelII - Indicates that this caller wants a level II oplock left
        on the file.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    NTSTATUS Status;

    BOOLEAN AcquiredMutex;

    DebugTrace( +1, Dbg, "FsRtlAcknowledgeOplockBreak:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  If there is no oplock structure, we complete this with invalid
    //  oplock protocol.
    //

    if (Oplock == NULL) {

        FsRtlCompleteRequest( Irp, STATUS_INVALID_OPLOCK_PROTOCOL );
        DebugTrace( -1, Dbg, "FsRtlAcknowledgeOplockBreak:  Exit -> %08lx\n", STATUS_INVALID_OPLOCK_PROTOCOL );
        return STATUS_INVALID_OPLOCK_PROTOCOL;
    }

    //
    //  Grab the synchronization object for the oplock.
    //

    ExAcquireFastMutexUnsafe( Oplock->FastMutex );
    AcquiredMutex = TRUE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        BOOLEAN DereferenceFileObject = TRUE;

        //
        //  If a break is underway but this is not the owner of the
        //  level 1 oplock, we complete the request and return a
        //  warning.
        //

        if (Oplock->FileObject != IrpSp->FileObject) {

            Status = STATUS_INVALID_OPLOCK_PROTOCOL;
            DebugTrace(0,
                       Dbg,
                       "Not oplock owner -> %08lx\n",
                       Status);

            FsRtlCompleteRequest( Irp, Status );
            try_return( Status );
        }

        //
        //  If the user would like a level II and we are breaking to level II
        //  then grant the oplock.
        //

        if (GrantLevelII &&
            FlagOn( Oplock->OplockState, BREAK_TO_II )) {

            PFAST_MUTEX OplockFastMutex = Oplock->FastMutex;

            DebugTrace(0, Dbg, "OplockItoII\n", 0);

            //
            //  The acknowledgement should never be synchronous.
            //

            ASSERT( !IoIsOperationSynchronous( Irp ));

            //
            //  We need to add this Irp to the oplock II queue, change
            //  the oplock state to Oplock II granted and set the
            //  return value to STATUS_PENDING.
            //


            IoMarkIrpPending( Irp );

            Irp->IoStatus.Status = STATUS_SUCCESS;

            InsertHeadList( &Oplock->IrpOplocksII,
                            &Irp->Tail.Overlay.ListEntry );

            DereferenceFileObject = FALSE;

            Oplock->OplockState = OplockIIGranted;

            Irp->IoStatus.Information = (ULONG_PTR) Oplock;

            IoAcquireCancelSpinLock( &Irp->CancelIrql );

            //
            //  Now if the irp is cancelled then we'll call the cancel
            //  routine right now to do away with the irp, otherwise
            //  we set the cancel routine
            //

            if (Irp->Cancel) {

                AcquiredMutex = FALSE;

                ExReleaseFastMutexUnsafe( OplockFastMutex );

                FsRtlCancelOplockIIIrp( NULL, Irp );

            } else {

                IoSetCancelRoutine( Irp, FsRtlCancelOplockIIIrp );
                IoReleaseCancelSpinLock( Irp->CancelIrql );
            }

            Status = STATUS_PENDING;

        //
        //  We will break to none since this is the expected case for these
        //  cases.
        //

        } else if (FlagOn( Oplock->OplockState, BREAK_TO_II | BREAK_TO_NONE )) {

            //
            //  We need to complete this Irp and return STATUS_SUCCESS.
            //  We also set the oplock state to no oplocks held.
            //

            DebugTrace(0, Dbg, "OplockItoNone\n", 0);

            Status = STATUS_SUCCESS;
            FsRtlCompleteRequest( Irp, Status );
            Oplock->OplockState = NoOplocksHeld;

        //
        //  In this case the user expects to be at level II.  He is
        //  expecting this Irp to be completed when the LevelII Oplock
        //  is broken.
        //

        } else if (FlagOn( Oplock->OplockState, BREAK_TO_II_TO_NONE )) {

            DebugTrace(0, Dbg, "AcknowledgeOplockBreak:  OplockItoIItoNone\n", 0);

            Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
            FsRtlCompleteRequest( Irp, Status );
            Oplock->OplockState = NoOplocksHeld;

        } else {

            Status = STATUS_INVALID_OPLOCK_PROTOCOL;
            DebugTrace(0,
                       Dbg,
                       "No break underway -> %08lx\n",
                       Status);

            FsRtlCompleteRequest( Irp, Status );
            try_return( Status );
        }

        //
        //  Complete the waiting Irps and cleanup the oplock structure.
        //

        while (!IsListEmpty( &Oplock->WaitingIrps )) {

            PWAITING_IRP WaitingIrp;

            //
            //  Remove the entry found and complete the Irp.
            //

            WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                            WAITING_IRP,
                                            Links );

            FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
        }

        if (DereferenceFileObject) {

            ObDereferenceObject( Oplock->FileObject );
        }

        Oplock->FileObject = NULL;

    try_exit:  NOTHING;
    } finally {

        //
        //  Give up the oplock synchronization object.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        }

        DebugTrace( -1, Dbg, "FsRtlAcknowledgeOplockBreak:  Exit -> %08x\n", Status );
    }

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
FsRtlOpBatchBreakClosePending (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when a user is acknowledging a batch oplock
    break or Level I oplock break.  In this case the user is planning
    to close the file as well and doesn't need a level II oplock.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN AcquiredMutex;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlOpBatchBreakClosePending:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  If there is no oplock structure, we complete this with invalid
    //  oplock protocol.
    //

    if (Oplock == NULL) {

        FsRtlCompleteRequest( Irp, STATUS_INVALID_OPLOCK_PROTOCOL );
        DebugTrace( -1, Dbg, "FsRtlOpBatchClosePending:  Exit -> %08lx\n", STATUS_INVALID_OPLOCK_PROTOCOL );
        return STATUS_INVALID_OPLOCK_PROTOCOL;
    }

    //
    //  Grab the synchronization object for the oplock.
    //

    ExAcquireFastMutexUnsafe( Oplock->FastMutex );
    AcquiredMutex = TRUE;

    //
    //  Use a try_finally to facilitate cleanup.
    //

    try {

        //
        //  If a break is underway but this is not the owner of the
        //  level 1 oplock, we complete the request and return a
        //  warning.
        //

        if (Oplock->FileObject != IrpSp->FileObject) {

            Status = STATUS_INVALID_OPLOCK_PROTOCOL;
            DebugTrace(0,
                       Dbg,
                       "Not oplock owner -> %08lx\n",
                       Status);

        } else {

            //
            //  If this is an opbatch operation we want to note that a
            //  close is pending.  For an exclusive oplock we set the state to
            //  no oplocsk held.  There must be a break in progress to
            //  process however.
            //

            if (FlagOn( Oplock->OplockState,
                        BREAK_TO_II | BREAK_TO_NONE | BREAK_TO_II_TO_NONE )) {

                //
                //  Break all oplocks for an exclusive oplock.
                //

                if (FlagOn( Oplock->OplockState, LEVEL_I_OPLOCK | PENDING )) {

                    //
                    //  Clean up the oplock structure and complete all waiting Irps.
                    //

                    if (FlagOn( Oplock->OplockState, LEVEL_I_OPLOCK )) {

                        ObDereferenceObject( Oplock->FileObject );
                    }

                    Oplock->OplockState = NoOplocksHeld;
                    Oplock->FileObject = NULL;

                    while (!IsListEmpty( &Oplock->WaitingIrps )) {

                        PWAITING_IRP WaitingIrp;

                        //
                        //  Remove the entry found and complete the Irp.
                        //

                        WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                                        WAITING_IRP,
                                                        Links );

                        FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
                    }

                //
                //  Set the state to close pending for batch and filter
                //  oplocks.
                //

                } else {

                    ClearFlag( Oplock->OplockState, OPLOCK_BREAK_MASK );
                    SetFlag( Oplock->OplockState, CLOSE_PENDING );
                }

            } else {

                Status = STATUS_INVALID_OPLOCK_PROTOCOL;
                DebugTrace(0,
                           Dbg,
                           "No break underway -> %08lx\n",
                           Status);
            }
        }

        //
        //  We simply complete this request.
        //

        FsRtlCompleteRequest( Irp, Status );

    } finally {

        //
        //  Release the synchronization object.
        //

        ExReleaseFastMutexUnsafe( Oplock->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlOpBatchBreakClosePending:  Exit -> %08lx\n", Status);
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
FsRtlOplockBreakNotify (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when the Irp refers the user request to
    be notified when there is no level 1 oplock break in progress.
    Under any other condition this routine completes immediately with
    STATUS_SUCCESS.  Otherwise we simply add this Irp to the list
    of Irp's waiting for the break to complete.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_PENDING if we return here but hold the Irp.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    NTSTATUS Status;

    BOOLEAN AcquiredMutex;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlOplockBreakNotify:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  If there is no oplock structure, we complete this with status success.
    //

    if (Oplock == NULL) {

        FsRtlCompleteRequest( Irp, STATUS_SUCCESS );
        DebugTrace( -1, Dbg, "FsRtlOpBatchClosePending:  Exit -> %08lx\n", STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Grap the synchronization object.
    //

    ExAcquireFastMutexUnsafe( Oplock->FastMutex );
    AcquiredMutex = TRUE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there are no outstanding level 1 oplocks breaks underway
        //  or batch oplock breaks underway we complete immediately.
        //

        if (!FlagOn( Oplock->OplockState, OPLOCK_BREAK_MASK )) {

            DebugTrace(0,
                       Dbg,
                       "No exclusive oplock break underway\n",
                       0);

            FsRtlCompleteRequest( Irp, STATUS_SUCCESS );
            try_return( Status = STATUS_SUCCESS );

        } else if (FlagOn( Oplock->OplockState, PENDING )) {

            Oplock->OplockState = NoOplocksHeld;
            Oplock->FileObject = NULL;

            FsRtlCompleteRequest( Irp, STATUS_SUCCESS );
            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  Otherwise we need to add this Irp to the list of Irp's waiting
        //  for the oplock break to complete.
        //

        AcquiredMutex = FALSE;

        //
        //  Initialize the return value to status success.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        Status = FsRtlWaitOnIrp( Oplock,
                                 Irp,
                                 NULL,
                                 FsRtlNotifyCompletion,
                                 NULL,
                                 NULL );

    try_exit:  NOTHING;
    } finally {

        //
        //  Give up the synchronization event if we haven't done so.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        }

        DebugTrace( -1, Dbg, "FsRtlOplockBreakNotify:  Exit -> %08lx\n", Status );
    }

    return Status;
}


//
//  Local support routine
//

VOID
FsRtlOplockCleanup (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to coordinate a cleanup operation with the
    oplock state for a file.  If there is no level 1 oplock for the
    file, then there is no action to take.  If the file object in this
    Irp matches the file object used in granting the level 1 oplock,
    then the close operation will terminate the oplock.  If this
    cleanup refers to a file object which has a level II oplock, then
    that Irp is completed and removed from the list of level II
    oplocked Irps.


Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

Return Value:

    None.

--*/

{
    DebugTrace( +1, Dbg, "FsRtlOplockCleanup:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );

    //
    //  Grab the synchronization object for the oplock.
    //

    ExAcquireFastMutexUnsafe( Oplock->FastMutex );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If the oplock has no oplock held we return immediately.
        //

        if (Oplock->OplockState == NoOplocksHeld) {

            DebugTrace(0,
                       Dbg,
                       "No oplocks on file\n",
                       0);

            try_return( NOTHING );
        }

        //
        //  If level II oplocks are held, check if this matches any of them.
        //

        if (Oplock->OplockState == OplockIIGranted) {

            PLIST_ENTRY Link;
            PIRP Irp;
            PIO_STACK_LOCATION NextIrpSp;

            DebugTrace(0,
                       Dbg,
                       "File has level 2 oplocks\n",
                       0);

            for (Link = Oplock->IrpOplocksII.Flink;
                 Link != &Oplock->IrpOplocksII;
                 Link = Link->Flink) {

                Irp = CONTAINING_RECORD( Link, IRP, Tail.Overlay.ListEntry );

                NextIrpSp = IoGetCurrentIrpStackLocation( Irp );

                //
                //  If the file objects match, then emove the entry found and complete the Irp.
                //

                if (IrpSp->FileObject == NextIrpSp->FileObject) {

                    //
                    //  Back up to remember this link.
                    //

                    Link = Link->Blink;

                    //
                    //

                    FsRtlRemoveAndCompleteIrp( Link->Flink );
                }
            }

            //
            //  If all the level II oplocks are gone, then the state is
            //  no oplocks held.
            //

            if (IsListEmpty( &Oplock->IrpOplocksII )) {

                Oplock->OplockState = NoOplocksHeld;
            }

            try_return( NOTHING );
        }

        //
        //  If this file object matches that used to request an exclusive
        //  oplock, we completely close the oplock break.
        //

        if (IrpSp->FileObject == Oplock->FileObject) {

            DebugTrace(0,
                       Dbg,
                       "Handle owns level 1 oplock\n",
                       0);

            //
            //  If an oplock break is not in progress, we initiate one and
            //  complete the exclusive Irp immediately.
            //

            if (!FlagOn( Oplock->OplockState, OPLOCK_BREAK_MASK | PENDING )) {

                PIRP ExclusiveIrp = Oplock->IrpExclusiveOplock;

                DebugTrace(0,
                           Dbg,
                           "Initiate oplock break\n",
                           0);

                IoAcquireCancelSpinLock( &ExclusiveIrp->CancelIrql );

                IoSetCancelRoutine( ExclusiveIrp, NULL );
                IoReleaseCancelSpinLock( ExclusiveIrp->CancelIrql );

                ExclusiveIrp->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;

                FsRtlCompleteRequest( Oplock->IrpExclusiveOplock, STATUS_SUCCESS );

                Oplock->IrpExclusiveOplock = NULL;
            }

            //
            //  Clean up the oplock structure and complete all waiting Irps.
            //  Don't do this if this is a pending opfilter request.
            //

            if (!FlagOn( Oplock->OplockState, PENDING )) {

                ObDereferenceObject( IrpSp->FileObject );
            }

            Oplock->FileObject = NULL;
            Oplock->OplockState = NoOplocksHeld;

            while (!IsListEmpty( &Oplock->WaitingIrps )) {

                PWAITING_IRP WaitingIrp;

                //
                //  Remove the entry found and complete the Irp.
                //

                WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                                WAITING_IRP,
                                                Links );

                FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
            }
        }

    try_exit:  NOTHING;
    } finally {

        //
        //  Give up the oplock synchronization object.
        //

        ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        DebugTrace( +1, Dbg, "FsRtlOplockCleanup:  Exit\n", 0 );
    }

    return;
}


//
//  Local support routine
//

NTSTATUS
FsRtlOplockBreakToII (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine
    )

/*++

Routine Description:

    This routine is a generic worker routine which is called when an
    operation will cause all oplocks to be broken to level II before the
    operation can proceed.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    Context - This value is passed as a parameter to the completion routine.

    CompletionRoutine - This is the routine which is called if this
                        Irp must wait for an Oplock to break.  This
                        is a synchronous operation if not specified
                        and we block in this thread waiting on
                        an event.

    PostIrpRoutine - This is the routine to call before we put anything
                     on our waiting Irp queue.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_PENDING if we return here but hold the Irp.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    KEVENT Event;
    NTSTATUS Status;

    BOOLEAN AcquiredMutex;

    DebugTrace( +1, Dbg, "CheckOplockBreakToII:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  Grap the synchronization object.
    //

    ExAcquireFastMutexUnsafe( Oplock->FastMutex );
    AcquiredMutex = TRUE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there are no outstanding oplocks or level II oplocks are held,
        //  we can return immediately.
        //

        if (!FlagOn( Oplock->OplockState, EXCLUSIVE )) {

            DebugTrace(0,
                       Dbg,
                       "No oplocks or level II oplocks on file\n",
                       0);

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  At this point there is an exclusive oplock break in progress.
        //  If this file object owns that oplock, we allow the operation
        //  to continue.
        //

        if (Oplock->FileObject == IrpSp->FileObject) {

            DebugTrace(0,
                       Dbg,
                       "Handle owns level 1 oplock\n",
                       0);

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  If there is currently an exclusive oplock held then complete
        //  the exclusive irp.
        //

        if (!FlagOn( Oplock->OplockState, PENDING | OPLOCK_BREAK_MASK )) {

            PIRP IrpExclusive = Oplock->IrpExclusiveOplock;

            DebugTrace(0,
                       Dbg,
                       "Breaking exclusive oplock\n",
                       0);

            IoAcquireCancelSpinLock( &IrpExclusive->CancelIrql );
            IoSetCancelRoutine( IrpExclusive, NULL );
            IoReleaseCancelSpinLock( IrpExclusive->CancelIrql );

            //
            //  If the Irp has been cancelled, we complete the Irp with
            //  status cancelled and break the oplock completely.
            //

            if (IrpExclusive->Cancel) {

                IrpExclusive->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
                FsRtlCompleteRequest( IrpExclusive, STATUS_CANCELLED );
                Oplock->OplockState = NoOplocksHeld;
                Oplock->IrpExclusiveOplock = NULL;

                ObDereferenceObject( Oplock->FileObject );
                Oplock->FileObject = NULL;

                //
                //  Release any waiting irps.
                //

                while (!IsListEmpty( &Oplock->WaitingIrps )) {

                    PWAITING_IRP WaitingIrp;

                    WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                                    WAITING_IRP,
                                                    Links );

                    FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
                }

                try_return( Status = STATUS_SUCCESS );

            } else {

                NTSTATUS CompletionStatus;

                if (FlagOn( Oplock->OplockState, LEVEL_I_OPLOCK | BATCH_OPLOCK )) {

                    SetFlag( Oplock->OplockState, BREAK_TO_II );
                    CompletionStatus = FILE_OPLOCK_BROKEN_TO_LEVEL_2;

                } else {

                    SetFlag( Oplock->OplockState, BREAK_TO_NONE );
                    CompletionStatus = FILE_OPLOCK_BROKEN_TO_NONE;
                }

                Oplock->IrpExclusiveOplock->IoStatus.Information = CompletionStatus;
                FsRtlCompleteRequest( Oplock->IrpExclusiveOplock, STATUS_SUCCESS );
                Oplock->IrpExclusiveOplock = NULL;
            }

        //
        //  If there is a pending opfilter request then clear the request.
        //

        } else if (FlagOn( Oplock->OplockState, PENDING )) {

            Oplock->OplockState = NoOplocksHeld;
            Oplock->FileObject = NULL;

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  If this is an open operation and the user doesn't want to
        //  block, we will complete the operation now.
        //

        if ((IrpSp->MajorFunction == IRP_MJ_CREATE) &&
            FlagOn( IrpSp->Parameters.Create.Options, FILE_COMPLETE_IF_OPLOCKED )) {

            DebugTrace( 0, Dbg, "Don't block open\n", 0 );

            try_return( Status = STATUS_OPLOCK_BREAK_IN_PROGRESS );
        }

        //
        //  If we get here that means that this operation can't continue
        //  until the oplock break is complete.
        //
        //  FsRtlWaitOnIrp will release the mutex.
        //

        AcquiredMutex = FALSE;

        Status = FsRtlWaitOnIrp( Oplock,
                                 Irp,
                                 Context,
                                 CompletionRoutine,
                                 PostIrpRoutine,
                                 &Event );

    try_exit:  NOTHING;
    } finally {

        //
        //  Give up the synchronization event if we haven't done so.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        }

        DebugTrace( -1, Dbg, "FsRtlOplockBreakToII:  Exit -> %08lx\n", Status );
    }

    return Status;
}


//
//  Local support routine.
//

NTSTATUS
FsRtlOplockBreakToNone (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIO_STACK_LOCATION IrpSp,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL
    )

/*++

Routine Description:

    This routine is a generic worker routine which is called when an
    operation will cause all oplocks to be broken before the operation can
    proceed.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    IrpSp - This is the Irp stack location for the current Irp.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    Context - This value is passed as a parameter to the completion routine.

    CompletionRoutine - This is the routine which is called if this
                        Irp must wait for an Oplock to break.  This
                        is a synchronous operation if not specified
                        and we block in this thread waiting on
                        an event.

    PostIrpRoutine - This is the routine to call before we put anything
                     on our waiting Irp queue.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_PENDING if we return here but hold the Irp.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    KEVENT Event;
    NTSTATUS Status;

    BOOLEAN AcquiredMutex;

    DebugTrace( +1, Dbg, "CheckOplockBreakToNone:  Entered\n", 0 );
    DebugTrace(  0, Dbg, "Oplock    -> %08lx\n", Oplock );
    DebugTrace(  0, Dbg, "IrpSp     -> %08lx\n", IrpSp );
    DebugTrace(  0, Dbg, "Irp       -> %08lx\n", Irp );

    //
    //  Grap the synchronization object.
    //

    ExAcquireFastMutexUnsafe( Oplock->FastMutex );
    AcquiredMutex = TRUE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If there are no outstanding oplocks, we can return immediately.
        //

        if (Oplock->OplockState == NoOplocksHeld) {

            DebugTrace(0,
                       Dbg,
                       "No oplocks on file\n",
                       0);

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  If there is an exclusive oplock held, we begin the break to none.
        //

        if (!FlagOn( Oplock->OplockState,
                     LEVEL_II_OPLOCK | PENDING | OPLOCK_BREAK_MASK )) {

            PIRP IrpExclusive = Oplock->IrpExclusiveOplock;

            DebugTrace(0,
                       Dbg,
                       "Breaking exclusive oplock\n",
                       0);

            IoAcquireCancelSpinLock( &IrpExclusive->CancelIrql );
            IoSetCancelRoutine( IrpExclusive, NULL );
            IoReleaseCancelSpinLock( IrpExclusive->CancelIrql );

            //
            //  If the Irp has been cancelled, we complete the Irp with
            //  status cancelled and break the oplock completely.
            //

            if (IrpExclusive->Cancel) {

                IrpExclusive->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
                FsRtlCompleteRequest( IrpExclusive, STATUS_CANCELLED );
                Oplock->OplockState = NoOplocksHeld;
                Oplock->IrpExclusiveOplock = NULL;

                ObDereferenceObject( Oplock->FileObject );
                Oplock->FileObject = NULL;

                //
                //  Release any waiting irps.
                //

                while (!IsListEmpty( &Oplock->WaitingIrps )) {

                    PWAITING_IRP WaitingIrp;

                    WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                                    WAITING_IRP,
                                                    Links );

                    FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
                }

                try_return( Status = STATUS_SUCCESS );

            } else {

                Oplock->IrpExclusiveOplock->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;
                FsRtlCompleteRequest( Oplock->IrpExclusiveOplock, STATUS_SUCCESS );
                Oplock->IrpExclusiveOplock = NULL;

                SetFlag( Oplock->OplockState, BREAK_TO_NONE );
            }

        //
        //  If there are level II oplocks, this will break all of them.
        //

        } else if (Oplock->OplockState == OplockIIGranted) {

            DebugTrace(0,
                       Dbg,
                       "Breaking all level 2 oplocks\n",
                       0);

            while (!IsListEmpty( &Oplock->IrpOplocksII )) {

                //
                //  Remove and complete this Irp with STATUS_SUCCESS.
                //

                FsRtlRemoveAndCompleteIrp( Oplock->IrpOplocksII.Flink );
            }

            //
            //  Set the oplock state to no oplocks held.
            //

            Oplock->OplockState = NoOplocksHeld;

            try_return( Status = STATUS_SUCCESS );

        //
        //  If we are currently breaking to level II then change that
        //  to BreakToIIToNone.
        //

        } else if (FlagOn( Oplock->OplockState, BREAK_TO_II )) {

            ClearFlag( Oplock->OplockState, BREAK_TO_II );
            SetFlag( Oplock->OplockState, BREAK_TO_II_TO_NONE );

        //
        //  If there is a pending opfilter request then clear that request.
        //

        } else if (FlagOn( Oplock->OplockState, PENDING )) {

            Oplock->OplockState = NoOplocksHeld;
            Oplock->FileObject = NULL;

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  At this point there is already an exclusive oplock break in progress.
        //  If this file object owns that oplock, we allow the operation
        //  to continue.
        //

        if (Oplock->FileObject == IrpSp->FileObject) {

            DebugTrace(0,
                       Dbg,
                       "Handle owns level 1 oplock\n",
                       0);

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  If this is an open operation and the user doesn't want to
        //  block, we will complete the operation now.
        //

        if ((IrpSp->MajorFunction == IRP_MJ_CREATE) &&
            FlagOn( IrpSp->Parameters.Create.Options, FILE_COMPLETE_IF_OPLOCKED )) {

            DebugTrace( 0, Dbg, "Don't block open\n", 0 );

            try_return( Status = STATUS_OPLOCK_BREAK_IN_PROGRESS );
        }

        //
        //  If we get here that means that this operation can't continue
        //  until the oplock break is complete.
        //
        //  FsRtlWaitOnIrp will release the mutex.
        //

        AcquiredMutex = FALSE;

        Status = FsRtlWaitOnIrp( Oplock,
                                 Irp,
                                 Context,
                                 CompletionRoutine,
                                 PostIrpRoutine,
                                 &Event );

    try_exit:  NOTHING;
    } finally {

        //
        //  Give up the synchronization event if we haven't done so.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        }

        DebugTrace( -1, Dbg, "CheckOplockBreakToNone:  Exit -> %08lx\n", Status );
    }

    return Status;
}


//
//  Local support routine.
//

VOID
FsRtlRemoveAndCompleteIrp (
    IN PLIST_ENTRY Link
    )

/*++

Routine Description:

    This routine is called to remove an Irp from a list of Irps linked
    with the Tail.ListEntry field and complete them with STATUS_CANCELLED
    if the Irp has been cancelled, STATUS_SUCCESS otherwise.

Arguments:

    Link - Supplies the entry to remove from the list.

Return Value:

    None.

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION OplockIIIrpSp;

    DebugTrace( +1, Dbg, "FsRtlRemoveAndCompleteIrp:  Entered\n", 0 );

    //
    //  Reference the Irp.
    //

    Irp = CONTAINING_RECORD( Link, IRP, Tail.Overlay.ListEntry );

    //
    //  Get the stack location and dereference the file object.
    //

    OplockIIIrpSp = IoGetCurrentIrpStackLocation( Irp );
    ObDereferenceObject( OplockIIIrpSp->FileObject );

    //
    //  Clear the cancel routine in the irp.
    //

    IoAcquireCancelSpinLock( &Irp->CancelIrql );

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    // Remove this from the list.
    //

    RemoveEntryList( Link );

    //
    //  Complete the oplock Irp.
    //

    Irp->IoStatus.Information = FILE_OPLOCK_BROKEN_TO_NONE;

    FsRtlCompleteRequest( Irp, Irp->Cancel ? STATUS_CANCELLED : STATUS_SUCCESS );

    DebugTrace( -1, Dbg, "FsRtlRemoveAndCompleteIrp:  Exit\n", 0 );
}


//
//  Local support routine.
//

NTSTATUS
FsRtlWaitOnIrp (
    IN OUT PNONOPAQUE_OPLOCK Oplock,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine is called to create a Wait Irp structure and attach it
    to the current Irp.  The Irp is then added to the list of Irps waiting
    for an oplock break.  We check if the Irp has been cancelled and if
    so we call our cancel routine to perform the work.

    This routine is holding the Mutex for the oplock on entry and
    must give it up on exit.

Arguments:

    Oplock - Supplies a pointer to the non-opaque oplock structure for
             this file.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

    Context - This value is passed as a parameter to the completion routine.

    CompletionRoutine - This is the routine which is called if this
                        Irp must wait for an Oplock to break.  This
                        is a synchronous operation if not specified
                        and we block in this thread waiting on
                        an event.

    PostIrpRoutine - This is the routine to call before we put anything
                     on our waiting Irp queue.

    Event - If there is no user completion routine, this thread will
            block using this event.

Return Value:

    STATUS_SUCCESS if we can complete the operation on exiting this thread.
    STATUS_PENDING if we return here but hold the Irp.
    STATUS_CANCELLED if the Irp is cancelled before we return.

--*/

{
    BOOLEAN AcquiredMutex;
    NTSTATUS Status;

    PWAITING_IRP WaitingIrp;

    DebugTrace( +1, Dbg, "FsRtlWaitOnIrp:   Entered\n", 0 );

    //
    //  Remember that we have the mutex.
    //

    AcquiredMutex = TRUE;

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        PFAST_MUTEX OplockFastMutex = Oplock->FastMutex;

        //
        //  Allocate and initialize the Wait Irp structure.
        //

        WaitingIrp = FsRtlpAllocatePool( PagedPool, sizeof( WAITING_IRP ));

        WaitingIrp->Irp = Irp;

        WaitingIrp->Context = Context;
        WaitingIrp->Information = (ULONG) Irp->IoStatus.Information;

        //
        //  Take appropriate action if depending on the value of the
        //  completion routine.
        //

        if (ARGUMENT_PRESENT( CompletionRoutine )) {

            WaitingIrp->CompletionRoutine = CompletionRoutine;
            WaitingIrp->Context = Context;

        } else {

            WaitingIrp->CompletionRoutine = FsRtlCompletionRoutinePriv;
            WaitingIrp->Context = Event;

            KeInitializeEvent( Event, NotificationEvent, FALSE );
        }

        //
        //  Call the file system's post Irp code.
        //

        if (ARGUMENT_PRESENT( PostIrpRoutine )) {

            PostIrpRoutine( Context, Irp );
        }

        //
        //  Initialize the return value to status success.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;

        //
        //  We put this into the Waiting Irp queue.
        //

        InsertTailList( &Oplock->WaitingIrps, &WaitingIrp->Links );

        //
        //  We grab the cancel spinlock and store the address of the oplock.
        //

        IoAcquireCancelSpinLock( &Irp->CancelIrql );
        Irp->IoStatus.Information = (ULONG_PTR) Oplock;

        //
        //  If the Irp is cancelled then we'll call the cancel routine
        //  right now to do away with the Waiting Irp structure.
        //

        if (Irp->Cancel) {

            ExReleaseFastMutexUnsafe( OplockFastMutex );
            AcquiredMutex = FALSE;

            if (ARGUMENT_PRESENT( CompletionRoutine )) {

                IoMarkIrpPending( Irp );
                Status = STATUS_PENDING;

            } else {

                Status = STATUS_CANCELLED;
            }

            FsRtlCancelWaitIrp( NULL, Irp );

        //
        //  Otherwise, we set the cancel routine and decide whether we
        //  are going to wait on our local event.
        //

        } else {

            IoSetCancelRoutine( Irp, FsRtlCancelWaitIrp );
            IoReleaseCancelSpinLock( Irp->CancelIrql );

            //
            //  If we wait on the event, we pull the return code out of
            //  the Irp.
            //

            if (!ARGUMENT_PRESENT( CompletionRoutine )) {

                AcquiredMutex = FALSE;

                ExReleaseFastMutexUnsafe( Oplock->FastMutex );

                KeWaitForSingleObject( Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL );

                Status = Irp->IoStatus.Status;

            //
            //  Otherwise, we return STATUS_PENDING.
            //

            } else {

                IoMarkIrpPending( Irp );

                Status = STATUS_PENDING;
            }
        }

    } finally {

        //
        //  Release the Mutex if we have not done so.
        //

        if (AcquiredMutex) {

            ExReleaseFastMutexUnsafe( Oplock->FastMutex );
        }

        DebugTrace( -1, Dbg, "FsRtlWaitOnIrp:   Exit\n", 0 );
    }

    return Status;
}


//
//  Local support routine.
//

VOID
FsRtlCompletionRoutinePriv (
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called when an operation must be synchronous with
    respect to the oplock package.  This routine will simply set the
    event in the Signalled state, allowing some other thread to resume
    execution.

Arguments:

    Context - This is the event to signal.

    Irp - Supplies a pointer to the Irp which declares the requested
          operation.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlCompletionRoutinePriv:  Entered\n", 0 );

    KeSetEvent( (PKEVENT)Context, 0, FALSE );

    DebugTrace( -1, Dbg, "FsRtlCompletionRoutinePriv:  Exit\n", 0 );

    return;

    UNREFERENCED_PARAMETER( Irp );
}


//
//  Local support routine.
//

VOID
FsRtlCancelWaitIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called for an Irp that is placed on the waiting
    Irp queue.  We remove the Cancel routine from the specified Irp and
    then call the completion routines for all the cancelled Irps on the
    queue.

Arguments:

    DeviceObject - Ignored.

    Irp - Supplies the Irp being cancelled.  A pointer to the
          Oplock structure for the Irp is stored in the information
          field of the Irp's Iosb.

Return Value:

    None.

--*/

{
    PNONOPAQUE_OPLOCK Oplock;

    PLIST_ENTRY Links;

    DebugTrace( +1, Dbg, "FsRtlCancelWaitIrp:  Entered\n", 0 );

    Oplock = (PNONOPAQUE_OPLOCK) Irp->IoStatus.Information;

    //
    //  We now need to void the cancel routine and release the spinlock
    //

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Iterate through all of the waiting locks looking for a canceled one
    //  We do this under the protection of the oplock mutex.
    //

    ExAcquireFastMutex( Oplock->FastMutex );

    try {

        for (Links = Oplock->WaitingIrps.Flink;
             Links != &Oplock->WaitingIrps;
             Links = Links->Flink ) {

            PWAITING_IRP WaitingIrp;

            //
            //  Get a pointer to the waiting Irp record
            //

            WaitingIrp = CONTAINING_RECORD( Links, WAITING_IRP, Links );

            DebugTrace(0, Dbg, "FsRtlCancelWaitIrp, Loop top, WaitingIrp = %08lx\n", WaitingIrp);

            //
            //  Check if the irp has been cancelled
            //

            if (WaitingIrp->Irp->Cancel) {

                //
                //  Now we need to remove this waiter and call the
                //  completion routine.  But we must not mess up our link
                //  iteration so we need to back up link one step and
                //  then the next iteration will go to our current flink.
                //

                Links = Links->Blink;

                FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
            }
        }

    } finally {

        //
        //  No matter how we exit we release the mutex
        //

        ExReleaseFastMutex( Oplock->FastMutex );

        DebugTrace( -1, Dbg, "FsRtlCancelWaitIrp:  Exit\n", 0 );
    }

    return;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine.
//

VOID
FsRtlCancelOplockIIIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called for an Irp that is placed in the Oplock II
    Irp queue.  We remove the Cancel routine from the specified Irp and
    then call the completion routines for all the cancelled Irps on the
    queue.

Arguments:

    DeviceObject - Ignored.

    Irp - Supplies the Irp being cancelled.  A pointer to the
          Oplock structure for the Irp is stored in the information
          field of the Irp's Iosb.

Return Value:

    None.

--*/

{
    PNONOPAQUE_OPLOCK Oplock;
    BOOLEAN LevelIIIrps;

    PLIST_ENTRY Links;

    DebugTrace( +1, Dbg, "FsRtlCancelOplockIIIrp:  Entered\n", 0 );

    Oplock = (PNONOPAQUE_OPLOCK) Irp->IoStatus.Information;

    //
    //  We now need to void the cancel routine and release the spinlock
    //

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    LevelIIIrps = FALSE;

    //
    //  Iterate through all of the level II oplocks looking for a canceled one
    //  We do this under the protection of the oplock mutex.
    //

    ExAcquireFastMutex( Oplock->FastMutex );

    try {

        for (Links = Oplock->IrpOplocksII.Flink;
             Links != &Oplock->IrpOplocksII;
             Links = Links->Flink ) {

            PIRP OplockIIIrp;

            //
            //  Get a pointer to the Irp record
            //

            OplockIIIrp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

            DebugTrace(0, Dbg, "FsRtlCancelOplockIIIrp, Loop top, Irp = %08lx\n", OplockIIIrp);

            //
            //  Check if the irp has been cancelled
            //

            if (OplockIIIrp->Cancel) {

                //
                //  Now we need to remove this waiter and call the
                //  completion routine.  But we must not mess up our link
                //  iteration so we need to back up link one step and
                //  then the next iteration will go to our current flink.
                //

                Links = Links->Blink;

                FsRtlRemoveAndCompleteIrp( Links->Flink );

                LevelIIIrps = TRUE;
            }
        }

        //
        //  If the list is now empty, change the oplock status to
        //  no oplocks held.
        //

        if (LevelIIIrps && IsListEmpty( &Oplock->IrpOplocksII )) {

            Oplock->OplockState = NoOplocksHeld;
        }

    } finally {

        //
        //  No matter how we exit we release the mutex
        //

        ExReleaseFastMutex( Oplock->FastMutex );

        DebugTrace( -1, Dbg, "FsRtlCancelOplockIIIrp:  Exit\n", 0 );
    }

    return;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine.
//

VOID
FsRtlCancelExclusiveIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called for either an exclusive or oplock I Irp.

Arguments:

    DeviceObject - Ignored.

    Irp - Supplies the Irp being cancelled.  A pointer to the
          Oplock structure for the Irp is stored in the information
          field of the Irp's Iosb.

Return Value:

    None.

--*/

{
    PNONOPAQUE_OPLOCK Oplock;

    DebugTrace( +1, Dbg, "FsRtlCancelExclusiveIrp:  Entered\n", 0 );

    Oplock = (PNONOPAQUE_OPLOCK) Irp->IoStatus.Information;

    //
    //  We now need to void the cancel routine and release the spinlock
    //

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Grab the synchronization object for this oplock.
    //

    ExAcquireFastMutex( Oplock->FastMutex );

    try {

        //
        //  We look for the exclusive Irp, if present and cancelled
        //  we complete it.
        //

        if ((Oplock->IrpExclusiveOplock != NULL) &&
            (Oplock->IrpExclusiveOplock->Cancel)) {

            FsRtlCompleteRequest( Oplock->IrpExclusiveOplock, STATUS_CANCELLED );
            Oplock->IrpExclusiveOplock = NULL;

            ObDereferenceObject( Oplock->FileObject );
            Oplock->FileObject = NULL;
            Oplock->OplockState = NoOplocksHeld;

            //
            //  Complete the waiting Irps.
            //

            while (!IsListEmpty( &Oplock->WaitingIrps )) {

                PWAITING_IRP WaitingIrp;

                //
                //  Remove the entry found and complete the Irp.
                //

                WaitingIrp = CONTAINING_RECORD( Oplock->WaitingIrps.Flink,
                                                WAITING_IRP,
                                                Links );

                FsRtlRemoveAndCompleteWaitIrp( WaitingIrp );
            }
        }

    } finally {

        //
        //  No matter how we exit we release the mutex
        //

        ExReleaseFastMutex( Oplock->FastMutex );

        DebugTrace( -1, Dbg, "FsRtlCancelExclusiveIrp:  Exit\n", 0 );
    }

    return;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine.
//

VOID
FsRtlRemoveAndCompleteWaitIrp (
    IN PWAITING_IRP WaitingIrp
    )

/*++

Routine Description:

    This routine is called to remove and perform any neccessary cleanup
    for an Irp stored on the waiting Irp list in an oplock structure.

Arguments:

    WaitingIrp - This is the auxilary structure attached to the Irp
                 being completed.

Return Value:

    None.

--*/

{
    PIRP Irp;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlRemoveAndCompleteWaitIrp:  Entered\n", 0 );

    //
    //  Remove the Irp from the queue.
    //

    RemoveEntryList( &WaitingIrp->Links );

    Irp = WaitingIrp->Irp;

    IoAcquireCancelSpinLock( &Irp->CancelIrql );

    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Restore the information field.
    //

    Irp->IoStatus.Information = WaitingIrp->Information;

    Irp->IoStatus.Status = (Irp->Cancel
                            ? STATUS_CANCELLED
                            : STATUS_SUCCESS);

    //
    //  Call the completion routine in the Waiting Irp.
    //

    WaitingIrp->CompletionRoutine( WaitingIrp->Context, Irp );

    //
    //  And free up pool
    //

    ExFreePool( WaitingIrp );

    DebugTrace( -1, Dbg, "FsRtlRemoveAndCompleteWaitIrp:  Exit\n", 0 );

    return;
}


//
//  Local support routine.
//

VOID
FsRtlNotifyCompletion (
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the completion routine called when a break notify Irp is to
    be completed.  We simply call FsRtlComplete request to dispose of the
    Irp.

Arguments:

    Context - Ignored.

    Irp - Irp used to request break notify.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace( +1, Dbg, "FsRtlNotifyCompletion:  Entered\n", 0 );

    //
    //  Call FsRtlCompleteRequest using the value in the Irp.
    //

    FsRtlCompleteRequest( Irp, Irp->IoStatus.Status );

    DebugTrace( -1, Dbg, "FsRtlNotifyCompletion:  Exit\n", 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\stackovf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StackOvf.c

Abstract:

    The file lock package provides a worker thread to handle
    stack overflow conditions in the file systems.  When the
    file system detects that it is near the end of its stack
    during a paging I/O read request it will post the request
    to this extra thread.

Author:

    Gary Kimura     [GaryKi]    24-Nov-1992

Revision History:

--*/

#include "FsRtlP.h"
//
// Queue object that is used to hold work queue entries and synchronize
// worker thread activity.
//

KQUEUE FsRtlWorkerQueues[2];

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('srSF')


//
//  Local Support Routine
//

VOID
FsRtlStackOverflowRead (
    IN PVOID Context
    );

VOID
FsRtlpPostStackOverflow (
    IN PVOID Context,
    IN PKEVENT Event,
    IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine,
    IN BOOLEAN PagingFile
    );

//
// Procedure prototype for the worker thread.
//

VOID
FsRtlWorkerThread(
    IN PVOID StartContext
    );

//
//  The following type is used to store an enqueue work item
//

typedef struct _STACK_OVERFLOW_ITEM {

    WORK_QUEUE_ITEM Item;

    //
    //  This is the call back routine
    //

    PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine;

    //
    //  Here are the parameters for the call back routine
    //

    PVOID Context;
    PKEVENT Event;

} STACK_OVERFLOW_ITEM;
typedef STACK_OVERFLOW_ITEM *PSTACK_OVERFLOW_ITEM;

KEVENT StackOverflowFallbackSerialEvent;
STACK_OVERFLOW_ITEM StackOverflowFallback;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, FsRtlInitializeWorkerThread)
#endif


NTSTATUS
FsRtlInitializeWorkerThread (
    VOID
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Thread;
    ULONG i;

    //
    // Create worker threads to handle normal and paging overflow reads.
    //

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, NULL, NULL);

    for (i=0; i < 2; i++) {

        //
        // Initialize the FsRtl stack overflow work Queue objects.
        //

        KeInitializeQueue(&FsRtlWorkerQueues[i], 0);

        if (!NT_SUCCESS(PsCreateSystemThread(&Thread,
                                             THREAD_ALL_ACCESS,
                                             &ObjectAttributes,
                                             0L,
                                             NULL,
                                             FsRtlWorkerThread,
                                             ULongToPtr( i )))) {

            return FALSE;
        }

        ZwClose( Thread );
    }

    //
    //  Initialize the serial workitem so we can guarantee to post items
    //  for paging files to the worker threads.
    //

    KeInitializeEvent( &StackOverflowFallbackSerialEvent, SynchronizationEvent, TRUE );

    return TRUE;
}

VOID
FsRtlPostStackOverflow (
    IN PVOID Context,
    IN PKEVENT Event,
    IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine
    )

/*++

Routine Description:

    This routines posts a stack overflow item to the stack overflow
    thread and returns.

Arguments:

    Context - Supplies the context to pass to the stack overflow
        call back routine.  If the low order bit is set, then
        this overflow was a read to a paging file.

    Event - Supplies a pointer to an event to pass to the stack
        overflow call back routine.

    StackOverflowRoutine - Supplies the call back to use when
        processing the request in the overflow thread.

Return Value:

    None.

--*/

{
    FsRtlpPostStackOverflow( Context, Event, StackOverflowRoutine, FALSE );
    return;
}


VOID
FsRtlPostPagingFileStackOverflow (
    IN PVOID Context,
    IN PKEVENT Event,
    IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine
    )

/*++

Routine Description:

    This routines posts a stack overflow item to the stack overflow
    thread and returns.
    
Arguments:

    Context - Supplies the context to pass to the stack overflow
        call back routine.  If the low order bit is set, then
        this overflow was a read to a paging file.

    Event - Supplies a pointer to an event to pass to the stack
        overflow call back routine.

    StackOverflowRoutine - Supplies the call back to use when
        processing the request in the overflow thread.

Return Value:

    None.

--*/

{
    FsRtlpPostStackOverflow( Context, Event, StackOverflowRoutine, TRUE );
    return;
}


VOID
FsRtlpPostStackOverflow (
    IN PVOID Context,
    IN PKEVENT Event,
    IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine,
    IN BOOLEAN PagingFile
    )

/*++

Routine Description:

    This routines posts a stack overflow item to the stack overflow
    thread and returns.

Arguments:

    Context - Supplies the context to pass to the stack overflow
        call back routine.  If the low order bit is set, then
        this overflow was a read to a paging file.

    Event - Supplies a pointer to an event to pass to the stack
        overflow call back routine.

    StackOverflowRoutine - Supplies the call back to use when
        processing the request in the overflow thread.

    PagingFile - Indicates if the read is destined to a paging file.

Return Value:

    None.

--*/

{
    PSTACK_OVERFLOW_ITEM StackOverflowItem;

    //
    //  Allocate a stack overflow work item it will later be deallocated by
    //  the stack overflow thread.  Conserve stack by raising here.
    //

    StackOverflowItem = ExAllocatePoolWithTag( NonPagedPool,
                                               sizeof(STACK_OVERFLOW_ITEM),
                                               MODULE_POOL_TAG );

    //
    //  If this fails, go to the fallback item for the paging file overflows.
    //  We can't have a single fallback item for non-pagingfile IO since this
    //  could lead to deadlocks if it waits on a thread that itself needs
    //  the fallback item.
    //
    
    if (StackOverflowItem == NULL) {
        
        if (!PagingFile) {
        
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        KeWaitForSingleObject( &StackOverflowFallbackSerialEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        StackOverflowItem = &StackOverflowFallback;
    }
    
    //
    //  Fill in the fields in the new item
    //

    StackOverflowItem->Context              = Context;
    StackOverflowItem->Event                = Event;
    StackOverflowItem->StackOverflowRoutine = StackOverflowRoutine;

    ExInitializeWorkItem( &StackOverflowItem->Item,
                          &FsRtlStackOverflowRead,
                          StackOverflowItem );

    //
    //  Safely add it to the overflow queue
    //

    KeInsertQueue( &FsRtlWorkerQueues[PagingFile],
                   &StackOverflowItem->Item.List );

    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

VOID
FsRtlStackOverflowRead (
    IN PVOID Context
    )

/*++

Routine Description:

    This routine processes all of the stack overflow request posted by
    the various file systems

Arguments:

Return Value:

    None.

--*/

{
    PSTACK_OVERFLOW_ITEM StackOverflowItem;

    //
    //  Since stack overflow reads are always recursive, set the
    //  TopLevelIrp field appropriately so that recurive reads
    //  from this point will not think they are top level.
    //

    PsGetCurrentThread()->TopLevelIrp = FSRTL_FSP_TOP_LEVEL_IRP;

    //
    //  Get a pointer to the stack overflow item and then call
    //  the callback routine to do the work
    //

    StackOverflowItem = (PSTACK_OVERFLOW_ITEM)Context;

    (StackOverflowItem->StackOverflowRoutine)(StackOverflowItem->Context,
                                              StackOverflowItem->Event);

    //
    //  Deallocate the work item, or simply return the serial item.
    //
    
    if (StackOverflowItem == &StackOverflowFallback) {

        KeSetEvent( &StackOverflowFallbackSerialEvent, 0, FALSE );
    
    } else {
        
        ExFreePool( StackOverflowItem );
    }

    PsGetCurrentThread()->TopLevelIrp = (ULONG_PTR)NULL;
}

VOID
FsRtlWorkerThread(
    IN PVOID StartContext
    )

{
    PLIST_ENTRY Entry;
    PWORK_QUEUE_ITEM WorkItem;
    ULONG PagingFile = (ULONG)(ULONG_PTR)StartContext;

    //
    //  Set our priority to low realtime, or +1 for PagingFile.
    //

    (VOID)KeSetPriorityThread( &PsGetCurrentThread()->Tcb,
                               LOW_REALTIME_PRIORITY + PagingFile );

    //
    // Loop forever waiting for a work queue item, calling the processing
    // routine, and then waiting for another work queue item.
    //

    do {

        //
        // Wait until something is put in the queue.
        //
        // By specifying a wait mode of KernelMode, the thread's kernel stack is
        // NOT swappable
        //

        Entry = KeRemoveQueue(&FsRtlWorkerQueues[PagingFile], KernelMode, NULL);
        WorkItem = CONTAINING_RECORD(Entry, WORK_QUEUE_ITEM, List);

        //
        // Execute the specified routine.
        //

        (WorkItem->WorkerRoutine)(WorkItem->Parameter);
        if (KeGetCurrentIrql() != 0) {
            KeBugCheckEx(
                IRQL_NOT_LESS_OR_EQUAL,
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)KeGetCurrentIrql(),
                (ULONG_PTR)WorkItem->WorkerRoutine,
                (ULONG_PTR)WorkItem
                );
        }

    } while(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fstub\efi.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    efi.h

Abstract:

    On-disk Data types for EFI disks. See chapter 16 of the "Extensible
    Firmware Interface Specification" for more information on these data
    types.
    

Author:

    Matthew D Hendel (math) 07-Sept-1999

Revision History:

--*/

#pragma once

#include <pshpack1.h>


#define EFI_PARTITION_TABLE_SIGNATURE   (0x5452415020494645)
#define EFI_PARTITION_TABLE_REVISION    (0x0010000)

//
// This is the PartitionType in the boot record for an EFI-partitioned disk.
//

#define EFI_MBR_PARTITION_TYPE          (0xEE)

typedef struct _EFI_PARTITION_ENTRY {
    GUID PartitionType;
    GUID UniquePartition;
    ULONG64 StartingLBA;
    ULONG64 EndingLBA;
    ULONG64 Attributes;
    WCHAR Name [36];
} EFI_PARTITION_ENTRY, *PEFI_PARTITION_ENTRY;


//
// Sanity Check: Since this is an on-disk structure defined in a specification
// the fields can never move or change size.
//

C_ASSERT (
    FIELD_OFFSET (EFI_PARTITION_ENTRY, UniquePartition) == 16 &&
    FIELD_OFFSET (EFI_PARTITION_ENTRY, Name) == 56 &&
    sizeof (EFI_PARTITION_ENTRY) == 128);


typedef struct _EFI_PARTITION_HEADER {
    ULONG64 Signature;
    ULONG32 Revision;
    ULONG32 HeaderSize;
    ULONG32 HeaderCRC32;
    ULONG32 Reserved;
    ULONG64 MyLBA;
    ULONG64 AlternateLBA;
    ULONG64 FirstUsableLBA;
    ULONG64 LastUsableLBA;
    GUID DiskGUID;
    ULONG64 PartitionEntryLBA;
    ULONG32 NumberOfEntries;
    ULONG32 SizeOfPartitionEntry;
    ULONG32 PartitionEntryCRC32;
} EFI_PARTITION_HEADER, *PEFI_PARTITION_HEADER;


//
// Sanity Check: Since the partition table header is a well-defined on-disk
// structure, it's fields and offsets can never change. Make sure this is
// the case.
//

C_ASSERT (
    FIELD_OFFSET (EFI_PARTITION_HEADER, Revision) == 8 &&
    FIELD_OFFSET (EFI_PARTITION_HEADER, PartitionEntryCRC32) == 88);


typedef struct _MBR_PARTITION_RECORD {
    UCHAR       BootIndicator;
    UCHAR       StartHead;
    UCHAR       StartSector;
    UCHAR       StartTrack;
    UCHAR       OSIndicator;
    UCHAR       EndHead;
    UCHAR       EndSector;
    UCHAR       EndTrack;
    ULONG32     StartingLBA;
    ULONG32     SizeInLBA;
} MBR_PARTITION_RECORD;


#define MBR_SIGNATURE           0xaa55
#define MIN_MBR_DEVICE_SIZE     0x80000
#define MBR_ERRATA_PAD          0x40000 // 128 MB

#define MAX_MBR_PARTITIONS  4

typedef struct _MASTER_BOOT_RECORD {
    UCHAR                   BootStrapCode[440];
    ULONG                   DiskSignature;
    USHORT                  Unused;
    MBR_PARTITION_RECORD    Partition[MAX_MBR_PARTITIONS];
    USHORT                  Signature;
} MASTER_BOOT_RECORD, *PMASTER_BOOT_RECORD;

C_ASSERT (sizeof (MASTER_BOOT_RECORD) == 512);

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\tmcb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    TMcbSup.c

Abstract:

    This module tests the Pinball Map Control Block support routines

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

--*/

#include <stdio.h>
#include <string.h>

#include "PbProcs.h"

VOID
PbDumpMcb (
    IN PMCB Mcb
    );



#ifndef SIMULATOR
ULONG IoInitIncludeDevices;
#endif // SIMULATOR

BOOLEAN McbTest();

int
main(
    int argc,
    char *argv[]
    )
{
    extern ULONG IoInitIncludeDevices;
    VOID KiSystemStartup();

    DbgPrint("sizeof(MCB) = %d\n", sizeof(MCB));

    IoInitIncludeDevices = 0; // IOINIT_FATFS |
                              // IOINIT_PINBALLFS |
                              // IOINIT_DDFS;
    TestFunction = McbTest;

    KiSystemStartup();

    return( 0 );
}

BOOLEAN
McbTest()
{
    BOOLEAN TestAddEntry();
    BOOLEAN TestRemoveEntry();
    BOOLEAN TestLookupEntry();
    BOOLEAN TestGetEntry();
    BOOLEAN TestLookupLastEntry();

    if (!TestAddEntry()) {
        return FALSE;
    }

    if (!TestRemoveEntry()) {
        return FALSE;
    }

    if (!TestLookupEntry()) {
        return FALSE;
    }

    if (!TestGetEntry()) {
        return FALSE;
    }

    if (!TestLookupLastEntry()) {
        return FALSE;
    }

    return TRUE;

}

BOOLEAN
TestAddEntry()
{
    MCB Mcb;
    ULONG i;
    ULONG Vbn,Lbn,Length;

    DbgPrint("\n\n\n>>>> Test PbAddMcbEntry <<<<\n");

    //
    //  Build the following runs
    //
    //  [0-9|10-19][20-29] [40-49]
    //

    PbInitializeMcb(Mcb, NonPagedPool);

    DbgPrint("\nTest 0:|--NewRun--|\n");
    if (!PbAddMcbEntry(Mcb,  0, 1000, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --LastRun--|--NewRun--|\n");
    if (!PbAddMcbEntry(Mcb, 10, 1010, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --LastRun--||--NewRun--|\n");
    if (!PbAddMcbEntry(Mcb, 20, 2020, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --LastRun--|  hole  |--NewRun--|\n");
    if (!PbAddMcbEntry(Mcb, 40, 1040, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest over writing an existing run\n");
    if (PbAddMcbEntry(Mcb, 40, 1190, 5)) {DbgPrint("Error\n");return FALSE;}
    if (PbAddMcbEntry(Mcb, 25, 1190, 10)) {DbgPrint("Error\n");return FALSE;}
    if (PbAddMcbEntry(Mcb, 15, 1190, 10)) {DbgPrint("Error\n");return FALSE;}

    PbUninitializeMcb(Mcb);

    //
    //  Build the following runs
    //
    //  [0-9] [30-39][40-49|50-59|60-64] [70-79][80-84] [90-99]
    //

    PbInitializeMcb(Mcb, NonPagedPool);

    DbgPrint("\nTest 0:  hole  |--NewRun--|\n");
    if (!PbAddMcbEntry(Mcb, 90, 1090, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest 0:  hole  |--NewRun--|  hole  |--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 50, 1050, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --PreviousRun--|  hole  |--NewRun--|  hole  |--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 70, 1070, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --PreviousRun--|--NewRun--|  hole  |--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 60, 1060,  5)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --PreviousRun--||--NewRun--|  hole  |--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 80, 1180,  5)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest 0:|--NewRun--|  hole  |--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb,  0, 1000, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --PreviousRun--|  hole  |--NewRun--|--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 40, 1040, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --PreviousRun--|  hole  |--NewRun--||--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 30, 1130, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    PbUninitializeMcb(Mcb);

    //
    //  Build the following runs
    //
    //  [0-9|10-19|20-29][30-39][40-49|50-59|60-69|70-79][80-89|90-99]
    //

    PbInitializeMcb(Mcb, NonPagedPool);
    if (!PbAddMcbEntry(Mcb, 90, 1090, 10)) {DbgPrint("Error\n");return FALSE;}

    DbgPrint("\nTest 0:  hole  |--NewRun--|--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 80, 1080, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest 0:  hole  |--NewRun--||--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 70, 1170, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    if (!PbAddMcbEntry(Mcb, 50, 1150, 10)) {DbgPrint("Error\n");return FALSE;}
    DbgPrint("\nTest --PreviousRun--|--NewRun--|--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 60, 1160, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    if (!PbAddMcbEntry(Mcb, 30, 1030, 10)) {DbgPrint("Error\n");return FALSE;}
    DbgPrint("\nTest --PreviousRun--||--NewRun--|--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 40, 1140, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    if (!PbAddMcbEntry(Mcb, 10, 1110, 10)) {DbgPrint("Error\n");return FALSE;}
    DbgPrint("\nTest --PreviousRun--|--NewRun--||--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 20, 1120, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest 0:|--NewRun--|--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb,  0, 1100, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    PbUninitializeMcb(Mcb);

    //
    //  Build the following runs
    //
    //  [0-69][80-79|80-89|90-99]
    //

    PbInitializeMcb(Mcb, NonPagedPool);
    if (!PbAddMcbEntry(Mcb, 90, 1090, 10)) {DbgPrint("Error\n");return FALSE;}

    if (!PbAddMcbEntry(Mcb, 70, 1070, 10)) {DbgPrint("Error\n");return FALSE;}
    DbgPrint("\nTest --PreviousRun--||--NewRun--||--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb, 80, 1010, 10)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    DbgPrint("\nTest 0:|--NewRun--||--FollowingRun--\n");
    if (!PbAddMcbEntry(Mcb,  0, 1100, 70)) {DbgPrint("Error\n");return FALSE;}
    PbDumpMcb( Mcb );

    PbUninitializeMcb(Mcb);

    return TRUE;

}


BOOLEAN
TestRemoveEntry()
{
    MCB Mcb;
    ULONG i;
    ULONG Vbn,Lbn,Length;

    DbgPrint("\n\n\n>>>> Test PbRemoveMcbEntry <<<<\n");

    PbInitializeMcb(Mcb, NonPagedPool);
    if (!PbAddMcbEntry(Mcb, 0, 1000, 100)) {DbgPrint("Error\n");return FALSE;}

    DbgPrint("\nTest --Previous--|  Hole\n");
    PbRemoveMcbEntry(Mcb, 90, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --Previous--|  Hole  |--Following--\n");
    PbRemoveMcbEntry(Mcb, 50, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --Previous--|  Hole  |--Hole--\n");
    PbRemoveMcbEntry(Mcb, 40, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --hole--|  Hole  |--Following--\n");
    PbRemoveMcbEntry(Mcb, 60, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --hole--|  Hole\n");
    PbRemoveMcbEntry(Mcb, 70, 20);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest 0:  Hole  |--Following--\n");
    PbRemoveMcbEntry(Mcb, 0, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest over remove\n");
    PbRemoveMcbEntry(Mcb, 0, 100);
    PbDumpMcb( Mcb );

    PbUninitializeMcb(Mcb);



    PbInitializeMcb(Mcb, NonPagedPool);
    if (!PbAddMcbEntry(Mcb, 0, 1000, 100)) {DbgPrint("Error\n");return FALSE;}

    PbRemoveMcbEntry(Mcb, 10, 10);
    DbgPrint("\nTest 0:  Hole |--Hole--\n");
    PbRemoveMcbEntry(Mcb,  0, 10);
    PbDumpMcb( Mcb );

    PbRemoveMcbEntry(Mcb, 30, 10);
    DbgPrint("\nTest --Hole--|  Hole  |--Hole--\n");
    PbRemoveMcbEntry(Mcb, 20, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest over remove\n");
    PbRemoveMcbEntry(Mcb, 0, 100);
    PbDumpMcb( Mcb );

    PbUninitializeMcb(Mcb);



    PbInitializeMcb(Mcb, NonPagedPool);
    if (!PbAddMcbEntry(Mcb, 0, 1000, 100)){DbgPrint("Error\n");return FALSE;}

    DbgPrint("\nTest 0:  Hole\n");
    PbRemoveMcbEntry(Mcb, 0, 100);
    PbDumpMcb( Mcb );

    if (!PbAddMcbEntry(Mcb,  0, 1000,  30)) {DbgPrint("Error\n");return FALSE;}
    if (!PbAddMcbEntry(Mcb, 30, 1130,  30)) {DbgPrint("Error\n");return FALSE;}
    if (!PbAddMcbEntry(Mcb, 60, 1060,  30)) {DbgPrint("Error\n");return FALSE;}
    if (!PbAddMcbEntry(Mcb, 90, 1190,  10)) {DbgPrint("Error\n");return FALSE;}

    DbgPrint("\nTest --Previous--|  Hole  |--Index--||--Following--\n");
    PbRemoveMcbEntry(Mcb, 30, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --Hole--|  Hole  |--Index--||--Following--\n");
    PbRemoveMcbEntry(Mcb, 40, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --Previous--||--Index--|  Hole  |--Following--\n");
    PbRemoveMcbEntry(Mcb, 80, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --Previous--||--Index--|  Hole  |--Hole--\n");
    PbRemoveMcbEntry(Mcb, 70, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest 0:|--Index--|  Hole  |--Index--||--Following--\n");
    PbRemoveMcbEntry(Mcb, 10, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest over remove\n");
    PbRemoveMcbEntry(Mcb, 0, 100);
    PbDumpMcb( Mcb );



    if (!PbAddMcbEntry(Mcb,  0, 1000,  30)) {DbgPrint("Error\n");return FALSE;}
    if (!PbAddMcbEntry(Mcb, 30, 1130,  30)) {DbgPrint("Error\n");return FALSE;}
    if (!PbAddMcbEntry(Mcb, 60, 1060,  30)) {DbgPrint("Error\n");return FALSE;}
    if (!PbAddMcbEntry(Mcb, 90, 1190,  10)) {DbgPrint("Error\n");return FALSE;}

    DbgPrint("\nTest --Previous--||--Index--|  Hole  |--Index--||--Following--\n");
    PbRemoveMcbEntry(Mcb, 40, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest 0:|--Index--|  Hole  |--Following--\n");
    PbRemoveMcbEntry(Mcb, 20, 10);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest --Previous--||--Index--|  Hole\n");
    PbRemoveMcbEntry(Mcb, 80, 20);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest over remove\n");
    PbRemoveMcbEntry(Mcb, 0, 100);
    PbDumpMcb( Mcb );


    if (!PbAddMcbEntry(Mcb,  0, 1000,  100)){DbgPrint("Error\n");return FALSE;}

    DbgPrint("\nTest 0:--Index--|  Hole\n");
    PbRemoveMcbEntry(Mcb, 50, 50);
    PbDumpMcb( Mcb );

    DbgPrint("\nTest over remove\n");
    PbRemoveMcbEntry(Mcb, 0, 100);
    PbDumpMcb( Mcb );



    if (!PbAddMcbEntry(Mcb,  0, 1000,  50)) {DbgPrint("Error\n");return FALSE;}
    if (!PbAddMcbEntry(Mcb, 50, 1150,  50)) {DbgPrint("Error\n");return FALSE;}

    DbgPrint("\nTest 0:  hole  |--Index--||--Following--\n");
    PbRemoveMcbEntry(Mcb,  0, 20);
    PbDumpMcb( Mcb );

    PbUninitializeMcb(Mcb);

    return TRUE;

}


BOOLEAN
TestLookupEntry()
{
    MCB Mcb;
    ULONG i;
    ULONG Vbn,Lbn,Length;

    DbgPrint("\n\n\n>>>> Test PbLookupMcbEntry <<<<\n");

    PbInitializeMcb(Mcb, NonPagedPool);

    for (i =  0; i < 100; i += 30) {
        if (!PbAddMcbEntry(Mcb, i, 1000+i, 10))
            {DbgPrint("Add1Error\n");return FALSE;}
    }
    for (i = 10; i < 100; i += 30) {
        if (!PbAddMcbEntry(Mcb, i, 1100+i, 10))
            {DbgPrint("Add2Error\n");return FALSE;}
    }

    PbDumpMcb( Mcb );

    for (i =  0; i < 100; i += 30) {
        if (!PbLookupMcbEntry(Mcb,i,&Lbn,&Length))
            {DbgPrint("Lookup1Error %d\n", i);return FALSE;}
        if ((Lbn != 1000+i) || (Length != 10))
            {DbgPrint("Result1Error %d, %d, %d\n", i, Lbn, Length);return FALSE;}
        if (!PbLookupMcbEntry(Mcb,i+5,&Lbn,&Length))
            {DbgPrint("Lookup2Error %d\n", i);return FALSE;}
        if ((Lbn != 1000+i+5) || (Length != 5))
            {DbgPrint("Result2Error %d, %d, %d\n", i, Lbn, Length);return FALSE;}
    }

    for (i = 20; i < 100; i += 30) {
        if (!PbLookupMcbEntry(Mcb,i,&Lbn,&Length))
            {DbgPrint("Lookup3Error %d\n", i);return FALSE;}
        if ((Lbn != 0) || (Length != 10))
            {DbgPrint("Result3Error %d, %d, %d\n", i, Lbn, Length);return FALSE;}

        if (!PbLookupMcbEntry(Mcb,i+5,&Lbn,&Length))
            {DbgPrint("Lookup4Error %d\n", i);return FALSE;}
        if ((Lbn != 0) || (Length != 5)) {
            DbgPrint("Result4Error %d", i+5);
            DbgPrint(", %08lx",   Lbn);
            DbgPrint(", %08lx\n", Length);
            return FALSE;
        }
    }

    PbUninitializeMcb(Mcb);

    return TRUE;

}


BOOLEAN
TestGetEntry()
{
    MCB Mcb;
    ULONG i;
    ULONG Vbn,Lbn,Length;

    DbgPrint("\n\n\n>>>> TestPbNumberOfRunsInMcb <<<<\n");

    PbInitializeMcb(Mcb, NonPagedPool);

    for (i =  0; i < 100; i += 30) {
        if (!PbAddMcbEntry(Mcb, i, 1000+i, 10))
            {DbgPrint("Add1Error\n");return FALSE;}
    }
    for (i = 10; i < 100; i += 30) {
        if (!PbAddMcbEntry(Mcb, i, 1100+i, 10))
            {DbgPrint("Add2Error\n");return FALSE;}
    }

    PbDumpMcb( Mcb );

    i = PbNumberOfRunsInMcb(Mcb);
    if (i != 10) {DbgPrint("Error\n");return FALSE;}
    for (i = 0; i < 10; i += 1) {
        if (!PbGetNextMcbEntry(Mcb,i,&Vbn,&Lbn,&Length))
            {DbgPrint("Error\n");return FALSE;}
        DbgPrint("%d", i);
        DbgPrint(", %ld", Vbn);
        DbgPrint(", %ld", Lbn);
        DbgPrint(", %ld\n", Length);
    }

    PbUninitializeMcb(Mcb);

    return TRUE;

}


BOOLEAN
TestLookupLastEntry()
{
    MCB Mcb;
    ULONG i;
    ULONG Vbn,Lbn,Length;


    DbgPrint("\n\n\n>>>> Test PbLookupLastMcbEntry <<<<\n");

    PbInitializeMcb(Mcb, NonPagedPool);

    if (!PbAddMcbEntry(Mcb,  0, 1000, 100)) {DbgPrint("Error\n");return FALSE;}

    if (!PbLookupLastMcbEntry(Mcb, &Vbn, &Lbn)) {DbgPrint("Error\n");return FALSE;}
    if ((Vbn != 99) && (Lbn != 1099)) {DbgPrint("Lookup Error\n");return FALSE;}

    PbUninitializeMcb(Mcb);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fstub\drivesup.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    hanfnc.c

Abstract:

    default handlers for hal functions which don't get handlers
    installed by the hal

Author:

    Ken Reneris (kenr) 19-July-1994

Revision History:

    G.Chrysanthakopoulos (georgioc)
    Added support for removable disk with a BPB,instead of a partition table.
    All changes in HalIoReadParitionTable. Started 01-June-1996

--*/

#include "ntos.h"
#include "zwapi.h"
#include "hal.h"
#include "ntdddisk.h"
#include "haldisp.h"
#include "ntddft.h"
#include "mountmgr.h"
#include "stdio.h"
#include <setupblk.h>

#include "drivesup.h"
#include "fstub.h"


//
// Macro definitions
//

#define GET_STARTING_SECTOR( p ) (                  \
        (ULONG) (p->StartingSectorLsb0) +           \
        (ULONG) (p->StartingSectorLsb1 << 8) +      \
        (ULONG) (p->StartingSectorMsb0 << 16) +     \
        (ULONG) (p->StartingSectorMsb1 << 24) )

#define GET_PARTITION_LENGTH( p ) (                 \
        (ULONG) (p->PartitionLengthLsb0) +          \
        (ULONG) (p->PartitionLengthLsb1 << 8) +     \
        (ULONG) (p->PartitionLengthMsb0 << 16) +    \
        (ULONG) (p->PartitionLengthMsb1 << 24) )

//
//  Structure for determing if an 0xaa55 marked sector has a BPB in it.
//

typedef struct _BOOT_SECTOR_INFO {
    UCHAR   JumpByte[1];
    UCHAR   Ignore1[2];
    UCHAR   OemData[8];
    UCHAR   BytesPerSector[2];
    UCHAR   Ignore2[6];
    UCHAR   NumberOfSectors[2];
    UCHAR   MediaByte[1];
    UCHAR   Ignore3[2];
    UCHAR   SectorsPerTrack[2];
    UCHAR   NumberOfHeads[2];
} BOOT_SECTOR_INFO, *PBOOT_SECTOR_INFO;

typedef struct _PARTITION_TABLE {
    PARTITION_INFORMATION PartitionEntry[4];
} PARTITION_TABLE, *PPARTITION_TABLE;

typedef struct _DISK_LAYOUT {
    ULONG TableCount;
    ULONG Signature;
    PARTITION_TABLE PartitionTable[1];
} DISK_LAYOUT, *PDISK_LAYOUT;

typedef struct _PTE {
    UCHAR ActiveFlag;               // Bootable or not
    UCHAR StartingTrack;            // Not used
    USHORT StartingCylinder;        // Not used
    UCHAR PartitionType;            // 12 bit FAT, 16 bit FAT etc.
    UCHAR EndingTrack;              // Not used
    USHORT EndingCylinder;          // Not used
    ULONG StartingSector;           // Hidden sectors
    ULONG PartitionLength;          // Sectors in this partition
} PTE;
typedef PTE UNALIGNED *PPTE;


//
// Strings definitions
//

static PUCHAR DiskPartitionName = "\\Device\\Harddisk%d\\Partition%d";
static PUCHAR RegistryKeyName   = DISK_REGISTRY_KEY;

VOID
HalpCalculateChsValues(
    IN PLARGE_INTEGER PartitionOffset,
    IN PLARGE_INTEGER PartitionLength,
    IN CCHAR ShiftCount,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfTracks,
    IN ULONG ConventionalCylinders,
    OUT PPARTITION_DESCRIPTOR PartitionDescriptor
    );

NTSTATUS
HalpQueryPartitionType(
    IN  PUNICODE_STRING             DeviceName,
    IN  PDRIVE_LAYOUT_INFORMATION   DriveLayout,
    OUT PULONG                      PartitionType
    );

NTSTATUS
HalpQueryDriveLayout(
    IN  PUNICODE_STRING             DeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION*  DriveLayout
    );

VOID
FASTCALL
xHalGetPartialGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG ConventionalCylinders,
    IN PLONGLONG DiskSize
    );

NTSTATUS
HalpGetFullGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDISK_GEOMETRY Geometry,
    OUT PULONGLONG RealSectorCount
    );

BOOLEAN
HalpIsValidPartitionEntry(
    PPARTITION_DESCRIPTOR Entry,
    ULONGLONG MaxOffset,
    ULONGLONG MaxSector
    );

NTSTATUS
HalpNextMountLetter(
    IN  PUNICODE_STRING DeviceName,
    OUT PUCHAR          DriveLetter
    );

UCHAR
HalpNextDriveLetter(
    IN  PUNICODE_STRING DeviceName,
    IN  PSTRING         NtDeviceName,
    OUT PUCHAR          NtSystemPath,
    IN  BOOLEAN         UseHardLinksIfNecessary
    );

VOID
HalpEnableAutomaticDriveLetterAssignment(
    );

NTSTATUS
HalpSetMountLetter(
    IN  PUNICODE_STRING DeviceName,
    IN  UCHAR           DriveLetter
    );

BOOLEAN
HalpIsOldStyleFloppy(
    IN  PUNICODE_STRING DeviceName
    );

PULONG
IopComputeHarddiskDerangements(
    IN  ULONG   DiskCount
    );

VOID
FstubFixupEfiPartition(
    IN PPARTITION_DESCRIPTOR Entry,
    IN ULONGLONG MaxSector
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpCalculateChsValues)
#pragma alloc_text(PAGE, HalpQueryPartitionType)
#pragma alloc_text(PAGE, HalpQueryDriveLayout)
#pragma alloc_text(PAGE, HalpNextMountLetter)
#pragma alloc_text(PAGE, HalpNextDriveLetter)
#pragma alloc_text(PAGE, HalpEnableAutomaticDriveLetterAssignment)
#pragma alloc_text(PAGE, HalpSetMountLetter)
#pragma alloc_text(PAGE, IoAssignDriveLetters)
#pragma alloc_text(PAGE, IoReadPartitionTable)
#pragma alloc_text(PAGE, IoSetPartitionInformation)
#pragma alloc_text(PAGE, IoWritePartitionTable)
#pragma alloc_text(PAGE, HalpIsValidPartitionEntry)
#pragma alloc_text(PAGE, HalpGetFullGeometry)
#pragma alloc_text(PAGE, HalpIsOldStyleFloppy)
#pragma alloc_text(PAGE, IopComputeHarddiskDerangements)
#pragma alloc_text(PAGE, FstubFixupEfiPartition)
#endif



VOID
FASTCALL
HalExamineMBR(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG MBRTypeIdentifier,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    Given a master boot record type (MBR - the zero'th sector on the disk),
    read the master boot record of a disk.  If the MBR is found to be of that
    type, allocate a structure whose layout is dependant upon that partition
    type, fill with the appropriate values, and return a pointer to that buffer
    in the output parameter.

    The best example for a use of this routine is to support Ontrack
    systems DiskManager software.  Ontrack software lays down a special
    partition describing the entire drive.  The special partition type
    (0x54) will be recognized and a couple of longwords of data will
    be passed back in a buffer for a disk driver to act upon.

Arguments:

    DeviceObject - The device object describing the entire drive.

    SectorSize - The minimum number of bytes that an IO operation can
                 fetch.

    MBRIndentifier - A value that will be searched for in the
                     in the MBR.  This routine will understand
                     the semantics implied by this value.

    Buffer - Pointer to a buffer that returns data according to the
             type of MBR searched for.  If the MBR is not of the
             type asked for, the buffer will not be allocated and this
             pointer will be NULL.  It is the responsibility of the
             caller of HalExamineMBR to deallocate the buffer.  The
             caller should deallocate the memory ASAP.

Return Value:

    None.

--*/

{


    LARGE_INTEGER partitionTableOffset;
    PUCHAR readBuffer = (PUCHAR) NULL;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIRP irp;
    PPARTITION_DESCRIPTOR partitionTableEntry;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG readSize;

    *Buffer = NULL;
    //
    // Determine the size of a read operation to ensure that at least 512
    // bytes are read.  This will guarantee that enough data is read to
    // include an entire partition table.  Note that this code assumes that
    // the actual sector size of the disk (if less than 512 bytes) is a
    // multiple of 2, a fairly reasonable assumption.
    //

    if (SectorSize >= 512) {
        readSize = SectorSize;
    } else {
        readSize = 512;
    }

    //
    // Start at sector 0 of the device.
    //

    partitionTableOffset = RtlConvertUlongToLargeInteger( 0 );

    //
    // Allocate a buffer that will hold the reads.
    //

    readBuffer = ExAllocatePoolWithTag(
                     NonPagedPoolCacheAligned,
                     PAGE_SIZE>readSize?PAGE_SIZE:readSize,
                     'btsF'
                     );

    if (readBuffer == NULL) {
        return;
    }

    //
    // Read record containing partition table.
    //
    // Create a notification event object to be used while waiting for
    // the read request to complete.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                        DeviceObject,
                                        readBuffer,
                                        readSize,
                                        &partitionTableOffset,
                                        &event,
                                        &ioStatus );

    if (!irp) {
        ExFreePool(readBuffer);
        return;
    } else {
        PIO_STACK_LOCATION irpStack;
        irpStack = IoGetNextIrpStackLocation(irp);
        irpStack->Flags |= SL_OVERRIDE_VERIFY_VOLUME;
    }

    status = IoCallDriver( DeviceObject, irp );

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS( status )) {
        ExFreePool(readBuffer);
        return;
    }

    //
    // Check for Boot Record signature.
    //

    if (((PUSHORT) readBuffer)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
        ExFreePool(readBuffer);
        return;
    }

    //
    // Check for DM type partition.
    //

    partitionTableEntry = (PPARTITION_DESCRIPTOR) &(((PUSHORT) readBuffer)[PARTITION_TABLE_OFFSET]);

    if (partitionTableEntry->PartitionType != MBRTypeIdentifier) {

        //
        // The partition type isn't what the caller cares about.
        //
        ExFreePool(readBuffer);

    } else {

        if (partitionTableEntry->PartitionType == 0x54) {

            //
            // Rather than allocate a new piece of memory to return
            // the data - just use the memory allocated for the buffer.
            // We can assume the caller will delete this shortly.
            //

            ((PULONG)readBuffer)[0] = 63;
            *Buffer = readBuffer;

        } else if (partitionTableEntry->PartitionType == 0x55) {

            //
            // EzDrive Parititon.  Simply return the pointer to non-null
            // There is no skewing here.
            //

            *Buffer = readBuffer;

        } else {

            ASSERT(partitionTableEntry->PartitionType == 0x55);

        }

    }

}

VOID
FASTCALL
xHalGetPartialGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG ConventionalCylinders,
    IN PLONGLONG DiskSize
    )

/*++

Routine Description:

    We need this routine to get the number of cylinders that the disk driver
    thinks is on the drive.  We will need this to calculate CHS values
    when we fill in the partition table entries.

Arguments:

    DeviceObject - The device object describing the entire drive.

    ConventionalCylinders - Number of cylinders on the drive.

Return Value:

    None.

--*/

{
    PIRP localIrp;
    PDISK_GEOMETRY diskGeometry;
    PIO_STATUS_BLOCK iosb;
    PKEVENT eventPtr;
    NTSTATUS status;

    *ConventionalCylinders = 0UL;
    *DiskSize = 0UL;

    diskGeometry = ExAllocatePoolWithTag(
                      NonPagedPool,
                      sizeof(DISK_GEOMETRY),
                      'btsF'
                      );

    if (!diskGeometry) {

        return;

    }

    iosb = ExAllocatePoolWithTag(
               NonPagedPool,
               sizeof(IO_STATUS_BLOCK),
               'btsF'
               );

    if (!iosb) {

        ExFreePool(diskGeometry);
        return;

    }

    eventPtr = ExAllocatePoolWithTag(
                   NonPagedPool,
                   sizeof(KEVENT),
                   'btsF'
                   );

    if (!eventPtr) {

        ExFreePool(iosb);
        ExFreePool(diskGeometry);
        return;

    }

    KeInitializeEvent(
        eventPtr,
        NotificationEvent,
        FALSE
        );

    localIrp = IoBuildDeviceIoControlRequest(
                   IOCTL_DISK_GET_DRIVE_GEOMETRY,
                   DeviceObject,
                   NULL,
                   0UL,
                   diskGeometry,
                   sizeof(DISK_GEOMETRY),
                   FALSE,
                   eventPtr,
                   iosb
                   );

    if (!localIrp) {

        ExFreePool(eventPtr);
        ExFreePool(iosb);
        ExFreePool(diskGeometry);
        return;

    }


    //
    // Call the lower level driver, wait for the opertion
    // to finish.
    //

    status = IoCallDriver(
                 DeviceObject,
                 localIrp
                 );

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject(
                   eventPtr,
                   Executive,
                   KernelMode,
                   FALSE,
                   (PLARGE_INTEGER) NULL
                   );
        status = iosb->Status;
    }

    if (NT_SUCCESS(status)) {

    //
    // The operation completed successfully.  Get the cylinder
    // count of the drive.
    //

        *ConventionalCylinders = diskGeometry->Cylinders.LowPart;

        //
        // If the count is less than 1024 we can pass that back.  Otherwise
        // send back the 1024
        //

        if (diskGeometry->Cylinders.QuadPart >= (LONGLONG)1024) {

            *ConventionalCylinders = 1024;

        }

        //
        // Calculate disk size from gemotry information
        //

        *DiskSize = diskGeometry->Cylinders.QuadPart *
                    diskGeometry->TracksPerCylinder *
                    diskGeometry->SectorsPerTrack *
                    diskGeometry->BytesPerSector;

    }

    ExFreePool(eventPtr);
    ExFreePool(iosb);
    ExFreePool(diskGeometry);
    return;

}


VOID
HalpCalculateChsValues(
    IN PLARGE_INTEGER PartitionOffset,
    IN PLARGE_INTEGER PartitionLength,
    IN CCHAR ShiftCount,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfTracks,
    IN ULONG ConventionalCylinders,
    OUT PPARTITION_DESCRIPTOR PartitionDescriptor
    )

/*++

Routine Description:

    This routine will determine the cylinder, head, and sector (CHS) values
    that should be placed in a partition table entry, given the partition's
    location on the disk and its size.  The values calculated are packed into
    int13 format -- the high two bits of the sector byte contain bits 8 and 9
    of the 10 bit cylinder value, the low 6 bits of the sector byte contain
    the 6 bit sector value;  the cylinder byte contains the low 8 bits
    of the cylinder value; and the head byte contains the 8-bit head value.
    Both the start and end CHS values are calculated.

Arguments:

    PartitionOffset - Byte offset of the partition, relative to the entire
        physical disk.

    PartitionLength - Size in bytes of the partition.

    ShiftCount - Shift count to convert from byte counts to sector counts.

    SectorsPerTrack - Number of sectors in a track on the media on which
        the partition resides.

    NumberOfTracks - Number of tracks in a cylinder on the media on which
        the partition resides.

    ConventionalCylinders - The "normalized" disk cylinders.  We will never
        set the cylinders greater than this.

    PartitionDescriptor - Structure to be filled in with the start and
        end CHS values.  Other fields in the structure are not referenced
        or modified.

Return Value:

    None.

Note:

    The Cylinder and Head values are 0-based but the Sector value is 1-based.

    If the start or end cylinder overflows 10 bits (ie, > 1023), CHS values
    will be set to all 1's.

    No checking is done on the SectorsPerTrack and NumberOfTrack values.

--*/

{
    ULONG startSector, sectorCount, endSector;
    ULONG sectorsPerCylinder;
    ULONG remainder;
    ULONG startC, startH, startS, endC, endH, endS;
    LARGE_INTEGER tempInt;

    PAGED_CODE();

    //
    // Calculate the number of sectors in a cylinder.  This is the
    // number of heads multiplied by the number of sectors per track.
    //

    sectorsPerCylinder = SectorsPerTrack * NumberOfTracks;

    //
    // Convert byte offset/count to sector offset/count.
    //

    tempInt.QuadPart = PartitionOffset->QuadPart >> ShiftCount;
    startSector = tempInt.LowPart;

    tempInt.QuadPart = PartitionLength->QuadPart >> ShiftCount;
    sectorCount = tempInt.LowPart;

    endSector = startSector + sectorCount - 1;

    startC = startSector / sectorsPerCylinder;
    endC   = endSector   / sectorsPerCylinder;

    if (!ConventionalCylinders) {

        ConventionalCylinders = 1024;

    }

    //
    // Set these values so that win95 is happy.
    //

    if (startC >= ConventionalCylinders) {

        startC = ConventionalCylinders - 1;

    }

    if (endC >= ConventionalCylinders) {

        endC = ConventionalCylinders - 1;

    }

    //
    // Calculate the starting track and sector.
    //

    remainder = startSector % sectorsPerCylinder;
    startH = remainder / SectorsPerTrack;
    startS = remainder % SectorsPerTrack;

    //
    // Calculate the ending track and sector.
    //

    remainder = endSector % sectorsPerCylinder;
    endH = remainder / SectorsPerTrack;
    endS = remainder % SectorsPerTrack;

    //
    // Pack the result into the caller's structure.
    //

    // low 8 bits of the cylinder => C value

    PartitionDescriptor->StartingCylinderMsb = (UCHAR) startC;
    PartitionDescriptor->EndingCylinderMsb   = (UCHAR) endC;

    // 8 bits of head value => H value

    PartitionDescriptor->StartingTrack = (UCHAR) startH;
    PartitionDescriptor->EndingTrack   = (UCHAR) endH;

    // bits 8-9 of cylinder and 6 bits of the sector => S value

    PartitionDescriptor->StartingCylinderLsb = (UCHAR) (((startS + 1) & 0x3f)
                                                        | ((startC >> 2) & 0xc0));

    PartitionDescriptor->EndingCylinderLsb = (UCHAR) (((endS + 1) & 0x3f)
                                                        | ((endC >> 2) & 0xc0));
}


#define BOOTABLE_PARTITION  0
#define PRIMARY_PARTITION   1
#define LOGICAL_PARTITION   2
#define FT_PARTITION        3
#define OTHER_PARTITION     4
#define GPT_PARTITION       5

NTSTATUS
HalpQueryPartitionType(
    IN  PUNICODE_STRING             DeviceName,
    IN  PDRIVE_LAYOUT_INFORMATION   DriveLayout,
    OUT PULONG                      PartitionType
    )

{
    NTSTATUS                    status;
    PFILE_OBJECT                fileObject;
    PDEVICE_OBJECT              deviceObject;
    KEVENT                      event;
    PIRP                        irp;
    PARTITION_INFORMATION_EX    partInfo;
    IO_STATUS_BLOCK             ioStatus;
    ULONG                       i;

    status = IoGetDeviceObjectPointer(DeviceName,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
    ObDereferenceObject(fileObject);

    if (deviceObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        ObDereferenceObject(deviceObject);
        *PartitionType = LOGICAL_PARTITION;
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO_EX,
                                        deviceObject, NULL, 0, &partInfo,
                                        sizeof(partInfo), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);

    if (!NT_SUCCESS(status)) {
        if (!DriveLayout) {
            *PartitionType = LOGICAL_PARTITION;
            return STATUS_SUCCESS;
        }
        return status;
    }

    if (partInfo.PartitionStyle != PARTITION_STYLE_MBR) {
        if (partInfo.PartitionStyle != PARTITION_STYLE_GPT) {
            *PartitionType = OTHER_PARTITION;
            return STATUS_SUCCESS;
        }

        if (IsEqualGUID(&partInfo.Gpt.PartitionType,
                        &PARTITION_BASIC_DATA_GUID)) {

            *PartitionType = GPT_PARTITION;
            return STATUS_SUCCESS;
        }

        *PartitionType = OTHER_PARTITION;
        return STATUS_SUCCESS;
    }

    if (!IsRecognizedPartition(partInfo.Mbr.PartitionType)) {
        *PartitionType = OTHER_PARTITION;
        return STATUS_SUCCESS;
    }

    if (partInfo.Mbr.PartitionType&0x80) {
        *PartitionType = FT_PARTITION;
        return STATUS_SUCCESS;
    }

    if (!DriveLayout) {
        *PartitionType = LOGICAL_PARTITION;
        return STATUS_SUCCESS;
    }

    for (i = 0; i < 4; i++) {
        if (partInfo.StartingOffset.QuadPart ==
            DriveLayout->PartitionEntry[i].StartingOffset.QuadPart) {

            if (partInfo.Mbr.BootIndicator) {
                *PartitionType = BOOTABLE_PARTITION;
            } else {
                *PartitionType = PRIMARY_PARTITION;
            }

            return STATUS_SUCCESS;
        }
    }

    *PartitionType = LOGICAL_PARTITION;

    return STATUS_SUCCESS;
}


NTSTATUS
HalpQueryDriveLayout(
    IN  PUNICODE_STRING             DeviceName,
    OUT PDRIVE_LAYOUT_INFORMATION*  DriveLayout
    )

{
    NTSTATUS        status;
    PFILE_OBJECT    fileObject;
    PDEVICE_OBJECT  deviceObject;
    KEVENT          event;
    PIRP            irp;
    DISK_GEOMETRY   geometry;
    IO_STATUS_BLOCK ioStatus;

    status = IoGetDeviceObjectPointer(DeviceName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
    ObDereferenceObject(fileObject);

    if (deviceObject->Characteristics&FILE_REMOVABLE_MEDIA) {
        ObDereferenceObject(deviceObject);
        return STATUS_NO_MEDIA;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        deviceObject, NULL, 0, &geometry,
                                        sizeof(geometry), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ObDereferenceObject(deviceObject);
        return status;
    }

    status = IoReadPartitionTable(deviceObject, geometry.BytesPerSector,
                                  FALSE, DriveLayout);

    ObDereferenceObject(deviceObject);

    return status;
}


NTSTATUS
HalpNextMountLetter(
    IN  PUNICODE_STRING DeviceName,
    OUT PUCHAR          DriveLetter
    )

/*++

Routine Description:

    This routine gives the device the next available drive letter.

Arguments:

    DeviceName  - Supplies the device name.

    DriveLetter - Returns the drive letter assigned or 0.

Return Value:

    NTSTATUS

--*/

{
    UNICODE_STRING                      name;
    PFILE_OBJECT                        fileObject;
    PDEVICE_OBJECT                      deviceObject;
    PMOUNTMGR_DRIVE_LETTER_TARGET       input;
    KEVENT                              event;
    PIRP                                irp;
    MOUNTMGR_DRIVE_LETTER_INFORMATION   output;
    IO_STATUS_BLOCK                     ioStatus;
    NTSTATUS                            status;

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    input = ExAllocatePoolWithTag(PagedPool,
                                  (sizeof(MOUNTMGR_DRIVE_LETTER_TARGET) +
                                   DeviceName->Length),
                                  'btsF'
                                 );

    if (!input) {
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    input->DeviceNameLength = DeviceName->Length;
    RtlCopyMemory(input->DeviceName, DeviceName->Buffer, DeviceName->Length);

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER,
                                        deviceObject, input,
                                        sizeof(MOUNTMGR_DRIVE_LETTER_TARGET) +
                                        DeviceName->Length, &output,
                                        sizeof(output), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ExFreePool(input);
        ObDereferenceObject(fileObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ExFreePool(input);
    ObDereferenceObject(fileObject);

    *DriveLetter = output.CurrentDriveLetter;

    return status;
}

UCHAR
HalpNextDriveLetter(
    IN  PUNICODE_STRING DeviceName,
    IN  PSTRING         NtDeviceName,
    OUT PUCHAR          NtSystemPath,
    IN  BOOLEAN         UseHardLinksIfNecessary
    )

/*++

Routine Description:

    This routine gives the device the next available drive letter.

Arguments:

    DeviceName      - Supplies the device name.

    NtDeviceName    - Supplies the NT device name.

    NtSystemPath    - Supplies the NT system path.

Return Value:

    The drive letter assigned or 0.

--*/

{
    NTSTATUS        status;
    UCHAR           firstDriveLetter, driveLetter;
    WCHAR           name[40];
    UNICODE_STRING  symName;
    UNICODE_STRING  unicodeString, floppyPrefix, cdromPrefix;

    status = HalpNextMountLetter(DeviceName, &driveLetter);
    if (NT_SUCCESS(status)) {
        return driveLetter;
    }

    if (!NtDeviceName || !NtSystemPath) {
        return 0xFF;
    }

    if (!UseHardLinksIfNecessary) {
        return 0;
    }

    RtlInitUnicodeString(&floppyPrefix, L"\\Device\\Floppy");
    RtlInitUnicodeString(&cdromPrefix, L"\\Device\\CdRom");
    if (RtlPrefixUnicodeString(&floppyPrefix, DeviceName, TRUE)) {
        firstDriveLetter = 'A';
    } else if (RtlPrefixUnicodeString(&cdromPrefix, DeviceName, TRUE)) {
        firstDriveLetter = 'D';
    } else {
        firstDriveLetter = 'C';
    }

    for (driveLetter = firstDriveLetter; driveLetter <= 'Z'; driveLetter++) {
        status = HalpSetMountLetter(DeviceName, driveLetter);
        if (NT_SUCCESS(status)) {
            RtlAnsiStringToUnicodeString(&unicodeString, NtDeviceName, TRUE);
            if (RtlEqualUnicodeString(&unicodeString, DeviceName, TRUE)) {
                NtSystemPath[0] = driveLetter;
            }
            RtlFreeUnicodeString(&unicodeString);
            return driveLetter;
        }
    }

    for (driveLetter = firstDriveLetter; driveLetter <= 'Z'; driveLetter++) {
        swprintf(name, L"\\DosDevices\\%c:", driveLetter);
        RtlInitUnicodeString(&symName, name);
        status = IoCreateSymbolicLink(&symName, DeviceName);
        if (NT_SUCCESS(status)) {
            RtlAnsiStringToUnicodeString(&unicodeString, NtDeviceName, TRUE);
            if (RtlEqualUnicodeString(&unicodeString, DeviceName, TRUE)) {
                NtSystemPath[0] = driveLetter;
            }
            RtlFreeUnicodeString(&unicodeString);
            return driveLetter;
        }
    }

    return 0;
}


VOID
HalpEnableAutomaticDriveLetterAssignment(
    )

/*++

Routine Description:

    This routine enables automatic drive letter assignment by the mount
    point manager.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UNICODE_STRING  name;
    PFILE_OBJECT    fileObject;
    PDEVICE_OBJECT  deviceObject;
    KEVENT          event;
    PIRP            irp;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS        status;

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        return;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS,
                                        deviceObject, NULL, 0, NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        ObDereferenceObject(fileObject);
        return;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(fileObject);
}


NTSTATUS
HalpSetMountLetter(
    IN  PUNICODE_STRING DeviceName,
    IN  UCHAR           DriveLetter
    )

/*++

Routine Description:

    This routine sets the drive letter for the given device.

Arguments:

    DeviceName  - Supplies the device name.

    DriveLetter - Supplies the drive letter.

Return Value:

    NTSTATUS

--*/

{
    WCHAR                           dosBuffer[30];
    UNICODE_STRING                  dosName;
    ULONG                           createPointSize;
    PMOUNTMGR_CREATE_POINT_INPUT    createPoint;
    UNICODE_STRING                  name;
    NTSTATUS                        status;
    PFILE_OBJECT                    fileObject;
    PDEVICE_OBJECT                  deviceObject;
    KEVENT                          event;
    PIRP                            irp;
    IO_STATUS_BLOCK                 ioStatus;

    swprintf(dosBuffer, L"\\DosDevices\\%c:", DriveLetter);
    RtlInitUnicodeString(&dosName, dosBuffer);

    createPointSize = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
                      dosName.Length + DeviceName->Length;

    createPoint = (PMOUNTMGR_CREATE_POINT_INPUT)
                  ExAllocatePoolWithTag(PagedPool, createPointSize, 'btsF');
    if (!createPoint) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    createPoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    createPoint->SymbolicLinkNameLength = dosName.Length;
    createPoint->DeviceNameOffset = createPoint->SymbolicLinkNameOffset +
                                    createPoint->SymbolicLinkNameLength;
    createPoint->DeviceNameLength = DeviceName->Length;

    RtlCopyMemory((PCHAR) createPoint + createPoint->SymbolicLinkNameOffset,
                  dosName.Buffer, dosName.Length);
    RtlCopyMemory((PCHAR) createPoint + createPoint->DeviceNameOffset,
                  DeviceName->Buffer, DeviceName->Length);

    RtlInitUnicodeString(&name, MOUNTMGR_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(&name, FILE_READ_ATTRIBUTES, &fileObject,
                                      &deviceObject);
    if (!NT_SUCCESS(status)) {
        ExFreePool(createPoint);
        return status;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_CREATE_POINT,
                                        deviceObject, createPoint,
                                        createPointSize, NULL, 0, FALSE,
                                        &event, &ioStatus);
    if (!irp) {
        ObDereferenceObject(fileObject);
        ExFreePool(createPoint);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(fileObject);
    ExFreePool(createPoint);

    return status;
}



BOOLEAN
HalpIsOldStyleFloppy(
    IN  PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine determines whether or not the given device is an old style
    floppy.  That is, a floppy controlled by a traditional floppy controller.
    These floppies have precedent in the drive letter ordering.

Arguments:

    DeviceName  - Supplies the device name.

Return Value:

    FALSE   - The given device is not an old style floppy.

    TRUE    - The given device is an old style floppy.

--*/

{
    PFILE_OBJECT    fileObject;
    PDEVICE_OBJECT  deviceObject;
    KEVENT          event;
    PIRP            irp;
    MOUNTDEV_NAME   name;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS        status;

    PAGED_CODE();

    status = IoGetDeviceObjectPointer(DeviceName, FILE_READ_ATTRIBUTES,
                                      &fileObject, &deviceObject);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }
    deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
    ObDereferenceObject(fileObject);


    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                                        deviceObject, NULL, 0, &name,
                                        sizeof(name), FALSE, &event,
                                        &ioStatus);
    if (!irp) {
        ObDereferenceObject(deviceObject);
        return FALSE;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    ObDereferenceObject(deviceObject);

    if (status == STATUS_BUFFER_OVERFLOW) {
        return FALSE;
    }

    return TRUE;
}

PULONG
IopComputeHarddiskDerangements(
    IN  ULONG   DiskCount
    )

/*++

Routine Description:

    This routine returns an array of hard disk numbers in the correct firmware
    (BIOS) order.  It does this by using the \ArcName\multi() names.

Arguments:

    DiskCount   - Supplies the number of disks in the system.

Return Value:

    An array of hard disk numbers.  The caller must free this list with
    ExFreePool.

--*/

{
    PULONG                  r;
    ULONG                   i, j;
    WCHAR                   deviceNameBuffer[50];
    UNICODE_STRING          deviceName;
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    KEVENT                  event;
    PIRP                    irp;
    STORAGE_DEVICE_NUMBER   number;
    IO_STATUS_BLOCK         ioStatus;

    if (DiskCount == 0) {
        return NULL;
    }

    r = ExAllocatePool(PagedPool|POOL_COLD_ALLOCATION, DiskCount*sizeof(ULONG));
    if (!r) {
        return NULL;
    }

    for (i = 0; i < DiskCount; i++) {
        swprintf(deviceNameBuffer, L"\\ArcName\\multi(0)disk(0)rdisk(%d)", i);
        RtlInitUnicodeString(&deviceName, deviceNameBuffer);

        status = IoGetDeviceObjectPointer(&deviceName, FILE_READ_ATTRIBUTES,
                                          &fileObject, &deviceObject);
        if (!NT_SUCCESS(status)) {
            r[i] = (ULONG) -1;
            continue;
        }
        deviceObject = IoGetAttachedDeviceReference(fileObject->DeviceObject);
        ObDereferenceObject(fileObject);

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                            deviceObject, NULL, 0, &number,
                                            sizeof(number), FALSE, &event,
                                            &ioStatus);
        if (!irp) {
            ObDereferenceObject(deviceObject);
            r[i] = (ULONG) -1;
            continue;
        }

        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        ObDereferenceObject(deviceObject);

        if (!NT_SUCCESS(status)) {
            r[i] = (ULONG) -1;
            continue;
        }

        r[i] = number.DeviceNumber;
    }

    for (i = 0; i < DiskCount; i++) {
        for (j = 0; j < DiskCount; j++) {
            if (r[j] == i) {
                break;
            }
        }
        if (j < DiskCount) {
            continue;
        }
        for (j = 0; j < DiskCount; j++) {
            if (r[j] == (ULONG) -1) {
                r[j] = i;
                break;
            }
        }
    }

    return r;
}

VOID
FASTCALL
IoAssignDriveLetters(
    IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    IN PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    )

/*++

Routine Description:

    This routine assigns DOS drive letters to eligible disk partitions
    and CDROM drives. It also maps the partition containing the NT
    boot path to \SystemRoot. In NT, objects are built for all partition
    types except 0 (unused) and 5 (extended). But drive letters are assigned
    only to recognized partition types (1, 4, 6, 7, e).

    Drive letter assignment is done in several stages:

        1) For each CdRom:
            Determine if sticky letters are assigned and reserve the letter.

        2) For each disk:
            Determine how many primary partitions and which is bootable.
            Determine which partitions already have 'sticky letters'
                and create their symbolic links.
            Create a bit map for each disk that idicates which partitions
                require default drive letter assignments.

        3) For each disk:
            Assign default drive letters for the bootable
                primary partition or the first nonbootable primary partition.

        4) For each disk:
            Assign default drive letters for the partitions in
                extended volumes.

        5) For each disk:
            Assign default drive letters for the remaining (ENHANCED)
                primary partitions.

        6) Assign A: and B: to the first two floppies in the system if they
            exist. Then assign remaining floppies next available drive letters.

        7) Assign drive letters to CdRoms (either sticky or default).

Arguments:

    LoaderBlock - pointer to a loader parameter block.

    NtDeviceName - pointer to the boot device name string used
            to resolve NtSystemPath.

Return Value:

    None.

--*/

{
    PUCHAR ntName;
    STRING ansiString;
    UNICODE_STRING unicodeString;
    PUCHAR ntPhysicalName;
    STRING ansiPhysicalString;
    UNICODE_STRING unicodePhysicalString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    PCONFIGURATION_INFORMATION configurationInformation;
    ULONG diskCount;
    ULONG floppyCount;
    HANDLE deviceHandle;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG diskNumber;
    ULONG i, j, k;
    UCHAR driveLetter;
    WCHAR deviceNameBuffer[50];
    UNICODE_STRING deviceName, floppyPrefix, cdromPrefix;
    PDRIVE_LAYOUT_INFORMATION layout;
    BOOLEAN bootable;
    ULONG partitionType;
    ULONG skip;
    ULONG diskCountIncrement;
    ULONG actualDiskCount = 0;
    PULONG harddiskDerangementArray;

    PAGED_CODE();

    //
    // Get the count of devices from the registry.
    //

    configurationInformation = IoGetConfigurationInformation();

    diskCount = configurationInformation->DiskCount;
    floppyCount = configurationInformation->FloppyCount;

    //
    // Allocate general NT name buffer.
    //

    ntName = ExAllocatePoolWithTag( NonPagedPool, 128, 'btsF');

    ntPhysicalName = ExAllocatePoolWithTag( NonPagedPool, 64, 'btsF');

    if (ntName == NULL || ntPhysicalName == NULL) {

        KeBugCheck( ASSIGN_DRIVE_LETTERS_FAILED );

    }

    //
    // If we're doing a remote boot, set NtSystemPath appropriately.
    //

    if (IoRemoteBootClient) {

        PUCHAR p;
        PUCHAR q;

        //
        // If this is a remote boot setup boot, NtBootPathName is of the
        // form \<server>\<share>\setup\<install-directory>\<platform>.
        // We want the root of the X: drive to be the root of the install
        // directory.
        //
        // If this is a normal remote boot, NtBootPathName is of the form
        // \<server>\<share>\images\<machine>\winnt. We want the root of
        // the X: drive to be the root of the machine directory.
        //
        // Thus in either case, we need to remove all but the last element
        // of the path.
        //
        // Find the beginning of the last element of the path (including
        // the leading backslash).
        //

        p = strrchr( LoaderBlock->NtBootPathName, '\\' );   // find last separator
        q = NULL;
        if ( (p != NULL) && (*(p+1) == 0) ) {

            //
            // NtBootPathName ends with a backslash, so we need to back up
            // to the previous backslash.
            //

            q = p;
            *q = 0;
            p = strrchr( LoaderBlock->NtBootPathName, '\\' );   // find last separator
            *q = '\\';
        }
        if ( p == NULL ) {
            KeBugCheck( ASSIGN_DRIVE_LETTERS_FAILED );
        }

        //
        // Set NtSystemPath to X:\<last element of path>. Note that the symbolic
        // link for X: is created in io\ioinit.c\IopInitializeBootDrivers.
        //
        // Note that we use X: for the textmode setup phase of a remote
        // installation. But for a true remote boot, we use C:.
        //

#if defined(REMOTE_BOOT)
        if ((LoaderBlock->SetupLoaderBlock->Flags & (SETUPBLK_FLAGS_REMOTE_INSTALL |
                                                     SETUPBLK_FLAGS_SYSPREP_INSTALL)) == 0) {
            NtSystemPath[0] = 'C';
        } else
#endif
        {
            NtSystemPath[0] = 'X';
        }
        NtSystemPath[1] = ':';
        strcpy(&NtSystemPath[2], p );
        if ( q != NULL ) {
            NtSystemPath[strlen(NtSystemPath)-1] = '\0'; // remove trailing backslash
        }
        RtlInitString(NtSystemPathString, NtSystemPath);

    }

    //
    // For each disk ...
    //

    diskCountIncrement = 0;
    for (diskNumber = 0; diskNumber < diskCount; diskNumber++) {

        //
        // Create ANSI name string for physical disk.
        //

        sprintf( ntName, DiskPartitionName, diskNumber, 0 );

        //
        // Convert to unicode string.
        //

        RtlInitAnsiString( &ansiString, ntName );

        RtlAnsiStringToUnicodeString( &unicodeString, &ansiString, TRUE );

        InitializeObjectAttributes( &objectAttributes,
                                    &unicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );

        //
        // Open device by name.
        //

        status = ZwOpenFile( &deviceHandle,
                             FILE_READ_DATA | SYNCHRONIZE,
                             &objectAttributes,
                             &ioStatusBlock,
                             FILE_SHARE_READ,
                             FILE_SYNCHRONOUS_IO_NONALERT );

        if (NT_SUCCESS( status )) {

            //
            // The device was successfully opened.  Generate a DOS device name
            // for the drive itself.
            //

            sprintf( ntPhysicalName, "\\DosDevices\\PhysicalDrive%d", diskNumber );

            RtlInitAnsiString( &ansiPhysicalString, ntPhysicalName );

            RtlAnsiStringToUnicodeString( &unicodePhysicalString, &ansiPhysicalString, TRUE );

            IoCreateSymbolicLink( &unicodePhysicalString, &unicodeString );

            RtlFreeUnicodeString( &unicodePhysicalString );

            ZwClose(deviceHandle);

            actualDiskCount = diskNumber + 1;
        }

        RtlFreeUnicodeString( &unicodeString );

        if (!NT_SUCCESS( status )) {

#if DBG
            DbgPrint( "IoAssignDriveLetters: Failed to open %s\n", ntName );
#endif // DBG

            //
            // This may be a sparse name space.  Try going farther but
            // not forever.
            //

            if (diskCountIncrement < 50) {
                diskCountIncrement++;
                diskCount++;
            }
        }

    } // end for diskNumber ...

    ExFreePool( ntName );
    ExFreePool( ntPhysicalName );

    diskCount -= diskCountIncrement;
    if (actualDiskCount > diskCount) {
        diskCount = actualDiskCount;
    }

    harddiskDerangementArray = IopComputeHarddiskDerangements(diskCount);

    for (k = 0; k < diskCount; k++) {

        if (harddiskDerangementArray) {
            i = harddiskDerangementArray[k];
        } else {
            i = k;
        }

        swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition0", i);
        RtlInitUnicodeString(&deviceName, deviceNameBuffer);

        status = HalpQueryDriveLayout(&deviceName, &layout);
        if (!NT_SUCCESS(status)) {
            layout = NULL;
        }

        bootable = FALSE;
        for (j = 1; ; j++) {

            swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition%d",
                     i, j);
            RtlInitUnicodeString(&deviceName, deviceNameBuffer);

            status = HalpQueryPartitionType(&deviceName, layout,
                                            &partitionType);
            if (!NT_SUCCESS(status)) {
                break;
            }

            if (partitionType != BOOTABLE_PARTITION &&
                partitionType != GPT_PARTITION) {

                continue;
            }

            bootable = TRUE;

            HalpNextDriveLetter(&deviceName, NtDeviceName, NtSystemPath, FALSE);

            if (partitionType == BOOTABLE_PARTITION) {
                break;
            }
        }

        if (bootable) {
            if (layout) {
                ExFreePool(layout);
            }
            continue;
        }

        for (j = 1; ; j++) {

            swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition%d",
                     i, j);
            RtlInitUnicodeString(&deviceName, deviceNameBuffer);

            status = HalpQueryPartitionType(&deviceName, layout,
                                            &partitionType);
            if (!NT_SUCCESS(status)) {
                break;
            }

            if (partitionType != PRIMARY_PARTITION) {
                continue;
            }

            HalpNextDriveLetter(&deviceName, NtDeviceName, NtSystemPath, FALSE);
            break;
        }

        if (layout) {
            ExFreePool(layout);
        }
    }

    for (k = 0; k < diskCount; k++) {

        if (harddiskDerangementArray) {
            i = harddiskDerangementArray[k];
        } else {
            i = k;
        }

        swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition0", i);
        RtlInitUnicodeString(&deviceName, deviceNameBuffer);

        status = HalpQueryDriveLayout(&deviceName, &layout);
        if (!NT_SUCCESS(status)) {
            layout = NULL;
        }

        for (j = 1; ; j++) {

            swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition%d",
                     i, j);
            RtlInitUnicodeString(&deviceName, deviceNameBuffer);

            status = HalpQueryPartitionType(&deviceName, layout,
                                            &partitionType);
            if (!NT_SUCCESS(status)) {
                break;
            }

            if (partitionType != LOGICAL_PARTITION) {
                continue;
            }

            HalpNextDriveLetter(&deviceName, NtDeviceName, NtSystemPath, FALSE);
        }

        if (layout) {
            ExFreePool(layout);
        }
    }

    for (k = 0; k < diskCount; k++) {

        if (harddiskDerangementArray) {
            i = harddiskDerangementArray[k];
        } else {
            i = k;
        }

        swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition0", i);
        RtlInitUnicodeString(&deviceName, deviceNameBuffer);

        status = HalpQueryDriveLayout(&deviceName, &layout);
        if (!NT_SUCCESS(status)) {
            layout = NULL;
        }

        skip = 0;
        for (j = 1; ; j++) {

            swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition%d",
                     i, j);
            RtlInitUnicodeString(&deviceName, deviceNameBuffer);

            status = HalpQueryPartitionType(&deviceName, layout,
                                            &partitionType);
            if (!NT_SUCCESS(status)) {
                break;
            }

            if (partitionType == BOOTABLE_PARTITION) {
                skip = j;
            } else if (partitionType == PRIMARY_PARTITION) {
                if (!skip) {
                    skip = j;
                }
            }
        }

        for (j = 1; ; j++) {

            if (j == skip) {
                continue;
            }

            swprintf(deviceNameBuffer, L"\\Device\\Harddisk%d\\Partition%d",
                     i, j);
            RtlInitUnicodeString(&deviceName, deviceNameBuffer);

            status = HalpQueryPartitionType(&deviceName, layout,
                                            &partitionType);
            if (!NT_SUCCESS(status)) {
                break;
            }

            if (partitionType != PRIMARY_PARTITION &&
                partitionType != FT_PARTITION) {

                continue;
            }

            HalpNextDriveLetter(&deviceName, NtDeviceName, NtSystemPath, FALSE);
        }

        if (layout) {
            ExFreePool(layout);
        }
    }

    if (harddiskDerangementArray) {
        ExFreePool(harddiskDerangementArray);
    }

    for (i = 0; i < floppyCount; i++) {

        swprintf(deviceNameBuffer, L"\\Device\\Floppy%d", i);
        RtlInitUnicodeString(&deviceName, deviceNameBuffer);

        if (!HalpIsOldStyleFloppy(&deviceName)) {
            continue;
        }

        HalpNextDriveLetter(&deviceName, NtDeviceName, NtSystemPath, TRUE);
    }

    for (i = 0; i < floppyCount; i++) {

        swprintf(deviceNameBuffer, L"\\Device\\Floppy%d", i);
        RtlInitUnicodeString(&deviceName, deviceNameBuffer);

        if (HalpIsOldStyleFloppy(&deviceName)) {
            continue;
        }

        HalpNextDriveLetter(&deviceName, NtDeviceName, NtSystemPath, TRUE);
    }

    for (i = 0; i < configurationInformation->CdRomCount; i++) {

        swprintf(deviceNameBuffer, L"\\Device\\CdRom%d", i);
        RtlInitUnicodeString(&deviceName, deviceNameBuffer);

        HalpNextDriveLetter(&deviceName, NtDeviceName, NtSystemPath, TRUE);
    }

    if (!IoRemoteBootClient) {
        RtlAnsiStringToUnicodeString(&unicodeString, NtDeviceName, TRUE);
        driveLetter = HalpNextDriveLetter(&unicodeString, NULL, NULL, TRUE);
        if (driveLetter) {
            if (driveLetter != 0xFF) {
                NtSystemPath[0] = driveLetter;
            }
        } else {
            RtlInitUnicodeString(&floppyPrefix, L"\\Device\\Floppy");
            RtlInitUnicodeString(&cdromPrefix, L"\\Device\\CdRom");
            if (RtlPrefixUnicodeString(&floppyPrefix, &unicodeString, TRUE)) {
                driveLetter = 'A';
            } else if (RtlPrefixUnicodeString(&cdromPrefix, &unicodeString, TRUE)) {
                driveLetter = 'D';
            } else {
                driveLetter = 'C';
            }
            for (; driveLetter <= 'Z'; driveLetter++) {
                status = HalpSetMountLetter(&unicodeString, driveLetter);
                if (NT_SUCCESS(status)) {
                    NtSystemPath[0] = driveLetter;
                }
            }
        }
        RtlFreeUnicodeString(&unicodeString);
    }

    HalpEnableAutomaticDriveLetterAssignment();

} // end IoAssignDriveLetters()




NTSTATUS
FASTCALL
IoReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    )

/*++

Routine Description:

    This routine walks the disk reading the partition tables and creates
    an entry in the partition list buffer for each partition.

    The algorithm used by this routine is two-fold:

        1)  Read each partition table and for each valid, recognized
            partition found, to build a descriptor in a partition list.
            Extended partitions are located in order to find other
            partition tables, but no descriptors are built for these.
            The partition list is built in nonpaged pool that is allocated
            by this routine.  It is the caller's responsibility to free
            this pool after it has gathered the appropriate information
            from the list.

        2)  Read each partition table and for each and every entry, build
            a descriptor in the partition list.  Extended partitions are
            located to find each partition table on the disk, and entries
            are built for these as well.  The partition list is build in
            nonpaged pool that is allocated by this routine.  It is the
            caller's responsibility to free this pool after it has copied
            the information back to its caller.

    The first algorithm is used when the ReturnRecognizedPartitions flag
    is set.  This is used to determine how many partition device objects
    the device driver is to create, and where each lives on the drive.

    The second algorithm is used when the ReturnRecognizedPartitions flag
    is clear.  This is used to find all of the partition tables and their
    entries for a utility such as fdisk, that would like to revamp where
    the partitions live.

Arguments:

    DeviceObject - Pointer to device object for this disk.

    SectorSize - Sector size on the device.

    ReturnRecognizedPartitions - A flag indicated whether only recognized
        partition descriptors are to be returned, or whether all partition
        entries are to be returned.

    PartitionBuffer - Pointer to the pointer of the buffer in which the list
        of partition will be stored.

Return Value:

    The functional value is STATUS_SUCCESS if at least one sector table was
    read.

Notes:

    It is the responsibility of the caller to deallocate the partition list
    buffer allocated by this routine.

--*/

{
    ULONG partitionBufferSize = PARTITION_BUFFER_SIZE;
    PDRIVE_LAYOUT_INFORMATION newPartitionBuffer = NULL;

    LONG partitionTableCounter = -1;

    DISK_GEOMETRY diskGeometry;
    ULONGLONG endSector;
    ULONGLONG maxSector;
    ULONGLONG maxOffset;

    LARGE_INTEGER partitionTableOffset;
    LARGE_INTEGER volumeStartOffset;
    LARGE_INTEGER tempInt;
    BOOLEAN primaryPartitionTable;
    LONG partitionNumber;
    PUCHAR readBuffer = (PUCHAR) NULL;
    KEVENT event;

    IO_STATUS_BLOCK ioStatus;
    PIRP irp;
    PPARTITION_DESCRIPTOR partitionTableEntry;
    CCHAR partitionEntry;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG readSize;
    PPARTITION_INFORMATION partitionInfo;
    BOOLEAN foundEZHooker = FALSE;

    BOOLEAN mbrSignatureFound = FALSE;
    BOOLEAN emptyPartitionTable = TRUE;

    PAGED_CODE();

    //
    // Create the buffer that will be passed back to the driver containing
    // the list of partitions on the disk.
    //

    *PartitionBuffer = ExAllocatePoolWithTag( NonPagedPool,
                                              partitionBufferSize,
                                              'btsF' );

    if (*PartitionBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Determine the size of a read operation to ensure that at least 512
    // bytes are read.  This will guarantee that enough data is read to
    // include an entire partition table.  Note that this code assumes that
    // the actual sector size of the disk (if less than 512 bytes) is a
    // multiple of 2, a fairly reasonable assumption.
    //

    if (SectorSize >= 512) {
        readSize = SectorSize;
    } else {
        readSize = 512;
    }

    //
    // Look to see if this is an EZDrive Disk.  If it is then get the
    // real parititon table at 1.
    //

    {

        PVOID buff;

        HalExamineMBR(
            DeviceObject,
            readSize,
            (ULONG)0x55,
            &buff
            );

        if (buff) {

            foundEZHooker = TRUE;
            ExFreePool(buff);
            partitionTableOffset.QuadPart = 512;

        } else {

            partitionTableOffset.QuadPart = 0;

        }

    }

    //
    // Get the drive size so we can verify that the partition table is
    // correct.
    //

    status = HalpGetFullGeometry(DeviceObject,
                                 &diskGeometry,
                                 &maxOffset);

    if(!NT_SUCCESS(status)) {
        ExFreePool(*PartitionBuffer);
        *PartitionBuffer = NULL;
        return status;
    }

    //
    // Partition offsets need to fit on the disk or we're not going to
    // expose them.  Partition ends are generally very very sloppy so we
    // need to allow some slop.  Adding in a cylinders worth isn't enough
    // so now we'll assume that all partitions end within 2x of the real end
    // of the disk.
    //

    endSector = maxOffset;

    maxSector = maxOffset * 2;

    KdPrintEx((DPFLTR_FSTUB_ID,
               DPFLTR_TRACE_LEVEL,
               "FSTUB: MaxOffset = %#I64x, maxSector = %#I64x\n",
               maxOffset,
               maxSector));

    //
    // Indicate that the primary partition table is being read and
    // processed.
    //

    primaryPartitionTable = TRUE;

    //
    // The partitions in this volume have their start sector as 0.
    //

    volumeStartOffset.QuadPart = 0;

    //
    // Initialize the number of partitions in the list.
    //

    partitionNumber = -1;

    //
    // Allocate a buffer that will hold the reads.
    //

    readBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                        PAGE_SIZE,
                                        'btsF' );

    if (readBuffer == NULL) {
        ExFreePool( *PartitionBuffer );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Read each partition table, create an object for the partition(s)
    // it represents, and then if there is a link entry to another
    // partition table, repeat.
    //

    do {

        BOOLEAN tableIsValid;
        ULONG containerPartitionCount;

        tableIsValid = TRUE;

        //
        // Read record containing partition table.
        //
        // Create a notification event object to be used while waiting for
        // the read request to complete.
        //

        KeInitializeEvent( &event, NotificationEvent, FALSE );

        //
        // Zero out the buffer we're reading into.  In case we get back
        // STATUS_NO_DATA_DETECTED we'll be prepared.
        //

        RtlZeroMemory(readBuffer, readSize);

        irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                            DeviceObject,
                                            readBuffer,
                                            readSize,
                                            &partitionTableOffset,
                                            &event,
                                            &ioStatus );

        if (!irp) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        } else {
            PIO_STACK_LOCATION irpStack;
            irpStack = IoGetNextIrpStackLocation(irp);
            irpStack->Flags |= SL_OVERRIDE_VERIFY_VOLUME;
        }

        status = IoCallDriver( DeviceObject, irp );

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL);
            status = ioStatus.Status;
        }

        //
        // Special case - if we got a blank-check reading the sector then
        // pretend it was just successful so we can deal with superfloppies
        // where noone bothered to write anything to the non-filesystem sectors
        //

        if(status == STATUS_NO_DATA_DETECTED) {
            status = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS( status )) {
            break;
        }

        //
        // If EZDrive is hooking the MBR then we found the first partition table
        // in sector 1 rather than 0.  However that partition table is relative
        // to sector zero.  So, Even though we got it from one, reset the partition
        // offset to 0.
        //

        if (foundEZHooker && (partitionTableOffset.QuadPart == 512)) {

            partitionTableOffset.QuadPart = 0;

        }

        //
        // Check for Boot Record signature.
        //

        if (((PUSHORT) readBuffer)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {

            KdPrintEx((DPFLTR_FSTUB_ID,
                       DPFLTR_WARNING_LEVEL,
                       "FSTUB: (IoReadPartitionTable) No 0xaa55 found in partition table %d\n",
                       partitionTableCounter + 1));

            break;

        } else {
            mbrSignatureFound = TRUE;
        }

        //
        // Copy NTFT disk signature to buffer
        //

        if (partitionTableOffset.QuadPart == 0) {
            (*PartitionBuffer)->Signature =  ((PULONG) readBuffer)[PARTITION_TABLE_OFFSET/2-1];
        }

        partitionTableEntry = (PPARTITION_DESCRIPTOR) &(((PUSHORT) readBuffer)[PARTITION_TABLE_OFFSET]);

        //
        // Keep count of partition tables in case we have an extended partition;
        //

        partitionTableCounter++;

        //
        // First create the objects corresponding to the entries in this
        // table that are not link entries or are unused.
        //

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB: Partition Table %d:\n",
                   partitionTableCounter));

        for (partitionEntry = 1, containerPartitionCount = 0;
             partitionEntry <= NUM_PARTITION_TABLE_ENTRIES;
             partitionEntry++, partitionTableEntry++) {

            KdPrintEx((DPFLTR_FSTUB_ID,
                       DPFLTR_TRACE_LEVEL,
                       "Partition Entry %d,%d: type %#x %s\n",
                       partitionTableCounter,
                       partitionEntry,
                       partitionTableEntry->PartitionType,
                       (partitionTableEntry->ActiveFlag) ? "Active" : ""));

            KdPrintEx((DPFLTR_FSTUB_ID,
                       DPFLTR_TRACE_LEVEL,
                       "\tOffset %#08lx for %#08lx Sectors\n",
                       GET_STARTING_SECTOR(partitionTableEntry),
                       GET_PARTITION_LENGTH(partitionTableEntry)));

            if (partitionTableEntry->PartitionType == 0xEE) {
                FstubFixupEfiPartition (partitionTableEntry,
                                        maxOffset);
            }
            
            //
            // Do a quick pass over the entry to see if this table is valid.
            // It's only fatal if the master partition table is invalid.
            //

            if((HalpIsValidPartitionEntry(partitionTableEntry,
                                          maxOffset,
                                          maxSector) == FALSE) &&
               (partitionTableCounter == 0)) {

                tableIsValid = FALSE;
                break;

            }
            //
            // Only one container partition is allowed per table - any more
            // and it's invalid.
            //

            if(IsContainerPartition(partitionTableEntry->PartitionType)) {

                containerPartitionCount++;

                if(containerPartitionCount != 1) {

                    KdPrintEx((DPFLTR_FSTUB_ID,
                               DPFLTR_ERROR_LEVEL,
                               "FSTUB: Multiple container partitions found in "
                                   "partition table %d\n - table is invalid\n",
                               partitionTableCounter));

                    tableIsValid = FALSE;
                    break;
                }

            }

            if(emptyPartitionTable) {

                if((GET_STARTING_SECTOR(partitionTableEntry) != 0) ||
                   (GET_PARTITION_LENGTH(partitionTableEntry) != 0)) {

                    //
                    // There's a valid, non-empty partition here. The table
                    // is not empty.
                    //

                    emptyPartitionTable = FALSE;
                }
            }

            //
            // If the partition entry is not used or not recognized, skip
            // it.  Note that this is only done if the caller wanted only
            // recognized partition descriptors returned.
            //

            if (ReturnRecognizedPartitions) {

                //
                // Check if partition type is 0 (unused) or 5/f (extended).
                // The definition of recognized partitions has broadened
                // to include any partition type other than 0 or 5/f.
                //

                if ((partitionTableEntry->PartitionType == PARTITION_ENTRY_UNUSED) ||
                    IsContainerPartition(partitionTableEntry->PartitionType)) {

                    continue;
                }
            }

            //
            // Bump up to the next partition entry.
            //

            partitionNumber++;

            if (((partitionNumber * sizeof( PARTITION_INFORMATION )) +
                 sizeof( DRIVE_LAYOUT_INFORMATION )) >
                (ULONG) partitionBufferSize) {

                //
                // The partition list is too small to contain all of the
                // entries, so create a buffer that is twice as large to
                // store the partition list and copy the old buffer into
                // the new one.
                //

                newPartitionBuffer = ExAllocatePoolWithTag( NonPagedPool,
                                                            partitionBufferSize << 1,
                                                            'btsF' );

                if (newPartitionBuffer == NULL) {
                    --partitionNumber;
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlCopyMemory( newPartitionBuffer,
                               *PartitionBuffer,
                               partitionBufferSize );

                ExFreePool( *PartitionBuffer );

                //
                // Reassign the new buffer to the return parameter and
                // reset the size of the buffer.
                //

                *PartitionBuffer = newPartitionBuffer;
                partitionBufferSize <<= 1;
            }

            //
            // Describe this partition table entry in the partition list
            // entry being built for the driver.  This includes writing
            // the partition type, starting offset of the partition, and
            // the length of the partition.
            //

            partitionInfo = &(*PartitionBuffer)->PartitionEntry[partitionNumber];

            partitionInfo->PartitionType = partitionTableEntry->PartitionType;

            partitionInfo->RewritePartition = FALSE;

            if (partitionTableEntry->PartitionType != PARTITION_ENTRY_UNUSED) {
                LONGLONG startOffset;

                partitionInfo->BootIndicator =
                    partitionTableEntry->ActiveFlag & PARTITION_ACTIVE_FLAG ?
                        (BOOLEAN) TRUE : (BOOLEAN) FALSE;

                if (IsContainerPartition(partitionTableEntry->PartitionType)) {
                    partitionInfo->RecognizedPartition = FALSE;
                    startOffset = volumeStartOffset.QuadPart;
                } else {
                    partitionInfo->RecognizedPartition = TRUE;
                    startOffset = partitionTableOffset.QuadPart;
                }

                partitionInfo->StartingOffset.QuadPart = startOffset +
                    UInt32x32To64(GET_STARTING_SECTOR(partitionTableEntry),
                                  SectorSize);
                tempInt.QuadPart = (partitionInfo->StartingOffset.QuadPart -
                                   startOffset) / SectorSize;
                partitionInfo->HiddenSectors = tempInt.LowPart;

                partitionInfo->PartitionLength.QuadPart =
                    UInt32x32To64(GET_PARTITION_LENGTH(partitionTableEntry),
                                  SectorSize);

            } else {

                //
                // Partitions that are not used do not describe any part
                // of the disk.  These types are recorded in the partition
                // list buffer when the caller requested all of the entries
                // be returned.  Simply zero out the remaining fields in
                // the entry.
                //

                partitionInfo->BootIndicator = FALSE;
                partitionInfo->RecognizedPartition = FALSE;
                partitionInfo->StartingOffset.QuadPart = 0;
                partitionInfo->PartitionLength.QuadPart = 0;
                partitionInfo->HiddenSectors = 0;
            }

        }

        KdPrintEx((DPFLTR_FSTUB_ID, DPFLTR_TRACE_LEVEL, "\n"));

        //
        // If an error occurred, leave the routine now.
        //

        if (!NT_SUCCESS( status )) {
            break;
        }

        if(tableIsValid == FALSE) {

            //
            // Invalidate this partition table and stop looking for new ones.
            // we'll build the partition list based on the ones we found
            // previously.
            //

            partitionTableCounter--;
            break;
        }

        //
        // Now check to see if there are any link entries in this table,
        // and if so, set up the sector address of the next partition table.
        // There can only be one link entry in each partition table, and it
        // will point to the next table.
        //

        partitionTableEntry = (PPARTITION_DESCRIPTOR) &(((PUSHORT) readBuffer)[PARTITION_TABLE_OFFSET]);

        //
        // Assume that the link entry is empty.
        //

        partitionTableOffset.QuadPart = 0;

        for (partitionEntry = 1;
             partitionEntry <= NUM_PARTITION_TABLE_ENTRIES;
             partitionEntry++, partitionTableEntry++) {

            if (IsContainerPartition(partitionTableEntry->PartitionType)) {

                //
                // Obtain the address of the next partition table on the
                // disk.  This is the number of hidden sectors added to
                // the beginning of the extended partition (in the case of
                // logical drives), since all logical drives are relative
                // to the extended partition.  The VolumeStartSector will
                // be zero if this is the primary parition table.
                //

                partitionTableOffset.QuadPart = volumeStartOffset.QuadPart +
                    UInt32x32To64(GET_STARTING_SECTOR(partitionTableEntry),
                                  SectorSize);

                //
                // Set the VolumeStartSector to be the begining of the
                // second partition (extended partition) because all of
                // the offsets to the partition tables of the logical drives
                // are relative to this extended partition.
                //

                if (primaryPartitionTable) {
                    volumeStartOffset = partitionTableOffset;
                }

                //
                // Update the maximum sector to be the end of the container
                // partition.
                //

                maxSector = GET_PARTITION_LENGTH(partitionTableEntry);

                KdPrintEx((DPFLTR_FSTUB_ID,
                           DPFLTR_TRACE_LEVEL,
                           "FSTUB: MaxSector now = %#08lx\n",
                           maxSector));

                //
                // There is only ever one link entry per partition table,
                // exit the loop once it has been found.
                //

                break;
            }
        }


        //
        // All the other partitions will be logical drives.
        //

        primaryPartitionTable = FALSE;


    } while (partitionTableOffset.HighPart | partitionTableOffset.LowPart);

    //
    // Detect super-floppy media attempt #1.
    // If the media is removable and has an 0xaa55 signature on it and
    // is empty then check to see if we can recognize the BPB.  If we recognize
    // a jump-byte at the beginning of the media then it's a super floppy.  If
    // we don't then it's an unpartitioned disk.
    //

    if((diskGeometry.MediaType == RemovableMedia) &&
       (partitionTableCounter == 0) &&
       (mbrSignatureFound == TRUE) &&
       (emptyPartitionTable == TRUE)) {

        PBOOT_SECTOR_INFO bootSector = (PBOOT_SECTOR_INFO) readBuffer;

        if((bootSector->JumpByte[0] == 0xeb) ||
           (bootSector->JumpByte[0] == 0xe9)) {

            //
            // We've got a superfloppy of some sort.
            //

            KdPrintEx((DPFLTR_FSTUB_ID,
                       DPFLTR_TRACE_LEVEL,
                       "FSTUB: Jump byte %#x found "
                           "along with empty partition table - disk is a "
                           "super floppy and has no valid MBR\n",
                       bootSector->JumpByte));

            partitionTableCounter = -1;
        }
    }

    //
    // If the partition table count is still -1 then we didn't find any
    // valid partition records.  In this case we'll build a partition list
    // that contiains one partition spanning the entire disk.
    //

    if(partitionTableCounter == -1) {

        if((mbrSignatureFound == TRUE) ||
           (diskGeometry.MediaType == RemovableMedia)) {

            //
            // Either we found a signature but the partition layout was
            // invalid (for all disks) or we didn't find a signature but this
            // is a removable disk.  Either of these two cases makes a
            // superfloppy.
            //

            KdPrintEx((DPFLTR_FSTUB_ID,
                       DPFLTR_TRACE_LEVEL,
                       "FSTUB: Drive %#p has no valid MBR. "
                           "Make it into a super-floppy\n", DeviceObject));

            KdPrintEx((DPFLTR_FSTUB_ID,
                       DPFLTR_TRACE_LEVEL,
                       "FSTUB: Drive has %#08lx sectors "
                           "and is %#016I64x bytes large\n",
                       endSector,
                       endSector * diskGeometry.BytesPerSector));

            if (endSector > 0) {

                partitionInfo = &(*PartitionBuffer)->PartitionEntry[0];

                partitionInfo->RewritePartition = FALSE;
                partitionInfo->RecognizedPartition = TRUE;
                partitionInfo->PartitionType = PARTITION_FAT_16;
                partitionInfo->BootIndicator = FALSE;

                partitionInfo->HiddenSectors = 0;

                partitionInfo->StartingOffset.QuadPart = 0;

                partitionInfo->PartitionLength.QuadPart =
                    (endSector * diskGeometry.BytesPerSector);

                (*PartitionBuffer)->Signature = 1;

                partitionNumber = 0;
            }
        } else {

            //
            // We found no partitions.  Make sure the partition count is -1
            // so that we setup a zeroed-out partition table below.
            //

            partitionNumber = -1;
        }
    }

    //
    // Fill in the first field in the PartitionBuffer. This field indicates how
    // many partition entries there are in the PartitionBuffer.
    //

    (*PartitionBuffer)->PartitionCount = ++partitionNumber;

    if (!partitionNumber) {

        //
        // Zero out disk signature.
        //

        (*PartitionBuffer)->Signature = 0;
    }

    //
    // Deallocate read buffer if it was allocated it.
    //

    if (readBuffer != NULL) {
        ExFreePool( readBuffer );
    }

    if (!NT_SUCCESS(status)) {
        ExFreePool(*PartitionBuffer);
        *PartitionBuffer = NULL;
    }

#if DBG
    if (NT_SUCCESS(status)) {
        FstubDbgPrintDriveLayout(*PartitionBuffer);
    }
#endif
    return status;
}

NTSTATUS
FASTCALL
IoSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    )

/*++

Routine Description:

    This routine is invoked when a disk device driver is asked to set the
    partition type in a partition table entry via an I/O control code.  This
    control code is generally issued by the format utility just after it
    has formatted the partition.  The format utility performs the I/O control
    function on the partition and the driver passes the address of the base
    physical device object and the number of the partition associated with
    the device object that the format utility has open.  If this routine
    returns success, then the disk driver should updates its notion of the
    partition type for this partition in its device extension.

Arguments:

    DeviceObject - Pointer to the base physical device object for the device
        on which the partition type is to be set.

    SectorSize - Supplies the size of a sector on the disk in bytes.

    PartitionNumber - Specifies the partition number on the device whose
        partition type is to be changed.

    PartitionType - Specifies the new type for the partition.

Return Value:

    The function value is the final status of the operation.

Notes:

    This routine is synchronous.  Therefore, it MUST be invoked by the disk
    driver's dispatch routine, or by a disk driver's thread.  Likewise, all
    users, FSP threads, etc., must be prepared to enter a wait state when
    issuing the I/O control code to set the partition type for the device.

    Note also that this routine assumes that the partition number passed
    in by the disk driver actually exists since the driver itself supplies
    this parameter.

    Finally, note that this routine may NOT be invoked at APC_LEVEL.  It
    must be invoked at PASSIVE_LEVEL.  This is due to the fact that this
    routine uses a kernel event object to synchronize I/O completion on the
    device.  The event cannot be set to the signaled state without queueing
    the I/O system's special kernel APC routine for I/O completion and
    executing it.  (This rules is a bit esoteric since it only holds true
    if the device driver returns something other than STATUS_PENDING, which
    it will probably never do.)

--*/

{

#define GET_STARTING_SECTOR( p ) (                  \
        (ULONG) (p->StartingSectorLsb0) +           \
        (ULONG) (p->StartingSectorLsb1 << 8) +      \
        (ULONG) (p->StartingSectorMsb0 << 16) +     \
        (ULONG) (p->StartingSectorMsb1 << 24) )

    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    LARGE_INTEGER partitionTableOffset;
    LARGE_INTEGER volumeStartOffset;
    PUCHAR buffer = (PUCHAR) NULL;
    ULONG transferSize;
    ULONG partitionNumber;
    ULONG partitionEntry;
    PPARTITION_DESCRIPTOR partitionTableEntry;
    BOOLEAN primaryPartitionTable;
    BOOLEAN foundEZHooker = FALSE;

    PAGED_CODE();

    //
    // Begin by determining the size of the buffer required to read and write
    // the partition information to/from the disk.  This is done to ensure
    // that at least 512 bytes are read, thereby guaranteeing that enough data
    // is read to include an entire partition table.  Note that this code
    // assumes that the actual sector size of the disk (if less than 512
    // bytes) is a multiple of 2, a
    // fairly reasonable assumption.
    //

    if (SectorSize >= 512) {
        transferSize = SectorSize;
    } else {
        transferSize = 512;
    }


    //
    // Look to see if this is an EZDrive Disk.  If it is then get the
    // real parititon table at 1.
    //

    {

        PVOID buff;

        HalExamineMBR(
            DeviceObject,
            transferSize,
            (ULONG)0x55,
            &buff
            );

        if (buff) {

            foundEZHooker = TRUE;
            ExFreePool(buff);
            partitionTableOffset.QuadPart = 512;

        } else {

            partitionTableOffset.QuadPart = 0;

        }

    }


    //
    // The partitions in this primary partition have their start sector 0.
    //

    volumeStartOffset.QuadPart = 0;

    //
    // Indicate that the table being read and processed is the primary partition
    // table.
    //

    primaryPartitionTable = TRUE;

    //
    // Initialize the number of partitions found thus far.
    //

    partitionNumber = 0;

    //
    // Allocate a buffer that will hold the read/write data.
    //

    buffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned, PAGE_SIZE, 'btsF');
    if (buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize a kernel event to use in synchronizing device requests
    // with I/O completion.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    //
    // Read each partition table scanning for the partition table entry that
    // the caller wishes to modify.
    //

    do {

        //
        // Read the record containing the partition table.
        //

        (VOID) KeResetEvent( &event );

        irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                            DeviceObject,
                                            buffer,
                                            transferSize,
                                            &partitionTableOffset,
                                            &event,
                                            &ioStatus );

        if (!irp) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        } else {
            PIO_STACK_LOCATION irpStack;
            irpStack = IoGetNextIrpStackLocation(irp);
            irpStack->Flags |= SL_OVERRIDE_VERIFY_VOLUME;
        }

        status = IoCallDriver( DeviceObject, irp );

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS( status )) {
            break;
        }

        //
        // If EZDrive is hooking the MBR then we found the first partition table
        // in sector 1 rather than 0.  However that partition table is relative
        // to sector zero.  So, Even though we got it from one, reset the partition
        // offset to 0.
        //

        if (foundEZHooker && (partitionTableOffset.QuadPart == 512)) {

            partitionTableOffset.QuadPart = 0;

        }

        //
        // Check for a valid Boot Record signature in the partition table
        // record.
        //

        if (((PUSHORT) buffer)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
            status = STATUS_BAD_MASTER_BOOT_RECORD;
            break;
        }

        partitionTableEntry = (PPARTITION_DESCRIPTOR) &(((PUSHORT) buffer)[PARTITION_TABLE_OFFSET]);

        //
        // Scan the partition entries in this partition table to determine if
        // any of the entries are the desired entry.  Each entry in each
        // table must be scanned in the same order as in IoReadPartitionTable
        // so that the partition table entry cooresponding to the driver's
        // notion of the partition number can be located.
        //

        for (partitionEntry = 1;
            partitionEntry <= NUM_PARTITION_TABLE_ENTRIES;
            partitionEntry++, partitionTableEntry++) {


            //
            // If the partition entry is empty or for an extended, skip it.
            //

            if ((partitionTableEntry->PartitionType == PARTITION_ENTRY_UNUSED) ||
                IsContainerPartition(partitionTableEntry->PartitionType)) {
                continue;
            }

            //
            // A valid partition entry that is recognized has been located.
            // Bump the count and check to see if this entry is the desired
            // entry.
            //

            partitionNumber++;

            if (partitionNumber == PartitionNumber) {

                //
                // This is the desired partition that is to be changed.  Simply
                // overwrite the partition type and write the entire partition
                // buffer back out to the disk.
                //

                partitionTableEntry->PartitionType = (UCHAR) PartitionType;

                (VOID) KeResetEvent( &event );

                irp = IoBuildSynchronousFsdRequest( IRP_MJ_WRITE,
                                                    DeviceObject,
                                                    buffer,
                                                    transferSize,
                                                    &partitionTableOffset,
                                                    &event,
                                                    &ioStatus );

                if (!irp) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                } else {
                    PIO_STACK_LOCATION irpStack;
                    irpStack = IoGetNextIrpStackLocation(irp);
                    irpStack->Flags |= SL_OVERRIDE_VERIFY_VOLUME;
                }

                status = IoCallDriver( DeviceObject, irp );

                if (status == STATUS_PENDING) {
                    (VOID) KeWaitForSingleObject( &event,
                                                  Executive,
                                                  KernelMode,
                                                  FALSE,
                                                  (PLARGE_INTEGER) NULL );
                    status = ioStatus.Status;
                }

                break;
            }
        }

        //
        // If all of the entries in the current buffer were scanned and the
        // desired entry was not found, then continue.  Otherwise, leave the
        // routine.
        //

        if (partitionEntry <= NUM_PARTITION_TABLE_ENTRIES) {
            break;
        }

        //
        // Now scan the current buffer to locate an extended partition entry
        // in the table so that its partition information can be read.  There
        // can only be one extended partition entry in each partition table,
        // and it will point to the next table.
        //

        partitionTableEntry = (PPARTITION_DESCRIPTOR) &(((PUSHORT) buffer)[PARTITION_TABLE_OFFSET]);

        for (partitionEntry = 1;
            partitionEntry <= NUM_PARTITION_TABLE_ENTRIES;
            partitionEntry++, partitionTableEntry++) {

            if (IsContainerPartition(partitionTableEntry->PartitionType)) {

                //
                // Obtain the address of the next partition table on the disk.
                // This is the number of hidden sectors added to the beginning
                // of the extended partition (in the case of logical drives),
                // since all logical drives are relative to the extended
                // partition.  The starting offset of the volume will be zero
                // if this is the primary partition table.
                //

                partitionTableOffset.QuadPart = volumeStartOffset.QuadPart +
                    UInt32x32To64(GET_STARTING_SECTOR(partitionTableEntry),
                                  SectorSize);

                //
                // Set the starting offset of the volume to be the beginning of
                // the second partition (the extended partition) because all of
                // the offsets to the partition tables of the logical drives
                // are relative to this extended partition.
                //

                if (primaryPartitionTable) {
                    volumeStartOffset = partitionTableOffset;
                }

                break;
            }
        }

        //
        // Ensure that a partition entry was located that was an extended
        // partition, otherwise the desired partition will never be found.
        //

        if (partitionEntry > NUM_PARTITION_TABLE_ENTRIES) {
            status = STATUS_BAD_MASTER_BOOT_RECORD;
            break;
        }

        //
        // All the other partitions will be logical drives.
        //

        primaryPartitionTable = FALSE;

    } while (partitionNumber < PartitionNumber);

    //
    // If a data buffer was successfully allocated, deallocate it now.
    //

    if (buffer != NULL) {
        ExFreePool( buffer );
    }

    return status;
}

NTSTATUS
FASTCALL
IoWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    )

/*++

Routine Description:

    This routine walks the disk writing the partition tables from
    the entries in the partition list buffer for each partition.

    Applications that create and delete partitions should issue a
    IoReadPartitionTable call with the 'return recognized partitions'
    boolean set to false to get a full description of the system.

    Then the drive layout structure can be modified by the application to
    reflect the new configuration of the disk and then is written back
    to the disk using this routine.

Arguments:

    DeviceObject - Pointer to device object for this disk.

    SectorSize - Sector size on the device.

    SectorsPerTrack - Track size on the device.

    NumberOfHeads - Same as tracks per cylinder.

    PartitionBuffer - Pointer drive layout buffer.

Return Value:

    The functional value is STATUS_SUCCESS if all writes are completed
    without error.

--*/

{

//
// This macro has the effect of Bit = log2(Data)
//

#define WHICH_BIT(Data, Bit) {                      \
    for (Bit = 0; Bit < 32; Bit++) {                \
        if ((Data >> Bit) == 1) {                   \
            break;                                  \
        }                                           \
    }                                               \
}

    ULONG writeSize;
    PUSHORT writeBuffer = NULL;
    PPTE partitionEntry;
    PPARTITION_TABLE partitionTable;
    CCHAR shiftCount;
    LARGE_INTEGER partitionTableOffset;
    LARGE_INTEGER nextRecordOffset;
    ULONG partitionTableCount;
    ULONG partitionEntryCount;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIRP irp;
    BOOLEAN rewritePartition = FALSE;
    NTSTATUS status = STATUS_SUCCESS;
    LARGE_INTEGER tempInt;
    BOOLEAN foundEZHooker = FALSE;
    ULONG conventionalCylinders;
    LONGLONG diskSize;

    BOOLEAN isSuperFloppy = FALSE;

    //
    // Cast to a structure that is easier to use.
    //

    PDISK_LAYOUT diskLayout = (PDISK_LAYOUT) PartitionBuffer;

    //
    // Ensure that no one is calling this function illegally.
    //

    PAGED_CODE();

    FstubDbgPrintDriveLayout ( PartitionBuffer );

    //
    // Determine the size of a write operation to ensure that at least 512
    // bytes are written.  This will guarantee that enough data is written to
    // include an entire partition table.  Note that this code assumes that
    // the actual sector size of the disk (if less than 512 bytes) is a
    // multiple of 2, a fairly reasonable assumption.
    //

    if (SectorSize >= 512) {
        writeSize = SectorSize;
    } else {
        writeSize = 512;
    }

    xHalGetPartialGeometry( DeviceObject,
                            &conventionalCylinders,
                            &diskSize );

    //
    // Look to see if this is an EZDrive Disk.  If it is then get the
    // real partititon table at 1.
    //

    {

        PVOID buff;

        HalExamineMBR(
            DeviceObject,
            writeSize,
            (ULONG)0x55,
            &buff
            );

        if (buff) {

            foundEZHooker = TRUE;
            ExFreePool(buff);
            partitionTableOffset.QuadPart = 512;

        } else {

            partitionTableOffset.QuadPart = 0;

        }

    }

    //
    // Initialize starting variables.
    //

    nextRecordOffset.QuadPart = 0;

    //
    // Calculate shift count for converting between byte and sector.
    //

    WHICH_BIT( SectorSize, shiftCount );

    //
    // Check to see if this device is partitioned (or is being partitioned)
    // as a floppy.  Floppys have a single partititon with hidden sector count
    // and partition offset equal to zero.  If the disk is being partitioned
    // like this then we need to be sure not to write an MBR signature or
    // an NTFT signature to the media.
    //
    // NOTE: this is only to catch ourself when someone tries to write the
    // existing partition table back to disk.  Any changes to the table will
    // result in a real MBR being written out.
    //

    if(PartitionBuffer->PartitionCount == 1) {

        PPARTITION_INFORMATION partitionEntry = PartitionBuffer->PartitionEntry;

        if((partitionEntry->StartingOffset.QuadPart == 0) &&
           (partitionEntry->HiddenSectors == 0)) {

            isSuperFloppy = TRUE;

            //
            // This would indeed appear to be an attempt to format a floppy.
            // Make sure the other parameters match the defaut values we
            // provide in ReadParititonTable.  If they don't then fail
            // the write operation.
            //

            if((partitionEntry->PartitionNumber != 0) ||
               (partitionEntry->PartitionType != PARTITION_FAT_16) ||
               (partitionEntry->BootIndicator == TRUE)) {

                return STATUS_INVALID_PARAMETER;
            }

            if(partitionEntry->RewritePartition == TRUE) {
                rewritePartition = TRUE;
            }

            foundEZHooker = FALSE;
        }
    }

    //
    // Convert partition count to partition table or boot sector count.
    //

    diskLayout->TableCount =
        (PartitionBuffer->PartitionCount +
        NUM_PARTITION_TABLE_ENTRIES - 1) /
        NUM_PARTITION_TABLE_ENTRIES;

    //
    // Allocate a buffer for the sector writes.
    //

    writeBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned, PAGE_SIZE, 'btsF');

    if (writeBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Point to the partition table entries in write buffer.
    //

    partitionEntry = (PPTE) &writeBuffer[PARTITION_TABLE_OFFSET];

    for (partitionTableCount = 0;
         partitionTableCount < diskLayout->TableCount;
         partitionTableCount++) {

        UCHAR   partitionType;

        //
        // the first partition table is in the mbr (physical sector 0).
        // other partition tables are in ebr's within the extended partition.
        //

        BOOLEAN mbr = (BOOLEAN) (!partitionTableCount);
        LARGE_INTEGER extendedPartitionOffset;

        //
        // Read the boot record that's already there into the write buffer
        // and save its boot code area if the signature is valid.  This way
        // we don't clobber any boot code that might be there already.
        //

        KeInitializeEvent( &event, NotificationEvent, FALSE );

        irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                        DeviceObject,
                                        writeBuffer,
                                        writeSize,
                                        &partitionTableOffset,
                                        &event,
                                        &ioStatus );

        if (!irp) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        } else {
            PIO_STACK_LOCATION irpStack;
            irpStack = IoGetNextIrpStackLocation(irp);
            irpStack->Flags |= SL_OVERRIDE_VERIFY_VOLUME;
        }

        status = IoCallDriver( DeviceObject, irp );

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL);
            status = ioStatus.Status;
        }

        if (!NT_SUCCESS( status )) {
            break;
        }

        //
        // If EZDrive is hooking the MBR then we found the first partition table
        // in sector 1 rather than 0.  However that partition table is relative
        // to sector zero.  So, Even though we got it from one, reset the partition
        // offset to 0.
        //

        if (foundEZHooker && (partitionTableOffset.QuadPart == 512)) {

            partitionTableOffset.QuadPart = 0;

        }

        if(isSuperFloppy == FALSE) {

            //
            // Write signature to last word of boot sector.
            //

            writeBuffer[BOOT_SIGNATURE_OFFSET] = BOOT_RECORD_SIGNATURE;

            //
            // Write NTFT disk signature if it changed and this is the MBR.
            //

            rewritePartition = FALSE;
            if (partitionTableOffset.QuadPart == 0) {

                if (((PULONG)writeBuffer)[PARTITION_TABLE_OFFSET/2-1] !=
                    PartitionBuffer->Signature) {

                    ((PULONG) writeBuffer)[PARTITION_TABLE_OFFSET/2-1] =
                        PartitionBuffer->Signature;
                    rewritePartition = TRUE;
                }
            }

            //
            // Get pointer to first partition table.
            //

            partitionTable = &diskLayout->PartitionTable[partitionTableCount];

            //
            // Walk table to determine whether this boot record has changed
            // and update partition table in write buffer in case it needs
            // to be written out to disk.
            //

            for (partitionEntryCount = 0;
                 partitionEntryCount < NUM_PARTITION_TABLE_ENTRIES;
                 partitionEntryCount++) {

                partitionType =
                        partitionTable->PartitionEntry[partitionEntryCount].PartitionType;

                //
                // If the rewrite ISN'T true then copy then just leave the data
                // alone that is in the on-disk table.
                //

                if (partitionTable->PartitionEntry[partitionEntryCount].RewritePartition) {

                    //
                    // This boot record needs to be written back to disk.
                    //

                    rewritePartition = TRUE;

                    //
                    // Copy partition type from user buffer to write buffer.
                    //

                    partitionEntry[partitionEntryCount].PartitionType =
                        partitionTable->PartitionEntry[partitionEntryCount].PartitionType;

                    //
                    // Copy the partition active flag.
                    //

                    partitionEntry[partitionEntryCount].ActiveFlag =
                        partitionTable->PartitionEntry[partitionEntryCount].BootIndicator ?
                        (UCHAR) PARTITION_ACTIVE_FLAG : (UCHAR) 0;

                    if (partitionType != PARTITION_ENTRY_UNUSED) {

                        LARGE_INTEGER sectorOffset;

                        //
                        // Calculate partition offset.
                        // If in the mbr or the entry is not a link entry, partition offset
                        // is sectors past last boot record.  Otherwise (not in the mbr and
                        // entry is a link entry), partition offset is sectors past start
                        // of extended partition.
                        //

                        if (mbr || !IsContainerPartition(partitionType)) {
                            tempInt.QuadPart = partitionTableOffset.QuadPart;
                        } else {
                            tempInt.QuadPart = extendedPartitionOffset.QuadPart;
                        }

                        sectorOffset.QuadPart =
                            partitionTable->PartitionEntry[partitionEntryCount].StartingOffset.QuadPart -
                            tempInt.QuadPart;

                        tempInt.QuadPart = sectorOffset.QuadPart >> shiftCount;
                        partitionEntry[partitionEntryCount].StartingSector = tempInt.LowPart;

                        //
                        // Calculate partition length.
                        //

                        tempInt.QuadPart = partitionTable->PartitionEntry[partitionEntryCount].PartitionLength.QuadPart >> shiftCount;
                        partitionEntry[partitionEntryCount].PartitionLength = tempInt.LowPart;

                        //
                        // Fill in CHS values
                        //

                        HalpCalculateChsValues(
                            &partitionTable->PartitionEntry[partitionEntryCount].StartingOffset,
                            &partitionTable->PartitionEntry[partitionEntryCount].PartitionLength,
                            shiftCount,
                            SectorsPerTrack,
                            NumberOfHeads,
                            conventionalCylinders,
                            (PPARTITION_DESCRIPTOR) &partitionEntry[partitionEntryCount]);

                    } else {

                        //
                        // Zero out partition entry fields in case an entry
                        // was deleted.
                        //

                        partitionEntry[partitionEntryCount].StartingSector = 0;
                        partitionEntry[partitionEntryCount].PartitionLength = 0;
                        partitionEntry[partitionEntryCount].StartingTrack = 0;
                        partitionEntry[partitionEntryCount].EndingTrack = 0;
                        partitionEntry[partitionEntryCount].StartingCylinder = 0;
                        partitionEntry[partitionEntryCount].EndingCylinder = 0;
                    }

                }

                if (IsContainerPartition(partitionType)) {

                    //
                    // Save next record offset.
                    //

                    nextRecordOffset =
                        partitionTable->PartitionEntry[partitionEntryCount].StartingOffset;
                }

            } // end for partitionEntryCount ...

        }

        if (rewritePartition == TRUE) {

            rewritePartition = FALSE;

            //
            // Create a notification event object to be used while waiting for
            // the write request to complete.
            //

            KeInitializeEvent( &event, NotificationEvent, FALSE );

            if (foundEZHooker && (partitionTableOffset.QuadPart == 0)) {

                partitionTableOffset.QuadPart = 512;

            }
            irp = IoBuildSynchronousFsdRequest( IRP_MJ_WRITE,
                                            DeviceObject,
                                            writeBuffer,
                                            writeSize,
                                            &partitionTableOffset,
                                            &event,
                                            &ioStatus );

            if (!irp) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            } else {
                PIO_STACK_LOCATION irpStack;
                irpStack = IoGetNextIrpStackLocation(irp);
                irpStack->Flags |= SL_OVERRIDE_VERIFY_VOLUME;
            }

            status = IoCallDriver( DeviceObject, irp );

            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL);
                status = ioStatus.Status;
            }

            if (!NT_SUCCESS( status )) {
                break;
            }


            if (foundEZHooker && (partitionTableOffset.QuadPart == 512)) {

                partitionTableOffset.QuadPart = 0;

            }

        } // end if (reWrite ...

        //
        // Update partitionTableOffset to next boot record offset
        //

        partitionTableOffset = nextRecordOffset;
        if(mbr) {
            extendedPartitionOffset = nextRecordOffset;
        }

    } // end for partitionTableCount ...

    //
    // Deallocate write buffer if it was allocated it.
    //

    if (writeBuffer != NULL) {
        ExFreePool( writeBuffer );
    }

    return status;
}



VOID
FstubFixupEfiPartition(
    IN PPARTITION_DESCRIPTOR Entry,
    IN ULONGLONG MaxSector
    )
/*++

Routine Description:

    Protective GPT partition entries can have invalid sizes. The EFI
    standard explicitly allows this. For these partitions, fixup
    the length so it doesn't go past the end of the disk.

Arguments:

    Entry - Supplies the partition entry to modify.

    MaxSector - Supplies the maximum valid sector.

Return Value:

    NTSTATUS code

--*/
{
    ULONGLONG endingSector;
    PPTE partitionEntry;

    PAGED_CODE();

    partitionEntry = (PPTE) Entry;

    endingSector = partitionEntry->StartingSector;
    endingSector += partitionEntry->PartitionLength;
    
    if (endingSector > MaxSector) {
        partitionEntry->PartitionLength =
            (ULONG)(MaxSector - partitionEntry->StartingSector);
    }
}
    
    

BOOLEAN
HalpIsValidPartitionEntry(
    PPARTITION_DESCRIPTOR Entry,
    ULONGLONG MaxOffset,
    ULONGLONG MaxSector
    )
{
    ULONGLONG endingSector;

    PAGED_CODE();

    if(Entry->PartitionType == PARTITION_ENTRY_UNUSED) {

        //
        // Unused partition entries are always valid.
        //

        return TRUE;

    }

    //
    // Container partition entries and normal partition entries are valid iff
    // the partition they describe can possibly fit on the disk.  We add
    // the base sector, the sector offset of the partition and the partition
    // length.  If they exceed the sector count then this partition entry
    // is considered invalid.
    //

    //
    // Do this in two steps to avoid 32-bit truncation.
    //
    
    endingSector = GET_STARTING_SECTOR(Entry);
    endingSector += GET_PARTITION_LENGTH(Entry);

    if(endingSector > MaxSector) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB: entry is invalid\n"));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB:     offset %#08lx\n",
                   GET_STARTING_SECTOR(Entry)));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB:     length %#08lx\n",
                   GET_PARTITION_LENGTH(Entry)));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB:     end %#I64x\n",
                   endingSector));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB:     max %#I64x\n",
                   MaxSector));

        return FALSE;

    } else if(GET_STARTING_SECTOR(Entry) > MaxOffset) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB: entry is invalid\n"));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB:    offset %#08lx\n",
                   GET_STARTING_SECTOR(Entry)));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB:    length %#08lx\n",
                   GET_PARTITION_LENGTH(Entry)));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB:    end %#I64x\n",
                   endingSector));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_TRACE_LEVEL,
                   "FSTUB:    maxOffset %#I64x\n",
                   MaxOffset));

        return FALSE;
    }

    return TRUE;
}


NTSTATUS
HalpGetFullGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDISK_GEOMETRY Geometry,
    OUT PULONGLONG RealSectorCount
    )

/*++

Routine Description:

    We need this routine to get the number of cylinders that the disk driver
    thinks is on the drive.  We will need this to calculate CHS values
    when we fill in the partition table entries.

Arguments:

    DeviceObject - The device object describing the entire drive.

    Geometry - The geometry of the drive

    RealSectorCount - the actual number of sectors reported by the drive (
                      this may be less than the size computed by the geometry)

Return Value:

    None.

--*/

{
    PIRP localIrp;
    IO_STATUS_BLOCK iosb;
    PKEVENT eventPtr;
    NTSTATUS status;

    PAGED_CODE();

    eventPtr = ExAllocatePoolWithTag(
                   NonPagedPool,
                   sizeof(KEVENT),
                   'btsF'
                   );

    if (!eventPtr) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(
        eventPtr,
        NotificationEvent,
        FALSE
        );

    localIrp = IoBuildDeviceIoControlRequest(
                   IOCTL_DISK_GET_DRIVE_GEOMETRY,
                   DeviceObject,
                   NULL,
                   0UL,
                   Geometry,
                   sizeof(DISK_GEOMETRY),
                   FALSE,
                   eventPtr,
                   &iosb
                   );

    if (!localIrp) {
        ExFreePool(eventPtr);
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Call the lower level driver, wait for the opertion
    // to finish.
    //

    status = IoCallDriver(
                 DeviceObject,
                 localIrp
                 );

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject(
                   eventPtr,
                   Executive,
                   KernelMode,
                   FALSE,
                   (PLARGE_INTEGER) NULL
                   );
        status = iosb.Status;
    }

    KeClearEvent (eventPtr);
    
    if(NT_SUCCESS(status)) {

        PARTITION_INFORMATION partitionInfo;

        localIrp = IoBuildDeviceIoControlRequest(
                       IOCTL_DISK_GET_PARTITION_INFO,
                       DeviceObject,
                       NULL,
                       0UL,
                       &partitionInfo,
                       sizeof(PARTITION_INFORMATION),
                       FALSE,
                       eventPtr,
                       &iosb
                       );

        if (!localIrp) {
            ExFreePool(eventPtr);
            return STATUS_INSUFFICIENT_RESOURCES;
        }


        //
        // Call the lower level driver, wait for the opertion
        // to finish.
        //

        status = IoCallDriver(
                     DeviceObject,
                     localIrp
                     );

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject(
                       eventPtr,
                       Executive,
                       KernelMode,
                       FALSE,
                       (PLARGE_INTEGER) NULL
                       );
            status = iosb.Status;
        }

        if(NT_SUCCESS(status)) {
            *RealSectorCount = (partitionInfo.PartitionLength.QuadPart /
                                Geometry->BytesPerSector);
        }
    }

    ExFreePool(eventPtr);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fstub\ex.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ex.c

Abstract:

    Extended routines for reading and writing new partition table types like
    EFI partitioned disks.

    The following routines are exported from this file:

        IoCreateDisk - Initialize an empty disk.

        IoWritePartitionTableEx - Write a partition table for either a
                legacy AT-style disk or an EFI partitioned disk.

        IoReadPartitionTableEx - Read the partition table for a disk.

        IoSetPartitionInformation - Set information for a specific
                partition.

Author:

    Matthew D Hendel (math) 07-Sept-1999

Revision History:

--*/


#include <ntos.h>
#include <zwapi.h>
#include <hal.h>
#include <ntdddisk.h>
#include <ntddft.h>
#include <setupblk.h>
#include <stdio.h>

#include "fstub.h"
#include "efi.h"
#include "ex.h"
#include "haldisp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IoCreateDisk)
#pragma alloc_text(PAGE, IoReadPartitionTableEx)
#pragma alloc_text(PAGE, IoWritePartitionTableEx)
#pragma alloc_text(PAGE, IoSetPartitionInformationEx)
#pragma alloc_text(PAGE, IoUpdateDiskGeometry)
#pragma alloc_text(PAGE, IoVerifyPartitionTable)

#pragma alloc_text(PAGE, FstubSetPartitionInformationEFI)
#pragma alloc_text(PAGE, FstubReadPartitionTableMBR)
#pragma alloc_text(PAGE, FstubDetectPartitionStyle)
#pragma alloc_text(PAGE, FstubGetDiskGeometry)
#pragma alloc_text(PAGE, FstubAllocateDiskInformation)
#pragma alloc_text(PAGE, FstubFreeDiskInformation)
#pragma alloc_text(PAGE, FstubWriteBootSectorEFI)
#pragma alloc_text(PAGE, FstubConvertExtendedToLayout)
#pragma alloc_text(PAGE, FstubWritePartitionTableMBR)
#pragma alloc_text(PAGE, FstubWriteEntryEFI)
#pragma alloc_text(PAGE, FstubWriteHeaderEFI)
#pragma alloc_text(PAGE, FstubAdjustPartitionCount)
#pragma alloc_text(PAGE, FstubCreateDiskEFI)
#pragma alloc_text(PAGE, FstubCreateDiskMBR)
#pragma alloc_text(PAGE, FstubCreateDiskRaw)
#pragma alloc_text(PAGE, FstubCopyEntryEFI)
#pragma alloc_text(PAGE, FstubWritePartitionTableEFI)
#pragma alloc_text(PAGE, FstubReadHeaderEFI)
#pragma alloc_text(PAGE, FstubReadPartitionTableEFI)
#pragma alloc_text(PAGE, FstubVerifyPartitionTableEFI)
#pragma alloc_text(PAGE, FstubUpdateDiskGeometryEFI)
#pragma alloc_text(PAGE, FstubWriteSector)
#pragma alloc_text(PAGE, FstubReadSector)

#if DBG
#pragma alloc_text(PAGE, FstubDbgPrintPartition)
#pragma alloc_text(PAGE, FstubDbgPrintDriveLayout)
#pragma alloc_text(PAGE, FstubDbgPrintPartitionEx)
#pragma alloc_text(PAGE, FstubDbgPrintDriveLayoutEx)
#pragma alloc_text(PAGE, FstubDbgPrintSetPartitionEx)
#endif // DBG

#endif


NTSTATUS
IoCreateDisk(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCREATE_DISK DiskInfo
    )

/*++

Routine Description:

    This routine creates an empty disk for the device object. It can operate
    on either an EFI disk or an MBR disk. The parameters necessary to create
    an empty disk vary for different type of partition tables the disks
    contain.

Arguments:

    DeviceObject - Device object to initialize disk for.

    DiskInfo - The information necessary to create the disk. This will vary
            for different partition types; e.g., MBR partitioned disks and
            EFI partitioned disks. If DiskInfo is NULL, then we default
            to initializing the disk to raw.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    ULONG PartitionStyle;

    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );

    //
    // If DiskInfo is NULL, we default to RAW.
    //
    
    if ( DiskInfo == NULL ) {
        PartitionStyle = PARTITION_STYLE_RAW;
    } else {
        PartitionStyle = DiskInfo->PartitionStyle;
    }

    //
    // Call the lower level routine for EFI, MBR or RAW disks.
    //

    switch ( PartitionStyle ) {

        case PARTITION_STYLE_GPT:
            Status = FstubCreateDiskEFI ( DeviceObject, &DiskInfo->Gpt );
            break;

        case PARTITION_STYLE_MBR:
            Status = FstubCreateDiskMBR ( DeviceObject, &DiskInfo->Mbr );
            break;

        case PARTITION_STYLE_RAW:
            Status = FstubCreateDiskRaw ( DeviceObject );
            break;
            
        default:
            Status = STATUS_NOT_SUPPORTED;
    }

    return Status;
}


NTSTATUS
IoWritePartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    )

/*++

Routine Description:

    Write a partition table to the disk.

Arguments:

    DeviceObject - The device object for the disk we want to write the
            partition table for.

    DriveLayout - The partition table information.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    PDISK_INFORMATION Disk;

    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );
    ASSERT ( DriveLayout != NULL );


    FstubDbgPrintDriveLayoutEx ( DriveLayout );

    //
    // Initialize a Disk structure.
    //

    Disk = NULL;

    Status = FstubAllocateDiskInformation (
                DeviceObject,
                &Disk,
                NULL
                );

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // ISSUE - 2000/03/17 - math: Check partition type.
    // We need to check the partition type so people don't write an MBR
    // drive layout over a GPT partition table. Detect the partition style
    // and if it doesn't match the one we're passed in, fail the call.
    //
    
    ASSERT ( Disk != NULL );

    switch ( DriveLayout->PartitionStyle ) {

        case PARTITION_STYLE_GPT: {

            ULONG MaxPartitionCount;
            PEFI_PARTITION_HEADER Header;


            //
            // Read the partition table header from the primary partition
            // table.
            //

            Header = NULL;

            //
            // NB: Header is allocated in the disk's scratch buffer. Thus,
            // it does not explicitly need to be deallocated.
            //

            Status = FstubReadHeaderEFI (
                                Disk,
                                PRIMARY_PARTITION_TABLE,
                                &Header
                                );

            if (!NT_SUCCESS (Status)) {

                //
                // Failed reading the header from the primary partition table.
                // Try the backup table.
                //

                Status = FstubReadHeaderEFI (
                                    Disk,
                                    BACKUP_PARTITION_TABLE,
                                    &Header
                                    );

                if (!NT_SUCCESS (Status)) {
                    break;
                }
            }

            MaxPartitionCount = Header->NumberOfEntries;

            //
            // You cannot write more partition table entries that the
            // table will hold.
            //

            if (DriveLayout->PartitionCount > MaxPartitionCount) {

                KdPrintEx((DPFLTR_FSTUB_ID,
                           DPFLTR_WARNING_LEVEL,
                           "FSTUB: ERROR: Requested to write %d partitions\n"
                               "\tto a table that can hold a maximum of %d entries\n",
                           DriveLayout->PartitionCount,
                           MaxPartitionCount));

                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Write the primary partition table.
            //

            Status = FstubWritePartitionTableEFI (
                                Disk,
                                DriveLayout->Gpt.DiskId,
                                MaxPartitionCount,
                                Header->FirstUsableLBA,
                                Header->LastUsableLBA,
                                PRIMARY_PARTITION_TABLE,
                                DriveLayout->PartitionCount,
                                DriveLayout->PartitionEntry
                                );

            if (!NT_SUCCESS (Status)) {
                break;
            }

            //
            // Write the backup partition table.
            //

            Status = FstubWritePartitionTableEFI (
                                Disk,
                                DriveLayout->Gpt.DiskId,
                                MaxPartitionCount,
                                Header->FirstUsableLBA,
                                Header->LastUsableLBA,
                                BACKUP_PARTITION_TABLE,
                                DriveLayout->PartitionCount,
                                DriveLayout->PartitionEntry
                                );
            break;
        }

        case PARTITION_STYLE_MBR:
            Status = FstubWritePartitionTableMBR (
                                Disk,
                                DriveLayout
                                );
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }


    if ( Disk != NULL ) {
        FstubFreeDiskInformation ( Disk );
    }

#if 0

    //
    // If we successfully wrote a new partition table. Verify that it is
    // valid.
    //

    if ( NT_SUCCESS (Status)) {
        NTSTATUS VerifyStatus;

        VerifyStatus = IoVerifyPartitionTable ( DeviceObject, FALSE );

        //
        // STATUS_NOT_SUPPORTED is returned for MBR disks.
        //

        if (VerifyStatus != STATUS_NOT_SUPPORTED) {
            ASSERT (NT_SUCCESS (VerifyStatus));
        }
    }
#endif

    return Status;
}



NTSTATUS
IoReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    )

/*++

Routine Description:

    This routine reads the partition table for the disk. Unlike
    IoReadPartitionTable, this routine understands both EFI and MBR
    partitioned disks.

    The partition list is built in nonpaged pool that is allocated by this
    routine. It is the caller's responsability to free this memory when it
    is finished with the data.

Arguments:

    DeviceObject - Pointer for device object for this disk.

    DriveLayout - Pointer to the pointer that will return the patition list.
            This buffer is allocated in nonpaged pool by this routine. It is
            the responsability of the caller to free this memory if this
            routine is successful.

Return Values:

    NTSTATUS code.

--*/

{

    NTSTATUS Status;
    PDISK_INFORMATION Disk;
    PARTITION_STYLE Style;
    BOOLEAN FoundGptPartition;

    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );
    ASSERT ( DriveLayout != NULL );

    Status = FstubAllocateDiskInformation (
                DeviceObject,
                &Disk,
                NULL
                );

    if ( !NT_SUCCESS ( Status ) ) {
        return Status;
    }

    ASSERT ( Disk != NULL );

    Status = FstubDetectPartitionStyle (
                    Disk,
                    &Style
                    );

    //
    // To include oddities such as super-floppies, EZDrive disks and
    // raw disks (which get a fake MBR partition created for them),
    // we use the following algorithm:
    //
    //      if ( valid gpt partition table)
    //          return GPT partition information
    //      else
    //          return MBR partition information
    //
    // When this code (especially FstubDetectPartitionStyle) is made
    // to understand such things as super-floppies and raw disks, this
    // will no longer be necessary.
    //
    
    FoundGptPartition = FALSE;
    
    if ( NT_SUCCESS (Status) && Style == PARTITION_STYLE_GPT ) {

        //
        // First, read the primary partition table.
        //
        
        Status = FstubReadPartitionTableEFI (
                    Disk,
                    PRIMARY_PARTITION_TABLE,
                    DriveLayout
                    );

        if (NT_SUCCESS (Status)) {

            FoundGptPartition = TRUE;

        } else {

            //
            // If the primary EFI partition table is invalid, try reading
            // the backup partition table instead. We should find a way
            // to notify the caller that the primary partition table is
            // invalid so it can take the steps to fix it.
            //

            Status = FstubReadPartitionTableEFI (
                        Disk,
                        BACKUP_PARTITION_TABLE,
                        DriveLayout
                        );

            if ( NT_SUCCESS (Status) ) {
                FoundGptPartition = TRUE;
            }
        }
    }

    if ( !FoundGptPartition ) {
    
        Status = FstubReadPartitionTableMBR (
                        Disk,
                        FALSE,
                        DriveLayout
                        );
    }

    if ( Disk ) {
        FstubFreeDiskInformation ( Disk );
    }

#if DBG

    if (NT_SUCCESS (Status)) {
        FstubDbgPrintDriveLayoutEx ( *DriveLayout );
    }

#endif


    return Status;
}


NTSTATUS
IoSetPartitionInformationEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG PartitionNumber,
    IN PSET_PARTITION_INFORMATION_EX PartitionInfo
    )

/*++

Routine Description:

    Set the partition information for a specific partition.

Arguments:

    DeviceObject - Pointer to the device object for the disk.

    PartitionNumber - A valid partition number we want to set the partition
            information for.

    PartitionInfo - The partition information.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    PDISK_INFORMATION Disk;
    PARTITION_STYLE Style;

    ASSERT ( DeviceObject != NULL );
    ASSERT ( PartitionInfo != NULL );

    PAGED_CODE ();


    //
    // Initialization
    //

    Disk = NULL;

    FstubDbgPrintSetPartitionEx (PartitionInfo, PartitionNumber);

    Status = FstubAllocateDiskInformation (
                    DeviceObject,
                    &Disk,
                    NULL
                    );

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Status = FstubDetectPartitionStyle ( Disk, &Style );

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    if ( Style != PartitionInfo->PartitionStyle ) {
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    switch ( Style ) {

        case PARTITION_STYLE_MBR:
            Status = IoSetPartitionInformation (
                            DeviceObject,
                            Disk->SectorSize,
                            PartitionNumber,
                            PartitionInfo->Mbr.PartitionType
                            );
            break;

        case PARTITION_STYLE_GPT:
            Status = FstubSetPartitionInformationEFI (
                            Disk,
                            PartitionNumber,
                            &PartitionInfo->Gpt
                            );
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }

done:

    if ( Disk != NULL ) {
        FstubFreeDiskInformation ( Disk );
        Disk = NULL;
    }

    return Status;
}


NTSTATUS
IoUpdateDiskGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDISK_GEOMETRY_EX OldDiskGeometry,
    IN PDISK_GEOMETRY_EX NewDiskGeometry
    )

/*++

Routine Description:

    Update the disk geometry for the specific device. On an EFI disk the EFI
    partition table will be moved to the end of the disk, so the final sectors
    must be writable by the time this routine is called.

    The primary and backup partition tables must be valid for this function to
    succeed.

Arguments:

    DeviceObject - The device whose geometry has changed.

    OldDiskGeometry - The old disk geometry.

    NewDiskGeometry - The new disk geometry.

Return Value:

    NTSTATUS code

--*/

{
    NTSTATUS Status;
    PARTITION_STYLE Style;
    PDISK_INFORMATION OldDisk;
    PDISK_INFORMATION NewDisk;

    PAGED_CODE ();


    ASSERT ( DeviceObject != NULL );
    ASSERT ( OldDiskGeometry != NULL );
    ASSERT ( NewDiskGeometry != NULL );

    //
    // Initialization.
    //

    OldDisk = NULL;
    NewDisk = NULL;

    //
    // Allocate objects representing the old disk and the new disk.
    //

    Status = FstubAllocateDiskInformation (
                    DeviceObject,
                    &OldDisk,
                    (PINTERNAL_DISK_GEOMETRY) OldDiskGeometry
                    );

    if ( !NT_SUCCESS (Status) ) {
        goto done;
    }


    Status = FstubAllocateDiskInformation (
                DeviceObject,
                &NewDisk,
                (PINTERNAL_DISK_GEOMETRY) NewDiskGeometry
                );

    if ( !NT_SUCCESS (Status) ) {
        goto done;
    }

    Status = FstubDetectPartitionStyle (
                OldDisk,
                &Style
                );

    if ( !NT_SUCCESS (Status) ) {
        goto done;
    }

    switch ( Style ) {

        case PARTITION_STYLE_GPT:

            //
            // Update the geometry for an EFI disk.
            //

            Status = FstubUpdateDiskGeometryEFI (
                        OldDisk,
                        NewDisk
                        );
            break;

        case PARTITION_STYLE_MBR:

            //
            // For MBR partitioned drives, there is nothing to do, so
            // we succeed by default.
            //

            Status = STATUS_SUCCESS;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }

done:

    if ( OldDisk ) {
        FstubFreeDiskInformation ( OldDisk );
        OldDisk = NULL;
    }

    if ( NewDisk ) {
        FstubFreeDiskInformation ( NewDisk );
        NewDisk = NULL;
    }

    return Status;
}


NTSTATUS
IoReadDiskSignature(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG BytesPerSector,
    OUT PDISK_SIGNATURE Signature
    )
/*++

Routine Description:

    This routine will read the disk signature information from the disk. For
    MBR disks, it will read the disk signature and calculate a checksum of the 
    contents of the MBR. For GPT disks, it will obtain the EFI DiskId from
    the disk.

Arguments:

    DeviceObject - A disk device object.

    BytesPerSector - The number of bytes per sector on this disk.

    DiskSignature - A buffer where the disk information will be stored.
    
Return Value:

    NT Status code.

--*/

{
    NTSTATUS Status;
    PULONG Mbr;

    PAGED_CODE();

    //
    // Make sure sector size is at least 512 bytes.
    //
    
    if (BytesPerSector < 512) {
        BytesPerSector = 512;
    }

    //
    // Allocate buffer for sector read.
    //

    Mbr = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                BytesPerSector,
                                FSTUB_TAG);

    if (Mbr == NULL) {
        return STATUS_NO_MEMORY;
    }

    Status = FstubReadSector (
                    DeviceObject,
                    BytesPerSector,
                    0,
                    Mbr);

    if (!NT_SUCCESS (Status)) {
        ExFreePool (Mbr);
        return Status;
    }
            
    //
    // If this is an EFI disk get the EFI disk signature instead.
    //
    
    if ( ((MASTER_BOOT_RECORD*)Mbr)->Partition[0].OSIndicator == EFI_MBR_PARTITION_TYPE &&
         ((MASTER_BOOT_RECORD*)Mbr)->Partition[1].OSIndicator == 0 &&
         ((MASTER_BOOT_RECORD*)Mbr)->Partition[2].OSIndicator == 0 &&
         ((MASTER_BOOT_RECORD*)Mbr)->Partition[3].OSIndicator == 0 ) {

        PEFI_PARTITION_HEADER EfiHeader;
        ULONG32 Temp;
        ULONG32 CheckSum;
        
        //
        // Get the EFI disk guid.
        //

        Status = FstubReadSector (
                    DeviceObject,
                    BytesPerSector,
                    1,
                    Mbr);

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Mbr);
            return Status;
        }

        EfiHeader = (PEFI_PARTITION_HEADER) Mbr;

        //
        // Compute the CRC32 CheckSum of the header block. This is used to
        // verify that we have a valid EFI disk.
        //
        
        Temp = EfiHeader->HeaderCRC32;
        EfiHeader->HeaderCRC32 = 0;
        CheckSum = RtlComputeCrc32 (0, EfiHeader, EfiHeader->HeaderSize);
        EfiHeader->HeaderCRC32 = Temp;

        //
        // The EFI CheckSum doesn't match what was in it's header. Return
        // failure.
        //
        
        if (CheckSum != EfiHeader->HeaderCRC32) {
            ExFreePool (Mbr);
            return STATUS_DISK_CORRUPT_ERROR;
        }

        //
        // This is a valid EFI disk. Copy the disk signature from the
        // EFI Header sector.
        //
        
        Signature->PartitionStyle = PARTITION_STYLE_GPT;
        Signature->Gpt.DiskId = EfiHeader->DiskGUID;

    } else {
    
        ULONG i;
        ULONG MbrCheckSum;

        //
        // Calculate MBR checksum.
        //

        MbrCheckSum = 0;

        for (i = 0; i < 128; i++) {
            MbrCheckSum += Mbr[i];
        }

        MbrCheckSum = ~(MbrCheckSum) + 1;

        //
        // Get the signature out of the sector and save it in the disk data block.
        //

        Signature->PartitionStyle = PARTITION_STYLE_MBR;
        Signature->Mbr.Signature = Mbr [PARTITION_TABLE_OFFSET/2-1];
        Signature->Mbr.CheckSum = MbrCheckSum;
    }

    ExFreePool (Mbr);

    return Status;
}
    


NTSTATUS
IoVerifyPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FixErrors
    )

/*++

Routine Description:

    Verify that the partition table and backup partition table (if present)
    is valid. If these tables are NOT valid, and FixErrors is TRUE, and the
    errors are recoverable errors, fix them.

Arguments:

    DeviceObject - A disk whose partition table should be verified and/or
            fixed.

    FixErrors - If the partition table contains errors and these errors are
            recoverable errors, fix the errors. Otherwise, the disk will not
            be modified.

Return Value:

    STATUS_SUCCESS - If the final partition table, after any modifications
            done by this routine, is valid.

    STATUS_DISK_CORRUPT_ERROR - If the final partition table, after any
            modifications done by this routine, is not valid.

    Other NTSTATUS code - Some other failure.

--*/


{
    NTSTATUS Status;
    PDISK_INFORMATION Disk;
    PARTITION_STYLE Style;

    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );

    Status = FstubAllocateDiskInformation (
                DeviceObject,
                &Disk,
                NULL
                );

    if ( !NT_SUCCESS ( Status ) ) {
        return Status;
    }

    ASSERT ( Disk != NULL );

    Status = FstubDetectPartitionStyle (
                    Disk,
                    &Style
                    );

    if ( !NT_SUCCESS (Status) ) {
        FstubFreeDiskInformation ( Disk );
        Disk = NULL;
        return Status;
    }

    switch ( Style ) {

        case PARTITION_STYLE_GPT:
            Status = FstubVerifyPartitionTableEFI (
                            Disk,
                            FixErrors
                            );
            break;

        case PARTITION_STYLE_MBR:
            Status = STATUS_SUCCESS;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }

    if ( Disk ) {
        FstubFreeDiskInformation ( Disk );
    }

    return Status;

}

//
// Internal Routines
//


NTSTATUS
FstubSetPartitionInformationEFI(
    IN PDISK_INFORMATION Disk,
    IN ULONG PartitionNumber,
    IN SET_PARTITION_INFORMATION_GPT* PartitionInfo
    )

/*++

Routine Description:

    Update the partition information for a specific EFI partition.

    The algorithm we use reads the entire partition table and writes it back
    again. This makes sense, because the entire table will have to be read in
    ANYWAY, since we have to checksum the table.

    NB: this algorithm assumes that the partition table hasn't changed since
    the time GetDriveLayout was called. Probably a safe assumption.

Arguments:

    Disk -

    PartitionNumber -

    PartitionInfo -

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    PPARTITION_INFORMATION_GPT EntryInfo;
    PDRIVE_LAYOUT_INFORMATION_EX Layout;
    ULONG PartitionOrdinal;


    ASSERT ( Disk != NULL );
    ASSERT ( PartitionInfo != NULL );

    PAGED_CODE ();


    //
    // Initialization
    //

    Layout = NULL;

    if ( PartitionNumber == 0 ) {
        return STATUS_INVALID_PARAMETER;
    }

    PartitionOrdinal = PartitionNumber - 1;

    //
    // Read in the entire partition table.
    //

    Status = IoReadPartitionTableEx (
                    Disk->DeviceObject,
                    &Layout
                    );

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ASSERT ( Layout != NULL );

    //
    // If it's out of range, fail.
    //

    if ( PartitionOrdinal >= Layout->PartitionCount ) {
        ExFreePool ( Layout );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Copy the information into the partition array.
    //

    EntryInfo = &Layout->PartitionEntry [PartitionOrdinal].Gpt;

    EntryInfo->PartitionType = PartitionInfo->PartitionType;
    EntryInfo->PartitionId = PartitionInfo->PartitionId;
    EntryInfo->Attributes = PartitionInfo->Attributes;

    RtlCopyMemory (
            EntryInfo->Name,
            PartitionInfo->Name,
            sizeof (EntryInfo->Name)
            );


    //
    // And rewrite the partition table.
    //

    Status = IoWritePartitionTableEx (
                    Disk->DeviceObject,
                    Layout
                    );

    ExFreePool ( Layout );
    Layout = NULL;

    return Status;
}



NTSTATUS
FstubReadPartitionTableMBR(
    IN PDISK_INFORMATION Disk,
    IN BOOLEAN RecognizedPartitionsOnly,
    OUT PDRIVE_LAYOUT_INFORMATION_EX* ReturnedDriveLayout
    )

/*++

Routine Description:

    Read the MBR partition table.

Arguments:

    Disk - The disk we want to obtain the partition information for.

    RecognizedPartitionsOnly - Whether to return information for all
            partitions or only recognized partitions.

    ReturnedDriveLayout - A pointer to pointer where the drive layout
            information will be returned. The caller of this function is
            responsible for freeing this memory using ExFreePool.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    ULONG i;
    ULONG Size;
    PDRIVE_LAYOUT_INFORMATION Layout;
    PDRIVE_LAYOUT_INFORMATION_EX LayoutEx;
    PPARTITION_INFORMATION Entry;
    PPARTITION_INFORMATION_EX EntryEx;


    PAGED_CODE ();

    ASSERT ( IS_VALID_DISK_INFO ( Disk ) );
    ASSERT ( ReturnedDriveLayout != NULL );

    //
    // Initialization
    //

    *ReturnedDriveLayout = NULL;
    Layout = NULL;


    Status = IoReadPartitionTable (
                    Disk->DeviceObject,
                    Disk->SectorSize,
                    RecognizedPartitionsOnly,
                    &Layout
                    );

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Size = FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[0]) +
           Layout->PartitionCount * sizeof (PARTITION_INFORMATION_EX);

    LayoutEx = ExAllocatePoolWithTag (
                    NonPagedPool,
                    Size,
                    FSTUB_TAG
                    );

    if ( LayoutEx == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Tranlated the drive layout information to the extended drive layout
    // information.
    //

    LayoutEx->PartitionStyle = PARTITION_STYLE_MBR;
    LayoutEx->PartitionCount = Layout->PartitionCount;
    LayoutEx->Mbr.Signature = Layout->Signature;

    //
    // Translate each entry in the table.
    //

    for (i = 0; i < Layout->PartitionCount; i++) {

        EntryEx = &LayoutEx->PartitionEntry[i];
        Entry = &Layout->PartitionEntry[i];

        EntryEx->PartitionStyle = PARTITION_STYLE_MBR;
        EntryEx->StartingOffset = Entry->StartingOffset;
        EntryEx->PartitionLength = Entry->PartitionLength;
        EntryEx->RewritePartition = Entry->RewritePartition;
        EntryEx->PartitionNumber = Entry->PartitionNumber;

        EntryEx->Mbr.PartitionType = Entry->PartitionType;
        EntryEx->Mbr.BootIndicator = Entry->BootIndicator;
        EntryEx->Mbr.RecognizedPartition = Entry->RecognizedPartition;
        EntryEx->Mbr.HiddenSectors = Entry->HiddenSectors;
    }

    //
    // Free layout information allocated by IoReadPartitionTable.
    //

    ExFreePool ( Layout );

    //
    // And return the translated, EX information.
    //

    *ReturnedDriveLayout = LayoutEx;

    return Status;
}



NTSTATUS
FstubDetectPartitionStyle(
    IN PDISK_INFORMATION Disk,
    OUT PARTITION_STYLE* PartitionStyle
    )

/*++

Routine Description:

    Detect how a disk has been partitioned. For an MBR partitioned disk,
    sector zero contains the MBR signature. For an EFI partitioned disk,
    sector zero contains a legacy style MBR with a single partition that
    consumes the entire disk.

Arguments:

    Disk - The disk to determine the partition style for.

    PartitionStyle - A buffer to

Return Values:

    STATUS_SUCCESS - If the disk has been partitioned by a recognized
            partitioning scheme EFI or MBR.

    STATUS_UNSUCCESSFUL - If partitioning scheme was not recognized.

--*/

{
    NTSTATUS Status;
    MASTER_BOOT_RECORD* Mbr;

    PAGED_CODE ();

    ASSERT ( IS_VALID_DISK_INFO ( Disk ) );
    ASSERT ( PartitionStyle != NULL );


    //
    // Read sector 0. This will contan the mbr on an mbr-partition disk
    // or the legacy mbr on an efi-partitioned disk.
    //

    Status = FstubReadSector (
                    Disk->DeviceObject,
                    Disk->SectorSize,
                    0,
                    Disk->ScratchBuffer
                    );

    if ( !NT_SUCCESS ( Status ) ) {
        return Status;
    }

    Mbr = Disk->ScratchBuffer;

    //
    // If the disk has an MBR 
    //

    *PartitionStyle = -1;
    
    if (Mbr->Signature == MBR_SIGNATURE) {

        if (Mbr->Partition[0].OSIndicator == EFI_MBR_PARTITION_TYPE &&
            Mbr->Partition[1].OSIndicator == 0 &&
            Mbr->Partition[2].OSIndicator == 0 &&
            Mbr->Partition[3].OSIndicator == 0) {

            *PartitionStyle = PARTITION_STYLE_GPT;
            Status = STATUS_SUCCESS;

        } else {

            *PartitionStyle = PARTITION_STYLE_MBR;
            Status = STATUS_SUCCESS;
        }

    } else {

        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}



NTSTATUS
FstubGetDiskGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PINTERNAL_DISK_GEOMETRY Geometry
    )

/*++

Routine Description:

    We need this routine to get the number of cylinders that the disk driver
    thinks is on the drive.  We will need this to calculate CHS values
    when we fill in the partition table entries.

Arguments:

    DeviceObject - The device object describing the entire drive.

Return Value:

    None.

--*/

{
    PIRP localIrp;
    PINTERNAL_DISK_GEOMETRY diskGeometry;
    PIO_STATUS_BLOCK iosb;
    PKEVENT eventPtr;
    NTSTATUS status;

    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );
    ASSERT ( Geometry != NULL );

    //
    // Initialization
    //

    eventPtr = NULL;
    iosb = NULL;
    diskGeometry = NULL;


    diskGeometry = ExAllocatePoolWithTag(
                      NonPagedPool,
                      sizeof (*diskGeometry),
                      'btsF'
                      );

    if (!diskGeometry) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    iosb = ExAllocatePoolWithTag(
               NonPagedPool,
               sizeof(IO_STATUS_BLOCK),
               'btsF'
               );

    if (!iosb) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;

    }

    eventPtr = ExAllocatePoolWithTag(
                   NonPagedPool,
                   sizeof(KEVENT),
                   'btsF'
                   );

    if (!eventPtr) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;

    }

    KeInitializeEvent(
        eventPtr,
        NotificationEvent,
        FALSE
        );

    localIrp = IoBuildDeviceIoControlRequest(
                   IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,
                   DeviceObject,
                   NULL,
                   0UL,
                   diskGeometry,
                   sizeof (*diskGeometry),
                   FALSE,
                   eventPtr,
                   iosb
                   );

    if (!localIrp) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }


    //
    // Call the lower level driver, wait for the opertion
    // to finish.
    //

    status = IoCallDriver(
                 DeviceObject,
                 localIrp
                 );

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(
                   eventPtr,
                   Executive,
                   KernelMode,
                   FALSE,
                   (PLARGE_INTEGER) NULL
                   );
        status = iosb->Status;
    }


    if (NT_SUCCESS(status)) {

        RtlCopyMemory (Geometry, diskGeometry, sizeof (*Geometry));
    }

done:

    if ( eventPtr ) {
        ExFreePool (eventPtr);
        eventPtr = NULL;
    }

    if ( iosb ) {
        ExFreePool(iosb);
        iosb = NULL;
    }

    if ( diskGeometry ) {
        ExFreePool (diskGeometry);
        diskGeometry = NULL;
    }

    if ( NT_SUCCESS ( status ) ) {

        //
        // If the the partition entry size is not a factor of the disk block
        // size, we will need to add code to deal with partition entries that
        // span physical sectors. This may happen if you change the size of
        // the partition entry or if you have a disk with a block size less
        // than 128 bytes.
        //

        ASSERT ( (Geometry->Geometry.BytesPerSector % PARTITION_ENTRY_SIZE) == 0);
    }

    return status;
}


NTSTATUS
FstubAllocateDiskInformation(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDISK_INFORMATION * DiskBuffer,
    IN PINTERNAL_DISK_GEOMETRY Geometry OPTIONAL
    )

/*++

Routine Description:

    Allocate and initialize a DISK_INFORMATION structure describing the
    disk DeviceObject.

Arguments:

    DeviceObject - A device object describing the entire disk.

    DiskBuffer - A buffer to a recieve the allocated DISK_INFORMATION pointer.

    Geometry - An optional pointer to an INTERNAL_DISK_GEOMETRY structure. If
            this pointer is NULL, the disk will be querried for it's geometry
            using IOCTL_DISK_GET_DRIVE_GEOMETRY_EX.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    PDISK_INFORMATION Disk;
    PVOID Buffer;

    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );
    ASSERT ( DiskBuffer != NULL );


    Disk = ExAllocatePoolWithTag (
                NonPagedPool,
                sizeof (DISK_INFORMATION),
                FSTUB_TAG
                );

    if ( Disk == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( Geometry ) {

        RtlCopyMemory (
                &Disk->Geometry,
                Geometry,
                sizeof (Disk->Geometry)
                );

    } else {

        Status = FstubGetDiskGeometry (
                                DeviceObject,
                                &Disk->Geometry
                                );


        if (!NT_SUCCESS (Status)) {

            KdPrintEx ((DPFLTR_FSTUB_ID,
                        DPFLTR_ERROR_LEVEL,
                        "FSTUB: disk %p failed to report geometry.\n",
                        DeviceObject));
                        
            ExFreePool ( Disk );
            return Status;
        }
    }

    //
    // Check the geometry. Sometimes drives report incorrect geometry.
    // Removable drives without media report a size of zero.
    //
        
    if (Disk->Geometry.Geometry.BytesPerSector == 0 ||
        Disk->Geometry.DiskSize.QuadPart == 0) {

        KdPrintEx ((DPFLTR_FSTUB_ID,
                    DPFLTR_WARNING_LEVEL,
                    "FSTUB: disk %p reported invalid geometry. Probably a removable.\n"
                    "    SectorSize %d\n"
                    "    DiskSize %I64x\n",
                    DeviceObject,
                    Disk->Geometry.Geometry.BytesPerSector,
                    Disk->Geometry.DiskSize.QuadPart));

        ExFreePool ( Disk );
        return STATUS_DEVICE_NOT_READY;
    }
    
    Disk->DeviceObject = DeviceObject;
    Disk->SectorSize = Disk->Geometry.Geometry.BytesPerSector;

    //
    // Do not use sector-count = cylinders * tracks * sector-size. Devices
    // like the memory stick can report a correct disk size and a more or
    // less correct sector size, a completely invalid number of cylinders
    // or tracks. Since the only thing we really need here is the sector
    // count, avoid using these potentially incorrect values.
    //
    
    Disk->SectorCount = Disk->Geometry.DiskSize.QuadPart /
                (ULONGLONG) Disk->Geometry.Geometry.BytesPerSector;

    //
    // NOTE: This does not need to be nonpaged or cache aligned, does it?
    //

    Buffer = ExAllocatePoolWithTag (
                    NonPagedPoolCacheAligned,
                    Disk->SectorSize,
                    FSTUB_TAG
                    );

    if ( Buffer == NULL ) {

        ExFreePool ( Disk );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Disk->ScratchBuffer = Buffer;
    *DiskBuffer = Disk;

    return STATUS_SUCCESS;
}


NTSTATUS
FstubFreeDiskInformation(
    IN OUT PDISK_INFORMATION Disk
    )

/*++

Routine Description:

    Free the allocated disk information.
    
Arguments:

    Disk - Disk information previously allocated
            with FstubAllocateDiskInformation().

Return Value:

    NTSTATUS code.

--*/

{
    //
    // Free up disk scratch buffer and disk object.
    //

    if ( Disk && Disk->ScratchBuffer ) {
        ExFreePool (Disk->ScratchBuffer);
        Disk->ScratchBuffer = NULL;
    }

    if ( Disk ) {
        ExFreePool (Disk);
        Disk = NULL;
    }

    return STATUS_SUCCESS;
}



NTSTATUS
FstubWriteBootSectorEFI(
    IN CONST PDISK_INFORMATION Disk
    )

/*++

Routine Description:

    Write the boot sector for an EFI partitioned disk. Note that the EFI
    boot sector uses the structure as the legacy AT-style MBR, but it
    contains only one partition entry and that entry covers the entire disk.

Arguments:

    Disk - The disk to write the MBR for.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    MASTER_BOOT_RECORD* Mbr;

    PAGED_CODE ();

    ASSERT ( Disk );
    ASSERT ( IS_VALID_DISK_INFO ( Disk ) );

    //
    // Construct an EFI Master Boot Record. The EFI Master Boot Record has
    // one partition entry which is setup to consume the entire disk. The
    // MBR we are writing is configured to boot using only the EFI firmware.
    // It will not via the legacy BIOS because we do not write valid
    // instructions to it.
    //

    Mbr = Disk->ScratchBuffer;

    //
    // The rest of this sector is not accessed by EFI. Zero it out so
    // other tools do not get confused. Especially, we need to make sure
    // the NTFT signature is NULL.
    //

    RtlZeroMemory (Mbr, Disk->SectorSize);

    //
    // NB: the cylinder and head values are 0-based, but the sector
    // value is 1-based.
    //

    //
    // ISSUE - 2000/02/01 - math: Is it necessary to properly initialize the
    // Head, Track, Sector and SizeInLba field for legacy BIOS compatability?
    // We are not doing this in the diskpart program, so probably not.
    //

    Mbr->Signature = MBR_SIGNATURE;
    Mbr->Partition[0].BootIndicator = 0;
    Mbr->Partition[0].StartHead = 0;
    Mbr->Partition[0].StartSector = 2;
    Mbr->Partition[0].StartTrack = 0;
    Mbr->Partition[0].OSIndicator = EFI_MBR_PARTITION_TYPE;
    Mbr->Partition[0].EndHead =  0xFF;
    Mbr->Partition[0].EndSector =  0xFF;
    Mbr->Partition[0].EndTrack =  0xFF;
    Mbr->Partition[0].StartingLBA = 1;
    Mbr->Partition[0].SizeInLBA = 0xFFFFFFFF;

    //
    // Zero out the remaining partitions as per the EFI spec.
    //

    RtlZeroMemory (&Mbr->Partition[1], sizeof (Mbr->Partition[1]));
    RtlZeroMemory (&Mbr->Partition[2], sizeof (Mbr->Partition[2]));
    RtlZeroMemory (&Mbr->Partition[3], sizeof (Mbr->Partition[3]));

    //
    // Write the EFI MBR to the zeroth sector of the disk.
    //

    Status = FstubWriteSector (
                    Disk->DeviceObject,
                    Disk->SectorSize,
                    0,
                    Mbr
                    );

    return Status;
}



PDRIVE_LAYOUT_INFORMATION
FstubConvertExtendedToLayout(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutEx
    )

/*++

Routine Description:

    Convert an extended drive layout structure to a (old) drive
    layout structure. Necessarily, the LayoutEx structure must
    represent an MBR layout, not a GPT layout.

Arguments:

    LayoutEx - The extended drive layout structure to be converted.

Return Value:

    The converted drive layout structure.

--*/

{
    ULONG i;
    ULONG LayoutSize;
    PDRIVE_LAYOUT_INFORMATION Layout;
    PPARTITION_INFORMATION Partition;
    PPARTITION_INFORMATION_EX PartitionEx;

    PAGED_CODE ();

    ASSERT ( LayoutEx );


    //
    // The only valid conversion is from an MBR extended layout structure to
    // the old structure.
    //

    if (LayoutEx->PartitionStyle != PARTITION_STYLE_MBR) {
        ASSERT ( FALSE );
        return NULL;
    }

    LayoutSize = FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION, PartitionEntry[0]) +
                 LayoutEx->PartitionCount * sizeof (PARTITION_INFORMATION);

    Layout = ExAllocatePoolWithTag (
                    NonPagedPool,
                    LayoutSize,
                    FSTUB_TAG
                    );

    if ( Layout == NULL ) {
        return NULL;
    }

    Layout->Signature = LayoutEx->Mbr.Signature;
    Layout->PartitionCount = LayoutEx->PartitionCount;

    for (i = 0; i < LayoutEx->PartitionCount; i++) {

        Partition = &Layout->PartitionEntry[i];
        PartitionEx = &LayoutEx->PartitionEntry[i];

        Partition->StartingOffset = PartitionEx->StartingOffset;
        Partition->PartitionLength = PartitionEx->PartitionLength;
        Partition->RewritePartition = PartitionEx->RewritePartition;
        Partition->PartitionNumber = PartitionEx->PartitionNumber;

        Partition->PartitionType = PartitionEx->Mbr.PartitionType;
        Partition->BootIndicator = PartitionEx->Mbr.BootIndicator;
        Partition->RecognizedPartition = PartitionEx->Mbr.RecognizedPartition;
        Partition->HiddenSectors = PartitionEx->Mbr.HiddenSectors;
    }

    return Layout;
}



NTSTATUS
FstubWritePartitionTableMBR(
    IN PDISK_INFORMATION Disk,
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutEx
    )

/*++

Routine Description:

    Write the MBR partition table represented by LayoutEx to
    the disk.

Arguments:

    Disk - The disk where the partition table should be written.

    LayoutEx - The new layout information.

Return Value:

    NTSTATUS code

--*/

{
    NTSTATUS Status;
    PDRIVE_LAYOUT_INFORMATION Layout;

    PAGED_CODE ();

    ASSERT ( IS_VALID_DISK_INFO ( Disk ) );
    ASSERT ( LayoutEx != NULL );

    //
    // Convert extended layout structure to old layout structure.
    //

    Layout = FstubConvertExtendedToLayout ( LayoutEx );

    if ( Layout == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = IoWritePartitionTable (
                    Disk->DeviceObject,
                    Disk->SectorSize,
                    Disk->Geometry.Geometry.SectorsPerTrack,
                    Disk->Geometry.Geometry.TracksPerCylinder,
                    Layout
                    );

    return Status;
}



NTSTATUS
FstubWriteEntryEFI(
    IN PDISK_INFORMATION Disk,
    IN ULONG PartitionEntrySectorCount,
    IN ULONG EntryNumber,
    IN PEFI_PARTITION_ENTRY PartitionEntry,
    IN ULONG Partition,
    IN BOOLEAN Flush,
    IN OUT ULONG32* PartialCheckSum
    )

/*++

Routine Description:

    Write an EFI partition entry to the EFI partition table for this disk.
    The partition table writes are buffered until an entire disk block's worth
    of entries have been written, then written to the disk.

Arguments:

    Disk - The disk to write the partition entry for.

    PartitionEntrySectorCount - The count of blocks that the partition table
            occupies.

    EntryNumber - The index into the partition table array to write this
            entry.

    PartitionEntry - The partition entry data.

    Partition - Whether this is the main partition table or the backup
            partition table.

    Flush - Boolean to force the flushing of the table now (TRUE) or wait
            until a complete block's worth of data is ready to be written
            (FALSE).

    PartialCheckSum - The updated partial checksum including this entry.

Return Values:

    NTSTATUS code.

--*/

{
    ULONG Offset;
    ULONGLONG Lba;
    ULONGLONG StartOfEntryArray;
    NTSTATUS Status;

    PAGED_CODE ();

    ASSERT ( Disk );
    ASSERT ( IS_VALID_DISK_INFO ( Disk ) );


    //
    // The primary partition table begins after the EFI Master Boot Record
    // (block 0) and the EFI partition table header (block 1). The backup
    // partition table ends at the last block of the disk, hence it begins
    // in (from the end) as many blocks as it ocupies on the disk.
    //


    if ( Partition == PRIMARY_PARTITION_TABLE ) {

        StartOfEntryArray = 2;

    } else {

        StartOfEntryArray = Disk->SectorCount - PartitionEntrySectorCount - 1;
    }


    Lba = ( EntryNumber * PARTITION_ENTRY_SIZE ) / Disk->SectorSize;
    Offset = ( EntryNumber * PARTITION_ENTRY_SIZE ) % Disk->SectorSize;

    RtlCopyMemory (
            ((PUCHAR) Disk->ScratchBuffer) + Offset,
            PartitionEntry,
            PARTITION_ENTRY_SIZE
            );

    Offset += PARTITION_ENTRY_SIZE;
    ASSERT ( Offset <= Disk->SectorSize );

    //
    // Flush the buffer if necessary.
    //

    if ( Offset == Disk->SectorSize || Flush ) {

        Status = FstubWriteSector (
                        Disk->DeviceObject,
                        Disk->SectorSize,
                        StartOfEntryArray + Lba,
                        Disk->ScratchBuffer
                        );

        if (!NT_SUCCESS (Status)) {
            return Status;
        }

        RtlZeroMemory ( Disk->ScratchBuffer, Disk->SectorSize );
    }


    if ( PartialCheckSum ) {
        *PartialCheckSum = RtlComputeCrc32 (
                                *PartialCheckSum,
                                PartitionEntry,
                                PARTITION_ENTRY_SIZE
                                );
    }

    return STATUS_SUCCESS;
}



NTSTATUS
FstubWriteHeaderEFI(
    IN PDISK_INFORMATION Disk,
    IN ULONG PartitionEntrySectorCount,
    IN GUID DiskGUID,
    IN ULONG32 MaxPartitionCount,
    IN ULONG64 FirstUsableLBA,
    IN ULONG64 LastUsableLBA,
    IN ULONG32 CheckSum,
    IN ULONG Partition
    )

/*++

Routine Description:

    Write an EFI partition table header to the disk.

Arguments:

    Disk - The disk the partition table header should be written to.

    PartitionEntrySectorCount - The number of sectors that the partition
            table array occupies. These must be complete sectors.

    DiskGUID - The Unique GUID for this disk.

    MaxPartitionCount - The maximum number of partitions allowed for this
            disk.

    FirstUsableLBA - The beginning sector of partitionable space for this
            disk.  This value must be larger than the space consumed by the
            MBR, and partition table.  This value is never validated for
            correctness.

    LastUsableLBA - The last sector of partitionable space on this disk. This
            value must be smaller than the last disk sector less space
            necessary for the backup partition table. This value is not
            validated for correctness.

    CheckSum - The CRC32 checksum for the partition entry array.

    Partition - Which partition we are writing, the primary partition or
            the backup partition.

Return Values:

    NTSTATUS code.

Notes:

    PartitionEntrySectorCount could be derived from MaxPartitionCount.

--*/

{
    NTSTATUS Status;
    PEFI_PARTITION_HEADER TableHeader;
    ULONG32 HeaderCheckSum;


    ASSERT ( Disk != NULL );
    ASSERT ( IS_VALID_DISK_INFO ( Disk ) );

    PAGED_CODE ();


    TableHeader = Disk->ScratchBuffer;

    TableHeader->Signature = EFI_PARTITION_TABLE_SIGNATURE;
    TableHeader->Revision = EFI_PARTITION_TABLE_REVISION;
    TableHeader->HeaderSize = sizeof (EFI_PARTITION_HEADER);
    TableHeader->HeaderCRC32 = 0;
    TableHeader->Reserved = 0;

    //
    // The primary partition table starts at block 1. The backup partition
    // table ends at the end of the disk.
    //

    if ( Partition == PRIMARY_PARTITION_TABLE ) {

        TableHeader->MyLBA = 1;
        TableHeader->AlternateLBA = Disk->SectorCount - 1;

    } else {

        TableHeader->MyLBA = Disk->SectorCount - 1;
        TableHeader->AlternateLBA = 1;
    }

    TableHeader->FirstUsableLBA = FirstUsableLBA;
    TableHeader->LastUsableLBA = LastUsableLBA;
    TableHeader->DiskGUID = DiskGUID;
    TableHeader->NumberOfEntries = MaxPartitionCount;
    TableHeader->SizeOfPartitionEntry = PARTITION_ENTRY_SIZE;
    TableHeader->PartitionEntryCRC32 = CheckSum;

    //
    // For the primary partition table the partition entry array begins the
    // sector directly following the partition table header sector. For the
    // backup partition table, the partition table header sector directly
    // follows the partition entry array.  The partition table header for
    // a backup partition is located on the last sector of the disk.
    //

    if ( Partition == PRIMARY_PARTITION_TABLE ) {
        TableHeader->PartitionEntryLBA = TableHeader->MyLBA + 1;
    } else {
        TableHeader->PartitionEntryLBA = TableHeader->MyLBA - PartitionEntrySectorCount;
    }

    TableHeader->HeaderCRC32 = RtlComputeCrc32 (
                                    0,
                                    TableHeader,
                                    TableHeader->HeaderSize
                                    );

    KdPrintEx((DPFLTR_FSTUB_ID,
               DPFLTR_WARNING_LEVEL,
               "FSTUB: Dump of %s EFI partition table\n"
                   "    Signature: %I64x\n"
                   "    Revision: %x\n"
                   "    HeaderSize: %x\n"
                   "    HeaderCRC32: %x\n"
                   "    MyLBA: %I64x\n"
                   "    AlternateLBA: %I64x\n",
               (Partition == PRIMARY_PARTITION_TABLE) ? "Primary" : "Backup",
               TableHeader->Signature,
               TableHeader->Revision,
               TableHeader->HeaderSize,
               TableHeader->HeaderCRC32,
               TableHeader->MyLBA,
               TableHeader->AlternateLBA));


    KdPrintEx((DPFLTR_FSTUB_ID,
               DPFLTR_WARNING_LEVEL,
               "    FirstUsableLBA: %I64x\n"
                   "    LastUsableLBA: %I64x\n"
                   "    NumberOfEntries: %x\n"
                   "    SizeOfPartitionEntry: %x\n"
                   "    PartitionEntryCRC32: %x\n\n",
               TableHeader->FirstUsableLBA,
               TableHeader->LastUsableLBA,
               TableHeader->NumberOfEntries,
               TableHeader->SizeOfPartitionEntry,
               TableHeader->PartitionEntryCRC32));

    Status = FstubWriteSector (
                    Disk->DeviceObject,
                    Disk->SectorSize,
                    TableHeader->MyLBA,
                    TableHeader
                    );

    return Status;
}



VOID
FstubAdjustPartitionCount(
    IN ULONG SectorSize,
    IN OUT PULONG PartitionCount
    )

/*++

Routine Description:

    Adjust the PartitionCount to be a valid EFI Maximum Partition Count.

    A valid value for the partition must be larger than MIN_PARTITOIN_COUNT,
    currently 128, and adjusted to take up as much of the remaining disk
    sector as is possible.

Arguments:

    SectorSize - The disk sector size.

    PartitionCount - The count to be adjusted.

Return Values:

    None.

--*/

{
    ULONG Count;
    ULONG EntrySize;

    PAGED_CODE ();

    ASSERT ( SectorSize != 0 );
    ASSERT ( PartitionCount != NULL );


    EntrySize = PARTITION_ENTRY_SIZE;
    Count = max (*PartitionCount, MIN_PARTITION_COUNT);

    Count = ROUND_TO ( EntrySize * Count, SectorSize ) / EntrySize;
    ASSERT ( *PartitionCount <= Count );

    *PartitionCount = Count;

#if DBG

    //
    // If we're on a machine with a 512 byte block (nearly every machine),
    // verify that we've calculated a reasonable Count.
    //


    if (SectorSize == 512) {
        ASSERT ( Count % 4 == 0 );
    }

#endif

}


NTSTATUS
FstubCreateDiskEFI(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCREATE_DISK_GPT DiskInfo
    )

/*++

Routine Description:

    Lay down an empty EFI partition table on a virgin disk.

Arguments:

    DeviceObject - The device object describing the drive.

    Layout - The EFI disk layout information.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    PDISK_INFORMATION Disk;
    ULONG64 FirstUsableLBA;
    ULONG64 LastUsableLBA;
    ULONG64 PartitionBlocks;
    ULONG32 MaxPartitionCount;


    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );
    ASSERT ( DiskInfo != NULL );

    //
    // Initialization
    //

    Disk = NULL;

    Status = FstubAllocateDiskInformation (
                    DeviceObject,
                    &Disk,
                    NULL
                    );

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    ASSERT ( Disk != NULL );

    //
    // Write the EFI MBR to the disk.
    //

    Status = FstubWriteBootSectorEFI ( Disk );

    if ( !NT_SUCCESS (Status) ) {
        FstubFreeDiskInformation ( Disk );
        Disk = NULL;
        return Status;
    }

    MaxPartitionCount = DiskInfo->MaxPartitionCount;

    FstubAdjustPartitionCount (
            Disk->SectorSize,
            &MaxPartitionCount
            );

    //
    // Initialize the start of partitionable space and the length of
    // partitionable space on this drive.
    //

    PartitionBlocks = ( MaxPartitionCount * PARTITION_ENTRY_SIZE ) / Disk->SectorSize;

    FirstUsableLBA = PartitionBlocks + 2;
    LastUsableLBA = Disk->SectorCount - ( PartitionBlocks + 1 );

    KdPrintEx((DPFLTR_FSTUB_ID,
               DPFLTR_TRACE_LEVEL,
               "FSTUB: Disk Information\n"
                   "    SectorCount: %I64x\n\n",
               Disk->SectorCount));


    //
    // Write the primary partition table.
    //

    Status = FstubWritePartitionTableEFI (
                    Disk,
                    DiskInfo->DiskId,
                    MaxPartitionCount,
                    FirstUsableLBA,
                    LastUsableLBA,
                    PRIMARY_PARTITION_TABLE,
                    0,
                    NULL
                    );

    if (NT_SUCCESS (Status)) {

        //
        // Write the backup partition table.
        //

        Status = FstubWritePartitionTableEFI (
                        Disk,
                        DiskInfo->DiskId,
                        MaxPartitionCount,
                        FirstUsableLBA,
                        LastUsableLBA,
                        BACKUP_PARTITION_TABLE,
                        0,
                        NULL
                        );
    }


    FstubFreeDiskInformation ( Disk );

    return Status;
}



NTSTATUS
FstubCreateDiskMBR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCREATE_DISK_MBR DiskInfo
    )

/*++

Routine Description:

    Create an empty MBR partition table on the disk. Note
    that when creating an empty MBR disk, we do not overwrite
    the bootstrapping code at the beginning of the MBR.

Arguments:

    DeviceObject - The device that should 

Return Value:

    NTSTATUS code

--*/


{
    NTSTATUS Status;
    PDISK_INFORMATION Disk;
    PMASTER_BOOT_RECORD Mbr;
    

    PAGED_CODE ();
    ASSERT ( DeviceObject != NULL );

    //
    // Initialization
    //
    
    Disk = NULL;
    
    Status = FstubAllocateDiskInformation (
                    DeviceObject,
                    &Disk,
                    NULL
                    );

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Status = FstubReadSector (
                Disk->DeviceObject,
                Disk->SectorSize,
                0,
                Disk->ScratchBuffer
                );

    if ( !NT_SUCCESS ( Status ) ) {
        goto done;
    }

    Mbr = (PMASTER_BOOT_RECORD) Disk->ScratchBuffer;

    //
    // Zero out all partition entries, set the AA55 signature
    // and set the NTFT signature.
    //
    
    RtlZeroMemory (&Mbr->Partition, sizeof (Mbr->Partition)); 
    Mbr->Signature = MBR_SIGNATURE;
    Mbr->DiskSignature = DiskInfo->Signature;

    //
    // Then write the sector back to the drive.
    //
    
    Status = FstubWriteSector (
                Disk->DeviceObject,
                Disk->SectorSize,
                0,
                Mbr
                );

done:

    if ( Disk ) {
        FstubFreeDiskInformation ( Disk );
        Disk = NULL;
    }

    return Status;
}



NTSTATUS
FstubCreateDiskRaw(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Erase all partition information from the disk.

Arguments:

    DeviceObject - Device object representing a disk to remove
            partition table from.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDISK_INFORMATION Disk;
    PMASTER_BOOT_RECORD Mbr;
    PARTITION_STYLE PartitionStyle;
    

    PAGED_CODE ();
    ASSERT ( DeviceObject != NULL );

    //
    // Initialization
    //
    
    Disk = NULL;
    
    Status = FstubAllocateDiskInformation (
                    DeviceObject,
                    &Disk,
                    NULL
                    );

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Figure out whether this is an MBR or GPT disk.
    //
    
    Status = FstubDetectPartitionStyle (
                        Disk,
                        &PartitionStyle
                        );

    if (!NT_SUCCESS (Status)) {
        goto done;
    }
                        
    Status = FstubReadSector (
                Disk->DeviceObject,
                Disk->SectorSize,
                0,
                Disk->ScratchBuffer
                );

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    Mbr = (PMASTER_BOOT_RECORD) Disk->ScratchBuffer;

    //
    // Zero out all partition entries, the AA55 signature
    // and the NTFT disk signature.
    //
    
    RtlZeroMemory (&Mbr->Partition, sizeof (Mbr->Partition)); 
    Mbr->Signature = 0;
    Mbr->DiskSignature = 0;

    //
    // Then write the sector back to the drive.
    //
    
    Status = FstubWriteSector (
                Disk->DeviceObject,
                Disk->SectorSize,
                0,
                Mbr
                );

    //
    // If this was a GPT disk, we null out the primary and backup partition
    // table header.
    //
    
    if (PartitionStyle == PARTITION_STYLE_GPT) {

        RtlZeroMemory (Disk->ScratchBuffer, Disk->SectorSize);

        //
        // Erase the primary partition table header.
        //
        
        Status = FstubWriteSector (
                        Disk->DeviceObject,
                        Disk->SectorSize,
                        1,
                        Disk->ScratchBuffer
                        );

        if (!NT_SUCCESS (Status)) {
            goto done;
        }

        //
        // Erase the backup partition table header.
        //
        
        Status = FstubWriteSector (
                        Disk->DeviceObject,
                        Disk->SectorSize,
                        Disk->SectorCount - 1,
                        Disk->ScratchBuffer
                        );
    }

done:

    if (Disk) {
        FstubFreeDiskInformation (Disk);
        Disk = NULL;
    }

    return Status;
}

    
    


VOID
FstubCopyEntryEFI(
    OUT PEFI_PARTITION_ENTRY Entry,
    IN PPARTITION_INFORMATION_EX Partition,
    IN ULONG SectorSize
    )
{
    ULONG64 StartingLBA;
    ULONG64 EndingLBA;

    PAGED_CODE ();

    ASSERT ( Entry != NULL );
    ASSERT ( Partition != NULL );
    ASSERT ( SectorSize != 0 );

    //
    // Translate and copy the Starting and Ending LBA.
    //

    StartingLBA = Partition->StartingOffset.QuadPart / SectorSize;
    EndingLBA = Partition->StartingOffset.QuadPart + Partition->PartitionLength.QuadPart - 1;
    EndingLBA /= (ULONG64) SectorSize;

    Entry->StartingLBA = StartingLBA;
    Entry->EndingLBA = EndingLBA;

    //
    // Copy the Type and Id GUIDs. Copy the attributes.
    //

    Entry->PartitionType = Partition->Gpt.PartitionType;
    Entry->UniquePartition = Partition->Gpt.PartitionId;
    Entry->Attributes = Partition->Gpt.Attributes;

    //
    // Copy the partition name.
    //

    RtlCopyMemory (
            Entry->Name,
            Partition->Gpt.Name,
            sizeof (Entry->Name)
            );
}



NTSTATUS
FstubWritePartitionTableEFI(
    IN PDISK_INFORMATION Disk,
    IN GUID DiskGUID,
    IN ULONG32 MaxPartitionCount,
    IN ULONG64 FirstUsableLBA,
    IN ULONG64 LastUsableLBA,
    IN ULONG PartitionTable,
    IN ULONG PartitionCount,
    IN PPARTITION_INFORMATION_EX PartitionArray
    )

/*++

Routine Description:

    Write an EFI partition table to the disk.

Arguments:

    Disk - The disk we want to write the partition table to.

    MaxPartitionCount -

    FirstUsableLBA -

    LastUsableLBA -

    PartitionTable - Which partition table to write to, either the primary
            partition table or the backup partition table.

    PartitionCount - The count of partitions in the partiton array.
            Partitions entries 0 through PartitionCount - 1 will be
            initialized from the array.  Partition entries PartitionCount
            through MaxPartitionCount will be initialized to null.

    PartitionArray - The array of partition entries to be written to disk.
            The value can be NULL only if PartitionCount is 0. In that case
            we will write an empty partition array.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    ULONG i;
    ULONG EntrySlot;
    ULONG TableSectorCount;
    ULONG SectorSize;
    ULONG32 CheckSum;
    EFI_PARTITION_ENTRY Entry;


    PAGED_CODE ();

    ASSERT ( Disk != NULL );


    SectorSize = Disk->SectorSize;

    ASSERT ( MaxPartitionCount >= 128 );
    ASSERT ( PartitionCount <= MaxPartitionCount );

    //
    // TableSectorCount is the number of blocks that the partition table
    // occupies.
    //

    TableSectorCount =
        ( PARTITION_ENTRY_SIZE * MaxPartitionCount + SectorSize - 1 ) / SectorSize;

    //
    // Write the partition table entry array before writing the partition
    // table header so we can calculate the checksum along the way.
    //

    CheckSum = 0;
    EntrySlot = 0;

    //
    // First, copy all non-NULL entries.
    //

    for (i = 0; i < PartitionCount ; i++) {

        //
        // Do not write NULL entries to disk. Note that this does not
        // prevent other tools from writing valid, NULL entries to the
        // drive. It just prevents us from doing it.
        //

        if ( IS_NULL_GUID ( PartitionArray [ i ].Gpt.PartitionType) ) {
            continue;
        }

        FstubCopyEntryEFI ( &Entry, &PartitionArray [i], SectorSize );
        Status = FstubWriteEntryEFI (
                                Disk,
                                TableSectorCount,
                                EntrySlot,
                                &Entry,
                                PartitionTable,
                                FALSE,
                                &CheckSum
                                );

        if ( !NT_SUCCESS (Status) ) {
            return Status;
        }

        EntrySlot++;
    }

    //
    // Next, copy all NULL entries at the end.
    //

    for (i = EntrySlot; i < MaxPartitionCount; i++) {

        RtlZeroMemory (&Entry, sizeof (Entry));

        Status = FstubWriteEntryEFI (
                                Disk,
                                TableSectorCount,
                                i,
                                &Entry,
                                PartitionTable,
                                FALSE,
                                &CheckSum
                                );

        if ( !NT_SUCCESS (Status) ) {
            return Status;
        }
    }

    //
    // Write the partition table header to disk.
    //

    Status = FstubWriteHeaderEFI (
                        Disk,
                        TableSectorCount,
                        DiskGUID,
                        MaxPartitionCount,
                        FirstUsableLBA,
                        LastUsableLBA,
                        CheckSum,
                        PartitionTable
                        );

    return Status;
}



NTSTATUS
FstubReadHeaderEFI(
    IN PDISK_INFORMATION Disk,
    IN ULONG PartitionTable,
    OUT PEFI_PARTITION_HEADER* HeaderBuffer
    )

/*++

Routine Description:

    Read in and validate the EFI partition table header.

    The algorithm for validating the partition table header is as follows:

      1) Check the Partitin Table Signature, Revision and Size.

      2) Check the Partition Table CRC.

      3) Check that the MyLBA entry to the LBA that contains the Partition
         Table.

      4) Check that the CRC of the partition Entry Array is correct.

Arguments:

    Disk - The disk to read the EFI partition table header from.

    PartitionTable - Whether to read the primary or backup partition table.

    HeaderBuffer - Pointer to a buffer when the header table pointer will be
            copied on success. Note that, the header table is physically
            stored in the disk's scratch buffer.

Return Values:

    STATUS_SUCCESS - If the header was successfully read.

    STATUS_DISK_CORRUPT_ERROR - If the specified header is invalid and/or
            corrupt.

    NTSTATUS code - For other errors.

--*/

{
    NTSTATUS Status;
    ULONG64 MyLBA;
    ULONG64 AlternateLBA;
    ULONG32 CheckSum;
    ULONG32 Temp;
    ULONG FullSectorCount;
    ULONG MaxPartitionCount;
    PVOID Buffer;
    ULONG i;
    ULONG PartialSectorEntries;
    PEFI_PARTITION_HEADER Header;


    PAGED_CODE ();

    ASSERT ( Disk != NULL );
    ASSERT ( IS_VALID_DISK_INFO ( Disk ) );
    ASSERT ( HeaderBuffer != NULL );


    //
    // Initialization
    //

    Buffer = NULL;
    *HeaderBuffer = NULL;


    if ( PartitionTable == PRIMARY_PARTITION_TABLE) {
        MyLBA = 1;
        AlternateLBA = Disk->SectorCount - 1;
    } else {
        MyLBA = Disk->SectorCount - 1;
        AlternateLBA = 1;
    }

    //
    // Read in the primary partition table header.
    //

    Status = FstubReadSector (
                Disk->DeviceObject,
                Disk->SectorSize,
                MyLBA,
                Disk->ScratchBuffer
                );

    if ( !NT_SUCCESS ( Status ) ) {
        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_WARNING_LEVEL,
                   "FSTUB: Could not read sector %I64x\n",
                   MyLBA));

        goto done;
    }

    Header = (PEFI_PARTITION_HEADER) Disk->ScratchBuffer;


    //
    // Check Signature, Revision and size.
    //

    if ( Header->Signature != EFI_PARTITION_TABLE_SIGNATURE ||
         Header->Revision != EFI_PARTITION_TABLE_REVISION ||
         Header->HeaderSize != sizeof (EFI_PARTITION_HEADER) ) {

        Status = STATUS_DISK_CORRUPT_ERROR;
        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_WARNING_LEVEL,
                   "FSTUB: Partition Header Invalid\n"
                       "       Header Signature / Revision / Size mismatch\n"));

        goto done;
    }


    //
    // Check the partition table CRC. The assumption here is that the
    // CRC is computed with a value of 0 for the HeaderCRC field.
    //

    Temp = Header->HeaderCRC32;
    Header->HeaderCRC32 = 0;
    CheckSum = RtlComputeCrc32 ( 0, Header, Header->HeaderSize );
    Header->HeaderCRC32 = Temp;


    if (CheckSum != Header->HeaderCRC32) {
        Status = STATUS_DISK_CORRUPT_ERROR;
        goto done;
    }

    //
    // Validate the MyLBA.
    //

    //
    // NB: We CANNOT validate AlternateLBA here. If we do, then when a disk
    // is grown or shrunk we will fail.
    //

    if ( Header->MyLBA != MyLBA ) {

        Status = STATUS_DISK_CORRUPT_ERROR;
        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_WARNING_LEVEL,
                   "FSTUB: Partition Header Invalid\n"
                       "       MyLBA or AlternateLBA is incorrect\n"));

        goto done;
    }

    //
    // Read and CRC the Partition Entry Array.
    //

    //
    // First we read and checksum all full sectors.
    //

    FullSectorCount = Header->NumberOfEntries * PARTITION_ENTRY_SIZE;
    FullSectorCount /= Disk->SectorSize;

    Buffer = ExAllocatePoolWithTag (
                    NonPagedPool,
                    Disk->SectorSize,
                    FSTUB_TAG
                    );

    if ( Buffer == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    CheckSum = 0;

    for (i = 0; i < FullSectorCount; i++) {

        Status = FstubReadSector (
                        Disk->DeviceObject,
                        Disk->SectorSize,
                        Header->PartitionEntryLBA + i,
                        Buffer
                        );

        if (!NT_SUCCESS (Status)) {
            goto done;
        }

        CheckSum = RtlComputeCrc32 (
                        CheckSum,
                        Buffer,
                        Disk->SectorSize
                        );
    }


    //
    // Next we read and checksum the final, partial sector. Note that this
    // is not very likely to ever get executed. The way we write the partition
    // table, it will never contain partial sectors as a part of the partition
    // array.
    //

    PartialSectorEntries = Header->NumberOfEntries * PARTITION_ENTRY_SIZE;
    PartialSectorEntries %= FullSectorCount;

    if ( PartialSectorEntries ) {

        //
        // Read the remaining sector which contains some partition entries.
        //

        Status = FstubReadSector (
                        Disk->DeviceObject,
                        Disk->SectorSize,
                        Header->PartitionEntryLBA + FullSectorCount,
                        Buffer
                        );

        if (!NT_SUCCESS (Status)) {
            goto done;
        }

        for (i = 0; i < PartialSectorEntries; i++) {

            CheckSum = RtlComputeCrc32 (
                            CheckSum,
                            &(((PEFI_PARTITION_ENTRY)Buffer)[ i ]),
                            Disk->SectorSize
                            );
        }
    }

    if ( Header->PartitionEntryCRC32 != CheckSum ) {

        Status = STATUS_DISK_CORRUPT_ERROR;
        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_WARNING_LEVEL,
                   "FSTUB: Partition Table Invalid\n"
                       "       Partition Array CRC invalid\n"));

        goto done;
    }

    *HeaderBuffer = Header;
    Status = STATUS_SUCCESS;

done:

    if ( Buffer != NULL ) {
        ExFreePool ( Buffer );
        Buffer = NULL;
    }

    if (!NT_SUCCESS (Status)) {
        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_ERROR_LEVEL,
                   "FSTUB: %s EFI Partition table is bad.\n",
                   PartitionTable == PRIMARY_PARTITION_TABLE ?
                       "Primary" : "Backup"));
    }

    return Status;
}



NTSTATUS
FstubReadPartitionTableEFI(
    IN PDISK_INFORMATION Disk,
    IN ULONG PartitionTable,
    OUT PDRIVE_LAYOUT_INFORMATION_EX* ReturnedDriveLayout
    )

/*++

Routine Description:

    This routine is called to read the partition table on an EFI-partitioned
    disk.

Arguments:

    Disk - The disk we should read the partition table from.

    PartitionTable - Which partition table to read, the primary or backup
            table.

    ReturnedDriveLayout - Pointer to pointer to the buffer where
            the partition information will be stored.

Return Values:

    STATUS_SUCCESS - If the partition table information was succesfully read
            into ReturnedDriveLayoutInformation.

    Otherwise - Failure.

Notes:

    The memory allocated by this routine must be free by the caller using
    ExFreePool().

--*/

{
    NTSTATUS Status;
    ULONG i;
    ULONG j;
    ULONG PartitionCount;
    ULONG CurrentSector;
    ULONG SectorNumber;
    ULONG SectorIndex;
    PVOID Block;
    ULONG MaxPartitionCount;
    ULONG DriveLayoutSize;
    ULONG PartitionsPerBlock;
    PEFI_PARTITION_ENTRY EntryArray;
    PEFI_PARTITION_ENTRY Entry;
    PEFI_PARTITION_HEADER Header;
    PDRIVE_LAYOUT_INFORMATION_EX DriveLayout;
    PPARTITION_INFORMATION_EX PartitionInfo;
    ULONG64 PartitionEntryLBA;


    PAGED_CODE ();

    ASSERT ( Disk != NULL );

    //
    // Initialization
    //

    DriveLayout = NULL;


    //
    // Read the partition table header.
    //

    Status = FstubReadHeaderEFI ( Disk, PartitionTable, &Header );

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // Allocate space the maximum number of EFI partitions on this drive.
    //

    MaxPartitionCount = Header->NumberOfEntries;

    DriveLayoutSize = FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[0]) +
                      MaxPartitionCount * sizeof (PARTITION_INFORMATION_EX);

    DriveLayout = ExAllocatePoolWithTag ( NonPagedPool,
                                          DriveLayoutSize,
                                          FSTUB_TAG
                                          );
    if ( DriveLayout == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }


    //
    // Copy the EFI disk layout information.
    //

    DriveLayout->PartitionStyle = PARTITION_STYLE_GPT;

    DriveLayout->Gpt.StartingUsableOffset.QuadPart =
            Header->FirstUsableLBA * Disk->SectorSize;
    DriveLayout->Gpt.UsableLength.QuadPart =
            (Header->LastUsableLBA - Header->FirstUsableLBA) * Disk->SectorSize;
    DriveLayout->Gpt.MaxPartitionCount = MaxPartitionCount;

    RtlCopyMemory (
            &DriveLayout->Gpt.DiskId,
            &Header->DiskGUID,
            sizeof (GUID)
            );

    //
    // Read in each block that contains entries in the partition table
    // array, then iterate through the partition table array and map
    // each EFI_PARTITION_ENTRY structure into an PARTITION_INFORMATION_GPT
    // structure.
    //

    PartitionEntryLBA = Header->PartitionEntryLBA;
    Header = NULL;
    EntryArray = (PEFI_PARTITION_ENTRY) Disk->ScratchBuffer;
    PartitionCount = 0;
    CurrentSector = -1;
    PartitionsPerBlock = (ULONG) (Disk->SectorSize / PARTITION_ENTRY_SIZE);

    for (i = 0; i < MaxPartitionCount; i++) {

        SectorNumber = i / PartitionsPerBlock ;
        SectorIndex = i % PartitionsPerBlock ;

        //
        // If we have a sector other than the current sector read in,
        // read in the current sector at this time.
        //

        if ( SectorNumber != CurrentSector ) {

            Status = FstubReadSector (
                            Disk->DeviceObject,
                            Disk->SectorSize,
                            PartitionEntryLBA + SectorNumber,
                            EntryArray
                            );

            if ( !NT_SUCCESS (Status) ) {
                goto done;
            }

            CurrentSector = SectorNumber;
        }

        Entry = &EntryArray[ SectorIndex ];

        //
        // We ignore NULL entries in the partition table. NOTE: Is this
        // dangerous?
        //

        if ( IS_NULL_GUID (Entry->PartitionType ) ) {
            continue;
        }

        //
        // Copy the data into the EFI partition array.
        //

        PartitionInfo = &DriveLayout->PartitionEntry[PartitionCount];

        PartitionInfo->StartingOffset.QuadPart = Entry->StartingLBA;
        PartitionInfo->StartingOffset.QuadPart *= (ULONG64) Disk->SectorSize;
        PartitionInfo->PartitionLength.QuadPart =
                (Entry->EndingLBA - Entry->StartingLBA) + 1;
                
        PartitionInfo->PartitionLength.QuadPart *= (ULONG64) Disk->SectorSize;
        PartitionInfo->PartitionStyle = PARTITION_STYLE_GPT;

        PartitionInfo->Gpt.PartitionType = Entry->PartitionType;
        PartitionInfo->Gpt.PartitionId = Entry->UniquePartition;
        PartitionInfo->Gpt.Attributes = Entry->Attributes;

        RtlCopyMemory (PartitionInfo->Gpt.Name,
                       Entry->Name,
                       sizeof (PartitionInfo->Gpt.Name)
                       );

        PartitionInfo->RewritePartition = FALSE;

        //
        // The PartitionNumber field of PARTITION_INFORMATION_EX is
        // not initialized by us. Instead, it is initialized in the
        // calling driver
        //


        PartitionInfo->PartitionNumber = -1;
        PartitionCount++;
    }

    //
    // Fill in the remaining fields of the DRIVE_LAYOUT structure.
    //

    DriveLayout->PartitionCount = PartitionCount;


done:

    //
    // Free all resources
    //

    if (!NT_SUCCESS (Status)) {

        //
        // DriveLayout is not being returned, so deallocate it if it has
        // be allocated.
        //

        if ( DriveLayout ) {
            ExFreePool (DriveLayout);
            DriveLayout = NULL;
        }

        *ReturnedDriveLayout = NULL;

    } else {

        *ReturnedDriveLayout = DriveLayout;
        DriveLayout = NULL;
    }

    return Status;
}


NTSTATUS
FstubVerifyPartitionTableEFI(
    IN PDISK_INFORMATION Disk,
    IN BOOLEAN FixErrors
    )

/*++

Routine Description:

    Verify that a partition table is correct.

Arguments:

    Disk - The disk whose partition table(s) should be verified.

    FixErrors - If, TRUE, this routine attempts to fix any errors in the
            partition table. Otherwise, this routine only checkes whether
            there are errrors in the partition table, "read only".

Return Value:

    STATUS_SUCCESS - If the final partition table, after any changes (only
            when FixErrors is TRUE), is valid.

    STATUS_DISK_CORRUPT - If the final partition table, after any changes (only
            when FixErrors is TRUE) is not valid.

    Other NTSTATUS code - Other type of failure.

--*/


{
    NTSTATUS Status;
    ULONG64 i;
    ULONG64 SourceStartingLBA;
    ULONG64 DestStartingLBA;
    ULONG SectorCount;
    BOOLEAN PrimaryValid;
    BOOLEAN BackupValid;
    ULONG GoodTable;
    ULONG BadTable;
    PEFI_PARTITION_HEADER Header;
    PEFI_PARTITION_HEADER GoodHeader;


    PAGED_CODE ();

    //
    // Initialization
    //

    Header = NULL;
    GoodHeader = NULL;
    PrimaryValid = FALSE;
    BackupValid = FALSE;

    GoodHeader = ExAllocatePoolWithTag (
            NonPagedPool,
            sizeof (EFI_PARTITION_HEADER),
            FSTUB_TAG
            );

    if ( GoodHeader == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = FstubReadHeaderEFI (
                        Disk,
                        PRIMARY_PARTITION_TABLE,
                        &Header
                        );

    if ( NT_SUCCESS (Status) ) {

        PrimaryValid = TRUE;
        ASSERT (Header != NULL);
        RtlCopyMemory (GoodHeader,
                       Header,
                       sizeof (EFI_PARTITION_HEADER)
                       );
    }


    Status = FstubReadHeaderEFI (
                        Disk,
                        BACKUP_PARTITION_TABLE,
                        &Header
                        );

    if ( NT_SUCCESS (Status) ) {

        BackupValid = TRUE;
        ASSERT (Header != NULL);
        RtlCopyMemory (GoodHeader,
                       Header,
                       sizeof (EFI_PARTITION_HEADER)
                       );
    }

    //
    // If both primary and backup partition tables are valid, return success.
    //

    if ( PrimaryValid && BackupValid ) {
        Status = STATUS_SUCCESS;
        goto done;
    }

    //
    // If both primary and backup partition tables are bad, return failure.

    if ( !PrimaryValid && !BackupValid ) {
        Status = STATUS_DISK_CORRUPT_ERROR;
        goto done;
    }

    //
    // If one of the partition tables is bad, and we were not instructed to
    // fix it, return failure.
    //

    if ( !FixErrors ) {
        Status = STATUS_DISK_CORRUPT_ERROR;
        goto done;
    }

    //
    // If we've reached this point, one or the other of the tables is
    // bad and we've been instructed to fix it.
    //

    ASSERT ( GoodHeader != NULL );

    //
    // SectorCount is the number of sectors occupied by the partition table.
    //

    SectorCount = ( PARTITION_ENTRY_SIZE * Header->NumberOfEntries + Disk->SectorSize - 1 ) / Disk->SectorSize;

    if ( PrimaryValid ) {

        GoodTable = PRIMARY_PARTITION_TABLE;
        BadTable = BACKUP_PARTITION_TABLE;
        SourceStartingLBA = 2;
        DestStartingLBA = Disk->SectorCount - SectorCount - 1;

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_ERROR_LEVEL,
                   "FSTUB: Restoring backup partition table from primary\n"));

    } else {

        ASSERT ( BackupValid );
        GoodTable = BACKUP_PARTITION_TABLE;
        BadTable = PRIMARY_PARTITION_TABLE;
        SourceStartingLBA = Disk->SectorCount - SectorCount - 1;
        DestStartingLBA = 2;

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_ERROR_LEVEL,
                   "FSTUB: Restoring primary partition table from backup\n"));
    }

    //
    // First copy the good partition table array over the bad partition table
    // array. This does not need to be checksummed since the checksum in
    // the good header will still be valid for this one.
    //

    for (i = 0; i < SectorCount; i++) {

        Status = FstubReadSector (
                        Disk->DeviceObject,
                        Disk->SectorSize,
                        SourceStartingLBA + i,
                        Disk->ScratchBuffer
                        );

        if ( !NT_SUCCESS (Status) ) {
            goto done;
        }

        Status = FstubWriteSector (
                        Disk->DeviceObject,
                        Disk->SectorSize,
                        DestStartingLBA + i,
                        Disk->ScratchBuffer
                        );

        if ( !NT_SUCCESS (Status) ) {
            goto done;
        }
    }

    //
    // Next, write out the header.
    //

    Status = FstubWriteHeaderEFI (
                Disk,
                SectorCount,
                GoodHeader->DiskGUID,
                GoodHeader->NumberOfEntries,
                GoodHeader->FirstUsableLBA,
                GoodHeader->LastUsableLBA,
                GoodHeader->PartitionEntryCRC32,
                BadTable
                );

done:

    if ( GoodHeader ) {
        ExFreePool ( GoodHeader );
        GoodHeader = NULL;
    }

    return Status;
}


NTSTATUS
FstubUpdateDiskGeometryEFI(
    IN PDISK_INFORMATION OldDisk,
    IN PDISK_INFORMATION NewDisk
    )

/*++

Routine Description:

    When a disk is grown or shrunk this API needs to be called to properly
    update the EFI partition tables. In particular, the backup partition table
    needs to be moved to be at the end of the disk.

Algorithm:

    We read in the old partition table, updat the size of the disk, then
    write out the new partition table given the changed disk size.

Arguments:

    OldDisk - A disk information object representing the old geometry.

    NewDisk - A disk information object representing the new goemetry.

Return Values:

    NTSTATUS Code.

--*/

{
    NTSTATUS Status;
    ULONG64 i;
    ULONG64 SourceStartingLBA;
    ULONG64 DestStartingLBA;
    ULONG SectorCount;
    PEFI_PARTITION_HEADER Header;


    PAGED_CODE ();

    //
    // Initialization
    //

    Header = NULL;

    Status = FstubReadHeaderEFI (
                        OldDisk,
                        BACKUP_PARTITION_TABLE,
                        &Header
                        );

    if ( !NT_SUCCESS (Status) ) {
        return Status;
    }

    //
    // SectorCount is the number of sectors occupied by the partition table.
    //

    SectorCount = ( PARTITION_ENTRY_SIZE * Header->NumberOfEntries + OldDisk->SectorSize - 1 ) / OldDisk->SectorSize;


    //
    // Write the partition table header for the primary partition table. Note
    // that the primary partition table does not need to be moved since it
    // is at the beginning of the disk.
    //

    Status = FstubWriteHeaderEFI (
                NewDisk,
                SectorCount,
                Header->DiskGUID,
                Header->NumberOfEntries,
                Header->FirstUsableLBA,
                Header->LastUsableLBA,
                Header->PartitionEntryCRC32,
                PRIMARY_PARTITION_TABLE
                );

    //
    // Write the partition table header for the backup table.
    //

    Status = FstubWriteHeaderEFI (
                NewDisk,
                SectorCount,
                Header->DiskGUID,
                Header->NumberOfEntries,
                Header->FirstUsableLBA,
                Header->LastUsableLBA,
                Header->PartitionEntryCRC32,
                BACKUP_PARTITION_TABLE
                );


    if ( !NT_SUCCESS (Status) ) {
        return Status;
    }

    //
    // Calculate the location of the backup table.
    //

    SourceStartingLBA = OldDisk->SectorCount - SectorCount - 1;
    DestStartingLBA = NewDisk->SectorCount - SectorCount - 1;

    //
    // And write the backup table.
    //

    for (i = 0; i < SectorCount; i++) {

        Status = FstubReadSector (
                        OldDisk->DeviceObject,
                        OldDisk->SectorSize,
                        SourceStartingLBA + i,
                        OldDisk->ScratchBuffer
                        );

        if ( !NT_SUCCESS (Status) ) {
            return Status;
        }

        Status = FstubWriteSector (
                        NewDisk->DeviceObject,
                        NewDisk->SectorSize,
                        DestStartingLBA + i,
                        OldDisk->ScratchBuffer
                        );
        if ( !NT_SUCCESS (Status) ) {
            return Status;
        }
    }


#if DBG

    //
    // Make a sanity check that we actually did this correctly.
    //

    Status = FstubVerifyPartitionTableEFI ( NewDisk, FALSE );
    ASSERT ( NT_SUCCESS ( Status ) );

#endif

    return Status;
}



NTSTATUS
FstubWriteSector(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG64 SectorNumber,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Read a sector from the device DeviceObject.

Arguments:

    DeviceObject - The object representing the device.

    SectorSize - The size of one sector on the device.

    SectorNumber - The sector number to write.

    Buffer - The buffer to write. The buffer must be of size SectorSize.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    IO_STATUS_BLOCK IoStatus;
    PIO_STACK_LOCATION IrpStack;
    KEVENT Event;
    LARGE_INTEGER Offset;


    PAGED_CODE ();

    ASSERT ( DeviceObject );
    ASSERT ( Buffer );
    ASSERT ( SectorSize != 0 );


    Offset.QuadPart = (SectorNumber * SectorSize);
    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    Irp = IoBuildSynchronousFsdRequest ( IRP_MJ_WRITE,
                                         DeviceObject,
                                         Buffer,
                                         SectorSize,
                                         &Offset,
                                         &Event,
                                         &IoStatus
                                         );

    if ( Irp == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IrpStack = IoGetNextIrpStackLocation (Irp);
    IrpStack->Flags |= SL_OVERRIDE_VERIFY_VOLUME;

    Status = IoCallDriver( DeviceObject, Irp );


    if (Status == STATUS_PENDING) {

        Status = KeWaitForSingleObject (
                                &Event,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL
                                );

        Status = IoStatus.Status;
    }

    return Status;
}



NTSTATUS
FstubReadSector(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG64 SectorNumber,
    OUT PVOID Buffer
    )

/*++

Routine Description:

    Read a logical block from the device (disk).

Arguments:

    DeviceObject - The device that we are going to read from.

    SectorSize - The size of the block and the size of the Buffer.

    SectorNumber - The Logical Block Number we are going to read.

    Buffer - The buffer into which we are going to read the block.


Return Values:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    IO_STATUS_BLOCK IoStatus;
    PIO_STACK_LOCATION IrpStack;
    KEVENT Event;
    LARGE_INTEGER Offset;

    PAGED_CODE ();

    ASSERT ( DeviceObject );
    ASSERT ( Buffer );
    ASSERT ( SectorSize != 0 );


    Offset.QuadPart = (SectorNumber * SectorSize);
    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    Irp = IoBuildSynchronousFsdRequest ( IRP_MJ_READ,
                                         DeviceObject,
                                         Buffer,
                                         SectorSize,
                                         &Offset,
                                         &Event,
                                         &IoStatus
                                         );

    if ( Irp == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IrpStack = IoGetNextIrpStackLocation (Irp);
    IrpStack->Flags |= SL_OVERRIDE_VERIFY_VOLUME;

    Status = IoCallDriver( DeviceObject, Irp );

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject ( &Event,
                                Executive,
                                KernelMode,
                                FALSE,
                                NULL
                                );
        Status = IoStatus.Status;
    }

    return Status;
}



//
// Debugging functions.
//

#if DBG

PCHAR
FstubDbgGuidToString(
    IN GUID* Guid,
    PCHAR StringBuffer
    )
{
    sprintf (StringBuffer,
            "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
            Guid->Data1,
            Guid->Data2,
            Guid->Data3,
            Guid->Data4[0],
            Guid->Data4[1],
            Guid->Data4[2],
            Guid->Data4[3],
            Guid->Data4[4],
            Guid->Data4[5],
            Guid->Data4[6],
            Guid->Data4[7]
            );

    return StringBuffer;
}


VOID
FstubDbgPrintSetPartitionEx(
    IN PSET_PARTITION_INFORMATION_EX SetPartition,
    IN ULONG PartitionNumber
    )

/*++

Routine Description:

    Print contents of the SET_PARTITION_INFORMATION structure to the
    debugger.

Arguments:

    SetPartition - A valid SET_PARTITION_INFORMATION_EX structure.

Return Value:

    None.

Mode:

    Checked build only.

--*/

{
    CHAR GuidStringBuffer [40];


    PAGED_CODE ();


    KdPrintEx((DPFLTR_FSTUB_ID,
               FSTUB_VERBOSE_LEVEL,
               "\n"
                   "FSTUB:\n"
                   "SET_PARTITION_INFORMATION_EX %p\n"));

    if ( SetPartition->PartitionStyle != PARTITION_STYLE_MBR &&
         SetPartition->PartitionStyle != PARTITION_STYLE_GPT ) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "ERROR: PartitionStyle is invalid %d\n",
                   SetPartition->PartitionStyle));
    }

    if ( SetPartition->PartitionStyle == PARTITION_STYLE_MBR ) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "Type: %8.8x\n\n",
                   SetPartition->Mbr.PartitionType));

    } else {


        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "[%d] %ws\n",
                   PartitionNumber,
                   SetPartition->Gpt.Name));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "  ATTR %-16I64x\n",
                   SetPartition->Gpt.Attributes));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "  TYPE %s\n",
                   FstubDbgGuidToString(&SetPartition->Gpt.PartitionType,
                                        GuidStringBuffer)));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "  ID %s\n",
                   FstubDbgGuidToString(&SetPartition->Gpt.PartitionId,
                                        GuidStringBuffer)));

    }

    KdPrintEx((DPFLTR_FSTUB_ID,  FSTUB_VERBOSE_LEVEL, "\n"));
}


VOID
FstubDbgPrintPartition(
    IN PPARTITION_INFORMATION Partition,
    IN ULONG PartitionCount
    )

/*++

Routine Description:

    Print a PARTITION_INFORMATION structure to the debugger.

Arguments:

    Partition - Pointer to a valid PARTITION_INFORMATION structure.

    PartitionCount - The number of partitions in the partition table or
            zero if unknown.

Return Value:

    None.

--*/

{
    ULONG PartitionNumber;

    PAGED_CODE ();

    //
    // Sanity check the data.
    //

    if ( (Partition->BootIndicator != TRUE &&
          Partition->BootIndicator != FALSE) ||
         (Partition->RecognizedPartition != TRUE &&
          Partition->RecognizedPartition != FALSE) ||
         (Partition->RewritePartition != TRUE &&
          Partition->RewritePartition != FALSE) ) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "Invalid partition information at %p\n",
                   Partition));
    }

    if (Partition->PartitionNumber > PartitionCount) {
        PartitionNumber = -1;
    } else {
        PartitionNumber = Partition->PartitionNumber;
    }

    KdPrintEx((DPFLTR_FSTUB_ID,
               FSTUB_VERBOSE_LEVEL,
               "[%-2d] %-16I64x %-16I64x %2.2x   %c  %c  %c\n",
               PartitionNumber,
               Partition->StartingOffset.QuadPart,
               Partition->PartitionLength.QuadPart,
               Partition->PartitionType,
               Partition->BootIndicator ? 'x' : ' ',
               Partition->RecognizedPartition ? 'x' : ' ',
               Partition->RewritePartition ? 'x' : ' '));
}


VOID
FstubDbgPrintDriveLayout(
    IN PDRIVE_LAYOUT_INFORMATION  Layout
    )

/*++

Routine Description:

    Print out a DRIVE_LAYOUT_INFORMATION structure to the debugger.

Arguments:

    Layout - Pointer to a valid DRIVE_LAYOUT_INFORMATION structure.

Return Value:

    None.

Mode:

    Checked build only.

--*/

{
    ULONG i;


    PAGED_CODE ();

    KdPrintEx((DPFLTR_FSTUB_ID,
               FSTUB_VERBOSE_LEVEL,
               "\n"
                   "FSTUB:\n"
                   "DRIVE_LAYOUT %p\n",
               Layout));

    //
    // Warn if the partition count is not a factor of 4. This is probably a
    // bad partition information structure, but we'll continue on anyway.
    //

    if (Layout->PartitionCount % 4 != 0) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "WARNING: Partition count should be a factor of 4.\n"));
    }

    KdPrintEx((DPFLTR_FSTUB_ID,
               FSTUB_VERBOSE_LEVEL,
               "PartitionCount: %d\n",
               Layout->PartitionCount));

    KdPrintEx((DPFLTR_FSTUB_ID,
               FSTUB_VERBOSE_LEVEL,
               "Signature: %8.8x\n\n",
               Layout->Signature));

    KdPrintEx((DPFLTR_FSTUB_ID,
               FSTUB_VERBOSE_LEVEL,
               "    ORD Offset           Length           Type BI RP RW\n"));

    KdPrintEx((DPFLTR_FSTUB_ID,
               FSTUB_VERBOSE_LEVEL,
               "   ------------------------------------------------------------\n"));

    for (i = 0; i < Layout->PartitionCount; i++) {

        FstubDbgPrintPartition (
                &Layout->PartitionEntry[i],
                Layout->PartitionCount
                );
    }

    KdPrintEx((DPFLTR_FSTUB_ID, FSTUB_VERBOSE_LEVEL, "\n"));
}


VOID
FstubDbgPrintPartitionEx(
    IN PPARTITION_INFORMATION_EX PartitionEx,
    IN ULONG PartitionCount
    )

/*++

Routine Description:

    Dump a PARTITION_INFORMATION_EX structure.

Arguments:

    PartitionEx - Pointer to a partition to dump.

    PartitionCount - The number of partitions. This is used to determine
            whether a particular partition ordinal is valid or not.

Return Value:

    None.

--*/
{
    ULONG Style;
    ULONG PartitionNumber;
    CHAR GuidStringBuffer [40];

    PAGED_CODE ();

    Style = PartitionEx->PartitionStyle;

    if (Style != PARTITION_STYLE_MBR &&
        Style != PARTITION_STYLE_GPT) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_ERROR_LEVEL,
                   "ERROR: PartitionStyle is invalid %d for partition %p\n",
                   PartitionEx));

        return;
    }


    //
    // We use -1 to denote an invalid partition ordinal.
    //

    if (PartitionEx->PartitionNumber < PartitionCount) {
        PartitionNumber = PartitionEx->PartitionNumber;
    } else {
        PartitionNumber = -1;
    }

    if (Style == PARTITION_STYLE_MBR) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "  [%-2d] %-16I64x %-16I64x %2.2x   %c  %c  %c\n",
                   PartitionNumber,
                   PartitionEx->StartingOffset.QuadPart,
                   PartitionEx->PartitionLength.QuadPart,
                   PartitionEx->Mbr.PartitionType,
                   PartitionEx->Mbr.BootIndicator ? 'x' : ' ',
                   PartitionEx->Mbr.RecognizedPartition ? 'x' : ' ',
                   PartitionEx->RewritePartition ? 'x' : ' '));
    } else {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "[%-2d] %ws\n",
                   PartitionNumber,
                   PartitionEx->Gpt.Name));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "  OFF %-16I64x LEN %-16I64x ATTR %-16I64x %s\n",
                   PartitionEx->StartingOffset.QuadPart,
                   PartitionEx->PartitionLength.QuadPart,
                   PartitionEx->Gpt.Attributes,
                   PartitionEx->RewritePartition ? "R/W" : ""));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "  TYPE %s\n",
                   FstubDbgGuidToString(&PartitionEx->Gpt.PartitionType,
                                        GuidStringBuffer)));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "  ID %s\n",
                   FstubDbgGuidToString(&PartitionEx->Gpt.PartitionId,
                                        GuidStringBuffer)));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "\n"));
    }
}

VOID
FstubDbgPrintDriveLayoutEx(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutEx
    )

/*++

Routine Description:

    Print the DRIVE_LAYOUT_INFORMATION_EX to the debugger.

Arguments:

    LayoutEx - A pointer to a valid DRIVE_LAYOUT_INFORMATION_EX structure.

Return Value:

    None.

Mode:

    Debugging function. Checked build only.

--*/


{
    ULONG i;
    ULONG Style;
    CHAR GuidStringBuffer[40];

    PAGED_CODE ();

    KdPrintEx((DPFLTR_FSTUB_ID,
               FSTUB_VERBOSE_LEVEL,
               "\n"
                   "FSTUB:\n"
                   "DRIVE_LAYOUT_EX %p\n",
               LayoutEx));

    Style = LayoutEx->PartitionStyle;

    if (Style != PARTITION_STYLE_MBR && Style != PARTITION_STYLE_GPT) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_ERROR_LEVEL,
                   "ERROR: invalid partition style %d for layout %p\n",
                   Style,
                   LayoutEx));
        return;
    }

    if (Style == PARTITION_STYLE_MBR &&
        LayoutEx->PartitionCount % 4 != 0) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   DPFLTR_WARNING_LEVEL,
                   "WARNING: Partition count is not a factor of 4, (%d)\n",
                   LayoutEx->PartitionCount));
    }

    if (Style == PARTITION_STYLE_MBR) {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "Signature: %8.8x\n",
                   LayoutEx->Mbr.Signature));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "PartitionCount %d\n\n",
                   LayoutEx->PartitionCount));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "  ORD Offset           Length           Type BI RP RW\n"));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "------------------------------------------------------------\n"));

    } else {

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "DiskId: %s\n",
                   FstubDbgGuidToString(&LayoutEx->Gpt.DiskId,
                                        GuidStringBuffer)));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "StartingUsableOffset: %I64x\n",
                   LayoutEx->Gpt.StartingUsableOffset.QuadPart));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "UsableLength:  %I64x\n",
                   LayoutEx->Gpt.UsableLength));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "MaxPartitionCount: %d\n",
                   LayoutEx->Gpt.MaxPartitionCount));

        KdPrintEx((DPFLTR_FSTUB_ID,
                   FSTUB_VERBOSE_LEVEL,
                   "PartitionCount %d\n\n",
                   LayoutEx->PartitionCount));
    }


    for (i = 0; i < LayoutEx->PartitionCount; i++) {

        FstubDbgPrintPartitionEx (
                &LayoutEx->PartitionEntry[i],
                LayoutEx->PartitionCount
                );
    }
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fstub\drivesup.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    hanfnc.c

Abstract:

    default handlers for hal functions which don't get handlers
    installed by the hal

--*/

#ifndef _DRIVESUP_H_
#define _DRIVESUP_H_

#define BOOTABLE_PARTITION  0
#define PRIMARY_PARTITION   1
#define LOGICAL_PARTITION   2
#define FT_PARTITION        3
#define OTHER_PARTITION     4

#endif // _DRIVESUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\tunnel.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Tunnel.c

Abstract:

    The tunnel package provides a set of routines that allow compatibility
    with applications that rely on filesystems being able to "hold onto"
    file meta-info for a short period of time after deletion/renaming and
    reinstantiating a new directory entry with that meta-info if a
    create/rename occurs to cause a file of that name to appear again in a
    short period of time.

    Note that this violates POSIX rules. This package should not be used
    on POSIX fileobjects, i.e. fileobjects that have case-sensitive names.

    Entries are keyed by directory and one of the short/long names. An opaque
    rock of information is also associated (create time, last write time, etc.).
    This is expected to vary on a per-filesystem basis.

    A TUNNEL variable should be initialized for every volume in the system
    at mount time. Thereafter, each delete/rename-out should add to the tunnel
    and each create/rename-in should read from the tunnel. Each directory
    deletion should also notify the package so that all associated entries can
    be flushed. The package is responsible for cleaning out aged entries.

    Tunneled information is in the paged pool.

    Concurrent access to the TUNNEL variable is controlled by this package.
    Callers are responsible for synchronizing access to the FsRtlDeleteTunnelCache
    call.

    The functions provided in this package are as follows:

      o  FsRtlInitializeTunnel - Initializes the TUNNEL package (called once per boot)

      o  FsRtlInitializeTunnelCache - Initializes a TUNNEL structure (called once on mount)

      o  FsRtlAddToTunnelCache - Adds a new key/value pair to the tunnel

      o  FsRtlFindInTunnelCache - Finds and returns a key/value from the tunnel

      o  FsRtlDeleteKeyFromTunnelCache - Deletes all entries with a given
           directory key from the tunnel

      o  FsRtlDeleteTunnelCache - Deletes a TUNNEL structure

Author:

    Dan Lovinger     [DanLo]    8-Aug-1995

Revision History:

--*/

#include "FsRtlP.h"

#ifndef INLINE
#define INLINE __inline
#endif

//
//  Registry keys/values for controlling tunneling
//

#define TUNNEL_KEY_NAME           L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\FileSystem"
#define TUNNEL_AGE_VALUE_NAME     L"MaximumTunnelEntryAgeInSeconds"
#define TUNNEL_SIZE_VALUE_NAME    L"MaximumTunnelEntries"
#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(ULONG)) + 64)

//
//  Tunnel expiration paramters (cached once at startup)
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
ULONG   TunnelMaxEntries = 256; // Value for !MmIsThisAnNtAsSystem()
ULONG   TunnelMaxAge = 15;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
//  We use a lookaside list to manage the common size tunnel entry. The common size
//  is contrived to be 128 bytes by adjusting the size we defer for the long name
//  to 16 characters, which is pretty reasonable. If we ever expect to get more than
//  a ULONGLONG data element or common names are observed to become larger, adjusting
//  this may be required.
//

PAGED_LOOKASIDE_LIST    TunnelLookasideList;
#define MAX_LOOKASIDE_DEPTH     256

#define LOOKASIDE_NODE_SIZE     ( sizeof(TUNNEL_NODE) +     \
                                  sizeof(WCHAR)*(8+1+3) +   \
                                  sizeof(WCHAR)*(16) +      \
                                  sizeof(ULONGLONG) )

//
//  Flag bits in the TUNNEL_NODE
//

#define TUNNEL_FLAG_NON_LOOKASIDE    0x1
#define TUNNEL_FLAG_KEY_SHORT        0x2

//
//  A node of tunneled information in the cache
//
//  A TUNNEL is allocated in each VCB and initialized at mount time.
//
//  TUNNEL_NODES are then arranged off of the TUNNEL in a splay tree keyed
//  by DirKey ## Name, where Name is whichever of the names was removed from
//  the directory (short or long). Each node is also timestamped and inserted
//  into a timer queue for age expiration.
//

typedef struct {

    //
    //  Splay links in the Cache tree
    //

    RTL_SPLAY_LINKS      CacheLinks;

    //
    //  List links in the timer queue
    //

    LIST_ENTRY           ListLinks;

    //
    //  Time this entry was created (for constant time insert)
    //

    LARGE_INTEGER        CreateTime;

    //
    //  Directory these names are associated with
    //

    ULONGLONG            DirKey;

    //
    //  Flags for the entry
    //

    ULONG                Flags;

    //
    //  Long/Short names of the file
    //

    UNICODE_STRING       LongName;
    UNICODE_STRING       ShortName;

    //
    //  Opaque tunneled data
    //

    PVOID                TunnelData;
    ULONG                TunnelDataLength;

} TUNNEL_NODE, *PTUNNEL_NODE;

//
//  Internal utility functions
//

NTSTATUS
FsRtlGetTunnelParameterValue (
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG Value);

VOID
FsRtlPruneTunnelCache (
    IN PTUNNEL Cache,
    IN OUT PLIST_ENTRY FreePoolList);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, FsRtlInitializeTunnels)
#pragma alloc_text(PAGE, FsRtlInitializeTunnelCache)
#pragma alloc_text(PAGE, FsRtlAddToTunnelCache)
#pragma alloc_text(PAGE, FsRtlFindInTunnelCache)
#pragma alloc_text(PAGE, FsRtlDeleteKeyFromTunnelCache)
#pragma alloc_text(PAGE, FsRtlDeleteTunnelCache)
#pragma alloc_text(PAGE, FsRtlPruneTunnelCache)
#pragma alloc_text(PAGE, FsRtlGetTunnelParameterValue)
#endif

//
//  Testing and usermode rig support. Define TUNNELTEST to get verbose debugger
//  output on various operations. Define USERTEST to transform the code into
//  a form which can be compiled in usermode for more efficient debugging.
//

#if defined(TUNNELTEST) || defined(KEYVIEW)
VOID DumpUnicodeString(UNICODE_STRING *s);
VOID DumpNode( TUNNEL_NODE *Node, ULONG Indent );
VOID DumpTunnel( TUNNEL *Tunnel );
#define DblHex64(a) (ULONG)((a >> 32) & 0xffffffff),(ULONG)(a & 0xffffffff)
#endif // TUNNELTEST

#ifdef USERTEST
#include <stdio.h>
#undef KeQuerySystemTime
#define KeQuerySystemTime NtQuerySystemTime
#undef ExInitializeFastMutex
#define ExInitializeFastMutex(arg)
#define ExAcquireFastMutex(arg)
#define ExReleaseFastMutex(arg)
#define DbgPrint printf
#undef PAGED_CODE
#define PAGED_CODE()
#endif


INLINE
LONG
FsRtlCompareNodeAndKey (
    TUNNEL_NODE *Node,
    ULONGLONG DirectoryKey,
    PUNICODE_STRING Name
    )
/*++

Routine Description:

    Compare a tunnel node with a key/name pair

Arguments:

    Node              - a tunnel node

    DirectoryKey      - a key value

    Name              - a filename

Return Value:

    Signed comparison result

--*/

{
    return  (Node->DirKey > DirectoryKey ?  1 :
            (Node->DirKey < DirectoryKey ? -1 :
            RtlCompareUnicodeString((FlagOn(Node->Flags, TUNNEL_FLAG_KEY_SHORT) ?
                                        &Node->ShortName : &Node->LongName),
                                    Name,
                                    TRUE)));
}


INLINE
VOID
FsRtlFreeTunnelNode (
    PTUNNEL_NODE Node,
    PLIST_ENTRY FreePoolList OPTIONAL
    )
/*++

Routine Description:

    Free a node

Arguments:

    Node            - a tunnel node to free

    FreePoolList    - optional list to hold freeable pool memory

Return Value:

    None

-*/
{
    if (FreePoolList) {

        InsertHeadList(FreePoolList, &Node->ListLinks);

    } else {

        if (FlagOn(Node->Flags, TUNNEL_FLAG_NON_LOOKASIDE)) {
    
            ExFreePool(Node);
    
        } else {
    
            ExFreeToPagedLookasideList(&TunnelLookasideList, Node);
        }
    }
}


INLINE
VOID
FsRtlEmptyFreePoolList (
    PLIST_ENTRY FreePoolList
    )
/*++

Routine Description:

    Free all pool memory that has been delayed onto a free list.

Arguments:

    FreePoolList    - a list of freeable pool memory

Return Value:

    None

-*/
{
    PTUNNEL_NODE FreeNode;

    while (!IsListEmpty(FreePoolList)) {

        FreeNode = CONTAINING_RECORD(FreePoolList->Flink, TUNNEL_NODE, ListLinks);
        RemoveEntryList(FreePoolList->Flink);

        FsRtlFreeTunnelNode(FreeNode, NULL);
    }
}


INLINE
VOID
FsRtlRemoveNodeFromTunnel (
    IN PTUNNEL Cache,
    IN PTUNNEL_NODE Node,
    IN PLIST_ENTRY FreePoolList,
    IN PBOOLEAN Splay OPTIONAL
    )
/*++

Routine Description:

    Performs the common work of deleting a node from a tunnel cache. Pool memory
    is not deleted immediately but is saved aside on a list for deletion later
    by the calling routine.

Arguments:

    Cache - the tunnel cache the node is in

    Node - the node being removed

    FreePoolList - an initialized list to take the node if it was allocated from
        pool

    Splay - an optional flag to indicate whether the tree should be splayed on
        the delete. Set to FALSE if splaying was performed.

Return Value:

    None.

--*/
{
    if (Splay && *Splay) {

        Cache->Cache = RtlDelete(&Node->CacheLinks);

        *Splay = FALSE;

    } else {

        RtlDeleteNoSplay(&Node->CacheLinks, &Cache->Cache);
    }

    RemoveEntryList(&Node->ListLinks);

    Cache->NumEntries--;

    FsRtlFreeTunnelNode(Node, FreePoolList);
}


VOID
FsRtlInitializeTunnels (
    VOID
    )
/*++

Routine Description:

    Initializes the global part of the tunneling package.

Arguments:

    None

Return Value:

    None

--*/
{
    UNICODE_STRING  ValueName;
    USHORT          LookasideDepth;

    PAGED_CODE();

    if (MmIsThisAnNtAsSystem()) {

        TunnelMaxEntries = 1024;

    }

    //
    //  Query our configurable parameters
    //
    //  Don't worry about failure in retrieving from the registry. We've gotten
    //  this far so fall back on defaults even if there was a problem with resources.
    //

    ValueName.Buffer = TUNNEL_SIZE_VALUE_NAME;
    ValueName.Length = sizeof(TUNNEL_SIZE_VALUE_NAME) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(TUNNEL_SIZE_VALUE_NAME);
    (VOID) FsRtlGetTunnelParameterValue(&ValueName, &TunnelMaxEntries);

    ValueName.Buffer = TUNNEL_AGE_VALUE_NAME;
    ValueName.Length = sizeof(TUNNEL_AGE_VALUE_NAME) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(TUNNEL_AGE_VALUE_NAME);
    (VOID) FsRtlGetTunnelParameterValue(&ValueName, &TunnelMaxAge);

    if (TunnelMaxAge == 0) {

        //
        //  If the registry has been set so the timeout is zero, we should force
        //  the number of entries to zero also. This preserves expectations and lets
        //  us key off of max entries alone in performing the hard disabling of the
        //  caching code.
        //

        TunnelMaxEntries = 0;
    }

    //
    //  Convert from seconds to 10ths of msecs, the internal resolution
    //

    TunnelMaxAge *= 10000000;

    //
    //  Build the lookaside list for common node allocation
    //

    if (TunnelMaxEntries > MAXUSHORT) {

        //
        //  User is hinting a big need to us
        //

        LookasideDepth = MAX_LOOKASIDE_DEPTH;

    } else {

        LookasideDepth = ((USHORT)TunnelMaxEntries)/16;
    }

    if (LookasideDepth == 0 && TunnelMaxEntries) {

        //
        //  Miniscule number of entries allowed. Lookaside 'em all.
        //

        LookasideDepth = (USHORT)TunnelMaxEntries + 1;
    }

    if (LookasideDepth > MAX_LOOKASIDE_DEPTH) {

        //
        //  Finally, restrict the depth to something reasonable.
        //

        LookasideDepth = MAX_LOOKASIDE_DEPTH;
    }

    ExInitializePagedLookasideList( &TunnelLookasideList,
                                    NULL,
                                    NULL,
                                    0,
                                    LOOKASIDE_NODE_SIZE,
                                    'LnuT',
                                    LookasideDepth );

    return;
}


//
//  *** SPEC
//
//    FsRtlInitializeTunnelCache - Initialize a tunneling cache for a volume
//
//    FsRtlInitializeTunnelCache will allocate a default cache (resizing policy is common
//    to all file systems) and initialize it to be empty.  File systems will store a pointer to
//    this cache in their per-volume structures.
//
//    Information is retained in the tunnel cache for a fixed period of time.  MarkZ would
//    assume that a value of 10 seconds would satisfy the vast majority of situations.  This
//    could be controlled by the registry or could be a compilation constant.
//
//  Change: W95 times out at 15 seconds. Would be a registry value initialized at tunnel
//  creation time, with a proposed default of 15 seconds.
//

VOID
FsRtlInitializeTunnelCache (
    IN PTUNNEL Cache
    )
/*++

Routine Description:

    Initialize a new tunnel cache.

Arguments:

    None

Return Value:

    None

--*/
{
    PAGED_CODE();

    ExInitializeFastMutex(&Cache->Mutex);

    Cache->Cache = NULL;
    InitializeListHead(&Cache->TimerQueue);
    Cache->NumEntries = 0;

    return;
}


//
//  *** SPEC
//
//    FsRtlAddToTunnelCache - add information to a tunnel cache
//
//    FsRtlAddToTunnelCache is called by file systems when a name disappears from a
//    directory.  This typically occurs in both the delete and the rename paths.  When
//    a name is deleted, all information needed to be cached is extracted from the file
//    and passed in a single buffer.  This information is stored keyed by the directory key
//    (a ULONG that is unique to the directory) and the short-name of the file.
//
//    The caller is required to synchronize this call against FsRtlDeleteTunnelCache.
//
//    Arguments:
//        Cache        pointer to cache initialized by FsRtlInitializeTunnelCache
//        DirectoryKey    ULONG unique ID of the directory containing the deleted file
//        ShortName    UNICODE_STRING* short (8.3) name of the file
//        LongName    UNICODE_STRING* full name of the file
//        DataLength    ULONG length of data to be cached with these names
//        Data        VOID* data that will be cached.
//
//    It is acceptable for the Cache to ignore this request based upon memory constraints.
//
//  Change: W95 maintains 10 items in the tunnel cache. Since we are a potential server
//  this should be much higher. The max count would be initialized from the registry with
//  a proposed default of 1024. Adds which run into the limit would cause least recently
//  inserted recycling (i.e., off of the top of the timer queue).
//
//  Change: Key should be by the name removed, not neccesarily the short name. If a long name
//  is removed, it would be incorrect to miss the tunnel. Use KeyByShortName boolean to specify
//  which.
//
//  Change: Specify that Data, ShortName, and LongName are copied for storage.
//

VOID
FsRtlAddToTunnelCache (
    IN PTUNNEL Cache,
    IN ULONGLONG DirKey,
    IN PUNICODE_STRING ShortName,
    IN PUNICODE_STRING LongName,
    IN BOOLEAN KeyByShortName,
    IN ULONG DataLength,
    IN PVOID Data
    )
/*++

Routine Description:

    Adds an entry to the tunnel cache keyed by

        DirectoryKey ## (KeyByShortName ? ShortName : LongName)

    ShortName, LongName, and Data are copied and stored in the tunnel. As a side
    effect, if there are too many entries in the tunnel cache, this routine will
    initiate expiration in the tunnel cache.

Arguments:

    Cache - a tunnel cache initialized by FsRtlInitializeTunnelCache()

    DirKey - the key value of the directory the name appeared in

    ShortName - (optional if !KeyByShortName) the 8.3 name of the file

    LongName - (optional if KeyByShortName) the long name of the file

    KeyByShortName - specifies which name is keyed in the tunnel cache

    DataLength - specifies the length of the opaque data segment (file
    system specific) which contains the tunnelling information for this
    file

    Data - pointer to the opaque tunneling data segment

Return Value:

    None

--*/
{
    LONG Compare;
    ULONG NodeSize;
    PUNICODE_STRING NameKey;
    PRTL_SPLAY_LINKS *Links;
    LIST_ENTRY FreePoolList;

    PTUNNEL_NODE Node = NULL;
    PTUNNEL_NODE NewNode = NULL;
    BOOLEAN FreeOldNode = FALSE;
    BOOLEAN AllocatedFromPool = FALSE;

    PAGED_CODE();

    //
    //  If MaxEntries is 0 then tunneling is disabled.
    //

    if (TunnelMaxEntries == 0) return;

    InitializeListHead(&FreePoolList);

    //
    //  Grab a new node for this data
    //

    NodeSize = sizeof(TUNNEL_NODE) + ShortName->Length + LongName->Length + DataLength;

    if (LOOKASIDE_NODE_SIZE >= NodeSize) {

        NewNode = ExAllocateFromPagedLookasideList(&TunnelLookasideList);
    }

    if (NewNode == NULL) {

        //
        //  Data doesn't fit in lookaside nodes
        //

        NewNode = ExAllocatePoolWithTag(PagedPool|POOL_COLD_ALLOCATION, NodeSize, 'PnuT');

        if (NewNode == NULL) {

            //
            //  Give up tunneling this entry
            //

            return;
        }

        AllocatedFromPool = TRUE;
    }

    //
    //  Traverse the cache to find our insertion point
    //

    NameKey = (KeyByShortName ? ShortName : LongName);

    ExAcquireFastMutex(&Cache->Mutex);

    Links = &Cache->Cache;

    while (*Links) {

        Node = CONTAINING_RECORD(*Links, TUNNEL_NODE, CacheLinks);

        Compare = FsRtlCompareNodeAndKey(Node, DirKey, NameKey);

        if (Compare > 0) {

            Links = &RtlLeftChild(&Node->CacheLinks);

        } else {

            if (Compare < 0) {

                Links = &RtlRightChild(&Node->CacheLinks);

            } else {

                break;
            }
        }
    }

    //
    //  Thread new data into the splay tree
    //

    RtlInitializeSplayLinks(&NewNode->CacheLinks);

    if (Node) {

        //
        //  Not inserting first node in tree
        //

        if (*Links) {

            //
            //  Entry exists in the cache, so replace by swapping all splay links
            //

            RtlRightChild(&NewNode->CacheLinks) = RtlRightChild(*Links);
            RtlLeftChild(&NewNode->CacheLinks) = RtlLeftChild(*Links);

            if (RtlRightChild(*Links)) RtlParent(RtlRightChild(*Links)) = &NewNode->CacheLinks;
            if (RtlLeftChild(*Links)) RtlParent(RtlLeftChild(*Links)) = &NewNode->CacheLinks;

            if (!RtlIsRoot(*Links)) {

                //
                //  Change over the parent links. Note that we've messed with *Links now
                //  since it is pointing at the parent member.
                //

                RtlParent(&NewNode->CacheLinks) = RtlParent(*Links);

                if (RtlIsLeftChild(*Links)) {

                    RtlLeftChild(RtlParent(*Links)) = &NewNode->CacheLinks;

                } else {

                    RtlRightChild(RtlParent(*Links)) = &NewNode->CacheLinks;
                }

            } else {

                //
                //  Set root of the cache
                //

                Cache->Cache = &NewNode->CacheLinks;
            }

            //
            //  Free old node
            //

            RemoveEntryList(&Node->ListLinks);

            FsRtlFreeTunnelNode(Node, &FreePoolList);

            Cache->NumEntries--;

        } else {

            //
            //  Simple insertion as a leaf
            //

            NewNode->CacheLinks.Parent = &Node->CacheLinks;
            *Links = &NewNode->CacheLinks;
        }

    } else {

        Cache->Cache = &NewNode->CacheLinks;
    }

    //
    //  Thread onto the timer list
    //

    KeQuerySystemTime(&NewNode->CreateTime);
    InsertTailList(&Cache->TimerQueue, &NewNode->ListLinks);

    Cache->NumEntries++;

    //
    //  Stash tunneling information
    //

    NewNode->DirKey = DirKey;

    if (KeyByShortName) {

        NewNode->Flags = TUNNEL_FLAG_KEY_SHORT;

    } else {

        NewNode->Flags = 0;
    }

    //
    //  Initialize the internal UNICODE_STRINGS to point at the buffer segments. For various
    //  reasons (UNICODE APIs are incomplete, we're avoiding calling any allocate routine more
    //  than once, UNICODE strings are not guaranteed to be null terminated) we have to do a lot
    //  of this by hand.
    //
    //  The data is layed out like this in the allocated block:
    //
    //  -----------------------------------------------------------------------------------
    //  | TUNNEL_NODE | Node->ShortName.Buffer | Node->LongName.Buffer | Node->TunnelData |
    //  -----------------------------------------------------------------------------------
    //

    NewNode->ShortName.Buffer = (PWCHAR)((PCHAR)NewNode + sizeof(TUNNEL_NODE));
    NewNode->LongName.Buffer = (PWCHAR)((PCHAR)NewNode + sizeof(TUNNEL_NODE) + ShortName->Length);

    NewNode->ShortName.Length = NewNode->ShortName.MaximumLength = ShortName->Length;
    NewNode->LongName.Length = NewNode->LongName.MaximumLength = LongName->Length;

    if (ShortName->Length) {

        RtlCopyMemory(NewNode->ShortName.Buffer, ShortName->Buffer, ShortName->Length);
    }

    if (LongName->Length) {

        RtlCopyMemory(NewNode->LongName.Buffer, LongName->Buffer, LongName->Length);
    }

    NewNode->TunnelData = (PVOID)((PCHAR)NewNode + sizeof(TUNNEL_NODE) + ShortName->Length + LongName->Length);

    NewNode->TunnelDataLength = DataLength;

    RtlCopyMemory(NewNode->TunnelData, Data, DataLength);

    if (AllocatedFromPool) {

        SetFlag(NewNode->Flags, TUNNEL_FLAG_NON_LOOKASIDE);
    }

#if defined(TUNNELTEST) || defined (KEYVIEW)
    DbgPrint("FsRtlAddToTunnelCache:\n");
    DumpNode(NewNode, 1);
#ifndef KEYVIEW
    DumpTunnel(Cache);
#endif
#endif // TUNNELTEST

    //
    //  Clean out the cache, release, and then drop any pool memory we need to
    //

    FsRtlPruneTunnelCache(Cache, &FreePoolList);

    ExReleaseFastMutex(&Cache->Mutex);

    FsRtlEmptyFreePoolList(&FreePoolList);

    return;
}


//
//  *** SPEC
//
//    FsRtlFindInTunnelCache - retrieve information from tunnel cache
//
//    FsRtlFindInTunnelCache consults the cache to see if an entry with the same
//    DirectoryKey and ShortName exist.  If so, it returns the data associated with the
//    cache entry.  The entry may or may not be freed from the cache.  Information that is
//    stale but not yet purged (older than the retention threshold but not yet cleaned out)
//    may be returned.
//
//    File systems call FsRtlFindInTunnel cache in the create path when a new file is
//    being created and in the rename path when a new name is appearing in a directory.
//
//    The caller is required to synchronize this call against FsRtlDeleteTunnelCache.
//
//    Arguments:
//        Cache        a tunnel cache initialized by FsRtlInitializeTunnelCache()
//        DirectoryKey    ULONG unique ID of the directory where a name is appearing
//        Name        UNICODE_STRING* name that is being created
//        DataLength     in length of buffer, out returned length of data found
//        Data        pointer to buffer
//
//    Returns:
//        TRUE iff a matching DirectoryKey/Name pair are found, FALSE otherwise
//
//  Change: Add out parameters ShortName and LongName to capture the file naming information.
//  Plus: this avoids the need for marshalling/unmarshalling steps for the current desired use of
//  this code since otherwise we'd have variable length unaligned structures to contain the
//  strings along with the other meta-info.
//  Minus: Possibly a bad precedent.
//
//  Change: spec reads "may or may not be freed from cache" on a hit. This complicates unwinding
//  from aborted operations. Data will not be freed on a hit, but will expire like normal entries.
//

BOOLEAN
FsRtlFindInTunnelCache (
    IN PTUNNEL Cache,
    IN ULONGLONG DirKey,
    IN PUNICODE_STRING Name,
    OUT PUNICODE_STRING ShortName,
    OUT PUNICODE_STRING LongName,
    IN OUT PULONG  DataLength,
    OUT PVOID Data
    )
/*++

Routine Description:

    Looks up the key

        DirKey ## Name

    in the tunnel cache and removes it. As a side effect, this routine will initiate
    expiration of the aged entries in the tunnel cache.

Arguments:

    Cache - a tunnel cache initialized by FsRtlInitializeTunnelCache()

    DirKey - the key value of the directory the name will appear in

    Name - the name of the entry

    ShortName - return string to hold the short name of the tunneled file. Must
        already be allocated and large enough for max 8.3 name

    LongName -  return string to hold the long name of the tunneled file. If
        already allocated, may be grown if not large enough. Caller is
        responsible for noticing this and freeing data regardless of return value.

    DataLength - provides the length of the buffer avaliable to hold the
        tunneling information, returns the size of the tunneled information
        read out

Return Value:

    Boolean true if found, false otherwise

--*/
{
    PRTL_SPLAY_LINKS Links;
    PTUNNEL_NODE Node;
    LONG Compare;
    LIST_ENTRY FreePoolList;

    BOOLEAN Status = FALSE;

    PAGED_CODE();

    //
    //  If MaxEntries is 0 then tunneling is disabled.
    //

    if (TunnelMaxEntries == 0) return FALSE;

    InitializeListHead(&FreePoolList);

#ifdef KEYVIEW
    DbgPrint("++\nSearching for %wZ , %08x%08x\n--\n", Name, DblHex64(DirKey));
#endif

    ExAcquireFastMutex(&Cache->Mutex);

    //
    //  Expire aged entries first so we don't grab old data
    //

    FsRtlPruneTunnelCache(Cache, &FreePoolList);

    Links = Cache->Cache;

    while (Links) {

        Node = CONTAINING_RECORD(Links, TUNNEL_NODE, CacheLinks);

        Compare = FsRtlCompareNodeAndKey(Node, DirKey, Name);

        if (Compare > 0) {

            Links = RtlLeftChild(&Node->CacheLinks);

        } else {

            if (Compare < 0) {

                Links = RtlRightChild(&Node->CacheLinks);

            } else {

                //
                //  Found tunneling information
                //

#if defined(TUNNELTEST) || defined(KEYVIEW)
                DbgPrint("FsRtlFindInTunnelCache:\n");
                DumpNode(Node, 1);
#ifndef KEYVIEW
                DumpTunnel(Cache);
#endif
#endif // TUNNELTEST

                break;
            }
        }
    }

    try {

        if (Links) {
    
            //
            //  Copy node data into caller's area
            //
    
            ASSERT(ShortName->MaximumLength >= (8+1+3)*sizeof(WCHAR));
            RtlCopyUnicodeString(ShortName, &Node->ShortName);
    
            if (LongName->MaximumLength >= Node->LongName.Length) {
    
                RtlCopyUnicodeString(LongName, &Node->LongName);
    
            } else {
    
                //
                //  Need to allocate more memory for the long name
                //
    
                LongName->Buffer = FsRtlAllocatePoolWithTag(PagedPool, Node->LongName.Length, '4nuT');
                LongName->Length = LongName->MaximumLength = Node->LongName.Length;
    
                RtlCopyMemory(LongName->Buffer, Node->LongName.Buffer, Node->LongName.Length);
            }
    
            ASSERT(*DataLength >= Node->TunnelDataLength);
            RtlCopyMemory(Data, Node->TunnelData, Node->TunnelDataLength);
            *DataLength = Node->TunnelDataLength;
    
            Status = TRUE;
        }

    } finally {

        ExReleaseFastMutex(&Cache->Mutex);
    
        FsRtlEmptyFreePoolList(&FreePoolList);
    }
    
    return Status;
}


//
//  *** SPEC
//
//    FsRtlDeleteKeyFromTunnelCache - delete all cached information associated with
//    a DirectoryKey
//
//    When file systems delete a directory, all cached information relating to that directory
//    must be purged.  File systems call FsRtlDeleteKeyFromTunnelCache in the rmdir path.
//
//    The caller is required to synchronize this call against FsRtlDeleteTunnelCache.
//
//    Arguments:
//        Cache        a tunnel cache initialized by FsRtlInitializeTunnelCache()
//        DirectoryKey    ULONGLONG unique ID of the directory that is being deleted
//

VOID
FsRtlDeleteKeyFromTunnelCache (
    IN PTUNNEL Cache,
    IN ULONGLONG DirKey
    )
/*++

Routine Description:

    Deletes all entries in the cache associated with a specific directory

Arguments:

    Cache - a tunnel cache initialized by FsRtlInitializeTunnelCache()

    DirKey - the key value of the directory (presumeably being removed)

Return Value:

    None

--*/
{
    PRTL_SPLAY_LINKS Links;
    PRTL_SPLAY_LINKS SuccessorLinks;
    PTUNNEL_NODE Node;
    LIST_ENTRY FreePoolList;

    PRTL_SPLAY_LINKS LastLinks = NULL;
    BOOLEAN Splay = TRUE;

    PAGED_CODE();

    //
    //  If MaxEntries is 0 then tunneling is disabled.
    //

    if (TunnelMaxEntries == 0) return;

    InitializeListHead(&FreePoolList);

#ifdef KEYVIEW
    DbgPrint("++\nDeleting key %08x%08x\n--\n", DblHex64(DirKey));
#endif

    ExAcquireFastMutex(&Cache->Mutex);

    Links = Cache->Cache;

    while (Links) {

        Node = CONTAINING_RECORD(Links, TUNNEL_NODE, CacheLinks);

        if (Node->DirKey > DirKey) {

            //
            //  All nodes to the right are bigger, go left
            //

            Links = RtlLeftChild(&Node->CacheLinks);

        } else {

            if (Node->DirKey < DirKey) {

                if (LastLinks) {

                    //
                    //  If we have previously seen a candidate node to delete
                    //  and we have now gone too far left - we know where to start.
                    //

                    break;
                }

                Links = RtlRightChild(&Node->CacheLinks);

            } else {

                //
                //  Node is a candidate to be deleted, but we might have more nodes
                //  to the left in the tree. Note this location and go on.
                //

                LastLinks = Links;
                Links = RtlLeftChild(&Node->CacheLinks);
            }
        }
    }

    for (Links = LastLinks;
         Links;
         Links = SuccessorLinks) {

        SuccessorLinks = RtlRealSuccessor(Links);
        Node = CONTAINING_RECORD(Links, TUNNEL_NODE, CacheLinks);

        if (Node->DirKey != DirKey) {

            //
            //  Reached nodes which have a different key, so we're done
            //

            break;
        }

        FsRtlRemoveNodeFromTunnel(Cache, Node, &FreePoolList, &Splay);
    }

#ifdef TUNNELTEST
    DbgPrint("FsRtlDeleteKeyFromTunnelCache:\n");
#ifndef KEYVIEW
    DumpTunnel(Cache);
#endif
#endif // TUNNELTEST

    ExReleaseFastMutex(&Cache->Mutex);

    //
    //  Free delayed pool
    //

    FsRtlEmptyFreePoolList(&FreePoolList);

    return;
}


//
//  *** SPEC
//
//    FsRtlDeleteTunnelCache - free a tunnel cache
//
//    FsRtlDeleteTunnelCache deletes all cached information.  The Cache is no longer
//    valid.
//
//    Arguments:
//        Cache        a tunnel cache initialized by FsRtlInitializeTunnelCache()
//

VOID
FsRtlDeleteTunnelCache (
    IN PTUNNEL Cache
    )
/*++

Routine Description:

    Deletes a tunnel cache

Arguments:

    Cache - the cache to delete, initialized by FsRtlInitializeTunnelCache()

Return Value:

    None

--*/
{
    PTUNNEL_NODE Node;
    PLIST_ENTRY Link, Next;

    PAGED_CODE();

    //
    //  If MaxEntries is 0 then tunneling is disabled.
    //

    if (TunnelMaxEntries == 0) return;

    //
    //  Zero out the cache and delete everything on the timer list
    //

    Cache->Cache = NULL;
    Cache->NumEntries = 0;

    for (Link = Cache->TimerQueue.Flink;
         Link != &Cache->TimerQueue;
         Link = Next) {

        Next = Link->Flink;

        Node = CONTAINING_RECORD(Link, TUNNEL_NODE, ListLinks);

        FsRtlFreeTunnelNode(Node, NULL);
    }

    InitializeListHead(&Cache->TimerQueue);

    return;
}


VOID
FsRtlPruneTunnelCache (
    IN PTUNNEL Cache,
    IN OUT PLIST_ENTRY FreePoolList
    )
/*++

Routine Description:

    Removes deadwood entries from the tunnel cache as defined by TunnelMaxAge and TunnelMaxEntries.
    Pool memory is returned on a list for deletion by the calling routine at a time of
    its choosing.

    For performance reasons we don't want to force freeing of memory inside a mutex.

Arguments:

    Cache - the tunnel cache to prune

    FreePoolList - a list to queue pool memory on to

Return Value:

    None
--*/
{
    PTUNNEL_NODE Node;
    LARGE_INTEGER ExpireTime;
    LARGE_INTEGER CurrentTime;
    BOOLEAN Splay = TRUE;

    PAGED_CODE();

    //
    //  Calculate the age of the oldest entry we want to keep
    //

    KeQuerySystemTime(&CurrentTime);
    ExpireTime.QuadPart = CurrentTime.QuadPart - TunnelMaxAge;

    //
    //  Expire old entries off of the timer queue.  We have to check
    //  for future time because the clock may jump as a result of
    //  hard clock change.  If we did not do this, a rogue entry
    //  with a future time could sit at the top of the queue and
    //  prevent entries from going away.
    //

    while (!IsListEmpty(&Cache->TimerQueue)) {

        Node = CONTAINING_RECORD(Cache->TimerQueue.Flink, TUNNEL_NODE, ListLinks);

        if (Node->CreateTime.QuadPart < ExpireTime.QuadPart ||
            Node->CreateTime.QuadPart > CurrentTime.QuadPart) {

#if defined(TUNNELTEST) || defined(KEYVIEW)
            DbgPrint("Expiring node %x (%ud%ud 1/10 msec too old)\n", Node, DblHex64(ExpireTime.QuadPart - Node->CreateTime.QuadPart));
#endif // TUNNELTEST

            FsRtlRemoveNodeFromTunnel(Cache, Node, FreePoolList, &Splay);

        } else {

            //
            //  No more nodes to be expired
            //

            break;
        }
    }

    //
    //  Remove entries until we're under the TunnelMaxEntries limit
    //

    while (Cache->NumEntries > TunnelMaxEntries) {

        Node = CONTAINING_RECORD(Cache->TimerQueue.Flink, TUNNEL_NODE, ListLinks);

#if defined(TUNNELTEST) || defined(KEYVIEW)
            DbgPrint("Dumping node %x (%d > %d)\n", Node, Cache->NumEntries, TunnelMaxEntries);
#endif // TUNNELTEST

        FsRtlRemoveNodeFromTunnel(Cache, Node, FreePoolList, &Splay);
    }

    return;
}


NTSTATUS
FsRtlGetTunnelParameterValue (
    IN PUNICODE_STRING ValueName,
    IN OUT PULONG Value
    )

/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the Tunnel parameter information and get the
    value.

Arguments:

    ValueName - the unicode name for the registry value located in the
                double space configuration location of the registry.
    Value   - a pointer to the ULONG for the result.

Return Value:

    NTSTATUS

    If STATUS_SUCCESSFUL is returned, the location *Value will be
    updated with the DWORD value from the registry.  If any failing
    status is returned, this value is untouched.

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    UCHAR Buffer[KEY_WORK_AREA];
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;

    KeyName.Buffer = TUNNEL_KEY_NAME;
    KeyName.Length = sizeof(TUNNEL_KEY_NAME) - sizeof(WCHAR);
    KeyName.MaximumLength = sizeof(TUNNEL_KEY_NAME);

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&Handle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    RequestLength = KEY_WORK_AREA;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

    while (1) {

        Status = ZwQueryValueKey(Handle,
                                 ValueName,
                                 KeyValueFullInformation,
                                 KeyValueInformation,
                                 RequestLength,
                                 &ResultLength);

        ASSERT( Status != STATUS_BUFFER_OVERFLOW );

        if (Status == STATUS_BUFFER_OVERFLOW) {

            //
            // Try to get a buffer big enough.
            //

            if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

                ExFreePool(KeyValueInformation);
            }

            RequestLength += 256;

            KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                  ExAllocatePoolWithTag(PagedPool,
                                                        RequestLength,
                                                        'KnuT');

            if (!KeyValueInformation) {
                return STATUS_NO_MEMORY;
            }

        } else {

            break;
        }
    }

    ZwClose(Handle);

    if (NT_SUCCESS(Status)) {

        if (KeyValueInformation->DataLength != 0) {

            PULONG DataPtr;

            //
            // Return contents to the caller.
            //

            DataPtr = (PULONG)
              ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
            *Value = *DataPtr;

        } else {

            //
            // Treat as if no value was found
            //

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (KeyValueInformation != (PKEY_VALUE_FULL_INFORMATION)Buffer) {

        ExFreePool(KeyValueInformation);
    }

    return Status;
}


#if defined(TUNNELTEST) || defined(KEYVIEW)

VOID
DumpTunnel (
    PTUNNEL Tunnel
    )
{
    PRTL_SPLAY_LINKS SplayLinks, Ptr;
    PTUNNEL_NODE Node;
    PLIST_ENTRY Link;
    ULONG Indent = 1, i;
    ULONG EntryCount = 0;
    BOOLEAN CountOff = FALSE;

    DbgPrint("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");

    DbgPrint("NumEntries = %d\n", Tunnel->NumEntries);
    DbgPrint("****** Cache Tree\n");

    SplayLinks = Tunnel->Cache;

    if (SplayLinks == NULL) {

        goto end;
    }

    while (RtlLeftChild(SplayLinks) != NULL) {

        SplayLinks = RtlLeftChild(SplayLinks);
        Indent++;
    }

    while (SplayLinks) {

        Node = CONTAINING_RECORD( SplayLinks, TUNNEL_NODE, CacheLinks );

        EntryCount++;

        DumpNode(Node, Indent);

        Ptr = SplayLinks;

        /*
          first check to see if there is a right subtree to the input link
          if there is then the real successor is the left most node in
          the right subtree.  That is find and return P in the following diagram

                      Links
                         \
                          .
                         .
                        .
                       /
                      P
                       \
        */

        if ((Ptr = RtlRightChild(SplayLinks)) != NULL) {

            Indent++;
            while (RtlLeftChild(Ptr) != NULL) {

                Indent++;
                Ptr = RtlLeftChild(Ptr);
            }

            SplayLinks = Ptr;

        } else {
            /*
              we do not have a right child so check to see if have a parent and if
              so find the first ancestor that we are a left decendent of. That
              is find and return P in the following diagram

                               P
                              /
                             .
                              .
                               .
                              Links
            */

            Ptr = SplayLinks;
            while (RtlIsRightChild(Ptr)) {

                Indent--;
                Ptr = RtlParent(Ptr);
            }

            if (!RtlIsLeftChild(Ptr)) {

                //
                //  we do not have a real successor so we simply return
                //  NULL
                //
                SplayLinks = NULL;

            } else {

                Indent--;
                SplayLinks = RtlParent(Ptr);
            }
        }
    }

    end:

    if (CountOff = (EntryCount != Tunnel->NumEntries)) {

        DbgPrint("!!!!!!!!!! Splay Tree Count Mismatch (%d != %d)\n", EntryCount, Tunnel->NumEntries);
    }

    EntryCount = 0;

    DbgPrint("****** Timer Queue\n");

    for (Link = Tunnel->TimerQueue.Flink;
         Link != &Tunnel->TimerQueue;
         Link = Link->Flink) {

        Node = CONTAINING_RECORD( Link, TUNNEL_NODE, ListLinks );

        EntryCount++;

        DumpNode(Node, 1);
    }

    if (CountOff |= (EntryCount != Tunnel->NumEntries)) {

        DbgPrint("!!!!!!!!!! Timer Queue Count Mismatch (%d != %d)\n", EntryCount, Tunnel->NumEntries);
    }

    ASSERT(!CountOff);

    DbgPrint("------------------------------------------------------------------\n");
}

#define MAXINDENT  128
#define INDENTSTEP 3

VOID
DumpNode (
    PTUNNEL_NODE Node,
    ULONG Indent
    )
{
    ULONG i;
    CHAR  SpaceBuf[MAXINDENT*INDENTSTEP + 1];

    Indent--;
    if (Indent > MAXINDENT) {
        Indent = MAXINDENT;
    }

    //
    //  DbgPrint is really expensive to iteratively call to do the indenting,
    //  so just build up the indentation all at once on the stack.
    //

    RtlFillMemory(SpaceBuf, Indent*INDENTSTEP, ' ');
    SpaceBuf[Indent*INDENTSTEP] = '\0';

    DbgPrint("%sNode 0x%x  CreateTime = %08x%08x, DirKey = %08x%08x, Flags = %d\n",
             SpaceBuf,
             Node,
             DblHex64(Node->CreateTime.QuadPart),
             DblHex64(Node->DirKey),
             Node->Flags );

    DbgPrint("%sShort = %wZ, Long = %wZ\n", SpaceBuf,
                                            &Node->ShortName,
                                            &Node->LongName );

    DbgPrint("%sP = %x, R = %x, L = %x\n", SpaceBuf,
                                           RtlParent(&Node->CacheLinks),
                                           RtlRightChild(&Node->CacheLinks),
                                           RtlLeftChild(&Node->CacheLinks) );
}
#endif // TUNNELTEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fsrtl\unc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    unc.c

Abstract:

    This file contains functions to support multiple UNC providers
    on a single NT machine.

Author:

    Manny Weiser     [MannyW]    20-Dec-1991

Revision History:

    Isaac Heizer     [IsaacHe]   16-Nov-1994  Defer loading the MUP
                                              Rewrite

    Milan Shah       [MilanS]    7-Mar-1996   Check for Dfs client status
                                              before loading the MUP

--*/

#include "fsrtlp.h"
#include <zwapi.h>
#include <ntddmup.h>
#include <ntddnull.h>

#define MupRegKey L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Mup"
#define UNCSymbolicLink L"\\DosDevices\\UNC"
#define DevNull L"\\Device\\Null"
#define DevMup DD_MUP_DEVICE_NAME

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('nuSF')

//
// Local prototypes
//

NTSTATUS
FsRtlpRegisterProviderWithMUP
(
    IN HANDLE mupHandle,
    IN PUNICODE_STRING RedirDevName,
    IN BOOLEAN MailslotsSupported
);

NTSTATUS
FsRtlpOpenDev(
    IN OUT PHANDLE Handle,
    IN LPWSTR DevNameStr
);

VOID
FsRtlpSetSymbolicLink(
    IN PUNICODE_STRING DevName OPTIONAL
);

BOOLEAN
FsRtlpIsDfsEnabled();

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlpRegisterProviderWithMUP)
#pragma alloc_text(PAGE, FsRtlpOpenDev)
#pragma alloc_text(PAGE, FsRtlpSetSymbolicLink)
#pragma alloc_text(PAGE, FsRtlRegisterUncProvider)
#pragma alloc_text(PAGE, FsRtlDeregisterUncProvider)
#pragma alloc_text(PAGE, FsRtlpIsDfsEnabled)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif
//
// We defer calling the MUP with the registration data until
//   the second redir loads and Dfs is disabled.  This structure holds the
//   data necessary to make that call.
//
struct {
    HANDLE MupHandle;
    HANDLE ReturnedHandle;
    UNICODE_STRING RedirDevName;
    BOOLEAN MailslotsSupported;
} FsRtlpDRD = {0};

//
// Number of times we've loaded redirs.
//
ULONG FsRtlpRedirs = 0;
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// Resource protection
//
KSEMAPHORE FsRtlpUncSemaphore;


NTSTATUS
FsRtlpRegisterProviderWithMUP
(
    IN HANDLE mupHandle,
    IN PUNICODE_STRING RedirDevName,
    IN BOOLEAN MailslotsSupported
)
/*++

Routine Description:

    This private routine does the FSCTL to the MUP to tell it about
        a new redir

Arguments:

    mupHandle - Handle to the MUP

    RedirDevName - The device name of the redir.

    MailslotsSupported - If TRUE, this redir supports mailslots.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG paramLength;
    PREDIRECTOR_REGISTRATION params;

    PAGED_CODE();

    paramLength = sizeof( REDIRECTOR_REGISTRATION ) +
                      RedirDevName->Length;

    params = ExAllocatePoolWithTag( NonPagedPool, paramLength, MODULE_POOL_TAG );
    if( params == NULL )
        return STATUS_INSUFFICIENT_RESOURCES;

    params->DeviceNameOffset = sizeof( REDIRECTOR_REGISTRATION );
    params->DeviceNameLength = RedirDevName->Length;
    params->MailslotsSupported = MailslotsSupported;

    RtlCopyMemory(
        (PCHAR)params + params->DeviceNameOffset,
        RedirDevName->Buffer,
        RedirDevName->Length
        );

    status = NtFsControlFile(
                 mupHandle,
                 0,
                 NULL,
                 NULL,
                 &ioStatusBlock,
                 FSCTL_MUP_REGISTER_UNC_PROVIDER,
                 params,
                 paramLength,
                 NULL,
                 0
                 );

    if ( status == STATUS_PENDING ) {
        status = NtWaitForSingleObject( mupHandle, TRUE, NULL );
    }

    if ( NT_SUCCESS( status ) ) {
        status = ioStatusBlock.Status;
    }

    ASSERT( NT_SUCCESS( status ) );

    ExFreePool( params );

    return status;
}

NTSTATUS
FsRtlpOpenDev(
    IN OUT PHANDLE Handle,
    IN LPWSTR DevNameStr
)
{
    NTSTATUS status;
    UNICODE_STRING DevName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    PAGED_CODE();

    RtlInitUnicodeString( &DevName, DevNameStr );

    InitializeObjectAttributes(
        &objectAttributes,
        &DevName,
        0,
        0,
        NULL
        );

    status = ZwCreateFile(
                 Handle,
                 GENERIC_WRITE,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN,
                 0,
                 NULL,
                 0
                 );

    if ( NT_SUCCESS( status ) ) {
        status = ioStatusBlock.Status;
    }

    if( !NT_SUCCESS( status ) ) {
        *Handle = (HANDLE)-1;
    }

    return status;
}

VOID
FsRtlpSetSymbolicLink( IN PUNICODE_STRING DevName OPTIONAL )
{
    NTSTATUS status;
    UNICODE_STRING UncSymbolicName;

    PAGED_CODE();

    RtlInitUnicodeString( &UncSymbolicName, UNCSymbolicLink );
    (VOID)IoDeleteSymbolicLink( &UncSymbolicName );
    if( ARGUMENT_PRESENT( DevName ) ) {
        status = IoCreateSymbolicLink( &UncSymbolicName, DevName );
        ASSERT( NT_SUCCESS( status ) );
    }
}

NTSTATUS
FsRtlRegisterUncProvider(
    IN OUT PHANDLE MupHandle,
    IN PUNICODE_STRING RedirDevName,
    IN BOOLEAN MailslotsSupported
    )
/*++

Routine Description:

    This routine registers a redir as a UNC provider.

Arguments:

    Handle - Pointer to a handle.  The handle is returned by the routine
        to be used when calling FsRtlDeregisterUncProvider.
        It is valid only if the routines returns STATUS_SUCCESS.

    RedirDevName - The device name of the redir.

    MailslotsSupported - If TRUE, this redir supports mailslots.

Return Value:

    NTSTATUS - The status of the operation.

--*/
{
    NTSTATUS status;
    HANDLE mupHandle = (HANDLE)-1;
    UNICODE_STRING mupDriverName;
    BOOLEAN dfsEnabled;

    PAGED_CODE();

    KeWaitForSingleObject(&FsRtlpUncSemaphore, Executive, KernelMode, FALSE, NULL );

    if (FsRtlpRedirs == 0) {

        dfsEnabled = FsRtlpIsDfsEnabled();

        if (dfsEnabled) {
            FsRtlpRedirs = 1;
            RtlZeroMemory((PVOID) &FsRtlpDRD, sizeof(FsRtlpDRD));
        }

    }

    switch( FsRtlpRedirs ) {
    case 0:
        //
        // Ok, the MUP isn't there and we don't need to use the
        //   MUP for the first redir.
        //
        // We need to return a handle, but we're not really using the MUP yet.
        //   And we may never use it (if there's only 1 redir).  Return
        //   a handle to the NULL device object, since we're committed to returning
        //   a handle to our caller.  Our caller isn't supposed to do anything with
        //   the handle except to call FsRtlDeregisterUncProvider() with it.
        //
        status = FsRtlpOpenDev( &mupHandle, DevNull );

        if( !NT_SUCCESS( status ) )
            break;

        //
        // Save up enough state to allow us to call the MUP later with
        // this registration info if necessary.
        //
        FsRtlpDRD.RedirDevName.Buffer = ExAllocatePoolWithTag( NonPagedPool, 
                                                               RedirDevName->MaximumLength, 
                                                               MODULE_POOL_TAG );

        if( FsRtlpDRD.RedirDevName.Buffer == NULL ) {
            status =  STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        FsRtlpDRD.RedirDevName.Length = RedirDevName->Length;
        FsRtlpDRD.RedirDevName.MaximumLength = RedirDevName->MaximumLength;

        RtlCopyMemory(
                (PCHAR)FsRtlpDRD.RedirDevName.Buffer,
                RedirDevName->Buffer,
                RedirDevName->MaximumLength
        );

        FsRtlpDRD.MailslotsSupported = MailslotsSupported;
        FsRtlpDRD.ReturnedHandle = mupHandle;
        FsRtlpDRD.MupHandle = (HANDLE)-1;

        //
        // Set the UNC symbolic link to point to the redir we just loaded
        //
        FsRtlpSetSymbolicLink( RedirDevName );

        break;

    default:
        //
        // This is the second or later redir load -- MUST use the MUP
        //
        status = FsRtlpOpenDev( &mupHandle, DevMup );

        if( !NT_SUCCESS( status ) ) {

            RtlInitUnicodeString( &mupDriverName, MupRegKey );

            (VOID)ZwLoadDriver( &mupDriverName );

            status = FsRtlpOpenDev( &mupHandle, DevMup );
            if( !NT_SUCCESS( status ) )
                break;
        }

        //
        // See if we need to tell the MUP about the first redir that registered
        //
        if( FsRtlpDRD.RedirDevName.Buffer ) {

            status = FsRtlpRegisterProviderWithMUP( mupHandle,
                    &FsRtlpDRD.RedirDevName,
                    FsRtlpDRD.MailslotsSupported );

            if( !NT_SUCCESS( status ) )
                break;

            FsRtlpDRD.MupHandle = mupHandle;

            ExFreePool( FsRtlpDRD.RedirDevName.Buffer );
            FsRtlpDRD.RedirDevName.Buffer = NULL;

            //
            // Set the UNC symbolic link to point to the MUP
            //
            RtlInitUnicodeString(  &mupDriverName, DevMup );
            FsRtlpSetSymbolicLink( &mupDriverName );

            status = FsRtlpOpenDev( &mupHandle, DevMup );

            if( !NT_SUCCESS( status ) )
                break;
        }

        //
        //  Pass the request to the MUP for this redir
        //
        status = FsRtlpRegisterProviderWithMUP( mupHandle,
                        RedirDevName,
                        MailslotsSupported );
        break;

    }

    if( NT_SUCCESS( status ) ) {
        FsRtlpRedirs++;
        *MupHandle = mupHandle;

    } else {
        if( mupHandle != (HANDLE)-1 && mupHandle != NULL ) {
            ZwClose( mupHandle );
        }

        *MupHandle = (HANDLE)-1;
    }

    KeReleaseSemaphore(&FsRtlpUncSemaphore, 0, 1, FALSE );
    return status;
}


VOID
FsRtlDeregisterUncProvider(
    IN HANDLE Handle
    )

/*++

Routine Description:

    This routine deregisters a redir as a UNC provider.

Arguments:

    Handle - A handle to the Multiple UNC router, returned by the
        registration call.

Return Value:

    None.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    if( Handle == (HANDLE)-1 || Handle == NULL )
        return;

    status = ZwClose( Handle );

    if( !NT_SUCCESS( status ) ) {
        return;
    }

    KeWaitForSingleObject(&FsRtlpUncSemaphore, Executive, KernelMode, FALSE, NULL );

    ASSERT( FsRtlpRedirs > 0 );

    if( Handle == FsRtlpDRD.ReturnedHandle ) {

        //
        // The first redir in the system is closing.  Release the state we saved
        //  for it, and pass the close on to the MUP if necessary
        //

        if( FsRtlpDRD.RedirDevName.Buffer != NULL ) {
            ExFreePool( FsRtlpDRD.RedirDevName.Buffer );
            FsRtlpDRD.RedirDevName.Buffer = NULL;
        }

        if( FsRtlpDRD.MupHandle != (HANDLE)-1 ) {
            ZwClose( FsRtlpDRD.MupHandle );
            FsRtlpDRD.MupHandle = (HANDLE)-1;
        }

        FsRtlpDRD.ReturnedHandle = (HANDLE)-1;

    }

    if( --FsRtlpRedirs == 0 ) {
        FsRtlpSetSymbolicLink( (PUNICODE_STRING)NULL );
    }

    KeReleaseSemaphore(&FsRtlpUncSemaphore, 0, 1, FALSE );
}


BOOLEAN
FsRtlpIsDfsEnabled()

/*++

Routine Description:

    This routine checks a registry key to see if the Dfs client is enabled.
    The client is assumed to be enabled by default, and disabled only if there
    is a registry value indicating that it should be disabled.

Arguments:

    None

Return Value:

    TRUE if Dfs client is enabled, FALSE otherwise.

--*/

{
    NTSTATUS status;
    HANDLE mupRegHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG valueSize;
    BOOLEAN dfsEnabled = TRUE;

    UNICODE_STRING mupRegKey = {
        sizeof(MupRegKey) - sizeof(WCHAR),
        sizeof(MupRegKey),
        MupRegKey};

#define DISABLE_DFS_VALUE_NAME  L"DisableDfs"

    UNICODE_STRING disableDfs = {
        sizeof(DISABLE_DFS_VALUE_NAME) - sizeof(WCHAR),
        sizeof(DISABLE_DFS_VALUE_NAME),
        DISABLE_DFS_VALUE_NAME};

    struct {
        KEY_VALUE_PARTIAL_INFORMATION Info;
        ULONG Buffer;
    } disableDfsValue;


    InitializeObjectAttributes(
        &objectAttributes,
        &mupRegKey,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    status = ZwOpenKey(&mupRegHandle, KEY_READ, &objectAttributes);

    if (NT_SUCCESS(status)) {

        status = ZwQueryValueKey(
                    mupRegHandle,
                    &disableDfs,
                    KeyValuePartialInformation,
                    (PVOID) &disableDfsValue,
                    sizeof(disableDfsValue),
                    &valueSize);

        if (NT_SUCCESS(status) && disableDfsValue.Info.Type == REG_DWORD) {

            if ( (*((PULONG) disableDfsValue.Info.Data)) == 1 )
                dfsEnabled = FALSE;

        }

        ZwClose( mupRegHandle );

    }

    return( dfsEnabled );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fstub\ex.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ex.h

Abstract:

    Private header file for ex.c

Author:

    Matthew D Hendel (math) 07-Sept-1999

Revision History:

--*/

#pragma once

//
// Macro definitions
//

#define FSTUB_TAG               ('BtsF')
#define PARTITION_ENTRY_SIZE    (128)
#define MIN_PARTITION_COUNT     (128)


//
// The disk information structure contains all the information required to
// partition the disk.
//

typedef struct _DISK_INFORMATION {

    //
    // The DeviceObject representing this disk.
    //
    
    PDEVICE_OBJECT DeviceObject;

    //
    // The sector size of the disk.
    //
    
    ULONG SectorSize;

    //
    // The geometry information for the disk.
    //
    
    INTERNAL_DISK_GEOMETRY Geometry;

    //
    // A scratch buffer of size SectorSize where information can be read into.
    //
    
    PVOID ScratchBuffer;

    //
    // How many logical blocks there are in this disk.
    //
    
    ULONGLONG SectorCount;
    
} DISK_INFORMATION, *PDISK_INFORMATION;


enum {
    PRIMARY_PARTITION_TABLE,
    BACKUP_PARTITION_TABLE
};


C_ASSERT (PARTITION_ENTRY_SIZE == sizeof (EFI_PARTITION_ENTRY));

#define IS_VALID_DISK_INFO(_Disk)                       \
            ((_Disk) != NULL &&                         \
             (_Disk)->DeviceObject != NULL &&           \
             (_Disk)->SectorSize != 0 &&                    \
             (_Disk)->ScratchBuffer != NULL &&          \
             (_Disk)->SectorCount != 0)


#define ROUND_TO(_val,_factor)  \
            ((((_val) + (_factor) - 1) / (_factor)) * (_factor))

#define max(a,b)            (((a) > (b)) ? (a) : (b))

#define IS_NULL_GUID(_guid)\
            ((_guid).Data1 == 0 &&      \
            (_guid).Data2 == 0 &&       \
            (_guid).Data3 == 0 &&       \
            (_guid).Data4[0] == 0 &&    \
            (_guid).Data4[1] == 0 &&    \
            (_guid).Data4[2] == 0 &&    \
            (_guid).Data4[3] == 0 &&    \
            (_guid).Data4[4] == 0 &&    \
            (_guid).Data4[5] == 0 &&    \
            (_guid).Data4[6] == 0 &&    \
            (_guid).Data4[7] == 0)




NTSTATUS
FstubReadPartitionTableMBR(
    IN PDISK_INFORMATION Disk,
    IN BOOLEAN RecognizedPartitionsOnly,
    OUT PDRIVE_LAYOUT_INFORMATION_EX* ReturnedDriveLayout
    );

NTSTATUS
FstubDetectPartitionStyle(
    IN PDISK_INFORMATION Disk,
    OUT PARTITION_STYLE* PartitionStyle
    );

NTSTATUS
FstubGetDiskGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PINTERNAL_DISK_GEOMETRY Geometry
    );

NTSTATUS
FstubAllocateDiskInformation(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDISK_INFORMATION * DiskBuffer,
    IN PINTERNAL_DISK_GEOMETRY Geometry OPTIONAL
    );

NTSTATUS
FstubFreeDiskInformation(
    IN OUT PDISK_INFORMATION Disk
    );

NTSTATUS
FstubWriteBootSectorEFI(
    IN CONST PDISK_INFORMATION Disk
    );

PDRIVE_LAYOUT_INFORMATION
FstubConvertExtendedToLayout(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutEx
    );

NTSTATUS
FstubWritePartitionTableMBR(
    IN PDISK_INFORMATION Disk,
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutEx
    );

NTSTATUS
FstubWriteEntryEFI(
    IN PDISK_INFORMATION Disk,
    IN ULONG PartitionEntryBlockCount,
    IN ULONG EntryNumber,
    IN PEFI_PARTITION_ENTRY PartitionEntry,
    IN ULONG Partition,
    IN BOOLEAN Flush,
    IN OUT ULONG32* PartialCheckSum
    );

NTSTATUS
FstubWriteHeaderEFI(
    IN PDISK_INFORMATION Disk,
    IN ULONG PartitionEntryBlockCount,
    IN GUID DiskGUID,
    IN ULONG32 MaxPartitionCount,
    IN ULONG64 FirstUsableLBA,
    IN ULONG64 LastUsableLBA,
    IN ULONG32 CheckSum,
    IN ULONG Partition
    );

VOID
FstubAdjustPartitionCount(
    IN ULONG SectorSize,
    IN OUT PULONG PartitionCount
    );

NTSTATUS
FstubCreateDiskEFI(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCREATE_DISK_GPT DiskInfo    
    );

NTSTATUS
FstubCreateDiskMBR(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCREATE_DISK_MBR DiskInfo
    );

NTSTATUS
FstubCreateDiskRaw(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
FstubCopyEntryEFI(
    OUT PEFI_PARTITION_ENTRY Entry,
    IN PPARTITION_INFORMATION_EX Partition,
    IN ULONG SectorSize
    );

NTSTATUS
FstubWritePartitionTableEFI(
    IN PDISK_INFORMATION Disk,
    IN GUID DiskGUID,
    IN ULONG32 MaxPartitionCount,
    IN ULONG64 FirstUsableLBA,
    IN ULONG64 LastUsableLBA,
    IN ULONG PartitionTable,
    IN ULONG PartitionCount,
    IN PPARTITION_INFORMATION_EX PartitionArray
    );

NTSTATUS
FstubReadHeaderEFI(
    IN PDISK_INFORMATION Disk,
    IN ULONG PartitionTable,
    OUT PEFI_PARTITION_HEADER* HeaderBuffer
    );

NTSTATUS
FstubReadPartitionTableEFI(
    IN PDISK_INFORMATION Disk,
    IN ULONG PartitionTable,
    OUT PDRIVE_LAYOUT_INFORMATION_EX* ReturnedDriveLayout
    );

NTSTATUS
FstubWriteSector(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG64 SectorNumber,
    IN PVOID Buffer
    );

NTSTATUS
FstubReadSector(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG64 SectorNumber,
    OUT PVOID Buffer
    );

NTSTATUS
FstubSetPartitionInformationEFI(
    IN PDISK_INFORMATION Disk,
    IN ULONG PartitionNumber,
    IN SET_PARTITION_INFORMATION_GPT* PartitionInfo
    );

NTSTATUS
FstubUpdateDiskGeometryEFI(
    IN PDISK_INFORMATION OldDisk,
    IN PDISK_INFORMATION NewDisk
    );

NTSTATUS
FstubVerifyPartitionTableEFI(
    IN PDISK_INFORMATION Disk,
    IN BOOLEAN FixErrors
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fstub\fstub.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    fstub.h

Abstract:

    Fstub private header file.

Author:

    Matthew D Hendel (math) 01-Nov-1999

Revision History:

--*/

#pragma once


typedef struct _INTERNAL_DISK_GEOMETRY {
    DISK_GEOMETRY Geometry;
    LARGE_INTEGER DiskSize;
} INTERNAL_DISK_GEOMETRY, *PINTERNAL_DISK_GEOMETRY;

//
// Verify that the INTERNAL_DISK_GEOMETRY structure matches the DISK_GEOMETRY
// structure.
//

C_ASSERT (FIELD_OFFSET (DISK_GEOMETRY_EX, Geometry) ==
            FIELD_OFFSET (INTERNAL_DISK_GEOMETRY, Geometry) &&
          FIELD_OFFSET (DISK_GEOMETRY_EX, DiskSize) ==
            FIELD_OFFSET (INTERNAL_DISK_GEOMETRY, DiskSize));

//
// Debugging macros and flags
//

#define FSTUB_VERBOSE_LEVEL 4

#if DBG

VOID
FstubDbgPrintPartition(
    IN PPARTITION_INFORMATION Partition,
    IN ULONG PartitionCount
    );

VOID
FstubDbgPrintDriveLayout(
    IN PDRIVE_LAYOUT_INFORMATION  Layout
    );

VOID
FstubDbgPrintPartitionEx(
    IN PPARTITION_INFORMATION_EX PartitionEx,
    IN ULONG PartitionCount
    );

VOID
FstubDbgPrintDriveLayoutEx(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutEx
    );

VOID
FstubDbgPrintSetPartitionEx(
    IN PSET_PARTITION_INFORMATION_EX SetPartition,
    IN ULONG PartitionNumber
    );

#else

#define FstubDbgPrintPartition(Partition, PartitionCount)
#define FstubDbgPrintDriveLayout(Layout)
#define FstubDbgPrintPartitionEx(PartitionEx, PartitionCount)
#define FstubDbgPrintDriveLayoutEx(LayoutEx)
#define FstubDbgPrintSetPartitionEx(SetPartition, PartitionNumber)

#endif // !DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\alpha.h ===
/*++

Copyright (c) 1993  Digital Equipment Corporation

Module Name:

   alpha.h

Abstract:

   The Alpha hardware specific header file.

Author:

   Joe Notarangelo  31-Mar-1992   (based on mips.h by Dave Cutler)

Revision History:

    Jeff McLeman (mcleman) 21-Jul-1992
      Add bus types for ISA and EISA

    Thomas Van Baak (tvb) 9-Jul-1992

        Created proper Alpha Exception and Trap structure definitions.

--*/

#ifndef _ALPHAH_
#define _ALPHAH_


// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

#if defined(_ALPHA_)
#ifdef __cplusplus
extern "C" {
#endif

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the Alpha compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

// end_wdm
#define POWER_LEVEL  7

// end_ntndis end_ntosp
// begin_wdm
//
// Include the Alpha instruction definitions
//

#include "alphaops.h"

//
// Include reference machine definitions.
//

#include "alpharef.h"

// end_ntddk end_wdm

//
// Define intrinsic PAL calls and their prototypes
//
void __di(void);
void __MB(void);
void __dtbis(void *);
void __ei(void);
void *__rdpcr(void);
void *__rdthread(void);
void __ssir(unsigned long);
unsigned char __swpirql(unsigned char);
void __tbia(void);
void __tbis(void *);
void __tbisasn(void *, unsigned long);

#if defined(_M_ALPHA) || defined(_M_AXP64)
#pragma intrinsic(__di)
#pragma intrinsic(__MB)
#pragma intrinsic(__dtbis)
#pragma intrinsic(__ei)
#pragma intrinsic(__rdpcr)
#pragma intrinsic(__rdthread)
#pragma intrinsic(__ssir)
#pragma intrinsic(__swpirql)
#pragma intrinsic(__tbia)
#pragma intrinsic(__tbis)
#pragma intrinsic(__tbisasn)
#endif

//
// Define Alpha Axp Processor Ids.
//

#if !defined(PROCESSOR_ALPHA_21064)
#define PROCESSOR_ALPHA_21064 (21064)
#endif // !PROCESSOR_ALPHA_21064

#if !defined(PROCESSOR_ALPHA_21164)
#define PROCESSOR_ALPHA_21164 (21164)
#endif // !PROCESSOR_ALPHA_21164

#if !defined(PROCESSOR_ALPHA_21066)
#define PROCESSOR_ALPHA_21066 (21066)
#endif // !PROCESSOR_ALPHA_21066

#if !defined(PROCESSOR_ALPHA_21068)
#define PROCESSOR_ALPHA_21068 (21068)
#endif // !PROCESSOR_ALPHA_21068

#if !defined(PROCESSOR_ALPHA_21164PC)
#define PROCESSOR_ALPHA_21164PC (21165)
#endif // !PROCESSOR_ALPHA_21164PC

#if !defined(PROCESSOR_ALPHA_21264)
#define PROCESSOR_ALPHA_21264 (21264)
#endif // !PROCESSOR_ALPHA_21264

// end_nthal

//
// Define Processor Control Region Structure.
//

typedef
VOID
(*PKTRAP_ROUTINE)(
    VOID
    );

// begin_ntddk begin_nthal
//
// Define macro to generate import names.
//

#define IMPORT_NAME(name) __imp_##name

//
// Define length of interrupt vector table.
//
// begin_ntosp

#define MAXIMUM_VECTOR 256

//
// Define bus error routine type.
//

struct _EXCEPTION_RECORD;
struct _KEXCEPTION_FRAME;
struct _KTRAP_FRAME;

typedef
BOOLEAN
(*PKBUS_ERROR_ROUTINE) (
    IN struct _EXCEPTION_RECORD *ExceptionRecord,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );


#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Major and minor version numbers of the PCR.
//

    ULONG MinorVersion;
    ULONG MajorVersion;

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific PAL/HAL code and will
// not change from version to version of NT.

//
// PALcode information.
//

    ULONGLONG PalBaseAddress;
    ULONG PalMajorVersion;
    ULONG PalMinorVersion;
    ULONG PalSequenceVersion;
    ULONG PalMajorSpecification;
    ULONG PalMinorSpecification;

//
// Firmware restart information.
//

    ULONGLONG FirmwareRestartAddress;
    PVOID RestartBlock;

//
// Reserved per-processor region for the PAL (3K-8 bytes).
//

    ULONGLONG PalReserved[383];

//
// Alignment fixup count updated by PAL and read by kernel.
//

    ULONGLONG PalAlignmentFixupCount;

//
// Panic Stack Address.
//

    PVOID PanicStack;

//
// Processor parameters.
//

    ULONG ProcessorType;
    ULONG ProcessorRevision;
    ULONG PhysicalAddressBits;
    ULONG MaximumAddressSpaceNumber;
    ULONG PageSize;
    ULONG FirstLevelDcacheSize;
    ULONG FirstLevelDcacheFillSize;
    ULONG FirstLevelIcacheSize;
    ULONG FirstLevelIcacheFillSize;

//
// System Parameters.
//

    ULONG FirmwareRevisionId;
    UCHAR SystemType[8];
    ULONG SystemVariant;
    ULONG SystemRevision;
    UCHAR SystemSerialNumber[16];
    ULONG CycleClockPeriod;
    ULONG SecondLevelCacheSize;
    ULONG SecondLevelCacheFillSize;
    ULONG ThirdLevelCacheSize;
    ULONG ThirdLevelCacheFillSize;
    ULONG FourthLevelCacheSize;
    ULONG FourthLevelCacheFillSize;

//
// Pointer to processor control block.
//

    struct _KPRCB *Prcb;

//
// Processor identification.
//

    CCHAR Number;
    KAFFINITY SetMember;

//
// Reserved per-processor region for the HAL (.5K bytes).
//

    ULONGLONG HalReserved[64];

//
// IRQL mapping tables.
//

    ULONG IrqlTable[8];

#define SFW_IMT_ENTRIES 4
#define HDW_IMT_ENTRIES 128

    struct _IRQLMASK {
        USHORT IrqlTableIndex;   // synchronization irql level
        USHORT IDTIndex;         // vector in IDT
    } IrqlMask[SFW_IMT_ENTRIES + HDW_IMT_ENTRIES];

//
// Interrupt Dispatch Table (IDT).
//

    PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];

//
// Reserved vectors mask, these vectors cannot be attached to via
// standard interrupt objects.
//

    ULONG ReservedVectors;

//
// Complement of processor affinity mask.
//

    KAFFINITY NotMember;

    ULONG InterruptInProgress;
    ULONG DpcRequested;

//
// Pointer to machine check handler
//

    PKBUS_ERROR_ROUTINE MachineCheckError;

//
// DPC Stack.
//

    PVOID DpcStack;

//
// End of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.  Some of these values are
// reserved for chip-specific palcode.
// end_ntddk end_nthal
//

//
// Start of the operating system release dependent section of the PCR.
// This section may change from release to release and should not be
// addressed by vendor/platform specific HAL code.

    ULONG Spare1;

//
// Current process id.
//

    ULONG CurrentPid;

//
// Spare field.
//

    ULONG Spare2;

//
// System service dispatch start and end address used by get/set context.
//

    ULONG_PTR SystemServiceDispatchStart;
    ULONG_PTR SystemServiceDispatchEnd;

//
// Pointer to Idle thread.
//

    struct _KTHREAD *IdleThread;


} KPCR, *PKPCR; // ntddk nthal

// end_ntosp
// Define Processor Status Register structure
//

typedef struct _PSR {
    ULONG MODE: 1;
    ULONG INTERRUPT_ENABLE: 1;
    ULONG IRQL: 3;
} PSR, *PPSR;

//
// Define Interrupt Enable Register structure
//

typedef struct _IE {
    ULONG SoftwareInterruptEnables: 2;
    ULONG HardwareInterruptEnables: 6;
} IE, *PIE;

#define HARDWARE_PTE_DIRTY_MASK     0x4


#if defined(_AXP64_)

#define _HARDWARE_PTE_WORKING_SET_BITS  14

typedef struct _HARDWARE_PTE {
    ULONGLONG Valid : 1;
    ULONGLONG Reserved1 : 1;
    ULONGLONG FaultOnWrite : 1;
    ULONGLONG Reserved2 : 1;
    ULONGLONG Global : 1;
    ULONGLONG GranularityHint : 2;
    ULONGLONG Reserved3 : 1;
    ULONGLONG KernelReadAccess : 1;
    ULONGLONG UserReadAccess : 1;
    ULONGLONG Reserved4 : 2;
    ULONGLONG KernelWriteAccess : 1;
    ULONGLONG UserWriteAccess : 1;
    ULONGLONG Reserved5 : 2;
    ULONGLONG Write : 1;
    ULONGLONG CopyOnWrite: 1;
    ULONGLONG SoftwareWsIndex : _HARDWARE_PTE_WORKING_SET_BITS;
    ULONGLONG PageFrameNumber : 32;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// Define initialize page directory base
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase, pfn)  \
    *((PULONGLONG)(dirbase)) = 0;                      \
    ((PHARDWARE_PTE)(dirbase))->PageFrameNumber = pfn; \
    ((PHARDWARE_PTE)(dirbase))->Write = 1;             \
    ((PHARDWARE_PTE)(dirbase))->KernelReadAccess = 1;  \
    ((PHARDWARE_PTE)(dirbase))->KernelWriteAccess = 1; \
    ((PHARDWARE_PTE)(dirbase))->Global = 0;            \
    ((PHARDWARE_PTE)(dirbase))->FaultOnWrite = 0;      \
    ((PHARDWARE_PTE)(dirbase))->Valid = 1;

#else

typedef struct _HARDWARE_PTE {
    ULONG Valid: 1;
    ULONG Owner: 1;
    ULONG Dirty: 1;
    ULONG reserved: 1;
    ULONG Global: 1;
    ULONG GranularityHint: 2;
    ULONG Write: 1;
    ULONG CopyOnWrite: 1;
    ULONG PageFrameNumber: 23;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// Define initialize page directory base
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase, pfn) \
        ((PHARDWARE_PTE)(dirbase))->PageFrameNumber = pfn; \
        ((PHARDWARE_PTE)(dirbase))->Global = 0; \
        ((PHARDWARE_PTE)(dirbase))->Dirty = 1; \
        ((PHARDWARE_PTE)(dirbase))->Valid = 1;

#endif


// begin_nthal
//
// Define some constants for bus type
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 2

//
//  Define pointer to Processor Control Registers
//

// begin_ntddk

#define PCR ((PKPCR)__rdpcr())

// begin_ntosp

#if defined(_AXP64_)

#define KI_USER_SHARED_DATA 0xffffffffff000000UI64

#else

#define KI_USER_SHARED_DATA 0xff000000UL

#endif

#define SharedUserData ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)

// begin_wdm
//
// length of dispatch code in interrupt template
//
#define DISPATCH_LENGTH 4

//
// Define IRQL levels across the architecture.
//

#define PASSIVE_LEVEL   0
#define LOW_LEVEL       0
#define APC_LEVEL       1
#define DISPATCH_LEVEL  2
#define HIGH_LEVEL      7
#define SYNCH_LEVEL (IPI_LEVEL-1)

// end_ntddk end_wdm end_nthal end_ntosp

#define KiProfileIrql PROFILE_LEVEL     // enable portable code

//
// Define interrupt levels that cannot be connected
//

#define ILLEGAL_LEVEL  ( (1<<0) | (1<<APC_LEVEL) | (1<<DISPATCH_LEVEL) | \
                         (1<<CLOCK_LEVEL) | (1<<IPI_LEVEL) )
//
// Sanitize FPCR and PSR based on processor mode.
//
// ## tvb&jn - need to replace these with proper macros.
//

#define SANITIZE_FPCR(fpcr, mode) (fpcr)

//
// Define SANITIZE_PSR for Alpha.
//
// If kernel mode, then caller specifies  psr
//
// If user mode, then
//      force mode bit to user (1)
//      force interrupt enable bit to true (1)
//      force irql to 0
//
// In both cases insure that extraneous bits are not set
//

#define SANITIZE_PSR(psr, mode) \
    ( ((mode) == KernelMode) ?  \
        (psr & 0x3f) :          \
        (0x3) )

// begin_nthal begin_ntosp
//
// Exception frame
//
//  This frame is established when handling an exception. It provides a place
//  to save all nonvolatile registers. The volatile registers will already
//  have been saved in a trap frame.
//
//  The layout of the record conforms to a standard call frame since it is
//  used as such. Thus it contains a place to save a return address and is
//  padded so that it is EXACTLY a multiple of 32 bytes in length.
//
//
//  N.B - the 32-byte alignment is more stringent than required by the
//  calling standard (which requires 16-byte alignment), the 32-byte alignment
//  is established for performance reasons in the interaction with the PAL.
//

typedef struct _KEXCEPTION_FRAME {

    ULONGLONG IntRa;    // return address register, ra

    ULONGLONG FltF2;    // nonvolatile floating registers, f2 - f9
    ULONGLONG FltF3;
    ULONGLONG FltF4;
    ULONGLONG FltF5;
    ULONGLONG FltF6;
    ULONGLONG FltF7;
    ULONGLONG FltF8;
    ULONGLONG FltF9;

    ULONGLONG IntS0;    //  nonvolatile integer registers, s0 - s5
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;
    ULONGLONG IntS4;
    ULONGLONG IntS5;
    ULONGLONG IntFp;    // frame pointer register, fp/s6

    ULONGLONG SwapReturn;
    ULONG Psr;          // processor status
    ULONG Fill[5];      // padding for 32-byte stack frame alignment
                        // N.B. - Ulongs from the filler section are used
                        //        in ctxsw.s - do not delete

} KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;

// end_ntosp

//
// Trap Frame
//
//  This frame is established when handling a trap. It provides a place to
//  save all volatile registers. The nonvolatile registers are saved in an
//  exception frame or through the normal C calling conventions for saved
//  registers.
//
//  The layout of the record conforms to a standard call frame since it is
//  used as such. Thus it contains a place to save a return address and is
//  padded so that it is EXACTLY a multiple of 32 bytes in length.
//
//
//  N.B - the 32-byte alignment is more stringent than required by the
//  calling standard (which requires 16-byte alignment), the 32-byte alignment
//  is established for performance reasons in the interaction with the PAL.
//

typedef struct _KTRAP_FRAME {

    //
    // Fields saved in the PALcode.
    //

    ULONGLONG IntSp;    // $30: stack pointer register, sp
    ULONGLONG Fir;      // (fault instruction) continuation address
    ULONG Psr;          // processor status
    ULONG Fill1[1];     // unused
    ULONGLONG IntFp;    // $15: frame pointer register, fp/s6

    ULONGLONG IntA0;    // $16: argument registers, a0 - a3
    ULONGLONG IntA1;    // $17:
    ULONGLONG IntA2;    // $18:
    ULONGLONG IntA3;    // $19:

    ULONGLONG IntRa;    // $26: return address register, ra
    ULONGLONG IntGp;    // $29: global pointer register, gp
    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD) + 15) & (~15)];

    //
    // Volatile integer registers, s0 - s5 are nonvolatile.
    //

    ULONGLONG IntV0;    //  $0: return value register, v0
    ULONGLONG IntT0;    //  $1: temporary registers, t0 - t7
    ULONGLONG IntT1;    //  $2:
    ULONGLONG IntT2;    //  $3:
    ULONGLONG IntT3;    //  $4:
    ULONGLONG IntT4;    //  $5:
    ULONGLONG IntT5;    //  $6:
    ULONGLONG IntT6;    //  $7:
    ULONGLONG IntT7;    //  $8:

    ULONGLONG IntT8;    // $22: temporary registers, t8 - t11
    ULONGLONG IntT9;    // $23:
    ULONGLONG IntT10;   // $24:
    ULONGLONG IntT11;   // $25:

    ULONGLONG IntT12;   // $27: temporary register, t12
    ULONGLONG IntAt;    // $28: assembler temporary register, at

    ULONGLONG IntA4;    // $20: remaining argument registers a4 - a5
    ULONGLONG IntA5;    // $21:

    //
    // Volatile floating point registers, f2 - f9 are nonvolatile.
    //

    ULONGLONG FltF0;    // $f0:
    ULONGLONG Fpcr;     // floating point control register
    ULONGLONG FltF1;    // $f1:

    ULONGLONG FltF10;   // $f10: temporary registers, $f10 - $f30
    ULONGLONG FltF11;   // $f11:
    ULONGLONG FltF12;   // $f12:
    ULONGLONG FltF13;   // $f13:
    ULONGLONG FltF14;   // $f14:
    ULONGLONG FltF15;   // $f15:
    ULONGLONG FltF16;   // $f16:
    ULONGLONG FltF17;   // $f17:
    ULONGLONG FltF18;   // $f18:
    ULONGLONG FltF19;   // $f19:
    ULONGLONG FltF20;   // $f20:
    ULONGLONG FltF21;   // $f21:
    ULONGLONG FltF22;   // $f22:
    ULONGLONG FltF23;   // $f23:
    ULONGLONG FltF24;   // $f24:
    ULONGLONG FltF25;   // $f25:
    ULONGLONG FltF26;   // $f26:
    ULONGLONG FltF27;   // $f27:
    ULONGLONG FltF28;   // $f28:
    ULONGLONG FltF29;   // $f29:
    ULONGLONG FltF30;   // $f30:

    ULONG OldIrql;      // Previous Irql.
    ULONG PreviousMode; // Previous Mode.
    ULONG_PTR TrapFrame; //
    ULONG Fill2[3];     // padding for 32-byte stack frame alignment

} KTRAP_FRAME, *PKTRAP_FRAME;

#define KTRAP_FRAME_LENGTH ((sizeof(KTRAP_FRAME) + 15) & ~15)
#define KTRAP_FRAME_ALIGN (16)
#define KTRAP_FRAME_ROUND (KTRAP_FRAME_ALIGN - 1)

//
// Firmware Frame
//
//  The firmware frame is similar to the trap frame, but is built by the PAL
//  code that is active when the OS Loader is running. It does not contain an
//  exception record or NT style exception information.
//
//  Type field defintions and parameters.
//

#define FW_EXC_MCHK 0xdec0              // p1=icPerrStat, p2=dcPerrStat
#define FW_EXC_ARITH 0xdec1             // p1=excSum, p2=excMask
#define FW_EXC_INTERRUPT 0xdec2         // p1=isr, p2=ipl, p3=intid
#define FW_EXC_DFAULT 0xdec3            // p1=sp
#define FW_EXC_ITBMISS 0xdec4           // none
#define FW_EXC_ITBACV 0xdec5            // none
#define FW_EXC_NDTBMISS 0xdec6          // p1=sp
#define FW_EXC_PDTBMISS 0xdec7          // p1=sp
#define FW_EXC_UNALIGNED 0xdec8         // p1=sp
#define FW_EXC_OPCDEC 0xdec9            // p1=sp
#define FW_EXC_FEN 0xdeca               // p1=icsr
#define FW_EXC_HALT 0xdecb              // not used
#define FW_EXC_BPT 0xdecc               // p1=0 - user, p1=1 - kernel, p1=type - call kdbg
#define FW_EXC_GENTRAP 0xdecd           // p1=gentrap code
#define FW_EXC_HALT_INTERRUPT 0xdece    // p1=isr, p2=ipl, p3=intid

typedef struct _FIRMWARE_FRAME {
    ULONGLONG Type;
    ULONGLONG Param1;
    ULONGLONG Param2;
    ULONGLONG Param3;
    ULONGLONG Param4;
    ULONGLONG Param5;
    ULONGLONG Psr;
    ULONGLONG Mmcsr;
    ULONGLONG Va;
    ULONGLONG Fir;
    ULONGLONG IntV0;
    ULONGLONG IntT0;
    ULONGLONG IntT1;
    ULONGLONG IntT2;
    ULONGLONG IntT3;
    ULONGLONG IntT4;
    ULONGLONG IntT5;
    ULONGLONG IntT6;
    ULONGLONG IntT7;
    ULONGLONG IntS0;
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;
    ULONGLONG IntS4;
    ULONGLONG IntS5;
    ULONGLONG IntFp;
    ULONGLONG IntA0;
    ULONGLONG IntA1;
    ULONGLONG IntA2;
    ULONGLONG IntA3;
    ULONGLONG IntA4;
    ULONGLONG IntA5;
    ULONGLONG IntT8;
    ULONGLONG IntT9;
    ULONGLONG IntT10;
    ULONGLONG IntT11;
    ULONGLONG IntRa;
    ULONGLONG IntT12;
    ULONGLONG IntAt;
    ULONGLONG IntGp;
    ULONGLONG IntSp;
    ULONGLONG IntZero;
    ULONGLONG FltF0;
    ULONGLONG FltF1;
    ULONGLONG FltF2;
    ULONGLONG FltF3;
    ULONGLONG FltF4;
    ULONGLONG FltF5;
    ULONGLONG FltF6;
    ULONGLONG FltF7;
    ULONGLONG FltF8;
    ULONGLONG FltF9;
    ULONGLONG FltF10;
    ULONGLONG FltF11;
    ULONGLONG FltF12;
    ULONGLONG FltF13;
    ULONGLONG FltF14;
    ULONGLONG FltF15;
    ULONGLONG FltF16;
    ULONGLONG FltF17;
    ULONGLONG FltF18;
    ULONGLONG FltF19;
    ULONGLONG FltF20;
    ULONGLONG FltF21;
    ULONGLONG FltF22;
    ULONGLONG FltF23;
    ULONGLONG FltF24;
    ULONGLONG FltF25;
    ULONGLONG FltF26;
    ULONGLONG FltF27;
    ULONGLONG FltF28;
    ULONGLONG FltF29;
    ULONGLONG FltF30;
    ULONGLONG FltF31;
} FIRMWARE_FRAME, *PFIRMWARE_FRAME;

#define FIRMWARE_FRAME_LENGTH sizeof(FIRMWARE_FRAME)

//
// The frame saved by KiCallUserMode is defined here to allow
// the kernel debugger to trace the entire kernel stack
// when usermode callouts are pending.
//

typedef struct _KCALLOUT_FRAME {
    ULONGLONG   F2;   // saved floating registers f2 - f9
    ULONGLONG   F3;
    ULONGLONG   F4;
    ULONGLONG   F5;
    ULONGLONG   F6;
    ULONGLONG   F7;
    ULONGLONG   F8;
    ULONGLONG   F9;
    ULONGLONG   S0;   // saved integer registers s0 - s5
    ULONGLONG   S1;
    ULONGLONG   S2;
    ULONGLONG   S3;
    ULONGLONG   S4;
    ULONGLONG   S5;
    ULONGLONG   FP;
    ULONGLONG   CbStk;  // saved callback stack address
    ULONGLONG   InStk;  // saved initial stack address
    ULONGLONG   TrFr;   // saved callback trap frame address
    ULONGLONG   TrFir;
    ULONGLONG   Ra;     // saved return address
    ULONGLONG   A0;     // saved argument registers a0-a2
    ULONGLONG   A1;
} KCALLOUT_FRAME, *PKCALLOUT_FRAME;

typedef struct _UCALLOUT_FRAME {
    PVOID Buffer;
    ULONG Length;
    ULONG ApiNumber;
    ULONG Pad;
    ULONGLONG Sp;
    ULONGLONG Ra;
} UCALLOUT_FRAME, *PUCALLOUT_FRAME;

//
// Define Machine Check Status code that is passed in the exception
// record for a machine check exception.
//

typedef struct _MCHK_STATUS {
    ULONG Correctable: 1;
    ULONG Retryable: 1;
} MCHK_STATUS, *PMCHK_STATUS;

//
// Define the MCES register (Machine Check Error Summary).
//

typedef struct _MCES {
    ULONG MachineCheck: 1;
    ULONG SystemCorrectable: 1;
    ULONG ProcessorCorrectable: 1;
    ULONG DisableProcessorCorrectable: 1;
    ULONG DisableSystemCorrectable: 1;
    ULONG DisableMachineChecks: 1;
} MCES, *PMCES;

// end_nthal

// begin_ntddk begin_wdm begin_ntosp
//
// Non-volatile floating point state
//

typedef struct _KFLOATING_SAVE {
    ULONGLONG   Fpcr;
    ULONGLONG   SoftFpcr;
    ULONG       Reserved1;              // These reserved words are here to make it
    ULONG       Reserved2;              // the same size as i386/WDM.
    ULONG       Reserved3;
    ULONG       Reserved4;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

// end_ntddk end_wdm end_ntosp
//
// Define Alpha status code aliases. These are internal to PALcode and
// kernel trap handling.
//

#define STATUS_ALPHA_FLOATING_NOT_IMPLEMENTED    STATUS_ILLEGAL_FLOAT_CONTEXT
#define STATUS_ALPHA_ARITHMETIC_EXCEPTION    STATUS_FLOAT_STACK_CHECK
#define STATUS_ALPHA_GENTRAP    STATUS_INSTRUCTION_MISALIGNMENT

//
// Define status code for bad virtual address.  This status differs from
// those above in that it will be forwarded to the offending code.  In lieu
// of defining a new status code, we wlll alias this to an access violation.
// Code can distinguish this error from an access violation by checking
// the number of parameters: a standard access violation has 2 parameters,
// while a non-canonical virtual address access violation will have 3
// parameters (the third parameter is the upper 32-bits of the non-canonical
// virtual address.
//

#define STATUS_ALPHA_BAD_VIRTUAL_ADDRESS    STATUS_ACCESS_VIOLATION

// begin_nthal begin_ntosp
//
// Define the halt reason codes.
//

#define AXP_HALT_REASON_HALT 0
#define AXP_HALT_REASON_REBOOT 1
#define AXP_HALT_REASON_RESTART 2
#define AXP_HALT_REASON_POWERFAIL 3
#define AXP_HALT_REASON_POWEROFF 4
#define AXP_HALT_REASON_PALMCHK 6
#define AXP_HALT_REASON_DBLMCHK 7

// Processor State frame: Before a processor freezes itself, it
// dumps the processor state to the processor state frame for
// debugger to examine.  This is used by KeFreezeExecution and
// KeUnfreezeExecution routines.
//

typedef struct _KPROCESSOR_STATE {
    struct _CONTEXT ContextFrame;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

// begin_ntddk
//
// Processor Control Block (PRCB)
//

#define PRCB_MINOR_VERSION 1
#define PRCB_MAJOR_VERSION 2
#define PRCB_BUILD_DEBUG        0x0001
#define PRCB_BUILD_UNIPROCESSOR 0x0002

typedef struct _KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;
    CCHAR Number;
    CCHAR Reserved;
    USHORT BuildType;
    KAFFINITY SetMember;
    struct _RESTART_BLOCK *RestartBlock;

//
// End of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
// end_ntddk end_nthal

    ULONG InterruptCount;
    ULONG DpcTime;
    ULONG InterruptTime;
    ULONG KernelTime;
    ULONG UserTime;
    KDPC QuantumEndDpc;

//
// Address of PCR.
//

    PKPCR Pcr;

//
// MP Information.
//

    struct _KNODE * ParentNode;         // Node this processor is a member of
    PVOID Spare3;
    volatile ULONG IpiFrozen;
    struct _KPROCESSOR_STATE ProcessorState;
    ULONG LastDpcCount;
    ULONG DpcBypassCount;
    ULONG SoftwareInterrupts;
    PKTRAP_FRAME InterruptTrapFrame;
    ULONG ApcBypassCount;
    ULONG DispatchInterruptCount;
    ULONG DebugDpcTime;
    PVOID Spares[6];

//
// Spares.
//

    PVOID MoreSpares[3];
    PKIPI_COUNTS IpiCounts;

//
// Per-processor data for various hot code which resides in the
// kernel image.  We give each processor it's own copy of the data
// to lessen the caching impact of sharing the data between multiple
// processors.
//

//
//  Spares (formerly fsrtl filelock free lists)
//

    PVOID SpareHotData[2];

//
// Cache manager performance counters.
//

    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadNotPossible;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;

//
// Kernel performance counters.
//

    ULONG KeAlignmentFixupCount;
    ULONG KeContextSwitches;
    ULONG KeDcacheFlushCount;
    ULONG KeExceptionDispatchCount;
    ULONG KeFirstLevelTbFills;
    ULONG KeFloatingEmulationCount;
    ULONG KeIcacheFlushCount;
    ULONG KeSecondLevelTbFills;
    ULONG KeSystemCalls;
    ULONG KeByteWordEmulationCount;

//
//  Reserved for future counters.
//

    ULONG ReservedCounter[1];

//
// I/O system per processor single entry lookaside lists.
//

    PVOID SmallIrpFreeEntry;
    PVOID LargeIrpFreeEntry;
    PVOID MdlFreeEntry;

//
// Object manager per processor single entry lookaside lists.
//

    PVOID CreateInfoFreeEntry;
    PVOID NameBufferFreeEntry;

//
// Cache manager per processor single entry lookaside lists.
//

    PVOID SharedCacheMapEntry;

//
//  Spares (formerly fsrtl filelock free lists)
//

#if defined(_AXP64_)

    PVOID MoreSpareHotData[1];

#else

    PVOID MoreSpareHotData[2];

#endif

//
// Nonpaged per processor lookaside lists.
//

    PP_LOOKASIDE_LIST PPLookasideList[16];

//
// Nonpaged per processor small pool lookaside lists.
//

    PP_LOOKASIDE_LIST PPNPagedLookasideList[POOL_SMALL_LISTS];

//
// Paged per processor small pool lookaside lists.
//

    PP_LOOKASIDE_LIST PPPagedLookasideList[POOL_SMALL_LISTS];

//
// Per processor lock queue entries.
//

    KSPIN_LOCK_QUEUE LockQueue[16];

//
// Reserved Pad.
//

#if defined(_AXP64_)

    UCHAR ReservedPad[(20 * 8) - 4];

#else

    UCHAR ReservedPad[(24 * 8) - 4];

#endif

//
// MP interprocessor request packet barrier.
//
// N.B. This is carefully allocated in a different cache line from
//      the request packet.
//

   volatile ULONG PacketBarrier;

//
// MP interprocessor request packet and summary.
//
// N.B. This is carefully aligned to be on a cache line boundary.
//

    volatile PVOID CurrentPacket[3];
    volatile KAFFINITY TargetSet;
    volatile PKIPI_WORKER WorkerRoutine;
    ULONG CachePad1[11];

//
// N.B. These two longwords must be on a quadword boundary and adjacent.
//

    volatile ULONGLONG RequestSummary;

//
// Spare counters.
//

    ULONG Spare4[14];
    ULONG DpcInterruptRequested;
    ULONG Spare5[17];
    ULONG CachePad2[1];
    ULONG PageColor;
    ULONG MaximumDpcQueueDepth;
    ULONG MinimumDpcRate;
    ULONG AdjustDpcThreshold;
    ULONG DpcRequestRate;
    LARGE_INTEGER StartCount;
//
// DPC list head, spinlock, and count.
//

    LIST_ENTRY DpcListHead;
    KSPIN_LOCK DpcLock;
    ULONG DpcCount;
    ULONG QuantumEnd;
    ULONG DpcRoutineActive;
    ULONG DpcQueueDepth;

    BOOLEAN SkipTick;

//
// Processor's power state
//
    PROCESSOR_POWER_STATE PowerState;

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;      // ntddk nthal

// begin_ntddk begin_wdm begin_nthal begin_ntndis
//
// I/O space read and write macros.
//
//  These have to be actual functions on Alpha, because we need
//  to shift the VA and OR in the BYTE ENABLES.
//
//  These can become INLINEs if we require that ALL Alpha systems shift
//  the same number of bits and have the SAME byte enables.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space?
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space?
//

NTHALAPI
UCHAR
READ_REGISTER_UCHAR(
    PUCHAR Register
    );

NTHALAPI
USHORT
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTHALAPI
ULONG
READ_REGISTER_ULONG(
    PULONG Register
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTHALAPI
VOID
WRITE_REGISTER_UCHAR(
    PUCHAR Register,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_REGISTER_ULONG(
    PULONG Register,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
READ_PORT_UCHAR(
    PUCHAR Port
    );

NTHALAPI
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

// end_ntndis end_wdm
//
// Define Interlocked operation result values.
//

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for value are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

//
// Convert portable interlock interfaces to architecture specific interfaces.
//


#define ExInterlockedIncrementLong(Addend, Lock) \
    ExAlphaInterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend, Lock) \
    ExAlphaInterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target, Value, Lock) \
    ExAlphaInterlockedExchangeUlong(Target, Value)

NTKERNELAPI
INTERLOCKED_RESULT
ExAlphaInterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
ExAlphaInterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
ExAlphaInterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

//  begin_wdm

#if defined(_M_ALPHA) && !defined(RC_INVOKED)

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd

LONG
InterlockedIncrement (
    IN OUT PLONG Addend
    );

LONG
InterlockedDecrement (
    IN OUT PLONG Addend
    );

LONG
InterlockedExchange (
    IN OUT PLONG Target,
    LONG Value
    );

#if defined(_M_AXP64)

#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedCompareExchange64 _InterlockedCompareExchange64
#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer
#define InterlockedExchange64 _InterlockedExchange64

LONG
InterlockedCompareExchange (
    IN OUT PLONG Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

LONGLONG
InterlockedCompareExchange64 (
    IN OUT PLONGLONG Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

PVOID
InterlockedExchangePointer (
    IN OUT PVOID *Target,
    IN PVOID Value
    );

PVOID
InterlockedCompareExchangePointer (
    IN OUT PVOID *Destination,
    IN PVOID ExChange,
    IN PVOID Comperand
    );

LONGLONG
InterlockedExchange64(
    IN OUT PLONGLONG Target,
    IN LONGLONG Value
    );

#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)
#pragma intrinsic(_InterlockedExchange64)

#else

#define InterlockedExchangePointer(Target, Value) \
    (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

#define InterlockedCompareExchange(Destination, ExChange, Comperand) \
    (LONG)_InterlockedCompareExchange((PVOID *)(Destination), (PVOID)(ExChange), (PVOID)(Comperand))

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    _InterlockedCompareExchange(Destination, ExChange, Comperand)

PVOID
_InterlockedCompareExchange (
    IN OUT PVOID *Destination,
    IN PVOID ExChange,
    IN PVOID Comperand
    );

NTKERNELAPI
LONGLONG
InterlockedCompareExchange64 (
    IN OUT PLONGLONG Destination,
    IN LONGLONG Exchange,
    IN LONGLONG Comperand
    );

NTKERNELAPI
LONGLONG
ExpInterlockedCompareExchange64 (
    IN OUT PLONGLONG Destination,
    IN PLONGLONG Exchange,
    IN PLONGLONG Comperand
    );

#endif

LONG
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Value
    );

#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)

#endif

// there is a lot of other stuff that could go in here
//   probe macros
//   others
// end_ntddk end_wdm end_nthal end_ntosp
//
// Intrinsic interlocked functions.
//


// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

//
// Define the page size for the Alpha ev4 and lca as 8k.
//

#define PAGE_SIZE 0x2000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 13L

// end_ntddk end_wdm end_nthal end_ntndis

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#if defined(_AXP64_)

#define PDI_SHIFT 23
#define PDI1_SHIFT 33
#define PDI2_SHIFT 23
#define PDI_MASK 0x3ff

#else

#define PDI_SHIFT 24

#endif

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 13

//
// Define the maximum address space number allowable for the architecture.
//

#define ALPHA_AXP_MAXIMUM_ASN 0xffffffff

// begin_ntddk begin_nthal

//
// The highest user address reserves 64K bytes for a guard page. This is so
// the probing of addresses from kernel mode only have to check the
// starting address for structures of 64K bytes or less.
//

#if defined(_AXP64_)

#define MM_HIGHEST_USER_ADDRESS (PVOID)0x3FFFFFEFFFF // highest user address
#define MM_USER_PROBE_ADDRESS          0x3FFFFFF0000UI64 // guard page address
#define MM_SYSTEM_RANGE_START   (PVOID)0xFFFFFC0000000000 // start of system space

#else

#define MM_HIGHEST_USER_ADDRESS (PVOID)0x7FFEFFFF // highest user address
#define MM_USER_PROBE_ADDRESS 0x7FFF0000 // starting address of guard page
#define MM_SYSTEM_RANGE_START (PVOID)KSEG0_BASE // start of system space

#endif


//
// The following definitions are required for the debugger data block.
//

extern PVOID MmHighestUserAddress;
extern PVOID MmSystemRangeStart;
extern ULONG_PTR MmUserProbeAddress;

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS  (PVOID)0x00010000

// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

// end_ntddk end_wdm end_nthal

//
// Define the page table base and the page directory base for
// the TB miss routines and memory management.
//

#if defined(_AXP64_)

#define PDE_TBASE 0xFFFFFE0180600000UI64 // first level PDR address
#define PDE_SELFMAP 0xFFFFFE0180601800UI64 // first level PDR self map address
#define PDE_UBASE 0xFFFFFE0180000000UI64 // user second level PDR address
#define PDE_KBASE 0xFFFFFE01807FE000UI64 // kernel second level PDR address
#define PDE_BASE PDE_KBASE              // kernel second level PDR address
#define PTE_BASE 0xFFFFFE0000000000UI64 // page table address
#define PDE64_BASE 0xFFFFFE0180600000UI64 // first level PDR address
#define PTE64_BASE 0xFFFFFE0000000000UI64 // page table address
#define VA_SHIFT (63 - 42)              // address sign extend shift count

#else

#define PDE_BASE (ULONG)0xC0180000      // first level PDR address
#define PDE_SELFMAP (ULONG)0xC0180300   // first level PDR self map address
#define PTE_BASE (ULONG)0xC0000000      // page table address
#define PDE64_BASE (ULONG)0xC0184000    // first level 64-bit PDR address
#define PTE64_BASE (ULONG)0xC2000000    // 64-bit page table address

#endif

// end_ntosp

//
// Generate kernel segment physical address.
//

#if defined(_AXP64_)

#define KSEG_ADDRESS(FrameNumber) \
    ((PVOID)(KSEG43_BASE | ((ULONG_PTR)(FrameNumber) << PAGE_SHIFT)))

#else

#define KSEG_ADDRESS(FrameNumber) \
    ((PVOID)(KSEG0_BASE | ((ULONG)(FrameNumber) << PAGE_SHIFT)))

#endif

// begin_ntddk begin_wdm
//
// The lowest address for system space.
//

#if defined(_AXP64_)

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xFFFFFE0200000000

#else

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000

#endif

// end_ntddk end_wdm

#if defined(_AXP64_)

#define SYSTEM_BASE 0xFFFFFE0200000000  // start of system space (no typecast)

#else

#define SYSTEM_BASE 0xc0800000          // start of system space (no typecast)

#endif

// begin_nthal begin_ntddk begin_wdm begin_ntosp

//
// Define prototypes to access PCR values
//

NTKERNELAPI
KIRQL
KeGetCurrentIrql();

// end_nthal end_ntddk end_wdm

#if defined(_M_ALPHA)
#define KeGetCurrentThread() ((struct _KTHREAD *) __rdthread())
#endif

// begin_ntddk begin_wdm

NTSTATUS
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTSTATUS
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );

// end_ntddk end_wdm
// begin_nthal

#define KeGetPreviousMode() (KeGetCurrentThread()->PreviousMode)

// end_ntosp

#define KeGetDcacheFillSize() PCR->FirstLevelDcacheFillSize

//
// Test if executing DPC.
//

BOOLEAN
KeIsExecutingDpc (
    VOID
    );

//
// Return interrupt trap frame
//
PKTRAP_FRAME
KeGetInterruptTrapFrame(
    VOID
    );

// begin_ntddk begin_ntosp
//
// Get address of current PRCB.
//

#define KeGetCurrentPrcb() (PCR->Prcb)

//
// Get current processor number.
//

#define KeGetCurrentProcessorNumber() KeGetCurrentPrcb()->Number

// end_ntddk end_ntosp

//
// Define interface to get pcr address
//

PKPCR KeGetPcr(VOID);

// end_nthal

//
// Data cache, instruction cache, I/O buffer, and write buffer flush routine
// prototypes.
//

VOID
KeSweepDcache (
    IN BOOLEAN AllProcessors
    );

#define KeSweepCurrentDcache() \
    HalSweepDcache();

VOID
KeSweepIcache (
    IN BOOLEAN AllProcessors
    );

VOID
KeSweepIcacheRange (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG_PTR Length
    );

#define KeSweepCurrentIcache() \
    HalSweepIcache();

VOID
KeFlushIcacheRange (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG_PTR Length
    );

// begin_ntddk begin_wdm begin_ntndis begin_nthal begin_ntosp
//
// Cache and write buffer flush functions.
//

VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );

// end_ntddk end_wdm end_ntndis end_ntosp

//
// Clock, profile, and interprocessor interrupt functions.
//

struct _KEXCEPTION_FRAME;
struct _KTRAP_FRAME;

NTKERNELAPI
VOID
KeIpiInterrupt (
    IN struct _KTRAP_FRAME *TrapFrame
    );

#define KeYieldProcessor()

NTKERNELAPI
VOID
KeProfileInterrupt (
    VOID
    );

// begin_ntosp

NTKERNELAPI
VOID
KeProfileInterruptWithSource (
    IN KPROFILE_SOURCE ProfileSource
    );

// end_ntosp

NTKERNELAPI
VOID
KeUpdateRunTime (
    VOID
    );

NTKERNELAPI
VOID
KeUpdateSystemTime (
    IN ULONG TimeIncrement
    );

//
// The following function prototypes are exported for use in MP HALs.
//


#if defined(NT_UP)

#define KiAcquireSpinLock(SpinLock)

#else

VOID
KiAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

#if defined(NT_UP)

#define KiReleaseSpinLock(SpinLock)

#else

VOID
KiReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

// end_nthal

//
// KeTestSpinLock may be used to spin at low IRQL until the lock is
// available.  The IRQL must then be raised and the lock acquired with
// KeTryToAcquireSpinLock.  If that fails, lower the IRQL and start again.
//

#if defined(NT_UP)

#define KeTestSpinLock(SpinLock) (TRUE)

#else

BOOLEAN
KeTestSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif


//
// Fill TB entry.
//

#define KeFillEntryTb(Pte, Virtual, Invalid) \
    if (Invalid != FALSE) { \
        KeFlushSingleTb(Virtual, FALSE, FALSE, Pte, *Pte); \
    }

NTKERNELAPI                                         // nthal
VOID                                                // nthal
KeFlushCurrentTb (                                  // nthal
    VOID                                            // nthal
    );                                              // nthal
                                                    // nthal
//
// Define machine-specific external references.
//

extern ULONG KiInterruptTemplate[];

//
// Define machine-dependent function prototypes.
//

VOID
KeFlushDcache (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress OPTIONAL,
    IN ULONG Length
    );

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    );

BOOLEAN
KiEmulateByteWord(
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN OUT struct _KTRAP_FRAME *TrapFrame
    );

BOOLEAN
KiEmulateFloating (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN OUT struct _KTRAP_FRAME *TrapFrame,
    IN OUT PSW_FPCR SoftwareFpcr
    );

BOOLEAN
KiEmulateReference (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN OUT struct _KTRAP_FRAME *TrapFrame
    );

BOOLEAN
KiFloatingException (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN OUT struct _KTRAP_FRAME *TrapFrame,
    IN BOOLEAN ImpreciseTrap,
    OUT PULONG SoftFpcrCopy
    );

ULONGLONG
KiGetRegisterValue (
    IN ULONG Register,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiSetFloatingStatus (
    IN OUT PEXCEPTION_RECORD ExceptionRecord
    );

VOID
KiSetRegisterValue (
    IN ULONG Register,
    IN ULONGLONG Value,
    OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    OUT struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiRequestSoftwareInterrupt (
    KIRQL RequestIrql
    );

//
// Define query tick count macro.
//
// begin_ntddk begin_nthal begin_ntosp

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

//  begin_wdm

#define KeQueryTickCount(CurrentCount ) \
    *(PULONGLONG)(CurrentCount) = **((volatile ULONGLONG **)(&KeTickCount));

//  end_wdm

#else

#define KiQueryTickCount(CurrentCount) \
    *(PULONGLONG)(CurrentCount) = KeTickCount.QuadPart;

VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// end_ntddk end_nthal end_ntosp

//
// Define executive macros for acquiring and releasing executive spinlocks.
// These macros can ONLY be used by executive components and NOT by drivers.
// Drivers MUST use the kernel interfaces since they must be MP enabled on
// all systems.
//
// KeRaiseIrql is one instruction shorter than KeAcquireSpinLock on Alpha UP.
// KeLowerIrql is one instruction shorter than KeReleaseSpinLock.
//

#if defined(NT_UP) && !defined(_NTDDK_) && !defined(_NTIFS_)
#define ExAcquireSpinLock(Lock, OldIrql) KeRaiseIrql(DISPATCH_LEVEL, (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock)
#else

//  begin_wdm begin_ntddk begin_ntosp

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

//  end_wdm end_ntddk end_ntosp

#endif

//
// The acquire and release fast lock macros disable and enable interrupts
// on UP nondebug systems. On MP or debug systems, the spinlock routines
// are used.
//
// N.B. Extreme caution should be observed when using these routines.
//

#if defined(_M_ALPHA)

#define _disable() __di()
#define _enable() __ei()

#endif

#if defined(NT_UP) && !DBG
#define ExAcquireFastLock(Lock, OldIrql) \
    ExAcquireSpinLock(Lock, OldIrql)
#else
#define ExAcquireFastLock(Lock, OldIrql) \
    ExAcquireSpinLock(Lock, OldIrql)
#endif

#if defined(NT_UP) && !DBG
#define ExReleaseFastLock(Lock, OldIrql) \
    ExReleaseSpinLock(Lock, OldIrql)
#else
#define ExReleaseFastLock(Lock, OldIrql) \
    ExReleaseSpinLock(Lock, OldIrql)
#endif


//
// Alpha function definitions
//

//++
//
// BOOLEAN
// KiIsThreadNumericStateSaved(
//     IN PKTHREAD Address
//     )
//
//  This call is used on a not running thread to see if it's numeric
//  state has been saved in its context information.  On Alpha the
//  numeric state is always saved.
//
//--

#define KiIsThreadNumericStateSaved(a) TRUE

//++
//
// VOID
// KiRundownThread(
//     IN PKTHREAD Address
//     )
//
//--

#define KiRundownThread(a)

//
// Alpha Feature bit definitions
//
#define KF_BYTE         0x00000001

//
// Define macro to test if x86 feature is present.
//
// N.B. All x86 features test TRUE on Alpha systems.
//

#define Isx86FeaturePresent(_f_) TRUE

// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp
#ifdef __cplusplus
}   // extern "C"
#endif
#endif // _ALPHA_
// end_ntddk end_wdm end_nthal end_ntndis end_ntosp

#endif // _ALPHAH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fstub\halfnc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    hanfnc.c

Abstract:

    Default handlers for HAL functions which don't get handlers
    installed by the HAL.

Author:

    Ken Reneris (kenr) 19-July-1994

Revision History:

--*/

#include "ntos.h"
#include "haldisp.h"

HAL_DISPATCH HalDispatchTable = {
    HAL_DISPATCH_VERSION,
    xHalQuerySystemInformation,
    xHalSetSystemInformation,
    xHalQueryBusSlots,
    0,
    HalExamineMBR,
    IoAssignDriveLetters,
    IoReadPartitionTable,
    IoSetPartitionInformation,
    IoWritePartitionTable,
    xHalHandlerForBus,                  // HalReferenceHandlerByBus
    xHalReferenceHandler,               // HalReferenceBusHandler
    xHalReferenceHandler,               // HalDereferenceBusHandler
    xHalInitPnpDriver,
    xHalInitPowerManagement,
    0,
    xHalGetInterruptTranslator,
    xHalStartMirroring,
    xHalEndMirroring,
    xHalMirrorPhysicalMemory,
    xHalEndOfBoot,
    xHalMirrorVerify
    };

HAL_PRIVATE_DISPATCH HalPrivateDispatchTable = {
    HAL_PRIVATE_DISPATCH_VERSION,
    xHalHandlerForBus,
    xHalHandlerForBus,
    xHalLocateHiberRanges,
    xHalRegisterBusHandler,
    xHalSetWakeEnable,
    xHalSetWakeAlarm,
    xHalTranslateBusAddress,
    xHalAssignSlotResources,
    xHalHaltSystem,
    (NULL),                             // HalFindBusAddressTranslation
    (NULL),                             // HalResetDisplay
    xKdSetupPciDeviceForDebugging,
    xKdReleasePciDeviceForDebugging,
    xKdGetAcpiTablePhase0,
    xKdCheckPowerButton,
    xHalVectorToIDTEntry,
    xKdMapPhysicalMemory64,
    xKdUnmapVirtualAddress,
    };

#if 0
DMA_OPERATIONS HalPrivateDmaOperations = {
    sizeof(DMA_OPERATIONS),
    xHalPutDmaAdapter,
    xHalAllocateCommonBuffer,
    xHalFreeCommonBuffer,
    xHalAllocateAdapterChannel,
    xHalFlushAdapterBuffers,
    xHalFreeAdapterChannel,
    xHalFreeMapRegisters,
    xHalMapTransfer,
    xHalGetDmaAlignment,
    xHalReadDmaCounter,
    xHalGetScatterGatherList,
    xHalPutScatterGatherList
    };
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,   xHalLocateHiberRanges)
#pragma alloc_text(PAGE,   xHalQuerySystemInformation)
#pragma alloc_text(PAGE,   xHalSetSystemInformation)
#pragma alloc_text(PAGE,   xHalQueryBusSlots)
#pragma alloc_text(PAGE,   xHalRegisterBusHandler)
#pragma alloc_text(PAGE,   xHalStartMirroring)
#pragma alloc_text(PAGE,   xHalEndOfBoot)
#pragma alloc_text(PAGELK, xHalSetWakeEnable)
#pragma alloc_text(PAGELK, xHalSetWakeAlarm)
#endif


//
// Global dispatch table for HAL apis
//


//
// Stub handlers for HALs which don't provide the above functions
//

NTSTATUS
xHalQuerySystemInformation(
    IN HAL_QUERY_INFORMATION_CLASS InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    )
{
    PAGED_CODE ();
    return STATUS_INVALID_LEVEL;
}

NTSTATUS
xHalSetSystemInformation(
    IN HAL_SET_INFORMATION_CLASS InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer
    )
{
    PAGED_CODE ();
    return STATUS_INVALID_LEVEL;
}

NTSTATUS
xHalQueryBusSlots(
    IN PBUS_HANDLER         BusHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    )
{
    PAGED_CODE ();
    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
xHalRegisterBusHandler(
    IN INTERFACE_TYPE          InterfaceType,
    IN BUS_DATA_TYPE           ConfigurationSpace,
    IN ULONG                   BusNumber,
    IN INTERFACE_TYPE          ParentBusType,
    IN ULONG                   ParentBusNumber,
    IN ULONG                   SizeofBusExtensionData,
    IN PINSTALL_BUS_HANDLER    InstallBusHandler,
    OUT PBUS_HANDLER           *BusHandler
    )
{
    PAGED_CODE ();
    return STATUS_NOT_SUPPORTED;
}


VOID
xHalSetWakeEnable(
    IN BOOLEAN              Enable
    )
{
}


VOID
xHalSetWakeAlarm(
    IN ULONGLONG        WakeTime,
    IN PTIME_FIELDS     WakeTimeFields
    )
{
}

VOID
xHalLocateHiberRanges (
    IN PVOID MemoryMap
    )
{
}

PBUS_HANDLER
FASTCALL
xHalHandlerForBus (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    )
{
    return NULL;
}

VOID
FASTCALL
xHalReferenceHandler (
    IN PBUS_HANDLER     Handler
    )
{
}
NTSTATUS
xHalInitPnpDriver(
    VOID
    )
{
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
xHalInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    )
{
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
xHalStartMirroring(
    VOID
    )
{
    PAGED_CODE ();
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
xHalEndMirroring(
    IN ULONG PassNumber
    )
{
    UNREFERENCED_PARAMETER (PassNumber);

    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
xHalMirrorPhysicalMemory(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN LARGE_INTEGER NumberOfBytes
    )
{
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
xHalMirrorVerify(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN LARGE_INTEGER NumberOfBytes
    )
{
    return STATUS_NOT_SUPPORTED;
}

#if 0
PDMA_ADAPTER
xHalGetDmaAdapter (
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
{
    PADAPTER_OBJECT AdapterObject;

    AdapterObject = ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof( ADAPTER_OBJECT ),
                                           ' laH');

    if (AdapterObject == NULL) {
        return NULL;
    }

    AdapterObject->DmaAdapter.Size = sizeof( ADAPTER_OBJECT );
    AdapterObject->DmaAdapter.Version = 1;
    AdapterObject->DmaAdapter.DmaOperations = &HalPrivateDmaOperations;
    AdapterObject->RealAdapterObject = HalGetAdapter( DeviceDescriptor,
                                                      NumberOfMapRegisters );

    if (AdapterObject->RealAdapterObject == NULL) {

        //
        // No adapter object was returned.  Just return NULL to the caller.
        //

        ExFreePool( AdapterObject );
        return NULL;
    }

    return &AdapterObject->DmaAdapter;
}

VOID
xHalPutDmaAdapter (
    PDMA_ADAPTER DmaAdapter
    )
{
    ExFreePool( DmaAdapter );
}

PVOID
xHalAllocateCommonBuffer (
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    )
{
    return HalAllocateCommonBuffer( ((PADAPTER_OBJECT) DmaAdapter)->RealAdapterObject,
                                    Length,
                                    LogicalAddress,
                                    CacheEnabled );

}

VOID
xHalFreeCommonBuffer (
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    )
{
    HalFreeCommonBuffer( ((PADAPTER_OBJECT) DmaAdapter)->RealAdapterObject,
                         Length,
                         LogicalAddress,
                         VirtualAddress,
                         CacheEnabled );

}

NTSTATUS
xHalAllocateAdapterChannel (
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )
{
    return IoAllocateAdapterChannel( ((PADAPTER_OBJECT) DmaAdapter)->RealAdapterObject,
                                     DeviceObject,
                                     NumberOfMapRegisters,
                                     ExecutionRoutine,
                                     Context );

}

BOOLEAN
xHalFlushAdapterBuffers (
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )
{
    return IoFlushAdapterBuffers( ((PADAPTER_OBJECT) DmaAdapter)->RealAdapterObject,
                                  Mdl,
                                  MapRegisterBase,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice );

}

VOID
xHalFreeAdapterChannel (
    IN PDMA_ADAPTER DmaAdapter
    )
{
    IoFreeAdapterChannel( ((PADAPTER_OBJECT) DmaAdapter)->RealAdapterObject );
}

VOID
xHalFreeMapRegisters (
    IN PDMA_ADAPTER DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    )

{
    IoFreeMapRegisters( ((PADAPTER_OBJECT) DmaAdapter)->RealAdapterObject,
                        MapRegisterBase,
                        NumberOfMapRegisters );
}

PHYSICAL_ADDRESS
xHalMapTransfer (
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    )
{
    return IoMapTransfer( ((PADAPTER_OBJECT) DmaAdapter)->RealAdapterObject,
                           Mdl,
                           MapRegisterBase,
                           CurrentVa,
                           Length,
                           WriteToDevice );
}

ULONG
xHalGetDmaAlignment (
    IN PDMA_ADAPTER DmaAdapter
    )
{
    return HalGetDmaAlignmentRequirement();
}

ULONG
xHalReadDmaCounter (
    IN PDMA_ADAPTER DmaAdapter
    )
{
    return HalReadDmaCounter( ((PADAPTER_OBJECT) DmaAdapter)->RealAdapterObject );
}


NTSTATUS
xHalGetScatterGatherList (
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter
    object.  Next a scatter/gather list is built based on the MDL, the
    CurrentVa and the requested Length.  Finally the driver's execution
    function is called with the scatter/gather list.  The adapter is
    released after the execution function returns.

    The scatter/gather list is freed by calling PutScatterGatherList.

Arguments:

    DmaAdapter - Pointer to the adapter control object to allocate for the
        driver.

    DeviceObject - Pointer to the device object that is allocating the
        adapter.

    Mdl - Pointer to the MDL that describes the pages of memory that are being
        read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

    WriteToDevice - Supplies the value that indicates whether this is a
        write to the device from memory (TRUE), or vice versa.

Return Value:

    Returns STATUS_SUCCESS unless too many map registers are requested or
    memory for the scatter/gather list could not be allocated.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

    The data in the buffer cannot be accessed until the put scatter/gather function has been called.

--*/

{
    PXHAL_WAIT_CONTEXT_BLOCK WaitBlock;
    PWAIT_CONTEXT_BLOCK Wcb;
    PMDL TempMdl;
    ULONG NumberOfMapRegisters;
    ULONG ContextSize;
    ULONG TransferLength;
    ULONG MdlLength;
    ULONG MdlCount;
    PUCHAR MdlVa;
    NTSTATUS Status;

    MdlVa = MmGetMdlVirtualAddress(Mdl);

    //
    // Calculate the number of required map registers.
    //

    TempMdl = Mdl;
    TransferLength = TempMdl->ByteCount - (ULONG)((PUCHAR) CurrentVa - MdlVa);
    MdlLength = TransferLength;

    MdlVa = (PUCHAR) BYTE_OFFSET(CurrentVa);
    NumberOfMapRegisters = 0;
    MdlCount = 1;

    //
    // Loop through the any chained MDLs accumulating the required
    // number of map registers.
    //

    while (TransferLength < Length && TempMdl->Next != NULL) {

        NumberOfMapRegisters += (ULONG)(((ULONG_PTR) MdlVa + MdlLength + PAGE_SIZE - 1) >>
                                    PAGE_SHIFT);

        TempMdl = TempMdl->Next;
        MdlVa = (PUCHAR) TempMdl->ByteOffset;
        MdlLength = TempMdl->ByteCount;
        TransferLength += MdlLength;
        MdlCount++;
    }

    if (TransferLength + PAGE_SIZE < (ULONG_PTR)(Length + MdlVa) ) {
        ASSERT(TransferLength >= Length);
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Calculate the last number of map registers based on the requested
    // length - not the length of the last MDL.
    //

    ASSERT( TransferLength <= MdlLength + Length );

    NumberOfMapRegisters += (ULONG)(((ULONG_PTR) MdlVa + Length + MdlLength - TransferLength +
                             PAGE_SIZE - 1) >> PAGE_SHIFT);

    //
    // Calculate how much memory is required for the context structure.  This
    // this actually laid out as follows:
    //
    //   XHAL_WAIT_CONTEXT_BLOCK;
    //   MapRegisterBase[ MdlCount ];
    //   union {
    //      WAIT_CONTEXT_BLOCK[ MdlCount ];
    //      SCATTER_GATHER_LIST [ NumberOfMapRegisters ];
    //   };
    //

    ContextSize = NumberOfMapRegisters * sizeof( SCATTER_GATHER_ELEMENT ) +
                  sizeof( SCATTER_GATHER_LIST );

    //
    // For each Mdl a separate Wcb is required since a separate map
    // register base must be allocated.
    //

    if (ContextSize < sizeof( WAIT_CONTEXT_BLOCK ) * MdlCount) {

        ContextSize = sizeof( WAIT_CONTEXT_BLOCK ) * MdlCount;
    }

    ContextSize += sizeof( XHAL_WAIT_CONTEXT_BLOCK ) +
                    MdlCount * sizeof( PVOID );
    WaitBlock = ExAllocatePoolWithTag( NonPagedPool, ContextSize, ' laH' );

    if (WaitBlock == NULL) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    // Store the wait context block at the end of our block.
    // All of the information in the wait block can be overwritten
    // by the scatter/gather list.
    //

    Wcb = (PWAIT_CONTEXT_BLOCK) ((PVOID *) (WaitBlock + 1) + MdlCount);

    //
    // Save the interesting data in the wait block.
    //

    WaitBlock->Mdl = Mdl;
    WaitBlock->CurrentVa = CurrentVa;
    WaitBlock->Length = Length;
    WaitBlock->RealAdapterObject = ((PADAPTER_OBJECT) DmaAdapter)->RealAdapterObject;
    WaitBlock->DriverExecutionRoutine = ExecutionRoutine;
    WaitBlock->DriverContext = Context;
    WaitBlock->CurrentIrp = DeviceObject->CurrentIrp;
    WaitBlock->MapRegisterLock = MdlCount;
    WaitBlock->WriteToDevice = WriteToDevice;
    WaitBlock->MdlCount = (UCHAR) MdlCount;

    //
    // Loop through each of the required MDLs, calling
    // IoAllocateAdapterChannel.
    //

    MdlCount = 0;

    TempMdl = Mdl;
    TransferLength = Length;
    MdlLength = TempMdl->ByteCount - (ULONG)((PUCHAR) CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    MdlVa = (PUCHAR) BYTE_OFFSET(CurrentVa);
    NumberOfMapRegisters = 0;

    //
    // Loop through the chained MDLs accumulating the required
    // number of map registers.
    //

    while (TransferLength > 0) {

        if (MdlLength > TransferLength) {

            MdlLength = TransferLength;
        }

        TransferLength -= MdlLength;

        NumberOfMapRegisters = (ULONG)(((ULONG_PTR) MdlVa + MdlLength + PAGE_SIZE - 1) >>
                                    PAGE_SHIFT);

        Wcb->DeviceContext = WaitBlock;
        Wcb->DeviceObject = DeviceObject;

        //
        // Store the map register index in the IRP pointer.
        //

        Wcb->CurrentIrp = (PVOID) MdlCount;

        //
        // Call the HAL to allocate the adapter channel.
        // xHalpAllocateAdapterCallback will fill in the scatter/gather list.
        //

        Status = HalAllocateAdapterChannel( ((PADAPTER_OBJECT) DmaAdapter)->RealAdapterObject,
                                            Wcb,
                                            NumberOfMapRegisters,
                                            xHalpAllocateAdapterCallback );

        if (TempMdl->Next == NULL) {
            break;
        }

        //
        // Advance to next MDL.
        //

        TempMdl = TempMdl->Next;
        MdlVa = (PUCHAR) TempMdl->ByteOffset;
        MdlLength = TempMdl->ByteCount;
        MdlCount++;
        Wcb++;
    }

    //
    // If HalAllocateAdapterChannel failed then free the wait block.
    //

    if (!NT_SUCCESS( Status)) {
        ExFreePool( WaitBlock );
    }

    return( Status );
}



VOID
xHalPutScatterGatherList (
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    )
{
    PXHAL_WAIT_CONTEXT_BLOCK WaitBlock = (PVOID) ScatterGather->Reserved;
    ULONG TransferLength;
    ULONG MdlLength;
    ULONG MdlCount = 0;
    PMDL Mdl;
    PUCHAR CurrentVa;

    //
    // Setup for the first MDL.  We expect the MDL pointer to be pointing
    // at the first used MDL.
    //

    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;
    ASSERT( CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl) && CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount );

    MdlLength = Mdl->ByteCount - (ULONG)(CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));
    TransferLength = WaitBlock->Length;

    //
    // Loop through the used MDLs calling IoFlushAdapterBuffers.
    //

    while (TransferLength >  0) {

        if (MdlLength > TransferLength) {

            MdlLength = TransferLength;
        }

        TransferLength -= MdlLength;

        IoFlushAdapterBuffers( WaitBlock->RealAdapterObject,
                                Mdl,
                                WaitBlock->MapRegisterBase[MdlCount],
                                CurrentVa,
                                MdlLength,
                                WriteToDevice );


        if (Mdl->Next == NULL) {
            break;
        }

        //
        // Advance to the next MDL.  Update the current VA and the MdlLength.
        //

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
        MdlCount++;
    }

    ExFreePool( WaitBlock );

}

IO_ALLOCATION_ACTION
xHalpAllocateAdapterCallback (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the adapter object and map registers are
    available for the data transfer. This routine saves the map register
    base away.  If all of the required bases have not been saved then it
    returns. Otherwise it builds the entire scatter/gather list by calling
    IoMapTransfer.  After the list is built, it is passed to the driver.

Arguments:

    DeviceObject - Pointer to the device object that is allocating the
        adapter.

    Irp - Supplies the map register offset assigned for this callback.

    MapRegisterBase - Supplies the map register base for use by the adapter
        routines.

    Context - Supplies a pointer to the xhal wait control block.

Return Value:

    Returns DeallocateObjectKeepRegisters.


--*/
{
    PXHAL_WAIT_CONTEXT_BLOCK WaitBlock = Context;
    PVOID *MapRegisterBasePtr;
    ULONG TransferLength;
    LONG MdlLength;
    PMDL Mdl;
    PUCHAR CurrentVa;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;

    //
    // Save the map register base in the appropriate slot.
    //

    WaitBlock->MapRegisterBase[ (ULONG_PTR) Irp ] = MapRegisterBase;

    //
    // See if this is the last callback.
    //

    if (InterlockedDecrement( &WaitBlock->MapRegisterLock ) != 0) {

        //
        // More to come, wait for the rest.
        //

        return( DeallocateObjectKeepRegisters );

    }

    //
    // Put the scatter gather list after wait block. Add a back pointer to
    // the beginning of the wait block.
    //

    MapRegisterBasePtr = (PVOID *) (WaitBlock + 1);
    ScatterGather = (PSCATTER_GATHER_LIST) (MapRegisterBasePtr +
                        WaitBlock->MdlCount);
    ScatterGather->Reserved = (ULONG_PTR) WaitBlock;
    Element = ScatterGather->Elements;

    //
    // Setup for the first MDL.  We expect the MDL pointer to be pointing
    // at the first used MDL.
    //

    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;
    ASSERT( CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl) && CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount );

    MdlLength = Mdl->ByteCount - (ULONG)(CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));
    TransferLength = WaitBlock->Length;

    //
    // Loop build the list for each MDL.
    //

    while (TransferLength >  0) {

        if ((ULONG) MdlLength > TransferLength) {

            MdlLength = TransferLength;
        }

        TransferLength -= MdlLength;

        //
        // Loop building the list for the elements within an MDL.
        //

        while (MdlLength > 0) {

            Element->Length = MdlLength;
            Element->Address = IoMapTransfer( WaitBlock->RealAdapterObject,
                                            Mdl,
                                            *MapRegisterBasePtr,
                                            CurrentVa,
                                            &Element->Length,
                                            WaitBlock->WriteToDevice );

            ASSERT( (ULONG) MdlLength >= Element->Length );
            MdlLength -= Element->Length;
            CurrentVa += Element->Length;
            Element++;
        }

        if (Mdl->Next == NULL) {

            //
            // There are a few cases where the buffer described by the MDL
            // is less than the transfer length.  This occurs when the
            // file system is transfering the last page of the file and MM
            // defines the MDL to be file size and the file system rounds
            // the write up to a sector.  This extra amount should never
            // cross a page boundary. Add this extra to the length of the
            // last element.
            //

            ASSERT(((Element - 1)->Length & (PAGE_SIZE - 1)) + TransferLength <= PAGE_SIZE );
            (Element - 1)->Length += TransferLength;

            break;
        }

        //
        // Advance to the next MDL.  Update the current VA and the MdlLength.
        //

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
        MapRegisterBasePtr++;

    }

    //
    // Set the number of elements actually used.
    //

    ScatterGather->NumberOfElements = (ULONG)(Element - ScatterGather->Elements);

    //
    // Call the driver with the scatter/gather list.
    //

    WaitBlock->DriverExecutionRoutine( DeviceObject,
                                       WaitBlock->CurrentIrp,
                                       ScatterGather,
                                       WaitBlock->DriverContext );

    return( DeallocateObjectKeepRegisters );
}
#endif
BOOLEAN
xHalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
{
    //
    // If the HAL fails to override this function, then
    // the HAL has clearly failed to initialize.
    //

    KeBugCheckEx(HAL_INITIALIZATION_FAILED, 0, 0, 0, 7);
    return FALSE;
}

NTSTATUS
xHalAssignSlotResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    )
{
    //
    // If the HAL fails to override this function, then
    // the HAL has clearly failed to initialize.
    //

    KeBugCheckEx(HAL_INITIALIZATION_FAILED, 0, 0, 0, 7);
    return STATUS_NOT_IMPLEMENTED;
}

VOID
xHalHaltSystem(
    VOID
    )
{
    for (;;) ;
}

NTSTATUS
xKdSetupPciDeviceForDebugging(
    IN     PVOID                     LoaderBlock,   OPTIONAL    
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
xKdReleasePciDeviceForDebugging(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    )
{
    return STATUS_NOT_IMPLEMENTED;
}

PVOID
xKdGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    )
{
    return NULL;
}

VOID
xKdCheckPowerButton(
    VOID
    )
{
    return;
}

VOID
xHalEndOfBoot(
    VOID
    )
{
    PAGED_CODE();
    return;
}

UCHAR
xHalVectorToIDTEntry(
    ULONG Vector
    )
{
    return (UCHAR)Vector;
}

PVOID
xKdMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    )
{
    return NULL;
}

VOID
xKdUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fstub\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=fstub

TARGETNAME=fstub
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..\..\inc

SOURCES=..\halfnc.c     \
        ..\drivesup.c   \
        ..\translate.c  \
        ..\ex.c

NTTEST=

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\apmlib.h ===
/*++

Module Name:

    apmlib.h

Abstract:

    Interfaces used for apm support, setup, etc.

Author:

Revision History:

--*/

BOOLEAN IsSystemACPI();

BOOLEAN IsApmActive();

ULONG   IsApmPresent();

#define APM_NOT_PRESENT             0
#define APM_PRESENT_BUT_NOT_USABLE  1
#define APM_ON_GOOD_LIST            2
#define APM_NEUTRAL                 3
#define APM_ON_BAD_LIST             4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fstub\translate.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    translate.c

Abstract:

    This is the default pnp IRQ translator.

Author:

    Andy Thornton (andrewth) 7-June-97

Environment:

    Kernel Mode Driver.

Notes:

    This should only be temporary and will be replaced by a call into the HAL
    to retrieve its translators.

Revision History:

--*/


#include "ntos.h"
#include "haldisp.h"
#include <wdmguid.h>

//
// Iteration macros
//

//
// Control macro (used like a for loop) which iterates over all entries in
// a standard doubly linked list.  Head is the list head and the entries are of
// type Type.  A member called ListEntry is assumed to be the LIST_ENTRY
// structure linking the entries together.  Current contains a pointer to each
// entry in turn.
//
#define FOR_ALL_IN_LIST(Type, Head, Current)                            \
    for((Current) = CONTAINING_RECORD((Head)->Flink, Type, ListEntry);  \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = CONTAINING_RECORD((Current)->ListEntry.Flink,        \
                                     Type,                              \
                                     ListEntry)                         \
       )
//
// Similar to the above only iteration is over an array of length _Size.
//
#define FOR_ALL_IN_ARRAY(_Array, _Size, _Current)                       \
    for ( (_Current) = (_Array);                                        \
          (_Current) < (_Array) + (_Size);                              \
          (_Current)++ )

//
// As above only iteration begins with the entry _Current
//
#define FOR_REST_IN_ARRAY(_Array, _Size, _Current)                      \
    for ( ;                                                             \
          (_Current) < (_Array) + (_Size);                              \
          (_Current)++ )

#define HAL_IRQ_TRANSLATOR_VERSION 0

NTSTATUS
FstubTranslateResource(
    IN  PVOID Context,
    IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN  RESOURCE_TRANSLATION_DIRECTION Direction,
    IN  ULONG AlternativesCount OPTIONAL,
    IN  IO_RESOURCE_DESCRIPTOR Alternatives[] OPTIONAL,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
FstubTranslateRequirement (
    IN  PVOID Context,
    IN  PIO_RESOURCE_DESCRIPTOR Source,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

VOID
FstubTranslatorNull(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,xHalGetInterruptTranslator)
#pragma alloc_text(PAGE,FstubTranslateResource)
#pragma alloc_text(PAGE,FstubTranslateRequirement)
#pragma alloc_text(PAGE,FstubTranslatorNull)
#endif


NTSTATUS
xHalGetInterruptTranslator(
	IN INTERFACE_TYPE ParentInterfaceType,
	IN ULONG ParentBusNumber,
	IN INTERFACE_TYPE BridgeInterfaceType,
	IN USHORT Size,
	IN USHORT Version,
	OUT PTRANSLATOR_INTERFACE Translator,
	OUT PULONG BridgeBusNumber
	)
/*++

Routine Description:


Arguments:

	ParentInterfaceType - The type of the bus the bridge lives on (normally PCI).

	ParentBusNumber - The number of the bus the bridge lives on.

	ParentSlotNumber - The slot number the bridge lives in (where valid).

	BridgeInterfaceType - The bus type the bridge provides (ie ISA for a PCI-ISA bridge).

	ResourceType - The resource type we want to translate.

	Size - The size of the translator buffer.

	Version - The version of the translator interface requested.

	Translator - Pointer to the buffer where the translator should be returned

	BridgeBusNumber - Pointer to where the bus number of the bridge bus should be returned

Return Value:

    Returns the status of this operation.

--*/
{
    PAGED_CODE();

#if defined(NO_LEGACY_DRIVERS)
    return STATUS_SUCCESS;
}
#else

    UNREFERENCED_PARAMETER(ParentInterfaceType);
    UNREFERENCED_PARAMETER(ParentBusNumber);

    ASSERT(Version == HAL_IRQ_TRANSLATOR_VERSION);
    ASSERT(Size >= sizeof (TRANSLATOR_INTERFACE));

    switch (BridgeInterfaceType) {
    case Eisa:
    case Isa:
    case MicroChannel:
    case InterfaceTypeUndefined:    // special "IDE" cookie

        //
        // Pass back an interface for an IRQ translator.
        //
        RtlZeroMemory(Translator, sizeof (TRANSLATOR_INTERFACE));

        Translator->Size = sizeof (TRANSLATOR_INTERFACE);
        Translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
        Translator->InterfaceReference = &FstubTranslatorNull;
        Translator->InterfaceDereference = &FstubTranslatorNull;
        Translator->TranslateResources = &FstubTranslateResource;
        Translator->TranslateResourceRequirements = &FstubTranslateRequirement;

        if (BridgeInterfaceType == InterfaceTypeUndefined) {
            Translator->Context = (PVOID)Isa;
        } else {
            Translator->Context = (PVOID)BridgeInterfaceType;
        }

        return STATUS_SUCCESS;

    default:
        return STATUS_NOT_IMPLEMENTED;
    }
}

NTSTATUS
FstubTranslateResource(
    IN  PVOID Context,
    IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN  RESOURCE_TRANSLATION_DIRECTION Direction,
    IN  ULONG AlternativesCount OPTIONAL,
    IN  IO_RESOURCE_DESCRIPTOR Alternatives[] OPTIONAL,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
{
    NTSTATUS status;
    ULONG affinity, currentVector, translatedVector;
    KIRQL irql;
    PIO_RESOURCE_DESCRIPTOR currentAlternative;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);

    //
    // Copy unchanged fields
    //

    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Perform the translation - The interrupt source is
        // ISA.
        //

        Target->u.Interrupt.Vector = HalGetInterruptVector(
                                         (INTERFACE_TYPE)(ULONG_PTR)Context,
                                         0,     // assume bus 0
                                         Source->u.Interrupt.Vector,
                                         Source->u.Interrupt.Vector,
                                         &irql,
                                         &affinity
                                         );

        Target->u.Interrupt.Level = irql;
        Target->u.Interrupt.Affinity = affinity;

        status = STATUS_TRANSLATION_COMPLETE;

        break;

    case TranslateParentToChild:

        //
        // Translate each alternative and when we match then use the value we
        // just translated
        //

        FOR_ALL_IN_ARRAY(Alternatives, AlternativesCount, currentAlternative) {

            ASSERT(currentAlternative->Type == CmResourceTypeInterrupt);

            currentVector = currentAlternative->u.Interrupt.MinimumVector;

            while (currentVector <=
                       currentAlternative->u.Interrupt.MaximumVector) {

                translatedVector = HalGetInterruptVector((INTERFACE_TYPE)(ULONG_PTR)Context,
                                                         0, // assume bus 0
                                                         currentVector,
                                                         currentVector,
                                                         &irql,
                                                         &affinity
                                                        );



                if (translatedVector == Source->u.Interrupt.Vector) {

                    //
                    // We found our vector - fill in the target and return
                    //

                    Target->u.Interrupt.Vector = currentVector;
                    Target->u.Interrupt.Level = Target->u.Interrupt.Vector;
                    Target->u.Interrupt.Affinity = 0xFFFFFFFF;
                    return STATUS_SUCCESS;
                }

                currentVector++;
            }

        }

        status = STATUS_UNSUCCESSFUL;

        break;
    }

    return status;
}
NTSTATUS
FstubTranslateRequirement (
    IN  PVOID Context,
    IN  PIO_RESOURCE_DESCRIPTOR Source,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
{
    ULONG affinity;
    KIRQL irql;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    'btsF'
                                    );

    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *TargetCount = 1;

    //
    // Copy unchanged fields
    //

    **Target = *Source;

    (*Target)->u.Interrupt.MinimumVector =
        HalGetInterruptVector(
            (INTERFACE_TYPE)(ULONG_PTR)Context,
            0,     // assume bus 0 
            Source->u.Interrupt.MinimumVector,
            Source->u.Interrupt.MinimumVector,
            &irql,
            &affinity
            );


    (*Target)->u.Interrupt.MaximumVector =
        HalGetInterruptVector(
            (INTERFACE_TYPE)(ULONG_PTR)Context,
            0,     // assume bus 0
            Source->u.Interrupt.MaximumVector,
            Source->u.Interrupt.MaximumVector,
            &irql,
            &affinity
            );


    return STATUS_TRANSLATION_COMPLETE;
}

VOID
FstubTranslatorNull(
    IN PVOID Context
    )
{
    PAGED_CODE();
    return;
}
#endif // NO_LEGACY_DRIVERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\fstub\haldisp.h ===
/*++ BUILD Version: 0001

Copyright (c) 1994  Microsoft Corporation

Module Name:

    haldisp.h

Abstract:

    This module contains the private structure definitions and APIs used by
    the NT haldisp

Author:


Revision History:


--*/

//
// Strcuture definitions.
//

typedef struct _ADAPTER_OBJECT {
    DMA_ADAPTER DmaAdapter;
    PADAPTER_OBJECT RealAdapterObject;
}ADAPTER_OBJECT;

typedef struct _XHAL_WAIT_CONTEXT_BLOCK {
    PMDL Mdl;
    PVOID CurrentVa;
    ULONG Length;
    PADAPTER_OBJECT RealAdapterObject;
    PDRIVER_LIST_CONTROL DriverExecutionRoutine;
    PVOID DriverContext;
    PIRP CurrentIrp;
    ULONG MapRegisterLock;
    UCHAR WriteToDevice;
    UCHAR MdlCount;
    PVOID MapRegisterBase[];
} XHAL_WAIT_CONTEXT_BLOCK, *PXHAL_WAIT_CONTEXT_BLOCK;

//
// Function prototypes
//

NTSTATUS
xHalQuerySystemInformation(
    IN HAL_QUERY_INFORMATION_CLASS InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    );

NTSTATUS
xHalSetSystemInformation(
    IN HAL_SET_INFORMATION_CLASS InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer
    );

NTSTATUS
xHalQueryBusSlots(
    IN PBUS_HANDLER         BusHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    );

VOID
xHalSetWakeEnable(
    IN BOOLEAN              Enable
    );

VOID
xHalSetWakeAlarm(
    IN ULONGLONG        WakeTime,
    IN PTIME_FIELDS     WakeTimeFields
    );

VOID
xHalLocateHiberRanges(
    IN PVOID MemoryMap
    );

NTSTATUS
xHalRegisterBusHandler(
    IN INTERFACE_TYPE          InterfaceType,
    IN BUS_DATA_TYPE           ConfigurationSpace,
    IN ULONG                   BusNumber,
    IN INTERFACE_TYPE          ParentBusType,
    IN ULONG                   ParentBusNumber,
    IN ULONG                   SizeofBusExtensionData,
    IN PINSTALL_BUS_HANDLER    InstallBusHandlers,
    OUT PBUS_HANDLER           *BusHandler
    );

PBUS_HANDLER
FASTCALL
xHalHandlerForBus (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    );

VOID
FASTCALL
xHalReferenceHandler (
    IN PBUS_HANDLER     Handler
    );

NTSTATUS
xHalInitPnpDriver(
    VOID
    );

NTSTATUS
xHalInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    );

PDMA_ADAPTER
xHalGetDmaAdapter (
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

VOID
xHalPutDmaAdapter (
    PDMA_ADAPTER DmaAdapter
    );

PVOID
xHalAllocateCommonBuffer (
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

VOID
xHalFreeCommonBuffer (
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

NTSTATUS
xHalAllocateAdapterChannel (
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

BOOLEAN
xHalFlushAdapterBuffers (
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

VOID
xHalFreeAdapterChannel (
    IN PDMA_ADAPTER DmaAdapter
    );

VOID
xHalFreeMapRegisters (
    IN PDMA_ADAPTER DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    );

PHYSICAL_ADDRESS
xHalMapTransfer (
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );

ULONG
xHalGetDmaAlignment (
    IN PDMA_ADAPTER DmaAdapter
    );

ULONG
xHalReadDmaCounter (
    IN PDMA_ADAPTER DmaAdapter
    );

NTSTATUS
xHalGetScatterGatherList (
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );


VOID
xHalPutScatterGatherList (
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    );

IO_ALLOCATION_ACTION
xHalpAllocateAdapterCallback (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );
    
NTSTATUS
xHalGetInterruptTranslator(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );

BOOLEAN
xHalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );
    
NTSTATUS
xHalAssignSlotResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

VOID
xHalHaltSystem(
    VOID
    );

NTSTATUS
xHalStartMirroring(
    VOID
    );

NTSTATUS
xHalEndMirroring(
    IN ULONG PassNumber
    );

NTSTATUS
xHalMirrorPhysicalMemory(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN LARGE_INTEGER NumberOfBytes
    );

NTSTATUS
xHalMirrorVerify(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN LARGE_INTEGER NumberOfBytes
    );

NTSTATUS
xKdSetupPciDeviceForDebugging(
    IN     PVOID                     LoaderBlock,   OPTIONAL    
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    );

NTSTATUS
xKdReleasePciDeviceForDebugging(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    );
    
PVOID
xKdGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    );

VOID
xKdCheckPowerButton(
    VOID
    );

VOID
xHalEndOfBoot(
    VOID
    );

UCHAR
xHalVectorToIDTEntry(
    ULONG Vector
    );

PVOID
xKdMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    );

VOID
xKdUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\amd64.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    amd64.h

Abstract:

    This module contains the AMD64 hardware specific header file.

Author:

    David N. Cutler (davec) 3-May-2000

Revision History:

--*/

#ifndef __amd64_
#define __amd64_

#if !(defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_)) && !defined(_BLDR_)

#define ExRaiseException RtlRaiseException
#define ExRaiseStatus RtlRaiseStatus

#endif

// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

#if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define intrinsic function to do in's and out's.
//

#ifdef __cplusplus
extern "C" {
#endif

UCHAR
__inbyte (
    IN USHORT Port
    );

USHORT
__inword (
    IN USHORT Port
    );

ULONG
__indword (
    IN USHORT Port
    );

VOID
__outbyte (
    IN USHORT Port,
    IN UCHAR Data
    );

VOID
__outword (
    IN USHORT Port,
    IN USHORT Data
    );

VOID
__outdword (
    IN USHORT Port,
    IN ULONG Data
    );

VOID
__inbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__inwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__indwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

VOID
__outbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__outwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__outdwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic(__inbyte)
#pragma intrinsic(__inword)
#pragma intrinsic(__indword)
#pragma intrinsic(__outbyte)
#pragma intrinsic(__outword)
#pragma intrinsic(__outdword)
#pragma intrinsic(__inbytestring)
#pragma intrinsic(__inwordstring)
#pragma intrinsic(__indwordstring)
#pragma intrinsic(__outbytestring)
#pragma intrinsic(__outwordstring)
#pragma intrinsic(__outdwordstring)

//
// Interlocked intrinsic functions.
//

#define InterlockedAnd _InterlockedAnd
#define InterlockedOr _InterlockedOr
#define InterlockedXor _InterlockedXor
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedAdd _InterlockedAdd
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange

#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedOr64 _InterlockedOr64
#define InterlockedXor64 _InterlockedXor64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64

#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer

#ifdef __cplusplus
extern "C" {
#endif

LONG
InterlockedAnd (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
InterlockedOr (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
InterlockedXor (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG64
InterlockedAnd64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG64
InterlockedOr64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG64
InterlockedXor64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG
InterlockedIncrement(
    IN OUT LONG volatile *Addend
    );

LONG
InterlockedDecrement(
    IN OUT LONG volatile *Addend
    );

LONG
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG
InterlockedAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    )

{
    return InterlockedExchangeAdd(Addend, Value) + Value;
}

#endif

LONG
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

LONG64
InterlockedIncrement64(
    IN OUT LONG64 volatile *Addend
    );

LONG64
InterlockedDecrement64(
    IN OUT LONG64 volatile *Addend
    );

LONG64
InterlockedExchange64(
    IN OUT LONG64 volatile *Target,
    IN LONG64 Value
    );

LONG64
InterlockedExchangeAdd64(
    IN OUT LONG64 volatile *Addend,
    IN LONG64 Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG64
InterlockedAdd64(
    IN OUT LONG64 volatile *Addend,
    IN LONG64 Value
    )

{
    return InterlockedExchangeAdd64(Addend, Value) + Value;
}

#endif

LONG64
InterlockedCompareExchange64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 ExChange,
    IN LONG64 Comperand
    );

PVOID
InterlockedCompareExchangePointer (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
InterlockedExchangePointer(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#ifdef __cplusplus
}
#endif

#endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#if defined(_AMD64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG64 SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG64 PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the AMD64 compiler supports the allocate pragmas.
//

#define ALLOC_PRAGMA 1
#define ALLOC_DATA_PRAGMA 1

// end_ntddk end_nthal end_ntndis end_wdm end_ntosp


//
// Length on interrupt object dispatch code in longwords.
// (shielint) Reserve 9*4 space for ABIOS stack mapping.  If NO
//            ABIOS support the size of DISPATCH_LENGTH should be 74.
//

// begin_nthal

#define NORMAL_DISPATCH_LENGTH 106                  // ntddk wdm
#define DISPATCH_LENGTH NORMAL_DISPATCH_LENGTH      // ntddk wdm
                                                    // ntddk wdm

// begin_ntosp
//
// Define constants for bits in CR0.
//

#define CR0_PE 0x00000001               // protection enable
#define CR0_MP 0x00000002               // math present
#define CR0_EM 0x00000004               // emulate math coprocessor
#define CR0_TS 0x00000008               // task switched
#define CR0_ET 0x00000010               // extension type (80387)
#define CR0_NE 0x00000020               // numeric error
#define CR0_WP 0x00010000               // write protect
#define CR0_AM 0x00040000               // alignment mask
#define CR0_NW 0x20000000               // not write-through
#define CR0_CD 0x40000000               // cache disable
#define CR0_PG 0x80000000               // paging

//
// Define functions to read and write CR0.
//

#ifdef __cplusplus
extern "C" {
#endif


#define ReadCR0() __readcr0()

ULONG64
__readcr0 (
    VOID
    );

#define WriteCR0(Data) __writecr0(Data)

VOID
__writecr0 (
    IN ULONG64 Data
    );

#pragma intrinsic(__readcr0)
#pragma intrinsic(__writecr0)

//
// Define functions to read and write CR3.
//

#define ReadCR3() __readcr3()

ULONG64
__readcr3 (
    VOID
    );

#define WriteCR3(Data) __writecr3(Data)

VOID
__writecr3 (
    IN ULONG64 Data
    );

#pragma intrinsic(__readcr3)
#pragma intrinsic(__writecr3)

//
// Define constants for bits in CR4.
//

#define CR4_VME 0x00000001              // V86 mode extensions
#define CR4_PVI 0x00000002              // Protected mode virtual interrupts
#define CR4_TSD 0x00000004              // Time stamp disable
#define CR4_DE  0x00000008              // Debugging Extensions
#define CR4_PSE 0x00000010              // Page size extensions
#define CR4_PAE 0x00000020              // Physical address extensions
#define CR4_MCE 0x00000040              // Machine check enable
#define CR4_PGE 0x00000080              // Page global enable
#define CR4_FXSR 0x00000200             // FXSR used by OS
#define CR4_XMMEXCPT 0x00000400         // XMMI used by OS

//
// Define functions to read and write CR4.
//

#define ReadCR4() __readcr4()

ULONG64
__readcr4 (
    VOID
    );

#define WriteCR4(Data) __writecr4(Data)

VOID
__writecr4 (
    IN ULONG64 Data
    );

#pragma intrinsic(__readcr4)
#pragma intrinsic(__writecr4)

//
// Define functions to read and write CR8.
//
// CR8 is the APIC TPR register.
//

#define ReadCR8() __readcr8()

ULONG64
__readcr8 (
    VOID
    );

#define WriteCR8(Data) __writecr8(Data)

VOID
__writecr8 (
    IN ULONG64 Data
    );

#pragma intrinsic(__readcr8)
#pragma intrinsic(__writecr8)

#ifdef __cplusplus
}
#endif

// end_nthal end_ntosp

//
// External references to the code labels.
//

extern ULONG KiInterruptTemplate[NORMAL_DISPATCH_LENGTH];

// begin_ntddk begin_wdm begin_nthal begin_ntosp
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0                 // Passive release level
#define LOW_LEVEL 0                     // Lowest interrupt level
#define APC_LEVEL 1                     // APC interrupt level
#define DISPATCH_LEVEL 2                // Dispatcher level

#define CLOCK_LEVEL 13                  // Interval clock level
#define IPI_LEVEL 14                    // Interprocessor interrupt level
#define POWER_LEVEL 14                  // Power failure level
#define PROFILE_LEVEL 15                // timer used for profiling.
#define HIGH_LEVEL 15                   // Highest interrupt level

#if defined(NT_UP)

#define SYNCH_LEVEL DISPATCH_LEVEL      // synchronization level

#else

#define SYNCH_LEVEL (IPI_LEVEL - 1)     // synchronization level

#endif

#define IRQL_VECTOR_OFFSET 2            // offset from IRQL to vector / 16

// end_ntddk end_wdm end_ntosp

#define KiSynchIrql SYNCH_LEVEL         // enable portable code

//
// Machine type definitions
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2

// end_nthal
//
//  The previous values and the following are or'ed in KeI386MachineType.
//

#define MACHINE_TYPE_PC_AT_COMPATIBLE      0x00000000
#define MACHINE_TYPE_PC_9800_COMPATIBLE    0x00000100
#define MACHINE_TYPE_FMR_COMPATIBLE        0x00000200

extern ULONG KeI386MachineType;

// begin_nthal
//
// Define constants used in selector tests.
//
//  N.B. MODE_MASK and MODE_BIT assumes that all code runs at either ring-0
//       or ring-3 and is used to test the mode. RPL_MASK is used for merging
//       or extracting RPL values.
//

#define MODE_BIT 0
#define MODE_MASK 1                                                 // ntosp
#define RPL_MASK 3

//
// Startup count value for KeStallExecution.  This value is used
// until KiInitializeStallExecution can compute the real one.
// Pick a value long enough for very fast processors.
//

#define INITIAL_STALL_COUNT 100

// end_nthal

//
// begin_nthal
//
// Macro to extract the high word of a long offset
//

#define HIGHWORD(l) \
    ((USHORT)(((ULONG)(l)>>16) & 0xffff))

//
// Macro to extract the low word of a long offset
//

#define LOWWORD(l) \
    ((USHORT)((ULONG)l & 0x0000ffff))

//
// Macro to combine two USHORT offsets into a long offset
//

#if !defined(MAKEULONG)

#define MAKEULONG(x, y) \
    (((((ULONG)(x))<<16) & 0xffff0000) | \
    ((ULONG)(y) & 0xffff))

#endif

// end_nthal

//
// Request a software interrupt.
//

#define KiRequestSoftwareInterrupt(RequestIrql) \
    HalRequestSoftwareInterrupt( RequestIrql )

// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use in/out instructions.)
//

__forceinline
UCHAR
READ_REGISTER_UCHAR (
    volatile UCHAR *Register
    )
{
    return *Register;
}

__forceinline
USHORT
READ_REGISTER_USHORT (
    volatile USHORT *Register
    )
{
    return *Register;
}

__forceinline
ULONG
READ_REGISTER_ULONG (
    volatile ULONG *Register
    )
{
    return *Register;
}

__forceinline
VOID
READ_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{
    __movsb(Register, Buffer, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{
    __movsw(Register, Buffer, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{
    __movsd(Register, Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_REGISTER_UCHAR (
    PUCHAR Register,
    UCHAR Value
    )
{
    LONG Synch;

    *Register = Value;
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_USHORT (
    PUSHORT Register,
    USHORT Value
    )
{
    LONG Synch;

    *Register = Value;
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG (
    PULONG Register,
    ULONG Value
    )
{
    LONG Synch;

    *Register = Value;
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{
    LONG Synch;

    __movsb(Register, Buffer, Count);
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{
    LONG Synch;

    __movsw(Register, Buffer, Count);
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{
    LONG Synch;

    __movsd(Register, Buffer, Count);
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
UCHAR
READ_PORT_UCHAR (
    PUCHAR Port
    )

{
    return __inbyte((USHORT)((ULONG64)Port));
}

__forceinline
USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )

{
    return __inword((USHORT)((ULONG64)Port));
}

__forceinline
ULONG
READ_PORT_ULONG (
    PULONG Port
    )

{
    return __indword((USHORT)((ULONG64)Port));
}


__forceinline
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    __inbytestring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    __inwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    __indwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR Value
    )

{
    __outbyte((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT Value
    )

{
    __outword((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG Value
    )

{
    __outdword((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    __outbytestring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    __outwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    __outdwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

// end_ntndis
//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L

// end_ntddk end_wdm end_nthal end_ntosp

//
// Fill TB entry and flush single TB entry.
//

#define KeFillEntryTb(Pte, Virtual, Invalid)                                \
    if (Invalid != FALSE) {                                                 \
        InvalidatePage(Virtual);                                            \
    }

// begin_nthal

#if !defined(_NTHAL_) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

__forceinline
VOID
KeFlushCurrentTb (
    VOID
    )

{

    ULONG64 Cr4;

    Cr4 = ReadCR4();
    WriteCR4(Cr4 & ~CR4_PGE);
    WriteCR4(Cr4 | CR4_PGE);
    return;
}

#else

NTKERNELAPI
VOID
KeFlushCurrentTb (
    VOID
    );

#endif

// end_nthal

#define KiFlushSingleTb(Invalid, Virtual) InvalidatePage(Virtual)

//
// Data cache, instruction cache, I/O buffer, and write buffer flush routine
// prototypes.
//

//  AMD64 has transparent caches, so these are noops.

#define KeSweepDcache(AllProcessors)
#define KeSweepCurrentDcache()

#define KeSweepIcache(AllProcessors)
#define KeSweepCurrentIcache()

#define KeSweepIcacheRange(AllProcessors, BaseAddress, Length)

// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)

// end_ntddk end_wdm end_ntndis end_ntosp

#define KeYieldProcessor()

// end_nthal

//
// Define executive macros for acquiring and releasing executive spinlocks.
// These macros can ONLY be used by executive components and NOT by drivers.
// Drivers MUST use the kernel interfaces since they must be MP enabled on
// all systems.
//

#if defined(NT_UP) && !DBG && !defined(_NTDDK_) && !defined(_NTIFS_)

#if !defined(_NTDRIVER_)
#define ExAcquireSpinLock(Lock, OldIrql) (*OldIrql) = KeRaiseIrqlToDpcLevel();
#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))
#else
#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#endif
#define ExAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock)

#else

//  begin_wdm begin_ntddk begin_ntosp

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

// end_wdm end_ntddk end_ntosp

#endif

// begin_nthal

//
// The acquire and release fast lock macros disable and enable interrupts
// on UP nondebug systems. On MP or debug systems, the spinlock routines
// are used.
//
// N.B. Extreme caution should be observed when using these routines.
//

#if defined(_M_AMD64) && !defined(USER_MODE_CODE)

VOID
_disable (
    VOID
    );

VOID
_enable (
    VOID
    );

#pragma warning(push)
#pragma warning(disable:4164)
#pragma intrinsic(_disable)
#pragma intrinsic(_enable)
#pragma warning(pop)

#endif

// end_nthal

#if defined(NT_UP) && !DBG && !defined(USER_MODE_CODE)
#define ExAcquireFastLock(Lock, OldIrql) _disable()
#else
#define ExAcquireFastLock(Lock, OldIrql) \
    ExAcquireSpinLock(Lock, OldIrql)
#endif

#if defined(NT_UP) && !DBG && !defined(USER_MODE_CODE)
#define ExReleaseFastLock(Lock, OldIrql) _enable()
#else
#define ExReleaseFastLock(Lock, OldIrql) \
    ExReleaseSpinLock(Lock, OldIrql)
#endif

//
// The following function prototypes must be in this module so that the
// above macros can call them directly.
//
// begin_nthal

#if defined(NT_UP)

#define KiAcquireSpinLock(SpinLock)
#define KiReleaseSpinLock(SpinLock)

#else

#define KiAcquireSpinLock(SpinLock) KeAcquireSpinLockAtDpcLevel(SpinLock)
#define KiReleaseSpinLock(SpinLock) KeReleaseSpinLockFromDpcLevel(SpinLock)

#endif // defined(NT_UP)

//
// KeTestSpinLock may be used to spin at low IRQL until the lock is
// available.  The IRQL must then be raised and the lock acquired with
// KeTryToAcquireSpinLock.  If that fails, lower the IRQL and start again.
//

#if defined(NT_UP)

#define KeTestSpinLock(SpinLock) (TRUE)

#else

BOOLEAN
KeTestSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

// end_nthal

//
// Define query tick count macro.
//
// begin_ntddk begin_nthal begin_ntosp

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// begin_wdm

#define KeQueryTickCount(CurrentCount ) \
    *(PULONG64)(CurrentCount) = **((volatile ULONG64 **)(&KeTickCount));

// end_wdm

#else

// end_ntddk end_nthal end_ntosp

#define KiQueryTickCount(CurrentCount) \
    *(PULONG64)(CurrentCount) = KeTickCount.QuadPart;

// begin_ntddk begin_nthal begin_ntosp

VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// end_ntddk end_nthal end_ntosp

BOOLEAN
KiEmulateReference (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN OUT struct _KTRAP_FRAME *TrapFrame
    );

// begin_nthal begin_ntosp
//
// AMD64 hardware structures
//
// A Page Table Entry on an AMD64 has the following definition.
//

#define _HARDWARE_PTE_WORKING_SET_BITS  11

typedef struct _HARDWARE_PTE {
    ULONG64 Valid : 1;
    ULONG64 Write : 1;                // UP version
    ULONG64 Owner : 1;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 LargePage : 1;
    ULONG64 Global : 1;
    ULONG64 CopyOnWrite : 1;          // software field
    ULONG64 Prototype : 1;            // software field
    ULONG64 reserved0 : 1;            // software field
    ULONG64 PageFrameNumber : 28;
    ULONG64 reserved1 : 24 - (_HARDWARE_PTE_WORKING_SET_BITS+1);
    ULONG64 SoftwareWsIndex : _HARDWARE_PTE_WORKING_SET_BITS;
    ULONG64 NoExecute : 1;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// Define macro to initialize directory table base.
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase,pfn) \
     *((PULONG64)(dirbase)) = (((ULONG64)(pfn)) << PAGE_SHIFT)

//
// Define Global Descriptor Table (GDT) entry structure and constants.
//
// Define descriptor type codes.
//

#define TYPE_CODE 0x1A                  // 11010 = code, read only
#define TYPE_DATA 0x12                  // 10010 = data, read and write
#define TYPE_TSS64 0x09                 // 01001 = task state segment

//
// Define descriptor privilege levels for user and system.
//

#define DPL_USER 3
#define DPL_SYSTEM 0

//
// Define limit granularity.
//

#define GRANULARITY_BYTE 0
#define GRANULARITY_PAGE 1

#define SELECTOR_TABLE_INDEX 0x04

typedef union _KGDTENTRY64 {
    struct {
        USHORT  LimitLow;
        USHORT  BaseLow;
        union {
            struct {
                UCHAR   BaseMiddle;
                UCHAR   Flags1;
                UCHAR   Flags2;
                UCHAR   BaseHigh;
            } Bytes;

            struct {
                ULONG   BaseMiddle : 8;
                ULONG   Type : 5;
                ULONG   Dpl : 2;
                ULONG   Present : 1;
                ULONG   LimitHigh : 4;
                ULONG   System : 1;
                ULONG   LongMode : 1;
                ULONG   DefaultBig : 1;
                ULONG   Granularity : 1;
                ULONG   BaseHigh : 8;
            } Bits;
        };

        ULONG BaseUpper;
        ULONG MustBeZero;
    };

    ULONG64 Alignment;
} KGDTENTRY64, *PKGDTENTRY64;

//
// Define Interrupt Descriptor Table (IDT) entry structure and constants.
//

typedef union _KIDTENTRY64 {
   struct {
       USHORT OffsetLow;
       USHORT Selector;
       USHORT IstIndex : 3;
       USHORT Reserved0 : 5;
       USHORT Type : 5;
       USHORT Dpl : 2;
       USHORT Present : 1;
       USHORT OffsetMiddle;
       ULONG OffsetHigh;
       ULONG Reserved1;
   };

   ULONG64 Alignment;
} KIDTENTRY64, *PKIDTENTRY64;

//
// Define two union definitions used for parsing addresses into the
// component fields required by a GDT.
//

typedef union _KGDT_BASE {
    struct {
        USHORT BaseLow;
        UCHAR BaseMiddle;
        UCHAR BaseHigh;
        ULONG BaseUpper;
    };

    ULONG64 Base;
} KGDT_BASE, *PKGDT_BASE;

C_ASSERT(sizeof(KGDT_BASE) == sizeof(ULONG64));


typedef union _KGDT_LIMIT {
    struct {
        USHORT LimitLow;
        USHORT LimitHigh : 4;
        USHORT MustBeZero : 12;
    };

    ULONG Limit;
} KGDT_LIMIT, *PKGDT_LIMIT;

C_ASSERT(sizeof(KGDT_LIMIT) == sizeof(ULONG));

//
// Define Task State Segment (TSS) structure and constants.
//
// Task switches are not supported by the AMD64, but a task state segment
// must be present to define the kernel stack pointer and I/O map base.
//
// N.B. This structure is misaligned as per the AMD64 specification.
//
// N.B. The size of TSS must be <= 0xDFFF.
//

#define IOPM_SIZE 8192

typedef UCHAR KIO_ACCESS_MAP[IOPM_SIZE];

typedef KIO_ACCESS_MAP *PKIO_ACCESS_MAP;

#pragma pack(push, 4)
typedef struct _KTSS64 {
    ULONG Reserved0;
    ULONG64 Rsp0;
    ULONG64 Rsp1;
    ULONG64 Rsp2;

    //
    // Element 0 of the Ist is reserved
    //

    ULONG64 Ist[8];
    ULONG64 Reserved1;
    USHORT IoMapBase;
    KIO_ACCESS_MAP IoMap;
    ULONG IoMapEnd;
    ULONG Reserved2;
} KTSS64, *PKTSS64;
#pragma pack(pop)

C_ASSERT((sizeof(KTSS64) % sizeof(PVOID)) == 0);

#define TSS_IST_RESERVED 0
#define TSS_IST_PANIC 1
#define TSS_IST_MCA 2

#define IO_ACCESS_MAP_NONE FALSE

#define KiComputeIopmOffset(Enable)               \
    ((Enable == FALSE) ?                          \
        (USHORT)(sizeof(KTSS64)) : (USHORT)(FIELD_OFFSET(KTSS64, IoMap[0])))

// begin_windbgkd

#if defined(_AMD64_)

//
// Define pseudo descriptor structures for both 64- and 32-bit mode.
//

typedef struct _KDESCRIPTOR {
    USHORT Pad[3];
    USHORT Limit;
    PVOID Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KDESCRIPTOR32 {
    USHORT Pad[3];
    USHORT Limit;
    ULONG Base;
} KDESCRIPTOR32, *PKDESCRIPTOR32;

//
// Define special kernel registers and the initial MXCSR value.
//

typedef struct _KSPECIAL_REGISTERS {
    ULONG64 Cr0;
    ULONG64 Cr2;
    ULONG64 Cr3;
    ULONG64 Cr4;
    ULONG64 KernelDr0;
    ULONG64 KernelDr1;
    ULONG64 KernelDr2;
    ULONG64 KernelDr3;
    ULONG64 KernelDr6;
    ULONG64 KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG MxCsr;
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

//
// Define processor state structure.
//

typedef struct _KPROCESSOR_STATE {
    KSPECIAL_REGISTERS SpecialRegisters;
    CONTEXT ContextFrame;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _AMD64_

// end_windbgkd

//
// Processor Control Block (PRCB)
//

#define PRCB_MAJOR_VERSION 1
#define PRCB_MINOR_VERSION 1

#define PRCB_BUILD_DEBUG 0x1
#define PRCB_BUILD_UNIPROCESSOR 0x2

typedef struct _KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    USHORT MinorVersion;
    USHORT MajorVersion;
    CCHAR Number;
    CCHAR Reserved;
    USHORT BuildType;
    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;
    KAFFINITY SetMember;
    KAFFINITY NotSetMember;
    KPROCESSOR_STATE ProcessorState;
    CCHAR CpuType;
    CCHAR CpuID;
    USHORT CpuStep;
    ULONG KernelReserved[16];
    ULONG HalReserved[16];
    UCHAR PrcbPad0[88 + 112];

//
// End of the architecturally defined section of the PRCB.
//
// end_nthal end_ntosp
//
// Numbered queued spin locks - 128-byte aligned.
//

    KSPIN_LOCK_QUEUE LockQueue[16];
    UCHAR PrcbPad1[16];

//
// Nonpaged per processor lookaside lists - 128-byte aligned.
//

    PP_LOOKASIDE_LIST PPLookasideList[16];

//
// Nonpaged per processor small pool lookaside lists - 128-byte aligned.
//

    PP_LOOKASIDE_LIST PPNPagedLookasideList[POOL_SMALL_LISTS];

//
// Paged per processor small pool lookaside lists.
//

    PP_LOOKASIDE_LIST PPPagedLookasideList[POOL_SMALL_LISTS];

//
// MP interprocessor request packet barrier - 128-byte aligned.
//

    volatile ULONG PacketBarrier;
    UCHAR PrcbPad2[124];

//
// MP interprocessor request packet and summary - 128-byte aligned.
//

    volatile PVOID CurrentPacket[3];
    volatile KAFFINITY TargetSet;
    volatile PKIPI_WORKER WorkerRoutine;
    volatile ULONG IpiFrozen;
    UCHAR PrcbPad3[84];

//
// MP interprocessor request summary and packet address - 128-byte aligned.
//
// N.B. Request summary includes the request summary mask as well as the
//      request packet. The address occupies the upper 48-bits and the mask
//      the lower 16-bits
//

#define IPI_PACKET_SHIFT 16

    volatile LONG64 RequestSummary;
    UCHAR PrcbPad4[120];

//
// DPC listhead, counts, and batching parameters - 128-byte aligned.
//

    LIST_ENTRY DpcListHead;
    PVOID DpcStack;
    PVOID SavedRsp;
    ULONG DpcCount;
    volatile ULONG DpcQueueDepth;
    volatile LOGICAL DpcRoutineActive;
    volatile LOGICAL DpcInterruptRequested;
    ULONG DpcLastCount;
    ULONG DpcRequestRate;
    ULONG MaximumDpcQueueDepth;
    ULONG MinimumDpcRate;
    ULONG QuantumEnd;
    UCHAR PrcbPad5[60];

//
// DPC list lock - 128-byte aligned.
//

    KSPIN_LOCK DpcLock;
    UCHAR PrcbPad6[120];

//
// Miscellaneous counters - 128-byte aligned.
//

    ULONG InterruptCount;
    ULONG KernelTime;
    ULONG UserTime;
    ULONG DpcTime;
    ULONG InterruptTime;
    ULONG AdjustDpcThreshold;
    ULONG PageColor;
    LOGICAL SkipTick;
    ULONG TimerHand;
    struct _KNODE * ParentNode;
    KAFFINITY MultiThreadProcessorSet;
    ULONG ThreadStartCount[2];
    UCHAR PrcbPad7[64];

//
// Performacne counters - 128-byte aligned.
//
// Cache manager performance counters.
//

    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadNotPossible;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;

//
// Kernel performance counters.
//

    ULONG KeAlignmentFixupCount;
    ULONG KeContextSwitches;
    ULONG KeDcacheFlushCount;
    ULONG KeExceptionDispatchCount;
    ULONG KeFirstLevelTbFills;
    ULONG KeFloatingEmulationCount;
    ULONG KeIcacheFlushCount;
    ULONG KeSecondLevelTbFills;
    ULONG KeSystemCalls;
    ULONG SpareCounter0[1];

//
// I/O IRP float.
//

    LONG LookasideIrpFloat;

//
// Processor information.
//

    UCHAR VendorString[13];
    UCHAR InitialApicId;
    UCHAR LogicalProcessorsPerPhysicalProcessor;
    ULONG MHz;
    ULONG FeatureBits;
    LARGE_INTEGER UpdateSignature;

//
// Processors power state
//

    PROCESSOR_POWER_STATE PowerState;

// begin_nthal begin_ntosp

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

// end_nthal end_ntosp

#if !defined(_X86AMD64_)

C_ASSERT(((FIELD_OFFSET(KPRCB, LockQueue) + 16) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, PPLookasideList) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, PPNPagedLookasideList) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, PacketBarrier) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, RequestSummary) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, DpcListHead) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, DpcLock) & (128 - 1)) == 0);
C_ASSERT((FIELD_OFFSET(KPRCB, InterruptCount) & (128 - 1)) == 0);

#endif

// begin_nthal begin_ntosp begin_ntddk

//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    NT_TIB NtTib;
    struct _KPRCB *CurrentPrcb;
    ULONG64 SavedRcx;
    ULONG64 SavedR11;
    KIRQL Irql;
    UCHAR SecondLevelCacheAssociativity;
    UCHAR Number;
    UCHAR Fill0;
    ULONG Irr;
    ULONG IrrActive;
    ULONG Idr;
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONG StallScaleFactor;
    union _KIDTENTRY64 *IdtBase;
    union _KGDTENTRY64 *GdtBase;
    struct _KTSS64 *TssBase;

// end_ntddk end_ntosp

    ULONG KernelReserved[15];
    ULONG SecondLevelCacheSize;
    ULONG HalReserved[16];

    ULONG MxCsr;

    PVOID KdVersionBlock;
    struct _KPCR *Self;

//
// End of the architecturally defined section of the PCR.
//
// end_nthal
//

    ULONG PcrAlign1[24];
    KPRCB Prcb;

// begin_nthal begin_ntddk begin_ntosp

} KPCR, *PKPCR;

// end_nthal end_ntddk end_ntosp

#if !defined (_X86AMD64_)

C_ASSERT((FIELD_OFFSET(KPCR, Prcb) & (128 - 1)) == 0);

//
// The offset of the DebuggerDataBlock must not change.
//

C_ASSERT(FIELD_OFFSET(KPCR, KdVersionBlock) == 0x108);

#endif

// begin_nthal begin_ntosp

//
// Define legacy floating status word bit masks.
//

#define FSW_INVALID_OPERATION 0x1
#define FSW_DENORMAL 0x2
#define FSW_ZERO_DIVIDE 0x4
#define FSW_OVERFLOW 0x8
#define FSW_UNDERFLOW 0x10
#define FSW_PRECISION 0x20
#define FSW_STACK_FAULT 0x40
#define FSW_CONDITION_CODE_0 0x100
#define FSW_CONDITION_CODE_1 0x200
#define FSW_CONDITION_CODE_2 0x400
#define FSW_CONDITION_CODE_3 0x4000

#define FSW_ERROR_MASK (FSW_INVALID_OPERATION | FSW_DENORMAL |              \
                        FSW_ZERO_DIVIDE | FSW_OVERFLOW | FSW_UNDERFLOW |    \
                        FSW_PRECISION | FSW_STACK_FAULT)

//
// Define MxCsr floating control/status word bit masks.
//
// No flush to zero, round to nearest, and all exception masked.
//

#define INITIAL_MXCSR 0x1f80            // initial MXCSR vlaue

#define XSW_INVALID_OPERATION 0x1
#define XSW_DENORMAL 0x2
#define XSW_ZERO_DIVIDE 0x4
#define XSW_OVERFLOW 0x8
#define XSW_UNDERFLOW 0x10
#define XSW_PRECISION 0x20

#define XSW_ERROR_MASK (XSW_INVALID_OPERATION |  XSW_DENORMAL |             \
                        XSW_ZERO_DIVIDE | XSW_OVERFLOW | XSW_UNDERFLOW |    \
                        XSW_PRECISION)

#define XSW_ERROR_SHIFT 7

#define XCW_INVALID_OPERATION 0x80
#define XCW_DENORMAL 0x100
#define XCW_ZERO_DIVIDE 0x200
#define XCW_OVERFLOW 0x400
#define XCW_UNDERFLOW 0x800
#define XCW_PRECISION 0x1000
#define XCW_ROUND_CONTROL 0x6000
#define XCW_FLUSH_ZERO 0x8000

//
// Define EFLAG bit masks and shift offsets.
//

#define EFLAGS_CF_MASK 0x00000001       // carry flag
#define EFLAGS_PF_MASK 0x00000004       // parity flag
#define EFALGS_AF_MASK 0x00000010       // auxiliary carry flag
#define EFLAGS_ZF_MASK 0x00000040       // zero flag
#define EFLAGS_SF_MASK 0x00000080       // sign flag
#define EFLAGS_TF_MASK 0x00000100       // trap flag
#define EFLAGS_IF_MASK 0x00000200       // interrupt flag
#define EFLAGS_DF_MASK 0x00000400       // direction flag
#define EFLAGS_OF_MASK 0x00000800       // overflow flag
#define EFLAGS_IOPL_MASK 0x00003000     // I/O privilege level
#define EFLAGS_NT_MASK 0x00004000       // nested task
#define EFLAGS_RF_MASK 0x00010000       // resume flag
#define EFLAGS_VM_MASK 0x00020000       // virtual 8086 mode
#define EFLAGS_AC_MASK 0x00040000       // alignment check
#define EFLAGS_VIF_MASK 0x00080000      // virtual interrupt flag
#define EFLAGS_VIP_MASK 0x00100000      // virtual interrupt pending
#define EFLAGS_ID_MASK 0x00200000       // identification flag

#define EFLAGS_TF_SHIFT 8               // trap
#define EFLAGS_IF_SHIFT 9               // interrupt enable

// end_nthal

//
// Define sanitize EFLAGS macro.
//
// If kernel mode, then
//      caller can specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Interrupt, Direction, Overflow, Align Check, identification.
//
// If user mode, then
//      caller can specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, Align Check, and force Interrupt on.
//

#define EFLAGS_KERNEL_SANITIZE 0x00240fd5L
#define EFLAGS_USER_SANITIZE 0x00040dd5L

#define SANITIZE_EFLAGS(eFlags, mode) (                                      \
    ((mode) == KernelMode ?                                                  \
        ((eFlags) & EFLAGS_KERNEL_SANITIZE) :                                \
        (((eFlags) & EFLAGS_USER_SANITIZE) | EFLAGS_IF_MASK)))

//
// Define sanitize debug register macros.
//
// Define control register settable bits and active mask.
//

#define DR7_LEGAL 0xffff0155
#define DR7_ACTIVE 0x00000055

//
// Define macro to sanitize the debug control register.
//

#define SANITIZE_DR7(Dr7, mode) ((Dr7 & DR7_LEGAL));

//
// Define macro to santitize debug address registers.
//

#define SANITIZE_DRADDR(DrReg, mode)                                         \
    ((mode) == KernelMode ?                                                  \
        (DrReg) :                                                            \
        (((PVOID)(DrReg) <= MM_HIGHEST_USER_ADDRESS) ? (DrReg) : 0))                                 \

//
// Define macro to clear reserved bits from MXCSR.
//

#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) & 0xffbf)

//
// Define macro to clear reserved bits for legacy FP control word.
//

#define SANITIZE_FCW(_fcw_) ((_fcw_) & 0x1f37)

// begin_nthal
//
// Exception frame
//
//  This frame is established when handling an exception. It provides a place
//  to save all nonvolatile registers. The volatile registers will already
//  have been saved in a trap frame.
//

typedef struct _KEXCEPTION_FRAME {

//
// Home address for the parameter registers.
//

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;

//
// Kernel callout initial stack value.
//

    ULONG64 InitialStack;

//
// Saved nonvolatile floating registers.
//

    M128 Xmm6;
    M128 Xmm7;
    M128 Xmm8;
    M128 Xmm9;
    M128 Xmm10;
    M128 Xmm11;
    M128 Xmm12;
    M128 Xmm13;
    M128 Xmm14;
    M128 Xmm15;

//
// Kernel callout frame variables.
//

    ULONG64 TrapFrame;
    ULONG64 CallbackStack;
    ULONG64 OutputBuffer;
    ULONG64 OutputLength;

//
// Saved nonvolatile register - not always saved.
//

    ULONG64 Fill1;
    ULONG64 Rbp;

//
// Saved nonvolatile registers.
//

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;
    ULONG64 R12;
    ULONG64 R13;
    ULONG64 R14;
    ULONG64 R15;

//
// EFLAGS and return address.
//

    ULONG64 Return;
} KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;

#define KEXCEPTION_FRAME_LENGTH sizeof(KEXCEPTION_FRAME)

C_ASSERT((sizeof(KEXCEPTION_FRAME) & STACK_ROUND) == 0);

#define EXCEPTION_RECORD_LENGTH                                              \
    ((sizeof(EXCEPTION_RECORD) + STACK_ROUND) & ~STACK_ROUND)

//
// Machine Frame
//
// This frame is established by code that trampolines to user mode (e.g. user
// APC, user callback, dispatch user exception, etc.). The purpose of this
// frame is to allow unwinding through these callbacks if an exception occurs.
//
// N.B. This frame is identical to the frame that is pushed for a trap without
//      an error code and is identical to the hardware part of a trap frame.
//

typedef struct _MACHINE_FRAME {
    ULONG64 Rip;
    USHORT SegCs;
    USHORT Fill1[3];
    ULONG EFlags;
    ULONG Fill2;
    ULONG64 Rsp;
    USHORT SegSs;
    USHORT Fill3[3];
} MACHINE_FRAME, *PMACHINE_FRAME;

#define MACHINE_FRAME_LENGTH sizeof(MACHINE_FRAME)

C_ASSERT((sizeof(MACHINE_FRAME) & STACK_ROUND) == 8);

//
// Switch Frame
//
// This frame is established by the code that switches context from one
// thread to the next and is used by the thread initialization code to
// construct a stack that will start the execution of a thread in the
// thread start up code.
//

typedef struct _KSWITCH_FRAME {
    ULONG64 Fill0;
    ULONG MxCsr;
    KIRQL ApcBypass;
    BOOLEAN NpxSave;
    UCHAR Fill1[2];
    ULONG64 Rbp;
    ULONG64 Return;
} KSWITCH_FRAME, *PKSWITCH_FRAME;

#define KSWITCH_FRAME_LENGTH sizeof(KSWITCH_FRAME)

C_ASSERT((sizeof(KSWITCH_FRAME) & STACK_ROUND) == 0);

//
// Trap frame
//
// This frame is established when handling a trap. It provides a place to
// save all volatile registers. The nonvolatile registers are saved in an
// exception frame or through the normal C calling conventions for saved
// registers.
//

typedef struct _KTRAP_FRAME {

//
// Home address for the parameter registers.
//

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;

//
// Previous processor mode (system services only) and previous IRQL
// (interrupts only).
//

    KPROCESSOR_MODE PreviousMode;
    KIRQL PreviousIrql;
    UCHAR Fill0[2];

//
// Floating point state.
//

    ULONG MxCsr;

//
//  Volatile registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    ULONG64 Rax;
    ULONG64 Rcx;
    ULONG64 Rdx;
    ULONG64 R8;
    ULONG64 R9;
    ULONG64 R10;
    ULONG64 R11;
    ULONG64 Spare0;

//
// Volatile floating registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    M128 Xmm0;
    M128 Xmm1;
    M128 Xmm2;
    M128 Xmm3;
    M128 Xmm4;
    M128 Xmm5;

//
//  Debug registers.
//

    ULONG64 Dr0;
    ULONG64 Dr1;
    ULONG64 Dr2;
    ULONG64 Dr3;
    ULONG64 Dr6;
    ULONG64 Dr7;

//
//  Segment registers
//

    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;

//
// Previous trap frame address.
//

    ULONG64 TrapFrame;

//
// Exception record for exceptions.
//

    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD) + 15) & (~15)];

//
// Saved nonvolatile registers RBX, RDI and RSI. These registers are only
// saved in system service trap frames.
//

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;

//
// Saved nonvolatile register RBP. This register is used as a frame
// pointer during trap processing and is saved in all trap frames.
//

    ULONG64 Rbp;

//
// Information pushed by hardware.
//
// N.B. The error code is not always pushed by hardware. For those cases
//      where it is not pushed by hardware a dummy error code is allocated
//      on the stack.
//

    ULONG64 ErrorCode;
    ULONG64 Rip;
    USHORT SegCs;
    USHORT Fill1[3];
    ULONG EFlags;
    ULONG Fill2;
    ULONG64 Rsp;
    USHORT SegSs;
    USHORT Fill3[3];
} KTRAP_FRAME, *PKTRAP_FRAME;

#define KTRAP_FRAME_LENGTH sizeof(KTRAP_FRAME)

C_ASSERT((sizeof(KTRAP_FRAME) & STACK_ROUND) == 0);

//
// IPI, profile, update run time, and update system time interrupt routines.
//

NTKERNELAPI
VOID
KeIpiInterrupt (
    IN PKTRAP_FRAME TrapFrame
    );

NTKERNELAPI
VOID
KeProfileInterruptWithSource (
    IN PKTRAP_FRAME TrapFrame,
    IN KPROFILE_SOURCE ProfileSource
    );

NTKERNELAPI
VOID
KeUpdateRunTime (
    IN PKTRAP_FRAME TrapFrame
    );

NTKERNELAPI
VOID
KeUpdateSystemTime (
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG64 Increment
    );

// end_nthal

//
// The frame saved by the call out to user mode code is defined here to allow
// the kernel debugger to trace the entire kernel stack when user mode callouts
// are active.
//
// N.B. The kernel callout frame is the same as an exception frame.
//

typedef KEXCEPTION_FRAME KCALLOUT_FRAME;
typedef PKEXCEPTION_FRAME PKCALLOUT_FRAME;

typedef struct _UCALLOUT_FRAME {
    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    PVOID Buffer;
    ULONG Length;
    ULONG ApiNumber;
    MACHINE_FRAME MachineFrame;
} UCALLOUT_FRAME, *PUCALLOUT_FRAME;

#define UCALLOUT_FRAME_LENGTH sizeof(UCALLOUT_FRAME)

C_ASSERT((sizeof(UCALLOUT_FRAME) & STACK_ROUND) == 8);

// begin_ntddk begin_wdm
//
// The nonvolatile floating state
//

typedef struct _KFLOATING_SAVE {
    ULONG MxCsr;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

// end_ntddk end_wdm end_ntosp

//
// Define profile values.
//

#define DEFAULT_PROFILE_INTERVAL  39063

//
// The minimum acceptable profiling interval is set to 1221 which is the
// fast RTC clock rate we can get.  If this
// value is too small, the system will run very slowly.
//

#define MINIMUM_PROFILE_INTERVAL   1221

// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp
//
// AMD64 Specific portions of mm component.
//
// Define the page size for the AMD64 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

// end_ntndis end_wdm

#define PXE_BASE          0xFFFFF6FB7DBED000UI64
#define PXE_SELFMAP       0xFFFFF6FB7DBEDF68UI64
#define PPE_BASE          0xFFFFF6FB7DA00000UI64
#define PDE_BASE          0xFFFFF6FB40000000UI64
#define PTE_BASE          0xFFFFF68000000000UI64

#define PXE_TOP           0xFFFFF6FB7DBEDFFFUI64
#define PPE_TOP           0xFFFFF6FB7DBFFFFFUI64
#define PDE_TOP           0xFFFFF6FB7FFFFFFFUI64
#define PTE_TOP           0xFFFFF6FFFFFFFFFFUI64

#define PDE_KTBASE_AMD64  PPE_BASE

#define PTI_SHIFT 12
#define PDI_SHIFT 21
#define PPI_SHIFT 30
#define PXI_SHIFT 39

#define PTE_PER_PAGE 512
#define PDE_PER_PAGE 512
#define PPE_PER_PAGE 512
#define PXE_PER_PAGE 512

#define PTI_MASK_AMD64 (PTE_PER_PAGE - 1)
#define PDI_MASK_AMD64 (PDE_PER_PAGE - 1)
#define PPI_MASK (PPE_PER_PAGE - 1)
#define PXI_MASK (PXE_PER_PAGE - 1)

//
// Define the highest user address and user probe address.
//

// end_ntddk end_nthal end_ntosp

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

// begin_ntddk begin_nthal begin_ntosp

extern PVOID *MmHighestUserAddress;
extern PVOID *MmSystemRangeStart;
extern ULONG64 *MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS *MmHighestUserAddress
#define MM_SYSTEM_RANGE_START *MmSystemRangeStart
#define MM_USER_PROBE_ADDRESS *MmUserProbeAddress

// end_ntddk end_nthal end_ntosp

#else

extern PVOID MmHighestUserAddress;
extern PVOID MmSystemRangeStart;
extern ULONG64 MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart
#define MM_USER_PROBE_ADDRESS MmUserProbeAddress

#define MI_HIGHEST_USER_ADDRESS (PVOID) (ULONG_PTR)((0x80000000000 - 0x10000 - 1)) // highest user address
#define MI_SYSTEM_RANGE_START (PVOID)(0xFFFF080000000000) // start of system space
#define MI_USER_PROBE_ADDRESS ((ULONG_PTR)(0x80000000000UI64 - 0x10000)) // starting address of guard page

#endif

// begin_nthal
//
// 4MB at the top of VA space is reserved for the HAL's use.
//

#define HAL_VA_START 0xFFFFFFFFFFC00000UI64
#define HAL_VA_SIZE  (4 * 1024 * 1024)

// end_nthal

// begin_ntddk begin_nthal begin_ntosp
//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000

//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xFFFF080000000000

// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

// end_ntddk end_wdm end_ntosp

//
// Define virtual base and alternate virtual base of kernel.
//

#define KSEG0_BASE 0xFFFFF80000000000UI64

//
// Generate kernel segment physical address.
//

#define KSEG_ADDRESS(PAGE) ((PVOID)(KSEG0_BASE | ((ULONG_PTR)(PAGE) << PAGE_SHIFT)))


// begin_ntddk begin_ntosp

#define KI_USER_SHARED_DATA     0xFFFFF78000000000UI64

#define SharedUserData  ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)

//
// Intrinsic functions
//

//  begin_wdm

#if defined(_M_AMD64) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)

// end_wdm

//
// The following routines are provided for backward compatibility with old
// code. They are no longer the preferred way to accomplish these functions.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

#define ExInterlockedDecrementLong(Addend, Lock)                            \
    _ExInterlockedDecrementLong(Addend)

__forceinline
LONG
_ExInterlockedDecrementLong (
    IN OUT PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedDecrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedIncrementLong(Addend, Lock)                            \
    _ExInterlockedIncrementLong(Addend)

__forceinline
LONG
_ExInterlockedIncrementLong (
    IN OUT PLONG Addend
    )

{

    LONG Result;

    Result = InterlockedIncrement(Addend);
    if (Result < 0) {
        return ResultNegative;

    } else if (Result > 0) {
        return ResultPositive;

    } else {
        return ResultZero;
    }
}

#define ExInterlockedExchangeUlong(Target, Value, Lock)                     \
    _ExInterlockedExchangeUlong(Target, Value)

__forceinline
_ExInterlockedExchangeUlong (
    IN OUT PULONG Target,
    IN ULONG Value
    )

{

    return (ULONG)InterlockedExchange((PLONG)Target, (LONG)Value);
}

// begin_wdm

#endif // defined(_M_AMD64) && !defined(RC_INVOKED)  && !defined(MIDL_PASS)

//  end_wdm end_ntddk end_nthal end_ntosp

//  begin_ntosp begin_nthal begin_ntddk begin_wdm

#if !defined(MIDL_PASS) && defined(_M_AMD64)

//
// AMD646 function prototype definitions
//

// end_wdm

// end_ntddk end_ntosp

//
// Get address of current processor block.
//

__forceinline
PKPCR
KeGetPcr (
    VOID
    )

{
    return (PKPCR)__readgsqword(FIELD_OFFSET(KPCR, Self));
}

// begin_ntosp

//
// Get address of current processor block.
//

__forceinline
PKPRCB
KeGetCurrentPrcb (
    VOID
    )

{

    return (PKPRCB)__readgsqword(FIELD_OFFSET(KPCR, CurrentPrcb));
}

// begin_ntddk

//
// Get the current processor number
//

__forceinline
ULONG
KeGetCurrentProcessorNumber (
    VOID
    )

{

    return (ULONG)__readgsbyte(FIELD_OFFSET(KPCR, Number));
}

// end_nthal end_ntddk end_ntosp
//
// Get address of current kernel thread object.
//
// WARNING: This inline macro can not be used for device drivers or HALs
// they must call the kernel function KeGetCurrentThread.
//

__forceinline
struct _KTHREAD *
KeGetCurrentThread (
    VOID
    )

{
    return (struct _KTHREAD *)__readgsqword(FIELD_OFFSET(KPCR, Prcb.CurrentThread));
}

//
// If processor executing a DPC.
//
// WARNING: This inline macro is always MP enabled because filesystems
// utilize it
//

__forceinline
ULONG
KeIsExecutingDpc (
    VOID
    )

{
    return (__readgsdword(FIELD_OFFSET(KPCR, Prcb.DpcRoutineActive)) != 0);
}

// begin_nthal begin_ntddk begin_ntosp

// begin_wdm

#endif // !defined(MIDL_PASS) && defined(_M_AMD64)

// end_nthal end_ntddk end_wdm end_ntosp

//++
//
//
// VOID
// KeMemoryBarrier (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function cases ordering of memory acceses as seen by other processors.
//    Memory ordering isn't an issue on amd64.
//
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeMemoryBarrier()


// begin_nthal
//
// Define inline functions to get and set the handler address in and IDT
// entry.
//

typedef union _KIDT_HANDLER_ADDRESS {
    struct {
        USHORT OffsetLow;
        USHORT OffsetMiddle;
        ULONG OffsetHigh;
    };

    ULONG64 Address;
} KIDT_HANDLER_ADDRESS, *PKIDT_HANDLER_ADDRESS;

#define KiGetIdtFromVector(Vector)                  \
    &KeGetPcr()->IdtBase[HalVectorToIDTEntry(Vector)]

#define KeGetIdtHandlerAddress(Vector,Addr) {       \
    KIDT_HANDLER_ADDRESS Handler;                   \
    PKIDTENTRY64 Idt;                               \
                                                    \
    Idt = KiGetIdtFromVector(Vector);               \
    Handler.OffsetLow = Idt->OffsetLow;             \
    Handler.OffsetMiddle = Idt->OffsetMiddle;       \
    Handler.OffsetHigh = Idt->OffsetHigh;           \
    *(Addr) = (PVOID)(Handler.Address);             \
}

#define KeSetIdtHandlerAddress(Vector,Addr) {      \
    KIDT_HANDLER_ADDRESS Handler;                  \
    PKIDTENTRY64 Idt;                              \
                                                   \
    Idt = KiGetIdtFromVector(Vector);              \
    Handler.Address = (ULONG64)(Addr);             \
    Idt->OffsetLow = Handler.OffsetLow;            \
    Idt->OffsetMiddle = Handler.OffsetMiddle;      \
    Idt->OffsetHigh = Handler.OffsetHigh;          \
}


// end_nthal

//++
//
// BOOLEAN
// KiIsThreadNumericStateSaved(
//     IN PKTHREAD Address
//     )
//
//--

#define KiIsThreadNumericStateSaved(a) TRUE

//++
//
// VOID
// KiRundownThread(
//     IN PKTHREAD Address
//     )
//
//--

#define KiRundownThread(a)

//
// functions specific to structure
//

VOID
KiSetIRR (
    IN ULONG SWInterruptMask
    );

// begin_ntddk begin_wdm begin_ntosp

NTKERNELAPI
NTSTATUS
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE SaveArea
    );

NTKERNELAPI
NTSTATUS
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE SaveArea
    );

// end_ntddk end_wdm end_ntosp

// begin_nthal begin_ntddk begin_wdm begin_ntndis begin_ntosp

#endif // defined(_AMD64_)

// end_nthal end_ntddk end_wdm end_ntndis end_ntosp

//
// Architecture specific kernel functions.
//

// begin_ntosp

#ifdef _AMD64_

VOID
KeSetIoAccessMap (
    PKIO_ACCESS_MAP IoAccessMap
    );

VOID
KeQueryIoAccessMap (
    PKIO_ACCESS_MAP IoAccessMap
    );

VOID
KeSetIoAccessProcess (
    struct _KPROCESS *Process,
    BOOLEAN Enable
    );

VOID
KiEditIopmDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#endif //_AMD64_

//
// Platform specific kernel fucntions to raise and lower IRQL.
//
// These functions are imported for ntddk, ntifs, and wdm. They are
// inlined for nthal, ntosp, and the system.
//

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_WDMDDK_)

// begin_ntddk begin_wdm

#if defined(_AMD64_)

NTKERNELAPI
KIRQL
KeGetCurrentIrql (
    VOID
    );

NTKERNELAPI
VOID
KeLowerIrql (
    IN KIRQL NewIrql
    );

#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

NTKERNELAPI
KIRQL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

// end_wdm

NTKERNELAPI
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    );

NTKERNELAPI
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    );

// begin_wdm

#endif // defined(_AMD64_)

// end_ntddk end_wdm

#else

// begin_nthal

#if defined(_AMD64_) && !defined(MIDL_PASS)

__forceinline
KIRQL
KeGetCurrentIrql (
    VOID
    )

/*++

Routine Description:

    This function return the current IRQL.

Arguments:

    None.

Return Value:

    The current IRQL is returned as the function value.

--*/

{

    return (KIRQL)ReadCR8();
}

__forceinline
VOID
KeLowerIrql (
   IN KIRQL NewIrql
   )

/*++

Routine Description:

    This function lowers the IRQL to the specified value.

Arguments:

    NewIrql  - Supplies the new IRQL value.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() >= NewIrql);

    WriteCR8(NewIrql);
    return;
}

#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

__forceinline
KIRQL
KfRaiseIrql (
    IN KIRQL NewIrql
    )

/*++

Routine Description:

    This function raises the current IRQL to the specified value and returns
    the previous IRQL.

Arguments:

    NewIrql (cl) - Supplies the new IRQL value.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{

    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    ASSERT(OldIrql <= NewIrql);

    WriteCR8(NewIrql);
    return OldIrql;
}

__forceinline
KIRQL
KeRaiseIrqlToDpcLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to DPC_LEVEL and returns the
    previous IRQL.

Arguments:

    None.

Return Value:

    The previous IRQL is retured as the function value.

--*/

{
    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    ASSERT(OldIrql <= DISPATCH_LEVEL);

    WriteCR8(DISPATCH_LEVEL);
    return OldIrql;
}

__forceinline
KIRQL
KeRaiseIrqlToSynchLevel (
    VOID
    )

/*++

Routine Description:

    This function raises the current IRQL to SYNCH_LEVEL and returns the
    previous IRQL.

Arguments:

Return Value:

    The previous IRQL is retured as the function value.

--*/

{
    KIRQL OldIrql;

    OldIrql = KeGetCurrentIrql();

    ASSERT(OldIrql <= SYNCH_LEVEL);

    WriteCR8(SYNCH_LEVEL);
    return OldIrql;
}

#endif // defined(_AMD64_) && !defined(MIDL_PASS)

// end_nthal

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_WDMDDK_)

// end_ntosp

//
// misc routines
//

VOID
KeOptimizeProcessorControlState (
    VOID
    );

// begin_nthal

#if defined(_AMD64_)

//
// Structure to aid in booting secondary processors
//

#pragma pack(push,1)

typedef struct _FAR_JMP_16 {
    UCHAR  OpCode;  // = 0xe9
    USHORT Offset;
} FAR_JMP_16;

typedef struct _FAR_TARGET_32 {
    USHORT Selector;
    ULONG Offset;
} FAR_TARGET_32;

typedef struct _FAR_TARGET_64 {
    USHORT Selector;
    ULONG64 Offset;
} FAR_TARGET_64;

typedef struct _PSEUDO_DESCRIPTOR_32 {
    USHORT Limit;
    ULONG Base;
} PSEUDO_DESCRIPTOR_32;

#pragma pack(pop)

#define PSB_GDT32_NULL      0 * 16
#define PSB_GDT32_CODE64    1 * 16
#define PSB_GDT32_DATA32    2 * 16
#define PSB_GDT32_CODE32    3 * 16
#define PSB_GDT32_MAX       3

typedef struct _PROCESSOR_START_BLOCK *PPROCESSOR_START_BLOCK;
typedef struct _PROCESSOR_START_BLOCK {

    //
    // The block starts with a jmp instruction to the end of the block
    //

    FAR_JMP_16 Jmp;

    //
    // Completion flag is set to non-zero when the target processor has
    // started
    //

    ULONG CompletionFlag;

    //
    // Pseudo descriptors for GDT and IDT.
    //

    PSEUDO_DESCRIPTOR_32 Gdt32;
    PSEUDO_DESCRIPTOR_32 Idt32;

    //
    // The temporary 32-bit GDT itself resides here.
    //

    KGDTENTRY64 Gdt[PSB_GDT32_MAX + 1];

    //
    // Physical address of the 64-bit top-level identity-mapped page table.
    //

    ULONG64 TiledCr3;

    //
    // Far jump target from Rm to Pm code
    //

    FAR_TARGET_32 PmTarget;

    //
    // Far jump target from Pm to Lm code
    //

    FAR_TARGET_64 LmTarget;

    //
    // Linear address of this structure
    //

    PPROCESSOR_START_BLOCK SelfMap;

    //
    // Initial processor state for the processor to be started
    //

    KPROCESSOR_STATE ProcessorState;

} PROCESSOR_START_BLOCK;


//
// AMD64 functions for special instructions
//

typedef struct _CPU_INFO {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
} CPU_INFO, *PCPU_INFO;

VOID
KiCpuId (
    ULONG Function,
    PCPU_INFO CpuInfo
    );

//
// Define read/write MSR fucntions and register definitions.
//

#define MSR_TSC 0x10                    // time stamp counter
#define MSR_PAT 0x277                   // page attributes table
#define MSR_EFER 0xc0000080             // extended function enable register
#define MSR_STAR 0xc0000081             // system call selectors
#define MSR_LSTAR 0xc0000082            // system call 64-bit entry
#define MSR_CSTAR 0xc0000083            // system call 32-bit entry
#define MSR_SYSCALL_MASK 0xc0000084     // system call flags mask
#define MSR_FS_BASE 0xc0000100          // fs long mode base address register
#define MSR_GS_BASE 0xc0000101          // gs long mode base address register
#define MSR_GS_SWAP 0xc0000102          // gs long mode swap GS base register

//
// Flags within MSR_EFER
//

#define MSR_SCE 0x00000001              // system call enable
#define MSR_LME 0x00000100              // long mode enable
#define MSR_LMA 0x00000400              // long mode active

//
// Page attributes table.
//

#define PAT_TYPE_STRONG_UC  0           // uncacheable/strongly ordered
#define PAT_TYPE_USWC       1           // write combining/weakly ordered
#define PAT_TYPE_WT         4           // write through
#define PAT_TYPE_WP         5           // write protected
#define PAT_TYPE_WB         6           // write back
#define PAT_TYPE_WEAK_UC    7           // uncacheable/weakly ordered

//
// Page attributes table structure.
//

typedef union _PAT_ATTRIBUTES {
    struct {
        UCHAR Pat[8];
    } hw;

    ULONG64 QuadPart;
} PAT_ATTRIBUTES, *PPAT_ATTRIBUTES;

#define ReadMSR(Msr) __readmsr(Msr)

ULONG64
__readmsr (
    IN ULONG Msr
    );

#define WriteMSR(Msr, Data) __writemsr(Msr, Data)

VOID
__writemsr (
    IN ULONG Msr,
    IN ULONG64 Value
    );

#define InvalidatePage(Page) __invlpg(Page)

VOID
__invlpg (
    IN PVOID Page
    );

#define WritebackInvalidate() __wbinvd()

VOID
__wbinvd (
    VOID
    );

#pragma intrinsic(__readmsr)
#pragma intrinsic(__writemsr)
#pragma intrinsic(__invlpg)
#pragma intrinsic(__wbinvd)

#endif  // _AMD64_

// end_nthal
//
// Define software feature bit definitions.
//

#define KF_V86_VIS      0x00000001
#define KF_RDTSC        0x00000002
#define KF_CR4          0x00000004
#define KF_CMOV         0x00000008
#define KF_GLOBAL_PAGE  0x00000010
#define KF_LARGE_PAGE   0x00000020
#define KF_MTRR         0x00000040
#define KF_CMPXCHG8B    0x00000080
#define KF_MMX          0x00000100
#define KF_WORKING_PTE  0x00000200
#define KF_PAT          0x00000400
#define KF_FXSR         0x00000800
#define KF_FAST_SYSCALL 0x00001000
#define KF_XMMI         0x00002000
#define KF_3DNOW        0x00004000
#define KF_AMDK6MTRR    0x00008000
#define KF_XMMI64       0x00010000
#define KF_DTS          0x00020000
#define KF_SMT          0x00040000

//
// Define required software feature bits.
//

#define KF_REQUIRED (KF_RDTSC | KF_CR4 | KF_CMOV | KF_GLOBAL_PAGE | \
                     KF_LARGE_PAGE | KF_CMPXCHG8B | KF_MMX | KF_WORKING_PTE | \
                     KF_PAT | KF_FXSR | KF_FAST_SYSCALL | KF_XMMI | KF_XMMI64)

//
// Define hardware feature bits definitions.
//

#define HF_FPU          0x00000001      // FPU is on chip
#define HF_VME          0x00000002      // virtual 8086 mode enhancement
#define HF_DE           0x00000004      // debugging extension
#define HF_PSE          0x00000008      // page size extension
#define HF_TSC          0x00000010      // time stamp counter
#define HF_MSR          0x00000020      // rdmsr and wrmsr support
#define HF_PAE          0x00000040      // physical address extension
#define HF_MCE          0x00000080      // machine check exception
#define HF_CXS          0x00000100      // cmpxchg8b instruction supported
#define HF_APIC         0x00000200      // APIC on chip
#define HF_UNUSED0      0x00000400      // unused bit
#define HF_SYSCALL      0x00000800      // fast system call
#define HF_MTRR         0x00001000      // memory type range registers
#define HF_PGE          0x00002000      // global page TB support
#define HF_MCA          0x00004000      // machine check architecture
#define HF_CMOV         0x00008000      // cmov instruction supported
#define HF_PAT          0x00010000      // physical attributes table
#define HF_UNUSED1      0x00020000      // unused bit
#define HF_UNUSED2      0x00040000      // unused bit
#define HF_UNUSED3      0x00080000      // unused bit
#define HF_UNUSED4      0x00100000      // unused bit
#define HF_UNUSED5      0x00200000      // unused bit
#define HF_UNUSED6      0x00400000      // unused bit
#define HF_MMX          0x00800000      // MMX technology supported
#define HF_FXSR         0x01000000      // fxsr instruction supported
#define HF_XMMI         0x02000000      // xmm (SSE) registers supported
#define HF_XMMI64       0x04000000      // xmm (SSE2) registers supported

//
// Define required hardware feature bits.
//

#define HF_REQUIRED (HF_FPU | HF_DE | HF_PSE | HF_TSC | HF_MSR | \
                     HF_PAE | HF_MCE | HF_CXS | HF_APIC | HF_SYSCALL | \
                     HF_PGE | HF_MCA | HF_CMOV | HF_PAT | HF_MMX | \
                     HF_FXSR |  HF_XMMI | HF_XMMI64)

//
// Define extended hardware feature bit definitions.
//

#define XHF_3DNOW       0x80000000      // 3DNOW supported

#endif // __amd64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\axp21164.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) 1994 Digital Euipment Corporation

Module Name:

    axp21164.h

Abstract:

    This module defines the DECchip 21164-specific structures that are
    defined in the PAL but must be visible to the HAL.

Revision History:

--*/

#ifndef _AXP21164_
#define _AXP21164_


//
// Define the "special" processor bus used by all machines that run a
// DECchip 21164.  The processor bus is used to access the internal
// performance counters.
//

#define PROCESSOR_BUS_21164 21164

//
// Define the physical address bit that turns on user-mode access
// to I/O space in the pfn of a pte.  This bit is required because of
// the current 36 bit physical address space limit on NT.
//

#define EV5_USER_IO_ADDRESS_SPACE (ULONGLONG)(0x800000000)

#define EV5_IO_BASE_PHYSICAL 0x8000000000

//
// Define the number of entries for repeated internal processor registers.
//

#define ITB_ENTRIES_21164 32
#define DTB_ENTRIES_21164 64
#define PAL_TEMPS_21164   24

//
// Define the Ibox Internal Processor Register formats.
//

//
// Define the ITB_PTE - write format.
//

typedef union _ITB_PTE_21164{
    struct {
        ULONG Ignore1: 4;
        ULONG Asm: 1;
        ULONG Gh: 2;
        ULONG Ignore2: 1;
        ULONG Kre: 1;
        ULONG Ere: 1;
        ULONG Sre: 1;
        ULONG Ure: 1;
        ULONG Ignore3: 20;
        ULONG Pfn: 27;
        ULONG Ignore4: 5;
    } ;
    ULONGLONG all;
} ITB_PTE_21164, *PITB_PTE_21164;

//
// Define the ITB_PTE_TEMP - read format.
//

typedef union _ITB_PTE_TEMP_21164{
    struct {
        ULONG Raz1: 13;
        ULONG Asm: 1;
        ULONG Raz2: 4;
        ULONG Kre: 1;
        ULONG Ere: 1;
        ULONG Sre: 1;
        ULONG Ure: 1;
        ULONG Raz3: 7;
        ULONG Ghd: 3;
        ULONG Pfn: 27;
        ULONG Raz4: 5;
    } ;
    ULONGLONG all;
} ITB_PTE_TEMP_21164, *PITB_PTE_TEMP_21164;

//
// Define the ITB_ASN.
//

typedef union _ITB_ASN_21164{
    struct {
        ULONG Raz1: 4;
        ULONG Asn: 7;
        ULONG Raz2: 21;
        ULONG Raz3: 32;
    } ;
    ULONGLONG all;
} ITB_ASN_21164, *PITB_ASN_21164;

//
// Define the ICPERR_STAT.
//

typedef union _ICPERR_STAT_21164{
    struct {
        ULONG Raz1: 11;
        ULONG Dpe: 1;
        ULONG Tpe: 1;
        ULONG Tmr: 1;
        ULONG Raz2: 18;
        ULONG Raz3: 32;
    } ;
    ULONGLONG all;
} ICPERR_STAT_21164, *PICPERR_STAT_21164;

//
// Define the EXC_SUM.
//

typedef union _EXC_SUM_21164{
    struct {
        ULONG Raz1: 10;
        ULONG Swc: 1;
        ULONG Inv: 1;
        ULONG Dze: 1;
        ULONG Fov: 1;
        ULONG Unf: 1;
        ULONG Ine: 1;
        ULONG Iov: 1;
        ULONG Raz2: 15;
        ULONG Raz3: 32;
    } ;
    ULONGLONG all;
} EXC_SUM_21164, *PEXC_SUM_21164;

//
// Define the PS.
//

typedef union _PS_21164{
    struct {
        ULONG Raz1: 3;
        ULONG Cm0: 1;
        ULONG Cm1: 1;
        ULONG Raz2: 27;
        ULONG Raz3: 32;
    } ;
    ULONGLONG all;
} PS_21164, *PPS_21164;

//
// Define the ICSR.
//

typedef union _ICSR_21164{
    struct {
        ULONG Raz1: 8;
        ULONG Pme: 2;
        ULONG Raz2: 7;
        ULONG Byte: 1;
        ULONG Raz3: 1;
        ULONG Mve: 1;   // PCA56
        ULONG Imsk: 4;
        ULONG Tmm: 1;
        ULONG Tmd: 1;
        ULONG Fpe: 1;
        ULONG Hwe: 1;
        ULONG Sp32: 1;
        ULONG Sp43: 1;
        ULONG Sde: 1;
        ULONG Raz4: 1;
        ULONG Crde: 1;
        ULONG Sle: 1;
        ULONG Fms: 1;
        ULONG Fbt: 1;
        ULONG Fbd: 1;
        ULONG Dbs: 1;
        ULONG Ista: 1;
        ULONG Tst: 1;
        ULONG Raz5: 24;
    } ;
    ULONGLONG all;
} ICSR_21164, *PICSR_21164;


//
// Define the SIRR.
//

typedef union _SIRR_21164{
    struct {
        ULONG Raz1: 4;
        ULONG Sir: 15;
        ULONG Raz2: 13;
        ULONG Raz3: 32;
    } ;
    ULONGLONG all;
} SIRR_21164, *PSIRR_21164;

//
// Define the HWINT_CLR.
//

typedef union _HWINT_CLR_21164{
    struct {
        ULONG Raz1: 27;
        ULONG Pc0c: 1;
        ULONG Pc1c: 1;
        ULONG Pc2c: 1;
        ULONG Raz2: 2;
        ULONG Crdc: 1;
        ULONG Slc: 1;
        ULONG Raz3: 30;
    } ;
    ULONGLONG all;
} HWINT_CLR_21164, *PHW_INTCLR_21164;

//
// Define the ISR.
//

typedef union _ISR_21164{
    struct {
        ULONG Ast: 4;
        ULONG Sirr: 15;
        ULONG Atr: 1;
        ULONG I20: 1;
        ULONG I21: 1;
        ULONG I22: 1;
        ULONG I23: 1;
        ULONG Raz1: 3;
        ULONG Pc0: 1;
        ULONG Pc1: 1;
        ULONG Pc2: 1;
        ULONG Pfl: 1;
        ULONG Mck: 1;
        ULONG Crd: 1;
        ULONG Sli: 1;
        ULONG Hlt: 1;
        ULONG Raz2: 29;
    } ;
    ULONGLONG all;
} ISR_21164, *PISR_21164;

//
// Define the PMCTR.
//

typedef union _PMCTR_21164{
    struct {
        ULONG Sel2: 4;
        ULONG Sel1: 4;
        ULONG Kk: 1;
        ULONG Kp: 1;
        ULONG Ctl2: 2;
        ULONG Ctl1: 2;
        ULONG Ctl0: 2;
        ULONG Ctr2: 14;
        ULONG Ku: 1;
        ULONG Sel0: 1;
        ULONG Ctr1: 16;
        ULONG Ctr0: 16;
    } ;
    ULONGLONG all;
} PMCTR_21164, *PPMCTR_21164;

//
// Define the Mbox and Dcache Internal Processor Register formats.
//

//
// Define the DTB_ASN.
//

typedef union _DTB_ASN_21164{
    struct {
        ULONG Raz1: 32;
        ULONG Raz2: 25;
        ULONG Asn: 7;
    } ;
    ULONGLONG all;
} DTB_ASN_21164, *PDTB_ASN_21164;

//
// Define the DTB_CM.
//

typedef union _DTB_CM_21164{
    struct {
        ULONG Raz1: 3;
        ULONG Cm0: 1;
        ULONG Cm1: 1;
        ULONG Raz2: 27;
        ULONG Raz3: 32;
    } ;
    ULONGLONG all;
} DTB_CM_21164, *PDTB_CM_21164;

//
// Define the DTB_PTE.
//

typedef union _DTB_PTE_21164{
    struct {
        ULONG Ignore1: 1;
        ULONG For: 1;
        ULONG Fow: 1;
        ULONG Ignore2: 1;
        ULONG Asm: 1;
        ULONG Gh: 2;
        ULONG Ignore3: 1;
        ULONG Kre: 1;
        ULONG Ere: 1;
        ULONG Sre: 1;
        ULONG Ure: 1;
        ULONG Kwe: 1;
        ULONG Ewe: 1;
        ULONG Swe: 1;
        ULONG Uwe: 1;
        ULONG Ignore4: 16;
        ULONG Pfn: 27;
        ULONG Ignore5: 5;
    } ;
    ULONGLONG all;
} DTB_PTE_21164, *PDTB_PTE_21164;

//
// Define the DTB_PTE_TEMP.
//

typedef union _DTB_PTE_TEMP_21164{
    struct {
        ULONG For: 1;
        ULONG Fow: 1;
        ULONG Kre: 1;
        ULONG Ere: 1;
        ULONG Sre: 1;
        ULONG Ure: 1;
        ULONG Kwe: 1;
        ULONG Ewe: 1;
        ULONG Swe: 1;
        ULONG Uwe: 1;
        ULONG Raz1: 3;
        ULONG Pfn31_13: 19;
        ULONG Pfn39_32: 8;
        ULONG Raz2: 24;
    } ;
    ULONGLONG all;
} DTB_PTE_TEMP_21164, *PDTB_PTE_TEMP_21164;

//
// Define the MM_STAT.
//

typedef union _MM_STAT_21164{
    struct {
        ULONG Wr: 1;
        ULONG Acv: 1;
        ULONG For: 1;
        ULONG Fow: 1;
        ULONG DtbMiss: 1;
        ULONG BadVa: 1;
        ULONG Ra: 5;
        ULONG Opcode: 6;
        ULONG Raz1: 15;
        ULONG Raz2: 32;
    } ;
    ULONGLONG all;
} MM_STAT_21164, *PMM_STAT_21164;

//
// Define the DC_PERR_STAT.
//

typedef union _DC_PERR_STAT_21164{
    struct {
        ULONG Seo: 1;
        ULONG Lock: 1;
        ULONG Dp0: 1;
        ULONG Dp1: 1;
        ULONG Tp0: 1;
        ULONG Tp1: 1;
        ULONG Raz1: 26;
        ULONG Raz2: 32;
    } ;
    ULONGLONG all;
} DC_PERR_STAT_21164, *PDC_PERR_STAT_21164;

//
// Define the MCSR.
//

typedef union _MCSR_21164{
    struct {
        ULONG MBigEndian: 1;
        ULONG Sp32: 1;
        ULONG Sp43: 1;
        ULONG DbgTestSel0: 1;
        ULONG EBigEndian: 1;
        ULONG DbgTestSel1: 1;
        ULONG Raz1: 26;
        ULONG Raz2: 32; 
    } ;
    ULONGLONG all;
} MCSR_21164, *PMCSR_21164;

//
// Define the DC_MODE.
//

typedef union _DC_MODE_21164{
    struct {
        ULONG DcEna: 1;
        ULONG DcFhit: 1;
        ULONG DcBadParity: 1;
        ULONG DcPerrDisable: 1;
        ULONG DcDoa: 1;
        ULONG Raz1: 27;
        ULONG Raz2: 32;
    } ;
    ULONGLONG all;
} DC_MODE_21164, *PDC_MODE_21164;

//
// Define the MAF_MODE.
//

typedef union _MAF_MODE_21164{
    struct {
        ULONG DreadNomerge: 1;
        ULONG WbFlushAlways: 1;
        ULONG WbNomerge: 1;
        ULONG IoNomerge: 1;
        ULONG WbCntDisable: 1;
        ULONG MafArbDisable: 1;
        ULONG DreadPending: 1;
        ULONG WbPending: 1;
        ULONG Raz1: 24;
        ULONG Raz2: 32;
    } ;
    ULONGLONG all;
} MAF_MODE_21164, *PMAF_MODE_21164;

//
// Define the ALT_MODE.
//

typedef union _ALT_MODE_21164{
    struct {
        ULONG Ignore1: 3;
        ULONG Am: 2;
        ULONG Ignore2: 27;
        ULONG Ignore3: 32;
    } ;
    ULONGLONG all;
} ALT_MODE_21164, *PALT_MODE_21164;

//
// Define the CC_CTL.
//

typedef union _CC_CTL_21164{
    struct {
        ULONG Count;
        ULONG CcEna: 1;
        ULONG Ignore: 31;
    } ;
    ULONGLONG all;
} CC_CTL_21164, *PCC_CTL_21164;

//
// Define Cbox Internal Processor Registers.
// (These IPRs are accessed via ld/st rather than mf/mt.)
//

//
// Define physical and superpage addresses for the CBOX registers.
//

#define BASE_SUPERVA (ULONGLONG)(0xfffffc0000000000)

#define SC_CTL_PA      (ULONGLONG)(0xfffff000a8)
#define SC_STAT_PA     (ULONGLONG)(0xfffff000e8)
#define SC_ADDR_PA     (ULONGLONG)(0xfffff00188)
#define BC_CONTROL_PA  (ULONGLONG)(0xfffff00128)
#define BC_CONFIG_PA   (ULONGLONG)(0xfffff001c8)
#define BC_TAG_ADDR_PA (ULONGLONG)(0xfffff00108)
#define EI_STAT_PA     (ULONGLONG)(0xfffff00168)
#define EI_ADDR_PA     (ULONGLONG)(0xfffff00148)
#define FILL_SYN_PA    (ULONGLONG)(0xfffff00068)
#define LD_LOCK_PA     (ULONGLONG)(0xfffff001e8)

#define SC_CTL_SVA      (ULONGLONG)( BASE_SUPERVA | SC_CTL_PA )
#define SC_STAT_SVA     (ULONGLONG)( BASE_SUPERVA | SC_STAT_PA )
#define SC_ADDR_SVA     (ULONGLONG)( BASE_SUPERVA | SC_ADDR_PA )
#define BC_CONTROL_SVA  (ULONGLONG)( BASE_SUPERVA | BC_CONTROL_PA )
#define BC_CONFIG_SVA   (ULONGLONG)( BASE_SUPERVA | BC_CONFIG_PA )
#define BC_TAG_ADDR_SVA (ULONGLONG)( BASE_SUPERVA | BC_TAG_ADDR_PA )
#define EI_STAT_SVA     (ULONGLONG)( BASE_SUPERVA | EI_STAT_PA )
#define EI_ADDR_SVA     (ULONGLONG)( BASE_SUPERVA | EI_ADDR_PA )
#define FILL_SYN_SVA    (ULONGLONG)( BASE_SUPERVA | FILL_SYN_PA )
#define LD_LOCK_SVA     (ULONGLONG)( BASE_SUPERVA | LD_LOCK_PA )

//
// Define the offsets for the Cbox IPRs to be used with specialized
// read/write ipr routines for EV5.
//

typedef struct _CBOX_IPRS_21164{
    UCHAR FillSyn;
    UCHAR Unused1;
    UCHAR ScCtl;
    UCHAR Unused2;
    UCHAR ScStat;
    UCHAR BcTagAddr;
    UCHAR BcControl;
    UCHAR EiAddr;
    UCHAR EiStat;
    UCHAR ScAddr;
    UCHAR Unused3;
    UCHAR BcConfig;
    UCHAR LdLock;
} CBOX_IPRS_21164, *PCBOX_IPRS_21164;

//
// Define the SC_CTL.
//

typedef union _SC_CTL_21164{
    struct {
        ULONG ScFhit: 1;
        ULONG ScFlush: 1;
        ULONG ScTagStat: 6;
        ULONG ScFbDp: 4;
        ULONG ScBlkSize: 1;
        ULONG ScSetEn: 3;
        ULONG Raz1: 16;
        ULONG Raz2: 32;
    } ;
    ULONGLONG all;
} SC_CTL_21164, *PSC_CTL_21164;

//
// Define the SC_ADDR.
//

typedef union _SC_ADDR_21164{
    struct {
        ULONGLONG Rao1: 4;
        ULONGLONG ScAddr: 35;
        ULONGLONG Raz1: 1;
        ULONGLONG Rao2: 24;
    };
    ULONGLONG all;
} SC_ADDR_21164, *PSC_ADDR_21164;

//
// Define the SC_STAT.
//

typedef union _SC_STAT_21164{
    struct {
        ULONG ScTperr: 3;
        ULONG ScDperr: 8;
        ULONG CboxCmd: 5;
        ULONG ScScndErr: 1;
        ULONG Raz1: 15;
        ULONG Raz2: 32;
    } ;
    ULONGLONG all;
} SC_STAT_21164, *PSC_STAT_21164;

//
// Define the BC_CONTROL.
//

typedef union _BC_CONTROL_21164{
    struct {
        ULONG BcEnabled: 1;
        ULONG AllocCyc: 1;
        ULONG EiCmdGrp1: 1;
        ULONG EiCmdGrp2: 1;
        ULONG CorrFillDat: 1;
        ULONG VtmFirst: 1;
        ULONG EiEccOrParity: 1;
        ULONG BcFhit: 1;
        ULONG BcTagStat: 5;
        ULONG BcBadDat: 2;
        ULONG EiDisErr: 1;
        ULONG TlPipeLatch: 1;
        ULONG BcWave: 2;
        ULONG PmMuxSel1: 3;
        ULONG PmMuxSel2: 3;
        ULONG Mbz1: 1;
        ULONG FlushScVtm: 1;
        ULONG Mbz2: 1;
        ULONG DisSysPar: 1;
        ULONG Mbz3: 3;
        ULONG Raz1: 1;
        ULONG NoByteIo: 1;
        ULONG Raz2: 30;
    } ;
    ULONGLONG all;
} BC_CONTROL_21164, *PBC_CONTROL_21164;

//
// Define the BC_CONFIG.
//

typedef union _BC_CONFIG_21164{
    struct {
        ULONG BcSize: 3;
        ULONG Reserved1: 1;
        ULONG BcRdSpd: 4;
        ULONG BcWrSpd: 4;
        ULONG BcRdWrSpc: 3;
        ULONG Reserved2: 1;
        ULONG FillWeOffset: 3;
        ULONG Reserved3: 1;
        ULONG BcWeCtl: 9;
        ULONG Reserved4: 3;
        ULONG Reserved5: 32;
    } ;
    ULONGLONG all;
} BC_CONFIG_21164, *PBC_CONFIG_21164;

//
// Define the EI_STAT.
//

typedef union _EI_STAT_21164{
    struct {
        ULONG Ra01: 24;
        ULONG ChipId: 4;
        ULONG BcTperr: 1;
        ULONG BcTcperr: 1;
        ULONG EiEs: 1;
        ULONG CorEccErr: 1;
        ULONG UncEccErr: 1;
        ULONG EiParErr: 1;
        ULONG FilIrd: 1;
        ULONG SeoHrdErr: 1;
        ULONG Ra02: 28;
    } ;
    ULONGLONG all;
} EI_STAT_21164, *PEI_STAT_21164;

//
// Define the EI_ADDR.
//

typedef union _EI_ADDR_21164{
    struct {
        ULONGLONG Rao1: 4;
        ULONGLONG EiAddr: 36;
        ULONGLONG Rao2: 24;
    };
    ULONGLONG all;
} EI_ADDR_21164, *PEI_ADDR_21164;

//
// Define the BC_TAG_ADDR.
//

typedef union _BC_TAG_ADDR_21164{
    struct {
        ULONG Ra01: 12;
        ULONG Hit: 1;
        ULONG TagCtlP: 1;
        ULONG TagCtlD: 1;
        ULONG TagCtlS: 1;
        ULONG TagCtlV: 1;
        ULONG TagP: 1;
        ULONG Ra02: 2;
        ULONG Tag0: 12;
        ULONG Tag1: 7;
        ULONG Ra03: 25;
    } ;
    ULONGLONG all;
} BC_TAG_ADDR_21164, *PBC_TAG_ADDR_21164;

//
// Define the FILL_SYN.
//

typedef union _FILL_SYN_21164{
    struct {
        ULONG Lo: 8;
        ULONG Hi: 8;
        ULONG Raz1: 16;
        ULONG Raz2: 32;
    } ;
    ULONGLONG all;
} FILL_SYN_21164, *PFILL_SYN_21164;

//++
// 21164PC Definitions
//--

//
// CBOX Register addresses
//

#define CBOX_CONFIG_PA          (ULONGLONG)(0xfffff00008)
#define CBOX_ADDRESS_PA         (ULONGLONG)(0xfffff00088)
#define CBOX_STATUS_PA          (ULONGLONG)(0xfffff00108)
#define CBOX_CONFIG2_PA         (ULONGLONG)(0xfffff00188)

#define CBOX_CONFIG_SVA         (ULONGLONG)( BASE_SUPERVA | CBOX_CONFIG_PA )
#define CBOX_ADDRESS_SVA        (ULONGLONG)( BASE_SUPERVA | CBOX_ADDRESS_PA )
#define CBOX_STATUS_SVA         (ULONGLONG)( BASE_SUPERVA | CBOX_STATUS_PA )
#define CBOX_CONFIG2_SVA        (ULONGLONG)( BASE_SUPERVA | CBOX_CONFIG2_PA )

//
// Define the offsets for the Cbox IPRs to be used with specialized
// read/write ipr routines for PCA56.
//

typedef struct _CBOX_IPRS_21164PC{
  UCHAR CboxConfig;
  UCHAR CboxAddress;
  UCHAR CboxStatus;
  UCHAR CboxConfig2;
} CBOX_IPRS_21164PC, *PCBOX_IPRS_21164PC;

//
// Define CBOX_CONFIG
//

typedef union _CBOX_CONFIG_21164PC{
  struct {
    ULONG Mbz1: 4;
    ULONG BcClkRatio: 4;
    ULONG BcLatencyOff: 4;
    ULONG BcSize: 2;
    ULONG BcClkDelay: 2;
    ULONG BcRwOff: 3;
    ULONG BcProbeDuringFill: 1;
    ULONG BcFillDelay: 3;
    ULONG IoParityEnable: 1;
    ULONG MemParityEnable: 1;
    ULONG BcForceHit: 1;
    ULONG BcForceErr: 1;
    ULONG BcBigDrv: 1;
    ULONG BcTagData: 3;
    ULONG BcEnable: 1;
    ULONG Mbz2: 32;
  };
  ULONGLONG all;
} CBOX_CONFIG_21164PC, *PCBOX_CONFIG_21164PC;

//
// Define CBOX_ADDRESS
//

typedef union _CBOX_ADDRESS_21164PC{
  struct {
    ULONGLONG Mbz1: 4;
    ULONGLONG Address36_4: 33;
    ULONGLONG Mbz2: 2;
    ULONGLONG Address39: 1;
    ULONGLONG Mbz3: 24;
  };
  ULONGLONG all;
} CBOX_ADDRESS_21164PC, *PCBOX_ADDRESS_21164PC;

//
// Define CBOX_STATUS
//

typedef union _CBOX_STATUS_21164PC{
  struct {
    ULONGLONG Mbz1: 4;
    ULONGLONG SysClkRatio: 4;
    ULONGLONG ChipRev: 4;
    ULONGLONG DataParErr: 4;
    ULONGLONG TagParErr: 1;
    ULONGLONG TagDirty: 1;
    ULONGLONG Memory: 1;
    ULONGLONG MultiErr: 1;
    ULONGLONG Mbz2: 44;
  };
  ULONGLONG all;
} CBOX_STATUS_21164PC, *PCBOX_STATUS_21164PC;

//
// Define CBOX_CONFIG2
//

typedef union _CBOX_CONFIG2_21164PC{
  struct {
    ULONGLONG Mbz1: 4;
    ULONGLONG BcRegReg: 1;
    ULONGLONG DbgSel: 1;
    ULONGLONG BcThreeMiss: 1;
    ULONGLONG Mbz2: 1;
    ULONGLONG Pm0Mux: 3;
    ULONGLONG Pm1Mux: 3;
    ULONGLONG Mbz3: 50;
  };
  ULONGLONG all;
} CBOX_CONFIG2_21164PC, *PCBOX_CONFIG2_21164PC;

//++
// End of 21164PC definitions
//--


//
// Define EV5 IPLs (interrupt priority levels.
//

#define EV5_IPL0   (0)
#define EV5_IPL1   (1)
#define EV5_IPL2   (2)
#define EV5_IPL3   (3)
#define EV5_IPL4   (4)
#define EV5_IPL5   (5)
#define EV5_IPL6   (6)
#define EV5_IPL7   (7)
#define EV5_IPL8   (8)
#define EV5_IPL9   (9)
#define EV5_IPL10 (10)
#define EV5_IPL11 (11)
#define EV5_IPL12 (12)
#define EV5_IPL13 (13)
#define EV5_IPL14 (14)
#define EV5_IPL15 (15)
#define EV5_IPL16 (16)
#define EV5_IPL17 (17)
#define EV5_IPL18 (18)
#define EV5_IPL19 (19)
#define EV5_IPL20 (20)
#define EV5_IPL21 (21)
#define EV5_IPL22 (22)
#define EV5_IPL23 (23)
#define EV5_IPL24 (24)
#define EV5_IPL25 (25)
#define EV5_IPL26 (26)
#define EV5_IPL27 (27)
#define EV5_IPL28 (28)
#define EV5_IPL29 (29)
#define EV5_IPL30 (30)
#define EV5_IPL31 (31)

//
// Define interrupt vector values for EV5.
//

#define EV5_IPL20_VECTOR (20)
#define EV5_IPL21_VECTOR (21)
#define EV5_IPL22_VECTOR (22)
#define EV5_IPL23_VECTOR (23)

#define EV5_IRQ0_VECTOR EV5_IPL20_VECTOR
#define EV5_IRQ1_VECTOR EV5_IPL21_VECTOR
#define EV5_IRQ2_VECTOR EV5_IPL22_VECTOR
#define EV5_IRQ3_VECTOR EV5_IPL23_VECTOR

#define EV5_HALT_VECTOR (14)
#define EV5_PFL_VECTOR (24)
#define EV5_MCHK_VECTOR (12)
#define EV5_CRD_VECTOR (25)
#define EV5_PC0_VECTOR (6)
#define EV5_PC1_VECTOR (8)
#define EV5_PC2_VECTOR (15)

//
// Define the Interrupt Mask structure communicated between the 
// HAL and PALcode.
//

typedef union _IMSK_21164{
    struct{
        ULONG Irq0Mask: 1;
        ULONG Irq1Mask: 1;
        ULONG Irq2Mask: 1;
        ULONG Irq3Mask: 1;
        ULONG Reserved: 28;
    };
    ULONG all;
} IMSK_21164, *PIMSK_21164;

//
// PALcode Event Counters for the 21164
// This is the structure of the data returned by the rdcounters call pal.
//

typedef struct _COUNTERS_21164{
    ULONGLONG MachineCheckCount;
    ULONGLONG ArithmeticExceptionCount;
    ULONGLONG InterruptCount;
    ULONGLONG ItbMissCount;
    ULONGLONG DtbMissSingleCount;
    ULONGLONG DtbMissDoubleCount;
    ULONGLONG IAccvioCount;
    ULONGLONG DfaultCount;
    ULONGLONG UnalignedCount;
    ULONGLONG OpcdecCount;
    ULONGLONG FenCount;
    ULONGLONG ItbTnvCount;
    ULONGLONG DtbTnvCount;
    ULONGLONG PdeTnvCount;
    ULONGLONG HardwareInterruptCount;
    ULONGLONG SoftwareInterruptCount;
    ULONGLONG SpecialInterruptCount;
    ULONGLONG HaltCount;
    ULONGLONG RestartCount;
    ULONGLONG DrainaCount;
    ULONGLONG RebootCount;
    ULONGLONG InitpalCount;
    ULONGLONG WrentryCount;
    ULONGLONG SwpirqlCount;
    ULONGLONG RdirqlCount;
    ULONGLONG DiCount;
    ULONGLONG EiCount;
    ULONGLONG SwppalCount;
    ULONGLONG SsirCount;
    ULONGLONG CsirCount;
    ULONGLONG RfeCount;
    ULONGLONG RetsysCount;
    ULONGLONG SwpctxCount;
    ULONGLONG SwpprocessCount;
    ULONGLONG RdmcesCount;
    ULONGLONG WrmcesCount;
    ULONGLONG TbiaCount;
    ULONGLONG TbisCount;
    ULONGLONG TbisasnCount;
    ULONGLONG DtbisCount;
    ULONGLONG RdkspCount;
    ULONGLONG SwpkspCount;
    ULONGLONG RdpsrCount;
    ULONGLONG RdpcrCount;
    ULONGLONG RdthreadCount;
    ULONGLONG TbimCount;
    ULONGLONG TbimasnCount;
    ULONGLONG RdcountersCount;
    ULONGLONG RdstateCount;
    ULONGLONG WrperfmonCount;
    ULONGLONG InitpcrCount;
    ULONGLONG BptCount;
    ULONGLONG CallsysCount;
    ULONGLONG ImbCount;
    ULONGLONG GentrapCount;
    ULONGLONG RdtebCount;
    ULONGLONG KbptCount;
    ULONGLONG CallkdCount;
    ULONGLONG AddressSpaceSwapCount;
    ULONGLONG AsnWrapCount;
    ULONGLONG Misc1Count;
    ULONGLONG Misc2Count;
    ULONGLONG Misc3Count;
    ULONGLONG Misc4Count;
    ULONGLONG Misc5Count;
    ULONGLONG Misc6Count;
    ULONGLONG Misc7Count;
    ULONGLONG Misc8Count;
    ULONGLONG Misc9Count;
    ULONGLONG Misc10Count;
    ULONGLONG Misc11Count;
    ULONGLONG Misc12Count;
    ULONGLONG Misc13Count;
    ULONGLONG Misc14Count;
    ULONGLONG Misc15Count;
    ULONGLONG Misc16Count;
    ULONGLONG Misc17Count;
    ULONGLONG Misc18Count;
    ULONGLONG Misc19Count;
    ULONGLONG Misc20Count;
    ULONGLONG SleepCount;
    ULONGLONG EalnfixCount;
    ULONGLONG DalnfixCount;
} COUNTERS_21164, *PCOUNTERS_21164;

//
// Types of performance counters.
//

typedef enum _AXP21164_PCCOUNTER{
	Ev5PerformanceCounter0 = 0,
	Ev5PerformanceCounter1 = 1,
	Ev5PerformanceCounter2 = 2
} AXP21164_PCCOUNTER, *PAXP21164_PCCOUNTER;

//
// Mux control values
//

typedef enum _AXP21164_PCMUXCONTROL{
	Ev5Cycles = 0x0,
	Ev5Instructions = 0x1,
	Ev5NonIssue = 0x0,
	Ev5SplitIssue = 0x1,
	Ev5PipeDry = 0x2,
	Ev5ReplayTrap = 0x3,
	Ev5SingleIssue = 0x4,
	Ev5DualIssue = 0x5,
	Ev5TripleIssue = 0x6,
	Ev5QuadIssue = 0x7,
	Ev5FlowChangeInst = 0x8,
	Ev5IntOpsIssued = 0x9,
	Ev5FPOpsIssued = 0xa,
	Ev5LoadsIssued = 0xb,
	Ev5StoresIssued = 0xc,
	Ev5IcacheIssued = 0xd,
	Ev5DcacheAccesses = 0xe,
	Ev5CBOXInput1 = 0xf,
	Ev5LongStalls = 0x0,
	Ev5PCMispredicts = 0x2,
	Ev5BRMispredicts = 0x3,
	Ev5IcacheRFBMisses = 0x4,
	Ev5ITBMisses = 0x5,
	Ev5DcacheLDMisses = 0x6,
	Ev5DTBMisses = 0x7,
	Ev5LDMergedMAF = 0x8,
	Ev5LDUReplayTraps = 0x9,
	Ev5WBMAFReplayTraps = 0xa,
	Ev5ExternPerfmonhInput = 0xb,
	Ev5CPUCycles = 0xc,
	Ev5MBStallCycles = 0xd,
	Ev5LDxLInstIssued = 0xe,
	Ev5CBOXInput2 = 0xf,

	//
	// Special MUX controls
	//

    Ev5PcSpecial = 0x10,

	Ev5JsrRetIssued = 0x10,
	Ev5CondBrIssued = 0x11,
	Ev5AllFlowIssued = 0x12,

    Ev5ScMux1 = 0x20,
    Ev5ScAccesses = 0x20,
    Ev5ScReads = 0x21,
    Ev5ScWrites = 0x22,
    Ev5ScVictims = 0x23,
    Ev5ScUndefined = 0x24,
    Ev5ScBcacheAccesses = 0x25,
    Ev5ScBcacheVictims = 0x26,
    Ev5ScSystemCmdReq = 0x27,
    Ev5ScMux2 = 0x28,
    Ev5ScMisses = 0x28,
    Ev5ScReadMisses = 0x29,
    Ev5ScWriteMisses = 0x2a,
    Ev5ScSharedWrites = 0x2b,
    Ev5ScWrites2 = 0x2c,
    Ev5ScBcacheMisses = 0x2d,
    Ev5ScSysInvalidate = 0x2e,
    Ev5ScSysReadReq = 0x2f,

} AXP21164_PCMUXCONTROL, *PAXP21164_PCMUXCONTROL;

//
// Counter control values.
//

typedef enum _AXP21164_PCEVENTCOUNT{
	Ev5CountEvents2xx8 = 0x100,
	Ev5CountEvents2xx14 = 0x4000,
	Ev5CountEvents2xx16 = 0x10000
} AXP21164_PCEVENTCOUNT, *PAXP21164_PCEVENTCOUNT;

//
//  Event count selection values
//

typedef enum _COUNTER_CONTROL{
    Ev5CounterDisable = 0x0,
    Ev5InterruptDisable = 0x1,
    Ev5EventCountLow=0x2,
    Ev5EventCountHigh=0x3
} COUNTER_CONTROL, *PCOUNTER_CONTROL;

//
// Internal processor state record.
// This is the structure of the data returned by the rdstate call pal.
//

typedef struct _PROCESSOR_STATE_21164{
    ITB_PTE_TEMP_21164 ItbPte[ ITB_ENTRIES_21164 ];
    ITB_ASN_21164 ItbAsn;
    ULONGLONG Ivptbr;
    ICPERR_STAT_21164 IcPerrStat;
    EXC_SUM_21164 ExcSum;
    ULONGLONG ExcMask;
    ULONGLONG PalBase;
    PS_21164 Ps;
    ICSR_21164 Icsr;
    ULONGLONG Ipl;
    ULONGLONG IntId;
    ULONGLONG Astrr;
    ULONGLONG Aster;
    SIRR_21164 Sirr;
    ISR_21164 Isr;
    PMCTR_21164 Pmctr;
    ULONGLONG PalTemp[ PAL_TEMPS_21164 ];
    DTB_PTE_TEMP_21164 DtbPte[ DTB_ENTRIES_21164 ];
    MM_STAT_21164 MmStat;
    ULONGLONG Va;
    DC_PERR_STAT_21164 DcPerrStat;
    MCSR_21164 Mcsr;
    DC_MODE_21164 DcMode;
    MAF_MODE_21164 MafMode;
    union {
      struct {  // EV5
        SC_CTL_21164 ScCtl;
        SC_ADDR_21164 ScAddr;
        SC_STAT_21164 ScStat;
        BC_CONTROL_21164 BcControl;
        BC_CONFIG_21164 BcConfig;
        EI_STAT_21164 EiStat;
        EI_ADDR_21164 EiAddr;
        BC_TAG_ADDR_21164 BcTagAddr;
        FILL_SYN_21164 FillSyn;
      };
      struct { // PCA56
        CBOX_CONFIG_21164PC CboxConfig;
        CBOX_ADDRESS_21164PC CboxAddress;
        CBOX_STATUS_21164PC CboxStatus;
        CBOX_CONFIG2_21164PC CboxConfig2;
        ULONGLONG Reserved1;
        ULONGLONG Reserved2;
        ULONGLONG Reserved3;
        ULONGLONG Reserved4;
        ULONGLONG Reserved5;
      };
    };
} PROCESSOR_STATE_21164, *PPROCESSOR_STATE_21164;

//
// Machine-check logout frame.
//

typedef struct _LOGOUT_FRAME_21164{
    ULONGLONG           ExcAddr;
    ULONGLONG           PalBase;
    ULONGLONG           Ps;
    ULONGLONG           Va;
    ULONGLONG           VaForm;
    ICSR_21164          Icsr;
    ICPERR_STAT_21164   IcPerrStat;
    ISR_21164           Isr;
    ULONGLONG           Ipl;
    ULONGLONG           IntId;
    MM_STAT_21164       MmStat;
    MCSR_21164          Mcsr;
    DC_PERR_STAT_21164  DcPerrStat;
    union {
      struct {  // EV5
        SC_CTL_21164        ScCtl;
        SC_STAT_21164       ScStat;
        SC_ADDR_21164       ScAddr;
        BC_CONTROL_21164    BcControl;
        BC_CONFIG_21164     BcConfig;
        BC_TAG_ADDR_21164   BcTagAddr;
        EI_STAT_21164       EiStat;
        EI_ADDR_21164       EiAddr;
        FILL_SYN_21164      FillSyn;
      };
      struct { // PCA56
        CBOX_CONFIG_21164PC CboxConfig;
        CBOX_ADDRESS_21164PC CboxAddress;
        CBOX_STATUS_21164PC CboxStatus;
        CBOX_CONFIG2_21164PC CboxConfig2;
        ULONGLONG Reserved1;
        ULONGLONG Reserved2;
        ULONGLONG Reserved3;
        ULONGLONG Reserved4;
        ULONGLONG Reserved5;
      };
    };
    ULONGLONG PalTemp[ PAL_TEMPS_21164 ];
} LOGOUT_FRAME_21164, *PLOGOUT_FRAME_21164;

//
// Correctable Machine-check logout frame.
//

typedef struct _CORRECTABLE_FRAME_21164{
    union {
      struct {  // EV5
        EI_STAT_21164       EiStat;
        EI_ADDR_21164       EiAddr;
        FILL_SYN_21164      FillSyn;
      };
      struct { // PCA56
        CBOX_STATUS_21164PC CboxStatus;
        CBOX_ADDRESS_21164PC CboxAddress;
        ULONGLONG Reserved;
      };
    };
    ISR_21164           Isr;
} CORRECTABLE_FRAME_21164;

//
// Define the number of physical and virtual address bits
//

#define EV5_PHYSICAL_ADDRESS_BITS     40
#define EV5_VIRTUAL_ADDRESS_BITS      43

#endif //!_AXP21164_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\axp21066.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) 1993 Digital Euipment Corporation

Module Name:

    axp21066.h

Abstract:

    This module defines the DECchip 21066-specific structures that are
    defined in the PAL but must be visible to the HAL.

Revision History:

--*/

#ifndef _AXP21066_
#define _AXP21066_


#ifndef CORE_21064
#define CORE_21064

//
// Define the "special" processor bus used by all machines that run a
// DECchip 21064.  The processor bus is used to access the internal
// performance counters.
//

#define PROCESSOR_BUS_21064 21064

//
// Define the number of entries for repeated internal processor registers.
//

#define ITB_ENTRIES_21064 12
#define DTB_ENTRIES_21064 32
#define PAL_TEMPS_21064   32

//
// Define an interrupt enable table entry.
//

typedef struct _IETEntry_21064{
    ULONG ApcEnable: 1;
    ULONG DispatchEnable: 1;
    ULONG PerformanceCounter0Enable: 1;
    ULONG PerformanceCounter1Enable: 1;
    ULONG CorrectableReadEnable: 1;
    ULONG Irq0Enable: 1;
    ULONG Irq1Enable: 1;
    ULONG Irq2Enable: 1;
    ULONG Irq3Enable: 1;
    ULONG Irq4Enable: 1;
    ULONG Irq5Enable: 1;
    ULONG Reserved: 21;
} IETEntry_21064, *PIETEntry_21064;


//
// Define the offsets and sizes of the mask sub-tables within the interrupt
// mask table in the PCR.
//

#define IRQLMASK_HDW_SUBTABLE_21064 (8)
#define IRQLMASK_HDW_SUBTABLE_21064_ENTRIES (64)

#define IRQLMASK_SFW_SUBTABLE_21064 (0)
#define IRQLMASK_SFW_SUBTABLE_21064_ENTRIES (4)

#define IRQLMASK_PC_SUBTABLE_21064  (4)
#define IRQLMASK_PC_SUBTABLE_21064_ENTRIES (4)

//
// PALcode Event Counters for the 21064
// This is the structure of the data returned by the rdcounters call pal.
//

typedef struct _COUNTERS_21064{
    LARGE_INTEGER MachineCheckCount;
    LARGE_INTEGER ArithmeticExceptionCount;
    LARGE_INTEGER InterruptCount;
    LARGE_INTEGER ItbMissCount;
    LARGE_INTEGER NativeDtbMissCount;
    LARGE_INTEGER PalDtbMissCount;
    LARGE_INTEGER ItbAcvCount;
    LARGE_INTEGER DtbAcvCount;
    LARGE_INTEGER UnalignedCount;
    LARGE_INTEGER OpcdecCount;
    LARGE_INTEGER FenCount;
    LARGE_INTEGER ItbTnvCount;
    LARGE_INTEGER DtbTnvCount;
    LARGE_INTEGER PteMissCount;
    LARGE_INTEGER KspMissCount;
    LARGE_INTEGER PdeTnvCount;
    LARGE_INTEGER HaltCount;
    LARGE_INTEGER RestartCount;
    LARGE_INTEGER DrainaCount;
    LARGE_INTEGER InitpalCount;
    LARGE_INTEGER WrentryCount;
    LARGE_INTEGER SwpirqlCount;
    LARGE_INTEGER RdirqlCount;
    LARGE_INTEGER DiCount;
    LARGE_INTEGER EiCount;
    LARGE_INTEGER SwppalCount;
    LARGE_INTEGER SsirCount;
    LARGE_INTEGER CsirCount;
    LARGE_INTEGER RfeCount;
    LARGE_INTEGER RetsysCount;
    LARGE_INTEGER SwpctxCount;
    LARGE_INTEGER SwpprocessCount;
    LARGE_INTEGER RdmcesCount;
    LARGE_INTEGER WrmcesCount;
    LARGE_INTEGER TbiaCount;
    LARGE_INTEGER TbisCount;
    LARGE_INTEGER DtbisCount;
    LARGE_INTEGER RdkspCount;
    LARGE_INTEGER SwpkspCount;
    LARGE_INTEGER RdpsrCount;
    LARGE_INTEGER RdpcrCount;
    LARGE_INTEGER RdthreadCount;
    LARGE_INTEGER RdcountersCount;
    LARGE_INTEGER RdstateCount;
    LARGE_INTEGER WrperfmonCount;
    LARGE_INTEGER InitpcrCount;
    LARGE_INTEGER BptCount;
    LARGE_INTEGER CallsysCount;
    LARGE_INTEGER ImbCount;
    LARGE_INTEGER GentrapCount;
    LARGE_INTEGER RdtebCount;
    LARGE_INTEGER KbptCount;
    LARGE_INTEGER CallkdCount;
    LARGE_INTEGER TbisasnCount;
    LARGE_INTEGER Misc1Count;
    LARGE_INTEGER Misc2Count;
    LARGE_INTEGER Misc3Count;
} COUNTERS_21064, *PCOUNTERS_21064;

typedef enum _AXP21064_PCCOUNTER{
    Ev4PerformanceCounter0 = 0,
    Ev4PerformanceCounter1 = 1
} AXP21064_PCCOUNTER, *PAXP21064_PCCOUNTER;

typedef enum _AXP21064_PCMUXCONTROL{
    Ev4TotalIssues = 0x0,
    Ev4PipelineDry = 0x2,
    Ev4LoadInstruction = 0x4,
    Ev4PipelineFrozen = 0x6,
    Ev4BranchInstructions = 0x8,
    Ev4PalMode = 0xb,
    Ev4TotalCycles = 0xa,
    Ev4TotalNonIssues = 0xc,
    Ev4ExternalCounter0 = 0xe,
    Ev4DcacheMiss = 0x0,
    Ev4IcacheMiss = 0x1,
    Ev4DualIssues = 0x2,
    Ev4BranchMispredicts = 0x3,
    Ev4FPInstructions = 0x4,
    Ev4IntegerOperate = 0x5,
    Ev4StoreInstructions = 0x6,
    Ev4ExternalCounter1 = 0x7
} AXP21064_PCMUXCONTROL, *PAXP21064_PCMUXCONTROL;

typedef enum _AXP21064_PCEVENTCOUNT{
    Ev4CountEvents2xx8 = 0x100,
    Ev4CountEvents2xx12 = 0x1000,
    Ev4CountEvents2xx16 = 0x10000
} AXP21064_PCEVENTCOUNT, *PAXP21064_PCEVENTCOUNT;

typedef enum _AXP21064_EVENTCOUNT{
    Ev4EventCountHigh = 1,
    Ev4EventCountLow = 0
} AXP21064_EVENTCOUNT, *PAXP21064_EVENTCOUNT;

//
// Internal Processor Register definitions (read format).
//

//
// Pte formats
//

typedef LARGE_INTEGER ITB_PTE_21064;
typedef ITB_PTE_21064 *PITB_PTE_21064;
typedef LARGE_INTEGER DTB_PTE_21064;
typedef DTB_PTE_21064 *PDTB_PTE_21064;

#define PTE_FOR_21064_SHIFT 3
#define PTE_FOW_21064_SHIFT 4
#define PTE_KWE_21064_SHIFT 5
#define PTE_EWE_21064_SHIFT 6
#define PTE_SWE_21064_SHIFT 7
#define PTE_UWE_21064_SHIFT 8
#define PTE_KRE_21064_SHIFT 9
#define PTE_ERE_21064_SHIFT 10
#define PTE_SRE_21064_SHIFT 11
#define PTE_URE_21064_SHIFT 12 
#define PTE_PFN_21064_SHIFT 13
#define PTE_PFN_21064_SHIFTMASK  0x1FFFF
#define PTE_ASM_21064_SHIFT 34

#define PTE_ALL_21064(itbpte) (itbpte)
#define PTE_FOR_21064(itbpte) ( (itbpte.LowPart >> PTE_FOR_21064_SHIFT) & 1)
#define PTE_FOW_21064(itbpte) ( (itbpte.LowPart >> PTE_FOW_21064_SHIFT) & 1)
#define PTE_KWE_21064(itbpte) ( (itbpte.LowPart >> PTE_KWE_21064_SHIFT) & 1)
#define PTE_EWE_21064(itbpte) ( (itbpte.LowPart >> PTE_EWE_21064_SHIFT) & 1)
#define PTE_SWE_21064(itbpte) ( (itbpte.LowPart >> PTE_SWE_21064_SHIFT) & 1)
#define PTE_UWE_21064(itbpte) ( (itbpte.LowPart >> PTE_UWE_21064_SHIFT) & 1)
#define PTE_KRE_21064(itbpte) ( (itbpte.LowPart >> PTE_KRE_21064_SHIFT) & 1)
#define PTE_ERE_21064(itbpte) ( (itbpte.LowPart >> PTE_ERE_21064_SHIFT) & 1)
#define PTE_SRE_21064(itbpte) ( (itbpte.LowPart >> PTE_SRE_21064_SHIFT) & 1)
#define PTE_URE_21064(itbpte) ( (itbpte.LowPart >> PTE_URE_21064_SHIFT) & 1)
#define PTE_ASM_21064(itbpte) ( (itbpte.LowPart >> PTE_ASM_21064_SHIFT) & 1)
#define PTE_PFN_21064(itbpte) ( (itbpte.LowPart >> PTE_PFN_21064_SHIFT) & PTE_PFN_21064_SHIFTMASK)

//
// Instruction Cache Control and Status Register format
//

typedef LARGE_INTEGER ICCSR_21064;
typedef ICCSR_21064 *PICCSR_21064;

#define ICCSR_PC0_21064_SHIFT   1
#define ICCSR_PC1_21064_SHIFT   2
#define ICCSR_PCMUX0_21064_SHIFT 9
#define ICCSR_PCMUX0_21064_SHIFTMASK 0xF
#define ICCSR_PCMUX1_21064_SHIFT 13
#define ICCSR_PCMUX1_21064_SHIFTMASK 0x7
#define ICCSR_PIPE_21064_SHIFT 16
#define ICCSR_BPE_21064_SHIFT  17
#define ICCSR_JSE_21064_SHIFT  18
#define ICCSR_BHE_21064_SHIFT  19
#define ICCSR_DI_21064_SHIFT   20
#define ICCSR_HWE_21064_SHIFT  21
#define ICCSR_MAP_21064_SHIFT  22
#define ICCSR_FPE_21064_SHIFT  23
#define ICCSR_ASN_21064_SHIFT  28
#define ICCSR_ASN_21064_SHIFTMASK 0x3F

#define ICCSR_ALL_21064(iccsr) (iccsr)
#define ICCSR_PC0_21064(iccsr) ( (iccsr.LowPart >> ICCSR_PC0_21064_SHIFT) & 1)
#define ICCSR_PC1_21064(iccsr) ( (iccsr.LowPart >> ICCSR_PC1_21064_SHIFT) & 1)
#define ICCSR_PCMUX0_21064(iccsr) \
    ( (iccsr.LowPart >> ICCSR_PCMUX0_21064_SHIFT) & ICCSR_PCMUX0_21064_SHIFTMASK)
#define ICCSR_PCMUX1_21064(iccsr) \
    ( (iccsr.LowPart >> ICCSR_PCMUX1_21064_SHIFT) & ICCSR_PCMUX1_21064_SHIFTMASK)
#define ICCSR_PIPE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_PIPE_21064_SHIFT) & 1)
#define ICCSR_BPE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_BPE_21064_SHIFT) & 1)
#define ICCSR_JSE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_JSE_21064_SHIFT) & 1)
#define ICCSR_BHE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_BHE_21064_SHIFT) & 1)
#define ICCSR_DI_21064(iccsr)  ( (iccsr.LowPart >> ICCSR_DI_21064_SHIFT) & 1)
#define ICCSR_HWE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_HWE_21064_SHIFT) & 1)
#define ICCSR_MAP_21064(iccsr) ( (iccsr.LowPart >> ICCSR_MAP_21064_SHIFT) & 1)
#define ICCSR_FPE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_FPE_21064_SHIFT) & 1)
#define ICCSR_ASN_21064(iccsr) \
    (ULONG)( (iccsr.LowPart >> ICCSR_ASN_21064_SHIFT) & ICCSR_ASN_21064_SHIFTMASK)

//
// Processor Status (PS) format.
//

typedef LARGE_INTEGER PS_21064;
typedef PS_21064 *PPS_21064;

#define PS_CM0_21064_SHIFT 1
#define PS_CM1_21064_SHIFT 34

#define PS_ALL_21064(ps) (ps)
#define PS_CM_21064(ps) \
        ( (((ps).LowPart >> PS_CM0_21064_SHIFT) & 1) || \
          (((ps).LowPart >> (PS_CM1_21064_SHIFT-1)) & 1) )

//
// Exception Summary (EXC_SUM) format.
//

typedef LARGE_INTEGER EXC_SUM_21064;
typedef EXC_SUM_21064 *PEXC_SUM_21064;

#define EXCSUM_SWC_21064_SHIFT 2
#define EXCSUM_INV_21064_SHIFT 3
#define EXCSUM_DZE_21064_SHIFT 4
#define EXCSUM_FOV_21064_SHIFT 5
#define EXCSUM_UNF_21064_SHIFT 6
#define EXCSUM_INE_21064_SHIFT 7
#define EXCSUM_IOV_21064_SHIFT 8
#define EXCSUM_MSK_21064_SHIFT 33

#define EXCSUM_ALL_21064(excsum) (excsum)
#define EXCSUM_SWC_21064(excsum) ((excsum.LowPart >> EXCSUM_SWC_21064_SHIFT) & 0x1)
#define EXCSUM_INV_21064(excsum) ( (excsum.LowPart >> EXCSUM_INV_21064_SHIFT) & 0x1)
#define EXCSUM_DZE_21064(excsum) ( (excsum.LowPart >> EXCSUM_DZE_21064_SHIFT) & 0x1)
#define EXCSUM_FOV_21064(excsum) ( (excsum.LowPart >> EXCSUM_FOV_21064_SHIFT) & 0x1)
#define EXCSUM_UNF_21064(excsum) ( (excsum.LowPart >> EXCSUM_UNF_21064_SHIFT) & 0x1)
#define EXCSUM_INE_21064(excsum) ( (excsum.LowPart >> EXCSUM_INE_21064_SHIFT) & 0x1)
#define EXCSUM_IOV_21064(excsum) ( (excsum.LowPart >> EXCSUM_IOV_21064_SHIFT) & 0x1)
#define EXCSUM_MSK_21064(excsum) ( (excsum.LowPart >> EXCSUM_MSK_21064_SHIFT) & 0x1)

//
// Interrupt Request (HIRR, SIRR, ASTRR) format.
//

typedef LARGE_INTEGER IRR_21064;
typedef IRR_21064 *PIRR_21064;

#define IRR_HWR_21064_SHIFT 1
#define IRR_SWR_21064_SHIFT 2
#define IRR_ATR_21064_SHIFT 3
#define IRR_CRR_21064_SHIFT 4
#define IRR_HIRR53_21064_SHIFT 5
#define IRR_HIRR53_21064_SHIFTMASK 0x7
#define IRR_PC1_21064_SHIFT 8
#define IRR_PC0_21064_SHIFT 9
#define IRR_HIRR20_21064_SHIFT 10
#define IRR_HIRR20_21064_SHIFTMASK 0x7
#define IRR_SLR_21064_SHIFT 13
#define IRR_SIRR_21064_SHIFT 14
#define IRR_SIRR_21064_SHIFTMASK 0x7FFF
#define IRR_ASTRR_21064_SHIFT 29
#define IRR_ASTRR_21064_SHIFTMASK 0xF

#define IRR_ALL_21064(irr) (irr)
#define IRR_HWR_21064(irr) ( (irr.LowPart >> IRR_HWR_21064_SHIFT) & 0x1)
#define IRR_SWR_21064(irr) ( (irr.LowPart >> IRR_SWR_21064_SHIFT) & 0x1)
#define IRR_ATR_21064(irr) ( (irr.LowPart >> IRR_ATR_21064_SHIFT) & 0x1)
#define IRR_CRR_21064(irr) ( (irr.LowPart >> IRR_CRR_21064_SHIFT) & 0x1)
#define IRR_HIRR_21064(irr) \
    ( ((irr.LowPart >> (IRR_HIRR53_21064_SHIFT-3)) & IRR_HIRR53_21064_SHIFTMASK) || \
    ( (irr.LowPart >> IRR_HIRR20_21064_SHIFT) & IRR_HIRR20_21064_SHIFTMASK) )
#define IRR_PC1_21064(irr) ( (irr.LowPart >> IRR_PC1_21064_SHIFT) & 0x1)
#define IRR_PC0_21064(irr) ( (irr.LowPart >> IRR_PC0_21064_SHIFT) & 0x1)
#define IRR_SLR_21064(irr) ( (irr.LowPart >> IRR_SLR_21064_SHIFT) & 0x1)
#define IRR_SIRR_21064(irr) \
    ( (irr.LowPart >> IRR_SIRR_21064_SHIFT) & IRR_SIRR_21064_SHIFTMASK)
#define IRR_ASTRR_21064(irr) \
    ( (irr.LowPart >> IRR_ASTRR_21064_SHIFT) & IRR_ASTRR_21064_SHIFTMASK)

//
// Interrupt Enable (HIER, SIER, ASTER) format.
//

typedef LARGE_INTEGER IER_21064;
typedef IER_21064 *PIER_21064;

#define IER_CRR_21064_SHIFT 4
#define IER_HIER53_21064_SHIFT 5
#define IER_HIER53_21064_SHIFTMASK 0x7
#define IER_PC1_21064_SHIFT 8
#define IER_PC0_21064_SHIFT 9
#define IER_HIER20_21064_SHIFT 10
#define IER_HIER20_21064_SHIFTMASK 0x7
#define IER_SLR_21064_SHIFT 13
#define IER_SIER_21064_SHIFT 14
#define IER_SIER_21064_SHIFTMASK 0x7FFF
#define IER_ASTER_21064_SHIFT 29
#define IER_ASTER_21064_SHIFTMASK 0xF

#define IER_ALL_21064(ier) (ier)
#define IER_CRR_21064(ier) ( (ier.LowPart >> IER_CRR_21064_SHIFT) & 0x1)
#define IER_HIER_21064(ier) \
    ( ( (ier.LowPart >> (IER_HIER53_21064_SHIFT-3)) & IER_HIER53_21064_SHIFTMASK) || \
      ( (ier.LowPart >> IER_HIER20_21064_SHIFT) & IER_HIER20_21064_SHIFTMASK) )
#define IER_PC1_21064(ier) ( (ier.LowPart >> IER_PC1_21064_SHIFT) & 0x1)
#define IER_PC0_21064(ier) ( (ier.LowPart >> IER_PC0_21064_SHIFT) & 0x1)
#define IER_SLR_21064(ier) ( (ier.LowPart >> IER_SLR_21064_SHIFT) & 0x1)
#define IER_SIER_21064(ier) \
    ( (ier.LowPart >> IER_SIER_21064_SHIFT) & IER_SIER_21064_SHIFTMASK)
#define IER_ASTER_21064(ier) \
    ( (ier.LowPart >> IER_ASTER_21064_SHIFT) & IER_ASTER_21064_SHIFTMASK)

//
// Abox Control Register (ABOX_CTL) format.
//

typedef union _ABOX_CTL_21064{
    struct {
        ULONG wb_dis: 1;
        ULONG mchk_en: 1;
        ULONG crd_en: 1;
        ULONG ic_sbuf_en: 1;
        ULONG spe_1: 1;
        ULONG spe_2: 1;
        ULONG emd_en: 1;
        ULONG mbz1: 3;
        ULONG dc_ena: 1;
        ULONG dc_fhit: 1;
    } bits;
    LARGE_INTEGER all;
} ABOX_CTL_21064, *PABOX_CTL_21064;

#define ABOXCTL_ALL_21064(aboxctl) ((aboxctl).all)
#define ABOXCTL_WBDIS_21064(aboxctl) ((aboxctl).bits.wb_dis)
#define ABOXCTL_MCHKEN_21064(aboxctl) ((aboxctl).bits.mchk_en)
#define ABOXCTL_CRDEN_21064(aboxctl) ((aboxctl).bits.crd_en)
#define ABOXCTL_ICSBUFEN_21064(aboxctl) ((aboxctl).bits.ic_sbuf_en)
#define ABOXCTL_SPE1_21064(aboxctl) ((aboxctl).bits.spe_1)
#define ABOXCTL_SPE2_21064(aboxctl) ((aboxctl).bits.spe_2)
#define ABOXCTL_EMDEN_21064(aboxctl) ((aboxctl).bits.emd_en)
#define ABOXCTL_DCENA_21064(aboxctl) ((aboxctl).bits.dc_ena)
#define ABOXCTL_DCFHIT_21064(aboxctl) ((aboxctl).bits.dc_fhit)

//
// Memory Management Control and Status Register (MMCSR) format.
//

typedef union _MMCSR_21064{
    struct {
        ULONG Wr: 1;
        ULONG Acv: 1;
        ULONG For: 1;
        ULONG Fow: 1;
        ULONG Ra: 5;
        ULONG Opcode: 6;
    } bits;
    LARGE_INTEGER all;
} MMCSR_21064, *PMMCSR_21064;

#define MMCSR_ALL_21064(mmcsr) ((mmcsr).all)
#define MMCSR_WR_21064(mmcsr) ((mmcsr).bits.Wr)
#define MMCSR_ACV_21064(mmcsr) ((mmcsr).bits.Acv)
#define MMCSR_FOR_21064(mmcsr) ((mmcsr).bits.For)
#define MMCSR_FOW_21064(mmcsr) ((mmcsr).bits.Fow)
#define MMCSR_RA_21064(mmcsr) ((mmcsr).bits.Ra)
#define MMCSR_OPCODE_21064(mmcsr) ((mmcsr).bits.Opcode)

//
// Dcache Status (DC_STAT) format.
//
typedef union _DC_STAT_21064{
    struct {
        ULONG Reserved: 3;
        ULONG DcHit: 1;
        ULONG DCacheParityError: 1;
        ULONG ICacheParityError: 1;
    } bits;
    LARGE_INTEGER all;
} DC_STAT_21064, *PDC_STAT_21064;

#define DCSTAT_ALL_21064(dcstat) ((dcstat).all)
#define DCSTAT_DCHIT_21064(dcstat) ((dcstat).bits.DcHit)
#define DCSTAT_DCPARITY_ERROR_21064(dcstat) ((dcstat).bits.DCacheParityError)
#define DCSTAT_ICPARITY_ERROR_21064(dcstat) ((dcstat).bits.ICacheParityError)

#endif //!CORE_21064

//end_axp21064

//
// Define the number of banks in the memory controller.
//

#define MEMORY_BANKS_21066 (4)

//
// Define the base physical addresses for the integrated
// memory and I/O controllers.
//

#define MEMORY_CONTROLLER_PHYSICAL_21066 (0x120000000)
#define IO_CONTROLLER_PHYSICAL_21066 (0x180000000)

//
// Define the memory controller CSR structure.
//

typedef struct _MEMC_CSRS_21066{
    LARGE_INTEGER Bcr0;
    LARGE_INTEGER Bcr1;
    LARGE_INTEGER Bcr2;
    LARGE_INTEGER Bcr3;
    LARGE_INTEGER Bmr0;
    LARGE_INTEGER Bmr1;
    LARGE_INTEGER Bmr2;
    LARGE_INTEGER Bmr3;
    LARGE_INTEGER Btr0;
    LARGE_INTEGER Btr1;
    LARGE_INTEGER Btr2;
    LARGE_INTEGER Btr3;
    LARGE_INTEGER Gtr;
    LARGE_INTEGER Esr;
    LARGE_INTEGER Ear;
    LARGE_INTEGER Car;
    LARGE_INTEGER Vgr;
    LARGE_INTEGER Plm;
    LARGE_INTEGER For;
} MEMC_CSRS_21066, *PMEMC_CSRS_21066;

//
// Define the i/o controller CSR structure.
//

typedef struct _IOC_CSRS_21066{
    LARGE_INTEGER Hae;
    LARGE_INTEGER Filler1[3];
    LARGE_INTEGER Cct;
    LARGE_INTEGER Filler2[3];
    LARGE_INTEGER IoStat0;
    LARGE_INTEGER Filler3[3];
    LARGE_INTEGER IoStat1;
    LARGE_INTEGER Filler4[3];
    LARGE_INTEGER Tbia;
    LARGE_INTEGER Filler5[3];
    LARGE_INTEGER Tben;
    LARGE_INTEGER Filler6[3];
    LARGE_INTEGER PciSoftReset;
    LARGE_INTEGER Filler7[3];
    LARGE_INTEGER PciParityDisable;
    LARGE_INTEGER Filler8[3];
    LARGE_INTEGER Wbase0;
    LARGE_INTEGER Filler9[3];
    LARGE_INTEGER Wbase1;
    LARGE_INTEGER Filler10[3];
    LARGE_INTEGER Wmask0;
    LARGE_INTEGER Filler11[3];
    LARGE_INTEGER Wmask1;
    LARGE_INTEGER Filler12[3];
    LARGE_INTEGER Tbase0;
    LARGE_INTEGER Filler13[3];
    LARGE_INTEGER Tbase1;
    LARGE_INTEGER Filler14[3];
} IOC_CSRS_21066, *PIOC_CSRS_21066;


//
// Bank Configuration Registers (BCR0 - BCR3)
//

typedef union _BCR_21066{
    struct {
        ULONG Reserved1: 6;
        ULONG Ras: 4;
        ULONG Erm: 1;
        ULONG Wrm: 1;
        ULONG Bwe: 1;
        ULONG Sbe: 1;
        ULONG Bav: 1;
        ULONG Reserved2: 5;
        ULONG BankBase: 9;
        ULONG Reserved3: 3;
    } ;
    LARGE_INTEGER all;
} BCR_21066, *PBCR_21066;

//
// Bank Address Mask Registers (BMR0 - BMR3)
//

typedef union _BMR_21066{
    struct {
        ULONG Reserved1: 20;
        ULONG BankAddressMask: 9;
        ULONG Reserved2: 3;
    } ;
    LARGE_INTEGER all;
} BMR_21066, *PBMR_21066;

//
// Global Timing Register (GTR)
//

typedef union _GTR_21066{
    struct {
        ULONG Precharge: 5;
        ULONG MinimumRas: 5;
        ULONG MaximumRas: 8;
        ULONG RefreshEnable: 1;
        ULONG RefreshInterval: 8;
        ULONG RefreshDivideSelect: 1;
        ULONG Setup: 4;
    } ;
    LARGE_INTEGER all;
} GTR_21066, *PGTR_21066;

//
// Error Status Register (ESR)
//

typedef union _ESR_21066{
    struct {
        ULONG Eav: 1;
        ULONG Cee: 1;
        ULONG Uee: 1;
        ULONG Wre: 1;
        ULONG Sor: 1;
        ULONG Reserved1: 2;
        ULONG Cte: 1;
        ULONG Reserved2: 1;
        ULONG Mse: 1;
        ULONG Mhe: 1;
        ULONG Ice: 1;
        ULONG Nxm: 1;
        ULONG Reserved3: 19;
        ULONG Ecc0: 1;       
        ULONG Wec6: 1;
        ULONG Wec3: 1;
        ULONG Reserved4: 1;
        ULONG Ecc1: 1;
        ULONG Reserved5: 3;
        ULONG Wec7: 1;
        ULONG Ecc2: 1;
        ULONG Wec2: 1;
        ULONG Reserved6: 2;
        ULONG Ecc3: 1;
        ULONG Reserved7: 2;
        ULONG Wec4: 1;
        ULONG Wec1: 1;
        ULONG Ecc4: 1;
        ULONG Wec0: 1;
        ULONG Reserved8: 2;
        ULONG Ecc5: 1;
        ULONG Reserved9: 4;
        ULONG Ecc6: 1;
        ULONG Wec5: 1;
        ULONG Reserved10: 2;
        ULONG Ecc7: 1;       
    } ;
    LARGE_INTEGER all;
} ESR_21066, *PESR_21066;

//
// Error Address Register (EAR)
//

typedef union _EAR_21066{
    struct {
        ULONG PerfCntMux0: 3;
        ULONG ErrorAddress: 26;
        ULONG PerfCntMux1: 3;
    } ;
    LARGE_INTEGER all;
} EAR_21066, *PEAR_21066;


//
// Cache Register (CAR)
//

typedef union _CAR_21066{
    struct {
        ULONG Bce: 1;
        ULONG Reserved1: 1;
        ULONG Etp: 1;
        ULONG Wwp: 1;
        ULONG Ece: 1;
        ULONG BCacheSize: 3;
        ULONG ReadCycles: 3;
        ULONG WriteCycles: 3;
        ULONG Whd: 1;
        ULONG Pwr: 1;
        ULONG Tag: 15;
        ULONG Hit: 1;
    } ;
    LARGE_INTEGER all;
} CAR_21066, *PCAR_21066;

       
//
// IOC Status 0 Registers (IOC_STAT0)
//

typedef union _IOC_STAT0_21066{
    struct {
        ULONG Cmd: 4;
        ULONG Err: 1;
        ULONG Lost: 1;
        ULONG Thit: 1;
        ULONG Tref: 1;
        ULONG Code: 3;
        ULONG Reserved1: 2;
        ULONG PageNumber: 19;
    } ;
    LARGE_INTEGER all;
} IOC_STAT0_21066, *PIOC_STAT0_21066;


//
// IOC Status 1 Register (IOC_STAT1)
//

typedef union _IOC_STAT1_21066{
    struct {
        ULONG Address: 32;
    } ;
    LARGE_INTEGER all;
} IOC_STAT1_21066, *PIOC_STAT1_21066;


//
// Internal Processor State record.
// This is the structure of the data returned by the rdstate call pal.
//

typedef struct _PROCESSOR_STATE_21066{
    ABOX_CTL_21064 AboxCtl;
    IER_21064 Aster;
    IRR_21064 Astrr;
    BCR_21066 BankConfig[ MEMORY_BANKS_21066 ];
    BMR_21066 BankMask[ MEMORY_BANKS_21066 ];
    DC_STAT_21064 DcStat;
    DTB_PTE_21064 DtbPte[ DTB_ENTRIES_21064 ];
    EXC_SUM_21064 ExcSum;
    IER_21064 Hier;
    IRR_21064 Hirr;
    ICCSR_21064 Iccsr;
    ITB_PTE_21064 ItbPte[ ITB_ENTRIES_21064 ];
    MMCSR_21064 MmCsr;
    LARGE_INTEGER PalBase;
    LARGE_INTEGER PalTemp[ PAL_TEMPS_21064 ];
    PS_21064 Ps;
    IER_21064 Sier;
    IRR_21064 Sirr;
    LARGE_INTEGER Va;
} PROCESSOR_STATE_21066, *PPROCESSOR_STATE_21066;

//
// Machine-check logout frame.
//

typedef struct _LOGOUT_FRAME_21066{
    ABOX_CTL_21064 AboxCtl;
    BCR_21066 BankConfig[ MEMORY_BANKS_21066 ];
    BMR_21066 BankMask[ MEMORY_BANKS_21066 ];
    DC_STAT_21064 DcStat;
    LARGE_INTEGER ExcAddr;
    EXC_SUM_21064 ExcSum;
    IER_21064 Hier;
    IRR_21064 Hirr;
    ICCSR_21064 Iccsr;
    MMCSR_21064 MmCsr;
    LARGE_INTEGER PalBase;
    LARGE_INTEGER PalTemp[ PAL_TEMPS_21064 ];
    PS_21064 Ps;
    LARGE_INTEGER Va;
} LOGOUT_FRAME_21066, *PLOGOUT_FRAME_21066;

//
// Correctable Machine-check logout frame.
//

typedef struct _CORRECTABLE_FRAME_21066{
    BCR_21066 BankConfig[ MEMORY_BANKS_21066 ];
    BMR_21066 BankMask[ MEMORY_BANKS_21066 ];
    DC_STAT_21064 DcStat;
} CORRECTABLE_FRAME_21066;

//
// Define the physical and virtual address bits
//

#define LCA_PHYSICAL_ADDRESS_BITS     34
#define LCA_VIRTUAL_ADDRESS_BITS      43

#endif //!_AXP21066_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\axp21064.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) 1993 Digital Euipment Corporation

Module Name:

    axp21064.h

Abstract:

    This module defines the DECchip 21064-specific structures that are
    defined in the PAL but must be visible to the HAL.

Revision History:

--*/

#ifndef _AXP21064_
#define _AXP21064_

//begin_axp21066

#ifndef CORE_21064
#define CORE_21064

//
// Define the "special" processor bus used by all machines that run a
// DECchip 21064.  The processor bus is used to access the internal
// performance counters.
//

#define PROCESSOR_BUS_21064 21064

//
// Define the number of entries for repeated internal processor registers.
//

#define ITB_ENTRIES_21064 12
#define DTB_ENTRIES_21064 32
#define PAL_TEMPS_21064   32

//
// Define an interrupt enable table entry.
//

typedef struct _IETEntry_21064{
    ULONG ApcEnable: 1;
    ULONG DispatchEnable: 1;
    ULONG PerformanceCounter0Enable: 1;
    ULONG PerformanceCounter1Enable: 1;
    ULONG CorrectableReadEnable: 1;
    ULONG Irq0Enable: 1;
    ULONG Irq1Enable: 1;
    ULONG Irq2Enable: 1;
    ULONG Irq3Enable: 1;
    ULONG Irq4Enable: 1;
    ULONG Irq5Enable: 1;
    ULONG Reserved: 21;
} IETEntry_21064, *PIETEntry_21064;


//
// Define the offsets and sizes of the mask sub-tables within the interrupt
// mask table in the PCR.
//

#define IRQLMASK_HDW_SUBTABLE_21064 (8)
#define IRQLMASK_HDW_SUBTABLE_21064_ENTRIES (64)

#define IRQLMASK_SFW_SUBTABLE_21064 (0)
#define IRQLMASK_SFW_SUBTABLE_21064_ENTRIES (4)

#define IRQLMASK_PC_SUBTABLE_21064  (4)
#define IRQLMASK_PC_SUBTABLE_21064_ENTRIES (4)

//
// PALcode Event Counters for the 21064
// This is the structure of the data returned by the rdcounters call pal.
//

typedef struct _COUNTERS_21064{
    LARGE_INTEGER MachineCheckCount;
    LARGE_INTEGER ArithmeticExceptionCount;
    LARGE_INTEGER InterruptCount;
    LARGE_INTEGER ItbMissCount;
    LARGE_INTEGER NativeDtbMissCount;
    LARGE_INTEGER PalDtbMissCount;
    LARGE_INTEGER ItbAcvCount;
    LARGE_INTEGER DtbAcvCount;
    LARGE_INTEGER UnalignedCount;
    LARGE_INTEGER OpcdecCount;
    LARGE_INTEGER FenCount;
    LARGE_INTEGER ItbTnvCount;
    LARGE_INTEGER DtbTnvCount;
    LARGE_INTEGER PteMissCount;
    LARGE_INTEGER KspMissCount;
    LARGE_INTEGER PdeTnvCount;
    LARGE_INTEGER HaltCount;
    LARGE_INTEGER RestartCount;
    LARGE_INTEGER DrainaCount;
    LARGE_INTEGER InitpalCount;
    LARGE_INTEGER WrentryCount;
    LARGE_INTEGER SwpirqlCount;
    LARGE_INTEGER RdirqlCount;
    LARGE_INTEGER DiCount;
    LARGE_INTEGER EiCount;
    LARGE_INTEGER SwppalCount;
    LARGE_INTEGER SsirCount;
    LARGE_INTEGER CsirCount;
    LARGE_INTEGER RfeCount;
    LARGE_INTEGER RetsysCount;
    LARGE_INTEGER SwpctxCount;
    LARGE_INTEGER SwpprocessCount;
    LARGE_INTEGER RdmcesCount;
    LARGE_INTEGER WrmcesCount;
    LARGE_INTEGER TbiaCount;
    LARGE_INTEGER TbisCount;
    LARGE_INTEGER DtbisCount;
    LARGE_INTEGER RdkspCount;
    LARGE_INTEGER SwpkspCount;
    LARGE_INTEGER RdpsrCount;
    LARGE_INTEGER RdpcrCount;
    LARGE_INTEGER RdthreadCount;
    LARGE_INTEGER RdcountersCount;
    LARGE_INTEGER RdstateCount;
    LARGE_INTEGER WrperfmonCount;
    LARGE_INTEGER InitpcrCount;
    LARGE_INTEGER BptCount;
    LARGE_INTEGER CallsysCount;
    LARGE_INTEGER ImbCount;
    LARGE_INTEGER GentrapCount;
    LARGE_INTEGER RdtebCount;
    LARGE_INTEGER KbptCount;
    LARGE_INTEGER CallkdCount;
    LARGE_INTEGER TbisasnCount;
    LARGE_INTEGER Misc1Count;
    LARGE_INTEGER Misc2Count;
    LARGE_INTEGER Misc3Count;
} COUNTERS_21064, *PCOUNTERS_21064;

typedef enum _AXP21064_PCCOUNTER{
    Ev4PerformanceCounter0 = 0,
    Ev4PerformanceCounter1 = 1
} AXP21064_PCCOUNTER, *PAXP21064_PCCOUNTER;

typedef enum _AXP21064_PCMUXCONTROL{
    Ev4TotalIssues = 0x0,
    Ev4PipelineDry = 0x2,
    Ev4LoadInstruction = 0x4,
    Ev4PipelineFrozen = 0x6,
    Ev4BranchInstructions = 0x8,
    Ev4PalMode = 0xb,
    Ev4TotalCycles = 0xa,
    Ev4TotalNonIssues = 0xc,
    Ev4ExternalCounter0 = 0xe,
    Ev4DcacheMiss = 0x0,
    Ev4IcacheMiss = 0x1,
    Ev4DualIssues = 0x2,
    Ev4BranchMispredicts = 0x3,
    Ev4FPInstructions = 0x4,
    Ev4IntegerOperate = 0x5,
    Ev4StoreInstructions = 0x6,
    Ev4ExternalCounter1 = 0x7
} AXP21064_PCMUXCONTROL, *PAXP21064_PCMUXCONTROL;

typedef enum _AXP21064_PCEVENTCOUNT{
    Ev4CountEvents2xx8 = 0x100,
    Ev4CountEvents2xx12 = 0x1000,
    Ev4CountEvents2xx16 = 0x10000
} AXP21064_PCEVENTCOUNT, *PAXP21064_PCEVENTCOUNT;

typedef enum _AXP21064_EVENTCOUNT{
    Ev4EventCountHigh = 1,
    Ev4EventCountLow = 0
} AXP21064_EVENTCOUNT, *PAXP21064_EVENTCOUNT;

//
// Internal Processor Register definitions (read format).
//

//
// Pte formats
//

typedef LARGE_INTEGER ITB_PTE_21064;
typedef ITB_PTE_21064 *PITB_PTE_21064;
typedef LARGE_INTEGER DTB_PTE_21064;
typedef DTB_PTE_21064 *PDTB_PTE_21064;

#define PTE_FOR_21064_SHIFT 3
#define PTE_FOW_21064_SHIFT 4
#define PTE_KWE_21064_SHIFT 5
#define PTE_EWE_21064_SHIFT 6
#define PTE_SWE_21064_SHIFT 7
#define PTE_UWE_21064_SHIFT 8
#define PTE_KRE_21064_SHIFT 9
#define PTE_ERE_21064_SHIFT 10
#define PTE_SRE_21064_SHIFT 11
#define PTE_URE_21064_SHIFT 12 
#define PTE_PFN_21064_SHIFT 13
#define PTE_PFN_21064_SHIFTMASK  0x1FFFF
#define PTE_ASM_21064_SHIFT 34

#define PTE_ALL_21064(itbpte) (itbpte)
#define PTE_FOR_21064(itbpte) ( (itbpte.LowPart >> PTE_FOR_21064_SHIFT) & 1)
#define PTE_FOW_21064(itbpte) ( (itbpte.LowPart >> PTE_FOW_21064_SHIFT) & 1)
#define PTE_KWE_21064(itbpte) ( (itbpte.LowPart >> PTE_KWE_21064_SHIFT) & 1)
#define PTE_EWE_21064(itbpte) ( (itbpte.LowPart >> PTE_EWE_21064_SHIFT) & 1)
#define PTE_SWE_21064(itbpte) ( (itbpte.LowPart >> PTE_SWE_21064_SHIFT) & 1)
#define PTE_UWE_21064(itbpte) ( (itbpte.LowPart >> PTE_UWE_21064_SHIFT) & 1)
#define PTE_KRE_21064(itbpte) ( (itbpte.LowPart >> PTE_KRE_21064_SHIFT) & 1)
#define PTE_ERE_21064(itbpte) ( (itbpte.LowPart >> PTE_ERE_21064_SHIFT) & 1)
#define PTE_SRE_21064(itbpte) ( (itbpte.LowPart >> PTE_SRE_21064_SHIFT) & 1)
#define PTE_URE_21064(itbpte) ( (itbpte.LowPart >> PTE_URE_21064_SHIFT) & 1)
#define PTE_ASM_21064(itbpte) ( (itbpte.LowPart >> PTE_ASM_21064_SHIFT) & 1)
#define PTE_PFN_21064(itbpte) ( (itbpte.LowPart >> PTE_PFN_21064_SHIFT) & PTE_PFN_21064_SHIFTMASK)

//
// Instruction Cache Control and Status Register format
//

typedef LARGE_INTEGER ICCSR_21064;
typedef ICCSR_21064 *PICCSR_21064;

#define ICCSR_PC0_21064_SHIFT   1
#define ICCSR_PC1_21064_SHIFT   2
#define ICCSR_PCMUX0_21064_SHIFT 9
#define ICCSR_PCMUX0_21064_SHIFTMASK 0xF
#define ICCSR_PCMUX1_21064_SHIFT 13
#define ICCSR_PCMUX1_21064_SHIFTMASK 0x7
#define ICCSR_PIPE_21064_SHIFT 16
#define ICCSR_BPE_21064_SHIFT  17
#define ICCSR_JSE_21064_SHIFT  18
#define ICCSR_BHE_21064_SHIFT  19
#define ICCSR_DI_21064_SHIFT   20
#define ICCSR_HWE_21064_SHIFT  21
#define ICCSR_MAP_21064_SHIFT  22
#define ICCSR_FPE_21064_SHIFT  23
#define ICCSR_ASN_21064_SHIFT  28
#define ICCSR_ASN_21064_SHIFTMASK 0x3F

#define ICCSR_ALL_21064(iccsr) (iccsr)
#define ICCSR_PC0_21064(iccsr) ( (iccsr.LowPart >> ICCSR_PC0_21064_SHIFT) & 1)
#define ICCSR_PC1_21064(iccsr) ( (iccsr.LowPart >> ICCSR_PC1_21064_SHIFT) & 1)
#define ICCSR_PCMUX0_21064(iccsr) \
    ( (iccsr.LowPart >> ICCSR_PCMUX0_21064_SHIFT) & ICCSR_PCMUX0_21064_SHIFTMASK)
#define ICCSR_PCMUX1_21064(iccsr) \
    ( (iccsr.LowPart >> ICCSR_PCMUX1_21064_SHIFT) & ICCSR_PCMUX1_21064_SHIFTMASK)
#define ICCSR_PIPE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_PIPE_21064_SHIFT) & 1)
#define ICCSR_BPE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_BPE_21064_SHIFT) & 1)
#define ICCSR_JSE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_JSE_21064_SHIFT) & 1)
#define ICCSR_BHE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_BHE_21064_SHIFT) & 1)
#define ICCSR_DI_21064(iccsr)  ( (iccsr.LowPart >> ICCSR_DI_21064_SHIFT) & 1)
#define ICCSR_HWE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_HWE_21064_SHIFT) & 1)
#define ICCSR_MAP_21064(iccsr) ( (iccsr.LowPart >> ICCSR_MAP_21064_SHIFT) & 1)
#define ICCSR_FPE_21064(iccsr) ( (iccsr.LowPart >> ICCSR_FPE_21064_SHIFT) & 1)
#define ICCSR_ASN_21064(iccsr) \
    (ULONG)( (iccsr.LowPart >> ICCSR_ASN_21064_SHIFT) & ICCSR_ASN_21064_SHIFTMASK)

//
// Processor Status (PS) format.
//

typedef LARGE_INTEGER PS_21064;
typedef PS_21064 *PPS_21064;

#define PS_CM0_21064_SHIFT 1
#define PS_CM1_21064_SHIFT 34

#define PS_ALL_21064(ps) (ps)
#define PS_CM_21064(ps) \
        ( (((ps).LowPart >> PS_CM0_21064_SHIFT) & 1) || \
          (((ps).LowPart >> (PS_CM1_21064_SHIFT-1)) & 1) )

//
// Exception Summary (EXC_SUM) format.
//

typedef LARGE_INTEGER EXC_SUM_21064;
typedef EXC_SUM_21064 *PEXC_SUM_21064;

#define EXCSUM_SWC_21064_SHIFT 2
#define EXCSUM_INV_21064_SHIFT 3
#define EXCSUM_DZE_21064_SHIFT 4
#define EXCSUM_FOV_21064_SHIFT 5
#define EXCSUM_UNF_21064_SHIFT 6
#define EXCSUM_INE_21064_SHIFT 7
#define EXCSUM_IOV_21064_SHIFT 8
#define EXCSUM_MSK_21064_SHIFT 33

#define EXCSUM_ALL_21064(excsum) (excsum)
#define EXCSUM_SWC_21064(excsum) ((excsum.LowPart >> EXCSUM_SWC_21064_SHIFT) & 0x1)
#define EXCSUM_INV_21064(excsum) ( (excsum.LowPart >> EXCSUM_INV_21064_SHIFT) & 0x1)
#define EXCSUM_DZE_21064(excsum) ( (excsum.LowPart >> EXCSUM_DZE_21064_SHIFT) & 0x1)
#define EXCSUM_FOV_21064(excsum) ( (excsum.LowPart >> EXCSUM_FOV_21064_SHIFT) & 0x1)
#define EXCSUM_UNF_21064(excsum) ( (excsum.LowPart >> EXCSUM_UNF_21064_SHIFT) & 0x1)
#define EXCSUM_INE_21064(excsum) ( (excsum.LowPart >> EXCSUM_INE_21064_SHIFT) & 0x1)
#define EXCSUM_IOV_21064(excsum) ( (excsum.LowPart >> EXCSUM_IOV_21064_SHIFT) & 0x1)
#define EXCSUM_MSK_21064(excsum) ( (excsum.LowPart >> EXCSUM_MSK_21064_SHIFT) & 0x1)

//
// Interrupt Request (HIRR, SIRR, ASTRR) format.
//

typedef LARGE_INTEGER IRR_21064;
typedef IRR_21064 *PIRR_21064;

#define IRR_HWR_21064_SHIFT 1
#define IRR_SWR_21064_SHIFT 2
#define IRR_ATR_21064_SHIFT 3
#define IRR_CRR_21064_SHIFT 4
#define IRR_HIRR53_21064_SHIFT 5
#define IRR_HIRR53_21064_SHIFTMASK 0x7
#define IRR_PC1_21064_SHIFT 8
#define IRR_PC0_21064_SHIFT 9
#define IRR_HIRR20_21064_SHIFT 10
#define IRR_HIRR20_21064_SHIFTMASK 0x7
#define IRR_SLR_21064_SHIFT 13
#define IRR_SIRR_21064_SHIFT 14
#define IRR_SIRR_21064_SHIFTMASK 0x7FFF
#define IRR_ASTRR_21064_SHIFT 29
#define IRR_ASTRR_21064_SHIFTMASK 0xF

#define IRR_ALL_21064(irr) (irr)
#define IRR_HWR_21064(irr) ( (irr.LowPart >> IRR_HWR_21064_SHIFT) & 0x1)
#define IRR_SWR_21064(irr) ( (irr.LowPart >> IRR_SWR_21064_SHIFT) & 0x1)
#define IRR_ATR_21064(irr) ( (irr.LowPart >> IRR_ATR_21064_SHIFT) & 0x1)
#define IRR_CRR_21064(irr) ( (irr.LowPart >> IRR_CRR_21064_SHIFT) & 0x1)
#define IRR_HIRR_21064(irr) \
    ( ((irr.LowPart >> (IRR_HIRR53_21064_SHIFT-3)) & IRR_HIRR53_21064_SHIFTMASK) || \
    ( (irr.LowPart >> IRR_HIRR20_21064_SHIFT) & IRR_HIRR20_21064_SHIFTMASK) )
#define IRR_PC1_21064(irr) ( (irr.LowPart >> IRR_PC1_21064_SHIFT) & 0x1)
#define IRR_PC0_21064(irr) ( (irr.LowPart >> IRR_PC0_21064_SHIFT) & 0x1)
#define IRR_SLR_21064(irr) ( (irr.LowPart >> IRR_SLR_21064_SHIFT) & 0x1)
#define IRR_SIRR_21064(irr) \
    ( (irr.LowPart >> IRR_SIRR_21064_SHIFT) & IRR_SIRR_21064_SHIFTMASK)
#define IRR_ASTRR_21064(irr) \
    ( (irr.LowPart >> IRR_ASTRR_21064_SHIFT) & IRR_ASTRR_21064_SHIFTMASK)

//
// Interrupt Enable (HIER, SIER, ASTER) format.
//

typedef LARGE_INTEGER IER_21064;
typedef IER_21064 *PIER_21064;

#define IER_CRR_21064_SHIFT 4
#define IER_HIER53_21064_SHIFT 5
#define IER_HIER53_21064_SHIFTMASK 0x7
#define IER_PC1_21064_SHIFT 8
#define IER_PC0_21064_SHIFT 9
#define IER_HIER20_21064_SHIFT 10
#define IER_HIER20_21064_SHIFTMASK 0x7
#define IER_SLR_21064_SHIFT 13
#define IER_SIER_21064_SHIFT 14
#define IER_SIER_21064_SHIFTMASK 0x7FFF
#define IER_ASTER_21064_SHIFT 29
#define IER_ASTER_21064_SHIFTMASK 0xF

#define IER_ALL_21064(ier) (ier)
#define IER_CRR_21064(ier) ( (ier.LowPart >> IER_CRR_21064_SHIFT) & 0x1)
#define IER_HIER_21064(ier) \
    ( ( (ier.LowPart >> (IER_HIER53_21064_SHIFT-3)) & IER_HIER53_21064_SHIFTMASK) || \
      ( (ier.LowPart >> IER_HIER20_21064_SHIFT) & IER_HIER20_21064_SHIFTMASK) )
#define IER_PC1_21064(ier) ( (ier.LowPart >> IER_PC1_21064_SHIFT) & 0x1)
#define IER_PC0_21064(ier) ( (ier.LowPart >> IER_PC0_21064_SHIFT) & 0x1)
#define IER_SLR_21064(ier) ( (ier.LowPart >> IER_SLR_21064_SHIFT) & 0x1)
#define IER_SIER_21064(ier) \
    ( (ier.LowPart >> IER_SIER_21064_SHIFT) & IER_SIER_21064_SHIFTMASK)
#define IER_ASTER_21064(ier) \
    ( (ier.LowPart >> IER_ASTER_21064_SHIFT) & IER_ASTER_21064_SHIFTMASK)

//
// Abox Control Register (ABOX_CTL) format.
//

typedef union _ABOX_CTL_21064{
    struct {
        ULONG wb_dis: 1;
        ULONG mchk_en: 1;
        ULONG crd_en: 1;
        ULONG ic_sbuf_en: 1;
        ULONG spe_1: 1;
        ULONG spe_2: 1;
        ULONG emd_en: 1;
        ULONG mbz1: 3;
        ULONG dc_ena: 1;
        ULONG dc_fhit: 1;
    } bits;
    LARGE_INTEGER all;
} ABOX_CTL_21064, *PABOX_CTL_21064;

#define ABOXCTL_ALL_21064(aboxctl) ((aboxctl).all)
#define ABOXCTL_WBDIS_21064(aboxctl) ((aboxctl).bits.wb_dis)
#define ABOXCTL_MCHKEN_21064(aboxctl) ((aboxctl).bits.mchk_en)
#define ABOXCTL_CRDEN_21064(aboxctl) ((aboxctl).bits.crd_en)
#define ABOXCTL_ICSBUFEN_21064(aboxctl) ((aboxctl).bits.ic_sbuf_en)
#define ABOXCTL_SPE1_21064(aboxctl) ((aboxctl).bits.spe_1)
#define ABOXCTL_SPE2_21064(aboxctl) ((aboxctl).bits.spe_2)
#define ABOXCTL_EMDEN_21064(aboxctl) ((aboxctl).bits.emd_en)
#define ABOXCTL_DCENA_21064(aboxctl) ((aboxctl).bits.dc_ena)
#define ABOXCTL_DCFHIT_21064(aboxctl) ((aboxctl).bits.dc_fhit)

//
// Memory Management Control and Status Register (MMCSR) format.
//

typedef union _MMCSR_21064{
    struct {
        ULONG Wr: 1;
        ULONG Acv: 1;
        ULONG For: 1;
        ULONG Fow: 1;
        ULONG Ra: 5;
        ULONG Opcode: 6;
    } bits;
    LARGE_INTEGER all;
} MMCSR_21064, *PMMCSR_21064;

#define MMCSR_ALL_21064(mmcsr) ((mmcsr).all)
#define MMCSR_WR_21064(mmcsr) ((mmcsr).bits.Wr)
#define MMCSR_ACV_21064(mmcsr) ((mmcsr).bits.Acv)
#define MMCSR_FOR_21064(mmcsr) ((mmcsr).bits.For)
#define MMCSR_FOW_21064(mmcsr) ((mmcsr).bits.Fow)
#define MMCSR_RA_21064(mmcsr) ((mmcsr).bits.Ra)
#define MMCSR_OPCODE_21064(mmcsr) ((mmcsr).bits.Opcode)

//
// Dcache Status (DC_STAT) format.
//
typedef union _DC_STAT_21064{
    struct {
        ULONG Reserved: 3;
        ULONG DcHit: 1;
        ULONG DCacheParityError: 1;
        ULONG ICacheParityError: 1;
    } bits;
    LARGE_INTEGER all;
} DC_STAT_21064, *PDC_STAT_21064;

#define DCSTAT_ALL_21064(dcstat) ((dcstat).all)
#define DCSTAT_DCHIT_21064(dcstat) ((dcstat).bits.DcHit)
#define DCSTAT_DCPARITY_ERROR_21064(dcstat) ((dcstat).bits.DCacheParityError)
#define DCSTAT_ICPARITY_ERROR_21064(dcstat) ((dcstat).bits.ICacheParityError)

#endif //!CORE_21064


//
// Bus Interface Unit Status (BIU_STAT) format.
//

typedef union _BIU_STAT_21064{
    struct {
        ULONG BiuHerr: 1;
        ULONG BiuSerr: 1;
        ULONG BcTperr: 1;
        ULONG BcTcperr: 1;
        ULONG BiuCmd: 3;
        ULONG Fatal1: 1;
        ULONG FillEcc: 1;
        ULONG Reserved: 1;
        ULONG FillDperr: 1;
        ULONG FillIrd: 1;
        ULONG FillQw: 2;
        ULONG Fatal2: 1;
    } bits;
    LARGE_INTEGER all;
} BIU_STAT_21064, *PBIU_STAT_21064;

#define BIUSTAT_ALL_21064(biustat) ((biustat).all)
#define BIUSTAT_HERR_21064(biustat) ((biustat).bits.BiuHerr)
#define BIUSTAT_SERR_21064(biustat) ((biustat).bits.BiuSerr)
#define BIUSTAT_TPERR_21064(biustat) ((biustat).bits.BcTperr)
#define BIUSTAT_TCPERR_21064(biustat) ((biustat).bits.BcTcperr)
#define BIUSTAT_CMD_21064(biustat) ((biustat).bits.BiuCmd)
#define BIUSTAT_FATAL1_21064(biustat) ((biustat).bits.Fatal1)
#define BIUSTAT_FILLECC_21064(biustat) ((biustat).bits.FillEcc)
#define BIUSTAT_FILLDPERR_21064(biustat) ((biustat).bits.FillDperr)
#define BIUSTAT_FILLIRD_21064(biustat) ((biustat).bits.FillIrd)
#define BIUSTAT_FILLQW_21064(biustat) ((biustat).bits.FillQw)
#define BIUSTAT_FATAL2_21064(biustat) ((biustat).bits.Fatal2)

//
// Fill Syndrome (FILL_SYNDROME) format.
//

typedef union _FILL_SYNDROME_21064{
    struct {
        ULONG Lo: 7;
        ULONG Hi: 7;
    } bits;
    LARGE_INTEGER all;
} FILL_SYNDROME_21064, *PFILL_SYNDROME_21064;

#define FILLSYNDROME_ALL_21064(fs) ((fs).all)
#define FILLSYNDROME_LO_21064(fs) ((fs).bits.Lo)
#define FILLSYNDROME_HI_21064(fs) ((fs).bits.Hi)

//
// Backup Cache Tag (BC_TAG) format.
//

typedef union _BC_TAG_21064{
    struct {
        ULONG Hit: 1;
        ULONG TagctlP: 1;
        ULONG TagctlD: 1;
        ULONG TagctlS: 1;
        ULONG TagctlV: 1;
        ULONG Tag: 17;
        ULONG TagP: 1;
    } bits;
    LARGE_INTEGER all;
} BC_TAG_21064, *PBC_TAG_21064;

#define BCTAG_ALL_21064(bctag) ((bctag).all)
#define BCTAG_HIT_21064(bctag) ((bctag).bits.Hit)
#define BCTAG_TAGCTLP_21064(bctag) ((bctag).bits.TagctlP)
#define BCTAG_TAGCTLD_21064(bctag) ((bctag).bits.TagctlD)
#define BCTAG_TAGCTLS_21064(bctag) ((bctag).bits.TagctlS)
#define BCTAG_TAGCTLV_21064(bctag) ((bctag).bits.TagctlV)
#define BCTAG_TAG_21064(bctag) ((bctag).bits.Tag)
#define BCTAG_TAGP_21064(bctag) ((bctag).bits.TagP)

//
// Bus Interface Unit Control Register (BIU_CTL) format.
//

typedef LARGE_INTEGER BIU_CTL_21064;
typedef BIU_CTL_21064 *PBIU_CTL_21064;

#define BIUCTL_BCENA_21064_SHIFT 0
#define BIUCTL_ECC_21064_SHIFT 1
#define BIUCTL_OE_21064_SHIFT 2
#define BIUCTL_BCFHIT_21064_SHIFT 3
#define BIUCTL_BCRDSPD_21064_SHIFT 4
#define BIUCTL_BCRDSPD_21064_SHIFTMASK 0xF
#define BIUCTL_BCWRSPD_21064_SHIFT 8
#define BIUCTL_BCWRSPD_21064_SHIFTMASK 0xF
#define BIUCTL_BCWECTL_21064_SHIFT 12
#define BIUCTL_BCWECTL_21064_SHIFTMASK 0xFFFF
#define BIUCTL_BCSIZE_21064_SHIFT 28
#define BIUCTL_BCSIZE_21064_SHIFTMASK 0x7
#define BIUCTL_BADTCP_21064_SHIFT 31
#define BIUCTL_BCPADIS_21064_SHIFT 32
#define BIUCTL_BCPADIS_21064_SHIFTMASK 0xF
#define BIUCTL_BADDP_21064_SHIFT 36

#define BIUCTL_ALL_21064(biuctl) (biuctl)
#define BIUCTL_BCENA_21064(biuctl) ( (biuctl.LowPart >> BIUCTL_BCENA_21064_SHIFT) & 1)
#define BIUCTL_ECC_21064(biuctl) ( (biuctl.LowPart >> BIUCTL_ECC_21064_SHIFT) & 1)
#define BIUCTL_OE_21064(biuctl) ( (biuctl.LowPart >> BIUCTL_OE_21064_SHIFT) & 1)
#define BIUCTL_BCFHIT_21064(biuctl) ( (biuctl.LowPart >> BIUCTL_BCFHIT_21064_SHIFT) & 1)
#define BIUCTL_BCRDSPD_21064(biuctl) \
    ( (biuctl.LowPart >> BIUCTL_BCRDSPD_21064_SHIFT) & BIUCTL_BCRDSPD_21064_SHIFTMASK)
#define BIUCTL_BCWRSPD_21064(biuctl) \
    ( (biuctl.LowPart >> BIUCTL_BCWRSPD_21064_SHIFT) & BIUCTL_BCWRSPD_21064_SHIFTMASK)
#define BIUCTL_BCWECTL_21064(biuctl) \
    ( (biuctl.LowPart >> BIUCTL_BCWECTL_21064_SHIFT) & BIUCTL_BCWECTL_21064_SHIFTMASK)
#define BIUCTL_BCSIZE_21064(biuctl) \
    ( (biuctl.LowPart >> BIUCTL_BCSIZE_21064_SHIFT) & BIUCTL_BCSIZE_21064_SHIFTMASK)
#define BIUCTL_BADTCP_21064(biuctl) \
    ( (biuctl.LowPart >> BIUCTL_BADTCP_21064_SHIFT) & 1)
#define BIUCTL_BCPADIS_21064(biuctl) \
    ( (biuctl.LowPart >> BIUCTL_BCPADIS_21064_SHIFT) & BIUCTL_BCPADIS_21064_SHIFTMASK)
#define BIUCTL_BADDP_21064(biuctl) \
    ( (biuctl.LowPart >> BIUCTL_BADDP_21064_SHIFT) & 1)

//
// Internal Processor State record.
// This is the structure of the data returned by the rdstate call pal.
//

typedef struct _PROCESSOR_STATE_21064{
    ITB_PTE_21064 ItbPte[ ITB_ENTRIES_21064 ];
    ICCSR_21064 Iccsr;
    PS_21064 Ps;
    EXC_SUM_21064 ExcSum;
    LARGE_INTEGER PalBase;
    IRR_21064 Hirr;
    IRR_21064 Sirr;
    IRR_21064 Astrr;
    IER_21064 Hier;
    IER_21064 Sier;
    IER_21064 Aster;
    ABOX_CTL_21064 AboxCtl;
    DTB_PTE_21064 DtbPte[ DTB_ENTRIES_21064 ];
    MMCSR_21064 MmCsr;
    LARGE_INTEGER Va;
    LARGE_INTEGER PalTemp[ PAL_TEMPS_21064 ];
    BIU_CTL_21064 BiuCtl;
    DC_STAT_21064 DcStat;
    BIU_STAT_21064 BiuStat;
    LARGE_INTEGER BiuAddr;
    LARGE_INTEGER FillAddr;
    FILL_SYNDROME_21064 FillSyndrome;
} PROCESSOR_STATE_21064, *PPROCESSOR_STATE_21064;


//
// Machine-check logout frame.
//

typedef struct _LOGOUT_FRAME_21064{
    BIU_STAT_21064 BiuStat;
    LARGE_INTEGER BiuAddr;
    BC_TAG_21064 BcTag;
    LARGE_INTEGER ExcAddr;
    LARGE_INTEGER FillAddr;
    FILL_SYNDROME_21064 FillSyndrome;
    DC_STAT_21064 DcStat;
    ICCSR_21064 Iccsr;
    PS_21064 Ps;
    EXC_SUM_21064 ExcSum;
    LARGE_INTEGER PalBase;
    IRR_21064 Hirr;
    IER_21064 Hier;
    ABOX_CTL_21064 AboxCtl;
    BIU_CTL_21064 BiuCtl;
    MMCSR_21064 MmCsr;
    LARGE_INTEGER Va;
    LARGE_INTEGER PalTemp[ PAL_TEMPS_21064 ];
} LOGOUT_FRAME_21064, *PLOGOUT_FRAME_21064;

//
// Correctable Machine-check logout frame.
//

typedef struct _CORRECTABLE_FRAME_21064{
    BIU_STAT_21064 BiuStat;
    LARGE_INTEGER BiuAddr;
    BC_TAG_21064 BcTag;
    LARGE_INTEGER FillAddr;
    FILL_SYNDROME_21064 FillSyndrome;
    DC_STAT_21064 DcStat;
} CORRECTABLE_FRAME_21064;

//
// Define the physical and virtual address bits
//

#define EV4_PHYSICAL_ADDRESS_BITS     34
#define EV4_VIRTUAL_ADDRESS_BITS      43

#endif //!_AXP21064_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\arbiter.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    arbiter.h

Abstract:

    This module contains support routines for the Pnp resource arbiters.

Author:

    Andrew Thornton (andrewth) 1-April-1997


Environment:

    Kernel mode

--*/

#ifndef _ARBITER_
#define _ARBITER_

#if !defined(MAXULONGLONG)
#define MAXULONGLONG ((ULONGLONG)-1)
#endif


#if ARB_DBG

//
// Debug print level:
//    -1 = no messages
//     0 = vital messages only
//     1 = call trace
//     2 = verbose messages
//

extern LONG ArbDebugLevel;

#define ARB_PRINT(Level, Message) \
    if (Level <= ArbDebugLevel) DbgPrint Message

#define ARB_INDENT(Level, Count) \
    if (Level < ArbDebugLevel) ArbpIndent(Count)

#else

#define ARB_PRINT(Level, Message)
#define ARB_INDENT(Level, Count)

#endif // ARB_DBG


//
// The ARBITER_ORDRING_LIST abstract data type
//

typedef struct _ARBITER_ORDERING {
    ULONGLONG Start;
    ULONGLONG End;
} ARBITER_ORDERING, *PARBITER_ORDERING;


typedef struct _ARBITER_ORDERING_LIST {

    //
    // The number of valid entries in the array
    //
    USHORT Count;

    //
    // The maximum number of entries that can fit in the Ordering buffer
    //
    USHORT Maximum;

    //
    // Array of orderings
    //
    PARBITER_ORDERING Orderings;

} ARBITER_ORDERING_LIST, *PARBITER_ORDERING_LIST;


NTSTATUS
ArbInitializeOrderingList(
    IN OUT PARBITER_ORDERING_LIST List
    );

VOID
ArbFreeOrderingList(
    IN OUT PARBITER_ORDERING_LIST List
    );

NTSTATUS
ArbCopyOrderingList(
    OUT PARBITER_ORDERING_LIST Destination,
    IN PARBITER_ORDERING_LIST Source
    );

NTSTATUS
ArbAddOrdering(
    OUT PARBITER_ORDERING_LIST List,
    IN ULONGLONG Start,
    IN ULONGLONG End
    );

NTSTATUS
ArbPruneOrdering(
    IN OUT PARBITER_ORDERING_LIST OrderingList,
    IN ULONGLONG Start,
    IN ULONGLONG End
    );

//
// ULONGLONG
// ALIGN_ADDRESS_DOWN(
//    ULONGLONG address,
//    ULONG alignment
//    );
//
// This aligns address to the previously correctly aligned value
//
#define ALIGN_ADDRESS_DOWN(address, alignment) \
    ((address) & ~((ULONGLONG)alignment - 1))

//
// ULONGLONG
// ALIGN_ADDRESS_UP(
//    ULONGLONG address,
//    ULONG alignment
//    );
//
// This aligns address to the next correctly aligned value
//
#define ALIGN_ADDRESS_UP(address, alignment) \
    (ALIGN_ADDRESS_DOWN( (address + alignment - 1), alignment))


#define LENGTH_OF(_start, _end) \
    ((_end) - (_start) + 1)

//
// This indicates that the alternative can coexist with shared resources and
// should be added to the range lists shared
//
#define ARBITER_ALTERNATIVE_FLAG_SHARED         0x00000001

//
// This indicates that the request if for a specific range with no alternatives.
// ie (End - Start + 1 == Length) eg port 60-60 L1 A1
//
#define ARBITER_ALTERNATIVE_FLAG_FIXED          0x00000002

//
// This indicates that request is invalid
//
#define ARBITER_ALTERNATIVE_FLAG_INVALID        0x00000004

typedef struct _ARBITER_ALTERNATIVE {

    //
    // The minimum acceptable start value from the requirement descriptor
    //
    ULONGLONG Minimum;

    //
    // The maximum acceptable end value from the requirement descriptor
    //
    ULONGLONG Maximum;

    //
    // The length from the requirement descriptor
    //
    ULONG Length;

    //
    // The alignment from the requirement descriptor
    //
    ULONG Alignment;

    //
    // Priority index - see comments below
    //

    LONG Priority;

    //
    // Flags - ARBITER_ALTERNATIVE_FLAG_SHARED - indicates the current
    //             requirement was for a shared resource.
    //         ARBITER_ALTERNATIVE_FLAG_FIXED - indicates the current
    //             requirement is for a specific resource (eg ports 220-230 and
    //             nothing else)
    //
    ULONG Flags;

    //
    // Descriptor - the descriptor describing this alternative
    //
    PIO_RESOURCE_DESCRIPTOR Descriptor;

    //
    // Packing...
    //
    ULONG Reserved[3];

} ARBITER_ALTERNATIVE, *PARBITER_ALTERNATIVE;


/*
    The priorities are a LONG values organised as:

    <------Preferred priorities-----> <-----Ordinary Priorities----->

    MINLONG--------------------------0-----------------------------MAXLONG
                                     ^                               ^ ^ ^
                                     |                               | | |
                                    NULL            PREFERRED_RESERVED | |
                                                                RESERVED |
                                                                     EXHAUSTED

    An ordinary priority is calculated the (index + 1) of the next ordering it
    intersects with (and has enough space for an allocation).

    A preferred priority is the ordinary priority * - 1

    In this way by examining each of the alternatives in priority order (lowest
    first) we achieve the desired allocation order of:

    (1) Preferred alternative with non-reserved resources
    (2) Alternatives with non-reserved resources
    (3) Preferred reserved resources
    (4) Reserved Resources

    MAXLONG the worst priority indicates that there are no more allocation range
    left.
*/

//
// The least significant 16 bits are reserved for the base arbitration code
// the most significant are arbiter specific
//

#define ARBITER_STATE_FLAG_RETEST           0x0001
#define ARBITER_STATE_FLAG_BOOT             0x0002
#define ARBITER_STATE_FLAG_CONFLICT         0x0004
#define ARBITER_STATE_FLAG_NULL_CONFLICT_OK 0x0008

typedef struct _ARBITER_ALLOCATION_STATE {

    //
    // The current value being considered as a possible start value
    //
    ULONGLONG Start;

    //
    // The current value being considered as a possible end value
    //
    ULONGLONG End;

    //
    // The values currently being considered as the Minimum and Maximum (this is
    // different because the prefered orderings can restrict the ranges where
    // we can allocate)
    //
    ULONGLONG CurrentMinimum;
    ULONGLONG CurrentMaximum;

    //
    // The entry in the arbitration list containing this request.
    //
    PARBITER_LIST_ENTRY Entry;

    //
    // The alternative currently being considered
    //
    PARBITER_ALTERNATIVE CurrentAlternative;

    //
    // The number of alternatives in the Alternatives array
    //
    ULONG AlternativeCount;

    //
    // The arbiters representation of the alternatives being considered
    //
    PARBITER_ALTERNATIVE Alternatives;

    //
    // Flags - ARBITER_STATE_FLAG_RETEST - indicates that we are in a retest
    //              operation not a test.
    //         ARBITER_STATE_FLAG_BOOT - indicates we are in a boot allocation
    //              operation not a test.
    //
    USHORT Flags;

    //
    // RangeAttributes - these are logically ORed in to the attributes for all
    // ranges added to the range list.
    //
    UCHAR RangeAttributes;

    //
    // Ranges that are to be considered available
    //
    UCHAR RangeAvailableAttributes;

    //
    // Space for the arbiter to use as it wishes
    //
    ULONG_PTR WorkSpace;

} ARBITER_ALLOCATION_STATE, *PARBITER_ALLOCATION_STATE;

typedef struct _ARBITER_INSTANCE ARBITER_INSTANCE, *PARBITER_INSTANCE;

typedef
NTSTATUS
(*PARBITER_UNPACK_REQUIREMENT) (
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

typedef
NTSTATUS
(*PARBITER_PACK_RESOURCE) (
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

typedef
NTSTATUS
(*PARBITER_UNPACK_RESOURCE) (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

typedef
LONG
(*PARBITER_SCORE_REQUIREMENT) (
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

typedef
NTSTATUS
(*PARBITER_PREPROCESS_ENTRY)(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE Entry
    );

typedef
NTSTATUS
(*PARBITER_ALLOCATE_ENTRY)(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE Entry
    );

typedef
NTSTATUS
(*PARBITER_TEST_ALLOCATION)(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

typedef
NTSTATUS
(*PARBITER_COMMIT_ALLOCATION)(
    IN PARBITER_INSTANCE Arbiter
    );

typedef
NTSTATUS
(*PARBITER_ROLLBACK_ALLOCATION)(
    IN PARBITER_INSTANCE Arbiter
    );

typedef
NTSTATUS
(*PARBITER_RETEST_ALLOCATION)(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

typedef
NTSTATUS
(*PARBITER_BOOT_ALLOCATION)(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

typedef
NTSTATUS
(*PARBITER_ADD_RESERVED)(
    IN PARBITER_INSTANCE Arbiter,
    IN PIO_RESOURCE_DESCRIPTOR Requirement      OPTIONAL,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource OPTIONAL
    );

typedef
BOOLEAN
(*PARBITER_GET_NEXT_ALLOCATION_RANGE)(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

typedef
BOOLEAN
(*PARBITER_FIND_SUITABLE_RANGE)(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

typedef
VOID
(*PARBITER_ADD_ALLOCATION)(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

typedef
VOID
(*PARBITER_BACKTRACK_ALLOCATION)(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

typedef
BOOLEAN
(*PARBITER_OVERRIDE_CONFLICT)(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

typedef
NTSTATUS
(*PARBITER_QUERY_ARBITRATE)(
    IN PARBITER_INSTANCE Arbiter,
    IN PLIST_ENTRY ArbitrationList
    );

typedef
NTSTATUS
(*PARBITER_QUERY_CONFLICT)(
    IN PARBITER_INSTANCE Arbiter,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PIO_RESOURCE_DESCRIPTOR ConflictingResource,
    OUT PULONG ConflictCount,
    OUT PARBITER_CONFLICT_INFO *Conflicts
    );

typedef
NTSTATUS
(*PARBITER_START_ARBITER)(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    );

//
// Attributes for the ranges
//

#define ARBITER_RANGE_BOOT_ALLOCATED            0x01
#define ARBITER_RANGE_SHARE_DRIVER_EXCLUSIVE    0x02

#define ARBITER_RANGE_ALIAS             0x10
#define ARBITER_RANGE_POSITIVE_DECODE   0x20

#define INITIAL_ALLOCATION_STATE_SIZE   PAGE_SIZE

#define ARBITER_INSTANCE_SIGNATURE      'sbrA'


typedef struct _ARBITER_INSTANCE {
    //
    // Signature - must be ARBITER_INSTANCE_SIGNATURE
    //
    ULONG Signature;

    //
    // Synchronisation lock
    //
    PKEVENT MutexEvent;

    //
    // The name of this arbiter - used for debugging and registry storage
    //
    PWSTR Name;

    //
    // The resource type this arbiter arbitrates.
    //
    CM_RESOURCE_TYPE ResourceType;

    //
    // Pointer to a pool allocated range list which contains the current
    // allocation
    //
    PRTL_RANGE_LIST Allocation;

    //
    // Pointer to a pool allocated range list which contains the allocation
    // under considetation.  This is set by test allocation.
    //
    PRTL_RANGE_LIST PossibleAllocation;

    //
    // The order in which these resources should be allocated.  Taken from the
    // HKLM\System\CurrentControlSet\Control\SystemResources\AssignmentOrdering
    // key and modified based on the reserved resources.
    //
    ARBITER_ORDERING_LIST OrderingList;

    //
    // The resources that should be reserved (not allocated until absolutley
    // necessary)
    //
    ARBITER_ORDERING_LIST ReservedList;

    //
    // The reference count of the number of entities that are using the
    // ARBITER_INTERFACE associated with this instance.
    //
    LONG ReferenceCount;

    //
    // The ARBITER_INTERFACE associated with this instance.
    //
    PARBITER_INTERFACE Interface;

    //
    // The size in bytes of the currently allocated AllocationStack
    //
    ULONG AllocationStackMaxSize;

    //
    // A pointer to an array of ARBITER_ALLOCATION_STATE entries encapsulating
    // the state of the current arbitration
    //
    PARBITER_ALLOCATION_STATE AllocationStack;


    //
    // Required helper function dispatches - these functions must always be
    // provided
    //

    PARBITER_UNPACK_REQUIREMENT UnpackRequirement;
    PARBITER_PACK_RESOURCE PackResource;
    PARBITER_UNPACK_RESOURCE UnpackResource;
    PARBITER_SCORE_REQUIREMENT ScoreRequirement;


    //
    // Main arbiter action dispatches
    //
    PARBITER_TEST_ALLOCATION TestAllocation;                    OPTIONAL
    PARBITER_RETEST_ALLOCATION RetestAllocation;                OPTIONAL
    PARBITER_COMMIT_ALLOCATION CommitAllocation;                OPTIONAL
    PARBITER_ROLLBACK_ALLOCATION RollbackAllocation;            OPTIONAL
    PARBITER_BOOT_ALLOCATION BootAllocation;                    OPTIONAL
    PARBITER_QUERY_ARBITRATE QueryArbitrate;                    OPTIONAL
    PARBITER_QUERY_CONFLICT QueryConflict;                      OPTIONAL
    PARBITER_ADD_RESERVED AddReserved;                          OPTIONAL
    PARBITER_START_ARBITER StartArbiter;                        OPTIONAL
    //
    // Optional helper functions
    //
    PARBITER_PREPROCESS_ENTRY PreprocessEntry;                  OPTIONAL
    PARBITER_ALLOCATE_ENTRY AllocateEntry;                      OPTIONAL
    PARBITER_GET_NEXT_ALLOCATION_RANGE GetNextAllocationRange;  OPTIONAL
    PARBITER_FIND_SUITABLE_RANGE FindSuitableRange;             OPTIONAL
    PARBITER_ADD_ALLOCATION AddAllocation;                      OPTIONAL
    PARBITER_BACKTRACK_ALLOCATION BacktrackAllocation;          OPTIONAL
    PARBITER_OVERRIDE_CONFLICT OverrideConflict;                OPTIONAL

    //
    // Debugging support
    //
    BOOLEAN TransactionInProgress;

    //
    // Arbiter specific extension - can be used to store extra arbiter specific
    // information
    //
    PVOID Extension;

    //
    // The bus device we arbitrate for
    //
    PDEVICE_OBJECT BusDeviceObject;

    //
    // Callback and context for RtlFindRange/RtlIsRangeAvailable to allow
    // complex conflicts
    //
    PVOID ConflictCallbackContext;
    PRTL_CONFLICT_RANGE_CALLBACK ConflictCallback;

} ARBITER_INSTANCE, *PARBITER_INSTANCE;


//
// Lock primitives that leave us at PASSIVE_LEVEL after acquiring the lock.
// (A FAST_MUTEX or CriticalRegion leave us at APC level and some people (ACPI)
// need to be at passive level in their arbiter)
//

#define ArbAcquireArbiterLock(_Arbiter) \
    KeWaitForSingleObject( (_Arbiter)->MutexEvent, Executive, KernelMode, FALSE, NULL )

#define ArbReleaseArbiterLock(_Arbiter) \
    KeSetEvent( (_Arbiter)->MutexEvent, 0, FALSE )

//
// Iteration macros
//

//
// Control macro (used like a for loop) which iterates over all entries in
// a standard doubly linked list.  Head is the list head and the entries are of
// type Type.  A member called ListEntry is assumed to be the LIST_ENTRY
// structure linking the entries together.  Current contains a pointer to each
// entry in turn.
//
#define FOR_ALL_IN_LIST(Type, Head, Current)                            \
    for((Current) = CONTAINING_RECORD((Head)->Flink, Type, ListEntry);  \
       (Head) != &(Current)->ListEntry;                                 \
       (Current) = CONTAINING_RECORD((Current)->ListEntry.Flink,        \
                                     Type,                              \
                                     ListEntry)                         \
       )
//
// Similar to the above only iteration is over an array of length _Size.
//
#define FOR_ALL_IN_ARRAY(_Array, _Size, _Current)                       \
    for ( (_Current) = (_Array);                                        \
          (_Current) < (_Array) + (_Size);                              \
          (_Current)++ )

//
// As above only iteration begins with the entry _Current
//
#define FOR_REST_IN_ARRAY(_Array, _Size, _Current)                      \
    for ( ;                                                             \
          (_Current) < (_Array) + (_Size);                              \
          (_Current)++ )

//
// BOOLEAN
// INTERSECT(
//      ULONGLONG s1,
//      ULONGLONG e1,
//      ULONGLONG s2,
//      ULONGLONG e2
//  );
//
// Determines if the ranges s1-e1 and s2-e2 intersect
//
#define INTERSECT(s1,e1,s2,e2)                                          \
    !( ((s1) < (s2) && (e1) < (s2))                                     \
    ||((s2) < (s1) && (e2) < (s1)) )


//
// ULONGLONG
// INTERSECT_SIZE(
//      ULONGLONG s1,
//      ULONGLONG e1,
//      ULONGLONG s2,
//      ULONGLONG e2
//  );
//
// Returns the size of the intersection of s1-e1 and s2-e2, undefined if they
// don't intersect
//
#define INTERSECT_SIZE(s1,e1,s2,e2)                                     \
    ( __min((e1),(e2)) - __max((s1),(s2)) + 1)


#define LEGACY_REQUEST(_Entry)                                                \
    ((_Entry)->RequestSource == ArbiterRequestLegacyReported ||               \
        (_Entry)->RequestSource == ArbiterRequestLegacyAssigned)

#define PNP_REQUEST(_Entry)                                                   \
    ((_Entry)->RequestSource == ArbiterRequestPnpDetected ||                  \
        (_Entry)->RequestSource == ArbiterRequestPnpEnumerated)

//
// Priorities used in ArbGetNextAllocationRange
//

#define ARBITER_PRIORITY_NULL                 0
#define ARBITER_PRIORITY_PREFERRED_RESERVED   (MAXLONG-2)
#define ARBITER_PRIORITY_RESERVED             (MAXLONG-1)
#define ARBITER_PRIORITY_EXHAUSTED            (MAXLONG)


typedef
NTSTATUS
(*PARBITER_TRANSLATE_ALLOCATION_ORDER)(
    OUT PIO_RESOURCE_DESCRIPTOR TranslatedDescriptor,
    IN PIO_RESOURCE_DESCRIPTOR RawDescriptor
    );

//
// Common arbiter routines
//

NTSTATUS
ArbInitializeArbiterInstance(
    OUT PARBITER_INSTANCE Arbiter,
    IN PDEVICE_OBJECT BusDevice,
    IN CM_RESOURCE_TYPE ResourceType,
    IN PWSTR Name,
    IN PWSTR OrderingName,
    IN PARBITER_TRANSLATE_ALLOCATION_ORDER TranslateOrdering
    );

VOID
ArbDeleteArbiterInstance(
    IN PARBITER_INSTANCE Arbiter
    );

NTSTATUS
ArbArbiterHandler(
    IN PVOID Context,
    IN ARBITER_ACTION Action,
    IN OUT PARBITER_PARAMETERS Params
    );

NTSTATUS
ArbTestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
ArbRetestAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
ArbCommitAllocation(
    PARBITER_INSTANCE Arbiter
    );

NTSTATUS
ArbRollbackAllocation(
    PARBITER_INSTANCE Arbiter
    );

NTSTATUS
ArbAddReserved(
    IN PARBITER_INSTANCE Arbiter,
    IN PIO_RESOURCE_DESCRIPTOR Requirement      OPTIONAL,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Resource OPTIONAL
    );

NTSTATUS
ArbPreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
ArbAllocateEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

NTSTATUS
ArbSortArbitrationList(
    IN OUT PLIST_ENTRY ArbitrationList
    );

VOID
ArbConfirmAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

BOOLEAN
ArbOverrideConflict(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );


NTSTATUS
ArbQueryConflict(
     IN PARBITER_INSTANCE Arbiter,
     IN PDEVICE_OBJECT PhysicalDeviceObject,
     IN PIO_RESOURCE_DESCRIPTOR ConflictingResource,
     OUT PULONG ConflictCount,
     OUT PARBITER_CONFLICT_INFO *Conflicts
     );

VOID
ArbBacktrackAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

BOOLEAN
ArbGetNextAllocationRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
ArbFindSuitableRange(
    PARBITER_INSTANCE Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

VOID
ArbAddAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

NTSTATUS
ArbBootAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
ArbStartArbiter(
    IN PARBITER_INSTANCE Arbiter,
    IN PCM_RESOURCE_LIST StartResources
    );

NTSTATUS
ArbBuildAssignmentOrdering(
    IN OUT PARBITER_INSTANCE Arbiter,
    IN PWSTR AllocationOrderName,
    IN PWSTR ReservedResourcesName,
    IN PARBITER_TRANSLATE_ALLOCATION_ORDER Translate OPTIONAL
    );


#if ARB_DBG

VOID
ArbpIndent(
    ULONG Count
    );

#endif // DBG


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\cache.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Cache.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the cache management system.

Author:


Revision History:

--*/

#ifndef _CACHE_
#define _CACHE_

#include "prefetch.h"
#include "perf.h"

//  begin_ntifs
//
//  Define two constants describing the view size (and alignment)
//  that the Cache Manager uses to map files.
//

#define VACB_MAPPING_GRANULARITY         (0x40000)
#define VACB_OFFSET_SHIFT                (18)

//
// Public portion of BCB
//

typedef struct _PUBLIC_BCB {

    //
    // Type and size of this record
    //
    // NOTE: The first four fields must be the same as the BCB in cc.h.
    //

    CSHORT NodeTypeCode;
    CSHORT NodeByteSize;

    //
    // Description of range of file which is currently mapped.
    //

    ULONG MappedLength;
    LARGE_INTEGER MappedFileOffset;
} PUBLIC_BCB, *PPUBLIC_BCB;

//
//  File Sizes structure.
//

typedef struct _CC_FILE_SIZES {

    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER FileSize;
    LARGE_INTEGER ValidDataLength;

} CC_FILE_SIZES, *PCC_FILE_SIZES;

//
// Define a Cache Manager callback structure.  These routines are required
// by the Lazy Writer, so that it can acquire resources in the right order
// to avoid deadlocks.  Note that otherwise you would have most FS requests
// acquiring FS resources first and caching structures second, while the
// Lazy Writer needs to acquire its own resources first, and then FS
// structures later as it calls the file system.
//

//
// First define the procedure pointer typedefs
//

//
// This routine is called by the Lazy Writer prior to doing a write,
// since this will require some file system resources associated with
// this cached file. The context parameter supplied is whatever the FS
// passed as the LazyWriteContext parameter when is called
// CcInitializeCacheMap.
//

typedef
BOOLEAN (*PACQUIRE_FOR_LAZY_WRITE) (
             IN PVOID Context,
             IN BOOLEAN Wait
             );

//
// This routine releases the Context acquired above.
//

typedef
VOID (*PRELEASE_FROM_LAZY_WRITE) (
             IN PVOID Context
             );

//
// This routine is called by the Lazy Writer prior to doing a readahead.
//

typedef
BOOLEAN (*PACQUIRE_FOR_READ_AHEAD) (
             IN PVOID Context,
             IN BOOLEAN Wait
             );

//
// This routine releases the Context acquired above.
//

typedef
VOID (*PRELEASE_FROM_READ_AHEAD) (
             IN PVOID Context
             );

typedef struct _CACHE_MANAGER_CALLBACKS {

    PACQUIRE_FOR_LAZY_WRITE AcquireForLazyWrite;
    PRELEASE_FROM_LAZY_WRITE ReleaseFromLazyWrite;
    PACQUIRE_FOR_READ_AHEAD AcquireForReadAhead;
    PRELEASE_FROM_READ_AHEAD ReleaseFromReadAhead;

} CACHE_MANAGER_CALLBACKS, *PCACHE_MANAGER_CALLBACKS;

//
//  This structure is passed into CcUninitializeCacheMap
//  if the caller wants to know when the cache map is deleted.
//

typedef struct _CACHE_UNINITIALIZE_EVENT {
    struct _CACHE_UNINITIALIZE_EVENT *Next;
    KEVENT Event;
} CACHE_UNINITIALIZE_EVENT, *PCACHE_UNINITIALIZE_EVENT;

//
// Callback routine for retrieving dirty pages from Cache Manager.
//

typedef
VOID (*PDIRTY_PAGE_ROUTINE) (
            IN PFILE_OBJECT FileObject,
            IN PLARGE_INTEGER FileOffset,
            IN ULONG Length,
            IN PLARGE_INTEGER OldestLsn,
            IN PLARGE_INTEGER NewestLsn,
            IN PVOID Context1,
            IN PVOID Context2
            );

//
// Callback routine for doing log file flushes to Lsn.
//

typedef
VOID (*PFLUSH_TO_LSN) (
            IN PVOID LogHandle,
            IN LARGE_INTEGER Lsn
            );

//
// Macro to test whether a file is cached or not.
//

#define CcIsFileCached(FO) (                                                         \
    ((FO)->SectionObjectPointer != NULL) &&                                          \
    (((PSECTION_OBJECT_POINTERS)(FO)->SectionObjectPointer)->SharedCacheMap != NULL) \
)

// end_ntifs
//
// Throw away miss counter
//

extern ULONG CcThrowAway;

//
// Performance Counters
//

extern ULONG CcFastReadNoWait;
extern ULONG CcFastReadWait;
extern ULONG CcFastReadResourceMiss;
extern ULONG CcFastReadNotPossible;

extern ULONG CcFastMdlReadNoWait;
extern ULONG CcFastMdlReadWait;             // ntifs
extern ULONG CcFastMdlReadResourceMiss;
extern ULONG CcFastMdlReadNotPossible;

extern ULONG CcMapDataNoWait;
extern ULONG CcMapDataWait;
extern ULONG CcMapDataNoWaitMiss;
extern ULONG CcMapDataWaitMiss;

extern ULONG CcPinMappedDataCount;

extern ULONG CcPinReadNoWait;
extern ULONG CcPinReadWait;
extern ULONG CcPinReadNoWaitMiss;
extern ULONG CcPinReadWaitMiss;

extern ULONG CcCopyReadNoWait;
extern ULONG CcCopyReadWait;
extern ULONG CcCopyReadNoWaitMiss;
extern ULONG CcCopyReadWaitMiss;

extern ULONG CcMdlReadNoWait;
extern ULONG CcMdlReadWait;
extern ULONG CcMdlReadNoWaitMiss;
extern ULONG CcMdlReadWaitMiss;

extern ULONG CcReadAheadIos;

extern ULONG CcLazyWriteIos;
extern ULONG CcLazyWritePages;
extern ULONG CcDataFlushes;
extern ULONG CcDataPages;

extern ULONG CcLostDelayedWrites;

extern PULONG CcMissCounter;

//
// Global Maintenance routines
//

NTKERNELAPI
BOOLEAN
CcInitializeCacheManager (
    VOID
    );

LOGICAL
CcHasInactiveViews (
    VOID
    );

LOGICAL
CcUnmapInactiveViews (
    IN ULONG NumberOfViewsToUnmap
    );

// begin_ntifs
//
// The following routines are intended for use by File Systems Only.
//

NTKERNELAPI
VOID
CcInitializeCacheMap (
    IN PFILE_OBJECT FileObject,
    IN PCC_FILE_SIZES FileSizes,
    IN BOOLEAN PinAccess,
    IN PCACHE_MANAGER_CALLBACKS Callbacks,
    IN PVOID LazyWriteContext
    );

NTKERNELAPI
BOOLEAN
CcUninitializeCacheMap (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER TruncateSize OPTIONAL,
    IN PCACHE_UNINITIALIZE_EVENT UninitializeCompleteEvent OPTIONAL
    );

NTKERNELAPI
VOID
CcSetFileSizes (
    IN PFILE_OBJECT FileObject,
    IN PCC_FILE_SIZES FileSizes
    );

//
//  VOID
//  CcFastIoSetFileSizes (
//      IN PFILE_OBJECT FileObject,
//      IN PCC_FILE_SIZES FileSizes
//      );
//

#define CcGetFileSizePointer(FO) (                                     \
    ((PLARGE_INTEGER)((FO)->SectionObjectPointer->SharedCacheMap) + 1) \
)

NTKERNELAPI
BOOLEAN
CcPurgeCacheSection (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length,
    IN BOOLEAN UninitializeCacheMaps
    );

NTKERNELAPI
VOID
CcSetDirtyPageThreshold (
    IN PFILE_OBJECT FileObject,
    IN ULONG DirtyPageThreshold
    );

NTKERNELAPI
VOID
CcFlushCache (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length,
    OUT PIO_STATUS_BLOCK IoStatus OPTIONAL
    );

NTKERNELAPI
LARGE_INTEGER
CcGetFlushedValidData (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer,
    IN BOOLEAN BcbListHeld
    );

// end_ntifs
NTKERNELAPI
VOID
CcZeroEndOfLastPage (
    IN PFILE_OBJECT FileObject
    );

// begin_ntifs
NTKERNELAPI
BOOLEAN
CcZeroData (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER StartOffset,
    IN PLARGE_INTEGER EndOffset,
    IN BOOLEAN Wait
    );

NTKERNELAPI
PVOID
CcRemapBcb (
    IN PVOID Bcb
    );

NTKERNELAPI
VOID
CcRepinBcb (
    IN PVOID Bcb
    );

NTKERNELAPI
VOID
CcUnpinRepinnedBcb (
    IN PVOID Bcb,
    IN BOOLEAN WriteThrough,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTKERNELAPI
PFILE_OBJECT
CcGetFileObjectFromSectionPtrs (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer
    );

NTKERNELAPI
PFILE_OBJECT
CcGetFileObjectFromBcb (
    IN PVOID Bcb
    );

//
// These routines are implemented to support write throttling.
//

//
//  BOOLEAN
//  CcCopyWriteWontFlush (
//      IN PFILE_OBJECT FileObject,
//      IN PLARGE_INTEGER FileOffset,
//      IN ULONG Length
//      );
//

#define CcCopyWriteWontFlush(FO,FOFF,LEN) ((LEN) <= 0X10000)

NTKERNELAPI
BOOLEAN
CcCanIWrite (
    IN PFILE_OBJECT FileObject,
    IN ULONG BytesToWrite,
    IN BOOLEAN Wait,
    IN BOOLEAN Retrying
    );

typedef
VOID (*PCC_POST_DEFERRED_WRITE) (
    IN PVOID Context1,
    IN PVOID Context2
    );

NTKERNELAPI
VOID
CcDeferWrite (
    IN PFILE_OBJECT FileObject,
    IN PCC_POST_DEFERRED_WRITE PostRoutine,
    IN PVOID Context1,
    IN PVOID Context2,
    IN ULONG BytesToWrite,
    IN BOOLEAN Retrying
    );

//
// The following routines provide a data copy interface to the cache, and
// are intended for use by File Servers and File Systems.
//

NTKERNELAPI
BOOLEAN
CcCopyRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTKERNELAPI
VOID
CcFastCopyRead (
    IN PFILE_OBJECT FileObject,
    IN ULONG FileOffset,
    IN ULONG Length,
    IN ULONG PageCount,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTKERNELAPI
BOOLEAN
CcCopyWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN PVOID Buffer
    );

NTKERNELAPI
VOID
CcFastCopyWrite (
    IN PFILE_OBJECT FileObject,
    IN ULONG FileOffset,
    IN ULONG Length,
    IN PVOID Buffer
    );

//
//  The following routines provide an Mdl interface for transfers to and
//  from the cache, and are primarily intended for File Servers.
//
//  NOBODY SHOULD BE CALLING THESE MDL ROUTINES DIRECTLY, USE FSRTL AND
//  FASTIO INTERFACES.
//

NTKERNELAPI
VOID
CcMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus
    );

//
//  This routine is now a wrapper for FastIo if present or CcMdlReadComplete2
//

NTKERNELAPI
VOID
CcMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain
    );

// end_ntifs
NTKERNELAPI
VOID
CcMdlReadComplete2 (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain
    );

// begin_ntifs

NTKERNELAPI
VOID
CcPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus
    );

//
//  This routine is now a wrapper for FastIo if present or CcMdlWriteComplete2
//

NTKERNELAPI
VOID
CcMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain
    );

VOID
CcMdlWriteAbort (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain
    );

// end_ntifs
NTKERNELAPI
VOID
CcMdlWriteComplete2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain
    );

// begin_ntifs
//
// Common ReadAhead call for Copy Read and Mdl Read.
//
// ReadAhead should always be invoked by calling the CcReadAhead macro,
// which tests first to see if the read is large enough to warrant read
// ahead.  Measurements have shown that, calling the read ahead routine
// actually decreases performance for small reads, such as issued by
// many compilers and linkers.  Compilers simply want all of the include
// files to stay in memory after being read the first time.
//

#define CcReadAhead(FO,FOFF,LEN) {                       \
    if ((LEN) >= 256) {                                  \
        CcScheduleReadAhead((FO),(FOFF),(LEN));          \
    }                                                    \
}

NTKERNELAPI
VOID
CcScheduleReadAhead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length
    );

//
//  The following routine allows a caller to wait for the next batch
//  of lazy writer work to complete.  In particular, this provides a
//  mechanism for a caller to be sure that all avaliable lazy closes
//  at the time of this call have issued.
//

NTSTATUS
CcWaitForCurrentLazyWriterActivity (
    VOID
    );

//
// This routine changes the read ahead granularity for a file, which is
// PAGE_SIZE by default.
//

NTKERNELAPI
VOID
CcSetReadAheadGranularity (
    IN PFILE_OBJECT FileObject,
    IN ULONG Granularity
    );

//
// The following routines provide direct access data which is pinned in the
// cache, and is primarily intended for use by File Systems.  In particular,
// this mode of access is ideal for dealing with volume structures.
//

//
//  Flags for pinning
//

//
//  Synchronous Wait - normally specified.  This pattern may be specified as TRUE.
//

#define PIN_WAIT                         (1)

//
//  Acquire metadata Bcb exclusive (default is shared, Lazy Writer uses exclusive).
//
//  Must be set with PIN_WAIT.
//

#define PIN_EXCLUSIVE                    (2)

//
//  Acquire metadata Bcb but do not fault data in.  Default is to fault the data in.
//  This unusual flag is only used by Ntfs for cache coherency synchronization between
//  compressed and uncompressed streams for the same compressed file.
//
//  Must be set with PIN_WAIT.
//

#define PIN_NO_READ                      (4)

//
//  This option may be used to pin data only if the Bcb already exists.  If the Bcb
//  does not already exist - the pin is unsuccessful and no Bcb is returned.  This routine
//  provides a way to see if data is already pinned (and possibly dirty) in the cache,
//  without forcing a fault if the data is not there.
//

#define PIN_IF_BCB                       (8)

//
//  Flags for mapping
//

//
//  Synchronous Wait - normally specified.  This pattern may be specified as TRUE.
//

#define MAP_WAIT                         (1)

//
//  Acquire metadata Bcb but do not fault data in.  Default is to fault the data in.
//  This should not overlap with any of the PIN_ flags so they can be passed down to
//  CcPinFileData
//

#define MAP_NO_READ                      (16)



NTKERNELAPI
BOOLEAN
CcPinRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG Flags,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

NTKERNELAPI
BOOLEAN
CcMapData (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG Flags,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

NTKERNELAPI
BOOLEAN
CcPinMappedData (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG Flags,
    IN OUT PVOID *Bcb
    );

NTKERNELAPI
BOOLEAN
CcPreparePinWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Zero,
    IN ULONG Flags,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    );

NTKERNELAPI
VOID
CcSetDirtyPinnedData (
    IN PVOID BcbVoid,
    IN PLARGE_INTEGER Lsn OPTIONAL
    );

NTKERNELAPI
VOID
CcUnpinData (
    IN PVOID Bcb
    );

NTKERNELAPI
VOID
CcSetBcbOwnerPointer (
    IN PVOID Bcb,
    IN PVOID OwnerPointer
    );

NTKERNELAPI
VOID
CcUnpinDataForThread (
    IN PVOID Bcb,
    IN ERESOURCE_THREAD ResourceThreadId
    );

// end_ntifs
//
// The following routines are in logsup.c, and provide special Cache Manager
// support for storting Lsns with dirty file pages, and peforming subsequent
// operations based on them.
//

NTKERNELAPI
BOOLEAN
CcSetPrivateWriteFile(
    PFILE_OBJECT FileObject
    );

// begin_ntifs

NTKERNELAPI
VOID
CcSetAdditionalCacheAttributes (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN DisableReadAhead,
    IN BOOLEAN DisableWriteBehind
    );

NTKERNELAPI
VOID
CcSetLogHandleForFile (
    IN PFILE_OBJECT FileObject,
    IN PVOID LogHandle,
    IN PFLUSH_TO_LSN FlushToLsnRoutine
    );

NTKERNELAPI
LARGE_INTEGER
CcGetDirtyPages (
    IN PVOID LogHandle,
    IN PDIRTY_PAGE_ROUTINE DirtyPageRoutine,
    IN PVOID Context1,
    IN PVOID Context2
    );

NTKERNELAPI
BOOLEAN
CcIsThereDirtyData (
    IN PVPB Vpb
    );

// end_ntifs

NTKERNELAPI
LARGE_INTEGER
CcGetLsnForFileObject(
    IN PFILE_OBJECT FileObject,
    OUT PLARGE_INTEGER OldestLsn OPTIONAL
    );

//
// Internal kernel interfaces for the prefetcher.
//

extern LONG CcPfNumActiveTraces;
#define CCPF_IS_PREFETCHER_ACTIVE() (CcPfNumActiveTraces)

extern LOGICAL CcPfEnablePrefetcher;
#define CCPF_IS_PREFETCHER_ENABLED() (CcPfEnablePrefetcher)

extern LOGICAL CcPfPrefetchingForBoot;
#define CCPF_IS_PREFETCHING_FOR_BOOT() (CcPfPrefetchingForBoot)

NTSTATUS
CcPfInitializePrefetcher(
    VOID
    );

NTSTATUS
CcPfBeginBootPhase(
    PF_BOOT_PHASE_ID Phase
    );

NTSTATUS
CcPfBeginAppLaunch(
    PEPROCESS Process,
    PVOID Section
    );

NTSTATUS
CcPfProcessExitNotification(
    PEPROCESS Process
    );

#define CCPF_TYPE_IMAGE             0x00000001  // Current fault is for an image
#define CCPF_TYPE_ROM               0x00000002  // Current fault is for a ROM

VOID
CcPfLogPageFault(
    IN PFILE_OBJECT FileObject,
    IN ULONGLONG FileOffset,
    IN ULONG Flags
    );

NTSTATUS
CcPfQueryPrefetcherInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PULONG Length
    );

NTSTATUS
CcPfSetPrefetcherInformation (
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    IN KPROCESSOR_MODE PreviousMode
    );

//
// Internal kernel interfaces for Perf FileName rundowns.
//

VOID
CcPerfFileRunDown (
    IN PPERFINFO_ENTRY_TABLE HashTable
    );

#endif  // CACHE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\axp21264.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) 1996 Digital Euipment Corporation

Module Name:

    axp21264.h

Abstract:

    This module defines the DECchip 21264-specific structures that are
    defined in the PAL but must be visible to the HAL.

Revision History:

--*/

#ifndef _AXP21264_
#define _AXP21264_


//
// Define the "special" processor bus used by all machines that run a
// DECchip 21264.  The processor bus is used to access the internal
// performance counters.
//

#define PROCESSOR_BUS_21264 21264

//
// Define the physical address bit that turns on user-mode access
// to I/O space in the pfn of a pte.  This bit is required because of
// the current 36 bit physical address space limit on NT.
//

#define EV6_USER_IO_ADDRESS_SPACE (ULONGLONG)(0x800000000)

//
// Define the Ebox Internal Processor Register formats.
//

//
// Define the CC_CTL.
//

typedef union _CC_CTL_21264{
    struct {
        ULONGLONG Count : 32;
        ULONGLONG CcEna : 1;
        ULONGLONG Ignore : 31;
    } ;
    ULONGLONG all;
} CC_CTL_21264, *PCC_CTL_21264;

//
//  Define VA_CTL.
//

typedef union _VA_CTL_21264{
    struct {
        ULONGLONG BigEndian : 1;
        ULONGLONG Va48 : 1;
        ULONGLONG VaForm32 : 1;
        ULONGLONG Mbz : 27;
        ULONGLONG VPtb : 34;
    };
    ULONGLONG all;
} VA_CTL_21264, *PVA_CTL_21264;

//
// Define the Ibox Internal Processor Register formats.
//

//
//  Define ITB_PTE.
//

typedef union _ITB_PTE_21264{
    struct {
        ULONGLONG Ignore1 : 4;
        ULONGLONG Asm : 1;
        ULONGLONG Gh : 2;
        ULONGLONG Ignore2 : 1;
        ULONGLONG Kre : 1;
        ULONGLONG Ere : 1;
        ULONGLONG Sre : 1;
        ULONGLONG Ure : 1;
        ULONGLONG Ignore3 : 1;
        ULONGLONG Pfn : 31;
        ULONGLONG Ignore4 : 20;
    };
    ULONGLONG all;
} ITB_PTE_21264, *PITB_PTE_21264;

//
// Define EXC_ADDR
//

typedef union _EXC_ADDR_21264{
	  struct{
		  ULONGLONG Pal : 1;
		  ULONGLONG Raz : 1;
		  ULONGLONG Pc  : 62;
	  };
	  ULONGLONG all;
}  EXC_ADDR_21264, *PEXC_ADDR_21264;



//
//  Define IER_CM - Interrupt Enable/Current Mode Register
//  Note that this can be also be written as two independant registers.
//

typedef union _IER_CM_21264{
    struct {
        ULONGLONG Raz1 : 3;
        ULONGLONG Cm : 2;
        ULONGLONG Raz2 : 8;
        ULONGLONG AstEn : 1;
        ULONGLONG SiEn : 15;
        ULONGLONG PcEn : 2;
        ULONGLONG CrEn : 1;
        ULONGLONG SlEn : 1;
        ULONGLONG EiEn : 6;
        ULONGLONG Raz3 : 25;
    };
    ULONGLONG all;
} IER_CM_21264, *PIER_CM_21264;

//
//  Define SIRR - Software Interrupt Request Register
//

typedef union _SIRR_21264{
    struct{
        ULONGLONG Raz1 : 14;
        ULONGLONG Sir : 15;
        ULONGLONG Raz2 : 35;
    };
    ULONGLONG all;
} SIRR_21264, *PSIRR_21264;

//
//  Define ISUM - Interrupt Summary register
//

typedef union _ISUM_21264{
    struct{
        ULONGLONG Raz1 : 3;
        ULONGLONG AstK : 1;
        ULONGLONG AstE : 1;
        ULONGLONG Raz2 : 4;
        ULONGLONG AstS : 1;
        ULONGLONG AstU : 1;
        ULONGLONG Raz3 : 3;
        ULONGLONG Si : 15;
        ULONGLONG Pc : 2;
        ULONGLONG Cr : 1;
        ULONGLONG Sl : 1;
        ULONGLONG Ei : 6;
        ULONGLONG Raz4 : 25;
    };
    ULONGLONG all;
} ISUM_21264, *PISUM_21264;

//
//  Define HW_INT_CLR - Hardware Interrupt Clear Register
//

typedef union _HW_INT_CLR_21264{
    struct{
        ULONGLONG Ign1 : 26;
        ULONGLONG Fbtp : 1;
        ULONGLONG Fbdp : 1;
        ULONGLONG MchkD : 1;
        ULONGLONG Pc : 2;
        ULONGLONG Cr : 1;
        ULONGLONG Sl : 1;
        ULONGLONG Ign2 : 31;
    };
    ULONGLONG all;
} HW_INT_CLR_21264, *PHW_INT_CLR_21264;

//
//  Define EXC_SUM - Exception Summary Register
//

typedef union _EXC_SUM_21264{
    struct{
        ULONGLONG Swc : 1;
        ULONGLONG Inv : 1;
        ULONGLONG Dze : 1;
        ULONGLONG Fov : 1;
        ULONGLONG Unf : 1;
        ULONGLONG Ine : 1;
        ULONGLONG Iov : 1;
        ULONGLONG Int : 1;
        ULONGLONG Reg : 5;
        ULONGLONG BadIva : 1;
        ULONGLONG Ignore1 : 27;
        ULONGLONG PcOvf	 : 1;
        ULONGLONG SetInv : 1;
        ULONGLONG SetDze : 1;
        ULONGLONG SetOvf : 1;
        ULONGLONG SetUnf : 1;
        ULONGLONG SetIne : 1;
        ULONGLONG SetIov : 1;
        ULONGLONG Ignore2 : 16;
    };
    ULONGLONG all;
} EXC_SUM_21264, *PEXC_SUM_21264;

//
//  Define I_CTL - Ibox Control Register
//

typedef union _I_CTL_21264{
    struct{
        ULONGLONG PcEn : 1;
        ULONGLONG IcEnable : 2;
        ULONGLONG Sp32 : 1;
        ULONGLONG Sp43 : 1;
        ULONGLONG Sp48 : 1;
        ULONGLONG Raz1 : 1;
        ULONGLONG Sde : 1;
        ULONGLONG Sbe : 2;
        ULONGLONG BpMode : 2;
        ULONGLONG Hwe : 1;
        ULONGLONG Fbtp : 1;
        ULONGLONG Fbdp : 1;
        ULONGLONG Va48 : 1;
        ULONGLONG VaForm32 : 1;
        ULONGLONG SingleIssue : 1;
        ULONGLONG Pct0En : 1;
        ULONGLONG Pct1En : 1;
        ULONGLONG CallPalR23 : 1;
        ULONGLONG MchkEn : 1;
        ULONGLONG TbMbEn : 1;
        ULONGLONG BistFail : 1;
        ULONGLONG ChipId : 6;
        ULONGLONG Vptb : 18;
        ULONGLONG Sext : 16;
    };
    ULONGLONG all;
} I_CTL_21264, *PI_CTL_21264;

//
//  Define I_STAT - Ibox Status Register
//

typedef union _I_STAT_21264{
    struct{
        ULONGLONG Raz1 : 29;
        ULONGLONG Tpe : 1;
        ULONGLONG Dpe : 1;
        ULONGLONG Raz2 : 33;
    };
    ULONGLONG all;
} I_STAT_21264, *PI_STAT_21264;

//
//  Define PCTX - Ibox Process Context Register
//  Note that this can be also be written as five independant registers.
//  (ASN, ASTER, ASTRR, PPCE, FPE)
//

typedef union _PCTX_21264{
    struct{
        ULONGLONG Raz1 : 1;
        ULONGLONG Ppce : 1;
        ULONGLONG Fpe : 1;
        ULONGLONG Raz2 : 2;
        ULONGLONG AstEr : 4;
        ULONGLONG AstRr : 4;
        ULONGLONG Raz3 : 26;
        ULONGLONG Asn : 8;
        ULONGLONG Raz4 : 17;
    };
    ULONGLONG all;
} PCTX_21264, *PPCTX_21264;

//
//  Define PCTR_CTL - Performance Counter Control Register
//

typedef union _PCTR_CTL_21264{
    struct{
        ULONGLONG Sel1 : 4;
        ULONGLONG Sel0 : 1;
        ULONGLONG Raz1 : 1;
        ULONGLONG Pctr1 : 20;
        ULONGLONG Raz2 : 2;
        ULONGLONG Pctr0 : 20;
        ULONGLONG Raz3 : 16;
    };
    ULONGLONG all;
} PCTR_CTL_21264, *PPCTR_CTL_21264;


//
// Define the Mbox and Dcache Internal Processor Register formats.
//

//
//  Define DTB_PTE
//

typedef union _DTB_PTE_21264{
    struct{
        ULONGLONG Ignore1 : 1;
        ULONGLONG For : 1;
        ULONGLONG Fow : 1;
        ULONGLONG Ignore2 : 1;
        ULONGLONG Asm : 1;
        ULONGLONG Gh : 2;
        ULONGLONG Ignore3 : 1;
        ULONGLONG Kre : 1;
        ULONGLONG Ere : 1;
        ULONGLONG Sre : 1;
        ULONGLONG Ure : 1;
        ULONGLONG Kwe : 1;
        ULONGLONG Ewe : 1;
        ULONGLONG Swe : 1;
        ULONGLONG Uwe : 1;
        ULONGLONG Ignore4 : 16;
        ULONGLONG Pfn : 31;
        ULONGLONG Ignore5 : 1;
    };
    ULONGLONG all;
} DTB_PTE_21264, *PDTB_PTE_21264;

//
//  Define DTB_ASN
//

typedef union _DTB_ASN_21264{
    struct{
        ULONGLONG Ignore1 : 56;
        ULONGLONG Asn : 8;
    };
    ULONGLONG all;
} DTB_ASN_21264, *PDTB_ASN_21264;

//
//  Define MM_STAT - MBOX Status Register
//

typedef union _MM_STAT_21264{
    struct{
        ULONGLONG Wr : 1;
        ULONGLONG Acv : 1;
        ULONGLONG For : 1;
        ULONGLONG Fow : 1;
        ULONGLONG Opcode : 6;
        ULONGLONG DcTagPerr : 1;
        ULONGLONG Ignore1 : 53;
    };
    ULONGLONG all;
} MM_STAT_21264, *PMM_STAT_21264;

//
//  Define M_CTL - MBOX Control Register
//

typedef union _M_CTL_21264{
    struct{
        ULONGLONG Mbz1	: 1;
        ULONGLONG sp32	: 1;
		ULONGLONG sp43	: 1;
		ULONGLONG sp48	: 1;
        ULONGLONG Mbz2	: 60;
    };
    ULONGLONG all;
} M_CTL_21264, *PM_CTL_21264;

//
//  Define DC_CTL - Dcache Control Register
//

typedef union _DC_CTL_21264{
    struct{
        ULONGLONG SetEn : 2;
        ULONGLONG Fhit : 1;
        ULONGLONG Flush : 1;
        ULONGLONG FBadTpar : 1;
        ULONGLONG FBadDecc : 1;
        ULONGLONG DcTagParEn : 1;
        ULONGLONG DcDatErrEn : 1;
        ULONGLONG Mbz1 : 56;
    };
    ULONGLONG all;
} DC_CTL_21264, *PDC_CTL_21264;

//
//  Define DC_STAT - Dcache Status Register
//

typedef union _DC_STAT_21264{
    struct{
        ULONGLONG TPerrP0 : 1;
        ULONGLONG TPerrP1 : 1;
        ULONGLONG EccErrSt : 1;
        ULONGLONG EccErrLd : 1;
        ULONGLONG Seo : 1;
        ULONGLONG Raz1 : 59;
    };
    ULONGLONG all;
} DC_STAT_21264, *PDC_STAT_21264;

        
//
// Define Cbox Internal Processor Registers.
//

//
// Define CSTAT field in CBOX read IPR
//

typedef union _C_STAT_21264 {
    struct {
        ULONGLONG       ErrorQualifier  :3;
        ULONGLONG       IstreamError    :1;
        ULONGLONG       DoubleBitError  :1;
        ULONGLONG       Reserved        :59;
    };
    ULONGLONG all;
} C_STAT_21264, *PC_STAT_21264;


// SjBfix. CBOX Register chain not defined yet.



//
// Define the Interrupt Mask structure communicated between the 
// HAL and PALcode.
//
// This is the bit defintion for the IRQL fields that are stored
// in the PCR IrqlTable. Keep it the same as on EV4.
//

typedef struct _IETEntry_21264{
    ULONG ApcEnable: 1;
    ULONG DispatchEnable: 1;
    ULONG PerformanceCounter0Enable: 1;
    ULONG PerformanceCounter1Enable: 1;
    ULONG CorrectableReadEnable: 1;
    ULONG Irq0Enable: 1;
    ULONG Irq1Enable: 1;
    ULONG Irq2Enable: 1;
    ULONG Irq3Enable: 1;
    ULONG Irq4Enable: 1;
    ULONG Irq5Enable: 1;
    ULONG Reserved: 21;
} IETEntry_21264, *PIETEntry_21264;

//
// Define the offsets and sizes of the mask sub-tables within the interrupt
// mask table in the PCR.
//

#define IRQLMASK_HDW_SUBTABLE_21264 (8)
#define IRQLMASK_HDW_SUBTABLE_21264_ENTRIES (64)

#define IRQLMASK_SFW_SUBTABLE_21264 (0)
#define IRQLMASK_SFW_SUBTABLE_21264_ENTRIES (4)

#define IRQLMASK_PC_SUBTABLE_21264  (4)
#define IRQLMASK_PC_SUBTABLE_21264_ENTRIES (4)

//
// HACKHACK - this should probably be in a table
//
#define EV6_CRD_VECTOR (25)

//
// PALcode Event Counters for the 21264
// This is the structure of the data returned by the rdcounters call pal.
//

typedef struct _COUNTERS_21264{
    ULONGLONG MachineCheckCount;
    ULONGLONG ArithmeticExceptionCount;
    ULONGLONG InterruptCount;
    ULONGLONG ItbMissCount;
    ULONGLONG DtbMissSingleCount;
    ULONGLONG DtbMissDoubleCount;
    ULONGLONG IAccvioCount;
    ULONGLONG DfaultCount;
    ULONGLONG UnalignedCount;
    ULONGLONG OpcdecCount;
    ULONGLONG FenCount;
    ULONGLONG ItbTnvCount;
    ULONGLONG DtbTnvCount;
    ULONGLONG PdeTnvCount;
    ULONGLONG FPCRCount;
    ULONGLONG RestCount;
    ULONGLONG DtbMissDouble4Count;
    ULONGLONG HardwareInterruptCount;
    ULONGLONG SoftwareInterruptCount;
    ULONGLONG SpecialInterruptCount;
    ULONGLONG HaltCount;
    ULONGLONG RestartCount;
    ULONGLONG DrainaCount;
    ULONGLONG RebootCount;
    ULONGLONG InitpalCount;
    ULONGLONG WrentryCount;
    ULONGLONG SwpirqlCount;
    ULONGLONG RdirqlCount;
    ULONGLONG DiCount;
    ULONGLONG EiCount;
    ULONGLONG SwppalCount;
    ULONGLONG SsirCount;
    ULONGLONG CsirCount;
    ULONGLONG RfeCount;
    ULONGLONG RetsysCount;
    ULONGLONG SwpctxCount;
    ULONGLONG SwpprocessCount;
    ULONGLONG RdmcesCount;
    ULONGLONG WrmcesCount;
    ULONGLONG TbiaCount;
    ULONGLONG TbisCount;
    ULONGLONG TbisasnCount;
    ULONGLONG DtbisCount;
    ULONGLONG RdkspCount;
    ULONGLONG SwpkspCount;
    ULONGLONG RdpsrCount;
    ULONGLONG RdpcrCount;
    ULONGLONG RdthreadCount;
    ULONGLONG TbimCount;
    ULONGLONG TbimasnCount;
    ULONGLONG RdcountersCount;
    ULONGLONG RdstateCount;
    ULONGLONG WrperfmonCount;
    ULONGLONG InitpcrCount;
    ULONGLONG BptCount;
    ULONGLONG CallsysCount;
    ULONGLONG ImbCount;
    ULONGLONG GentrapCount;
    ULONGLONG RdtebCount;
    ULONGLONG KbptCount;
    ULONGLONG CallkdCount;
    ULONGLONG AddressSpaceSwapCount;
    ULONGLONG AsnWrapCount;
    ULONGLONG EalnfixCount;
    ULONGLONG DalnfixCount;
    ULONGLONG SleepCount;
    ULONGLONG Misc1Count;
    ULONGLONG Misc2Count;
    ULONGLONG Misc3Count;
    ULONGLONG Misc4Count;
    ULONGLONG Misc5Count;
    ULONGLONG Misc6Count;
    ULONGLONG Misc7Count;
    ULONGLONG Misc8Count;
    ULONGLONG Misc9Count;
    ULONGLONG Misc10Count;
    ULONGLONG Misc11Count;
    ULONGLONG Misc12Count;
    ULONGLONG Misc13Count;
    ULONGLONG Misc14Count;
    ULONGLONG Misc15Count;
    ULONGLONG Misc16Count;
    ULONGLONG Misc17Count;
} COUNTERS_21264, *PCOUNTERS_21264;

//
// Types of performance counters.
//

typedef enum _AXP21264_PCCOUNTER{
	Ev6PerformanceCounter0 = 0,
	Ev6PerformanceCounter1 = 1,
} AXP21264_PCCOUNTER, *PAXP21264_PCCOUNTER;

//
// Mux control values
//

typedef enum _AXP21264_PCMUXCONTROL{
    //
    //  Mux values for PCTR1:
    //
    Ev6Instructions = 0x00,
    Ev6CondBranches = 0x01,
    Ev6Mispredicts = 0x02,
    Ev6ITBMisses = 0x03,
    Ev6DTBMisses = 0x04,
    Ev6Unaligned = 0x05,
    Ev6IcacheMisses = 0x06,
    Ev6ReplayTraps = 0x07,
    Ev6LoadMisses = 0x08,
    Ev6DcacheMisses = 0x09,
    Ev6BcacheReads = 0x0a,
    Ev6BcacheWrites = 0x0b,
    Ev6SysPortReads = 0x0c,
    Ev6SysPortWrites = 0x0d,
    Ev6MBStalls = 0x0e,             // SjBfix. Not documented
    Ev6StcStalls = 0x0f,            // SjBfix. Not documented

    //
    //  Mux values for PCTR0:
    //
    Ev6Cycles = 0x00,
    Ev6RetiredInstructions = 0x01

} AXP21264_PCMUXCONTROL, *PAXP21264_PCMUXCONTROL;


//
// Internal processor state record.
// This is the structure of the data returned by the rdstate call pal.
//

typedef struct _PROCESSOR_STATE_21264{
    IER_CM_21264 IerCm;
    SIRR_21264 Sirr;
    ISUM_21264 Isum;
    EXC_SUM_21264 ExcSum;
    ULONGLONG PalBase;
    I_CTL_21264 ICtl;
    I_STAT_21264 IStat;
    PCTX_21264 PCtx;
    PCTR_CTL_21264 PCtr;
    MM_STAT_21264 MmStat;
    DC_STAT_21264 DcStat;

} PROCESSOR_STATE_21264, *PPROCESSOR_STATE_21264;

//
// Machine-check logout frame.
//

typedef struct _LOGOUT_FRAME_21264{
    ULONG               FrameSize;
    ULONG               RSDC;
    ULONG               CpuAreaOffset;
    ULONG               SystemAreaOffset;
    ULONG               MchkCode;
    ULONG               MchkFrameRev;
    I_STAT_21264        IStat;
    DC_STAT_21264       DcStat;
    ULONGLONG           CAddr;
    ULONGLONG           Dc1Syndrome;
    ULONGLONG           Dc0Syndrome;
    ULONGLONG           CStat;
    ULONGLONG           CSts;
    ULONGLONG           Va;
    ULONGLONG           ExcAddr;
    IER_CM_21264        IerCm;
    ISUM_21264          ISum;
    MM_STAT_21264       MmStat;
    ULONGLONG           PalBase;
    I_CTL_21264         ICtl;
    PCTX_21264          PCtx;
    VA_CTL_21264        VaCtl;
    ULONGLONG           Ps;
} LOGOUT_FRAME_21264, *PLOGOUT_FRAME_21264;

//
// Correctable logout frame
//

typedef struct _CORRECTABLE_FRAME_21264 {
    ULONG               FrameSize;
    ULONG               RSDC;
    ULONG               CpuAreaOffset;
    ULONG               SystemAreaOffset;
    ULONG               MchkCode;
    ULONG               MchkFrameRev;
    I_STAT_21264        IStat;
    DC_STAT_21264       DCStat;
    ULONGLONG           CAddr;
    ULONGLONG           Dc1Syndrome;
    ULONGLONG           Dc0Syndrome;
    ULONGLONG           CStat;
    ULONGLONG           CSts;
    ULONGLONG           MmStat;
} CORRECTABLE_FRAME_21264, *PCORRECTABLE_FRAME_21264;

//
// Define the number of physical and virtual address bits
//

#define EV6_PHYSICAL_ADDRESS_BITS       44
#define EV6_VIRTUAL_ADDRESS_BITS        43

#endif //!_AXP21264_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efi.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efi.h

Abstract:

    Public EFI header files



Revision History

--*/

/* 
 *  Build flags on input
 *   EFI32
 *   EFI_DEBUG               - Enable debugging code
 *   EFI_NT_EMULATOR         - Building for running under NT
 */


#ifndef _EFI_INCLUDE_
#define _EFI_INCLUDE_

#define EFI_FIRMWARE_VENDOR         L"INTEL"
#define EFI_FIRMWARE_MAJOR_REVISION 12
#define EFI_FIRMWARE_MINOR_REVISION 24
#define EFI_FIRMWARE_REVISION ((EFI_FIRMWARE_MAJOR_REVISION <<16) | (EFI_FIRMWARE_MINOR_REVISION))

#if defined(_WIN64)
    #include "efibind64.h"
#else
    #include "efibind32.h"
#endif

#include "efidef.h"
#include "efidevp.h"
#include "efiprot.h"
#include "eficon.h"
#include "efiser.h"
#include "efi_nii.h"
#include "efipxebc.h"
#include "efinet.h"
#include "efiapi.h"
#include "efifs.h"
#include "efierr.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\class.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    class.h

Abstract:

    These are the structures and defines that are used in the
    SCSI class drivers.

Author:

    Mike Glass (mglass)
    Jeff Havens (jhavens)

Revision History:

--*/

#ifndef _CLASS_

#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddtape.h>
#include <ntddchgr.h>
#include <ntddstor.h>
#include "ntddscsi.h"
#include <stdio.h>

// begin_ntminitape

#if DBG

#define DebugPrint(x) ScsiDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

// end_ntminitape

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'HscS')
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'HscS')
#endif

#define MAXIMUM_RETRIES 4

typedef
VOID
(*PCLASS_ERROR) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT NTSTATUS *Status,
    IN OUT BOOLEAN *Retry
    );

typedef struct _DEVICE_EXTENSION {

    //
    // Back pointer to device object
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Pointer to port device object
    //

    PDEVICE_OBJECT PortDeviceObject;

    //
    // Length of partition in bytes
    //

    LARGE_INTEGER PartitionLength;

    //
    // Number of bytes before start of partition
    //

    LARGE_INTEGER StartingOffset;

    //
    // Bytes to skew all requests, since DM Driver has been placed on an IDE drive.
    //

    ULONG DMByteSkew;

    //
    // Sectors to skew all requests.
    //

    ULONG DMSkew;

    //
    // Flag to indicate whether DM driver has been located on an IDE drive.
    //

    BOOLEAN DMActive;

    //
    // Pointer to the specific class error routine.
    //

    PCLASS_ERROR ClassError;

    //
    // SCSI port driver capabilities
    //

    PIO_SCSI_CAPABILITIES PortCapabilities;

    //
    // Buffer for drive parameters returned in IO device control.
    //

    PDISK_GEOMETRY DiskGeometry;

    //
    // Back pointer to device object of physical device
    //

    PDEVICE_OBJECT PhysicalDevice;

    //
    // Request Sense Buffer
    //

    PSENSE_DATA SenseData;

    //
    // Request timeout in seconds;
    //

    ULONG TimeOutValue;

    //
    // System device number
    //

    ULONG DeviceNumber;

    //
    // Add default Srb Flags.
    //

    ULONG SrbFlags;

    //
    // Total number of SCSI protocol errors on the device.
    //

    ULONG ErrorCount;

    //
    // Spinlock for split requests
    //

    KSPIN_LOCK SplitRequestSpinLock;

    //
    // Zone header and spin lock for zoned SRB requests.
    //

    PZONE_HEADER SrbZone;

    PKSPIN_LOCK SrbZoneSpinLock;

    //
    // Lock count for removable media.
    //

    LONG LockCount;

    //
    // Scsi port number
    //

    UCHAR PortNumber;

    //
    // SCSI path id
    //

    UCHAR PathId;

    //
    // SCSI bus target id
    //

    UCHAR TargetId;

    //
    // SCSI bus logical unit number
    //

    UCHAR Lun;

    //
    // Log2 of sector size
    //

    UCHAR SectorShift;

    //
    // Flag to indicate that the device has write caching enabled.
    //

    BOOLEAN WriteCache;

    //
    // Build SCSI 1 or SCSI 2 CDBs
    //

    BOOLEAN UseScsi1;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Define context structure for asynchronous completions.
//

typedef struct _COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    SCSI_REQUEST_BLOCK Srb;
}COMPLETION_CONTEXT, *PCOMPLETION_CONTEXT;


NTSTATUS
ScsiClassGetCapabilities(
    IN PDEVICE_OBJECT PortDeviceObject,
    OUT PIO_SCSI_CAPABILITIES *PortCapabilities
    );

NTSTATUS
ScsiClassGetInquiryData(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PSCSI_ADAPTER_BUS_INFO *ConfigInfo
    );

NTSTATUS
ScsiClassReadDriveCapacity(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
ScsiClassReleaseQueue(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ScsiClassRemoveDevice(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    );

NTSTATUS
ScsiClassAsynchronousCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

VOID
ScsiClassSplitRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG MaximumBytes
    );

NTSTATUS
ScsiClassDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

NTSTATUS
ScsiClassIoComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ScsiClassIoCompleteAssociated(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
ScsiClassInterpretSenseInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR MajorFunctionCode,
    IN ULONG IoDeviceCode,
    IN ULONG RetryCount,
    OUT NTSTATUS *Status
    );

NTSTATUS
ScsiClassSendSrbSynchronous(
        PDEVICE_OBJECT DeviceObject,
        PSCSI_REQUEST_BLOCK Srb,
        PVOID BufferAddress,
        ULONG BufferLength,
        BOOLEAN WriteToDevice
        );

NTSTATUS
ScsiClassSendSrbAsynchronous(
        PDEVICE_OBJECT DeviceObject,
        PSCSI_REQUEST_BLOCK Srb,
        PIRP Irp,
        PVOID BufferAddress,
        ULONG BufferLength,
        BOOLEAN WriteToDevice
        );

VOID
ScsiClassBuildRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

ULONG
ScsiClassModeSense(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    );

BOOLEAN
ScsiClassModeSelect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCHAR ModeSelectBuffer,
    IN ULONG Length,
    IN BOOLEAN SavePage
    );

PVOID
ScsiClassFindModePage(
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    );

NTSTATUS
ScsiClassClaimDevice(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PSCSI_INQUIRY_DATA LunInfo,
    IN BOOLEAN Release,
    OUT PDEVICE_OBJECT *NewPortDeviceObject OPTIONAL
    );

NTSTATUS
ScsiClassInternalIoControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#endif /* _CLASS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\cm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cm.h

Abstract:

    This module contains the internal structure definitions and APIs
    used by the NT configuration management system, including the
    registry.

Author:

    Bryan M. Willman (bryanwi)  28-Aug-91


Revision History:


--*/

#ifndef _CM_
#define _CM_

//
// Define Names used to access the regsitry
//

extern UNICODE_STRING CmRegistryRootName;            // \REGISTRY
extern UNICODE_STRING CmRegistryMachineName;         // \REGISTRY\MACHINE
extern UNICODE_STRING CmRegistryMachineHardwareName; // \REGISTRY\MACHINE\HARDWARE
extern UNICODE_STRING CmRegistryMachineHardwareDescriptionName;
                            // \REGISTRY\MACHINE\HARDWARE\DESCRIPTION
extern UNICODE_STRING CmRegistryMachineHardwareDescriptionSystemName;
                            // \REGISTRY\MACHINE\HARDWARE\DESCRIPTION\SYSTEM
extern UNICODE_STRING CmRegistryMachineHardwareDeviceMapName;
                            // \REGISTRY\MACHINE\HARDWARE\DEVICEMAP
extern UNICODE_STRING CmRegistryMachineHardwareResourceMapName;
                            // \REGISTRY\MACHINE\HARDWARE\RESOURCEMAP
extern UNICODE_STRING CmRegistryMachineHardwareOwnerMapName;
                            // \REGISTRY\MACHINE\HARDWARE\OWNERMAP
extern UNICODE_STRING CmRegistryMachineSystemName;
                            // \REGISTRY\MACHINE\SYSTEM
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSet;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetEnumName;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\ENUM
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetEnumRootName;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\ENUM\ROOT
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetServices;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\SERVICES
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\HARDWARE PROFILES\CURRENT
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlClass;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\CONTROL\CLASS
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlSafeBoot;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\CONTROL\SAFEBOOT
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlSessionManagerMemoryManagement;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\CONTROL\SESSION MANAGER\MEMORY MANAGEMENT
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlBootLog;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\CONTROL\BOOTLOG
extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetServicesEventLog;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\SERVICES\EVENTLOG
extern UNICODE_STRING CmRegistryUserName;            // \REGISTRY\USER

#ifdef _WANT_MACHINE_IDENTIFICATION

extern UNICODE_STRING CmRegistryMachineSystemCurrentControlSetControlBiosInfo;
                            // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\CONTROL\BIOSINFO

#endif

//
// The following strings will be used as the keynames for registry
// nodes.
// The associated enumerated type is CONFIGURATION_TYPE in arc.h
//

extern UNICODE_STRING CmTypeName[];
extern const PWSTR CmTypeString[];

//
// CmpClassString - contains strings which are used as the class
//     strings in the keynode.
// The associated enumerated type is CONFIGURATION_CLASS in arc.h
//

extern UNICODE_STRING CmClassName[];
extern const PWSTR CmClassString[];

// begin_ntosp

//
// Define structure of boot driver list.
//

typedef struct _BOOT_DRIVER_LIST_ENTRY {
    LIST_ENTRY Link;
    UNICODE_STRING FilePath;
    UNICODE_STRING RegistryPath;
    PKLDR_DATA_TABLE_ENTRY LdrEntry;
} BOOT_DRIVER_LIST_ENTRY, *PBOOT_DRIVER_LIST_ENTRY;
// end_ntosp
PHANDLE
CmGetSystemDriverList(
    VOID
    );

BOOLEAN
CmInitSystem1(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

BOOLEAN
CmInitSystem2(
    VOID
    );

VOID
CmNotifyRunDown(
    PETHREAD    Thread
    );

VOID
CmShutdownSystem(
    VOID
    );

VOID
CmBootLastKnownGood(
    ULONG ErrorLevel
    );

BOOLEAN
CmIsLastKnownGoodBoot(
    VOID
    );

//
// Stuctures and definitions for use with CmGetSystemControlValues
//

//
// NOTES:
//      KeyPath is relative to currentcontrolset.  So, if the variable
//      of interest is
//      "\registry\machine\system\currentcontrolset\control\fruit\apple:x"
//      the entry is
//      { L"fruit\\apple",
//        L"x",
//        &Xbuffer,
//        sizeof(ULONG),
//        &Xtype
//      }
//
//      *BufferLength is available space on input
//      on output:
//          -1 = no such key or value
//          0  = key and value exist, but have 0 length data
//          > input = buffer too small, filled to available space,
//                    value is actual size of data in registry
//          <= input = number of bytes copied out
//
typedef struct _CM_SYSTEM_CONTROL_VECTOR {
    PWSTR       KeyPath;                // path name relative to
                                        // current control set
    PWSTR       ValueName;              // name of value entry
    PVOID       Buffer;                 // data goes here
    PULONG      BufferLength;           // IN: space allocated
                                        // OUT: space used, -1 for no such
                                        //      key or value, 0 for key/value
                                        //      found but has 0 length data
                                        // if NULL pointer, assume 4 bytes
                                        // (reg DWORD) available and do not
                                        // report actual size
    PULONG      Type;                   // return type of found data, may
                                        // be NULL
} CM_SYSTEM_CONTROL_VECTOR, *PCM_SYSTEM_CONTROL_VECTOR;

VOID
CmGetSystemControlValues(
    PVOID                   SystemHiveBuffer,
    PCM_SYSTEM_CONTROL_VECTOR  ControlVector
    );

VOID
CmQueryRegistryQuotaInformation(
    IN PSYSTEM_REGISTRY_QUOTA_INFORMATION RegistryQuotaInformation
    );

VOID
CmSetRegistryQuotaInformation(
    IN PSYSTEM_REGISTRY_QUOTA_INFORMATION RegistryQuotaInformation
    );



typedef
VOID
(*PCM_TRACE_NOTIFY_ROUTINE)(
    IN NTSTATUS         Status,
    IN PVOID            Kcb,
    IN LONGLONG         ElapsedTime,
    IN ULONG            Index,
    IN PUNICODE_STRING  KeyName,
    IN UCHAR            Type
    );

NTSTATUS
CmSetTraceNotifyRoutine(
    IN PCM_TRACE_NOTIFY_ROUTINE NotifyRoutine,
    IN BOOLEAN Remove
    );


NTSTATUS
CmPrefetchHivePages(
                    IN  PUNICODE_STRING     FullHivePath,
                    IN  OUT PREAD_LIST      ReadList
                    );

VOID
CmSetLazyFlushState(BOOLEAN Enable);

// begin_ntddk begin_wdm

//
// Registry kernel mode callbacks
//

//
// Hook selector
//
typedef enum _REG_NOTIFY_CLASS {
    RegNtDeleteKey,
    RegNtSetValueKey,
    RegNtDeleteValueKey,
    RegNtSetInformationKey,
    RegNtRenameKey,
    RegNtEnumerateKey,
    RegNtEnumerateValueKey,
    RegNtQueryKey,
    RegNtQueryValueKey,
    RegNtQueryMultipleValueKey,
    RegNtPreCreateKey,
    RegNtPostCreateKey,
    RegNtPreOpenKey,
    RegNtPostOpenKey,
    RegNtKeyHandleClose
} REG_NOTIFY_CLASS;

//
// Parameter description for each notify class
//
typedef struct _REG_DELETE_KEY_INFORMATION {
    PVOID               Object;                      // IN
} REG_DELETE_KEY_INFORMATION, *PREG_DELETE_KEY_INFORMATION;

typedef struct _REG_SET_VALUE_KEY_INFORMATION {
    PVOID               Object;                         // IN
    PUNICODE_STRING     ValueName;                      // IN
    ULONG               TitleIndex;                     // IN
    ULONG               Type;                           // IN
    PVOID               Data;                           // IN
    ULONG               DataSize;                       // IN
} REG_SET_VALUE_KEY_INFORMATION, *PREG_SET_VALUE_KEY_INFORMATION;

typedef struct _REG_DELETE_VALUE_KEY_INFORMATION {
    PVOID               Object;                         // IN
    PUNICODE_STRING     ValueName;                      // IN
} REG_DELETE_VALUE_KEY_INFORMATION, *PREG_DELETE_VALUE_KEY_INFORMATION;

typedef struct _REG_SET_INFORMATION_KEY_INFORMATION {
    PVOID                       Object;                 // IN
    KEY_SET_INFORMATION_CLASS   KeySetInformationClass; // IN
    PVOID                       KeySetInformation;      // IN
    ULONG                       KeySetInformationLength;// IN
} REG_SET_INFORMATION_KEY_INFORMATION, *PREG_SET_INFORMATION_KEY_INFORMATION;

typedef struct _REG_ENUMERATE_KEY_INFORMATION {
    PVOID                       Object;                 // IN
    ULONG                       Index;                  // IN
    KEY_INFORMATION_CLASS       KeyInformationClass;    // IN
    PVOID                       KeyInformation;         // IN
    ULONG                       Length;                 // IN
    PULONG                      ResultLength;           // OUT
} REG_ENUMERATE_KEY_INFORMATION, *PREG_ENUMERATE_KEY_INFORMATION;

typedef struct _REG_ENUMERATE_VALUE_KEY_INFORMATION {
    PVOID                           Object;                     // IN
    ULONG                           Index;                      // IN
    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;   // IN
    PVOID                           KeyValueInformation;        // IN
    ULONG                           Length;                     // IN
    PULONG                          ResultLength;               // OUT
} REG_ENUMERATE_VALUE_KEY_INFORMATION, *PREG_ENUMERATE_VALUE_KEY_INFORMATION;

typedef struct _REG_QUERY_KEY_INFORMATION {
    PVOID                       Object;                 // IN
    KEY_INFORMATION_CLASS       KeyInformationClass;    // IN
    PVOID                       KeyInformation;         // IN
    ULONG                       Length;                 // IN
    PULONG                      ResultLength;           // OUT
} REG_QUERY_KEY_INFORMATION, *PREG_QUERY_KEY_INFORMATION;

typedef struct _REG_QUERY_VALUE_KEY_INFORMATION {
    PVOID                           Object;                     // IN
    PUNICODE_STRING                 ValueName;                  // IN
    KEY_VALUE_INFORMATION_CLASS     KeyValueInformationClass;   // IN
    PVOID                           KeyValueInformation;        // IN
    ULONG                           Length;                     // IN
    PULONG                          ResultLength;               // OUT
} REG_QUERY_VALUE_KEY_INFORMATION, *PREG_QUERY_VALUE_KEY_INFORMATION;

typedef struct _REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION {
    PVOID               Object;                 // IN
    PKEY_VALUE_ENTRY    ValueEntries;           // IN
    ULONG               EntryCount;             // IN
    PVOID               ValueBuffer;            // IN
    PULONG              BufferLength;           // IN OUT
    PULONG              RequiredBufferLength;   // OUT
} REG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION, *PREG_QUERY_MULTIPLE_VALUE_KEY_INFORMATION;

typedef struct _REG_RENAME_KEY_INFORMATION {
    PVOID            Object;    // IN
    PUNICODE_STRING  NewName;   // IN
} REG_RENAME_KEY_INFORMATION, *PREG_RENAME_KEY_INFORMATION;

typedef struct _REG_PRE_CREATE_KEY_INFORMATION {
    PUNICODE_STRING     CompleteName;   // IN
} REG_PRE_CREATE_KEY_INFORMATION, REG_PRE_OPEN_KEY_INFORMATION,*PREG_PRE_CREATE_KEY_INFORMATION, *PREG_PRE_OPEN_KEY_INFORMATION;;

typedef struct _REG_POST_CREATE_KEY_INFORMATION {
    PUNICODE_STRING     CompleteName;   // IN
    PVOID               Object;         // IN
    NTSTATUS            Status;         // IN
} REG_POST_CREATE_KEY_INFORMATION,REG_POST_OPEN_KEY_INFORMATION, *PREG_POST_CREATE_KEY_INFORMATION, *PREG_POST_OPEN_KEY_INFORMATION;

typedef struct _REG_KEY_HANDLE_CLOSE_INFORMATION {
    PVOID               Object;         // IN
} REG_KEY_HANDLE_CLOSE_INFORMATION, *PREG_KEY_HANDLE_CLOSE_INFORMATION;


NTSTATUS
CmRegisterCallback(IN PEX_CALLBACK_FUNCTION Function,
                   IN PVOID                 Context,
                   IN OUT PLARGE_INTEGER    Cookie
                    );
NTSTATUS
CmUnRegisterCallback(IN LARGE_INTEGER    Cookie);

// end_ntddk end_wdm

//
// PnP private API
//
typedef VOID (*PCM_HYSTERESIS_CALLBACK)(PVOID Ref, ULONG Level);

ULONG
CmRegisterSystemHiveLimitCallback(
                                    ULONG Low,
                                    ULONG High,
                                    PVOID Ref,
                                    PCM_HYSTERESIS_CALLBACK Callback
                                    );

#endif // _CM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\cpyuchr.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cpyuchr.h

Abstract:

    A more central set of definitions for unpacking unaligned
    data (i.e. for unbpacking bios parameter blocks).

Author:

Revision History:

--*/

#ifndef CopyUchar1
//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

#define CopyU4char(Dst,Src) {                                \
    *((UNALIGNED UCHAR4 *)(Dst)) = *((UCHAR4 *)(Src)); \
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\dockintf.h ===
/*++
Copyright (c) 1999  Microsoft Corporation

Module Name:

    DockIntf.h

Abstract:

    This header defines the Dock Interface

Author:

    Adrian J. Oney

Environment:

    kernel mode only

Notes:


Revision History:
    Adrian J. Oney           21-May-1999     Created

--*/

DEFINE_GUID(GUID_DOCK_INTERFACE,
            0xa9956ff5L, 0x13da, 0x11d3,
            0x97, 0xdb, 0x00, 0xa0, 0xc9, 0x40, 0x52, 0x2e );

#ifndef _DOCKINTF_H_
#define _DOCKINTF_H_

//
// The interface returned consists of the following structure and functions.
//

#define DOCK_INTRF_STANDARD_VER   1

typedef enum {

    PDS_UPDATE_DEFAULT = 1,
    PDS_UPDATE_ON_REMOVE,
    PDS_UPDATE_ON_INTERFACE,
    PDS_UPDATE_ON_EJECT

} PROFILE_DEPARTURE_STYLE;

typedef ULONG (* PFN_PROFILE_DEPARTURE_SET_MODE)(
    IN  PVOID                   Context,
    IN  PROFILE_DEPARTURE_STYLE Style
    );

typedef ULONG (* PFN_PROFILE_DEPARTURE_UPDATE)(
    IN  PVOID   Context
    );

typedef struct {

    struct _INTERFACE; // Unnamed struct

    PFN_PROFILE_DEPARTURE_SET_MODE  ProfileDepartureSetMode;
    PFN_PROFILE_DEPARTURE_UPDATE    ProfileDepartureUpdate;

} DOCK_INTERFACE, *PDOCK_INTERFACE;

#endif // _DOCKINTF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\dbgk.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dbgk.h

Abstract:

    This header file describes public data structures and functions
    that make up the kernel mode portion of the Dbg subsystem.

Author:

    Mark Lucovsky (markl) 19-Jan-1990

Revision History:

--*/

#ifndef _DBGK_
#define _DBGK_

//
// Define the debug object thats used to atatch to processes that are being debugged.
//
#define DEBUG_OBJECT_DELETE_PENDING (0x1) // Debug object is delete pending.
#define DEBUG_OBJECT_KILL_ON_CLOSE  (0x2) // Kill all debugged processes on close

typedef struct _DEBUG_OBJECT {
    //
    // Event thats set when the EventList is populated.
    //
    KEVENT EventsPresent;
    //
    // Mutex to protect the structure
    //
    FAST_MUTEX Mutex;
    //
    // Queue of events waiting for debugger intervention
    //
    LIST_ENTRY EventList;
    //
    // Flags for the object
    //
    ULONG Flags;
} DEBUG_OBJECT, *PDEBUG_OBJECT;

VOID
DbgkCreateThread(
    PVOID StartAddress
    );

VOID
DbgkExitThread(
    NTSTATUS ExitStatus
    );

VOID
DbgkExitProcess(
    NTSTATUS ExitStatus
    );

VOID
DbgkMapViewOfSection(
    IN HANDLE SectionHandle,
    IN PVOID BaseAddress,
    IN ULONG SectionOffset,
    IN ULONG_PTR ViewSize
    );

VOID
DbgkUnMapViewOfSection(
    IN PVOID BaseAddress
    );

BOOLEAN
DbgkForwardException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN DebugException,
    IN BOOLEAN SecondChance
    );

NTSTATUS
DbgkInitialize (
    VOID
    );

VOID
DbgkCopyProcessDebugPort (
    IN PEPROCESS TargetProcess,
    IN PEPROCESS SourceProcess
    );

NTSTATUS
DbgkOpenProcessDebugPort (
    IN PEPROCESS TargetProcess,
    IN KPROCESSOR_MODE PreviousMode,
    OUT HANDLE *pHandle
    );

NTSTATUS
DbgkClearProcessDebugObject (
    IN PEPROCESS Process,
    IN PDEBUG_OBJECT SourceDebugObject
    );


extern POBJECT_TYPE DbgkDebugObjectType;


#endif // _DBGK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\cmdata.h ===
//depot/main/Base/ntos/inc/cmdata.h#8 - integrate change 19035 (text)
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    cmdata.h

Abstract:

    This module contains data structures used by the 
    configuration manager.

Author:

    Dragos C. Sambotin (dragoss) 13-Jan-99

Revision History:

--*/

#ifndef __CM_DATA__
#define __CM_DATA__

// \nt\private\ntos\inc\hivedata.h
#include "hivedata.h"


//
// Limits on lengths of names, all in BYTES, all INCLUDING nulls.
//

#define MAX_KEY_PATH_LENGTH         65535       
#define MAX_FRIENDLY_NAME_LENGTH    160         // allow for 80  unicode chars in FriendlyNames


//
// ----- Control structures, object manager structures ------
//


//
// CM_KEY_CONTROL_BLOCK
//
// One key control block exists for each open key.  All of the key objects
// (open instances) for the key refer to the key control block.
//


typedef ULONG HASH_VALUE;

typedef struct _CM_KEY_HASH {
    ULONG   ConvKey;
    struct _CM_KEY_HASH *NextHash;
    PHHIVE     KeyHive;                         // Hive containing CM_KEY_NODE
    HCELL_INDEX KeyCell;                        // Cell containing CM_KEY_NODE
} CM_KEY_HASH, *PCM_KEY_HASH;

#ifdef CM_DEBUG_KCB
#define KCB_SIGNATURE 'bKmC'

#define SET_KCB_SIGNATURE(_kcb_,_sig_) (_kcb_)->Signature = (_sig_)
#define ASSERT_KCB(_kcb_) ASSERT((_kcb_)->Signature == KCB_SIGNATURE)
#define ASSERT_KEY_HASH(_keyhash_) ASSERT_KCB(CONTAINING_RECORD((_keyhash_), CM_KEY_CONTROL_BLOCK, KeyHash))
#else
#define SET_KCB_SIGNATURE(_kcb_,_sig_)
#define ASSERT_KCB(_kcb_)
#define ASSERT_KEY_HASH(_keyhash_)
#endif



//
// The registry is a large data structure that has had poor locality.
// To improve performance without changing the on disk structure, we
// cache the frequently used registry data to minimize reference on
// registry data.
//
// A KCB (Key Control Block) is the core structure for registry cache.
// It uses HashValue for quick cache lookup and contains the most
// frequently used data in a key node.
//
// It contains the most frequently used data in a key node:
// Security, Flags, and Value index.
//
// A KCB may also contains additional information
// (which are cached lazily) about its subkeys, value nodes and values' data.
//
// The subkey information is distinquished by ExtFlags.  See CM_KCB_* below.
// The value nodes and data are distinguished by a bit in the vairable.
// See CMP_IS_CELL_CACHED.
//
// Caches for value data will be created during query process, the cached
// structure is shown as the following picture.  The structure is almost
// the same as the registry structure
// except they are pointers to the allocation instead of offset index on hive.
//
// To minimize the name string storage space KCB's,  we do not store the complete
// path name of the key in the kcb, instead, we implemented the tree structure
// (like the registry hive structure) to share name prefix.
// Also, knowing that there are lots of keys sharing same names,
// we create NameBlock strucuture so KCB's of same names
// can share the NameBlock.  NameBlock is compressed.
//
// Meanings when the following bits are set in ExtFlags:
// 1. The following bits are used for Parse and are for
//    non-symbolic keys.  Also, at most one bit can be set at any given time.
//    CM_KCB_KEY_NON_EXIST : This key is a fake key (no such key in the hive).
//    CM_KCB_NO_SUBKEY     : This key is has no subkey.
//    CM_KCB_SUBKEY_ONE    : This key has only one subkey and IndexHint is
//                           the first four characters of this subkey.
//    CM_KCB_SUBKEY_HINT   : This key has the first four characters of all
//                           its subkeys (buffer pointed by IndexHint).
//
// 2. CM_KCB_SYM_LINK_FOUND: This bit is only for symbolic keys.  It
//                           indicates that the symbolic link has been
//                           resolved and the KCB for the link is pointed to
//                           by ValueCache.RealKcb.
//                           In this case, the Value Index of this key is no longer
//                           available in the KCB.  (We hardly query the value
//                           of a symbolic link key other than finding the path
//                           of the real key anyway).
//
// 3. CM_KCB_NO_DELAY_CLOSE: This bit is only used for non-symbolic keys and is
//                           independent of bits on item 1. When set, it indicates that
//                           key should not be kept in delay close when the refererence
//                           count goes to zero.
//                           This is for the case when a key has no open handles but
//                           still has subkeys in the cache.
//                           When its last subkey is kicked out of cache, we do not
//                           want to keep this key around.
//                           This is done so CmpSearchForOpenSubKeysInCachen can clean
//                           up the cache properly before a key can be unloaded.
//
//
//   KCB
//   +-------------------+
//   | ...               |      (Typical case)
//   +-------------------+      Value Index
//   | ValueCache        |  +-->+---------+         Value Key (with small data)
//   +  +----------------+  |   |        o--------->+-----------+
//   |  | ValueList     o---+   +---------+         | ....      |
//   |  +---- Union -----|      |         |         +-----------+
//   |  | RealKcb       o---+   +---------+         | Data (S)  |
//   |  +----------------|  |   |         |         +-----------+
//   |                   |  |   +---------+
//   |                   |  |   |         |
//   |                   |  |   +---------+         Value Key (with large data)
//   |                   |  |   |        o--------->+-----------+
//   |                   |  |   +---------+         | ...       |
//   |                   |  |   |         |         +-----------+
//   |                   |  |   +---------+         | Data (L) o------+
//   |                   |  |                       +-----------+     |
//   |                   |  |                       |           | <---+ (Append at the end of Value Node)
//   |                   |  |                       |           |
//   |                   |  |                       |           |
//   |                   |  |                       +-----------+
//   |                   |  |
//   |                   |  |   KCB (Symbolic link key, CM_KCB_SYM_LINK_FOUND set).
//   |                   |  +-->+---------+
//   |                   |      |         |
//   |                   |      |         |
//   |                   |      |         |
//   |                   |      |         |
//   |                   |      |         |
//   |                   |      +---------+
//   |                   |
//   | ...               |
//   +-------------------+      Index Hint
//   | IndexHint        o------>+---------+
//   +-------------------+      | 4 char  |
//   |                   |      +---------+
//   |                   |      | 4 char  |
//   +-------------------+      +---------+
//   |                   |      (CM_KCB_SUBKEY_HINT)
//   |                   |
//   |                   |
//   +-------------------+                 Name Block
//   | NameBlock        o----------------->+----------+
//   +-------------------+                 |          |
//                                         +----------+
//
//
// The TotalLevels is used for quick comparison for notification and cache lookup.
//
// *** MP Synchronization ***
// The KCB lock is held for any write to KCB unless the registry is locked exclusively.
// KCB is also locked while reading fields that can be modified by another thread
// during a read operation, i.e., when the registry lock is held shared.
//
// The fields are the follows: ExtFlags, ValueCache, IndexInfo, IndexHint, or NameHint.
//
// Reading of other entries in the KCB does not need to hold the KCB lock since
// these entries will not change for any registry read operation.  When there
// are changes to these entries, registry must be locked exclusively.
//
// NOTE: the KCB size is 56 bytes now, plus the pool header of 8 bytes,
//       it fits into a 64byte allocation.  Think carefully if you want to
//       enlarge the data structure.  Also, watch it if the pool allocation code changes.
//
//       The RefCount in KCB is the number of open handles plus the number of cached subkeys.
//       We can change this by having a RefCount and a CachedSubKeyCount.  To not grow the
//       structure size, we can merge the boolean Delete into ExtFlags.

typedef struct _CM_NAME_HASH {
    ULONG   ConvKey;
    struct _CM_NAME_HASH *NextHash;
    USHORT  NameLength;      // Length of string value
    WCHAR   Name[1] ;      // The actual string value
} CM_NAME_HASH, *PCM_NAME_HASH;

//
// !!! In Whistler, the Name in the NameBlock is Always UpperCase !!!
//
typedef struct _CM_NAME_CONTROL_BLOCK {
    BOOLEAN     Compressed;       // Flags to indicate which extension we have.
    USHORT      RefCount;
    union {
        CM_NAME_HASH             NameHash;
        struct {
            ULONG   ConvKey;
            struct _CM_KEY_HASH *NextHash;
            USHORT  NameLength;      // Length of string value
            WCHAR   Name[1] ;      // The actual string value
        };
    };
} CM_NAME_CONTROL_BLOCK, *PCM_NAME_CONTROL_BLOCK;

typedef struct _CM_INDEX_HINT_BLOCK {
    ULONG   Count;
    ULONG   HashKey[1];        // hash key of name

} CM_INDEX_HINT_BLOCK, *PCM_INDEX_HINT_BLOCK;

typedef struct _CACHED_CHILD_LIST {
    ULONG       Count;                  // 0 for empty list
    union {
        ULONG_PTR   ValueList;
        struct _CM_KEY_CONTROL_BLOCK *RealKcb;
    };
} CACHED_CHILD_LIST, *PCACHED_CHILD_LIST;

//
// Define the HINT Length used
//
#define CM_SUBKEY_HINT_LENGTH   4
#define CM_MAX_CACHE_HINT_SIZE 14

//
// ----- Structures used to implement registry hierarchy -----
//

typedef enum _NODE_TYPE {
    KeyBodyNode,
    KeyValueNode
} NODE_TYPE;


typedef enum _CMP_COPY_TYPE {
    Copy,
    Sync,
    Merge
} CMP_COPY_TYPE;

typedef enum _SUBKEY_SEARCH_TYPE {
    SearchIfExist,
    SearchAndDeref,
    SearchAndCount,
    SearchAndRehash,
	SearchAndTagNoDelayClose
} SUBKEY_SEARCH_TYPE;

//
// ChildList
//
//      NOTE:   CHILD_LIST structures are normally refered to
//              with HCELL_INDEX, not PCHILD_LIST vars.
//

typedef struct _CHILD_LIST {
    ULONG       Count;                  // 0 for empty list
    HCELL_INDEX List;
} CHILD_LIST, *PCHILD_LIST;

//
// CM_KEY_REFERENCE
//

typedef struct  _CM_KEY_REFERENCE {
    HCELL_INDEX KeyCell;
    PHHIVE      KeyHive;
} CM_KEY_REFERENCE , *PCM_KEY_REFERENCE;

//
// ----- CM_KEY_INDEX -----
//
// A leaf index may be one of two types. The "old" CM_KEY_INDEX type is used for
// hives circa NT3.1, 3.5, and 3.51. NT4.0 introduces the newer CM_KEY_FAST_INDEX
// which is used for all leaf indexes that have less than CM_MAX_FAST_INDEX leaves.
//
// The main advantage of the fast index is that the first four characters of the
// names are stored within the index itself. This almost always saves us from having
// to fault in a number of unneccessary pages when searching for a given key.
//
// The main disadvantage is that each subkey requires twice as much storage. One dword
// for the HCELL_INDEX and one dword to hold the first four characters of the subkey
// name. If one of the first four characters in the subkey name is a unicode character
// where the high byte is non-zero, the actual subkey must be examined to determine the
// name.
//
// Hive version 1 & 2 do not support the fast index. Version 3 adds support for the
// fast index. All hives that are newly created on a V3-capable system are therefore
// unreadable on V1 & 2 systems.
//
// N.B. There is code in cmindex.c that relies on the Signature and Count fields of
//      CM_KEY_INDEX and CM_KEY_FAST_INDEX being at the same offset in the structure!

#define INVALID_INDEX           0x80000000  // index is not valid

#define UseFastIndex(Hive)      ((Hive)->Version >= 3)
#define UseHashIndex(Hive)      ((Hive)->Version >= HSYS_WHISTLER)

#define CM_KEY_INDEX_ROOT       0x6972      // ir
#define CM_KEY_INDEX_LEAF       0x696c      // il
#define CM_KEY_FAST_LEAF        0x666c      // fl
#define CM_KEY_HASH_LEAF        0x686c      // hl

typedef struct _CM_INDEX {
    HCELL_INDEX Cell;
    union {
        UCHAR       NameHint[4];    // upcased first four chars of name 
        ULONG       HashKey;        // hash key of name
    };
} CM_INDEX, *PCM_INDEX;

typedef struct _CM_KEY_FAST_INDEX {
    USHORT      Signature;              // also type selector
    USHORT      Count;
    CM_INDEX    List[1];                // Variable sized array
} CM_KEY_FAST_INDEX, *PCM_KEY_FAST_INDEX;

typedef struct _CM_KEY_INDEX {
    USHORT      Signature;              // also type selector
    USHORT      Count;
    HCELL_INDEX List[1];                // Variable sized array
} CM_KEY_INDEX, *PCM_KEY_INDEX;

//
// Allow index to grow to size that will cause allocation of exactly
// one logical block.  Works out to be 1013 entries.
//
#define CM_MAX_INDEX                                                        \
 ( (HBLOCK_SIZE-                                                             \
    (sizeof(HBIN)+FIELD_OFFSET(HCELL,u)+FIELD_OFFSET(CM_KEY_INDEX,List))) /  \
    sizeof(HCELL_INDEX) )

#define CM_MAX_LEAF_SIZE ((sizeof(HCELL_INDEX)*CM_MAX_INDEX) + \
                          (FIELD_OFFSET(CM_KEY_INDEX, List)))

//
// Allow index to grow to size that will cause allocation of exactly
// one logical block.  Works out to be approx. 500 entries.
//
#define CM_MAX_FAST_INDEX                                                    \
 ( (HBLOCK_SIZE-                                                             \
    (sizeof(HBIN)+FIELD_OFFSET(HCELL,u)+FIELD_OFFSET(CM_KEY_FAST_INDEX,List))) /  \
    sizeof(CM_INDEX) )

#define CM_MAX_FAST_LEAF_SIZE ((sizeof(CM_INDEX)*CM_MAX_FAST_INDEX) + \
                          (FIELD_OFFSET(CM_KEY_FAST_INDEX, List)))



//
// ----- CM_KEY_NODE -----
//

#define CM_KEY_NODE_SIGNATURE     0x6b6e           // "kn"
#define CM_LINK_NODE_SIGNATURE     0x6b6c          // "kl"

#define KEY_VOLATILE        0x0001      // This key (and all its children)
                                        // is volatile.

#define KEY_HIVE_EXIT       0x0002      // This key marks a bounary to another
                                        // hive (sort of a link).  The null
                                        // value entry contains the hive
                                        // and hive index of the root of the
                                        // child hive.

#define KEY_HIVE_ENTRY      0x0004      // This key is the root of a particular
                                        // hive.

#define KEY_NO_DELETE       0x0008      // This key cannot be deleted, period.

#define KEY_SYM_LINK        0x0010      // This key is really a symbolic link.
#define KEY_COMP_NAME       0x0020      // The name for this key is stored in a
                                        // compressed form.
#define KEY_PREDEF_HANDLE   0x0040      // There is no real key backing this,
                                        // return the predefined handle.
                                        // Predefined handles are stashed in
                                        // ValueList.Count.

#define KEY_USER_FLAGS_CLEAR_MASK   0x0FFF  // used to clear the user defined flags

#define KEY_USER_FLAGS_VALID_MASK   0x000F  // we only allow 4 bits for the user defined flags
                                            // (this is just for the time being) - we may extend 
                                            // this as we see fit)

#define KEY_USER_FLAGS_SHIFT        12      // shift count (to be updated if we change the number of flags)

#define KEY_BREAK_ON_OPEN		    0x8000  // used to determine if we need to break to dbg

#pragma pack(4)
typedef struct _CM_KEY_NODE {
    USHORT      Signature;
    USHORT      Flags;                      // first 4 bits are User defined flags !!!!
    LARGE_INTEGER LastWriteTime;
    ULONG       Spare;                      // not used, yet
    HCELL_INDEX Parent;
    ULONG       SubKeyCounts[HTYPE_COUNT];  // Stable and Volatile
    union {
        struct {
            HCELL_INDEX SubKeyLists[HTYPE_COUNT];   // Stable and Volatile
            CHILD_LIST  ValueList;
        };
        CM_KEY_REFERENCE    ChildHiveReference;
    };

    HCELL_INDEX Security;
    HCELL_INDEX Class;
    ULONG       MaxNameLen;
    ULONG       MaxClassLen;
    ULONG       MaxValueNameLen;
    ULONG       MaxValueDataLen;

    ULONG       WorkVar;                // WARNING: This DWORD is used
                                        //          by the system at run
                                        //          time, do attempt to
                                        //          store user data in it.

    USHORT      NameLength;
    USHORT      ClassLength;
    WCHAR       Name[1];                // Variable sized array
} CM_KEY_NODE, *PCM_KEY_NODE;
#pragma pack()

//
// ----- CM_KEY_VALUE -----
//

#define CM_KEY_VALUE_SIGNATURE      0x6b76                      // "kv"

#define CM_KEY_VALUE_SPECIAL_SIZE   0x80000000                  // 2 gig

#define CM_KEY_VALUE_SMALL          4


#define CM_KEY_VALUE_BIG            0x3fd8 // 16K ; Only new hive formats will have this
//
//  The above comes from this:
// (0x4000 - sizeof(HBIN) - ROUND_UP(FIELD_OFFSET(HCELL, u.NewCell.u.UserData),8) ) 
//


#define VALUE_COMP_NAME             0x0001                      // The name for this value is stored in a
                                                                // compressed form.
typedef struct _CM_KEY_VALUE {
    USHORT      Signature;
    USHORT      NameLength;
    ULONG       DataLength;
    HCELL_INDEX Data;
    ULONG       Type;
    USHORT      Flags;                      // Used to be TitleIndex
    USHORT      Spare;                      // Used to be TitleIndex
    WCHAR       Name[1];                    // Variable sized array
} CM_KEY_VALUE, *PCM_KEY_VALUE;

//
// realsize is set to real size, returns TRUE if small, else FALSE
//
#define CmpIsHKeyValueSmall(realsize, size)                     \
        ((size >= CM_KEY_VALUE_SPECIAL_SIZE) ?                  \
        ((realsize) = size - CM_KEY_VALUE_SPECIAL_SIZE, TRUE) : \
        ((realsize) = size, FALSE))

#define CmpIsHKeyValueBig(Hive,size)   ( (Hive->Version >= HSYS_WHISTLER_BETA1) && ((size) < CM_KEY_VALUE_SPECIAL_SIZE) && ((size) > CM_KEY_VALUE_BIG ) )

#define  ASSERT_KEY_VALUE(Value) ASSERT( (Value)->Signature == CM_KEY_VALUE_SIGNATURE )
//
// ----- CM_BIG_DATA ------
//

#define CM_BIG_DATA_SIGNATURE      0x6264                      // "bd"

typedef struct _CM_BIG_DATA {
    USHORT      Signature;
    USHORT      Count;              // 0 for empty list; this shouldn't happen
    HCELL_INDEX List;               // HCELL_NIL for empty list; this shouldn't happen
} CM_BIG_DATA, *PCM_BIG_DATA;

#define ASSERT_BIG_DATA(BigData) ASSERT( ((BigData)->Signature == CM_BIG_DATA_SIGNATURE) && ((BigData)->Count > 0 ) && ((BigData)->List != HCELL_NIL) );

//
// ----- CM_KEY_SECURITY -----
//

#define CM_KEY_SECURITY_SIGNATURE 0x6b73              // "ks"

typedef struct _CM_KEY_SECURITY {
    USHORT                  Signature;
    USHORT                  Reserved;
    HCELL_INDEX             Flink;
    HCELL_INDEX             Blink;
    ULONG                   ReferenceCount;
    ULONG                   DescriptorLength;
    SECURITY_DESCRIPTOR_RELATIVE     Descriptor;         // Variable length
} CM_KEY_SECURITY, *PCM_KEY_SECURITY;

//
// ----- CM_KEY_SECURITY_CACHE ----
//

typedef struct _CM_KEY_SECURITY_CACHE {
    HCELL_INDEX                     Cell;                   // security cellindex (inside the hive)
    ULONG                           ConvKey;                
    LIST_ENTRY                      List;
    ULONG                           DescriptorLength;
    SECURITY_DESCRIPTOR_RELATIVE    Descriptor;         // Variable length
} CM_KEY_SECURITY_CACHE, *PCM_KEY_SECURITY_CACHE;

typedef struct _CM_KEY_SECURITY_CACHE_ENTRY {
    HCELL_INDEX             Cell;                   // security cellindex (inside the hive) - 
                                                    // this is to avoid touching the Security pages 
                                                    // at lookup operations                                                        

    PCM_KEY_SECURITY_CACHE  CachedSecurity;               // actual security cell (cached)
} CM_KEY_SECURITY_CACHE_ENTRY, *PCM_KEY_SECURITY_CACHE_ENTRY;



//
// ----- CELL_DATA -----
//
// Union of types of data that could be in a cell
//

typedef struct _CELL_DATA {
    union _u {
        CM_KEY_NODE      KeyNode;
        CM_KEY_VALUE     KeyValue;
        CM_KEY_SECURITY  KeySecurity;    // Variable security descriptor length
        CM_KEY_INDEX     KeyIndex;       // Variable sized structure
        CM_BIG_DATA      ValueData;      // This is only for big cells; a list of cells 
                                         // all of the length CM_KEY_VALUE_BIG
        HCELL_INDEX      KeyList[1];     // Variable sized array
        WCHAR            KeyString[1];   // Variable sized array
    } u;
} CELL_DATA, *PCELL_DATA;


//
// Unions for KEY_INFORMATION, KEY_VALUE_INFORMATION
//

typedef union _KEY_INFORMATION {
    KEY_BASIC_INFORMATION   KeyBasicInformation;
    KEY_NODE_INFORMATION    KeyNodeInformation;
    KEY_FULL_INFORMATION    KeyFullInformation;
    KEY_NAME_INFORMATION    KeyNameInformation;
    KEY_CACHED_INFORMATION  KeyCachedInformation;
    KEY_FLAGS_INFORMATION   KeyFlagsInformation;
} KEY_INFORMATION, *PKEY_INFORMATION;

typedef union _KEY_VALUE_INFORMATION {
    KEY_VALUE_BASIC_INFORMATION KeyValueBasicInformation;
    KEY_VALUE_FULL_INFORMATION  KeyValueFullInformation;
    KEY_VALUE_PARTIAL_INFORMATION KeyValuePartialInformation;
    KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 KeyValuePartialInformationAlign64;
} KEY_VALUE_INFORMATION, *PKEY_VALUE_INFORMATION;



//
// ----- CACHED_DATA -----
//
// When values are not cached, List in ValueCache is the Hive cell index to the value list.
// When they are cached, List will be pointer to the allocation.  We distinguish them by
// marking the lowest bit in the variable to indicate it is a cached allocation.
//
// Note that the cell index for value list
// is stored in the cached allocation.  It is not used now but may be in further performance
// optimization.
//
// When value key and vaule data are cached, there is only one allocation for both.
// Value data is appended that the end of value key.  DataCacheType indicates
// whether data is cached and ValueKeySize tells how big is the value key (so
// we can calculate the address of cached value data)
//
//

#define CM_CACHE_DATA_NOT_CACHED 0
#define CM_CACHE_DATA_CACHED     1
#define CM_CACHE_DATA_TOO_BIG    2
#define MAXIMUM_CACHED_DATA   2048  // Maximum data size to be cached.

typedef struct _CM_CACHED_VALUE_INDEX {
    HCELL_INDEX CellIndex;
    union {
        CELL_DATA        CellData;
        ULONG_PTR        List[1];
    } Data;
} CM_CACHED_VALUE_INDEX, *PCM_CACHED_VALUE_INDEX; // This is only used as a pointer.

typedef struct _CM_CACHED_VALUE {
    USHORT DataCacheType;
    USHORT ValueKeySize;
    CM_KEY_VALUE  KeyValue;
} CM_CACHED_VALUE, *PCM_CACHED_VALUE; // This is only used as a pointer.

typedef PCM_CACHED_VALUE *PPCM_CACHED_VALUE;

#define CMP_CELL_CACHED_MASK  1

#define CMP_IS_CELL_CACHED(Cell) (((ULONG_PTR) (Cell) & CMP_CELL_CACHED_MASK) && ((Cell) != (ULONG_PTR) HCELL_NIL))
#define CMP_GET_CACHED_ADDRESS(Cell) (((ULONG_PTR) (Cell)) & ~CMP_CELL_CACHED_MASK)
#define CMP_GET_CACHED_CELLDATA(Cell) (&(((PCM_CACHED_VALUE_INDEX)(((ULONG_PTR) (Cell)) & ~CMP_CELL_CACHED_MASK))->Data.CellData))
#define CMP_GET_CACHED_KEYVALUE(Cell) (&(((PCM_CACHED_VALUE)(((ULONG_PTR) (Cell)) & ~CMP_CELL_CACHED_MASK))->KeyValue))
#define CMP_GET_CACHED_CELL(Cell) (((PCM_CACHED_ENTRY)(((ULONG_PTR) (Cell)) & ~CMP_CELL_CACHED_MASK))->CellIndex)
#define CMP_MARK_CELL_CACHED(Cell) (((ULONG_PTR) (Cell)) | CMP_CELL_CACHED_MASK)

#define CMP_GET_CACHED_CELL_INDEX(Cell) (PtrToUlong((PVOID) (Cell)))



// Dragos: From here start the changes!!!


//
// Bits used in the ExtFlags in KCB.
//

#define CM_KCB_NO_SUBKEY        0x0001      // This key has no subkeys
#define CM_KCB_SUBKEY_ONE       0x0002      // This key has only one subkey and the
                                            // first 4 char
                                            //
#define CM_KCB_SUBKEY_HINT          0x0004
#define CM_KCB_SYM_LINK_FOUND       0x0008
#define CM_KCB_KEY_NON_EXIST        0x0010
#define CM_KCB_NO_DELAY_CLOSE       0x0020
#define CM_KCB_INVALID_CACHED_INFO  0x0040  // info stored in SubKeyCount is not valid, so we shouldn't rely on it

#define CM_KCB_CACHE_MASK (CM_KCB_NO_SUBKEY | \
                           CM_KCB_KEY_NON_EXIST | \
                           CM_KCB_SUBKEY_ONE | \
                           CM_KCB_SUBKEY_HINT)

#define CM_KCB_READ_ONLY_KEY        0x0080  // this kcb is read-only all write operations onto it are denied.

typedef struct _CM_KEY_CONTROL_BLOCK {
#ifdef CM_DEBUG_KCB
    ULONG                       Signature;
#endif
    USHORT                      RefCount;
    USHORT                      Flags;          // Same Flags as KeyNode

    struct {
        ULONG                   ExtFlags            : 8;  // 00000000 00000000 00000000 ????????  Flags to indicate which extension we have.
        ULONG                   PrivateAlloc        : 1;  // 00000000 00000000 0000000? 00000000  are we allocated from our private pool?
        ULONG                   Delete              : 1;  // 00000000 00000000 000000?0 00000000
        ULONG                   DelayedCloseIndex   : 12; // 00000000 00?????? ??????00 00000000  CmpDelayedCloseSize  means it is 
                                                          //                                      not in the delay close table
        ULONG                   TotalLevels         : 10; // ???????? ??000000 00000000 00000000  max 512
    };

    union {
        CM_KEY_HASH             KeyHash;
        struct {
            ULONG               ConvKey;
            struct _CM_KEY_HASH *NextHash;
            PHHIVE              KeyHive;        // Hive containing CM_KEY_NODE
            HCELL_INDEX         KeyCell;        // Cell containing CM_KEY_NODE
        };
    };

    struct _CM_KEY_CONTROL_BLOCK *ParentKcb;
    PCM_NAME_CONTROL_BLOCK      NameBlock;

    PCM_KEY_SECURITY_CACHE      CachedSecurity; // pointer to cached security
    struct _CACHED_CHILD_LIST   ValueCache;
    union {                                                         // The hint is always stored in uppercase.
        PCM_INDEX_HINT_BLOCK    IndexHint;                          // CM_KCB_SUBKEY_HINT
        ULONG                   HashKey;                            // CM_KCB_SUBKEY_ONE
        ULONG                   SubKeyCount;                        // when none of the  CM_KCB_NO_SUBKEY | CM_KCB_SUBKEY_ONE | CM_KCB_SUBKEY_HINT
                                                                    // is set in ExtFlags, we cache here the number of subkeys
                                                                    // (Node->SubKeyCounts[Stable] + Node->SubKeyCounts[Volatile])
    };

    union {
        LIST_ENTRY                  KeyBodyListHead;    // head of the list with all key_nodes using this kcb 
        LIST_ENTRY                  FreeListEntry;      // entry in the free kcbs list inside a page - when we use the private allocator
    };

    //
    // Bellow is information cached from KEY_NODE for performance reasons.
    // Values here should be IDENTICAL with the ones in the corresponding KEY_NODE
    //
    LARGE_INTEGER               KcbLastWriteTime;  
    USHORT                      KcbMaxNameLen;
    USHORT                      KcbMaxValueNameLen;
    ULONG                       KcbMaxValueDataLen;

} CM_KEY_CONTROL_BLOCK, *PCM_KEY_CONTROL_BLOCK;


#endif //__CM_DATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efierr.h ===
#ifndef _EFI_ERR_H
#define _EFI_ERR_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efierr.h

Abstract:

    EFI error codes




Revision History

--*/


#define EFIWARN(a)                            (a)
#define EFI_ERROR(a)              (((INTN) a) < 0)


#define EFI_SUCCESS                             0
#define EFI_LOAD_ERROR                  EFIERR(1)
#define EFI_INVALID_PARAMETER           EFIERR(2)
#define EFI_UNSUPPORTED                 EFIERR(3)
#define EFI_BAD_BUFFER_SIZE             EFIERR(4)
#define EFI_BUFFER_TOO_SMALL            EFIERR(5)
#define EFI_NOT_READY                   EFIERR(6)
#define EFI_DEVICE_ERROR                EFIERR(7)
#define EFI_WRITE_PROTECTED             EFIERR(8)
#define EFI_OUT_OF_RESOURCES            EFIERR(9)
#define EFI_VOLUME_CORRUPTED            EFIERR(10)
#define EFI_VOLUME_FULL                 EFIERR(11)
#define EFI_NO_MEDIA                    EFIERR(12)
#define EFI_MEDIA_CHANGED               EFIERR(13)
#define EFI_NOT_FOUND                   EFIERR(14)
#define EFI_ACCESS_DENIED               EFIERR(15)
#define EFI_NO_RESPONSE                 EFIERR(16)
#define EFI_NO_MAPPING                  EFIERR(17)
#define EFI_TIMEOUT                     EFIERR(18)
#define EFI_NOT_STARTED                 EFIERR(19)
#define EFI_ALREADY_STARTED             EFIERR(20)
#define EFI_ABORTED                     EFIERR(21)
#define EFI_ICMP_ERROR                  EFIERR(22)
#define EFI_TFTP_ERROR                  EFIERR(23)
#define EFI_PROTOCOL_ERROR              EFIERR(24)

#define EFI_WARN_UNKOWN_GLYPH           EFIWARN(1)
#define EFI_WARN_DELETE_FAILURE         EFIWARN(2)
#define EFI_WARN_WRITE_FAILURE          EFIWARN(3)
#define EFI_WARN_BUFFER_TOO_SMALL       EFIWARN(4)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efiapi.h ===
#ifndef _EFI_API_H
#define _EFI_API_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efiapi.h

Abstract:

    Global EFI runtime & boot service interfaces




Revision History

--*/

/* 
 *  EFI Specification Revision
 */

#define EFI_SPECIFICATION_MAJOR_REVISION 0
#define EFI_SPECIFICATION_MINOR_REVISION 99

/* 
 *  Declare forward referenced data structures
 */

INTERFACE_DECL(_EFI_SYSTEM_TABLE);

/* 
 *  EFI Memory
 */

typedef
EFI_STATUS
(EFIAPI *EFI_ALLOCATE_PAGES) (
    IN EFI_ALLOCATE_TYPE            Type,
    IN EFI_MEMORY_TYPE              MemoryType,
    IN UINTN                        NoPages,
    OUT EFI_PHYSICAL_ADDRESS        *Memory
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FREE_PAGES) (
    IN EFI_PHYSICAL_ADDRESS         Memory,
    IN UINTN                        NoPages
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_MEMORY_MAP) (
    IN OUT UINTN                    *MemoryMapSize,
    IN OUT EFI_MEMORY_DESCRIPTOR    *MemoryMap,
    OUT UINTN                       *MapKey,
    OUT UINTN                       *DescriptorSize,
    OUT UINT32                      *DescriptorVersion
    );

#define NextMemoryDescriptor(Ptr,Size)  ((EFI_MEMORY_DESCRIPTOR *) (((UINT8 *) Ptr) + Size))


typedef
EFI_STATUS
(EFIAPI *EFI_ALLOCATE_POOL) (
    IN EFI_MEMORY_TYPE              PoolType,
    IN UINTN                        Size,
    OUT VOID                        **Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FREE_POOL) (
    IN VOID                         *Buffer
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP) (
    IN UINTN                        MemoryMapSize,
    IN UINTN                        DescriptorSize,
    IN UINT32                       DescriptorVersion,
    IN EFI_MEMORY_DESCRIPTOR        *VirtualMap
    );


#define EFI_OPTIONAL_PTR            0x00000001
#define EFI_INTERNAL_FNC            0x00000002      /*  Pointer to internal runtime fnc */
#define EFI_INTERNAL_PTR            0x00000004      /*  Pointer to internal runtime data */


typedef 
EFI_STATUS
(EFIAPI *EFI_CONVERT_POINTER) (
    IN UINTN                        DebugDisposition,
    IN OUT VOID                     **Address
    );


/* 
 *  EFI Events
 */



#define EVT_TIMER                           0x80000000
#define EVT_RUNTIME                         0x40000000
#define EVT_RUNTIME_CONTEXT                 0x20000000

#define EVT_NOTIFY_WAIT                     0x00000100
#define EVT_NOTIFY_SIGNAL                   0x00000200

#define EVT_SIGNAL_EXIT_BOOT_SERVICES       0x00000201
#define EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE   0x60000202

#define EVT_EFI_SIGNAL_MASK                 0x000000FF
#define EVT_EFI_SIGNAL_MAX                  2

typedef
VOID
(EFIAPI *EFI_EVENT_NOTIFY) (
    IN EFI_EVENT                Event,
    IN VOID                     *Context
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CREATE_EVENT) (
    IN UINT32                       Type,
    IN EFI_TPL                      NotifyTpl,
    IN EFI_EVENT_NOTIFY             NotifyFunction,
    IN VOID                         *NotifyContext,
    OUT EFI_EVENT                   *Event
    );

typedef enum {
    TimerCancel,
    TimerPeriodic,
    TimerRelative,
    TimerTypeMax
} EFI_TIMER_DELAY;

typedef
EFI_STATUS
(EFIAPI *EFI_SET_TIMER) (
    IN EFI_EVENT                Event,
    IN EFI_TIMER_DELAY          Type,
    IN UINT64                   TriggerTime
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SIGNAL_EVENT) (
    IN EFI_EVENT                Event
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_WAIT_FOR_EVENT) (
    IN UINTN                    NumberOfEvents,
    IN EFI_EVENT                *Event,
    OUT UINTN                   *Index
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CLOSE_EVENT) (
    IN EFI_EVENT                Event
    );

typedef
EFI_STATUS
(EFIAPI *EFI_CHECK_EVENT) (
    IN EFI_EVENT                Event
    );

/* 
 *  Task priority level
 */

#define TPL_APPLICATION    4
#define TPL_CALLBACK       8
#define TPL_NOTIFY        16 
#define TPL_HIGH_LEVEL    31 

typedef
EFI_TPL
(EFIAPI *EFI_RAISE_TPL) (
    IN EFI_TPL      NewTpl
    );

typedef
VOID
(EFIAPI *EFI_RESTORE_TPL) (
    IN EFI_TPL      OldTpl
    );


/* 
 *  EFI platform varibles
 */

#define EFI_GLOBAL_VARIABLE     \
    { 0x8BE4DF61, 0x93CA, 0x11d2, 0xAA, 0x0D, 0x00, 0xE0, 0x98, 0x03, 0x2B, 0x8C }

/*  Variable attributes */
#define EFI_VARIABLE_NON_VOLATILE           0x00000001
#define EFI_VARIABLE_BOOTSERVICE_ACCESS     0x00000002
#define EFI_VARIABLE_RUNTIME_ACCESS         0x00000004


typedef
EFI_STATUS
(EFIAPI *EFI_GET_VARIABLE) (
    IN CHAR16                       *VariableName,
    IN EFI_GUID                     *VendorGuid,
    OUT UINT32                      *Attributes OPTIONAL,
    IN OUT UINTN                    *DataSize,
    OUT VOID                        *Data
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME) (
    IN OUT UINTN                    *VariableNameSize,
    IN OUT CHAR16                   *VariableName,
    IN OUT EFI_GUID                 *VendorGuid
    );


typedef
EFI_STATUS
(EFIAPI *EFI_SET_VARIABLE) (
    IN CHAR16                       *VariableName,
    IN EFI_GUID                     *VendorGuid,
    IN UINT32                       Attributes,
    IN UINTN                        DataSize,
    IN VOID                         *Data
    );


/* 
 *  EFI Time
 */

typedef struct {
        UINT32                      Resolution;     /*  1e-6 parts per million */
        UINT32                      Accuracy;       /*  hertz */
        BOOLEAN                     SetsToZero;     /*  Set clears sub-second time */
} EFI_TIME_CAPABILITIES;


typedef
EFI_STATUS
(EFIAPI *EFI_GET_TIME) (
    OUT EFI_TIME                    *Time,
    OUT EFI_TIME_CAPABILITIES       *Capabilities OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SET_TIME) (
    IN EFI_TIME                     *Time
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_WAKEUP_TIME) (
    OUT BOOLEAN                     *Enabled,
    OUT BOOLEAN                     *Pending,
    OUT EFI_TIME                    *Time
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SET_WAKEUP_TIME) (
    IN BOOLEAN                      Enable,
    IN EFI_TIME                     *Time OPTIONAL
    );


/* 
 *  Image functions
 */


/*  PE32+ Subsystem type for EFI images */

#if !defined(IMAGE_SUBSYSTEM_EFI_APPLICATION)
#define IMAGE_SUBSYSTEM_EFI_APPLICATION             10
#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER     11
#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER          12
#endif

/*  PE32+ Machine type for EFI images */

#if !defined(EFI_IMAGE_MACHINE_IA32)
#define EFI_IMAGE_MACHINE_IA32      0x014c
#endif

#if !defined(EFI_IMAGE_MACHINE_IA64)
#define EFI_IMAGE_MACHINE_IA64      0x0200
#endif

/*  Image Entry prototype */

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_ENTRY_POINT) (
    IN EFI_HANDLE                   ImageHandle,
    IN struct _EFI_SYSTEM_TABLE     *SystemTable
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_LOAD) (
    IN BOOLEAN                      BootPolicy,
    IN EFI_HANDLE                   ParentImageHandle,
    IN EFI_DEVICE_PATH              *FilePath,
    IN VOID                         *SourceBuffer   OPTIONAL,
    IN UINTN                        SourceSize,
    OUT EFI_HANDLE                  *ImageHandle
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_START) (
    IN EFI_HANDLE                   ImageHandle,
    OUT UINTN                       *ExitDataSize,
    OUT CHAR16                      **ExitData  OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_EXIT) (
    IN EFI_HANDLE                   ImageHandle,
    IN EFI_STATUS                   ExitStatus,
    IN UINTN                        ExitDataSize,
    IN CHAR16                       *ExitData OPTIONAL
    );

typedef 
EFI_STATUS
(EFIAPI *EFI_IMAGE_UNLOAD) (
    IN EFI_HANDLE                   ImageHandle
    );


/*  Image handle */
#define LOADED_IMAGE_PROTOCOL      \
    { 0x5B1B31A1, 0x9562, 0x11d2, 0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B }

#define EFI_IMAGE_INFORMATION_REVISION      0x1000
typedef struct {
    UINT32                          Revision;
    EFI_HANDLE                      ParentHandle;
    struct _EFI_SYSTEM_TABLE        *SystemTable;

    /*  Source location of image */
    EFI_HANDLE                      DeviceHandle;
    EFI_DEVICE_PATH                 *FilePath;
    VOID                            *Reserved;

    /*  Images load options */
    UINT32                          LoadOptionsSize;
    VOID                            *LoadOptions;

    /*  Location of where image was loaded */
    VOID                            *ImageBase;
    UINT64                          ImageSize;
    EFI_MEMORY_TYPE                 ImageCodeType;
    EFI_MEMORY_TYPE                 ImageDataType;

    /*  If the driver image supports a dynamic unload request */
    EFI_IMAGE_UNLOAD                Unload;

} EFI_LOADED_IMAGE;


typedef
EFI_STATUS
(EFIAPI *EFI_EXIT_BOOT_SERVICES) (
    IN EFI_HANDLE                   ImageHandle,
    IN UINTN                        MapKey
    );

/* 
 *  Misc
 */


typedef
EFI_STATUS
(EFIAPI *EFI_STALL) (
    IN UINTN                    Microseconds
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SET_WATCHDOG_TIMER) (
    IN UINTN                    Timeout,
    IN UINT64                   WatchdogCode,
    IN UINTN                    DataSize,
    IN CHAR16                   *WatchdogData OPTIONAL
    );


typedef enum {
    EfiResetCold,
    EfiResetWarm
} EFI_RESET_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_RESET_SYSTEM) (
    IN EFI_RESET_TYPE           ResetType,
    IN EFI_STATUS               ResetStatus,
    IN UINTN                    DataSize,
    IN CHAR16                   *ResetData OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_MONOTONIC_COUNT) (
    OUT UINT64                  *Count
    );

typedef
EFI_STATUS
(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT) (
    OUT UINT32                  *HighCount
    );

/* 
 *  Protocol handler functions
 */

typedef enum {
    EFI_NATIVE_INTERFACE,
    EFI_PCODE_INTERFACE
} EFI_INTERFACE_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_INSTALL_PROTOCOL_INTERFACE) (
    IN OUT EFI_HANDLE           *Handle,
    IN EFI_GUID                 *Protocol,
    IN EFI_INTERFACE_TYPE       InterfaceType,
    IN VOID                     *Interface
    );

typedef
EFI_STATUS
(EFIAPI *EFI_REINSTALL_PROTOCOL_INTERFACE) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    IN VOID                     *OldInterface,
    IN VOID                     *NewInterface
    );

typedef
EFI_STATUS
(EFIAPI *EFI_UNINSTALL_PROTOCOL_INTERFACE) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    IN VOID                     *Interface
    );

typedef
EFI_STATUS
(EFIAPI *EFI_HANDLE_PROTOCOL) (
    IN EFI_HANDLE               Handle,
    IN EFI_GUID                 *Protocol,
    OUT VOID                    **Interface
    );

typedef
EFI_STATUS 
(EFIAPI *EFI_REGISTER_PROTOCOL_NOTIFY) (
    IN EFI_GUID                 *Protocol,
    IN EFI_EVENT                Event,
    OUT VOID                    **Registration
    );

typedef enum {
    AllHandles,
    ByRegisterNotify,
    ByProtocol
} EFI_LOCATE_SEARCH_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_LOCATE_HANDLE) (
    IN EFI_LOCATE_SEARCH_TYPE   SearchType,
    IN EFI_GUID                 *Protocol OPTIONAL,
    IN VOID                     *SearchKey OPTIONAL,
    IN OUT UINTN                *BufferSize,
    OUT EFI_HANDLE              *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_LOCATE_DEVICE_PATH) (
    IN EFI_GUID                 *Protocol,
    IN OUT EFI_DEVICE_PATH      **DevicePath,
    OUT EFI_HANDLE              *Device
    );

typedef
EFI_STATUS
(EFIAPI *EFI_INSTALL_CONFIGURATION_TABLE) (
    IN EFI_GUID                 *Guid,
    IN VOID                     *Table
    );

typedef
EFI_STATUS
(EFIAPI *EFI_RESERVED_SERVICE) (
    );

/* 
 *  Standard EFI table header
 */

typedef struct _EFI_TABLE_HEARDER {
    UINT64                      Signature;
    UINT32                      Revision;
    UINT32                      HeaderSize;
    UINT32                      CRC32;
    UINT32                      Reserved;
} EFI_TABLE_HEADER;


/* 
 *  EFI Runtime Serivces Table
 */

#define EFI_RUNTIME_SERVICES_SIGNATURE  0x56524553544e5552
#define EFI_RUNTIME_SERVICES_REVISION   (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)

typedef struct  {
    EFI_TABLE_HEADER                Hdr;

    /* 
     *  Time services
     */

    EFI_GET_TIME                    GetTime;
    EFI_SET_TIME                    SetTime;
    EFI_GET_WAKEUP_TIME             GetWakeupTime;
    EFI_SET_WAKEUP_TIME             SetWakeupTime;

    /* 
     *  Virtual memory services
     */

    EFI_SET_VIRTUAL_ADDRESS_MAP     SetVirtualAddressMap;
    EFI_CONVERT_POINTER             ConvertPointer;

    /* 
     *  Variable serviers
     */

    EFI_GET_VARIABLE                GetVariable;
    EFI_GET_NEXT_VARIABLE_NAME      GetNextVariableName;
    EFI_SET_VARIABLE                SetVariable;

    /* 
     *  Misc
     */

    EFI_GET_NEXT_HIGH_MONO_COUNT    GetNextHighMonotonicCount;
    EFI_RESET_SYSTEM                ResetSystem;

} EFI_RUNTIME_SERVICES;


/* 
 *  EFI Boot Services Table
 */

#define EFI_BOOT_SERVICES_SIGNATURE     0x56524553544f4f42
#define EFI_BOOT_SERVICES_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)

typedef struct _EFI_BOOT_SERVICES {

    EFI_TABLE_HEADER                Hdr;

    /* 
     *  Task priority functions
     */

    EFI_RAISE_TPL                   RaiseTPL;
    EFI_RESTORE_TPL                 RestoreTPL;

    /* 
     *  Memory functions
     */

    EFI_ALLOCATE_PAGES              AllocatePages;
    EFI_FREE_PAGES                  FreePages;
    EFI_GET_MEMORY_MAP              GetMemoryMap;
    EFI_ALLOCATE_POOL               AllocatePool;
    EFI_FREE_POOL                   FreePool;

    /* 
     *  Event & timer functions
     */

    EFI_CREATE_EVENT                CreateEvent;
    EFI_SET_TIMER                   SetTimer;
    EFI_WAIT_FOR_EVENT              WaitForEvent;
    EFI_SIGNAL_EVENT                SignalEvent;
    EFI_CLOSE_EVENT                 CloseEvent;
    EFI_CHECK_EVENT                 CheckEvent;

    /* 
     *  Protocol handler functions
     */

    EFI_INSTALL_PROTOCOL_INTERFACE  InstallProtocolInterface;
    EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;
    EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;
    EFI_HANDLE_PROTOCOL             HandleProtocol;
    EFI_HANDLE_PROTOCOL             PCHandleProtocol;
    EFI_REGISTER_PROTOCOL_NOTIFY    RegisterProtocolNotify;
    EFI_LOCATE_HANDLE               LocateHandle;
    EFI_LOCATE_DEVICE_PATH          LocateDevicePath;
    EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable;

    /* 
     *  Image functions
     */

    EFI_IMAGE_LOAD                  LoadImage;
    EFI_IMAGE_START                 StartImage;
    EFI_EXIT                        Exit;
    EFI_IMAGE_UNLOAD                UnloadImage;
    EFI_EXIT_BOOT_SERVICES          ExitBootServices;

    /* 
     *  Misc functions
     */

    EFI_GET_NEXT_MONOTONIC_COUNT    GetNextMonotonicCount;
    EFI_STALL                       Stall;
    EFI_SET_WATCHDOG_TIMER          SetWatchdogTimer;

} EFI_BOOT_SERVICES;


/* 
 *  EFI Configuration Table and GUID definitions
 */

#define MPS_TABLE_GUID    \
    { 0xeb9d2d2f, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define ACPI_TABLE_GUID  \
    { 0x8868e871, 0xe4f1, 0x11d3, 0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }

#define SMBIOS_TABLE_GUID    \
    { 0xeb9d2d31, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define SAL_SYSTEM_TABLE_GUID    \
    { 0xeb9d2d32, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }


typedef struct _EFI_CONFIGURATION_TABLE {
    EFI_GUID                VendorGuid;
    VOID                    *VendorTable;
} EFI_CONFIGURATION_TABLE;


/* 
 *  EFI System Table
 */




#define EFI_SYSTEM_TABLE_SIGNATURE      0x5453595320494249
#define EFI_SYSTEM_TABLE_REVISION      (EFI_SPECIFICATION_MAJOR_REVISION<<16) | (EFI_SPECIFICATION_MINOR_REVISION)

typedef struct _EFI_SYSTEM_TABLE {
    EFI_TABLE_HEADER                Hdr;

    CHAR16                          *FirmwareVendor;
    UINT32                          FirmwareRevision;

    EFI_HANDLE                      ConsoleInHandle;
    SIMPLE_INPUT_INTERFACE          *ConIn;

    EFI_HANDLE                      ConsoleOutHandle;
    SIMPLE_TEXT_OUTPUT_INTERFACE    *ConOut;

    EFI_HANDLE                      StandardErrorHandle;
    SIMPLE_TEXT_OUTPUT_INTERFACE    *StdErr;

    EFI_RUNTIME_SERVICES            *RuntimeServices;
    EFI_BOOT_SERVICES               *BootServices;

    UINTN                           NumberOfTableEntries;
    EFI_CONFIGURATION_TABLE         *ConfigurationTable;

} EFI_SYSTEM_TABLE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efifs.h ===
#ifndef _EFI_FS_H
#define _EFI_FS_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efifs.h

Abstract:

    EFI File System structures



Revision History

--*/


/* 
 *  EFI Partition header (normaly starts in LBA 1)
 */

#define EFI_PARTITION_SIGNATURE         0x5053595320494249
#define EFI_PARTITION_REVISION          0x00010001
#define MIN_EFI_PARTITION_BLOCK_SIZE    512
#define EFI_PARTITION_LBA               1

typedef struct _EFI_PARTITION_HEADER {
    EFI_TABLE_HEADER    Hdr;
    UINT32              DirectoryAllocationNumber;
    UINT32              BlockSize;
    EFI_LBA             FirstUsableLba;
    EFI_LBA             LastUsableLba;
    EFI_LBA             UnusableSpace;
    EFI_LBA             FreeSpace;
    EFI_LBA             RootFile;
    EFI_LBA             SecutiryFile;
} EFI_PARTITION_HEADER;


/* 
 *  File header
 */

#define EFI_FILE_HEADER_SIGNATURE   0x454c494620494249
#define EFI_FILE_HEADER_REVISION    0x00010000
#define EFI_FILE_STRING_SIZE        260

typedef struct _EFI_FILE_HEADER {
    EFI_TABLE_HEADER    Hdr;
    UINT32              Class;
    UINT32              LBALOffset;
    EFI_LBA             Parent;
    UINT64              FileSize;
    UINT64              FileAttributes;
    EFI_TIME            FileCreateTime;
    EFI_TIME            FileModificationTime;
    EFI_GUID            VendorGuid;
    CHAR16              FileString[EFI_FILE_STRING_SIZE];
} EFI_FILE_HEADER;


/* 
 *  Return the file's first LBAL which is in the same
 *  logical block as the file header
 */

#define EFI_FILE_LBAL(a)    ((EFI_LBAL *) (((CHAR8 *) (a)) + (a)->LBALOffset))

#define EFI_FILE_CLASS_FREE_SPACE   1
#define EFI_FILE_CLASS_EMPTY        2
#define EFI_FILE_CLASS_NORMAL       3


/* 
 *  Logical Block Address List - the fundemental block
 *  description structure
 */

#define EFI_LBAL_SIGNATURE      0x4c41424c20494249
#define EFI_LBAL_REVISION       0x00010000

typedef struct _EFI_LBAL {
    EFI_TABLE_HEADER    Hdr;
    UINT32              Class;
    EFI_LBA             Parent;
    EFI_LBA             Next;
    UINT32              ArraySize;
    UINT32              ArrayCount;
} EFI_LBAL;

/*  Array size  */
#define EFI_LBAL_ARRAY_SIZE(lbal,offs,blks)  \
        (((blks) - (offs) - (lbal)->Hdr.HeaderSize) / sizeof(EFI_RL))

/* 
 *  Logical Block run-length
 */

typedef struct {
    EFI_LBA     Start;
    UINT64      Length;
} EFI_RL;

/* 
 *  Return the run-length structure from an LBAL header
 */

#define EFI_LBAL_RL(a)      ((EFI_RL*) (((CHAR8 *) (a)) + (a)->Hdr.HeaderSize))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\eficon.h ===
#ifndef _EFI_CON_H
#define _EFI_CON_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    eficon.h

Abstract:

    EFI console protocols



Revision History

--*/

/* 
 *  Text output protocol
 */

#define SIMPLE_TEXT_OUTPUT_PROTOCOL \
    { 0x387477c2, 0x69c7, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

INTERFACE_DECL(_SIMPLE_TEXT_OUTPUT_INTERFACE);

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_RESET) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN BOOLEAN                      ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_OUTPUT_STRING) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN CHAR16                       *String
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_TEST_STRING) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN CHAR16                       *String
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_QUERY_MODE) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        ModeNumber,
    OUT UINTN                       *Columns,
    OUT UINTN                       *Rows
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_SET_MODE) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        ModeNumber
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_SET_ATTRIBUTE) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        Attribute
    );

#define EFI_BLACK   0x00
#define EFI_BLUE    0x01
#define EFI_GREEN   0x02
#define EFI_CYAN            (EFI_BLUE | EFI_GREEN)
#define EFI_RED     0x04
#define EFI_MAGENTA         (EFI_BLUE | EFI_RED)
#define EFI_BROWN           (EFI_GREEN | EFI_RED)
#define EFI_LIGHTGRAY       (EFI_BLUE | EFI_GREEN | EFI_RED)
#define EFI_BRIGHT  0x08
#define EFI_DARKGRAY        (EFI_BRIGHT)
#define EFI_LIGHTBLUE       (EFI_BLUE | EFI_BRIGHT)
#define EFI_LIGHTGREEN      (EFI_GREEN | EFI_BRIGHT)
#define EFI_LIGHTCYAN       (EFI_CYAN | EFI_BRIGHT)
#define EFI_LIGHTRED        (EFI_RED | EFI_BRIGHT)
#define EFI_LIGHTMAGENTA    (EFI_MAGENTA | EFI_BRIGHT)
#define EFI_YELLOW          (EFI_BROWN | EFI_BRIGHT)
#define EFI_WHITE           (EFI_BLUE | EFI_GREEN | EFI_RED | EFI_BRIGHT)

#define EFI_TEXT_ATTR(f,b)  ((f) | ((b) << 4))

#define EFI_BACKGROUND_BLACK        0x00
#define EFI_BACKGROUND_BLUE         0x10
#define EFI_BACKGROUND_GREEN        0x20
#define EFI_BACKGROUND_CYAN         (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN)
#define EFI_BACKGROUND_RED          0x40
#define EFI_BACKGROUND_MAGENTA      (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_RED)
#define EFI_BACKGROUND_BROWN        (EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
#define EFI_BACKGROUND_LIGHTGRAY    (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)


typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_CLEAR_SCREEN) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN UINTN                        Column,
    IN UINTN                        Row
    );

typedef
EFI_STATUS
(EFIAPI *EFI_TEXT_ENABLE_CURSOR) (
    IN struct _SIMPLE_TEXT_OUTPUT_INTERFACE     *This,
    IN BOOLEAN                      Enable
    );

typedef struct {
    INT32                           MaxMode;
    /*  current settings */
    INT32                           Mode;
    INT32                           Attribute;
    INT32                           CursorColumn;
    INT32                           CursorRow;
    BOOLEAN                         CursorVisible;
} SIMPLE_TEXT_OUTPUT_MODE;

typedef struct _SIMPLE_TEXT_OUTPUT_INTERFACE {
    EFI_TEXT_RESET                  Reset;

    EFI_TEXT_OUTPUT_STRING          OutputString;
    EFI_TEXT_TEST_STRING            TestString;

    EFI_TEXT_QUERY_MODE             QueryMode;
    EFI_TEXT_SET_MODE               SetMode;
    EFI_TEXT_SET_ATTRIBUTE          SetAttribute;

    EFI_TEXT_CLEAR_SCREEN           ClearScreen;
    EFI_TEXT_SET_CURSOR_POSITION    SetCursorPosition;
    EFI_TEXT_ENABLE_CURSOR          EnableCursor;

    /*  Current mode */
    SIMPLE_TEXT_OUTPUT_MODE         *Mode;
} SIMPLE_TEXT_OUTPUT_INTERFACE;

/* 
 *  Define's for required EFI Unicode Box Draw character
 */

#define BOXDRAW_HORIZONTAL                  0x2500
#define BOXDRAW_VERTICAL                    0x2502
#define BOXDRAW_DOWN_RIGHT                  0x250c
#define BOXDRAW_DOWN_LEFT                   0x2510
#define BOXDRAW_UP_RIGHT                    0x2514
#define BOXDRAW_UP_LEFT                     0x2518
#define BOXDRAW_VERTICAL_RIGHT              0x251c
#define BOXDRAW_VERTICAL_LEFT               0x2524
#define BOXDRAW_DOWN_HORIZONTAL             0x252c
#define BOXDRAW_UP_HORIZONTAL               0x2534
#define BOXDRAW_VERTICAL_HORIZONTAL         0x253c

#define BOXDRAW_DOUBLE_HORIZONTAL           0x2550
#define BOXDRAW_DOUBLE_VERTICAL             0x2551
#define BOXDRAW_DOWN_RIGHT_DOUBLE           0x2552
#define BOXDRAW_DOWN_DOUBLE_RIGHT           0x2553
#define BOXDRAW_DOUBLE_DOWN_RIGHT           0x2554

#define BOXDRAW_DOWN_LEFT_DOUBLE            0x2555
#define BOXDRAW_DOWN_DOUBLE_LEFT            0x2556
#define BOXDRAW_DOUBLE_DOWN_LEFT            0x2557

#define BOXDRAW_UP_RIGHT_DOUBLE             0x2558
#define BOXDRAW_UP_DOUBLE_RIGHT             0x2559
#define BOXDRAW_DOUBLE_UP_RIGHT             0x255a

#define BOXDRAW_UP_LEFT_DOUBLE              0x255b
#define BOXDRAW_UP_DOUBLE_LEFT              0x255c
#define BOXDRAW_DOUBLE_UP_LEFT              0x255d

#define BOXDRAW_VERTICAL_RIGHT_DOUBLE       0x255e
#define BOXDRAW_VERTICAL_DOUBLE_RIGHT       0x255f
#define BOXDRAW_DOUBLE_VERTICAL_RIGHT       0x2560

#define BOXDRAW_VERTICAL_LEFT_DOUBLE        0x2561
#define BOXDRAW_VERTICAL_DOUBLE_LEFT        0x2562
#define BOXDRAW_DOUBLE_VERTICAL_LEFT        0x2563

#define BOXDRAW_DOWN_HORIZONTAL_DOUBLE      0x2564
#define BOXDRAW_DOWN_DOUBLE_HORIZONTAL      0x2565
#define BOXDRAW_DOUBLE_DOWN_HORIZONTAL      0x2566

#define BOXDRAW_UP_HORIZONTAL_DOUBLE        0x2567
#define BOXDRAW_UP_DOUBLE_HORIZONTAL        0x2568
#define BOXDRAW_DOUBLE_UP_HORIZONTAL        0x2569

#define BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE  0x256a
#define BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL  0x256b
#define BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL  0x256c

/* 
 *  EFI Required Block Elements Code Chart
 */

#define BLOCKELEMENT_FULL_BLOCK             0x2588
#define BLOCKELEMENT_LIGHT_SHADE            0x2591
/* 
 *  EFI Required Geometric Shapes Code Chart
 */

#define GEOMETRICSHAPE_UP_TRIANGLE           0x25b2
#define GEOMETRICSHAPE_RIGHT_TRIANGLE        0x25ba
#define GEOMETRICSHAPE_DOWN_TRIANGLE         0x25bc
#define GEOMETRICSHAPE_LEFT_TRIANGLE         0x25c4

/* 
 *  EFI Required Arrow shapes
 */

#define ARROW_UP                            0x2191
#define ARROW_DOWN                          0x2193

/* 
 *  Text input protocol
 */

#define SIMPLE_TEXT_INPUT_PROTOCOL  \
    { 0x387477c1, 0x69c7, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

INTERFACE_DECL(_SIMPLE_INPUT_INTERFACE);

typedef struct {
    UINT16                              ScanCode;
    CHAR16                              UnicodeChar;
} EFI_INPUT_KEY;

/* 
 *  Baseline unicode control chars
 */

#define CHAR_NULL                       0x0000
#define CHAR_BACKSPACE                  0x0008
#define CHAR_TAB                        0x0009
#define CHAR_LINEFEED                   0x000A
#define CHAR_CARRIAGE_RETURN            0x000D

/* 
 *  Scan codes for base line keys
 */

#define SCAN_NULL                       0x0000
#define SCAN_UP                         0x0001
#define SCAN_DOWN                       0x0002
#define SCAN_RIGHT                      0x0003
#define SCAN_LEFT                       0x0004
#define SCAN_HOME                       0x0005
#define SCAN_END                        0x0006
#define SCAN_INSERT                     0x0007
#define SCAN_DELETE                     0x0008
#define SCAN_PAGE_UP                    0x0009
#define SCAN_PAGE_DOWN                  0x000A
#define SCAN_F1                         0x000B
#define SCAN_F2                         0x000C
#define SCAN_F3                         0x000D
#define SCAN_F4                         0x000E
#define SCAN_F5                         0x000F
#define SCAN_F6                         0x0010
#define SCAN_F7                         0x0011
#define SCAN_F8                         0x0012
#define SCAN_F9                         0x0013
#define SCAN_F10                        0x0014
#define SCAN_ESC                        0x0017

typedef
EFI_STATUS
(EFIAPI *EFI_INPUT_RESET) (
    IN struct _SIMPLE_INPUT_INTERFACE   *This,
    IN BOOLEAN                          ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_INPUT_READ_KEY) (
    IN struct _SIMPLE_INPUT_INTERFACE   *This,
    OUT EFI_INPUT_KEY                   *Key
    );

typedef struct _SIMPLE_INPUT_INTERFACE {
    EFI_INPUT_RESET                     Reset;
    EFI_INPUT_READ_KEY                  ReadKeyStroke;
    EFI_EVENT                           WaitForKey;
} SIMPLE_INPUT_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efiboot.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    efiboot.h

Abstract:

    EFI Boot Manager definitions.

Author:

    Chuck Lenzmeier (chuckl) 17-Dec-2000
        added because none of the Intel-provided efi*.h had this stuff


Revision History:

--*/

#ifndef _EFIBOOT_
#define _EFIBOOT_

//
// This is the structure that the EFI Boot Manager recognizes in a Boot####
// environment variable.
//

typedef struct _EFI_LOAD_OPTION {
    UINT32 Attributes;
    UINT16 FilePathLength;
    CHAR16 Description[1];
    //EFI_DEVICE_PATH FilePath[];
    //UINT8 OptionalData[];
} EFI_LOAD_OPTION, *PEFI_LOAD_OPTION;

#define LOAD_OPTION_ACTIVE 0x00000001

#endif // _EFIBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efidef.h ===
#ifndef _EFI_DEF_H
#define _EFI_DEF_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efidef.h

Abstract:

    EFI definitions




Revision History

--*/

typedef UINT16          CHAR16;
typedef UINT8           CHAR8;
/* typedef UINT8           BOOLEAN; */

#ifndef TRUE
    #define TRUE    ((BOOLEAN) 1)
    #define FALSE   ((BOOLEAN) 0)
#endif

#ifndef NULL
    #define NULL    ((VOID *) 0)
#endif

typedef UINTN           EFI_STATUS;
typedef UINT64          EFI_LBA;
typedef UINTN           EFI_TPL;
typedef VOID            *EFI_HANDLE;
typedef VOID            *EFI_EVENT;


/* 
 *  Prototype argument decoration for EFI parameters to indicate
 *  their direction
 * 
 *  IN - argument is passed into the function
 *  OUT - argument (pointer) is returned from the function
 *  OPTIONAL - argument is optional
 */

#ifndef IN
    #define IN
    #define OUT
    #define OPTIONAL
#endif


/* 
 *  A GUID
 */

typedef struct {          
    UINT32  Data1;
    UINT16  Data2;
    UINT16  Data3;
    UINT8   Data4[8]; 
} EFI_GUID;


/* 
 *  Time
 */

typedef struct {          
    UINT16      Year;       /*  1998 - 20XX */
    UINT8       Month;      /*  1 - 12 */
    UINT8       Day;        /*  1 - 31 */
    UINT8       Hour;       /*  0 - 23 */
    UINT8       Minute;     /*  0 - 59 */
    UINT8       Second;     /*  0 - 59 */
    UINT8       Pad1;
    UINT32      Nanosecond; /*  0 - 999,999,999 */
    INT16       TimeZone;   /*  -1440 to 1440 or 2047 */
    UINT8       Daylight;
    UINT8       Pad2;
} EFI_TIME;

/*  Bit definitions for EFI_TIME.Daylight */
#define EFI_TIME_ADJUST_DAYLIGHT    0x01
#define EFI_TIME_IN_DAYLIGHT        0x02

/*  Value definition for EFI_TIME.TimeZone */
#define EFI_UNSPECIFIED_TIMEZONE    0x07FF



/* 
 *  Networking
 */

typedef struct {
    UINT8                   Addr[4];
} EFI_IPv4_ADDRESS;

typedef struct {
    UINT8                   Addr[16];
} EFI_IPv6_ADDRESS;

typedef struct {
    UINT8                   Addr[32];
} EFI_MAC_ADDRESS;

/* 
 *  Memory
 */

typedef UINT64          EFI_PHYSICAL_ADDRESS;
typedef UINT64          EFI_VIRTUAL_ADDRESS;

typedef enum {
    AllocateAnyPages,
    AllocateMaxAddress,
    AllocateAddress,
    MaxAllocateType
} EFI_ALLOCATE_TYPE;

/* Preseve the attr on any range supplied.
 * ConventialMemory must have WB,SR,SW when supplied.
 * When allocating from ConventialMemory always make it WB,SR,SW
 * When returning to ConventialMemory always make it WB,SR,SW
 * When getting the memory map, or on RT for runtime types */


typedef enum {
    EfiReservedMemoryType,
    EfiLoaderCode,
    EfiLoaderData,
    EfiBootServicesCode,
    EfiBootServicesData,
    EfiRuntimeServicesCode,
    EfiRuntimeServicesData,
    EfiConventionalMemory,
    EfiUnusableMemory,
    EfiACPIReclaimMemory,
    EfiACPIMemoryNVS,
    EfiMemoryMappedIO,
    EfiMemoryMappedIOPortSpace,
    EfiPalCode,
    EfiMaxMemoryType
} EFI_MEMORY_TYPE;

/*  possible caching types for the memory range */
#define EFI_MEMORY_UC           0x0000000000000001
#define EFI_MEMORY_WC           0x0000000000000002
#define EFI_MEMORY_WT           0x0000000000000004
#define EFI_MEMORY_WB           0x0000000000000008
#define EFI_MEMORY_UCE          0x0000000000000010  

/*  physical memory protection on range  */
#define EFI_MEMORY_WP           0x0000000000001000
#define EFI_MEMORY_RP           0x0000000000002000
#define EFI_MEMORY_XP           0x0000000000004000

/*  range requires a runtime mapping */
#define EFI_MEMORY_RUNTIME      0x8000000000000000

#define EFI_MEMORY_DESCRIPTOR_VERSION  1
typedef struct {
    UINT32                          Type;           /*  Field size is 32 bits followed by 32 bit pad */
    EFI_PHYSICAL_ADDRESS            PhysicalStart;  /*  Field size is 64 bits */
    EFI_VIRTUAL_ADDRESS             VirtualStart;   /*  Field size is 64 bits */
    UINT64                          NumberOfPages;  /*  Field size is 64 bits */
    UINT64                          Attribute;      /*  Field size is 64 bits */
} EFI_MEMORY_DESCRIPTOR;

/* 
 *  International Language
 */

typedef UINT8   ISO_639_2;
#define ISO_639_2_ENTRY_SIZE    3

/* 
 * 
 */

#define EFI_PAGE_SIZE   4096
#define EFI_PAGE_MASK   0xFFF
#define EFI_PAGE_SHIFT  12

#define EFI_SIZE_TO_PAGES(a)  \
    ( ((a) >> EFI_PAGE_SHIFT) + ((a) & EFI_PAGE_MASK ? 1 : 0) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efibind32.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efefind.h

Abstract:

    EFI to compile bindings




Revision History

--*/

#pragma pack()


/* 
 *  Basic int types of various widths
 */

#if (__STDC_VERSION__ < 199901L )

    /*  No ANSI C 1999/2000 stdint.h integer width declarations  */

    #if _MSC_EXTENSIONS

        /*  Use Microsoft C compiler integer width declarations  */

        typedef unsigned __int64    uint64_t;
        typedef __int64             int64_t;
        typedef unsigned __int32    uint32_t;
        typedef __int32             int32_t;
        typedef unsigned short      uint16_t;
        typedef short               int16_t;
        typedef unsigned char       uint8_t;
        typedef char                int8_t;
    #else             
        #ifdef UNIX_LP64

            /*  Use LP64 programming model from C_FLAGS for integer width declarations  */

            typedef unsigned long       uint64_t;
            typedef long                int64_t;
            typedef unsigned int        uint32_t;
            typedef int                 int32_t;
            typedef unsigned short      uint16_t;
            typedef short               int16_t;
            typedef unsigned char       uint8_t;
            typedef char                int8_t;
        #else

            /*  Assume P64 programming model from C_FLAGS for integer width declarations  */

            typedef unsigned long long  uint64_t;
            typedef long long           int64_t;
            typedef unsigned int        uint32_t;
            typedef int                 int32_t;
            typedef unsigned short      uint16_t;
            typedef short               int16_t;
            typedef unsigned char       uint8_t;
            typedef char                int8_t;
        #endif
    #endif
#endif

/* 
 *  Basic EFI types of various widths
 */

typedef uint64_t   UINT64;
typedef int64_t    INT64;

#ifndef _BASETSD_H_
    typedef uint32_t   UINT32;
    typedef int32_t    INT32;
#endif

typedef uint16_t   UINT16;
typedef int16_t    INT16;
typedef uint8_t    UINT8;
typedef int8_t     INT8;


#undef VOID
#define VOID    void


typedef int32_t    INTN;
typedef uint32_t   UINTN;

#ifdef EFI_NT_EMULATOR
    #define POST_CODE(_Data)
#else    
    #ifdef EFI_DEBUG
#define POST_CODE(_Data)    __asm mov eax,(_Data) __asm out 0x80,al
    #else
        #define POST_CODE(_Data)
    #endif  
#endif

#define EFIERR(a)           (0x80000000 | a)
#define EFI_ERROR_MASK      0x80000000
#define EFIERR_OEM(a)       (0xc0000000 | a)      


#define BAD_POINTER         0xFBFBFBFB
#define MAX_ADDRESS         0xFFFFFFFF

#ifdef EFI_NT_EMULATOR
    #define BREAKPOINT()        __asm { int 3 }
#else
    #define BREAKPOINT()        while (TRUE);    /*  Make it hang on Bios[Dbg]32 */
#endif

/* 
 *  Pointers must be aligned to these address to function
 */

#define MIN_ALIGNMENT_SIZE  4

#define ALIGN_VARIABLE(Value ,Adjustment) \
            (UINTN)Adjustment = 0; \
            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
            Value = (UINTN)Value + (UINTN)Adjustment


/* 
 *  Define macros to build data structure signatures from characters.
 */

#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | (EFI_SIGNATURE_32(E,F,G,H) << 32))

/* 
 *  To export & import functions in the EFI emulator environment
 */

#if EFI_NT_EMULATOR
    #define EXPORTAPI           __declspec( dllexport )
#else
    #define EXPORTAPI
#endif


/* 
 *  EFIAPI - prototype calling convention for EFI function pointers
 *  BOOTSERVICE - prototype for implementation of a boot service interface
 *  RUNTIMESERVICE - prototype for implementation of a runtime service interface
 *  RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
 *  RUNTIME_CODE - pragma macro for declaring runtime code    
 */

#ifndef EFIAPI                  /*  Forces EFI calling conventions reguardless of compiler options  */
    #if _MSC_EXTENSIONS
        #define EFIAPI __cdecl  /*  Force C calling convention for Microsoft C compiler  */
    #else
        #define EFIAPI          /*  Substitute expresion to force C calling convention  */
    #endif
#endif

#define BOOTSERVICE
/* #define RUNTIMESERVICE(proto,a)    alloc_text("rtcode",a); proto a
 * #define RUNTIMEFUNCTION(proto,a)   alloc_text("rtcode",a); proto a */
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION


#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE    volatile

#define MEMORY_FENCE()    

#ifdef EFI_NT_EMULATOR

/* 
 *  To help ensure proper coding of integrated drivers, they are
 *  compiled as DLLs.  In NT they require a dll init entry pointer.
 *  The macro puts a stub entry point into the DLL so it will load.
 */

#define EFI_DRIVER_ENTRY_POINT(InitFunction)    \
    UINTN                                       \
    __stdcall                                   \
    _DllMainCRTStartup (                        \
        UINTN    Inst,                          \
        UINTN    reason_for_call,               \
        VOID    *rserved                        \
        )                                       \
    {                                           \
        return 1;                               \
    }                                           \
                                                \
    int                                         \
    EXPORTAPI                                   \
    __cdecl                                     \
    InitializeDriver (                          \
        void *ImageHandle,                      \
        void *SystemTable                       \
        )                                       \
    {                                           \
        return InitFunction(ImageHandle, SystemTable);       \
    }


    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)      \
        (_if)->LoadInternal(type, name, NULL)             

#else /*  EFI_NT_EMULATOR  */

/* 
 *  When build similiar to FW, then link everything together as
 *  one big module.
 */

    #define EFI_DRIVER_ENTRY_POINT(InitFunction)

    #define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
            (_if)->LoadInternal(type, name, entry)

#endif /*  EFI_FW_NT  */

/* 
 *  Some compilers don't support the forward reference construct:
 *   typedef struct XXXXX
 * 
 *  The following macro provide a workaround for such cases.
 */
#ifdef NO_INTERFACE_DECL
#define INTERFACE_DECL(x)
#else
#define INTERFACE_DECL(x) typedef struct x
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efidevp.h ===
#ifndef _DEVPATH_H
#define _DEVPATH_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    devpath.h

Abstract:

    Defines for parsing the EFI Device Path structures



Revision History

--*/

/* 
 *  Device Path structures - Section C
 */

typedef struct _EFI_DEVICE_PATH {
        UINT8                           Type;
        UINT8                           SubType;
        UINT8                           Length[2];
} EFI_DEVICE_PATH;

#define EFI_DP_TYPE_MASK                    0x7F
#define EFI_DP_TYPE_UNPACKED                0x80

/* #define END_DEVICE_PATH_TYPE                0xff */
#define END_DEVICE_PATH_TYPE                0x7f
/* #define END_DEVICE_PATH_TYPE_UNPACKED       0x7f */

#define END_ENTIRE_DEVICE_PATH_SUBTYPE      0xff
#define END_INSTANCE_DEVICE_PATH_SUBTYPE    0x01
#define END_DEVICE_PATH_LENGTH              (sizeof(EFI_DEVICE_PATH))


#define DP_IS_END_TYPE(a)
#define DP_IS_END_SUBTYPE(a)        ( ((a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )

#define DevicePathType(a)           ( ((a)->Type) & EFI_DP_TYPE_MASK )
#define DevicePathSubType(a)        ( (a)->SubType )
#define DevicePathNodeLength(a)     ( ((a)->Length[0]) | ((a)->Length[1] << 8) )
#define NextDevicePathNode(a)       ( (EFI_DEVICE_PATH *) ( ((UINT8 *) (a)) + DevicePathNodeLength(a)))
/* #define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE_UNPACKED ) */
#define IsDevicePathEndType(a)      ( DevicePathType(a) == END_DEVICE_PATH_TYPE )
#define IsDevicePathEndSubType(a)   ( (a)->SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE )
#define IsDevicePathEnd(a)          ( IsDevicePathEndType(a) && IsDevicePathEndSubType(a) )
#define IsDevicePathUnpacked(a)     ( (a)->Type & EFI_DP_TYPE_UNPACKED )


#define SetDevicePathNodeLength(a,l) {                  \
            (a)->Length[0] = (UINT8) (l);               \
            (a)->Length[1] = (UINT8) ((l) >> 8);        \
            }

#define SetDevicePathEndNode(a)  {                      \
            (a)->Type = END_DEVICE_PATH_TYPE;           \
            (a)->SubType = END_ENTIRE_DEVICE_PATH_SUBTYPE;     \
            (a)->Length[0] = sizeof(EFI_DEVICE_PATH);   \
            (a)->Length[1] = 0;                         \
            }



/*
 *
 */
#define HARDWARE_DEVICE_PATH            0x01

#define HW_PCI_DP                       0x01
typedef struct _PCI_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT8                           Function;
        UINT8                           Device;
} PCI_DEVICE_PATH;

#define HW_PCCARD_DP                    0x02
typedef struct _PCCARD_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT8                           SocketNumber;
} PCCARD_DEVICE_PATH;

#define HW_MEMMAP_DP                    0x03
typedef struct _MEMMAP_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          MemoryType;
        EFI_PHYSICAL_ADDRESS            StartingAddress;
        EFI_PHYSICAL_ADDRESS            EndingAddress;
} MEMMAP_DEVICE_PATH;

#define HW_VENDOR_DP                    0x04
typedef struct _VENDOR_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        EFI_GUID                        Guid;
} VENDOR_DEVICE_PATH;

#define UNKNOWN_DEVICE_GUID \
    { 0xcf31fac5, 0xc24e, 0x11d2,  0x85, 0xf3, 0x0, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b  }

typedef struct _UKNOWN_DEVICE_VENDOR_DP {
    VENDOR_DEVICE_PATH      DevicePath;
    UINT8                   LegacyDriveLetter;
} UNKNOWN_DEVICE_VENDOR_DEVICE_PATH;

#define HW_CONTROLLER_DP            0x05
typedef struct _CONTROLLER_DEVICE_PATH {
        EFI_DEVICE_PATH     Header;
        UINT32              Controller;
} CONTROLLER_DEVICE_PATH;

/*
 *
 */
#define ACPI_DEVICE_PATH                 0x02

#define ACPI_DP                         0x01
typedef struct _ACPI_HID_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          HID;
        UINT32                          UID;
} ACPI_HID_DEVICE_PATH;

/* 
 *  EISA ID Macro
 *  EISA ID Definition 32-bits
 *   bits[15:0] - three character compressed ASCII EISA ID.
 *   bits[31:16] - binary number
 *    Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
 */
#define PNP_EISA_ID_CONST       0x41d0    
#define EISA_ID(_Name, _Num)    ((UINT32) ((_Name) | (_Num) << 16))   
#define EISA_PNP_ID(_PNPId)     (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))

#define PNP_EISA_ID_MASK        0xffff
#define EISA_ID_TO_NUM(_Id)     ((_Id) >> 16)
/*
 *
 */
#define MESSAGING_DEVICE_PATH           0x03 

#define MSG_ATAPI_DP                    0x01
typedef struct _ATAPI_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT8                           PrimarySecondary;
        UINT8                           SlaveMaster;
        UINT16                          Lun;
} ATAPI_DEVICE_PATH;

#define MSG_SCSI_DP                     0x02
typedef struct _SCSI_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT16                          Pun;
        UINT16                          Lun; 
} SCSI_DEVICE_PATH;

#define MSG_FIBRECHANNEL_DP             0x03
typedef struct _FIBRECHANNEL_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          Reserved;
        UINT64                          WWN;
} FIBRECHANNEL_DEVICE_PATH;

#define MSG_1394_DP                     0x04
typedef struct _F1394_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          Reserved;
        UINT64                          Guid;
} F1394_DEVICE_PATH;

#define MSG_USB_DP                      0x05
typedef struct _USB_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT8                           Port;
        UINT8                           Reserved[3];
        UINT64                          Guid;
} USB_DEVICE_PATH;

#define MSG_I2O_DP                      0x06
typedef struct _I2O_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          Tid;
} I2O_DEVICE_PATH;

#define MSG_MAC_ADDR_DP                 0x0b
typedef struct _MAC_ADDR_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        EFI_MAC_ADDRESS                 MacAddress;
        UINT8                           IfType;
} MAC_ADDR_DEVICE_PATH;

#define MSG_IPv4_DP                     0x0c
typedef struct _IPv4_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        EFI_IPv4_ADDRESS                LocalIpAddress;
        EFI_IPv4_ADDRESS                RemoteIpAddress;
        UINT16                          LocalPort;
        UINT16                          RemotePort;
        UINT16                          Protocol;
        BOOLEAN                         StaticIpAddress;
} IPv4_DEVICE_PATH;

#define MSG_IPv6_DP                     0x0d
typedef struct _IPv6_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        EFI_IPv6_ADDRESS                LocalIpAddress;
        EFI_IPv6_ADDRESS                RemoteIpAddress;
        UINT16                          LocalPort;
        UINT16                          RemotePort;
        UINT16                          Protocol;
        BOOLEAN                         StaticIpAddress;
} IPv6_DEVICE_PATH;

#define MSG_INFINIBAND_DP               0x09
typedef struct _INFINIBAND_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
} INFINIBAND_DEVICE_PATH;

#define MSG_UART_DP                     0x0e
typedef struct _UART_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT64                          BaudRate;
        UINT8                           DataBits;
        UINT8                           Parity;
        UINT8                           StopBits;
} UART_DEVICE_PATH;

#define MSG_VENDOR_DP                   0x0A
/* Use VENDOR_DEVICE_PATH struct */

#define DEVICE_PATH_MESSAGING_PC_ANSI \
    { 0xe0c14753, 0xf9be, 0x11d2,  0x9a, 0x0c, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d  }

#define DEVICE_PATH_MESSAGING_VT_100 \
    { 0xdfa66065, 0xb419, 0x11d3,  0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d  }



#define MEDIA_DEVICE_PATH               0x04

#define MEDIA_HARDDRIVE_DP              0x01
typedef struct _HARDDRIVE_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          PartitionNumber;
        UINT64                          PartitionStart;
        UINT64                          PartitionSize;
        UINT8                           Signature[16];
        UINT8                           MBRType;
        UINT8                           SignatureType;
} HARDDRIVE_DEVICE_PATH;

#define MBR_TYPE_PCAT                       0x01
#define MBR_TYPE_EFI_PARTITION_TABLE_HEADER 0x02

#define SIGNATURE_TYPE_MBR                  0x01
#define SIGNATURE_TYPE_GUID                 0x02

#define MEDIA_CDROM_DP                  0x02
typedef struct _CDROM_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT32                          BootEntry;
        UINT64                          PartitionStart;
        UINT64                          PartitionSize;
} CDROM_DEVICE_PATH;

#define MEDIA_VENDOR_DP                 0x03
/* Use VENDOR_DEVICE_PATH struct */

#define MEDIA_FILEPATH_DP               0x04
typedef struct _FILEPATH_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        CHAR16                          PathName[1];
} FILEPATH_DEVICE_PATH;

#define SIZE_OF_FILEPATH_DEVICE_PATH EFI_FIELD_OFFSET(FILEPATH_DEVICE_PATH,PathName)

#define MEDIA_PROTOCOL_DP               0x05
typedef struct _MEDIA_PROTOCOL_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        EFI_GUID                        Protocol;
} MEDIA_PROTOCOL_DEVICE_PATH;


#define BBS_DEVICE_PATH                 0x05
#define BBS_BBS_DP                      0x01
typedef struct _BBS_BBS_DEVICE_PATH {
        EFI_DEVICE_PATH                 Header;
        UINT16                          DeviceType;
        UINT16                          StatusFlag;
        CHAR8                           String[1];
} BBS_BBS_DEVICE_PATH;

/* DeviceType definitions - from BBS specification */
#define BBS_TYPE_FLOPPY                 0x01
#define BBS_TYPE_HARDDRIVE              0x02
#define BBS_TYPE_CDROM                  0x03
#define BBS_TYPE_PCMCIA                 0x04
#define BBS_TYPE_USB                    0x05
#define BBS_TYPE_EMBEDDED_NETWORK       0x06
#define BBS_TYPE_DEV                    0x80
#define BBS_TYPE_UNKNOWN                0xFF

typedef union {
    EFI_DEVICE_PATH                      DevPath;
    PCI_DEVICE_PATH                      Pci;
    PCCARD_DEVICE_PATH                   PcCard;
    MEMMAP_DEVICE_PATH                   MemMap;
    VENDOR_DEVICE_PATH                   Vendor;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    UnknownVendor;   
    CONTROLLER_DEVICE_PATH               Controller;
    ACPI_HID_DEVICE_PATH                 Acpi;

    ATAPI_DEVICE_PATH                    Atapi;
    SCSI_DEVICE_PATH                     Scsi;
    FIBRECHANNEL_DEVICE_PATH             FibreChannel;

    F1394_DEVICE_PATH                    F1394;
    USB_DEVICE_PATH                      Usb;
    I2O_DEVICE_PATH                      I2O;
    MAC_ADDR_DEVICE_PATH                 MacAddr;
    IPv4_DEVICE_PATH                     Ipv4;
    IPv6_DEVICE_PATH                     Ipv6;
    INFINIBAND_DEVICE_PATH               InfiniBand;
    UART_DEVICE_PATH                     Uart;

    HARDDRIVE_DEVICE_PATH                HardDrive;
    CDROM_DEVICE_PATH                    CD;

    FILEPATH_DEVICE_PATH                 FilePath;
    MEDIA_PROTOCOL_DEVICE_PATH           MediaProtocol;

    BBS_BBS_DEVICE_PATH                  Bbs;

} EFI_DEV_PATH;

typedef union {
    EFI_DEVICE_PATH                      *DevPath;
    PCI_DEVICE_PATH                      *Pci;
    PCCARD_DEVICE_PATH                   *PcCard;
    MEMMAP_DEVICE_PATH                   *MemMap;
    VENDOR_DEVICE_PATH                   *Vendor;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH    *UnknownVendor;   
    CONTROLLER_DEVICE_PATH               *Controller;
    ACPI_HID_DEVICE_PATH                 *Acpi;

    ATAPI_DEVICE_PATH                    *Atapi;
    SCSI_DEVICE_PATH                     *Scsi;
    FIBRECHANNEL_DEVICE_PATH             *FibreChannel;

    F1394_DEVICE_PATH                    *F1394;
    USB_DEVICE_PATH                      *Usb;
    I2O_DEVICE_PATH                      *I2O;
    MAC_ADDR_DEVICE_PATH                 *MacAddr;
    IPv4_DEVICE_PATH                     *Ipv4;
    IPv6_DEVICE_PATH                     *Ipv6;
    INFINIBAND_DEVICE_PATH               *InfiniBand;
    UART_DEVICE_PATH                     *Uart;

    HARDDRIVE_DEVICE_PATH                *HardDrive;

    FILEPATH_DEVICE_PATH                 *FilePath;
    MEDIA_PROTOCOL_DEVICE_PATH           *MediaProtocol;

    CDROM_DEVICE_PATH                    *CD;
    BBS_BBS_DEVICE_PATH                  *Bbs;

} EFI_DEV_PATH_PTR;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efibind64.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efefind.h

Abstract:

    EFI to compile bindings




Revision History

--*/

#pragma pack()


/* 
 *  Basic int types of various widths
 */

#if (__STDC_VERSION__ < 199901L )

    /*  No ANSI C 1999/2000 stdint.h integer width declarations  */

    #if _MSC_EXTENSIONS

        /*  Use Microsoft C compiler integer width declarations  */

        typedef unsigned __int64    uint64_t;
        typedef __int64             int64_t;
        typedef unsigned __int32    uint32_t;
        typedef __int32             int32_t;
        typedef unsigned __int16    uint16_t;
        typedef __int16             int16_t;
        typedef unsigned __int8     uint8_t;
        typedef __int8              int8_t;
    #else             
        #ifdef UNIX_LP64

            /*  Use LP64 programming model from C_FLAGS for integer width declarations  */

            typedef unsigned long       uint64_t;
            typedef long                int64_t;
            typedef unsigned int        uint32_t;
            typedef int                 int32_t;
            typedef unsigned short      uint16_t;
            typedef short               int16_t;
            typedef unsigned char       uint8_t;
            typedef char                int8_t;
        #else

            /*  Assume P64 programming model from C_FLAGS for integer width declarations  */

            typedef unsigned long long  uint64_t;
            typedef long long           int64_t;
            typedef unsigned int        uint32_t;
            typedef int                 int32_t;
            typedef unsigned short      uint16_t;
            typedef short               int16_t;
            typedef unsigned char       uint8_t;
            typedef char                int8_t;
        #endif
    #endif
#endif

/* 
 *  Basic EFI types of various widths
 */


#ifndef _BASETSD_H_
    typedef uint64_t   UINT64;
    typedef int64_t    INT64;
    typedef uint32_t   UINT32;
    typedef int32_t    INT32;
    typedef uint16_t   UINT16;
    typedef int16_t    INT16;
    typedef uint8_t    UINT8;
    typedef int8_t     INT8;
#endif

#undef VOID
#define VOID    void


typedef int64_t    INTN;
typedef uint64_t   UINTN;

/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *  BugBug: Code to debug
 */
#define BIT63   0x8000000000000000

#define PLATFORM_IOBASE_ADDRESS   (0xffffc000000 | BIT63)                                               
#define PORT_TO_MEMD(_Port) (PLATFORM_IOBASE_ADDRESS | ( ( ( (_Port) & 0xfffc) << 10 ) | ( (_Port) & 0x0fff) ) )
                                                                           
/*                                                                   
 *  Macro's with casts make this much easier to use and read.
 */
#define PORT_TO_MEM8D(_Port)  (*(UINT8  *)(PORT_TO_MEMD(_Port)))
#define POST_CODE(_Data)  (PORT_TO_MEM8D(0x80) = (_Data))
/* 
 *  BugBug: End Debug Code!!!
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

#define EFIERR(a)           (0x8000000000000000 | a)
#define EFI_ERROR_MASK      0x8000000000000000
#define EFIERR_OEM(a)       (0xc000000000000000 | a)      

#define BAD_POINTER         0xFBFBFBFBFBFBFBFB
#define MAX_ADDRESS         0xFFFFFFFFFFFFFFFF

#define BREAKPOINT()        while (TRUE)

/* 
 *  Pointers must be aligned to these address to function
 *   you will get an alignment fault if this value is less than 8
 */
#define MIN_ALIGNMENT_SIZE  8

#define ALIGN_VARIABLE(Value , Adjustment) \
            (UINTN) Adjustment = 0; \
            if((UINTN)Value % MIN_ALIGNMENT_SIZE) \
                (UINTN)Adjustment = MIN_ALIGNMENT_SIZE - ((UINTN)Value % MIN_ALIGNMENT_SIZE); \
            Value = (UINTN)Value + (UINTN)Adjustment

/* 
 *  Define macros to create data structure signatures.
 */

#define EFI_SIGNATURE_16(A,B)             ((A) | (B<<8))
#define EFI_SIGNATURE_32(A,B,C,D)         (EFI_SIGNATURE_16(A,B)     | (EFI_SIGNATURE_16(C,D)     << 16))
#define EFI_SIGNATURE_64(A,B,C,D,E,F,G,H) (EFI_SIGNATURE_32(A,B,C,D) | (EFI_SIGNATURE_32(E,F,G,H) << 32))

/* 
 *  To export & import functions in the EFI emulator environment
 */

    #define EXPORTAPI

/* 
 *  EFIAPI - prototype calling convention for EFI function pointers
 *  BOOTSERVICE - prototype for implementation of a boot service interface
 *  RUNTIMESERVICE - prototype for implementation of a runtime service interface
 *  RUNTIMEFUNCTION - prototype for implementation of a runtime function that is not a service
 *  RUNTIME_CODE - pragma macro for declaring runtime code    
 */

#ifndef EFIAPI                  /*  Forces EFI calling conventions reguardless of compiler options  */
    #if _MSC_EXTENSIONS
        #define EFIAPI __cdecl  /*  Force C calling convention for Microsoft C compiler  */
    #else
        #define EFIAPI          /*  Substitute expresion to force C calling convention  */
    #endif
#endif

#define BOOTSERVICE
#define RUNTIMESERVICE
#define RUNTIMEFUNCTION

#define RUNTIME_CODE(a)         alloc_text("rtcode", a)
#define BEGIN_RUNTIME_DATA()    data_seg("rtdata")
#define END_RUNTIME_DATA()      data_seg("")

#define VOLATILE    volatile

/* 
 *  BugBug: Need to find out if this is portable accross compliers.
 */
void __mf (void);                       
#pragma intrinsic (__mf)  
#define MEMORY_FENCE()    __mf()

/* 
 *  When build similiar to FW, then link everything together as
 *  one big module.
 */

#define EFI_DRIVER_ENTRY_POINT(InitFunction)

#define LOAD_INTERNAL_DRIVER(_if, type, name, entry)    \
        (_if)->LoadInternal(type, name, entry)

/* 
 *  Some compilers don't support the forward reference construct:
 *   typedef struct XXXXX
 * 
 *  The following macro provide a workaround for such cases.
 */
#ifdef NO_INTERFACE_DECL
#define INTERFACE_DECL(x)
#else
#define INTERFACE_DECL(x) typedef struct x
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efinet.h ===
#ifndef _EFINET_H
#define _EFINET_H


/*++
Copyright (c) 1999  Intel Corporation

Module Name:
    efinet.h

Abstract:
    EFI Simple Network protocol

Revision History
--*/


/* /////////////////////////////////////////////////////////////////////////////
 * 
 *       Simple Network Protocol
 */

#define EFI_SIMPLE_NETWORK_PROTOCOL \
    { 0xA19832B9, 0xAC25, 0x11D3, 0x9A, 0x2D, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D }


INTERFACE_DECL(_EFI_SIMPLE_NETWORK);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef struct {
    /* 
     *  Total number of frames received.  Includes frames with errors and
     *  dropped frames.
     */
    UINT64  RxTotalFrames;

    /* 
     *  Number of valid frames received and copied into receive buffers.
     */
    UINT64  RxGoodFrames;

    /* 
     *  Number of frames below the minimum length for the media.
     *  This would be <64 for ethernet.
     */
    UINT64  RxUndersizeFrames;

    /* 
     *  Number of frames longer than the maxminum length for the
     *  media.  This would be >1500 for ethernet.
     */
    UINT64  RxOversizeFrames;

    /* 
     *  Valid frames that were dropped because receive buffers were full.
     */
    UINT64  RxDroppedFrames;

    /* 
     *  Number of valid unicast frames received and not dropped.
     */
    UINT64  RxUnicastFrames;

    /* 
     *  Number of valid broadcast frames received and not dropped.
     */
    UINT64  RxBroadcastFrames;

    /* 
     *  Number of valid mutlicast frames received and not dropped.
     */
    UINT64  RxMulticastFrames;

    /* 
     *  Number of frames w/ CRC or alignment errors.
     */
    UINT64  RxCrcErrorFrames;

    /* 
     *  Total number of bytes received.  Includes frames with errors
     *  and dropped frames.
     */
    UINT64  RxTotalBytes;

    /* 
     *  Transmit statistics.
     */
    UINT64  TxTotalFrames;
    UINT64  TxGoodFrames;
    UINT64  TxUndersizeFrames;
    UINT64  TxOversizeFrames;
    UINT64  TxDroppedFrames;
    UINT64  TxUnicastFrames;
    UINT64  TxBroadcastFrames;
    UINT64  TxMulticastFrames;
    UINT64  TxCrcErrorFrames;
    UINT64  TxTotalBytes;

    /* 
     *  Number of collisions detection on this subnet.
     */
    UINT64  Collisions;

    /* 
     *  Number of frames destined for unsupported protocol.
     */
    UINT64  UnsupportedProtocol;

} EFI_NETWORK_STATISTICS;

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef enum {
    EfiSimpleNetworkStopped,
    EfiSimpleNetworkStarted,
    EfiSimpleNetworkInitialized,
    EfiSimpleNetworkMaxState
} EFI_SIMPLE_NETWORK_STATE;

/* /////////////////////////////////////////////////////////////////////////////
 */

#define EFI_SIMPLE_NETWORK_RECEIVE_UNICAST               0x01
#define EFI_SIMPLE_NETWORK_RECEIVE_MULTICAST             0x02
#define EFI_SIMPLE_NETWORK_RECEIVE_BROADCAST             0x04
#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS           0x08
#define EFI_SIMPLE_NETWORK_RECEIVE_PROMISCUOUS_MULTICAST 0x10

/* /////////////////////////////////////////////////////////////////////////////
 */

#define EFI_SIMPLE_NETWORK_RECEIVE_INTERRUPT        0x01
#define EFI_SIMPLE_NETWORK_TRANSMIT_INTERRUPT       0x02
#define EFI_SIMPLE_NETWORK_COMMAND_INTERRUPT        0x04
#define EFI_SIMPLE_NETWORK_SOFTWARE_INTERRUPT       0x08

/* /////////////////////////////////////////////////////////////////////////////
 */
#define MAX_MCAST_FILTER_CNT    16
typedef struct {
    UINT32                      State;
    UINT32                      HwAddressSize;
    UINT32                      MediaHeaderSize;
    UINT32                      MaxPacketSize;
    UINT32                      NvRamSize;
    UINT32                      NvRamAccessSize;
    UINT32                      ReceiveFilterMask;
    UINT32                      ReceiveFilterSetting;
    UINT32                      MaxMCastFilterCount;
    UINT32                      MCastFilterCount;
    EFI_MAC_ADDRESS             MCastFilter[MAX_MCAST_FILTER_CNT];
    EFI_MAC_ADDRESS             CurrentAddress;
    EFI_MAC_ADDRESS             BroadcastAddress;
    EFI_MAC_ADDRESS             PermanentAddress;
    UINT8                       IfType;
    BOOLEAN                     MacAddressChangeable;
    BOOLEAN                     MultipleTxSupported;
    BOOLEAN                     MediaPresentSupported;
    BOOLEAN                     MediaPresent;
} EFI_SIMPLE_NETWORK_MODE;

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_START) (
    IN struct _EFI_SIMPLE_NETWORK  *This
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_STOP) (
    IN struct _EFI_SIMPLE_NETWORK  *This
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_INITIALIZE) (
    IN struct _EFI_SIMPLE_NETWORK  *This,
    IN UINTN                       ExtraRxBufferSize  OPTIONAL,
    IN UINTN                       ExtraTxBufferSize  OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_RESET) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN BOOLEAN                      ExtendedVerification
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_SHUTDOWN) (
    IN struct _EFI_SIMPLE_NETWORK  *This
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE_FILTERS) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN UINT32                       Enable,
    IN UINT32                       Disable,
    IN BOOLEAN                      ResetMCastFilter,
    IN UINTN                        MCastFilterCnt     OPTIONAL,
    IN EFI_MAC_ADDRESS              *MCastFilter       OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_STATION_ADDRESS) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN BOOLEAN                      Reset,
    IN EFI_MAC_ADDRESS              *New      OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_STATISTICS) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN BOOLEAN                      Reset,
    IN OUT UINTN                    *StatisticsSize   OPTIONAL,
    OUT EFI_NETWORK_STATISTICS      *StatisticsTable  OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN BOOLEAN                      IPv6,
    IN EFI_IP_ADDRESS               *IP,
    OUT EFI_MAC_ADDRESS             *MAC
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_NVDATA) (
    IN struct _EFI_SIMPLE_NETWORK  *This,
    IN BOOLEAN                     ReadWrite,
    IN UINTN                       Offset,
    IN UINTN                       BufferSize,
    IN OUT VOID                    *Buffer
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_GET_STATUS) (
    IN struct _EFI_SIMPLE_NETWORK  *This,
    OUT UINT32                     *InterruptStatus  OPTIONAL,
    OUT VOID                       **TxBuf           OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_TRANSMIT) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    IN UINTN                        HeaderSize,
    IN UINTN                        BufferSize,
    IN VOID                         *Buffer,
    IN EFI_MAC_ADDRESS              *SrcAddr     OPTIONAL,
    IN EFI_MAC_ADDRESS              *DestAddr    OPTIONAL,
    IN UINT16                       *Protocol    OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

typedef 
EFI_STATUS 
(EFIAPI *EFI_SIMPLE_NETWORK_RECEIVE) (
    IN struct _EFI_SIMPLE_NETWORK   *This,
    OUT UINTN                       *HeaderSize  OPTIONAL,
    IN OUT UINTN                    *BufferSize,
    OUT VOID                        *Buffer,
    OUT EFI_MAC_ADDRESS             *SrcAddr     OPTIONAL,
    OUT EFI_MAC_ADDRESS             *DestAddr    OPTIONAL,
    OUT UINT16                      *Protocol    OPTIONAL
);

/* /////////////////////////////////////////////////////////////////////////////
 */

#define EFI_SIMPLE_NETWORK_INTERFACE_REVISION   0x00010000

typedef struct _EFI_SIMPLE_NETWORK {
    UINT64                              Revision;
    EFI_SIMPLE_NETWORK_START            Start;
    EFI_SIMPLE_NETWORK_STOP             Stop;
    EFI_SIMPLE_NETWORK_INITIALIZE       Initialize;
    EFI_SIMPLE_NETWORK_RESET            Reset;
    EFI_SIMPLE_NETWORK_SHUTDOWN         Shutdown;
    EFI_SIMPLE_NETWORK_RECEIVE_FILTERS  ReceiveFilters;
    EFI_SIMPLE_NETWORK_STATION_ADDRESS  StationAddress;
    EFI_SIMPLE_NETWORK_STATISTICS       Statistics;
    EFI_SIMPLE_NETWORK_MCAST_IP_TO_MAC  MCastIpToMac;
    EFI_SIMPLE_NETWORK_NVDATA           NvData;
    EFI_SIMPLE_NETWORK_GET_STATUS       GetStatus;
    EFI_SIMPLE_NETWORK_TRANSMIT         Transmit;
    EFI_SIMPLE_NETWORK_RECEIVE          Receive;
    EFI_EVENT                           WaitForPacket;
    EFI_SIMPLE_NETWORK_MODE             *Mode;
} EFI_SIMPLE_NETWORK;

#endif /* _EFINET_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efiprot.h ===
#ifndef _EFI_PROT_H
#define _EFI_PROT_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efiprot.h

Abstract:

    EFI Protocols



Revision History

--*/

/* 
 *  Device Path protocol
 */

#define DEVICE_PATH_PROTOCOL    \
    { 0x9576e91, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }


/* 
 *  Block IO protocol
 */

#define BLOCK_IO_PROTOCOL \
    { 0x964e5b21, 0x6459, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
#define EFI_BLOCK_IO_INTERFACE_REVISION   0x00010000

INTERFACE_DECL(_EFI_BLOCK_IO);

typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_RESET) (
    IN struct _EFI_BLOCK_IO     *This,
    IN BOOLEAN                  ExtendedVerification
    );

typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_READ) (
    IN struct _EFI_BLOCK_IO     *This,
    IN UINT32                   MediaId,
    IN EFI_LBA                  LBA,
    IN UINTN                    BufferSize,
    OUT VOID                    *Buffer
    );


typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_WRITE) (
    IN struct _EFI_BLOCK_IO     *This,
    IN UINT32                   MediaId,
    IN EFI_LBA                  LBA,
    IN UINTN                    BufferSize,
    IN VOID                     *Buffer
    );


typedef
EFI_STATUS
(EFIAPI *EFI_BLOCK_FLUSH) (
    IN struct _EFI_BLOCK_IO     *This
    );



typedef struct {
    UINT32              MediaId;
    BOOLEAN             RemovableMedia;
    BOOLEAN             MediaPresent;

    BOOLEAN             LogicalPartition;
    BOOLEAN             ReadOnly;
    BOOLEAN             WriteCaching;

    UINT32              BlockSize;
    UINT32              IoAlign;

    EFI_LBA             LastBlock;
} EFI_BLOCK_IO_MEDIA;

typedef struct _EFI_BLOCK_IO {
    UINT64                  Revision;

    EFI_BLOCK_IO_MEDIA      *Media;

    EFI_BLOCK_RESET         Reset;
    EFI_BLOCK_READ          ReadBlocks;
    EFI_BLOCK_WRITE         WriteBlocks;
    EFI_BLOCK_FLUSH         FlushBlocks;

} EFI_BLOCK_IO;



/* 
 *  Disk Block IO protocol
 */

#define DISK_IO_PROTOCOL \
    { 0xce345171, 0xba0b, 0x11d2,  0x8e, 0x4f, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }
#define EFI_DISK_IO_INTERFACE_REVISION   0x00010000

INTERFACE_DECL(_EFI_DISK_IO);

typedef
EFI_STATUS
(EFIAPI *EFI_DISK_READ) (
    IN struct _EFI_DISK_IO      *This,
    IN UINT32                   MediaId,
    IN UINT64                   Offset,
    IN UINTN                    BufferSize,
    OUT VOID                    *Buffer
    );


typedef
EFI_STATUS
(EFIAPI *EFI_DISK_WRITE) (
    IN struct _EFI_DISK_IO      *This,
    IN UINT32                   MediaId,
    IN UINT64                   Offset,
    IN UINTN                    BufferSize,
    IN VOID                     *Buffer
    );


typedef struct _EFI_DISK_IO {
    UINT64              Revision;
    EFI_DISK_READ       ReadDisk;
    EFI_DISK_WRITE      WriteDisk;
} EFI_DISK_IO;


/* 
 *  Simple file system protocol
 */

#define SIMPLE_FILE_SYSTEM_PROTOCOL \
    { 0x964e5b22, 0x6459, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

INTERFACE_DECL(_EFI_FILE_IO_INTERFACE);
INTERFACE_DECL(_EFI_FILE_HANDLE);

typedef
EFI_STATUS
(EFIAPI *EFI_VOLUME_OPEN) (
    IN struct _EFI_FILE_IO_INTERFACE    *This,
    OUT struct _EFI_FILE_HANDLE         **Root
    );

#define EFI_FILE_IO_INTERFACE_REVISION   0x00010000

typedef struct _EFI_FILE_IO_INTERFACE {
    UINT64                  Revision;
    EFI_VOLUME_OPEN         OpenVolume;
} EFI_FILE_IO_INTERFACE;

/* 
 * 
 */

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_OPEN) (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT struct _EFI_FILE_HANDLE **NewHandle,
    IN CHAR16                   *FileName,
    IN UINT64                   OpenMode,
    IN UINT64                   Attributes
    );

/*  Open modes */
#define EFI_FILE_MODE_READ      0x0000000000000001
#define EFI_FILE_MODE_WRITE     0x0000000000000002
#define EFI_FILE_MODE_CREATE    0x8000000000000000

/*  File attributes */
#define EFI_FILE_READ_ONLY      0x0000000000000001
#define EFI_FILE_HIDDEN         0x0000000000000002
#define EFI_FILE_SYSTEM         0x0000000000000004
#define EFI_FILE_RESERVIED      0x0000000000000008
#define EFI_FILE_DIRECTORY      0x0000000000000010
#define EFI_FILE_ARCHIVE        0x0000000000000020
#define EFI_FILE_VALID_ATTR     0x0000000000000037

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_CLOSE) (
    IN struct _EFI_FILE_HANDLE  *File
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_DELETE) (
    IN struct _EFI_FILE_HANDLE  *File
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_READ) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    OUT VOID                    *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_WRITE) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN OUT UINTN                *BufferSize,
    IN VOID                     *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_SET_POSITION) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN UINT64                   Position
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_GET_POSITION) (
    IN struct _EFI_FILE_HANDLE  *File,
    OUT UINT64                  *Position
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_GET_INFO) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN EFI_GUID                 *InformationType,
    IN OUT UINTN                *BufferSize,
    OUT VOID                    *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_SET_INFO) (
    IN struct _EFI_FILE_HANDLE  *File,
    IN EFI_GUID                 *InformationType,
    IN UINTN                    BufferSize,
    IN VOID                     *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_FILE_FLUSH) (
    IN struct _EFI_FILE_HANDLE  *File
    );



#define EFI_FILE_HANDLE_REVISION         0x00010000
typedef struct _EFI_FILE_HANDLE {
    UINT64                  Revision;
    EFI_FILE_OPEN           Open;
    EFI_FILE_CLOSE          Close;
    EFI_FILE_DELETE         Delete;
    EFI_FILE_READ           Read;
    EFI_FILE_WRITE          Write;
    EFI_FILE_GET_POSITION   GetPosition;
    EFI_FILE_SET_POSITION   SetPosition;
    EFI_FILE_GET_INFO       GetInfo;
    EFI_FILE_SET_INFO       SetInfo;
    EFI_FILE_FLUSH          Flush;
} EFI_FILE, *EFI_FILE_HANDLE;


/* 
 *  File information types
 */

#define EFI_FILE_INFO_ID   \
    { 0x9576e92, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

typedef struct {
    UINT64                  Size;
    UINT64                  FileSize;
    UINT64                  PhysicalSize;
    EFI_TIME                CreateTime;
    EFI_TIME                LastAccessTime;
    EFI_TIME                ModificationTime;
    UINT64                  Attribute;
    CHAR16                  FileName[1];
} EFI_FILE_INFO;

/* 
 *  The FileName field of the EFI_FILE_INFO data structure is variable length.
 *  Whenever code needs to know the size of the EFI_FILE_INFO data structure, it needs to
 *  be the size of the data structure without the FileName field.  The following macro 
 *  computes this size correctly no matter how big the FileName array is declared.
 *  This is required to make the EFI_FILE_INFO data structure ANSI compilant. 
 */

#define SIZE_OF_EFI_FILE_INFO EFI_FIELD_OFFSET(EFI_FILE_INFO,FileName)

#define EFI_FILE_SYSTEM_INFO_ID    \
    { 0x9576e93, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

typedef struct {
    UINT64                  Size;
    BOOLEAN                 ReadOnly;
    UINT64                  VolumeSize;
    UINT64                  FreeSpace;
    UINT32                  BlockSize;
    CHAR16                  VolumeLabel[1];
} EFI_FILE_SYSTEM_INFO;

/* 
 *  The VolumeLabel field of the EFI_FILE_SYSTEM_INFO data structure is variable length.
 *  Whenever code needs to know the size of the EFI_FILE_SYSTEM_INFO data structure, it needs
 *  to be the size of the data structure without the VolumeLable field.  The following macro 
 *  computes this size correctly no matter how big the VolumeLable array is declared.
 *  This is required to make the EFI_FILE_SYSTEM_INFO data structure ANSI compilant. 
 */

#define SIZE_OF_EFI_FILE_SYSTEM_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_INFO,VolumeLabel)

#define EFI_FILE_SYSTEM_VOLUME_LABEL_INFO_ID    \
    { 0xDB47D7D3,0xFE81, 0x11d3, 0x9A, 0x35, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0x4D }

typedef struct {
    CHAR16                  VolumeLabel[1];
} EFI_FILE_SYSTEM_VOLUME_LABEL_INFO;

#define SIZE_OF_EFI_FILE_SYSTEM_VOLUME_LABEL_INFO EFI_FIELD_OFFSET(EFI_FILE_SYSTEM_VOLUME_LABEL_INFO,VolumeLabel)

/* 
 *  Load file protocol
 */


#define LOAD_FILE_PROTOCOL \
    { 0x56EC3091, 0x954C, 0x11d2, 0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B }

INTERFACE_DECL(_EFI_LOAD_FILE_INTERFACE);

typedef
EFI_STATUS
(EFIAPI *EFI_LOAD_FILE) (
    IN struct _EFI_LOAD_FILE_INTERFACE  *This,
    IN EFI_DEVICE_PATH                  *FilePath,
    IN BOOLEAN                          BootPolicy,
    IN OUT UINTN                        *BufferSize,
    IN VOID                             *Buffer OPTIONAL
    );

typedef struct _EFI_LOAD_FILE_INTERFACE {
    EFI_LOAD_FILE                       LoadFile;
} EFI_LOAD_FILE_INTERFACE;


/* 
 *  Device IO protocol
 */

#define DEVICE_IO_PROTOCOL \
    { 0xaf6ac311, 0x84c3, 0x11d2, 0x8e, 0x3c, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

INTERFACE_DECL(_EFI_DEVICE_IO_INTERFACE);

typedef enum {
    IO_UINT8,
    IO_UINT16,
    IO_UINT32,
    IO_UINT64,
/* 
 *  Specification Change: Copy from MMIO to MMIO vs. MMIO to buffer, buffer to MMIO
 */
    MMIO_COPY_UINT8,
    MMIO_COPY_UINT16,
    MMIO_COPY_UINT32,
    MMIO_COPY_UINT64
} EFI_IO_WIDTH;

#define EFI_PCI_ADDRESS(_bus,_dev,_func) \
    ( (UINT64) ( (((UINTN)_bus) << 24) + (((UINTN)_dev) << 16) + (((UINTN)_func) << 8) ) )


typedef
EFI_STATUS
(EFIAPI *EFI_DEVICE_IO) (
    IN struct _EFI_DEVICE_IO_INTERFACE *This,
    IN EFI_IO_WIDTH                 Width,
    IN UINT64                       Address,
    IN UINTN                        Count,
    IN OUT VOID                     *Buffer
    );

typedef struct {
    EFI_DEVICE_IO                   Read;
    EFI_DEVICE_IO                   Write;
} EFI_IO_ACCESS;

typedef 
EFI_STATUS
(EFIAPI *EFI_PCI_DEVICE_PATH) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
    IN UINT64                           Address,
    IN OUT EFI_DEVICE_PATH              **PciDevicePath
    );

typedef enum {
    EfiBusMasterRead,
    EfiBusMasterWrite,
    EfiBusMasterCommonBuffer
} EFI_IO_OPERATION_TYPE;

typedef
EFI_STATUS
(EFIAPI *EFI_IO_MAP) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
    IN EFI_IO_OPERATION_TYPE            Operation,
    IN EFI_PHYSICAL_ADDRESS             *HostAddress,
    IN OUT UINTN                        *NumberOfBytes,
    OUT EFI_PHYSICAL_ADDRESS            *DeviceAddress,
    OUT VOID                            **Mapping
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_UNMAP) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
    IN VOID                             *Mapping
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_ALLOCATE_BUFFER) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
    IN EFI_ALLOCATE_TYPE                Type,
    IN EFI_MEMORY_TYPE                  MemoryType,
    IN UINTN                            Pages,
    IN OUT EFI_PHYSICAL_ADDRESS         *HostAddress
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_FLUSH) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_IO_FREE_BUFFER) (
    IN struct _EFI_DEVICE_IO_INTERFACE  *This,
    IN UINTN                            Pages,
    IN EFI_PHYSICAL_ADDRESS             HostAddress
    );

typedef struct _EFI_DEVICE_IO_INTERFACE {
    EFI_IO_ACCESS                       Mem;
    EFI_IO_ACCESS                       Io;
    EFI_IO_ACCESS                       Pci;
    EFI_IO_MAP                          Map;
    EFI_PCI_DEVICE_PATH                 PciDevicePath;
    EFI_IO_UNMAP                        Unmap;
    EFI_IO_ALLOCATE_BUFFER              AllocateBuffer;
    EFI_IO_FLUSH                        Flush;
    EFI_IO_FREE_BUFFER                  FreeBuffer;
} EFI_DEVICE_IO_INTERFACE;


/* 
 *  Unicode Collation protocol
 */

#define UNICODE_COLLATION_PROTOCOL \
    { 0x1d85cd7f, 0xf43d, 0x11d2, 0x9a, 0xc,  0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define UNICODE_BYTE_ORDER_MARK       (CHAR16)(0xfeff)

INTERFACE_DECL(_EFI_UNICODE_COLLATION_INTERFACE);

typedef
INTN
(EFIAPI *EFI_UNICODE_STRICOLL) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                         *s1,
    IN CHAR16                         *s2
    );

typedef
BOOLEAN
(EFIAPI *EFI_UNICODE_METAIMATCH) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                         *String,
    IN CHAR16                         *Pattern
    );

typedef
VOID
(EFIAPI *EFI_UNICODE_STRLWR) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN OUT CHAR16                       *Str
    );

typedef
VOID
(EFIAPI *EFI_UNICODE_STRUPR) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN OUT CHAR16                       *Str
    );

typedef
VOID
(EFIAPI *EFI_UNICODE_FATTOSTR) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN UINTN                            FatSize,
    IN CHAR8                            *Fat,
    OUT CHAR16                          *String
    );

typedef
BOOLEAN
(EFIAPI *EFI_UNICODE_STRTOFAT) (
    IN struct _EFI_UNICODE_COLLATION_INTERFACE  *This,
    IN CHAR16                           *String,
    IN UINTN                            FatSize,
    OUT CHAR8                           *Fat
    );


typedef struct _EFI_UNICODE_COLLATION_INTERFACE {

    /*  general */
    EFI_UNICODE_STRICOLL                StriColl;
    EFI_UNICODE_METAIMATCH              MetaiMatch;
    EFI_UNICODE_STRLWR                  StrLwr;
    EFI_UNICODE_STRUPR                  StrUpr;

    /*  for supporting fat volumes */
    EFI_UNICODE_FATTOSTR                FatToStr;
    EFI_UNICODE_STRTOFAT                StrToFat;

    CHAR8                               *SupportedLanguages;
} EFI_UNICODE_COLLATION_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efiser.h ===
#ifndef _EFI_SER_H
#define _EFI_SER_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efiser.h

Abstract:

    EFI serial protocol

Revision History

--*/

/* 
 *  Serial protocol
 */

#define SERIAL_IO_PROTOCOL \
    { 0xBB25CF6F, 0xF1D4, 0x11D2, 0x9A, 0x0C, 0x00, 0x90, 0x27, 0x3F, 0xC1, 0xFD }

INTERFACE_DECL(_SERIAL_IO_INTERFACE);

typedef enum {
    DefaultParity,      
    NoParity,           
    EvenParity,
    OddParity,
    MarkParity,
    SpaceParity
} EFI_PARITY_TYPE;

typedef enum {
    DefaultStopBits,        
    OneStopBit,         /*  1 stop bit */
    OneFiveStopBits,    /*  1.5 stop bits */
    TwoStopBits         /*  2 stop bits */
} EFI_STOP_BITS_TYPE;

#define EFI_SERIAL_CLEAR_TO_SEND        0x0010  /*  RO */
#define EFI_SERIAL_DATA_SET_READY       0x0020  /*  RO */
#define EFI_SERIAL_RING_INDICATE        0x0040  /*  RO */
#define EFI_SERIAL_CARRIER_DETECT       0x0080  /*  RO */
#define EFI_SERIAL_REQUEST_TO_SEND      0x0002  /*  WO */
#define EFI_SERIAL_DATA_TERMINAL_READY  0x0001  /*  WO */
#define EFI_SERIAL_INPUT_BUFFER_EMPTY   0x0100  /*  RO */

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_RESET) (
    IN struct _SERIAL_IO_INTERFACE  *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_SET_ATTRIBUTES) (
    IN struct _SERIAL_IO_INTERFACE  *This,
    IN UINT64                       BaudRate,
    IN UINT32                       ReceiveFifoDepth,
    IN UINT32                       Timeout,
    IN EFI_PARITY_TYPE              Parity,
    IN UINT8                        DataBits,
    IN EFI_STOP_BITS_TYPE           StopBits
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_SET_CONTROL_BITS) (
    IN struct _SERIAL_IO_INTERFACE  *This,
    IN UINT32                       Control
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_GET_CONTROL_BITS) (
    IN struct _SERIAL_IO_INTERFACE  *This,
    OUT UINT32                      *Control
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_WRITE) (
    IN struct _SERIAL_IO_INTERFACE  *This,
    IN OUT UINTN                    *BufferSize,
    IN VOID                         *Buffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_SERIAL_READ) (
    IN struct _SERIAL_IO_INTERFACE  *This,
    IN OUT UINTN                    *BufferSize,
    OUT VOID                        *Buffer
    );

typedef struct {
    UINT32                  ControlMask;

    /*  current Attributes */
    UINT32                  Timeout;
    UINT64                  BaudRate;
    UINT32                  ReceiveFifoDepth;
    UINT32                  DataBits;
    UINT32                  Parity;
    UINT32                  StopBits;
} SERIAL_IO_MODE;

#define SERIAL_IO_INTERFACE_REVISION    0x00010000

typedef struct _SERIAL_IO_INTERFACE {
    UINT32                       Revision;
    EFI_SERIAL_RESET             Reset;
    EFI_SERIAL_SET_ATTRIBUTES    SetAttributes;
    EFI_SERIAL_SET_CONTROL_BITS  SetControl;
    EFI_SERIAL_GET_CONTROL_BITS  GetControl;
    EFI_SERIAL_WRITE             Write;
    EFI_SERIAL_READ              Read;

    SERIAL_IO_MODE               *Mode;
} SERIAL_IO_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efi_nii.h ===
#ifndef _EFI_NII_H
#define _EFI_NII_H

/*++
Copyright (c) 2000  Intel Corporation

Module name:
    efi_nii.h

Abstract:

Revision history:
    2000-Feb-18 M(f)J   GUID updated.
                Structure order changed for machine word alignment.
                Added StringId[4] to structure.
                
    2000-Feb-14 M(f)J   Genesis.
--*/

#define EFI_NETWORK_INTERFACE_IDENTIFIER_PROTOCOL \
    { 0xE18541CD, 0xF755, 0x4f73, 0x92, 0x8D, 0x64, 0x3C, 0x8A, 0x79, 0xB2, 0x29 }

#define EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE_REVISION 0x00010000

typedef enum {
    EfiNetworkInterfaceUndi = 1
} EFI_NETWORK_INTERFACE_TYPE;

typedef struct {

    UINT64 Revision;
    /*  Revision of the network interface identifier protocol interface. */

    UINT64 ID;
    /*  Address of the first byte of the identifying structure for this
     *  network interface.  This is set to zero if there is no structure.
     * 
     *  For PXE/UNDI this is the first byte of the !PXE structure. */

    UINT64 ImageAddr;
    /*  Address of the UNrelocated driver/ROM image.  This is set
     *  to zero if there is no driver/ROM image.
     * 
     *  For 16-bit UNDI, this is the first byte of the option ROM in
     *  upper memory.
     * 
     *  For 32/64-bit S/W UNDI, this is the first byte of the EFI ROM
     *  image.
     * 
     *  For H/W UNDI, this is set to zero. */

    UINT32 ImageSize;
    /*  Size of the UNrelocated driver/ROM image of this network interface.
     *  This is set to zero if there is no driver/ROM image. */

    CHAR8 StringId[4];
    /*  4 char ASCII string to go in class identifier (option 60) in DHCP
     *  and Boot Server discover packets.
     *  For EfiNetworkInterfaceUndi this field is "UNDI".
     *  For EfiNetworkInterfaceSnp this field is "SNPN". */

    UINT8 Type;
    UINT8 MajorVer;
    UINT8 MinorVer;
    /*  Information to be placed into the PXE DHCP and Discover packets.
     *  This is the network interface type and version number that will
     *  be placed into DHCP option 94 (client network interface identifier). */
    BOOLEAN Ipv6Supported;
} EFI_NETWORK_INTERFACE_IDENTIFIER_INTERFACE;

extern EFI_GUID NetworkInterfaceIdentifierProtocol;

#endif /*  _EFI_NII_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\eisa.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    eisa.h

Abstract:

    The module defines the structures, and defines  for the EISA chip set.

Author:

    Jeff Havens  (jhavens) 19-Jun-1991

Revision History:


--*/

#ifndef _EISA_
#define _EISA_



//
// Define the DMA page register structure.
//

typedef struct _DMA_PAGE{
    UCHAR Reserved1;
    UCHAR Channel2;
    UCHAR Channel3;
    UCHAR Channel1;
    UCHAR Reserved2[3];
    UCHAR Channel0;
    UCHAR Reserved3;
    UCHAR Channel6;
    UCHAR Channel7;
    UCHAR Channel5;
    UCHAR Reserved4[3];
    UCHAR RefreshPage;
}DMA_PAGE, *PDMA_PAGE;

//
// Define the DMA stop register structure.
//

typedef struct _DMA_CHANNEL_STOP {
    UCHAR ChannelLsb;
    UCHAR ChannelMsb;
    UCHAR ChannelHsb;
    UCHAR Reserved;
}DMA_CHANNEL_STOP, *PDMA_CHANNEL_STOP;

//
// Define DMA 1 address and count structure.
//

typedef struct _DMA1_ADDRESS_COUNT {
    UCHAR DmaBaseAddress;
    UCHAR DmaBaseCount;
}DMA1_ADDRESS_COUNT, *PDMA1_ADDRESS_COUNT;

//
// Define DMA 2 address and count structure.
//

typedef struct _DMA2_ADDRESS_COUNT {
    UCHAR DmaBaseAddress;
    UCHAR Reserved1;
    UCHAR DmaBaseCount;
    UCHAR Reserved2;
}DMA2_ADDRESS_COUNT, *PDMA2_ADDRESS_COUNT;

//
// Define DMA 1 control register structure.
//

typedef struct _DMA1_CONTROL {
    DMA1_ADDRESS_COUNT DmaAddressCount[4];
    UCHAR DmaStatus;
    UCHAR DmaRequest;
    UCHAR SingleMask;
    UCHAR Mode;
    UCHAR ClearBytePointer;
    UCHAR MasterClear;
    UCHAR ClearMask;
    UCHAR AllMask;
}DMA1_CONTROL, *PDMA1_CONTROL;

//
// Define DMA 2 control register structure.
//

typedef struct _DMA2_CONTROL {
    DMA2_ADDRESS_COUNT DmaAddressCount[4];
    UCHAR DmaStatus;
    UCHAR Reserved1;
    UCHAR DmaRequest;
    UCHAR Reserved2;
    UCHAR SingleMask;
    UCHAR Reserved3;
    UCHAR Mode;
    UCHAR Reserved4;
    UCHAR ClearBytePointer;
    UCHAR Reserved5;
    UCHAR MasterClear;
    UCHAR Reserved6;
    UCHAR ClearMask;
    UCHAR Reserved7;
    UCHAR AllMask;
    UCHAR Reserved8;
}DMA2_CONTROL, *PDMA2_CONTROL;

//
// Define Timer control register structure.
//

typedef struct _TIMER_CONTROL {
    UCHAR BcdMode : 1;
    UCHAR Mode : 3;
    UCHAR SelectByte : 2;
    UCHAR SelectCounter : 2;
}TIMER_CONTROL, *PTIMER_CONTROL;

//
// Define Timer status register structure.
//

typedef struct _TIMER_STATUS {
    UCHAR BcdMode : 1;
    UCHAR Mode : 3;
    UCHAR SelectByte : 2;
    UCHAR CrContentsMoved : 1;
    UCHAR OutPin : 1;
}TIMER_STATUS, *PTIMER_STATUS;

//
// Define Mode values.
//

#define TM_SIGNAL_END_OF_COUNT  0
#define TM_ONE_SHOT             1
#define TM_RATE_GENERATOR       2
#define TM_SQUARE_WAVE          3
#define TM_SOFTWARE_STROBE      4
#define TM_HARDWARE_STROBE      5

//
// Define SelectByte values
//

#define SB_COUNTER_LATCH        0
#define SB_LSB_BYTE             1
#define SB_MSB_BYTE             2
#define SB_LSB_THEN_MSB         3

//
// Define SelectCounter values.
//

#define SELECT_COUNTER_0        0
#define SELECT_COUNTER_1        1
#define SELECT_COUNTER_2        2
#define SELECT_READ_BACK        3

//
// Define Timer clock for speaker.
//

#define TIMER_CLOCK_IN  1193167     // 1.193Mhz

//
// Define NMI Status/Control register structure.
//

typedef struct _NMI_STATUS {
    UCHAR SpeakerGate : 1;
    UCHAR SpeakerData : 1;
    UCHAR DisableEisaParity : 1;
    UCHAR DisableNmi : 1;
    UCHAR RefreshToggle : 1;
    UCHAR SpeakerTimer : 1;
    UCHAR IochkNmi : 1;
    UCHAR ParityNmi : 1;
}NMI_STATUS, *PNMI_STATUS;

//
// Define NMI Enable register structure.
//

typedef struct _NMI_ENABLE {
   UCHAR RtClockAddress : 7;
   UCHAR NmiDisable : 1;
}NMI_ENABLE, *PNMI_ENABLE;
//
// Define the NMI extended status and control register structure.
//

typedef struct _NMI_EXTENDED_CONTROL {
    UCHAR BusReset : 1;
    UCHAR EnableNmiPort : 1;
    UCHAR EnableFailSafeNmi : 1;
    UCHAR EnableBusMasterTimeout : 1;
    UCHAR Reserved1 : 1;
    UCHAR PendingPortNmi : 1;
    UCHAR PendingBusMasterTimeout : 1;
    UCHAR PendingFailSafeNmi : 1;
}NMI_EXTENDED_CONTROL, *PNMI_EXTENDED_CONTROL;

//
// Define 82357 register structure.
//

typedef struct _EISA_CONTROL {
    DMA1_CONTROL Dma1BasePort;          // Offset 0x000
    UCHAR Reserved0[16];
    UCHAR Interrupt1ControlPort0;       // Offset 0x020
    UCHAR Interrupt1ControlPort1;       // Offset 0x021
    UCHAR Reserved1[32 - 2];
    UCHAR Timer1;                       // Offset 0x40
    UCHAR RefreshRequest;               // Offset 0x41
    UCHAR SpeakerTone;                  // Offset 0x42
    UCHAR CommandMode1;                 // Offset 0x43
    UCHAR Reserved17[4];
    UCHAR Timer2;                       // Offset 0x48
    UCHAR Reserved13;
    UCHAR CpuSpeedControl;              // Offset 0x4a
    UCHAR CommandMode2;                 // Offset 0x4b
    UCHAR Reserved14[21];
    UCHAR NmiStatus;                    // Offset 0x61
    UCHAR Reserved15[14];
    UCHAR NmiEnable;                    // Offset 0x70
    UCHAR Reserved16[15];
    DMA_PAGE DmaPageLowPort;            // Offset 0x080
    UCHAR Reserved2[16];
    UCHAR Interrupt2ControlPort0;       // Offset 0x0a0
    UCHAR Interrupt2ControlPort1;       // Offset 0x0a1
    UCHAR Reserved3[32-2];
    DMA2_CONTROL Dma2BasePort;          // Offset 0x0c0
    UCHAR Reserved4[0x320];
    UCHAR Dma1CountHigh[8];             // Offset 0x400
    UCHAR Reserved5[2];
    UCHAR Dma1ChainingInterrupt;        // Offset 0x40a
    UCHAR Dma1ExtendedModePort;         // Offset 0x40b
    UCHAR MasterControlPort;            // Offset 0x40c
    UCHAR SteppingLevelRegister;        // Offset 0x40d
    UCHAR IspTest1;                     // Offset 0x40e
    UCHAR IspTest2;                     // Offset 0x40f
    UCHAR Reserved6[81];
    UCHAR ExtendedNmiResetControl;      // Offset 0x461
    UCHAR NmiIoInterruptPort;           // Offset 0x462
    UCHAR Reserved7;
    UCHAR LastMaster;                   // Offset 0x464
    UCHAR Reserved8[27];
    DMA_PAGE DmaPageHighPort;           // Offset 0x480
    UCHAR Reserved12[48];
    UCHAR Dma2HighCount[16];            // Offset 0x4c0
    UCHAR Interrupt1EdgeLevel;          // Offset 0x4d0
    UCHAR Interrupt2EdgeLevel;          // Offset 0x4d1
    UCHAR Reserved9[2];
    UCHAR Dma2ChainingInterrupt;        // Offset 0x4d4
    UCHAR Reserved10;
    UCHAR Dma2ExtendedModePort;         // Offset 0x4d6
    UCHAR Reserved11[9];
    DMA_CHANNEL_STOP DmaChannelStop[8]; // Offset 0x4e0
} EISA_CONTROL, *PEISA_CONTROL;

//
// Define initialization command word 1 structure.
//

typedef struct _INITIALIZATION_COMMAND_1 {
    UCHAR Icw4Needed : 1;
    UCHAR CascadeMode : 1;
    UCHAR Unused1 : 2;
    UCHAR InitializationFlag : 1;
    UCHAR Unused2 : 3;
}INITIALIZATION_COMMAND_1, *PINITIALIZATION_COMMAND_1;

//
// Define initialization command word 4 structure.
//

typedef struct _INITIALIZATION_COMMAND_4 {
    UCHAR I80x86Mode : 1;
    UCHAR AutoEndOfInterruptMode : 1;
    UCHAR Unused1 : 2;
    UCHAR SpecialFullyNested : 1;
    UCHAR Unused2 : 3;
}INITIALIZATION_COMMAND_4, *PINITIALIZATION_COMMAND_4;

//
// Define EISA interrupt controller operational command values.
// Define operation control word 2 commands.
//

#define NONSPECIFIC_END_OF_INTERRUPT 0x20
#define SPECIFIC_END_OF_INTERRUPT    0x60

//
// Define the IRQL which the slave intterrupts the master controller.
//

#define SLAVE_IRQL_LEVEL 2

//
// Define external EISA interupts
//

#define EISA_EXTERNAL_INTERRUPTS_1  0xf8
#define EISA_EXTERNAL_INTERRUPTS_2  0xbe

//
// Define the DMA mode register structure.
//

typedef struct _DMA_EISA_MODE {
    UCHAR Channel : 2;
    UCHAR TransferType : 2;
    UCHAR AutoInitialize : 1;
    UCHAR AddressDecrement : 1;
    UCHAR RequestMode : 2;
}DMA_EISA_MODE, *PDMA_EISA_MODE;

//
// Define TransferType values.
//

#define VERIFY_TRANSFER     0x00
#define READ_TRANSFER       0x01        // Read from the device.
#define WRITE_TRANSFER      0x02        // Write to the device.

//
// Define RequestMode values.
//

#define DEMAND_REQUEST_MODE         0x00
#define SINGLE_REQUEST_MODE         0x01
#define BLOCK_REQUEST_MODE          0x02
#define CASCADE_REQUEST_MODE        0x03

//
// Define the DMA extended mode register structure.
//

typedef struct _DMA_EXTENDED_MODE {
    UCHAR ChannelNumber : 2;
    UCHAR TransferSize : 2;
    UCHAR TimingMode : 2;
    UCHAR EndOfPacketInput : 1;
    UCHAR StopRegisterEnabled : 1;
}DMA_EXTENDED_MODE, *PDMA_EXTENDED_MODE;

//
// Define the DMA extended mode register transfer size values.
//

#define BY_BYTE_8_BITS      0
#define BY_WORD_16_BITS     1
#define BY_BYTE_32_BITS     2
#define BY_BYTE_16_BITS     3

//
// Define the DMA extended mode timing mode values.
//

#define COMPATIBLITY_TIMING 0
#define TYPE_A_TIMING       1
#define TYPE_B_TIMING       2
#define BURST_TIMING        3

#ifndef DMA1_COMMAND_STATUS


//
// Define constants used by Intel 8237A DMA chip
//

#define DMA_SETMASK     4
#define DMA_CLEARMASK       0
#define DMA_READ            4  // These two appear backwards, but I think
#define DMA_WRITE           8  // the DMA docs have them mixed up
#define DMA_SINGLE_TRANSFER 0x40
#define DMA_AUTO_INIT       0x10 // Auto initialization mode
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\efipxebc.h ===
#ifndef _EFIPXEBC_H
#define _EFIPXEBC_H

/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    efipxebc.h

Abstract:

    EFI PXE Base Code Protocol



Revision History

--*/

/* 
 *  PXE Base Code protocol
 */

#define EFI_PXE_BASE_CODE_PROTOCOL \
    { 0x03c4e603, 0xac28, 0x11d3, 0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

INTERFACE_DECL(_EFI_PXE_BASE_CODE);

#define DEFAULT_TTL 4
#define DEFAULT_ToS 0
/* 
 *  Address definitions
 */

typedef union {
    UINT32      Addr[4];
    EFI_IPv4_ADDRESS    v4;
    EFI_IPv6_ADDRESS    v6;
} EFI_IP_ADDRESS;

typedef UINT16 EFI_PXE_BASE_CODE_UDP_PORT;

/* 
 *  Packet definitions
 */

typedef struct {
    UINT8                           BootpOpcode;
    UINT8                           BootpHwType;
    UINT8                           BootpHwAddrLen;
    UINT8                           BootpGateHops;
    UINT32                          BootpIdent;
    UINT16                          BootpSeconds;
    UINT16                          BootpFlags;
    UINT8                           BootpCiAddr[4];
    UINT8                           BootpYiAddr[4];
    UINT8                           BootpSiAddr[4];
    UINT8                           BootpGiAddr[4];
    UINT8                           BootpHwAddr[16];
    UINT8                           BootpSrvName[64];
    UINT8                           BootpBootFile[128];
    UINT32                          DhcpMagik;
    UINT8                           DhcpOptions[56];
} EFI_PXE_BASE_CODE_DHCPV4_PACKET;

/*  TBD in EFI v1.1
 * typedef struct {
 *     UINT8                           reserved;
 * } EFI_PXE_BASE_CODE_DHCPV6_PACKET; */

typedef union {
    UINT8                               Raw[1472];
    EFI_PXE_BASE_CODE_DHCPV4_PACKET     Dhcpv4;
/*     EFI_PXE_BASE_CODE_DHCPV6_PACKET     Dhcpv6; */
} EFI_PXE_BASE_CODE_PACKET;

typedef struct {
    UINT8                   Type;
    UINT8                   Code;
    UINT16                  Checksum;
    union {
        UINT32              reserved;
        UINT32              Mtu;
        UINT32              Pointer;
        struct {
            UINT16          Identifier;
            UINT16          Sequence;
        } Echo;
    } u;
    UINT8                   Data[494];
} EFI_PXE_BASE_CODE_ICMP_ERROR;

typedef struct {
    UINT8                   ErrorCode;
    CHAR8                   ErrorString[127];
} EFI_PXE_BASE_CODE_TFTP_ERROR;

/* 
 *  IP Receive Filter definitions
 */
#define EFI_PXE_BASE_CODE_MAX_IPCNT             8
typedef struct {
    UINT8                       Filters;
    UINT8                       IpCnt;
    UINT16                      reserved;
    EFI_IP_ADDRESS              IpList[EFI_PXE_BASE_CODE_MAX_IPCNT];
} EFI_PXE_BASE_CODE_IP_FILTER;

#define EFI_PXE_BASE_CODE_IP_FILTER_STATION_IP             0x0001
#define EFI_PXE_BASE_CODE_IP_FILTER_BROADCAST              0x0002
#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS            0x0004
#define EFI_PXE_BASE_CODE_IP_FILTER_PROMISCUOUS_MULTICAST  0x0008

/* 
 *  ARP Cache definitions
 */

typedef struct {
    EFI_IP_ADDRESS       IpAddr;
    EFI_MAC_ADDRESS      MacAddr;
} EFI_PXE_BASE_CODE_ARP_ENTRY;

typedef struct {
    EFI_IP_ADDRESS       IpAddr;
    EFI_IP_ADDRESS       SubnetMask;
    EFI_IP_ADDRESS       GwAddr;
} EFI_PXE_BASE_CODE_ROUTE_ENTRY;

/* 
 *  UDP definitions
 */

#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_IP    0x0001
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_SRC_PORT  0x0002
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_IP   0x0004
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_ANY_DEST_PORT 0x0008
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_USE_FILTER    0x0010
#define EFI_PXE_BASE_CODE_UDP_OPFLAGS_MAY_FRAGMENT  0x0020

/* 
 *  Discover() definitions
 */

#define EFI_PXE_BASE_CODE_BOOT_TYPE_BOOTSTRAP           0   
#define EFI_PXE_BASE_CODE_BOOT_TYPE_MS_WINNT_RIS        1
#define EFI_PXE_BASE_CODE_BOOT_TYPE_INTEL_LCM           2
#define EFI_PXE_BASE_CODE_BOOT_TYPE_DOSUNDI             3
#define EFI_PXE_BASE_CODE_BOOT_TYPE_NEC_ESMPRO          4
#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_WSoD            5
#define EFI_PXE_BASE_CODE_BOOT_TYPE_IBM_LCCM            6
#define EFI_PXE_BASE_CODE_BOOT_TYPE_CA_UNICENTER_TNG    7
#define EFI_PXE_BASE_CODE_BOOT_TYPE_HP_OPENVIEW         8
#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_9           9
#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_10          10
#define EFI_PXE_BASE_CODE_BOOT_TYPE_ALTIRIS_11          11
#define EFI_PXE_BASE_CODE_BOOT_TYPE_NOT_USED_12         12
#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_INSTALL      13
#define EFI_PXE_BASE_CODE_BOOT_TYPE_REDHAT_BOOT         14
#define EFI_PXE_BASE_CODE_BOOT_TYPE_REMBO               15
#define EFI_PXE_BASE_CODE_BOOT_TYPE_BEOBOOT             16
/* 
 *  17 through 32767 are reserved
 *  32768 through 65279 are for vendor use
 *  65280 through 65534 are reserved
 */
#define EFI_PXE_BASE_CODE_BOOT_TYPE_PXETEST             65535

#define EFI_PXE_BASE_CODE_BOOT_LAYER_MASK               0x7FFF
#define EFI_PXE_BASE_CODE_BOOT_LAYER_INITIAL            0x0000


typedef struct {
    UINT16                      Type;
    BOOLEAN                     AcceptAnyResponse;
    UINT8                       Reserved;
    EFI_IP_ADDRESS              IpAddr;
} EFI_PXE_BASE_CODE_SRVLIST;

typedef struct {
    BOOLEAN                     UseMCast;
    BOOLEAN                     UseBCast;
    BOOLEAN                     UseUCast;
    BOOLEAN                     MustUseList;
    EFI_IP_ADDRESS              ServerMCastIp;
    UINT16                      IpCnt;
    EFI_PXE_BASE_CODE_SRVLIST   SrvList[1];
} EFI_PXE_BASE_CODE_DISCOVER_INFO;

/* 
 *  Mtftp() definitions
 */

typedef enum {
    EFI_PXE_BASE_CODE_TFTP_FIRST,
    EFI_PXE_BASE_CODE_TFTP_GET_FILE_SIZE,
    EFI_PXE_BASE_CODE_TFTP_READ_FILE,
    EFI_PXE_BASE_CODE_TFTP_WRITE_FILE,
    EFI_PXE_BASE_CODE_TFTP_READ_DIRECTORY,
    EFI_PXE_BASE_CODE_MTFTP_GET_FILE_SIZE,
    EFI_PXE_BASE_CODE_MTFTP_READ_FILE,
    EFI_PXE_BASE_CODE_MTFTP_READ_DIRECTORY,
    EFI_PXE_BASE_CODE_MTFTP_LAST
} EFI_PXE_BASE_CODE_TFTP_OPCODE;

typedef struct {
    EFI_IP_ADDRESS   MCastIp;
    EFI_PXE_BASE_CODE_UDP_PORT  CPort;
    EFI_PXE_BASE_CODE_UDP_PORT  SPort;
    UINT16                      ListenTimeout;
    UINT16                      TransmitTimeout;
} EFI_PXE_BASE_CODE_MTFTP_INFO;

/* 
 *  PXE Base Code Mode structure
 */

#define EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES       8
#define EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES     8

typedef struct {
    BOOLEAN                         Started;
    BOOLEAN                         Ipv6Available;
    BOOLEAN                         Ipv6Supported;
    BOOLEAN                         UsingIpv6;
    BOOLEAN                         BisSupported;
    BOOLEAN                         BisDetected;
    BOOLEAN                         AutoArp;
    BOOLEAN                         SendGUID;
    BOOLEAN                         DhcpDiscoverValid;
    BOOLEAN                         DhcpAckReceived;
    BOOLEAN                         ProxyOfferReceived;
    BOOLEAN                         PxeDiscoverValid;
    BOOLEAN                         PxeReplyReceived;
    BOOLEAN                         PxeBisReplyReceived;
    BOOLEAN                         IcmpErrorReceived;
    BOOLEAN                         TftpErrorReceived;
    BOOLEAN                         MakeCallbacks;
    UINT8                           TTL;
    UINT8                           ToS;
    EFI_IP_ADDRESS                  StationIp;
    EFI_IP_ADDRESS                  SubnetMask;
    EFI_PXE_BASE_CODE_PACKET        DhcpDiscover;
    EFI_PXE_BASE_CODE_PACKET        DhcpAck;
    EFI_PXE_BASE_CODE_PACKET        ProxyOffer;
    EFI_PXE_BASE_CODE_PACKET        PxeDiscover;
    EFI_PXE_BASE_CODE_PACKET        PxeReply;
    EFI_PXE_BASE_CODE_PACKET        PxeBisReply;
    EFI_PXE_BASE_CODE_IP_FILTER     IpFilter;
    UINT32                          ArpCacheEntries;
    EFI_PXE_BASE_CODE_ARP_ENTRY     ArpCache[EFI_PXE_BASE_CODE_MAX_ARP_ENTRIES];
    UINT32                          RouteTableEntries;
    EFI_PXE_BASE_CODE_ROUTE_ENTRY   RouteTable[EFI_PXE_BASE_CODE_MAX_ROUTE_ENTRIES];
    EFI_PXE_BASE_CODE_ICMP_ERROR    IcmpError;
    EFI_PXE_BASE_CODE_TFTP_ERROR    TftpError;
} EFI_PXE_BASE_CODE_MODE;

/* 
 *  PXE Base Code Interface Function definitions
 */

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_START) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN BOOLEAN                      UseIpv6
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_STOP) (
    IN struct _EFI_PXE_BASE_CODE    *This
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_DHCP) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN BOOLEAN                      SortOffers
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_DISCOVER) (
    IN struct _EFI_PXE_BASE_CODE            *This,
    IN UINT16                               Type,
    IN UINT16                               *Layer,
    IN BOOLEAN                              UseBis,
    IN OUT EFI_PXE_BASE_CODE_DISCOVER_INFO  *Info   OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_MTFTP) (
    IN struct _EFI_PXE_BASE_CODE        *This,
    IN EFI_PXE_BASE_CODE_TFTP_OPCODE    Operation,
    IN OUT VOID                         *BufferPtr  OPTIONAL,
    IN BOOLEAN                          Overwrite,
    IN OUT UINTN                        *BufferSize,
    IN UINTN                            *BlockSize  OPTIONAL,
    IN EFI_IP_ADDRESS                   *ServerIp,
    IN UINT8                            *Filename,
    IN EFI_PXE_BASE_CODE_MTFTP_INFO     *Info       OPTIONAL,
    IN BOOLEAN                          DontUseBuffer
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_UDP_WRITE) (
    IN struct _EFI_PXE_BASE_CODE        *This,
    IN UINT16                           OpFlags,
    IN EFI_IP_ADDRESS                   *DestIp,
    IN EFI_PXE_BASE_CODE_UDP_PORT       *DestPort,
    IN EFI_IP_ADDRESS                   *GatewayIp,  OPTIONAL
    IN EFI_IP_ADDRESS                   *SrcIp,      OPTIONAL
    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,    OPTIONAL
    IN UINTN                            *HeaderSize, OPTIONAL
    IN VOID                             *HeaderPtr,  OPTIONAL
    IN UINTN                            *BufferSize,
    IN VOID                             *BufferPtr
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_UDP_READ) (
    IN struct _EFI_PXE_BASE_CODE        *This,
    IN UINT16                           OpFlags,
    IN OUT EFI_IP_ADDRESS               *DestIp,      OPTIONAL
    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *DestPort,    OPTIONAL
    IN OUT EFI_IP_ADDRESS               *SrcIp,       OPTIONAL
    IN OUT EFI_PXE_BASE_CODE_UDP_PORT   *SrcPort,     OPTIONAL
    IN UINTN                            *HeaderSize,  OPTIONAL
    IN VOID                             *HeaderPtr,   OPTIONAL
    IN OUT UINTN                        *BufferSize,
    IN VOID                             *BufferPtr
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_IP_FILTER) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN EFI_PXE_BASE_CODE_IP_FILTER  *NewFilter
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_ARP) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN EFI_IP_ADDRESS               *IpAddr,      
    IN EFI_MAC_ADDRESS              *MacAddr      OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_PARAMETERS) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN BOOLEAN                      *NewAutoArp,    OPTIONAL
    IN BOOLEAN                      *NewSendGUID,   OPTIONAL
    IN UINT8                        *NewTTL,        OPTIONAL
    IN UINT8                        *NewToS,        OPTIONAL
    IN BOOLEAN                      *NewMakeCallback    OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_STATION_IP) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    IN EFI_IP_ADDRESS               *NewStationIp,  OPTIONAL
    IN EFI_IP_ADDRESS               *NewSubnetMask  OPTIONAL
    );

typedef
EFI_STATUS
(EFIAPI *EFI_PXE_BASE_CODE_SET_PACKETS) (
    IN struct _EFI_PXE_BASE_CODE    *This,
    BOOLEAN                         *NewDhcpDiscoverValid,  OPTIONAL
    BOOLEAN                         *NewDhcpAckReceived,    OPTIONAL
    BOOLEAN                         *NewProxyOfferReceived, OPTIONAL
    BOOLEAN                         *NewPxeDiscoverValid,   OPTIONAL
    BOOLEAN                         *NewPxeReplyReceived,   OPTIONAL
    BOOLEAN                         *NewPxeBisReplyReceived,OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpDiscover, OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewDhcpAck,      OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewProxyOffer,   OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeDiscover,  OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeReply,     OPTIONAL
    IN EFI_PXE_BASE_CODE_PACKET     *NewPxeBisReply   OPTIONAL
    );

/* 
 *  PXE Base Code Protocol structure
 */

#define EFI_PXE_BASE_CODE_INTERFACE_REVISION    0x00010000

typedef struct _EFI_PXE_BASE_CODE {
    UINT64                              Revision;
    EFI_PXE_BASE_CODE_START             Start;
    EFI_PXE_BASE_CODE_STOP              Stop;
    EFI_PXE_BASE_CODE_DHCP              Dhcp;
    EFI_PXE_BASE_CODE_DISCOVER          Discover;
    EFI_PXE_BASE_CODE_MTFTP             Mtftp;
    EFI_PXE_BASE_CODE_UDP_WRITE         UdpWrite;
    EFI_PXE_BASE_CODE_UDP_READ          UdpRead;
    EFI_PXE_BASE_CODE_SET_IP_FILTER     SetIpFilter;
    EFI_PXE_BASE_CODE_ARP               Arp;
    EFI_PXE_BASE_CODE_SET_PARAMETERS    SetParameters;
    EFI_PXE_BASE_CODE_SET_STATION_IP    SetStationIp;
    EFI_PXE_BASE_CODE_SET_PACKETS       SetPackets;
    EFI_PXE_BASE_CODE_MODE              *Mode;
} EFI_PXE_BASE_CODE;

/* 
 *  Call Back Definitions
 */

#define EFI_PXE_BASE_CODE_CALLBACK_PROTOCOL \
    { 0x245dca21, 0xfb7b, 0x11d3, 0x8f, 0x01, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b }

/* 
 *  Revision Number
 */

#define EFI_PXE_BASE_CODE_CALLBACK_INTERFACE_REVISION   0x00010000

INTERFACE_DECL(_EFI_PXE_BASE_CODE_CALLBACK);

typedef enum {
    EFI_PXE_BASE_CODE_FUNCTION_FIRST,
    EFI_PXE_BASE_CODE_FUNCTION_DHCP,
    EFI_PXE_BASE_CODE_FUNCTION_DISCOVER,
    EFI_PXE_BASE_CODE_FUNCTION_MTFTP,
    EFI_PXE_BASE_CODE_FUNCTION_UDP_WRITE,
    EFI_PXE_BASE_CODE_FUNCTION_UDP_READ,
    EFI_PXE_BASE_CODE_FUNCTION_ARP,
    EFI_PXE_BASE_CODE_FUNCTION_IGMP,
    EFI_PXE_BASE_CODE_PXE_FUNCTION_LAST
} EFI_PXE_BASE_CODE_FUNCTION;

typedef enum {
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_FIRST,
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_CONTINUE,
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_ABORT,
    EFI_PXE_BASE_CODE_CALLBACK_STATUS_LAST
} EFI_PXE_BASE_CODE_CALLBACK_STATUS;

typedef
EFI_PXE_BASE_CODE_CALLBACK_STATUS 
(EFIAPI *EFI_PXE_CALLBACK) (
    IN struct _EFI_PXE_BASE_CODE_CALLBACK   *This,
    IN EFI_PXE_BASE_CODE_FUNCTION           Function,
    IN BOOLEAN                              Received,
    IN UINTN                                PacketLen,
    IN EFI_PXE_BASE_CODE_PACKET             *Packet     OPTIONAL
    );

typedef struct _EFI_PXE_BASE_CODE_CALLBACK {
    UINT64                      Revision;
    EFI_PXE_CALLBACK            Callback;
} EFI_PXE_BASE_CODE_CALLBACK;

#endif /* _EFIPXEBC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\em387.inc ===
subttl  em387.inc - Emulator Internal Format and Macros
	page
;***
;em387.inc - Emulator Internal Format and Macros
;
;	 Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1987, 1992
;
;	 All Rights Reserved
;
;Purpose:
;	Emulator Internal Format and Macros
;
;Revision History:  (also see emulator.hst)
;
;    8/23/91  TP    New tag definitions
;   10/30/89  WAJ   Added this header.
;   02/12/89  WAJ   Added local stack frame definition.
;
;*******************************************************************************


GetEmData	macro	dest,use
ifdef	_CRUISER
	mov	dest,[edataSEG]
elseifdef  _DOS32EXT
ifdifi	<use>,<ax>
	push	eax
	call	_SelKrnGetEmulData
	mov	dest,ax
	pop	eax
else
	call	_SelKrnGetEmulData
	mov	dest,ax
endif
endif
	endm



;The SKIP macro optimizes very short jumps by treating the code
;as data to a "cmp" instruction.  This reduces jump time from
;8 clocks or more down to 2 clocks.  It destroy the flags!

SKIP	macro	dist,target
if	dist eq 4
	db	3DH			;cmp eax,<immed>
elseif	dist eq 3
	db	3DH,0			;cmp eax,<immed>
elseif	dist eq 2
	db	66H,3DH			;cmp ax,<immed>
elseif	dist eq 1
	db	3CH			;cmp al,<immed>
else
	.err
endif

	ifnb	<target>
.erre	$+dist eq target
	endif

	endm

;*******************************************************************************
;
;   80x87 environment structures.
;
;*******************************************************************************


Env80x87_32 struc
	E32_ControlWord	dw	?
	reserved1		dw	?
	E32_StatusWord	dw	?
	reserved2		dw	?
	E32_TagWord		dw	?
	reserved3		dw	?
	E32_CodeOff		dd	?
	E32_CodeSeg		dw	?
	reserved4		dw	?
	E32_DataOff		dd	?
	E32_DataSeg		dw	?
	reserved5		dw	?
Env80x87_32 ends


;---------------------------------------------------------------------------
;
; Emulator Internal Format:
;
;	     +0  +1  +2  +3  +4  +5  +6  +7  +8  +9  +10 +11
;	    .___.___.___.___.___.___.___.___.___.___.___.___.
;   ptr --> |___|___|___|___|___|___|___|___|___|___|___|___|
;	     lsb			 msb tag sgn exl exh
;	    |<---      mantissa 	--->|       |exponent
;
;   The mantissa contains the leading 1 before the decimal point in the hi
;   bit of the msb. The exponent is not biased (signed two's complement).
;   The flag and tag bytes are as below.
;
;   bit:      7   6   5   4   3   2   1   0
;	    .___.___.___.___.___.___.___.___.
;   Sign:   |___|_X_|_X_|_X_|_X_|_X_|_X_|_X_|  X = unused
;	      ^ 
;     SIGN
;
;
;   bit:      7   6   5   4   3   2   1   0
;	    .___.___.___.___.___.___.___.___.
;   Tag:    |___|___|_X_|_X_|___|___|___|___|  X = unused
;	      ^	  ^	      ^	  ^   ^   ^
;	      |	  |	      |	  |   |	  |
;    387 tag -+---+	      |	  |   |   |
;			      |	  |   |	  |
;    Special enumeration -----+---+   |	  |
;				      |	  |
;    Internal tag --------------------+---+
;
;There are four internal tags: Single, Double, Zero, Special.  Within
;Special, there is NAN, Infinity, Denormal, and Empty.
;
;Representations for Single, Double, and Denormal are the same.  Denormals
;are not actually kept denormalized, although they are rounded to the
;correct number of bits as if they were.  The Single tag means the 
;low 32 bits of the mantissa are zero.  This allows optimizing multiply 
;and divide.
;
;Tag		Mantissa	Exponent	Sign
;---------------------------------------------------
;Zero		0		0		valid
;Empty		?		?		?
;NAN		valid		TexpMax		valid
;Infinity	8000...000	TexpMax		valid
;
;The mantissa for a NAN distinguishes between a quiet NAN (QNAN) or a 
;signaling NAN (SNAN).  If the bit below the MSB is 1, it is a QNAN,
;otherwise it is an SNAN.
;


;*******************************************************************************
;*
;*  Stack entry defineds with a struct.
;*
;*******************************************************************************

EmStackEntry struc
    bMan0   db	    ?
    bMan1   db	    ?
    bMan2   db	    ?
    bMan3   db	    ?
    bMan4   db	    ?
    bMan5   db	    ?
    bMan6   db	    ?
    bMan7   db	    ?
    bTag    db	    ?
    bSgn    db      ?
    bExpLo  db      ?
    bExpHi  db      ?
EmStackEntry ends

wMantisa struc
    wMan0   dw	    ?
    wMan1   dw	    ?
    wMan2   dw	    ?
    wMan3   dw	    ?
    TagSgn  dw	    ?
    wExp    dw	    ?
wMantisa ends


lMantisa struc
    lManLo	dd	?
    lManHi	dd	?
    ExpSgn	dd	?
lMantisa ends

.erre	size lMantisa eq size wMantisa

Reg87Len	equ	size lMantisa


;*******************************************************************************
;*
;*  bFlags and bTag constants.
;*
;*******************************************************************************

;The rules for internal number formats:
;
;1. Everything is either normalized or zero--unnormalized formats cannot
;get in.  So if the high half mantissa is zero, the number must be all zero.
;
;2. Although the exponent bias is different, NANs and Infinities are in
;standard IEEE format - exponent is TexpMax, mantissa indicates NAN vs.
;infinity (mantissa for infinity is 800..000H).
;
;3. Denormals have an exponent less than TexpMin.
;
;4. If the low half of the mantissa is zero, it is tagged bTAG_SNGL
;
;5. Everything else is bTAG_VALID


bSign	    equ     80h

;These are the INTERNAL flags
TAG_MASK	equ	3
TAG_SHIFT	equ	2
;
TAG_SNGL	equ	0		;SINGLE: low 32 bits are zero
TAG_VALID	equ	1
TAG_ZERO	equ	2
TAG_SPCL	equ	3		;NAN, Infinity, Denormal, Empty
ZEROorSPCL      equ     2	       ;Test for Zero or Special
;Enumeration of "special":
TAG_SPCLBITS	equ	0CH
TAG_EMPTY	equ	TAG_SPCL+(0 shl TAG_SHIFT)
TAG_INF		equ	TAG_SPCL+(1 shl TAG_SHIFT)
TAG_NAN		equ	TAG_SPCL+(2 shl TAG_SHIFT)
TAG_DEN		equ	TAG_SPCL+(3 shl TAG_SHIFT)

;These are the tags used by the 387
T87_VALID	equ	0
T87_ZERO	equ	1
T87_SPCL	equ	2		;NAN, Infinity, Denormal
T87_EMPTY	equ	3

;The tag word for each stack entry combines these two tags.
;Internal tags are in the low bits, 387 tags are in the high two bits
bTAG_VALID	equ	(T87_VALID shl 6) or TAG_VALID
bTAG_SNGL	equ	(T87_VALID shl 6) or TAG_SNGL
bTAG_ZERO	equ	(T87_ZERO shl 6) or TAG_ZERO
bTAG_NAN	equ	(T87_SPCL shl 6) or TAG_NAN
bTAG_INF	equ	(T87_SPCL shl 6) or TAG_INF
bTAG_EMPTY	equ	(T87_EMPTY shl 6) or TAG_EMPTY
bTAG_DEN	equ	(T87_SPCL shl 6) or TAG_DEN
bTAG_NOPOP	equ	-1

bTAG_MASK   equ     3



MantissaByteCnt equ	8

IexpBias	equ	3FFFh	; 16,383
IexpMax 	equ	7FFFh	; Biased Exponent for Infinity
IexpMin 	equ	0	; Biased Exponent for zero

DexpBias	equ	3FFh	; 1023
DexpMax 	equ	7FFh	; Biased Exponent for Infinity
DexpMin 	equ	0	; Biased Exponent for zero

SexpBias	equ	07Fh	; 127
SexpMax 	equ	0FFh	; Biased Exponent for Infinity
SexpMin 	equ	0	; Biased Exponent for zero

TexpBias	equ	0	; Bias for internal format of temp real
UnderBias	equ	24576	; 3 * 2^13.  Extra bias for unmasked underflow
TexpMax		equ	IexpMax - IexpBias + TexpBias	;NAN/Infinity exponent
TexpMin		equ	IexpMin-IexpBias+1	;Smallest non-denormal exponent

; Control Word Format	CWcntl

RoundControl		equ	0Ch
    RCchop		equ	0Ch
    RCup		equ	08h
    RCdown		equ	04h
    RCnear		equ	 0

PrecisionControl	equ	03h
    PC24		equ	 0
    PC53		equ	02h
    PC64		equ	03h

; Status Word Format	SWcc
    C0			equ	01h
    C1			equ	02h
    C2			equ	04h
    C3			equ	40h
ConditionCode		equ	C3 or C2 or C1 or C0
    CCgreater		equ	 0
    CCless		EQU	C0
    CCequal		equ	C3
    CCincomprable	equ	C3 or C2 or C0

RoundUp			equ	C1
StackOverflow		equ	C1

; Status Flags Format	CURerr

Invalid 		equ	   1h		; chip status flags
Denormal		equ	   2h
ZeroDivide		equ	   4h
Overflow		equ	   8h
Underflow		equ	  10h
Precision		equ	  20h
StackFlag		equ	  40h
Summary 		equ	  80h

SavedErrs		equ	Invalid or Denormal or ZeroDivide or Overflow or Underflow or Precision or StackFlag
LongSavedFlags	equ	(CCincomprable SHL 16) OR (SavedErrs SHL 8)	; save C0, C2, C3 & errs
;*******************************************************************************
;*
;*  Define emulator interrupt stack frame.
;*
;*******************************************************************************

StackFrame   struc
            regEAX	    dd	    ?
	    regECX	    dd	    ?
	    regEDX	    dd	    ?
	    regEBX	    dd	    ?
	    regESP	    dd	    ?
	    regEBP	    dd	    ?
	    regESI	    dd	    ?
	    regEDI	    dd	    ?
	    OldCodeOff      dd      ?
	    OldLongStatus   dd      ?
	    regDS	    dd	    ?
	    regEIP	    dd	    ?
	    regCS	    dd	    ?
	    regFlg	    dd	    ?
StackFrame  ends

regAX	    equ		    word ptr regEAX

; .erre   StatusWord eq LongStatusWord+1
OldStatus   equ		    word ptr OldLongStatus+1

;*******************************************************************************
;*
;*  Define emulator entry point macro.
;*
;*******************************************************************************

EM_ENTRY	macro	entryname
ifdef NT386
public ___&entryname
___&entryname:
endif			; ifdef NT386
		endm

Em87Busy	EQU	1
Em87Idle	EQU	0



ifdef NT386
;*********************************************************************;
;								      ;
;                     Emulator TEB Layout                             ;
;								      ;
;*********************************************************************;

.errnz (TbSystemReserved1 and 3)        ; Make sure TB is dword aligned

Numlev          equ     8               ; Number of stack registers

InitControlWord	equ	37FH		; Default - Round near,
					; 64 bits, all exceptions masked

DefaultControlWord equ  27FH            ; Default - Round near,
                                        ; 53 bits, all exceptions masked

EmulatorTebData struc
    TbSystemResrvd  db      TbSystemReserved1 DUP (?)   ; Skip to Emulator area

    RoundMode       dd      ?           ; Address of rounding routine
    SavedRoundMode  dd      ?           ; For restoring RoundMode
    ZeroVector      dd      ?           ; Address of sum-to-zero routine
    TransRound      dd      ?           ; Round mode w/o precision
    Result          dd      ?           ; Result pointer
    PrevCodeOff     dd      ?
    PrevDataOff     dd      ?

    ;(See comment below on 'emulator stack area'
    CURstk          dd      ?           ; init to start of stack
    BEGstk          db      (Numlev-1)*Reg87Len dup(?) ;Allocate register 1 - 7
    INITstk         db      Reg87Len dup(?)

    FloatTemp       db      Reg87Len dup(?)
    ArgTemp         db      Reg87Len dup(?)

    Einstall        db      0           ; Emulator installed flag
    SWerr           db      ?           ; Initially no exceptions (sticky flags)
    SWcc            db      ?           ; Condition codes from various operations
    CURerr          db      ?           ; initially 8087 exception flags clear
                                        ; this is the internal flag reset after
                                        ; each operation to detect per instruction
                                        ; errors
    CWmask          db      ?           ; exception masks
    CWcntl          db      ?           ; arithmetic control flags
    ErrMask         db      ?
    dummy           db      ?
EmulatorTebData ends

ENDstk          equ byte ptr INITstk + Reg87Len
LongStatusWord  equ dword ptr Einstall  ;Combine Einstall, CURerr, StatusWord
StatusWord      equ word ptr SWerr      ;Combine SWerr, SWcc
CurErrCond      equ word ptr SWcc       ;Combine SWcc, CURErr
LongControlWord equ dword ptr CWmask    ;Combine CWMask, CWcntl, ErrMask, dummy
ControlWord     equ word ptr CWmask     ;Combine CWMask, CWcntl

YFloatTemp      equ FloatTemp
YArgTemp        equ ArgTemp

.errnz (SWerr   - Einstall -1)
.errnz (SWcc    - Einstall -2)
.errnz (CURerr  - Einstall -3)
.errnz (CWcntl  - CWmask   -1)
.errnz (ErrMask - CWmask   -2)
.errnz (dummy   - CWmask   -3)


;*******************************************************************************
;
; Emulator stack area
;
;The top of stack pointer CURstk is initialized to the last register 
;in the list; on a real 8087, this corresponds to hardware register 0.
;The stack grows toward lower addresses, so the first push (which is
;hardware register 7) is stored into the second-to-last slot.  This gives
;the following relationship between hardware registers and memory
;locations:
;
; BEGstk --> |    reg 1    |  (lowest memory address)
; 	     |    reg 2    |
; 	     |    reg 3    |
; 	     |    reg 4    |
; 	     |    reg 5    |
; 	     |    reg 6    |
; 	     |    reg 7    |
; 	     |    reg 0    |  <-- Initial top of stack (empty)
; ENDstk -->
;
;This means that the wrap-around case on decrementing CURstk will not
;occur until the last (8th) item is pushed.
;
;Note that the physical register numbers are only used in regard to
;the tag word.  All other operations are relative the current top.


endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\exboosts.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exboosts.h

Abstract:

    This file contains all of the Priority boots numbers used by the NT
    executive.

Author:

    Steve Wood (stevewo) 03-Jun-1989

Revision History:

--*/

// begin_ntddk begin_wdm begin_ntifs begin_ntosp
//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

// end_ntddk end_wdm end_ntifs end_ntosp
//
// Priority increment used when satisfying a wait on an executive event pair
//

#define EVENT_PAIR_INCREMENT            1

//
// Priority increment used when satisfying a wait on a semaphore used for
// LPC communication.
//

#define LPC_RELEASE_WAIT_INCREMENT      1

// begin_ntddk begin_wdm begin_ntifs begin_ntosp
//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0


//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1

// end_ntifs

//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6

// begin_ntifs
//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2

// end_ntifs
//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6

// begin_ntifs
//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2

// end_ntifs
//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

// end_ntddk end_wdm
//
// Priority increment used when satisfying a wait on an executive mutant
// (NtReleaseMutant)
//

#define MUTANT_INCREMENT                1

// begin_ntddk begin_wdm begin_ntifs
//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1

// end_ntddk end_wdm end_ntifs end_ntosp
//
// Priority increment used when queuing an APC for an executive timer.
//

#define TIMER_APC_INCREMENT             0

//
// Priority increment used to get slow exclusive eresource holders
// moving again.
//

#define ERESOURCE_INCREMENT             4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\exlevels.h ===
//
// Kernel Mutex Level Numbers (must be globallly assigned within executive)
// The third token in the name is the sub-component name that defines and
// uses the level number.
//

//
// Used by Vdm for protecting io simulation structures
//

#define MUTEX_LEVEL_VDM_IO                  (ULONG)0x00000001

#define MUTEX_LEVEL_EX_PROFILE              (ULONG)0x00000040

//
// The LANMAN Redirector uses the file system major function, but defines
// it's own mutex levels.  We can do this safely because we know that the
// local filesystem will never call the remote filesystem and vice versa.
//

#define MUTEX_LEVEL_RDR_FILESYS_DATABASE    (ULONG)0x10100000
#define MUTEX_LEVEL_RDR_FILESYS_SECURITY    (ULONG)0x10100001

//
// File System levels.
//

#define MUTEX_LEVEL_FILESYSTEM_RAW_VCB      (ULONG)0x11000006

//
// In the NT STREAMS environment, a mutex is used to serialize open, close
// and Scheduler threads executing in a subsystem-parallelized stack.
//

#define MUTEX_LEVEL_STREAMS_SUBSYS          (ULONG)0x11001001

//
// Mutex level used by LDT support on x86
//

#define MUTEX_LEVEL_PS_LDT                  (ULONG)0x1F000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\ex.h ===
/*++ BUILD Version: 0007    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ex.h

Abstract:

    Public executive data structures and procedure prototypes.

Author:

    Mark Lucovsky (markl) 23-Feb-1989

Revision History:

--*/

#ifndef _EX_
#define _EX_

//
// Define caller count hash table structures and function prototypes.
//

#define CALL_HASH_TABLE_SIZE 64

typedef struct _CALL_HASH_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID CallersAddress;
    PVOID CallersCaller;
    ULONG CallCount;
} CALL_HASH_ENTRY, *PCALL_HASH_ENTRY;

typedef struct _CALL_PERFORMANCE_DATA {
    KSPIN_LOCK SpinLock;
    LIST_ENTRY HashTable[CALL_HASH_TABLE_SIZE];
} CALL_PERFORMANCE_DATA, *PCALL_PERFORMANCE_DATA;

VOID
ExInitializeCallData(
    IN PCALL_PERFORMANCE_DATA CallData
    );

VOID
ExRecordCallerInHashTable(
    IN PCALL_PERFORMANCE_DATA CallData,
    IN PVOID CallersAddress,
    IN PVOID CallersCaller
    );

#define RECORD_CALL_DATA(Table)                                            \
    {                                                                      \
        PVOID CallersAddress;                                              \
        PVOID CallersCaller;                                               \
        RtlGetCallersAddress(&CallersAddress, &CallersCaller);             \
        ExRecordCallerInHashTable((Table), CallersAddress, CallersCaller); \
    }

//
// Define executive event pair object structure.
//

typedef struct _EEVENT_PAIR {
    KEVENT_PAIR KernelEventPair;
} EEVENT_PAIR, *PEEVENT_PAIR;

//
// empty struct def so we can forward reference ETHREAD
//

struct _ETHREAD;

//
// System Initialization procedure for EX subcomponent of NTOS (in exinit.c)
//

NTKERNELAPI
BOOLEAN
ExInitSystem(
    VOID
    );

NTKERNELAPI
VOID
ExInitSystemPhase2(
    VOID
    );

VOID
ExInitPoolLookasidePointers (
    VOID
    );

ULONG
ExComputeTickCountMultiplier (
    IN ULONG TimeIncrement
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis begin_ntosp
//
// Pool Allocation routines (in pool.c)
//

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType

    // end_wdm
    ,
    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    // begin_wdm

    } POOL_TYPE;

#define POOL_COLD_ALLOCATION 256     // Note this cannot encode into the header.

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis begin_ntosp

//
// The following two definitions control the raising of exceptions on quota
// and allocation failures.
//

#define POOL_QUOTA_FAIL_INSTEAD_OF_RAISE 8
#define POOL_RAISE_IF_ALLOCATION_FAILURE 16               // ntifs


// end_ntosp

VOID
InitializePool(
    IN POOL_TYPE PoolType,
    IN ULONG Threshold
    );

//
// These routines are private to the pool manager and the memory manager.
//

VOID
ExInsertPoolTag (
    ULONG Tag,
    PVOID Va,
    SIZE_T NumberOfBytes,
    POOL_TYPE PoolType
    );

VOID
ExAllocatePoolSanityChecks(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

VOID
ExFreePoolSanityChecks(
    IN PVOID P
    );

// begin_ntddk begin_nthal begin_ntifs begin_wdm begin_ntosp

NTKERNELAPI
PVOID
ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
ExAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

//
// _EX_POOL_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPoolPriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPoolPriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPoolPriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//
// SpecialPool can be specified to bound the allocation at a page end (or
// beginning).  This should only be done on systems being debugged as the
// memory cost is expensive.
//
// N.B.  These values are very carefully chosen so that the pool allocation
//       code can quickly crack the priority request.
//

typedef enum _EX_POOL_PRIORITY {
    LowPoolPriority,
    LowPoolPrioritySpecialPoolOverrun = 8,
    LowPoolPrioritySpecialPoolUnderrun = 9,
    NormalPoolPriority = 16,
    NormalPoolPrioritySpecialPoolOverrun = 24,
    NormalPoolPrioritySpecialPoolUnderrun = 25,
    HighPoolPriority = 32,
    HighPoolPrioritySpecialPoolOverrun = 40,
    HighPoolPrioritySpecialPoolUnderrun = 41

    } EX_POOL_PRIORITY;

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTagPriority(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN EX_POOL_PRIORITY Priority
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif //POOL_TAGGING

NTKERNELAPI
PVOID
ExAllocatePoolWithQuotaTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithQuotaTag(a,b,c) ExAllocatePoolWithQuota(a,b)
#endif //POOL_TAGGING

NTKERNELAPI
VOID
NTAPI
ExFreePool(
    IN PVOID P
    );

// end_wdm
#if defined(POOL_TAGGING)
#define ExFreePool(a) ExFreePoolWithTag(a,0)
#endif

//
// If high order bit in Pool tag is set, then must use ExFreePoolWithTag to free
//

#define PROTECTED_POOL 0x80000000

// begin_wdm
NTKERNELAPI
VOID
ExFreePoolWithTag(
    IN PVOID P,
    IN ULONG Tag
    );

// end_ntddk end_wdm end_nthal end_ntifs


#ifndef POOL_TAGGING
#define ExFreePoolWithTag(a,b) ExFreePool(a)
#endif //POOL_TAGGING

// end_ntosp


NTKERNELAPI
KIRQL
ExLockPool(
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
VOID
ExUnlockPool(
    IN POOL_TYPE PoolType,
    IN KIRQL LockHandle
    );

// begin_ntosp
NTKERNELAPI                                     // ntifs
SIZE_T                                          // ntifs
ExQueryPoolBlockSize (                          // ntifs
    IN PVOID PoolBlock,                         // ntifs
    OUT PBOOLEAN QuotaCharged                   // ntifs
    );                                          // ntifs
// end_ntosp

NTKERNELAPI
VOID
ExQueryPoolUsage(
    OUT PULONG PagedPoolPages,
    OUT PULONG NonPagedPoolPages,
    OUT PULONG PagedPoolAllocs,
    OUT PULONG PagedPoolFrees,
    OUT PULONG PagedPoolLookasideHits,
    OUT PULONG NonPagedPoolAllocs,
    OUT PULONG NonPagedPoolFrees,
    OUT PULONG NonPagedPoolLookasideHits
    );

VOID
ExReturnPoolQuota (
    IN PVOID P
    );

#if DBG || (i386 && !FPO)
NTKERNELAPI
NTSTATUS
ExSnapShotPool(
    IN POOL_TYPE PoolType,
    IN PSYSTEM_POOL_INFORMATION PoolInformation,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL
    );
#endif // DBG || (i386 && !FPO)


// begin_ntifs begin_ntddk begin_wdm begin_nthal begin_ntosp
//
// Routines to support fast mutexes.
//

typedef struct _FAST_MUTEX {
    LONG Count;
    PKTHREAD Owner;
    ULONG Contention;
    KEVENT Event;
    ULONG OldIrql;
} FAST_MUTEX, *PFAST_MUTEX;

#define ExInitializeFastMutex(_FastMutex)                            \
    (_FastMutex)->Count = 1;                                         \
    (_FastMutex)->Owner = NULL;                                      \
    (_FastMutex)->Contention = 0;                                    \
    KeInitializeEvent(&(_FastMutex)->Event,                          \
                      SynchronizationEvent,                          \
                      FALSE);

NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutexUnsafe (
    IN PFAST_MUTEX FastMutex
    );

#if defined(_ALPHA_) || defined(_IA64_) || defined(_AMD64_)

NTKERNELAPI
VOID
FASTCALL
ExAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
VOID
FASTCALL
ExReleaseFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTKERNELAPI
BOOLEAN
FASTCALL
ExTryToAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

#elif defined(_X86_)

NTHALAPI
VOID
FASTCALL
ExAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTHALAPI
VOID
FASTCALL
ExReleaseFastMutex (
    IN PFAST_MUTEX FastMutex
    );

NTHALAPI
BOOLEAN
FASTCALL
ExTryToAcquireFastMutex (
    IN PFAST_MUTEX FastMutex
    );

#else

#error "Target architecture not defined"

#endif

// end_ntifs end_ntddk end_wdm end_nthal end_ntosp

#define ExIsFastMutexOwned(_FastMutex) ((_FastMutex)->Count != 1)


//
// Interlocked support routine definitions.
//
// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis begin_ntosp
//

NTKERNELAPI
VOID
FASTCALL
ExInterlockedAddLargeStatistic (
    IN PLARGE_INTEGER Addend,
    IN ULONG Increment
    );

// end_ntndis

NTKERNELAPI
LARGE_INTEGER
ExInterlockedAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment,
    IN PKSPIN_LOCK Lock
    );

//  end_ntddk end_wdm end_nthal end_ntifs end_ntosp

#if defined(NT_UP) && !defined(_NTHAL_) && !defined(_NTDDK_) && !defined(_NTIFS_)

#undef ExInterlockedAddUlong
#define ExInterlockedAddUlong(x, y, z) InterlockedExchangeAdd((PLONG)(x), (LONG)(y))

#else

//  begin_wdm begin_ntddk begin_nthal begin_ntifs begin_ntosp

NTKERNELAPI
ULONG
FASTCALL
ExInterlockedAddUlong (
    IN PULONG Addend,
    IN ULONG Increment,
    IN PKSPIN_LOCK Lock
    );

// end_wdm end_ntddk end_nthal end_ntifs end_ntosp

#endif

// begin_wdm begin_ntddk begin_nthal begin_ntifs begin_ntosp

#if defined(_AMD64_) || defined(_AXP64_) || defined(_IA64_)

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    InterlockedCompareExchange64(Destination, *(Exchange), *(Comperand))

#elif defined(_ALPHA_)

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    ExpInterlockedCompareExchange64(Destination, Exchange, Comperand)

#else

#define ExInterlockedCompareExchange64(Destination, Exchange, Comperand, Lock) \
    ExfInterlockedCompareExchange64(Destination, Exchange, Comperand)

#endif

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPopEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
ExInterlockedPushEntryList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

// end_wdm end_ntddk end_nthal end_ntifs end_ntosp
//
// Define non-blocking interlocked queue functions.
//
// A non-blocking queue is a singly link list of queue entries with a
// head pointer and a tail pointer. The head and tail pointers use
// sequenced pointers as do next links in the entries themselves. The
// queueing discipline is FIFO. New entries are inserted at the tail
// of the list and current entries are removed from the front of the
// list.
//
// Non-blocking queues require a descriptor for each entry in the queue.
// A descriptor consists of a sequenced next pointer and a PVOID data
// value. Descriptors for a queue must be preallocated and inserted in
// an SLIST before calling the function to initialize a non-blocking
// queue header. The SLIST should have as many entries as required for
// the respective queue.
//

typedef struct _NBQUEUE_BLOCK {
    ULONG64 Next;
    ULONG64 Data;
} NBQUEUE_BLOCK, *PNBQUEUE_BLOCK;

PVOID
ExInitializeNBQueueHead (
    IN PSLIST_HEADER SlistHead
    );

BOOLEAN
ExInsertTailNBQueue (
    IN PVOID Header,
    IN ULONG64 Value
    );

BOOLEAN
ExRemoveHeadNBQueue (
    IN PVOID Header,
    OUT PULONG64 Value
    );

// begin_wdm begin_ntddk begin_nthal begin_ntifs begin_ntosp begin_ntndis
//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables AMD64, IA64, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
//

#if !defined(_WINBASE_)

/*++

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#if defined(_WIN64) && (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
VOID
InitializeSListHead (
    IN PSLIST_HEADER SListHead
    );

#else

__inline
VOID
InitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

{

#ifdef _WIN64

    //
    // Slist headers must be 16 byte aligned.
    //

    if ((ULONG_PTR) SListHead & 0x0f) {

        DbgPrint( "InitializeSListHead unaligned Slist header.  Address = %p, Caller = %p\n", SListHead, _ReturnAddress());
        RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
    }

#endif

    SListHead->Alignment = 0;

    //
    // For IA-64 we save the region number of the elements of the list in a
    // separate field.  This imposes the requirement that all elements stored
    // in the list are from the same region.

#if defined(_IA64_)

    SListHead->Region = (ULONG_PTR)SListHead & VRN_MASK;

#elif defined(_AMD64_)

    SListHead->Region = 0;

#endif

    return;
}

#endif

#endif // !defined(_WINBASE_)

#define ExInitializeSListHead InitializeSListHead

PSLIST_ENTRY
FirstEntrySList (
    IN const SLIST_HEADER *SListHead
    );

/*++

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#if defined(_WIN64)

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
USHORT
ExQueryDepthSList (
    IN PSLIST_HEADER SListHead
    );

#else

__inline
USHORT
ExQueryDepthSList (
    IN PSLIST_HEADER SListHead
    )

{

    return (USHORT)(SListHead->Alignment & 0xffff);
}

#endif

#else

#define ExQueryDepthSList(_listhead_) (_listhead_)->Depth

#endif

#if defined(_WIN64)

#define ExInterlockedPopEntrySList(Head, Lock) \
    ExpInterlockedPopEntrySList(Head)

#define ExInterlockedPushEntrySList(Head, Entry, Lock) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define ExInterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#if !defined(_WINBASE_)

#define InterlockedPopEntrySList(Head) \
    ExpInterlockedPopEntrySList(Head)

#define InterlockedPushEntrySList(Head, Entry) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define InterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#else

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

#else

#define ExInterlockedPopEntrySList(ListHead, Lock) \
    InterlockedPopEntrySList(ListHead)

#define ExInterlockedPushEntrySList(ListHead, ListEntry, Lock) \
    InterlockedPushEntrySList(ListHead, ListEntry)

#endif

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#if !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry
    );

#define InterlockedFlushSList(Head) \
    ExInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

#endif // defined(_WIN64)

// end_ntddk end_wdm end_ntosp


PSLIST_ENTRY
FASTCALL
InterlockedPushListSList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY List,
    IN PSLIST_ENTRY ListEnd,
    IN ULONG Count
    );


//
// Define interlocked lookaside list structure and allocation functions.
//

VOID
ExAdjustLookasideDepth (
    VOID
    );

// begin_ntddk begin_wdm begin_ntosp

typedef
PVOID
(*PALLOCATE_FUNCTION) (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

typedef
VOID
(*PFREE_FUNCTION) (
    IN PVOID Buffer
    );

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))

typedef struct _GENERAL_LOOKASIDE {

#else

typedef struct DECLSPEC_CACHEALIGN _GENERAL_LOOKASIDE {

#endif

    SLIST_HEADER ListHead;
    USHORT Depth;
    USHORT MaximumDepth;
    ULONG TotalAllocates;
    union {
        ULONG AllocateMisses;
        ULONG AllocateHits;
    };

    ULONG TotalFrees;
    union {
        ULONG FreeMisses;
        ULONG FreeHits;
    };

    POOL_TYPE Type;
    ULONG Tag;
    ULONG Size;
    PALLOCATE_FUNCTION Allocate;
    PFREE_FUNCTION Free;
    LIST_ENTRY ListEntry;
    ULONG LastTotalAllocates;
    union {
        ULONG LastAllocateMisses;
        ULONG LastAllocateHits;
    };

    ULONG Future[2];
} GENERAL_LOOKASIDE, *PGENERAL_LOOKASIDE;

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))

typedef struct _NPAGED_LOOKASIDE_LIST {

#else

typedef struct DECLSPEC_CACHEALIGN _NPAGED_LOOKASIDE_LIST {

#endif

    GENERAL_LOOKASIDE L;

#if !defined(_AMD64_) && !defined(_IA64_)

    KSPIN_LOCK Lock__ObsoleteButDoNotDelete;

#endif

} NPAGED_LOOKASIDE_LIST, *PNPAGED_LOOKASIDE_LIST;

NTKERNELAPI
VOID
ExInitializeNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
ExDeleteNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    );

__inline
PVOID
ExAllocateFromNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

    Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead,
                                       &Lookaside->Lock__ObsoleteButDoNotDelete);


#else

    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);

#endif

    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

__inline
VOID
ExFreeToNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

        ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                    (PSLIST_ENTRY)Entry,
                                    &Lookaside->Lock__ObsoleteButDoNotDelete);

#else

        InterlockedPushEntrySList(&Lookaside->L.ListHead,
                                  (PSLIST_ENTRY)Entry);

#endif

    }
    return;
}

// end_ntndis

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_)  || defined(_NDIS_))

typedef struct _PAGED_LOOKASIDE_LIST {

#else

typedef struct DECLSPEC_CACHEALIGN _PAGED_LOOKASIDE_LIST {

#endif

    GENERAL_LOOKASIDE L;

#if !defined(_AMD64_) && !defined(_IA64_)

    FAST_MUTEX Lock__ObsoleteButDoNotDelete;

#endif

} PAGED_LOOKASIDE_LIST, *PPAGED_LOOKASIDE_LIST;

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp
//
// N.B. Nonpaged lookaside list structures and pages lookaside list
//      structures MUST be the same size for the system itself. The
//      per-processor lookaside lists for small pool and I/O are
//      allocated with one allocation.
//

#if defined(_WIN64) || (!defined(_NTDDK_) && !defined(_NTIFS_) && !defined(_NDIS_))

C_ASSERT(sizeof(NPAGED_LOOKASIDE_LIST) == sizeof(PAGED_LOOKASIDE_LIST));

#endif

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

NTKERNELAPI
VOID
ExInitializePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
ExDeletePagedLookasideList (
    IN PPAGED_LOOKASIDE_LIST Lookaside
    );

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
PVOID
ExAllocateFromPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside
    );

#else

__inline
PVOID
ExAllocateFromPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

#endif

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
VOID
ExFreeToPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    );

#else

__inline
VOID
ExFreeToPagedLookasideList(
    IN PPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {
        InterlockedPushEntrySList(&Lookaside->L.ListHead,
                                  (PSLIST_ENTRY)Entry);
    }

    return;
}

#endif

// end_ntddk end_nthal end_ntifs end_wdm end_ntosp

VOID
ExInitializeSystemLookasideList (
    IN PGENERAL_LOOKASIDE Lookaside,
    IN POOL_TYPE Type,
    IN ULONG Size,
    IN ULONG Tag,
    IN USHORT Depth,
    IN PLIST_ENTRY ListHead
    );

//
// Define per processor nonpage lookaside list structures.
//

typedef enum _PP_NPAGED_LOOKASIDE_NUMBER {
    LookasideSmallIrpList,
    LookasideLargeIrpList,
    LookasideMdlList,
    LookasideCreateInfoList,
    LookasideNameBufferList,
    LookasideTwilightList,
    LookasideCompletionList,
    LookasideMaximumList
} PP_NPAGED_LOOKASIDE_NUMBER, *PPP_NPAGED_LOOKASIDE_NUMBER;

#if !defined(_CROSS_PLATFORM_)

FORCEINLINE
PVOID
ExAllocateFromPPLookasideList (
    IN PP_NPAGED_LOOKASIDE_NUMBER Number
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified per
    processor lookaside list.

    N.B. It is possible to context switch during the allocation from a
         per processor nonpaged lookaside list, but this should happen
         infrequently and should not aversely effect the benefits of
         per processor lookaside lists.

Arguments:

    Number - Supplies the per processor nonpaged lookaside list number.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;
    PGENERAL_LOOKASIDE Lookaside;
    PKPRCB Prcb;

    ASSERT((Number >= 0) && (Number < LookasideMaximumList));

    //
    // Attempt to allocate from the per processor lookaside list.
    //

    Prcb = KeGetCurrentPrcb();
    Lookaside = Prcb->PPLookasideList[Number].P;
    Lookaside->TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->ListHead);

    //
    // If the per processor allocation attempt failed, then attempt to
    // allocate from the system lookaside list.
    //

    if (Entry == NULL) {
        Lookaside->AllocateMisses += 1;
        Lookaside = Prcb->PPLookasideList[Number].L;
        Lookaside->TotalAllocates += 1;
        Entry = InterlockedPopEntrySList(&Lookaside->ListHead);
        if (Entry == NULL) {
            Lookaside->AllocateMisses += 1;
            Entry = (Lookaside->Allocate)(Lookaside->Type,
                                          Lookaside->Size,
                                          Lookaside->Tag);
        }
    }

    return Entry;
}

FORCEINLINE
VOID
ExFreeToPPLookasideList (
    IN PP_NPAGED_LOOKASIDE_NUMBER Number,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    per processor lookaside list.

    N.B. It is possible to context switch during the free of a per
         processor nonpaged lookaside list, but this should happen
         infrequently and should not aversely effect the benefits of
         per processor lookaside lists.

Arguments:

    Number - Supplies the per processor nonpaged lookaside list number.

    Entry - Supples a pointer to the entry that is inserted in the per
        processor lookaside list.

Return Value:

    None.

--*/

{

    PGENERAL_LOOKASIDE Lookaside;
    PKPRCB Prcb;

    ASSERT((Number >= 0) && (Number < LookasideMaximumList));

    //
    // If the current depth is less than of equal to the maximum depth, then
    // free the specified entry to the per processor lookaside list. Otherwise,
    // free the entry to the system lookaside list;
    //
    //

    Prcb = KeGetCurrentPrcb();
    Lookaside = Prcb->PPLookasideList[Number].P;
    Lookaside->TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->ListHead) >= Lookaside->Depth) {
        Lookaside->FreeMisses += 1;
        Lookaside = Prcb->PPLookasideList[Number].L;
        Lookaside->TotalFrees += 1;
        if (ExQueryDepthSList(&Lookaside->ListHead) >= Lookaside->Depth) {
            Lookaside->FreeMisses += 1;
            (Lookaside->Free)(Entry);
            return;
        }
    }

    InterlockedPushEntrySList(&Lookaside->ListHead,
                              (PSINGLE_LIST_ENTRY)Entry);

    return;
}

#endif

#if i386 && !FPO

NTSTATUS
ExQuerySystemBackTraceInformation(
    OUT PRTL_PROCESS_BACKTRACES BackTraceInformation,
    IN ULONG BackTraceInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTKERNELAPI
USHORT
ExGetPoolBackTraceIndex(
    IN PVOID P
    );

#endif // i386 && !FPO

NTKERNELAPI
NTSTATUS
ExLockUserBuffer(
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PVOID *LockedBuffer,
    OUT PVOID *LockVariable
    );

NTKERNELAPI
VOID
ExUnlockUserBuffer(
    IN PVOID LockVariable
    );



// begin_ntddk begin_wdm begin_ntifs begin_ntosp

NTKERNELAPI
VOID
NTAPI
ProbeForRead(
    IN CONST VOID *Address,
    IN SIZE_T Length,
    IN ULONG Alignment
    );

// end_ntddk end_wdm end_ntifs end_ntosp

#if !defined(_NTHAL_) && !defined(_NTDDK_) && !defined(_NTIFS_)

// begin_ntosp
// Probe function definitions
//
// Probe for read functions.
//
//++
//
// VOID
// ProbeForRead(
//     IN PVOID Address,
//     IN ULONG Length,
//     IN ULONG Alignment
//     )
//
//--

#define ProbeForRead(Address, Length, Alignment)                             \
    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||                       \
           ((Alignment) == 4) || ((Alignment) == 8) ||                       \
           ((Alignment) == 16));                                             \
                                                                             \
    if ((Length) != 0) {                                                     \
        if (((ULONG_PTR)(Address) & ((Alignment) - 1)) != 0) {               \
            ExRaiseDatatypeMisalignment();                                   \
                                                                             \
        }                                                                    \
        if ((((ULONG_PTR)(Address) + (Length)) < (ULONG_PTR)(Address)) ||    \
            (((ULONG_PTR)(Address) + (Length)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) { \
            ExRaiseAccessViolation();                                        \
        }                                                                    \
    }

//++
//
// VOID
// ProbeForReadSmallStructure(
//     IN PVOID Address,
//     IN ULONG Length,
//     IN ULONG Alignment
//     )
//
//--

#define ProbeForReadSmallStructure(Address,Size,Alignment) {                 \
    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||                       \
           ((Alignment) == 4) || ((Alignment) == 8) ||                       \
           ((Alignment) == 16));                                             \
    if (Size == 0 || Size > 0x10000) {                                       \
        ASSERT (0);                                                          \
        ProbeForRead (Address,Size,Alignment);                               \
    } else {                                                                 \
        if (((ULONG_PTR)(Address) & ((Alignment) - 1)) != 0) {               \
            ExRaiseDatatypeMisalignment();                                   \
        }                                                                    \
        if ((ULONG_PTR)(Address) >= (ULONG_PTR)MM_USER_PROBE_ADDRESS) {      \
            *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;              \
        }                                                                    \
    }                                                                        \
}

// end_ntosp
#endif
// begin_ntosp

//++
//
// BOOLEAN
// ProbeAndReadBoolean(
//     IN PBOOLEAN Address
//     )
//
//--

#define ProbeAndReadBoolean(Address) \
    (((Address) >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile BOOLEAN * const)MM_USER_PROBE_ADDRESS) : (*(volatile BOOLEAN *)(Address)))

//++
//
// CHAR
// ProbeAndReadChar(
//     IN PCHAR Address
//     )
//
//--

#define ProbeAndReadChar(Address) \
    (((Address) >= (CHAR * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CHAR * const)MM_USER_PROBE_ADDRESS) : (*(volatile CHAR *)(Address)))

//++
//
// UCHAR
// ProbeAndReadUchar(
//     IN PUCHAR Address
//     )
//
//--

#define ProbeAndReadUchar(Address) \
    (((Address) >= (UCHAR * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile UCHAR * const)MM_USER_PROBE_ADDRESS) : (*(volatile UCHAR *)(Address)))

//++
//
// SHORT
// ProbeAndReadShort(
//     IN PSHORT Address
//     )
//
//--

#define ProbeAndReadShort(Address) \
    (((Address) >= (SHORT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile SHORT * const)MM_USER_PROBE_ADDRESS) : (*(volatile SHORT *)(Address)))

//++
//
// USHORT
// ProbeAndReadUshort(
//     IN PUSHORT Address
//     )
//
//--

#define ProbeAndReadUshort(Address) \
    (((Address) >= (USHORT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile USHORT * const)MM_USER_PROBE_ADDRESS) : (*(volatile USHORT *)(Address)))

//++
//
// HANDLE
// ProbeAndReadHandle(
//     IN PHANDLE Address
//     )
//
//--

#define ProbeAndReadHandle(Address) \
    (((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile HANDLE * const)MM_USER_PROBE_ADDRESS) : (*(volatile HANDLE *)(Address)))

//++
//
// PVOID
// ProbeAndReadPointer(
//     IN PVOID *Address
//     )
//
//--

#define ProbeAndReadPointer(Address) \
    (((Address) >= (PVOID * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile PVOID * const)MM_USER_PROBE_ADDRESS) : (*(volatile PVOID *)(Address)))

//++
//
// LONG
// ProbeAndReadLong(
//     IN PLONG Address
//     )
//
//--

#define ProbeAndReadLong(Address) \
    (((Address) >= (LONG * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile LONG * const)MM_USER_PROBE_ADDRESS) : (*(volatile LONG *)(Address)))

//++
//
// ULONG
// ProbeAndReadUlong(
//     IN PULONG Address
//     )
//
//--


#define ProbeAndReadUlong(Address) \
    (((Address) >= (ULONG * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile ULONG * const)MM_USER_PROBE_ADDRESS) : (*(volatile ULONG *)(Address)))

//++
//
// ULONG_PTR
// ProbeAndReadUlong_ptr(
//     IN PULONG_PTR Address
//     )
//
//--

#define ProbeAndReadUlong_ptr(Address) \
    (((Address) >= (ULONG_PTR * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile ULONG_PTR * const)MM_USER_PROBE_ADDRESS) : (*(volatile ULONG_PTR *)(Address)))

//++
//
// QUAD
// ProbeAndReadQuad(
//     IN PQUAD Address
//     )
//
//--

#define ProbeAndReadQuad(Address) \
    (((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile QUAD * const)MM_USER_PROBE_ADDRESS) : (*(volatile QUAD *)(Address)))

//++
//
// UQUAD
// ProbeAndReadUquad(
//     IN PUQUAD Address
//     )
//
//--

#define ProbeAndReadUquad(Address) \
    (((Address) >= (UQUAD * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile UQUAD * const)MM_USER_PROBE_ADDRESS) : (*(volatile UQUAD *)(Address)))

//++
//
// LARGE_INTEGER
// ProbeAndReadLargeInteger(
//     IN PLARGE_INTEGER Source
//     )
//
//--

#define ProbeAndReadLargeInteger(Source)  \
    (((Source) >= (LARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile LARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) : (*(volatile LARGE_INTEGER *)(Source)))

//++
//
// ULARGE_INTEGER
// ProbeAndReadUlargeInteger(
//     IN PULARGE_INTEGER Source
//     )
//
//--

#define ProbeAndReadUlargeInteger(Source)  \
    (((Source) >= (ULARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile ULARGE_INTEGER * const)MM_USER_PROBE_ADDRESS) : (*(volatile ULARGE_INTEGER *)(Source)))

//++
//
// UNICODE_STRING
// ProbeAndReadUnicodeString(
//     IN PUNICODE_STRING Source
//     )
//
//--

#define ProbeAndReadUnicodeString(Source)  \
    (((Source) >= (UNICODE_STRING * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile UNICODE_STRING * const)MM_USER_PROBE_ADDRESS) : (*(volatile UNICODE_STRING *)(Source)))
//++
//
// <STRUCTURE>
// ProbeAndReadStructure(
//     IN P<STRUCTURE> Source
//     <STRUCTURE>
//     )
//
//--

#define ProbeAndReadStructure(Source,STRUCTURE)  \
    (((Source) >= (STRUCTURE * const)MM_USER_PROBE_ADDRESS) ? \
        (*(STRUCTURE * const)MM_USER_PROBE_ADDRESS) : (*(STRUCTURE *)(Source)))

//
// Probe for write functions definitions.
//
//++
//
// VOID
// ProbeForWriteBoolean(
//     IN PBOOLEAN Address
//     )
//
//--

#define ProbeForWriteBoolean(Address) {                                      \
    if ((Address) >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) {               \
        *(volatile BOOLEAN * const)MM_USER_PROBE_ADDRESS = 0;                \
    }                                                                        \
                                                                             \
    *(volatile BOOLEAN *)(Address) = *(volatile BOOLEAN *)(Address);         \
}

//++
//
// VOID
// ProbeForWriteChar(
//     IN PCHAR Address
//     )
//
//--

#define ProbeForWriteChar(Address) {                                         \
    if ((Address) >= (CHAR * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile CHAR * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(volatile CHAR *)(Address) = *(volatile CHAR *)(Address);               \
}

//++
//
// VOID
// ProbeForWriteUchar(
//     IN PUCHAR Address
//     )
//
//--

#define ProbeForWriteUchar(Address) {                                        \
    if ((Address) >= (UCHAR * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile UCHAR * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile UCHAR *)(Address) = *(volatile UCHAR *)(Address);             \
}

//++
//
// VOID
// ProbeForWriteIoStatus(
//     IN PIO_STATUS_BLOCK Address
//     )
//
//--

#define ProbeForWriteIoStatus(Address) {                                     \
    if ((Address) >= (IO_STATUS_BLOCK * const)MM_USER_PROBE_ADDRESS) {       \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile IO_STATUS_BLOCK *)(Address) = *(volatile IO_STATUS_BLOCK *)(Address); \
}

#ifdef  _WIN64
#define ProbeForWriteIoStatusEx(Address, Cookie) {                                          \
    if ((Address) >= (IO_STATUS_BLOCK * const)MM_USER_PROBE_ADDRESS) {                      \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                                 \
    }                                                                                       \
    if ((ULONG_PTR)(Cookie) & (ULONG)1) {                                                            \
        *(volatile IO_STATUS_BLOCK32 *)(Address) = *(volatile IO_STATUS_BLOCK32 *)(Address);\
    } else {                                                                                \
        *(volatile IO_STATUS_BLOCK *)(Address) = *(volatile IO_STATUS_BLOCK *)(Address);    \
    }                                                                                       \
}
#else
#define ProbeForWriteIoStatusEx(Address, Cookie)    ProbeForWriteIoStatus(Address)
#endif

//++
//
// VOID
// ProbeForWriteShort(
//     IN PSHORT Address
//     )
//
//--

#define ProbeForWriteShort(Address) {                                        \
    if ((Address) >= (SHORT * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile SHORT * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile SHORT *)(Address) = *(volatile SHORT *)(Address);             \
}

//++
//
// VOID
// ProbeForWriteUshort(
//     IN PUSHORT Address
//     )
//
//--

#define ProbeForWriteUshort(Address) {                                       \
    if ((Address) >= (USHORT * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile USHORT * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(volatile USHORT *)(Address) = *(volatile USHORT *)(Address);           \
}

//++
//
// VOID
// ProbeForWriteHandle(
//     IN PHANDLE Address
//     )
//
//--

#define ProbeForWriteHandle(Address) {                                       \
    if ((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile HANDLE * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(volatile HANDLE *)(Address) = *(volatile HANDLE *)(Address);           \
}

//++
//
// VOID
// ProbeAndZeroHandle(
//     IN PHANDLE Address
//     )
//
//--

#define ProbeAndZeroHandle(Address) {                                        \
    if ((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile HANDLE * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(volatile HANDLE *)(Address) = 0;                                       \
}

//++
//
// VOID
// ProbeForWritePointer(
//     IN PVOID Address
//     )
//
//--

#define ProbeForWritePointer(Address) {                                      \
    if ((PVOID *)(Address) >= (PVOID * const)MM_USER_PROBE_ADDRESS) {        \
        *(volatile PVOID * const)MM_USER_PROBE_ADDRESS = NULL;               \
    }                                                                        \
                                                                             \
    *(volatile PVOID *)(Address) = *(volatile PVOID *)(Address);             \
}

//++
//
// VOID
// ProbeAndNullPointer(
//     IN PVOID *Address
//     )
//
//--

#define ProbeAndNullPointer(Address) {                                       \
    if ((PVOID *)(Address) >= (PVOID * const)MM_USER_PROBE_ADDRESS) {        \
        *(volatile PVOID * const)MM_USER_PROBE_ADDRESS = NULL;               \
    }                                                                        \
                                                                             \
    *(volatile PVOID *)(Address) = NULL;                                     \
}

//++
//
// VOID
// ProbeForWriteLong(
//     IN PLONG Address
//     )
//
//--

#define ProbeForWriteLong(Address) {                                        \
    if ((Address) >= (LONG * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                       \
                                                                            \
    *(volatile LONG *)(Address) = *(volatile LONG *)(Address);              \
}

//++
//
// VOID
// ProbeForWriteUlong(
//     IN PULONG Address
//     )
//
//--

#define ProbeForWriteUlong(Address) {                                        \
    if ((Address) >= (ULONG * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile ULONG *)(Address) = *(volatile ULONG *)(Address);             \
}
//++
//
// VOID
// ProbeForWriteUlong_ptr(
//     IN PULONG_PTR Address
//     )
//
//--

#define ProbeForWriteUlong_ptr(Address) {                                    \
    if ((Address) >= (ULONG_PTR * const)MM_USER_PROBE_ADDRESS) {             \
        *(volatile ULONG_PTR * const)MM_USER_PROBE_ADDRESS = 0;              \
    }                                                                        \
                                                                             \
    *(volatile ULONG_PTR *)(Address) = *(volatile ULONG_PTR *)(Address);     \
}

//++
//
// VOID
// ProbeForWriteQuad(
//     IN PQUAD Address
//     )
//
//--

#define ProbeForWriteQuad(Address) {                                         \
    if ((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(volatile QUAD *)(Address) = *(volatile QUAD *)(Address);               \
}

//++
//
// VOID
// ProbeForWriteUquad(
//     IN PUQUAD Address
//     )
//
//--

#define ProbeForWriteUquad(Address) {                                        \
    if ((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile UQUAD *)(Address) = *(volatile UQUAD *)(Address);             \
}

//
// Probe and write functions definitions.
//
//++
//
// VOID
// ProbeAndWriteBoolean(
//     IN PBOOLEAN Address,
//     IN BOOLEAN Value
//     )
//
//--

#define ProbeAndWriteBoolean(Address, Value) {                               \
    if ((Address) >= (BOOLEAN * const)MM_USER_PROBE_ADDRESS) {               \
        *(volatile BOOLEAN * const)MM_USER_PROBE_ADDRESS = 0;                \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteChar(
//     IN PCHAR Address,
//     IN CHAR Value
//     )
//
//--

#define ProbeAndWriteChar(Address, Value) {                                  \
    if ((Address) >= (CHAR * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile CHAR * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUchar(
//     IN PUCHAR Address,
//     IN UCHAR Value
//     )
//
//--

#define ProbeAndWriteUchar(Address, Value) {                                 \
    if ((Address) >= (UCHAR * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile UCHAR * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteShort(
//     IN PSHORT Address,
//     IN SHORT Value
//     )
//
//--

#define ProbeAndWriteShort(Address, Value) {                                 \
    if ((Address) >= (SHORT * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile SHORT * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUshort(
//     IN PUSHORT Address,
//     IN USHORT Value
//     )
//
//--

#define ProbeAndWriteUshort(Address, Value) {                                \
    if ((Address) >= (USHORT * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile USHORT * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteHandle(
//     IN PHANDLE Address,
//     IN HANDLE Value
//     )
//
//--

#define ProbeAndWriteHandle(Address, Value) {                                \
    if ((Address) >= (HANDLE * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile HANDLE * const)MM_USER_PROBE_ADDRESS = 0;                 \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteLong(
//     IN PLONG Address,
//     IN LONG Value
//     )
//
//--

#define ProbeAndWriteLong(Address, Value) {                                  \
    if ((Address) >= (LONG * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUlong(
//     IN PULONG Address,
//     IN ULONG Value
//     )
//
//--

#define ProbeAndWriteUlong(Address, Value) {                                 \
    if ((Address) >= (ULONG * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteQuad(
//     IN PQUAD Address,
//     IN QUAD Value
//     )
//
//--

#define ProbeAndWriteQuad(Address, Value) {                                  \
    if ((Address) >= (QUAD * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile LONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteUquad(
//     IN PUQUAD Address,
//     IN UQUAD Value
//     )
//
//--

#define ProbeAndWriteUquad(Address, Value) {                                 \
    if ((Address) >= (UQUAD * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}

//++
//
// VOID
// ProbeAndWriteSturcture(
//     IN P<STRUCTURE> Address,
//     IN <STRUCTURE> Value,
//     <STRUCTURE>
//     )
//
//--

#define ProbeAndWriteStructure(Address, Value,STRUCTURE) {                   \
    if ((STRUCTURE * const)(Address) >= (STRUCTURE * const)MM_USER_PROBE_ADDRESS) {    \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(Address) = (Value);                                                    \
}


// begin_ntifs begin_ntddk begin_wdm begin_ntosp
//
// Common probe for write functions.
//

NTKERNELAPI
VOID
NTAPI
ProbeForWrite (
    IN PVOID Address,
    IN SIZE_T Length,
    IN ULONG Alignment
    );

// end_ntifs end_ntddk end_wdm end_ntosp



//
// Timer Rundown
//

NTKERNELAPI
VOID
ExTimerRundown (
    VOID
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// Worker Thread
//

typedef enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue,
    DelayedWorkQueue,
    HyperCriticalWorkQueue,
    MaximumWorkQueue
} WORK_QUEUE_TYPE;

typedef
VOID
(*PWORKER_THREAD_ROUTINE)(
    IN PVOID Parameter
    );

typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    PWORKER_THREAD_ROUTINE WorkerRoutine;
    PVOID Parameter;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInitializeWorkItem)    // Use IoAllocateWorkItem
#endif
#define ExInitializeWorkItem(Item, Routine, Context) \
    (Item)->WorkerRoutine = (Routine);               \
    (Item)->Parameter = (Context);                   \
    (Item)->List.Flink = NULL;

DECLSPEC_DEPRECATED_DDK                     // Use IoQueueWorkItem
NTKERNELAPI
VOID
ExQueueWorkItem(
    IN PWORK_QUEUE_ITEM WorkItem,
    IN WORK_QUEUE_TYPE QueueType
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

VOID
ExSwapinWorkerThreads(
    IN BOOLEAN AllowSwap
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

NTKERNELAPI
BOOLEAN
ExIsProcessorFeaturePresent(
    ULONG ProcessorFeature
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

//
// QueueDisabled indicates that the queue is being shut down, and new
// workers should not join the queue.  WorkerCount indicates the total
// number of worker threads processing items in this queue.  These two
// pieces of information need to do a RMW together, so it's simpler to
// smush them together than to use a lock.
//

typedef union {
    struct {

#define EX_WORKER_QUEUE_DISABLED    0x80000000

        ULONG QueueDisabled :  1;

        //
        // MakeThreadsAsNecessary indicates whether this work queue is eligible
        // for dynamic creation of threads not just for deadlock detection,
        // but to ensure that the CPUs are all kept busy clearing any work
        // item backlog.
        //

        ULONG MakeThreadsAsNecessary : 1;

        ULONG WaitMode : 1;

        ULONG WorkerCount   : 29;
    };
    LONG QueueWorkerInfo;
} EX_QUEUE_WORKER_INFO;

typedef struct _EX_WORK_QUEUE {

    //
    // Queue objects that that are used to hold work queue entries and
    // synchronize worker thread activity.
    //

    KQUEUE WorkerQueue;

    //
    // Number of dynamic worker threads that have been created "on the fly"
    // as part of worker thread deadlock prevention
    //

    ULONG DynamicThreadCount;

    //
    // Count of the number of work items processed.
    //

    ULONG WorkItemsProcessed;

    //
    // Used for deadlock detection, WorkItemsProcessedLastPass equals the value
    // of WorkItemsProcessed the last time ExpDetectWorkerThreadDeadlock()
    // ran.
    //

    ULONG WorkItemsProcessedLastPass;

    //
    // QueueDepthLastPass is also part of the worker queue state snapshot
    // taken by ExpDetectWorkerThreadDeadlock().
    //

    ULONG QueueDepthLastPass;

    EX_QUEUE_WORKER_INFO Info;

} EX_WORK_QUEUE, *PEX_WORK_QUEUE;

extern EX_WORK_QUEUE ExWorkerQueue[];


// begin_ntddk begin_nthal begin_ntifs begin_ntosp
//
// Zone Allocation
//

typedef struct _ZONE_SEGMENT_HEADER {
    SINGLE_LIST_ENTRY SegmentList;
    PVOID Reserved;
} ZONE_SEGMENT_HEADER, *PZONE_SEGMENT_HEADER;

typedef struct _ZONE_HEADER {
    SINGLE_LIST_ENTRY FreeList;
    SINGLE_LIST_ENTRY SegmentList;
    ULONG BlockSize;
    ULONG TotalSegmentSize;
} ZONE_HEADER, *PZONE_HEADER;


DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExInitializeZone(
    IN PZONE_HEADER Zone,
    IN ULONG BlockSize,
    IN PVOID InitialSegment,
    IN ULONG InitialSegmentSize
    );

DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExExtendZone(
    IN PZONE_HEADER Zone,
    IN PVOID Segment,
    IN ULONG SegmentSize
    );

DECLSPEC_DEPRECATED_DDK
NTKERNELAPI
NTSTATUS
ExInterlockedExtendZone(
    IN PZONE_HEADER Zone,
    IN PVOID Segment,
    IN ULONG SegmentSize,
    IN PKSPIN_LOCK Lock
    );

//++
//
// PVOID
// ExAllocateFromZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
//--
#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExAllocateFromZone)
#endif
#define ExAllocateFromZone(Zone) \
    (PVOID)((Zone)->FreeList.Next); \
    if ( (Zone)->FreeList.Next ) (Zone)->FreeList.Next = (Zone)->FreeList.Next->Next


//++
//
// PVOID
// ExFreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExFreeToZone)
#endif
#define ExFreeToZone(Zone,Block)                                    \
    ( ((PSINGLE_LIST_ENTRY)(Block))->Next = (Zone)->FreeList.Next,  \
      (Zone)->FreeList.Next = ((PSINGLE_LIST_ENTRY)(Block)),        \
      ((PSINGLE_LIST_ENTRY)(Block))->Next                           \
    )

//++
//
// BOOLEAN
// ExIsFullZone(
//     IN PZONE_HEADER Zone
//     )
//
// Routine Description:
//
//     This routine determines if the specified zone is full or not.  A zone
//     is considered full if the free list is empty.
//
// Arguments:
//
//     Zone - Pointer to the zone header to be tested.
//
// Return Value:
//
//     TRUE if the zone is full and FALSE otherwise.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExIsFullZone)
#endif
#define ExIsFullZone(Zone) \
    ( (Zone)->FreeList.Next == (PSINGLE_LIST_ENTRY)NULL )

//++
//
// PVOID
// ExInterlockedAllocateFromZone(
//     IN PZONE_HEADER Zone,
//     IN PKSPIN_LOCK Lock
//     )
//
// Routine Description:
//
//     This routine removes an entry from the zone and returns a pointer to it.
//     The removal is performed with the specified lock owned for the sequence
//     to make it MP-safe.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage from which the
//         entry is to be allocated.
//
//     Lock - Pointer to the spin lock which should be obtained before removing
//         the entry from the allocation list.  The lock is released before
//         returning to the caller.
//
// Return Value:
//
//     The function value is a pointer to the storage allocated from the zone.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedAllocateFromZone)
#endif
#define ExInterlockedAllocateFromZone(Zone,Lock) \
    (PVOID) ExInterlockedPopEntryList( &(Zone)->FreeList, Lock )

//++
//
// PVOID
// ExInterlockedFreeToZone(
//     IN PZONE_HEADER Zone,
//     IN PVOID Block,
//     IN PKSPIN_LOCK Lock
//     )
//
// Routine Description:
//
//     This routine places the specified block of storage back onto the free
//     list in the specified zone.  The insertion is performed with the lock
//     owned for the sequence to make it MP-safe.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         entry is to be inserted.
//
//     Block - Pointer to the block of storage to be freed back to the zone.
//
//     Lock - Pointer to the spin lock which should be obtained before inserting
//         the entry onto the free list.  The lock is released before returning
//         to the caller.
//
// Return Value:
//
//     Pointer to previous block of storage that was at the head of the free
//         list.  NULL implies the zone went from no available free blocks to
//         at least one free block.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedFreeToZone)
#endif
#define ExInterlockedFreeToZone(Zone,Block,Lock) \
    ExInterlockedPushEntryList( &(Zone)->FreeList, ((PSINGLE_LIST_ENTRY) (Block)), Lock )


//++
//
// BOOLEAN
// ExIsObjectInFirstZoneSegment(
//     IN PZONE_HEADER Zone,
//     IN PVOID Object
//     )
//
// Routine Description:
//
//     This routine determines if the specified pointer lives in the zone.
//
// Arguments:
//
//     Zone - Pointer to the zone header controlling the storage to which the
//         object may belong.
//
//     Object - Pointer to the object in question.
//
// Return Value:
//
//     TRUE if the Object came from the first segment of zone.
//
//--

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExIsObjectInFirstZoneSegment)
#endif
#define ExIsObjectInFirstZoneSegment(Zone,Object) ((BOOLEAN)     \
    (((PUCHAR)(Object) >= (PUCHAR)(Zone)->SegmentList.Next) &&   \
     ((PUCHAR)(Object) < (PUCHAR)(Zone)->SegmentList.Next +      \
                         (Zone)->TotalSegmentSize))              \
)

// end_ntddk end_nthal end_ntifs end_ntosp



// begin_ntifs begin_ntddk begin_wdm begin_ntosp
//
//  Define executive resource data structures.
//

typedef ULONG_PTR ERESOURCE_THREAD;
typedef ERESOURCE_THREAD *PERESOURCE_THREAD;

typedef struct _OWNER_ENTRY {
    ERESOURCE_THREAD OwnerThread;
    union {
        LONG OwnerCount;
        ULONG TableSize;
    };

} OWNER_ENTRY, *POWNER_ENTRY;

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    POWNER_ENTRY OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    OWNER_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG_PTR CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;
//
//  Values for ERESOURCE.Flag
//

#define ResourceNeverExclusive       0x10
#define ResourceReleaseByOtherThread 0x20
#define ResourceOwnedExclusive       0x80

#define RESOURCE_HASH_TABLE_SIZE 64

typedef struct _RESOURCE_HASH_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID Address;
    ULONG ContentionCount;
    ULONG Number;
} RESOURCE_HASH_ENTRY, *PRESOURCE_HASH_ENTRY;

typedef struct _RESOURCE_PERFORMANCE_DATA {
    ULONG ActiveResourceCount;
    ULONG TotalResourceCount;
    ULONG ExclusiveAcquire;
    ULONG SharedFirstLevel;
    ULONG SharedSecondLevel;
    ULONG StarveFirstLevel;
    ULONG StarveSecondLevel;
    ULONG WaitForExclusive;
    ULONG OwnerTableExpands;
    ULONG MaximumTableExpand;
    LIST_ENTRY HashTable[RESOURCE_HASH_TABLE_SIZE];
} RESOURCE_PERFORMANCE_DATA, *PRESOURCE_PERFORMANCE_DATA;

//
// Define executive resource function prototypes.
//
NTKERNELAPI
NTSTATUS
ExInitializeResourceLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
NTSTATUS
ExReinitializeResourceLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
BOOLEAN
ExAcquireResourceSharedLite(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExAcquireResourceExclusiveLite(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExAcquireSharedStarveExclusive(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExAcquireSharedWaitForExclusive(
    IN PERESOURCE Resource,
    IN BOOLEAN Wait
    );

NTKERNELAPI
BOOLEAN
ExTryToAcquireResourceExclusiveLite(
    IN PERESOURCE Resource
    );

//
//  VOID
//  ExReleaseResource(
//      IN PERESOURCE Resource
//      );
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExReleaseResource)       // Use ExReleaseResourceLite
#endif
#define ExReleaseResource(R) (ExReleaseResourceLite(R))

NTKERNELAPI
VOID
FASTCALL
ExReleaseResourceLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
VOID
ExReleaseResourceForThreadLite(
    IN PERESOURCE Resource,
    IN ERESOURCE_THREAD ResourceThreadId
    );

NTKERNELAPI
VOID
ExSetResourceOwnerPointer(
    IN PERESOURCE Resource,
    IN PVOID OwnerPointer
    );

NTKERNELAPI
VOID
ExConvertExclusiveToSharedLite(
    IN PERESOURCE Resource
    );

NTKERNELAPI
NTSTATUS
ExDeleteResourceLite (
    IN PERESOURCE Resource
    );

NTKERNELAPI
ULONG
ExGetExclusiveWaiterCount (
    IN PERESOURCE Resource
    );

NTKERNELAPI
ULONG
ExGetSharedWaiterCount (
    IN PERESOURCE Resource
    );

// end_ntddk end_wdm end_ntosp

NTKERNELAPI
VOID
ExDisableResourceBoostLite (
    IN PERESOURCE Resource
    );

// begin_ntddk begin_wdm begin_ntosp
//
//  ERESOURCE_THREAD
//  ExGetCurrentResourceThread(
//      );
//

#define ExGetCurrentResourceThread() ((ULONG_PTR)PsGetCurrentThread())

NTKERNELAPI
BOOLEAN
ExIsResourceAcquiredExclusiveLite (
    IN PERESOURCE Resource
    );

NTKERNELAPI
ULONG
ExIsResourceAcquiredSharedLite (
    IN PERESOURCE Resource
    );

//
// An acquired resource is always owned shared, as shared ownership is a subset
// of exclusive ownership.
//
#define ExIsResourceAcquiredLite ExIsResourceAcquiredSharedLite

// end_wdm
//
//  ntddk.h stole the entrypoints we wanted so fix them up here.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInitializeResource)            // use ExInitializeResourceLite
#pragma deprecated(ExAcquireResourceShared)         // use ExAcquireResourceSharedLite
#pragma deprecated(ExAcquireResourceExclusive)      // use ExAcquireResourceExclusiveLite
#pragma deprecated(ExReleaseResourceForThread)      // use ExReleaseResourceForThreadLite
#pragma deprecated(ExConvertExclusiveToShared)      // use ExConvertExclusiveToSharedLite
#pragma deprecated(ExDeleteResource)                // use ExDeleteResourceLite
#pragma deprecated(ExIsResourceAcquiredExclusive)   // use ExIsResourceAcquiredExclusiveLite
#pragma deprecated(ExIsResourceAcquiredShared)      // use ExIsResourceAcquiredSharedLite
#pragma deprecated(ExIsResourceAcquired)            // use ExIsResourceAcquiredSharedLite
#endif
#define ExInitializeResource ExInitializeResourceLite
#define ExAcquireResourceShared ExAcquireResourceSharedLite
#define ExAcquireResourceExclusive ExAcquireResourceExclusiveLite
#define ExReleaseResourceForThread ExReleaseResourceForThreadLite
#define ExConvertExclusiveToShared ExConvertExclusiveToSharedLite
#define ExDeleteResource ExDeleteResourceLite
#define ExIsResourceAcquiredExclusive ExIsResourceAcquiredExclusiveLite
#define ExIsResourceAcquiredShared ExIsResourceAcquiredSharedLite
#define ExIsResourceAcquired ExIsResourceAcquiredSharedLite

// end_ntddk end_ntosp
#define ExDisableResourceBoost ExDisableResourceBoostLite
// end_ntifs

NTKERNELAPI
NTSTATUS
ExQuerySystemLockInformation(
    OUT struct _RTL_PROCESS_LOCKS *LockInformation,
    IN ULONG LockInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );



// begin_ntosp

//
// Push lock definitions
//
typedef struct _EX_PUSH_LOCK {

#define EX_PUSH_LOCK_WAITING   0x1
#define EX_PUSH_LOCK_EXCLUSIVE 0x2
#define EX_PUSH_LOCK_SHARE_INC 0x4

    union {
        struct {
            ULONG_PTR Waiting : 1;
            ULONG_PTR Exclusive : 1;
            ULONG_PTR Shared : sizeof (ULONG_PTR) * 8 - 2;
        };
        ULONG_PTR Value;
        PVOID Ptr;
    };
} EX_PUSH_LOCK, *PEX_PUSH_LOCK;


#if defined (NT_UP)
#define EX_CACHE_LINE_SIZE 16
#define EX_PUSH_LOCK_FANNED_COUNT 1
#else
#define EX_CACHE_LINE_SIZE 128
#define EX_PUSH_LOCK_FANNED_COUNT (PAGE_SIZE/EX_CACHE_LINE_SIZE)
#endif

//
// Define a fan out structure for n push locks each in its own cache line
//
typedef struct _EX_PUSH_LOCK_CACHE_AWARE {
    PEX_PUSH_LOCK Locks[EX_PUSH_LOCK_FANNED_COUNT];
} EX_PUSH_LOCK_CACHE_AWARE, *PEX_PUSH_LOCK_CACHE_AWARE;

//
// Define structure thats a push lock padded to the size of a cache line
//
typedef struct _EX_PUSH_LOCK_CACHE_AWARE_PADDED {
        EX_PUSH_LOCK Lock;
        union {
            UCHAR Pad[EX_CACHE_LINE_SIZE - sizeof (EX_PUSH_LOCK)];
            BOOLEAN Single;
        };
} EX_PUSH_LOCK_CACHE_AWARE_PADDED, *PEX_PUSH_LOCK_CACHE_AWARE_PADDED;


//
// Rundown protection structure
//
typedef struct _EX_RUNDOWN_REF {

#define EX_RUNDOWN_ACTIVE      0x1
#define EX_RUNDOWN_COUNT_SHIFT 0x1
#define EX_RUNDOWN_COUNT_INC   (1<<EX_RUNDOWN_COUNT_SHIFT)
    union {
        ULONG_PTR Count;
        PVOID Ptr;
    };
} EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

//
//  The Ex/Ob handle table interface package (in handle.c)
//

//
//  The Ex/Ob handle table package uses a common handle definition.  The actual
//  type definition for a handle is a pvoid and is declared in sdk/inc.  This
//  package uses only the low 32 bits of the pvoid pointer.
//
//  For simplicity we declare a new typedef called an exhandle
//
//  The 2 bits of an EXHANDLE is available to the application and is
//  ignored by the system.  The next 24 bits store the handle table entry
//  index and is used to refer to a particular entry in a handle table.
//
//  Note that this format is immutable because there are outside programs with
//  hardwired code that already assumes the format of a handle.
//

typedef struct _EXHANDLE {

    union {

        struct {

            //
            //  Application available tag bits
            //

            ULONG TagBits : 2;

            //
            //  The handle table entry index
            //

            ULONG Index : 30;

        };

        HANDLE GenericHandleOverlay;

#define HANDLE_VALUE_INC 4 // Amount to increment the Value to get to the next handle

        ULONG_PTR Value;
    };

} EXHANDLE, *PEXHANDLE;
// end_ntosp

typedef struct _HANDLE_TABLE_ENTRY_INFO {


    //
    //  The following field contains the audit mask for the handle if one
    //  exists.  The purpose of the audit mask is to record all of the accesses
    //  that may have been audited when the handle was opened in order to
    //  support "per operation" based auditing.  It is computed by walking the
    //  SACL of the object being opened and keeping a record of all of the audit
    //  ACEs that apply to the open operation going on.  Each set bit corresponds
    //  to an access that would be audited.  As each operation takes place, its
    //  corresponding access bit is removed from this mask.
    //

    ACCESS_MASK AuditMask;

} HANDLE_TABLE_ENTRY_INFO, *PHANDLE_TABLE_ENTRY_INFO;

//
//  A handle table stores multiple handle table entries, each entry is looked
//  up by its exhandle.  A handle table entry has really two fields.
//
//  The first field contains a pointer object and is overloaded with the three
//  low order bits used by ob to denote inherited, protected, and audited
//  objects.   The upper bit used as a handle table entry lock.  Note, this
//  means that all valid object pointers must be at least longword aligned and
//  have their sign bit set (i.e., be negative).
//
//  The next field contains the acces mask (sometimes in the form of a granted
//  access index, and creator callback trace) if the entry is in use or a
//  pointer in the free list if the entry is free.
//
//  Two things to note:
//
//  1. An entry is free if the object pointer is null, this means that the
//     following field contains the FreeTableEntryList.
//
//  2. An entry is unlocked if the object pointer is positive and locked if its
//     negative.  The handle package through callbacks and Map Handle to
//     Pointer will lock the entry (thus making the pointer valid) outside
//     routines can then read and reset the attributes field and the object
//     provided they don't unlock the entry.  When the callbacks return the
//     entry will be unlocked and the callers or MapHandleToPointer will need
//     to call UnlockHandleTableEntry explicitly.
//

typedef struct _HANDLE_TABLE_ENTRY {

    //
    //  The pointer to the object overloaded with three ob attributes bits in
    //  the lower order and the high bit to denote locked or unlocked entries
    //

    union {

        PVOID Object;

        ULONG ObAttributes;

        PHANDLE_TABLE_ENTRY_INFO InfoTable;

        ULONG_PTR Value;
    };

    //
    //  This field either contains the granted access mask for the handle or an
    //  ob variation that also stores the same information.  Or in the case of
    //  a free entry the field stores the index for the next free entry in the
    //  free list.  This is like a FAT chain, and is used instead of pointers
    //  to make table duplication easier, because the entries can just be
    //  copied without needing to modify pointers.
    //

    union {

        union {

            ACCESS_MASK GrantedAccess;

            struct {

                USHORT GrantedAccessIndex;
                USHORT CreatorBackTraceIndex;
            };
        };

        LONG NextFreeTableEntry;
    };

} HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY;


//
// Define a structure to track handle usage
//

#define HANDLE_TRACE_DB_MAX_STACKS 4096
#define HANDLE_TRACE_DB_STACK_SIZE 16

typedef struct _HANDLE_TRACE_DB_ENTRY {
    CLIENT_ID ClientId;
    HANDLE Handle;
#define HANDLE_TRACE_DB_OPEN   1
#define HANDLE_TRACE_DB_CLOSE  2
#define HANDLE_TRACE_DB_BADREF 3
    ULONG Type;
    PVOID StackTrace[HANDLE_TRACE_DB_STACK_SIZE];
} HANDLE_TRACE_DB_ENTRY, *PHANDLE_TRACE_DB_ENTRY;

typedef struct _HANDLE_TRACE_DEBUG_INFO {

        //
        // Current index for the stack trace DB
        //
        ULONG CurrentStackIndex;

        //
        // Save traces of those who open and close handles
        //
        HANDLE_TRACE_DB_ENTRY TraceDb[HANDLE_TRACE_DB_MAX_STACKS];

} HANDLE_TRACE_DEBUG_INFO, *PHANDLE_TRACE_DEBUG_INFO;

//
//  One handle table exists per process.  Unless otherwise specified, via a
//  call to RemoveHandleTable, all handle tables are linked together in a
//  global list.  This list is used by the snapshot handle tables call.
//


typedef struct _HANDLE_TABLE {

    //
    //  A pointer to the top level handle table tree node.
    //

    ULONG_PTR TableCode;

    //
    //  The process who is being charged quota for this handle table and a
    //  unique process id to use in our callbacks
    //

    struct _EPROCESS *QuotaProcess;
    HANDLE UniqueProcessId;


    //
    // These locks are used for table expansion and preventing the A-B-A problem
    // on handle allocate.
    //

#define HANDLE_TABLE_LOCKS 4

    EX_PUSH_LOCK HandleTableLock[HANDLE_TABLE_LOCKS];

    //
    //  The list of global handle tables.  This field is protected by a global
    //  lock.
    //

    LIST_ENTRY HandleTableList;

    //
    // Define a field to block on if a handle is found locked.
    //
    EX_PUSH_LOCK HandleContentionEvent;

    //
    // Debug info. Only allocated if we are debuggign handles
    //
    PHANDLE_TRACE_DEBUG_INFO DebugInfo;

    //
    //  The number of pages for additional info.
    //  This counter is used to improve the performance
    //  in ExGetHandleInfo
    //
    LONG ExtraInfoPages;

    //
    //  This is a singly linked list of free table entries.  We don't actually
    //  use pointers, but have each store the index of the next free entry
    //  in the list.  The list is managed as a lifo list.  We also keep track
    //  of the next index that we have to allocate pool to hold.
    //

    ULONG FirstFree;

    //
    // We free handles to this list when handle debugging is on or if we see
    // that a thread has this handles bucket lock held. The allows us to delay reuse
    // of handles to get a better chance of catching offenders
    //

    ULONG LastFree;

    //
    // This is the next handle index needing a pool allocation. Its also used as a bound
    // for good handles.
    //

    ULONG NextHandleNeedingPool;

    //
    //  The number of handle table entries in use.
    //

    LONG HandleCount;

    //
    // Define a flags field
    //
    union {
        ULONG Flags;

        //
        // For optimization we reuse handle values quickly. This can be a problem for
        // some usages of handles and makes debugging a little harder. If this
        // bit is set then we always use FIFO handle allocation.
        //
        BOOLEAN StrictFIFO : 1;
    };

} HANDLE_TABLE, *PHANDLE_TABLE;

//
//  Routines for handle manipulation.
//

//
//  Function for unlocking handle table entries
//

NTKERNELAPI
VOID
ExUnlockHandleTableEntry (
    PHANDLE_TABLE HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry
    );

//
//  A global initialization function called on at system start up
//

NTKERNELAPI
VOID
ExInitializeHandleTablePackage (
    VOID
    );

//
//  Functions to create, remove, and destroy handle tables per process.  The
//  destroy function uses a callback.
//

NTKERNELAPI
PHANDLE_TABLE
ExCreateHandleTable (
    IN struct _EPROCESS *Process OPTIONAL
    );

VOID
ExSetHandleTableStrictFIFO (
    IN PHANDLE_TABLE HandleTable
    );

NTKERNELAPI
VOID
ExRemoveHandleTable (
    IN PHANDLE_TABLE HandleTable
    );

NTKERNELAPI
NTSTATUS
ExEnableHandleTracing (
    IN PHANDLE_TABLE HandleTable
    );

typedef VOID (*EX_DESTROY_HANDLE_ROUTINE)(
    IN HANDLE Handle
    );

NTKERNELAPI
VOID
ExDestroyHandleTable (
    IN PHANDLE_TABLE HandleTable,
    IN EX_DESTROY_HANDLE_ROUTINE DestroyHandleProcedure
    );

//
//  A function to enumerate through the handle table of a process using a
//  callback.
//

typedef BOOLEAN (*EX_ENUMERATE_HANDLE_ROUTINE)(
    IN PHANDLE_TABLE_ENTRY HandleTableEntry,
    IN HANDLE Handle,
    IN PVOID EnumParameter
    );

NTKERNELAPI
BOOLEAN
ExEnumHandleTable (
    IN PHANDLE_TABLE HandleTable,
    IN EX_ENUMERATE_HANDLE_ROUTINE EnumHandleProcedure,
    IN PVOID EnumParameter,
    OUT PHANDLE Handle OPTIONAL
    );

NTKERNELAPI
VOID
ExSweepHandleTable (
    IN PHANDLE_TABLE HandleTable,
    IN EX_ENUMERATE_HANDLE_ROUTINE EnumHandleProcedure,
    IN PVOID EnumParameter
    );

//
//  A function to duplicate the handle table of a process using a callback
//

typedef BOOLEAN (*EX_DUPLICATE_HANDLE_ROUTINE)(
    IN struct _EPROCESS *Process OPTIONAL,
    IN PHANDLE_TABLE OldHandleTable,
    IN PHANDLE_TABLE_ENTRY OldHandleTableEntry,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry
    );

NTKERNELAPI
PHANDLE_TABLE
ExDupHandleTable (
    IN struct _EPROCESS *Process OPTIONAL,
    IN PHANDLE_TABLE OldHandleTable,
    IN EX_DUPLICATE_HANDLE_ROUTINE DupHandleProcedure OPTIONAL
    );

//
//  A function that enumerates all the handles in all the handle tables
//  throughout the system using a callback.
//

typedef NTSTATUS (*PEX_SNAPSHOT_HANDLE_ENTRY)(
    IN OUT PSYSTEM_HANDLE_TABLE_ENTRY_INFO *HandleEntryInfo,
    IN HANDLE UniqueProcessId,
    IN PHANDLE_TABLE_ENTRY HandleEntry,
    IN HANDLE Handle,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    );

typedef NTSTATUS (*PEX_SNAPSHOT_HANDLE_ENTRY_EX)(
    IN OUT PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX *HandleEntryInfo,
    IN HANDLE UniqueProcessId,
    IN PHANDLE_TABLE_ENTRY HandleEntry,
    IN HANDLE Handle,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    );

NTKERNELAPI
NTSTATUS
ExSnapShotHandleTables (
    IN PEX_SNAPSHOT_HANDLE_ENTRY SnapShotHandleEntry,
    IN OUT PSYSTEM_HANDLE_INFORMATION HandleInformation,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    );

NTKERNELAPI
NTSTATUS
ExSnapShotHandleTablesEx (
    IN PEX_SNAPSHOT_HANDLE_ENTRY_EX SnapShotHandleEntry,
    IN OUT PSYSTEM_HANDLE_INFORMATION_EX HandleInformation,
    IN ULONG Length,
    IN OUT PULONG RequiredLength
    );

//
//  Functions to create, destroy, and modify handle table entries the modify
//  function using a callback
//

NTKERNELAPI
HANDLE
ExCreateHandle (
    IN PHANDLE_TABLE HandleTable,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry
    );


NTKERNELAPI
BOOLEAN
ExDestroyHandle (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN PHANDLE_TABLE_ENTRY HandleTableEntry OPTIONAL
    );


typedef BOOLEAN (*PEX_CHANGE_HANDLE_ROUTINE) (
    IN OUT PHANDLE_TABLE_ENTRY HandleTableEntry,
    IN ULONG_PTR Parameter
    );

NTKERNELAPI
BOOLEAN
ExChangeHandle (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN PEX_CHANGE_HANDLE_ROUTINE ChangeRoutine,
    IN ULONG_PTR Parameter
    );

//
//  A function that takes a handle value and returns a pointer to the
//  associated handle table entry.
//

NTKERNELAPI
PHANDLE_TABLE_ENTRY
ExMapHandleToPointer (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle
    );

NTKERNELAPI
PHANDLE_TABLE_ENTRY
ExMapHandleToPointerEx (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN KPROCESSOR_MODE PreviousMode
    );

NTKERNELAPI
NTSTATUS
ExSetHandleInfo (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN PHANDLE_TABLE_ENTRY_INFO EntryInfo,
    IN BOOLEAN EntryLocked
    );

NTKERNELAPI
PHANDLE_TABLE_ENTRY_INFO
ExpGetHandleInfo (
    IN PHANDLE_TABLE HandleTable,
    IN HANDLE Handle,
    IN BOOLEAN EntryLocked
    );

#define ExGetHandleInfo(HT,H,E) \
    ((HT)->ExtraInfoPages ? ExpGetHandleInfo((HT),(H),(E)) : NULL)


//
//  Macros for resetting the owner of the handle table, and current
//  noop macro for setting fifo/lifo behaviour of the table
//

#define ExSetHandleTableOwner(ht,id) {(ht)->UniqueProcessId = (id);}

#define ExSetHandleTableOrder(ht,or) {NOTHING;}


//
// Locally Unique Identifier Services
//

NTKERNELAPI
BOOLEAN
ExLuidInitialization (
    VOID
    );

//
// VOID
// ExAllocateLocallyUniqueId (
//     PLUID Luid
//     )
//
//*++
//
// Routine Description:
//
//     This function returns an LUID value that is unique since the system
//     was last rebooted. It is unique only on the system it is generated on
//     and not network wide.
//
//     N.B. A LUID is a 64-bit value and for all practical purposes will
//          never carry in the lifetime of a single boot of the system.
//          At an increment rate of 1ns, the value would carry to zero in
//          approximately 126 years.
//
// Arguments:
//
//     Luid - Supplies a pointer to a variable that receives the allocated
//          locally unique Id.
//
// Return Value:
//
//     The allocated LUID value.
//
// --*/


extern LARGE_INTEGER ExpLuid;
extern const LARGE_INTEGER ExpLuidIncrement;

__inline
VOID
ExAllocateLocallyUniqueId (
    IN OUT PLUID Luid
    )

{
    LARGE_INTEGER Initial;

#if defined (_IA64_)
    Initial.QuadPart = InterlockedAdd64 (&ExpLuid.QuadPart, ExpLuidIncrement.QuadPart);
#else
    LARGE_INTEGER Value;


    while (1) {
        Initial.QuadPart = ExpLuid.QuadPart;

        Value.QuadPart = Initial.QuadPart + ExpLuidIncrement.QuadPart;
        Value.QuadPart = InterlockedCompareExchange64(&ExpLuid.QuadPart,
                                                      Value.QuadPart,
                                                      Initial.QuadPart);
        if (Initial.QuadPart != Value.QuadPart) {
            continue;
        }
        break;
    }

#endif

    Luid->LowPart = Initial.LowPart;
    Luid->HighPart = Initial.HighPart;
    return;
}

// begin_ntddk begin_wdm begin_ntifs begin_ntosp
//
// Get previous mode
//

NTKERNELAPI
KPROCESSOR_MODE
ExGetPreviousMode(
    VOID
    );
// end_ntddk end_wdm end_ntifs end_ntosp

//
// Raise exception from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseException (
    PEXCEPTION_RECORD ExceptionRecord
    );

// begin_ntddk begin_wdm begin_ntifs begin_ntosp
//
// Raise status from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseStatus (
    IN NTSTATUS Status
    );

// end_wdm

NTKERNELAPI
VOID
ExRaiseDatatypeMisalignment (
    VOID
    );

NTKERNELAPI
VOID
ExRaiseAccessViolation (
    VOID
    );

// end_ntddk end_ntifs end_ntosp


FORCEINLINE
VOID
ProbeForWriteSmallStructure (
    IN PVOID Address,
    IN SIZE_T Size,
    IN ULONG Alignment)
/*++

Routine Description:

    Probes a structure whose size is know at compile time

Arguments:

    Address - Address of structure
    Size    - Size of structure. This should be a compile time constant
    Alignment - Alignment of structure. This should be a compile time constant

Return Value:

    None

--*/

{
    if ((ULONG_PTR)(Address) >= (ULONG_PTR)MM_USER_PROBE_ADDRESS) {
         *(volatile UCHAR *) MM_USER_PROBE_ADDRESS = 0;
    }
    ASSERT(((Alignment) == 1) || ((Alignment) == 2) ||
           ((Alignment) == 4) || ((Alignment) == 8) ||
           ((Alignment) == 16));
    //
    // If the size of the structure is > 4k then call the standard routine.
    // wow64 uses a page size of 4k even on ia64.
    //
    if (Size == 0 || Size >= 0x1000) {
        ASSERT (0);
        ProbeForWrite (Address, Size, Alignment);
    } else {
        if (((ULONG_PTR)(Address) & ((Alignment) - 1)) != 0) {
            ExRaiseDatatypeMisalignment();
        }
        *(volatile UCHAR *)(Address) = *(volatile UCHAR *)(Address);
        if (Size > Alignment) {
            ((volatile UCHAR *)(Address))[(Size-1)&~(SIZE_T)(Alignment-1)] =
                ((volatile UCHAR *)(Address))[(Size-1)&~(SIZE_T)(Alignment-1)];
        }
    }
}

extern BOOLEAN ExReadyForErrors;

// begin_ntosp
NTKERNELAPI
NTSTATUS
ExRaiseHardError(
    IN NTSTATUS ErrorStatus,
    IN ULONG NumberOfParameters,
    IN ULONG UnicodeStringParameterMask,
    IN PULONG_PTR Parameters,
    IN ULONG ValidResponseOptions,
    OUT PULONG Response
    );
int
ExSystemExceptionFilter(
    VOID
    );

NTKERNELAPI
VOID
ExGetCurrentProcessorCpuUsage(
    IN PULONG CpuUsage
    );

NTKERNELAPI
VOID
ExGetCurrentProcessorCounts(
    OUT PULONG IdleCount,
    OUT PULONG KernelAndUser,
    OUT PULONG Index
    );
// end_ntosp

//
// The following are global counters used by the EX component to indicate
// the amount of EventPair transactions being performed in the system.
//

extern ULONG EvPrSetHigh;
extern ULONG EvPrSetLow;


//
// Debug event logging facility
//

#define EX_DEBUG_LOG_FORMAT_NONE     (UCHAR)0
#define EX_DEBUG_LOG_FORMAT_ULONG    (UCHAR)1
#define EX_DEBUG_LOG_FORMAT_PSZ      (UCHAR)2
#define EX_DEBUG_LOG_FORMAT_PWSZ     (UCHAR)3
#define EX_DEBUG_LOG_FORMAT_STRING   (UCHAR)4
#define EX_DEBUG_LOG_FORMAT_USTRING  (UCHAR)5
#define EX_DEBUG_LOG_FORMAT_OBJECT   (UCHAR)6
#define EX_DEBUG_LOG_FORMAT_HANDLE   (UCHAR)7

#define EX_DEBUG_LOG_NUMBER_OF_DATA_VALUES 4
#define EX_DEBUG_LOG_NUMBER_OF_BACK_TRACES 4

typedef struct _EX_DEBUG_LOG_TAG {
    UCHAR Format[ EX_DEBUG_LOG_NUMBER_OF_DATA_VALUES ];
    PCHAR Name;
} EX_DEBUG_LOG_TAG, *PEX_DEBUG_LOG_TAG;

typedef struct _EX_DEBUG_LOG_EVENT {
    USHORT ThreadId;
    USHORT ProcessId;
    ULONG Time : 24;
    ULONG Tag : 8;
    ULONG BackTrace[ EX_DEBUG_LOG_NUMBER_OF_BACK_TRACES ];
    ULONG Data[ EX_DEBUG_LOG_NUMBER_OF_DATA_VALUES ];
} EX_DEBUG_LOG_EVENT, *PEX_DEBUG_LOG_EVENT;

typedef struct _EX_DEBUG_LOG {
    KSPIN_LOCK Lock;
    ULONG NumberOfTags;
    ULONG MaximumNumberOfTags;
    PEX_DEBUG_LOG_TAG Tags;
    ULONG CountOfEventsLogged;
    PEX_DEBUG_LOG_EVENT First;
    PEX_DEBUG_LOG_EVENT Last;
    PEX_DEBUG_LOG_EVENT Next;
} EX_DEBUG_LOG, *PEX_DEBUG_LOG;


NTKERNELAPI
PEX_DEBUG_LOG
ExCreateDebugLog(
    IN UCHAR MaximumNumberOfTags,
    IN ULONG MaximumNumberOfEvents
    );

NTKERNELAPI
UCHAR
ExCreateDebugLogTag(
    IN PEX_DEBUG_LOG Log,
    IN PCHAR Name,
    IN UCHAR Format1,
    IN UCHAR Format2,
    IN UCHAR Format3,
    IN UCHAR Format4
    );

NTKERNELAPI
VOID
ExDebugLogEvent(
    IN PEX_DEBUG_LOG Log,
    IN UCHAR Tag,
    IN ULONG Data1,
    IN ULONG Data2,
    IN ULONG Data3,
    IN ULONG Data4
    );

VOID
ExShutdownSystem(
    IN ULONG Phase
    );

BOOLEAN
ExAcquireTimeRefreshLock(
    IN BOOLEAN Wait
    );

VOID
ExReleaseTimeRefreshLock(
    VOID
    );

VOID
ExUpdateSystemTimeFromCmos (
    IN BOOLEAN UpdateInterruptTime,
    IN ULONG   MaxSepInSeconds
    );

VOID
ExGetNextWakeTime (
    OUT PULONGLONG      DueTime,
    OUT PTIME_FIELDS    TimeFields,
    OUT PVOID           *TimerObject
    );

// begin_ntddk begin_wdm begin_ntifs begin_ntosp
//
// Set timer resolution.
//

NTKERNELAPI
ULONG
ExSetTimerResolution (
    IN ULONG DesiredTime,
    IN BOOLEAN SetResolution
    );

//
// Subtract time zone bias from system time to get local time.
//

NTKERNELAPI
VOID
ExSystemTimeToLocalTime (
    IN PLARGE_INTEGER SystemTime,
    OUT PLARGE_INTEGER LocalTime
    );

//
// Add time zone bias to local time to get system time.
//

NTKERNELAPI
VOID
ExLocalTimeToSystemTime (
    IN PLARGE_INTEGER LocalTime,
    OUT PLARGE_INTEGER SystemTime
    );

// end_ntddk end_wdm end_ntifs end_ntosp

NTKERNELAPI
VOID
ExInitializeTimeRefresh(
    VOID
    );

// begin_ntddk begin_wdm begin_ntifs begin_nthal begin_ntminiport begin_ntosp

//
// Define the type for Callback function.
//

typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;

typedef VOID (*PCALLBACK_FUNCTION ) (
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );


NTKERNELAPI
NTSTATUS
ExCreateCallback (
    OUT PCALLBACK_OBJECT *CallbackObject,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN Create,
    IN BOOLEAN AllowMultipleCallbacks
    );

NTKERNELAPI
PVOID
ExRegisterCallback (
    IN PCALLBACK_OBJECT CallbackObject,
    IN PCALLBACK_FUNCTION CallbackFunction,
    IN PVOID CallbackContext
    );

NTKERNELAPI
VOID
ExUnregisterCallback (
    IN PVOID CallbackRegistration
    );

NTKERNELAPI
VOID
ExNotifyCallback (
    IN PVOID CallbackObject,
    IN PVOID Argument1,
    IN PVOID Argument2
    );


// end_ntddk end_wdm end_ntifs end_nthal end_ntminiport end_ntosp

//
// System lookaside list structure list.
//

extern LIST_ENTRY ExSystemLookasideListHead;

//
// The current bias from GMT to LocalTime
//

extern LARGE_INTEGER ExpTimeZoneBias;
extern LONG ExpLastTimeZoneBias;
extern LONG ExpAltTimeZoneBias;
extern ULONG ExpCurrentTimeZoneId;
extern ULONG ExpRealTimeIsUniversal;
extern ULONG ExCriticalWorkerThreads;
extern ULONG ExDelayedWorkerThreads;
extern ULONG ExpTickCountMultiplier;

//
// Used for cmos clock sanity
//
extern BOOLEAN ExCmosClockIsSane;

//
// The lock handle for PAGELK section, initialized in init\init.c
//

extern PVOID ExPageLockHandle;

//
// Global executive callbacks
//

extern PCALLBACK_OBJECT ExCbSetSystemTime;
extern PCALLBACK_OBJECT ExCbSetSystemState;
extern PCALLBACK_OBJECT ExCbPowerState;


// begin_ntosp


typedef
PVOID
(*PKWIN32_GLOBALATOMTABLE_CALLOUT) ( void );

extern PKWIN32_GLOBALATOMTABLE_CALLOUT ExGlobalAtomTableCallout;

// end_ntosp

// begin_ntddk begin_ntosp begin_ntifs

//
// UUID Generation
//

typedef GUID UUID;

NTKERNELAPI
NTSTATUS
ExUuidCreate(
    OUT UUID *Uuid
    );

// end_ntddk end_ntosp end_ntifs

// begin_ntddk begin_wdm begin_ntifs
//
// suite support
//

NTKERNELAPI
BOOLEAN
ExVerifySuite(
    SUITE_TYPE SuiteType
    );

// end_ntddk end_wdm end_ntifs


// begin_ntosp

NTKERNELAPI
VOID
FASTCALL
ExfInitializeRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     );

NTKERNELAPI
VOID
FORCEINLINE
FASTCALL
ExInitializeRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     )
/*++

Routine Description:

    Initialize rundown protection structure

Arguments:

    RunRef - Rundown block to be referenced

Return Value:

    None

--*/
{
    RunRef->Count = 0;
}


//
// Reset a rundown protection block
//
NTKERNELAPI
VOID
FASTCALL
ExReInitializeRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     );

//
// Acquire rundown protection
//
NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     );

NTKERNELAPI
BOOLEAN
FASTCALL
ExAcquireRundownProtectionEx (
     IN PEX_RUNDOWN_REF RunRef,
     IN ULONG Count
     );

//
// Release rundown protection
//
NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtection (
     IN PEX_RUNDOWN_REF RunRef
     );

NTKERNELAPI
VOID
FASTCALL
ExReleaseRundownProtectionEx (
     IN PEX_RUNDOWN_REF RunRef,
     IN ULONG Count
     );

//
// Mark rundown block as rundown having been completed.
//
NTKERNELAPI
VOID
FASTCALL
ExRundownCompleted (
     IN PEX_RUNDOWN_REF RunRef
     );

//
// Wait for all protected acquires to exit
//
NTKERNELAPI
VOID
FASTCALL
ExWaitForRundownProtectionRelease (
     IN PEX_RUNDOWN_REF RunRef
     );


// end_ntosp

//
// Fast reference routines. See ntos\ob\fastref.c for algorithm description.
//
#if defined (_WIN64)
#define MAX_FAST_REFS 15
#else
#define MAX_FAST_REFS 7
#endif

typedef struct _EX_FAST_REF {
    union {
        PVOID Object;
#if defined (_WIN64)
        ULONG_PTR RefCnt : 4;
#else
        ULONG_PTR RefCnt : 3;
#endif
        ULONG_PTR Value;
    };
} EX_FAST_REF, *PEX_FAST_REF;


NTKERNELAPI
LOGICAL
FORCEINLINE
ExFastRefCanBeReferenced (
    IN EX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine allows the caller to determine if the fast reference
    structure contains cached references.

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    LOGICAL - TRUE: There were cached references in the object,
              FALSE: No cached references are available.

--*/
{
    return FastRef.RefCnt != 0;
}

NTKERNELAPI
LOGICAL
FORCEINLINE
ExFastRefCanBeDereferenced (
    IN EX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine allows the caller to determine if the fast reference
    structure contains room for cached references.

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    LOGICAL - TRUE: There is space for cached references in the object,
              FALSE: No space was available.

--*/
{
    return FastRef.RefCnt != MAX_FAST_REFS;
}

NTKERNELAPI
LOGICAL
FORCEINLINE
ExFastRefIsLastReference (
    IN EX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine allows the caller to determine if the fast reference
    structure contains only 1 cached reference.

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    LOGICAL - TRUE: There is only one cached reference in the object,
              FALSE: The is more or less than one cached reference available.

--*/
{
    return FastRef.RefCnt == 1;
}


NTKERNELAPI
PVOID
FORCEINLINE
ExFastRefGetObject (
    IN EX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine allows the caller to obtain the object pointer from a fast
    reference structure.

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    PVOID - The contained object or NULL if there isn't one.

--*/
{
    return (PVOID) (FastRef.Value & ~MAX_FAST_REFS);
}

NTKERNELAPI
BOOLEAN
FORCEINLINE
ExFastRefObjectNull (
    IN EX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine allows the caller to test of the specified fastref value
    has a null pointer

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    BOOLEAN - TRUE if the object is NULL FALSE otherwise

--*/
{
    return (BOOLEAN) (FastRef.Value == 0);
}

NTKERNELAPI
BOOLEAN
FORCEINLINE
ExFastRefEqualObjects (
    IN EX_FAST_REF FastRef,
    IN PVOID Object
    )
/*++

Routine Description:

    This routine allows the caller to test of the specified fastref contains
    the specified object

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    BOOLEAN - TRUE if the object matches FALSE otherwise

--*/
{
    return (BOOLEAN)((FastRef.Value^(ULONG_PTR)Object) <= MAX_FAST_REFS);
}


NTKERNELAPI
ULONG
FORCEINLINE
ExFastRefGetUnusedReferences (
    IN EX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine allows the caller to obtain the number of cached refrences
    in the fast reference structure.

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    ULONG - The number of cached references.

--*/
{
    return (ULONG) FastRef.RefCnt;
}


NTKERNELAPI
VOID
FORCEINLINE
ExFastRefInitialize (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object OPTIONAL
    )
/*++

Routine Description:

    This routine initializes fast reference structure.

Arguments:

    FastRef - Fast reference block to be used
    Object  - Object pointer to be assigned to the fast reference

Return Value:

    None.

--*/
{
    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);

    if (Object == NULL) {
       FastRef->Object = NULL;
    } else {
       FastRef->Value = (ULONG_PTR) Object | MAX_FAST_REFS;
    }
}

NTKERNELAPI
VOID
FORCEINLINE
ExFastRefInitializeEx (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object OPTIONAL,
    IN ULONG AdditionalRefs
    )
/*++

Routine Description:

    This routine initializes fast reference structure with the specified additional references.

Arguments:

    FastRef       - Fast reference block to be used
    Object        - Object pointer to be assigned to the fast reference
    AditionalRefs - Number of additional refs to add to the object

Return Value:

    None

--*/
{
    ASSERT (AdditionalRefs <= MAX_FAST_REFS);
    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);

    if (Object == NULL) {
       FastRef->Object = NULL;
    } else {
       FastRef->Value = (ULONG_PTR) Object + AdditionalRefs;
    }
}

NTKERNELAPI
ULONG
FORCEINLINE
ExFastRefGetAdditionalReferenceCount (
    VOID
    )
{
    return MAX_FAST_REFS;
}



NTKERNELAPI
EX_FAST_REF
FORCEINLINE
ExFastReference (
    IN PEX_FAST_REF FastRef
    )
/*++

Routine Description:

    This routine attempts to obtain a fast (cached) reference from a fast
    reference structure.

Arguments:

    FastRef - Fast reference block to be used

Return Value:

    EX_FAST_REF - The old or current contents of the fast reference structure.

--*/
{
    EX_FAST_REF OldRef, NewRef;

    while (1) {
        //
        // Fetch the old contents of the fast ref structure
        //
        OldRef = *FastRef;
        //
        // If the object pointer is null or if there are no cached references
        // left then bail. In the second case this reference will need to be
        // taken while holding the lock. Both cases are covered by the single
        // test of the lower bits since a null pointer can never have cached
        // refs.
        //
        if (OldRef.RefCnt != 0) {
            //
            // We know the bottom bits can't underflow into the pointer for a
            // request that works so just decrement
            //
            NewRef.Value = OldRef.Value - 1;
            NewRef.Object = InterlockedCompareExchangePointer (&FastRef->Object,
                                                               NewRef.Object,
                                                               OldRef.Object);
            if (NewRef.Object != OldRef.Object) {
                //
                // The structured changed beneath us. Try the operation again
                //
                continue;
            }
        }
        break;
    }

    return OldRef;
}

NTKERNELAPI
LOGICAL
FORCEINLINE
ExFastRefDereference (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object
    )
/*++

Routine Description:

    This routine attempts to release a fast reference from a fast ref
    structure. This routine could be called for a reference obtained
    directly from the object but preumably the chances of the pointer
    matching would be unlikely. The algorithm will work correctly in this
    case.

Arguments:

    FastRef - Fast reference block to be used

    Object - The original object that the reference was taken on.

Return Value:

    LOGICAL - TRUE: The fast dereference worked ok, FALSE: the
              dereference didn't.

--*/
{
    EX_FAST_REF OldRef, NewRef;

    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);
    ASSERT (Object != NULL);

    while (1) {
        //
        // Fetch the old contents of the fast ref structure
        //
        OldRef = *FastRef;

        //
        // If the reference cache is fully populated or the pointer has
        // changed to another object then just return the old value. The
        // caller can return the reference to the object instead.
        //
        if ((OldRef.Value^(ULONG_PTR)Object) >= MAX_FAST_REFS) {
            return FALSE;
        }
        //
        // We know the bottom bits can't overflow into the pointer so just
        // increment
        //
        NewRef.Value = OldRef.Value + 1;
        NewRef.Object = InterlockedCompareExchangePointer (&FastRef->Object,
                                                           NewRef.Object,
                                                           OldRef.Object);
        if (NewRef.Object != OldRef.Object) {
            //
            // The structured changed beneath us. Try the operation again
            //
            continue;
        }
        break;
    }
    return TRUE;
}

NTKERNELAPI
LOGICAL
FORCEINLINE
ExFastRefAddAdditionalReferenceCounts (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object,
    IN ULONG RefsToAdd
    )
/*++

Routine Description:

    This routine attempts to update the cached references on structure to
    allow future callers to run lock free. Callers must have already biased
    the object by the RefsToAdd reference count. This operation can fail at
    which point the caller should removed the extra references added and
    continue.

Arguments:

    FastRef - Fast reference block to be used

    Object - The original object that has had its reference count biased.

    RefsToAdd - The number of references to add to the cache

Return Value:

    LOGICAL - TRUE: The references where cached ok, FALSE: The references
              could not be cached.

--*/
{
    EX_FAST_REF OldRef, NewRef;

    ASSERT (RefsToAdd <= MAX_FAST_REFS);
    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);

    while (1) {
        //
        // Fetch the old contents of the fast ref structure
        //
        OldRef = *FastRef;

        //
        // If the count would push us above maximum cached references or
        // if the object pointer has changed the fail the request.
        //
        if (OldRef.RefCnt + RefsToAdd > MAX_FAST_REFS ||
            (ULONG_PTR) Object != (OldRef.Value & ~MAX_FAST_REFS)) {
            return FALSE;
        }
        //
        // We know the bottom bits can't overflow into the pointer so just
        // increment
        //
        NewRef.Value = OldRef.Value + RefsToAdd;
        NewRef.Object = InterlockedCompareExchangePointer (&FastRef->Object,
                                                           NewRef.Object,
                                                           OldRef.Object);
        if (NewRef.Object != OldRef.Object) {
            //
            // The structured changed beneath us. Use the return value from the
            // exchange and try it all again.
            //
            continue;
        }
        break;
    }
    return TRUE;
}

NTKERNELAPI
EX_FAST_REF
FORCEINLINE
ExFastRefSwapObject (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object
    )
/*++

Routine Description:

    This routine attempts to replace the current object with a new object.
    This routine must be called while holding the lock that protects the
    pointer field if concurrency with the slow ref path is possible.
    Its also possible to obtain and drop the lock after this operation has
    completed to force all the slow referencers from the slow reference path.

Arguments:

    FastRef - Fast reference block to be used

    Object - The new object that is to be placed in the structure. This
             object must have already had its reference count biased by
             the caller to account for the reference cache.

Return Value:

    EX_FAST_REF - The old contents of the fast reference structure.

--*/
{
    EX_FAST_REF OldRef;
    EX_FAST_REF NewRef;

    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);
    if (Object != NULL) {
        NewRef.Value = (ULONG_PTR) Object | MAX_FAST_REFS;
    } else {
        NewRef.Value = 0;
    }
    OldRef.Object = InterlockedExchangePointer (&FastRef->Object, NewRef.Object);
    return OldRef;
}

NTKERNELAPI
EX_FAST_REF
FORCEINLINE
ExFastRefCompareSwapObject (
    IN PEX_FAST_REF FastRef,
    IN PVOID Object,
    IN PVOID OldObject
    )
/*++

Routine Description:

    This routine attempts to replace the current object with a new object if
    the current object matches the old object.
    This routine must be called while holding the lock that protects the
    pointer field if concurrency with the slow ref path is possible.
    Its also possible to obtain and drop the lock after this operation has
    completed to force all the slow referencers from the slow reference path.

Arguments:

    FastRef - Fast reference block to be used

    Object - The new object that is to be placed in the structure. This
             object must have already had its reference count biased by
             the caller to account for the reference cache.

    OldObject - The object that must match the current object for the
                swap to occure.

Return Value:

    EX_FAST_REF - The old contents of the fast reference structure.

--*/
{
    EX_FAST_REF OldRef;
    EX_FAST_REF NewRef;

    ASSERT ((((ULONG_PTR)Object)&MAX_FAST_REFS) == 0);
    while (1) {
        //
        // Fetch the old contents of the fast ref structure
        //
        OldRef = *FastRef;

        //
        // Compare the current object to the old to see if a swap is possible.
        //
        if (!ExFastRefEqualObjects (OldRef, OldObject)) {
            return OldRef;
        }

        if (Object != NULL) {
            NewRef.Value = (ULONG_PTR) Object | MAX_FAST_REFS;
        } else {
            NewRef.Value = (ULONG_PTR) Object;
        }

        NewRef.Object = InterlockedCompareExchangePointer (&FastRef->Object,
                                                           NewRef.Object,
                                                           OldRef.Object);
        if (NewRef.Object != OldRef.Object) {
            //
            // The structured changed beneath us. Try it all again.
            //
            continue;
        }
        break;
    }
    return OldRef;
}


NTKERNELAPI
VOID
FORCEINLINE
ExInitializePushLock (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Initialize a push lock structure

Arguments:

    PushLock - Push lock to be initialized

Return Value:

    None

--*/
{
    PushLock->Value = 0;
}

NTKERNELAPI
VOID
FASTCALL
ExfAcquirePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     );

NTKERNELAPI
VOID
FASTCALL
ExfAcquirePushLockShared (
     IN PEX_PUSH_LOCK PushLock
     );

NTKERNELAPI
VOID
FASTCALL
ExfReleasePushLock (
     IN PEX_PUSH_LOCK PushLock
     );

NTKERNELAPI
VOID
FORCEINLINE
ExAcquireReleasePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock exclusively and immediately release it

Arguments:

    PushLock - Push lock to be acquired and released

Return Value:

    None

--*/
{
    KeMemoryBarrier ();
    if ((volatile EX_PUSH_LOCK *)PushLock->Ptr != NULL) {
        ExfAcquirePushLockExclusive (PushLock);
        ExfReleasePushLock (PushLock);
    }
}

NTKERNELAPI
BOOLEAN
FORCEINLINE
ExTryAcquireReleasePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Try to acquire a push lock exclusively and immediately release it

Arguments:

    PushLock - Push lock to be acquired and released

Return Value:

    BOOLEAN - TRUE: The lock was acquired, FALSE: The lock was not acquired

--*/
{
    KeMemoryBarrier ();
    if ((volatile EX_PUSH_LOCK *)PushLock->Ptr == NULL) {
        return TRUE;
    } else {
        return FALSE;
    }
}

NTKERNELAPI
VOID
FORCEINLINE
ExAcquirePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock exclusively

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE,
                                           NULL) != NULL) {
        ExfAcquirePushLockExclusive (PushLock);
    }
}

NTKERNELAPI
BOOLEAN
FORCEINLINE
ExTryAcquirePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Try and acquire a push lock exclusively

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    BOOLEAN - TRUE: Acquire was successfull, FALSE: Lock was already acquired

--*/
{
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE,
                                           NULL) == NULL) {
        return TRUE;
    } else {
        return FALSE;
    }
}

NTKERNELAPI
VOID
FORCEINLINE
ExAcquirePushLockShared (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a push lock shared

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue = *PushLock;
    OldValue.Value &= ~(EX_PUSH_LOCK_EXCLUSIVE | EX_PUSH_LOCK_WAITING);
    NewValue.Value = OldValue.Value + EX_PUSH_LOCK_SHARE_INC;
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           NewValue.Ptr,
                                           OldValue.Ptr) != OldValue.Ptr) {
        ExfAcquirePushLockShared (PushLock);
    }
}

NTKERNELAPI
BOOLEAN
FORCEINLINE
ExTryConvertPushLockSharedToExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Attempts to convert a shared acquire to exclusive. If other sharers or waiters are present
    the function fails.

Arguments:

    PushLock - Push lock to be acquired

Return Value:

    BOOLEAN - TRUE: Conversion worked ok, FALSE: The conversion could not be achieved

--*/
{
    if (InterlockedCompareExchangePointer (&PushLock->Ptr, (PVOID) EX_PUSH_LOCK_EXCLUSIVE,
                                           (PVOID) EX_PUSH_LOCK_SHARE_INC) ==
                                               (PVOID)EX_PUSH_LOCK_SHARE_INC) {
        return TRUE;
    } else {
        return FALSE;
    }
}



NTKERNELAPI
VOID
FORCEINLINE
ExReleasePushLock (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired exclusively or shared

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue = *PushLock;
    OldValue.Value &= ~EX_PUSH_LOCK_WAITING;
    NewValue.Value = (OldValue.Value - EX_PUSH_LOCK_EXCLUSIVE) &
                         ~EX_PUSH_LOCK_EXCLUSIVE;
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           NewValue.Ptr,
                                           OldValue.Ptr) != OldValue.Ptr) {
        ExfReleasePushLock (PushLock);
    }
}

NTKERNELAPI
VOID
FORCEINLINE
ExReleasePushLockExclusive (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired exclusively

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    ASSERT (PushLock->Value & (EX_PUSH_LOCK_WAITING|EX_PUSH_LOCK_EXCLUSIVE));

    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           NULL,
                                           (PVOID)EX_PUSH_LOCK_EXCLUSIVE) != (PVOID)EX_PUSH_LOCK_EXCLUSIVE) {
        ExfReleasePushLock (PushLock);
    }
}

NTKERNELAPI
VOID
FORCEINLINE
ExReleasePushLockShared (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Release a push lock that was acquired shared

Arguments:

    PushLock - Push lock to be released

Return Value:

    None

--*/
{
    EX_PUSH_LOCK OldValue, NewValue;

    OldValue = *PushLock;
    ASSERT (OldValue.Waiting || !OldValue.Exclusive);
    OldValue.Value &= ~EX_PUSH_LOCK_WAITING;
    NewValue.Value = OldValue.Value - EX_PUSH_LOCK_SHARE_INC;
    if (InterlockedCompareExchangePointer (&PushLock->Ptr,
                                           NewValue.Ptr,
                                           OldValue.Ptr) != OldValue.Ptr) {
        ExfReleasePushLock (PushLock);
    }
}

//
// This is a block held on the local stack of the waiting threads.
//

typedef  struct _EX_PUSH_LOCK_WAIT_BLOCK *PEX_PUSH_LOCK_WAIT_BLOCK;

typedef struct _EX_PUSH_LOCK_WAIT_BLOCK {
    KEVENT WakeEvent;
    PEX_PUSH_LOCK_WAIT_BLOCK Next;
    ULONG ShareCount;
    BOOLEAN Exclusive;
} EX_PUSH_LOCK_WAIT_BLOCK;


NTKERNELAPI
VOID
FASTCALL
ExBlockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock
     );

NTKERNELAPI
VOID
FASTCALL
ExfUnblockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock OPTIONAL
     );

NTKERNELAPI
VOID
FORCEINLINE
ExUnblockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock OPTIONAL
     )
{
    if (WaitBlock != NULL || PushLock->Ptr != NULL) {
        ExfUnblockPushLock (PushLock, WaitBlock);
    }
}

NTKERNELAPI
VOID
FORCEINLINE
ExWaitForUnblockPushLock (
     IN PEX_PUSH_LOCK PushLock,
     IN PEX_PUSH_LOCK_WAIT_BLOCK WaitBlock OPTIONAL
     )
{
    UNREFERENCED_PARAMETER (PushLock);

    KeWaitForSingleObject (&WaitBlock->WakeEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL);
}


NTKERNELAPI
PEX_PUSH_LOCK_CACHE_AWARE
ExAllocateCacheAwarePushLock (
     VOID
     );

NTKERNELAPI
VOID
ExFreeCacheAwarePushLock (
     PEX_PUSH_LOCK_CACHE_AWARE PushLock
     );

NTKERNELAPI
VOID
ExAcquireCacheAwarePushLockExclusive (
     IN PEX_PUSH_LOCK_CACHE_AWARE CacheAwarePushLock
     );

NTKERNELAPI
VOID
ExReleaseCacheAwarePushLockExclusive (
     IN PEX_PUSH_LOCK_CACHE_AWARE CacheAwarePushLock
     );

NTKERNELAPI
PEX_PUSH_LOCK
FORCEINLINE
ExAcquireCacheAwarePushLockShared (
     IN PEX_PUSH_LOCK_CACHE_AWARE CacheAwarePushLock
     )
/*++

Routine Description:

    Acquire a cache aware push lock shared.

Arguments:

    PushLock - Cache aware push lock to be acquired

Return Value:

    None

--*/
{
    PEX_PUSH_LOCK PushLock;
    //
    // Take a single one of the slots in shared mode.
    // Exclusive acquires must obtain all the slots exclusive.
    //
    PushLock = CacheAwarePushLock->Locks[KeGetCurrentProcessorNumber()%EX_PUSH_LOCK_FANNED_COUNT];
    ExAcquirePushLockShared (PushLock);
    return PushLock;
}

NTKERNELAPI
VOID
FORCEINLINE
ExReleaseCacheAwarePushLockShared (
     IN PEX_PUSH_LOCK PushLock
     )
/*++

Routine Description:

    Acquire a cache aware push lock shared.

Arguments:

    PushLock - Part of cache aware push lock returned by ExAcquireCacheAwarePushLockShared

Return Value:

    None

--*/
{
    ExReleasePushLockShared (PushLock);
    return;
}

//
// Define low overhead callbacks for thread create etc
//

// begin_wdm begin_ntddk

//
// Define a block to hold the actual routine registration.
//
typedef NTSTATUS (*PEX_CALLBACK_FUNCTION ) (
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

// end_wdm end_ntddk

typedef struct _EX_CALLBACK_ROUTINE_BLOCK {
    EX_RUNDOWN_REF        RundownProtect;
    PEX_CALLBACK_FUNCTION Function;
    PVOID                 Context;
} EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;

//
// Define a structure the caller uses to hold the callbacks
//
typedef struct _EX_CALLBACK {
    EX_FAST_REF RoutineBlock;
} EX_CALLBACK, *PEX_CALLBACK;

VOID
ExInitializeCallBack (
    IN OUT PEX_CALLBACK CallBack
    );

BOOLEAN
ExCompareExchangeCallBack (
    IN OUT PEX_CALLBACK CallBack,
    IN PEX_CALLBACK_ROUTINE_BLOCK NewBlock,
    IN PEX_CALLBACK_ROUTINE_BLOCK OldBlock
    );

NTSTATUS
ExCallCallBack (
    IN OUT PEX_CALLBACK CallBack,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

PEX_CALLBACK_ROUTINE_BLOCK
ExAllocateCallBack (
    IN PEX_CALLBACK_FUNCTION Function,
    IN PVOID Context
    );

VOID
ExFreeCallBack (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    );

PEX_CALLBACK_ROUTINE_BLOCK
ExReferenceCallBackBlock (
    IN OUT PEX_CALLBACK CallBack
    );

PEX_CALLBACK_FUNCTION
ExGetCallBackBlockRoutine (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    );

PVOID
ExGetCallBackBlockContext (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    );

VOID
ExDereferenceCallBackBlock (
    IN OUT PEX_CALLBACK CallBack,
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    );

VOID
ExWaitForCallBacks (
    IN PEX_CALLBACK_ROUTINE_BLOCK CallBackBlock
    );

#endif /* _EX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\fastsys.inc ===
; /*
;
; Copyright (c) 1997 Microsoft Corporation
;
; Module Name:
;
;    fastsys.inc
;
; Abstract:
;
;    This module implements the header for Fast System Calls for Intel
;    x86 family processors.
;
; Author:
;
;    Bryan M. Willman (bryanwi) 09-Jan-1998
;
; Environment:
;
;    kernel mode.
;
; Revision History:
;
;   Peter Johnston (peterj) 07-May-1998
;       Add support for AMD implementation.
;
;--

if 0  ; Begin C only code   */

// CPUID Feature bit in EDX indicating that fast system calls are supported

#define KI_FAST_SYSCALL_SUPPORTED   0x0800

#define MSR_SYSENTER_CS             0x00000174
#define MSR_SYSENTER_ESP            0x00000175
#define MSR_SYSENTER_EIP            0x00000176

#define MSR_EXT_FEATURE_ENABLE      0xC0000080
#define MSR_SYSCALL_TARGET_ADDR     0xC0000081

//
// Define bits in the Extended Feature Enable Register (EFER) (MSR).
//

#define MSR_EFER_SCE                0x1

/*
endif
;
;  Begin Assembly definitions
;


iSYSENTER macro
    db 0fH,34H
endm ;; SYSENTER

iSYSEXIT macro
    db 0fH,35H
endm ;; SYSEXIT

iSYSCALL macro
    db 0fH,05H
endm ;; SYSCALL

iSYSRET macro
    db 0fH,07H
endm ;; SYSRET

; */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\fsrtl.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsRtl.h

Abstract:

    This module defines all of the general File System Rtl routines

Author:

    Gary Kimura     [GaryKi]    30-Jul-1990

Revision History:

--*/

#ifndef _FSRTL_
#define _FSRTL_

//  begin_ntifs
//
//  The following are globally used definitions for an LBN and a VBN
//

typedef ULONG LBN;
typedef LBN *PLBN;

typedef ULONG VBN;
typedef VBN *PVBN;


//  end_ntifs
//
//  The following routine is called during phase 1 initialization to allow
//  us to create the pool of file system threads and the associated
//  synchronization resources.
//

NTKERNELAPI
BOOLEAN
FsRtlInitSystem (
    );

//  begin_ntifs
//
//  Every file system that uses the cache manager must have FsContext
//  of the file object point to a common fcb header structure.
//  end_ntifs
//  Either the normal or advanced FsRtl Header.
//  begin_ntifs
//

typedef enum _FAST_IO_POSSIBLE {
    FastIoIsNotPossible = 0,
    FastIoIsPossible,
    FastIoIsQuestionable
} FAST_IO_POSSIBLE;

//  end_ntifs
//  Changes to this structure will affect FSRTL_ADVANCED_FCB_HEADER.
//  begin_ntifs

typedef struct _FSRTL_COMMON_FCB_HEADER {

    CSHORT NodeTypeCode;
    CSHORT NodeByteSize;

    //
    //  General flags available to FsRtl.
    //

    UCHAR Flags;

    //
    //  Indicates if fast I/O is possible or if we should be calling
    //  the check for fast I/O routine which is found via the driver
    //  object.
    //

    UCHAR IsFastIoPossible; // really type FAST_IO_POSSIBLE

    //
    //  Second Flags Field
    //

    UCHAR Flags2;

    //
    //  The following reserved field should always be 0
    //

    UCHAR Reserved;

    PERESOURCE Resource;

    PERESOURCE PagingIoResource;

    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER FileSize;
    LARGE_INTEGER ValidDataLength;

} FSRTL_COMMON_FCB_HEADER;
typedef FSRTL_COMMON_FCB_HEADER *PFSRTL_COMMON_FCB_HEADER;

//
//  This Fcb header is used for files which support caching
//  of compressed data, and related new support.
//
//  We start out by prefixing this structure with the normal
//  FsRtl header from above, which we have to do two different
//  ways for c++ or c.
//

#ifdef __cplusplus
typedef struct _FSRTL_ADVANCED_FCB_HEADER:FSRTL_COMMON_FCB_HEADER {
#else   // __cplusplus

typedef struct _FSRTL_ADVANCED_FCB_HEADER {

    //
    //  Put in the standard FsRtl header fields
    //

    FSRTL_COMMON_FCB_HEADER ;

#endif  // __cplusplus

    //
    //  The following two fields are supported only if
    //  Flags2 contains FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS
    //

    //
    //  This is a pointer to a Fast Mutex which may be used to
    //  properly synchronize access to the FsRtl header.  The
    //  Fast Mutex must be nonpaged.
    //

    PFAST_MUTEX FastMutex;

    //
    // This is a pointer to a list of context structures belonging to
    // filesystem filter drivers that are linked above the filesystem.
    // Each structure is headed by FSRTL_FILTER_CONTEXT.
    //

    LIST_ENTRY FilterContexts;

} FSRTL_ADVANCED_FCB_HEADER;
typedef FSRTL_ADVANCED_FCB_HEADER *PFSRTL_ADVANCED_FCB_HEADER;

//
//  Define FsRtl common header flags
//

#define FSRTL_FLAG_FILE_MODIFIED        (0x01)
#define FSRTL_FLAG_FILE_LENGTH_CHANGED  (0x02)
#define FSRTL_FLAG_LIMIT_MODIFIED_PAGES (0x04)

//
//  Following flags determine how the modified page writer should
//  acquire the file.  These flags can't change while either resource
//  is acquired.  If neither of these flags is set then the
//  modified/mapped page writer will attempt to acquire the paging io
//  resource shared.
//

#define FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX (0x08)
#define FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH (0x10)

//
//  This flag will be set by the Cache Manager if a view is mapped
//  to a file.
//

#define FSRTL_FLAG_USER_MAPPED_FILE     (0x20)

//  This flag indicates that the file system is using the 
//  FSRTL_ADVANCED_FCB_HEADER structure instead of the FSRTL_COMMON_FCB_HEADER
//  structure.
//

#define FSRTL_FLAG_ADVANCED_HEADER      (0x40)

//  This flag determines whether there currently is an Eof advance
//  in progress.  All such advances must be serialized.
//

#define FSRTL_FLAG_EOF_ADVANCE_ACTIVE   (0x80)

//
//  Flag values for Flags2
//
//  All unused bits are reserved and should NOT be modified.
//

//
//  If this flag is set, the Cache Manager will allow modified writing
//  in spite of the value of FsContext2.
//

#define FSRTL_FLAG2_DO_MODIFIED_WRITE        (0x01)

//
//  If this flag is set, the additional fields FilterContexts and FastMutex
//  are supported in FSRTL_COMMON_HEADER, and can be used to associate
//  context for filesystem filters with streams.
//

#define FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS  (0x02)

//
//  If this flag is set, the cache manager will flush and purge the cache map when
//  a user first maps a file
//

#define FSRTL_FLAG2_PURGE_WHEN_MAPPED (0x04)

//
//  The following constants are used to block top level Irp processing when
//  (in either the fast io or cc case) file system resources have been
//  acquired above the file system, or we are in an Fsp thread.
//

#define FSRTL_FSP_TOP_LEVEL_IRP         0x01
#define FSRTL_CACHE_TOP_LEVEL_IRP       0x02
#define FSRTL_MOD_WRITE_TOP_LEVEL_IRP   0x03
#define FSRTL_FAST_IO_TOP_LEVEL_IRP     0x04
#define FSRTL_MAX_TOP_LEVEL_IRP_FLAG    0x04

//
//  The following structure is used to synchronize Eof extends.
//

typedef struct _EOF_WAIT_BLOCK {

    LIST_ENTRY EofWaitLinks;
    KEVENT Event;

} EOF_WAIT_BLOCK;

typedef EOF_WAIT_BLOCK *PEOF_WAIT_BLOCK;

//  begin_ntosp
//
//  Normal uncompressed Copy and Mdl Apis
//

NTKERNELAPI
BOOLEAN
FsRtlCopyRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
BOOLEAN
FsRtlCopyWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

// end_ntifs

NTKERNELAPI
BOOLEAN
FsRtlMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus
    );

BOOLEAN
FsRtlMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain
    );

// end_ntosp

NTKERNELAPI
BOOLEAN
FsRtlPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus
    );

BOOLEAN
FsRtlMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain
    );

// begin_ntifs

NTKERNELAPI
BOOLEAN
FsRtlMdlReadDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
BOOLEAN
FsRtlMdlReadCompleteDev (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
BOOLEAN
FsRtlPrepareMdlWriteDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
BOOLEAN
FsRtlMdlWriteCompleteDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  In Irps, compressed reads and writes are  designated by the
//  subfunction IRP_MN_COMPRESSED must be set and the Compressed
//  Data Info buffer must be described by the following structure
//  pointed to by Irp->Tail.Overlay.AuxiliaryBuffer.
//

typedef struct _FSRTL_AUXILIARY_BUFFER {

    //
    //  Buffer description with length.
    //

    PVOID Buffer;
    ULONG Length;

    //
    //  Flags
    //

    ULONG Flags;

    //
    //  Pointer to optional Mdl mapping buffer for file system use
    //

    PMDL Mdl;

} FSRTL_AUXILIARY_BUFFER;
typedef FSRTL_AUXILIARY_BUFFER *PFSRTL_AUXILIARY_BUFFER;

//
//  If this flag is set, the auxiliary buffer structure is
//  deallocated on Irp completion.  The caller has the
//  option in this case of appending this structure to the
//  structure being described, causing it all to be
//  deallocated at once.  If this flag is clear, no deallocate
//  occurs.
//

#define FSRTL_AUXILIARY_FLAG_DEALLOCATE 0x00000001

//  end_ntifs
//
//  The following routines are intended to be called by Mm to avoid deadlocks.
//  They prerequire file system resources before acquire Mm resources.
//

//
//  This macro is called once when the ModifiedPageWriter is started.
//

#define FsRtlSetTopLevelIrpForModWriter() {            \
    IoSetTopLevelIrp((PIRP)FSRTL_MOD_WRITE_TOP_LEVEL_IRP); \
}

NTKERNELAPI
BOOLEAN
FsRtlAcquireFileForModWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease
    );

NTKERNELAPI
NTSTATUS
FsRtlAcquireFileForModWriteEx (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT PERESOURCE *ResourceToRelease
    );

NTKERNELAPI
VOID
FsRtlReleaseFileForModWrite (
    IN PFILE_OBJECT FileObject,
    IN PERESOURCE ResourceToRelease
    );

NTKERNELAPI
VOID
FsRtlAcquireFileForCcFlush (
    IN PFILE_OBJECT FileObject
    );

NTKERNELAPI
NTSTATUS
FsRtlAcquireFileForCcFlushEx (
    IN PFILE_OBJECT FileObject
    );

NTKERNELAPI
VOID
FsRtlReleaseFileForCcFlush (
    IN PFILE_OBJECT FileObject
    );

NTKERNELAPI
NTSTATUS
FsRtlAcquireToCreateMappedSection (
    IN PFILE_OBJECT FileObject,
    IN ULONG SectionPageProtection
    );
    
NTKERNELAPI
NTSTATUS
FsRtlAcquireFileExclusiveCommon (
    IN PFILE_OBJECT FileObject,
    IN FS_FILTER_SECTION_SYNC_TYPE SyncType,
    IN ULONG SectionPageProtection
    );

//  begin_ntifs
//
//  The following two routines are called from NtCreateSection to avoid
//  deadlocks with the file systems.
//

NTKERNELAPI
VOID
FsRtlAcquireFileExclusive (
    IN PFILE_OBJECT FileObject
    );

NTKERNELAPI
VOID
FsRtlReleaseFile (
    IN PFILE_OBJECT FileObject
    );

//
//  These routines provide a simple interface for the common operations
//  of query/set file size.
//

NTSTATUS
FsRtlGetFileSize(
    IN PFILE_OBJECT FileObject,
    IN OUT PLARGE_INTEGER FileSize
    );

//  end_ntifs

NTSTATUS
FsRtlSetFileSize(
    IN PFILE_OBJECT FileObject,
    IN OUT PLARGE_INTEGER FileSize
    );

// begin_ntddk begin_ntifs
//
// Determine if there is a complete device failure on an error.
//

NTKERNELAPI
BOOLEAN
FsRtlIsTotalDeviceFailure(
    IN NTSTATUS Status
    );

// end_ntddk

//
//  Byte range file lock routines, implemented in FileLock.c
//
//  The file lock info record is used to return enumerated information
//  about a file lock
//

typedef struct _FILE_LOCK_INFO {

    //
    //  A description of the current locked range, and if the lock
    //  is exclusive or shared
    //

    LARGE_INTEGER StartingByte;
    LARGE_INTEGER Length;
    BOOLEAN ExclusiveLock;

    //
    //  The following fields describe the owner of the lock.
    //

    ULONG Key;
    PFILE_OBJECT FileObject;
    PVOID ProcessId;

    //
    //  The following field is used internally by FsRtl
    //

    LARGE_INTEGER EndingByte;

} FILE_LOCK_INFO;
typedef FILE_LOCK_INFO *PFILE_LOCK_INFO;

//
//  The following two procedure prototypes are used by the caller of the
//  file lock package to supply an alternate routine to call when
//  completing an IRP and when unlocking a byte range.  Note that the only
//  utility to us this interface is currently the redirector, all other file
//  system will probably let the IRP complete normally with IoCompleteRequest.
//  The user supplied routine returns any value other than success then the
//  lock package will remove any lock that we just inserted.
//

typedef NTSTATUS (*PCOMPLETE_LOCK_IRP_ROUTINE) (
    IN PVOID Context,
    IN PIRP Irp
    );

typedef VOID (*PUNLOCK_ROUTINE) (
    IN PVOID Context,
    IN PFILE_LOCK_INFO FileLockInfo
    );

//
//  A FILE_LOCK is an opaque structure but we need to declare the size of
//  it here so that users can allocate space for one.
//

typedef struct _FILE_LOCK {

    //
    //  The optional procedure to call to complete a request
    //

    PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine;

    //
    //  The optional procedure to call when unlocking a byte range
    //

    PUNLOCK_ROUTINE UnlockRoutine;

    //
    //  FastIoIsQuestionable is set to true whenever the filesystem require
    //  additional checking about whether the fast path can be taken.  As an
    //  example Ntfs requires checking for disk space before the writes can
    //  occur.
    //

    BOOLEAN FastIoIsQuestionable;
    BOOLEAN SpareC[3];

    //
    //  FsRtl lock information
    //

    PVOID   LockInformation;

    //
    //  Contains continuation information for FsRtlGetNextFileLock
    //

    FILE_LOCK_INFO  LastReturnedLockInfo;
    PVOID           LastReturnedLock;

} FILE_LOCK;
typedef FILE_LOCK *PFILE_LOCK;

PFILE_LOCK
FsRtlAllocateFileLock (
    IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine OPTIONAL,
    IN PUNLOCK_ROUTINE UnlockRoutine OPTIONAL
    );

VOID
FsRtlFreeFileLock (
    IN PFILE_LOCK FileLock
    );

NTKERNELAPI
VOID
FsRtlInitializeFileLock (
    IN PFILE_LOCK FileLock,
    IN PCOMPLETE_LOCK_IRP_ROUTINE CompleteLockIrpRoutine OPTIONAL,
    IN PUNLOCK_ROUTINE UnlockRoutine OPTIONAL
    );

NTKERNELAPI
VOID
FsRtlUninitializeFileLock (
    IN PFILE_LOCK FileLock
    );

NTKERNELAPI
NTSTATUS
FsRtlProcessFileLock (
    IN PFILE_LOCK FileLock,
    IN PIRP Irp,
    IN PVOID Context OPTIONAL
    );

NTKERNELAPI
BOOLEAN
FsRtlCheckLockForReadAccess (
    IN PFILE_LOCK FileLock,
    IN PIRP Irp
    );

NTKERNELAPI
BOOLEAN
FsRtlCheckLockForWriteAccess (
    IN PFILE_LOCK FileLock,
    IN PIRP Irp
    );

NTKERNELAPI
BOOLEAN
FsRtlFastCheckLockForRead (
    IN PFILE_LOCK FileLock,
    IN PLARGE_INTEGER StartingByte,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId
    );

NTKERNELAPI
BOOLEAN
FsRtlFastCheckLockForWrite (
    IN PFILE_LOCK FileLock,
    IN PLARGE_INTEGER StartingByte,
    IN PLARGE_INTEGER Length,
    IN ULONG Key,
    IN PVOID FileObject,
    IN PVOID ProcessId
    );

NTKERNELAPI
PFILE_LOCK_INFO
FsRtlGetNextFileLock (
    IN PFILE_LOCK FileLock,
    IN BOOLEAN Restart
    );

NTKERNELAPI
NTSTATUS
FsRtlFastUnlockSingle (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN LARGE_INTEGER UNALIGNED *FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL,
    IN BOOLEAN AlreadySynchronized
    );

NTKERNELAPI
NTSTATUS
FsRtlFastUnlockAll (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    IN PVOID Context OPTIONAL
    );

NTKERNELAPI
NTSTATUS
FsRtlFastUnlockAllByKey (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN PVOID Context OPTIONAL
    );

NTKERNELAPI
BOOLEAN
FsRtlPrivateLock (
    IN PFILE_LOCK FileLock,
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK Iosb,
    IN PIRP Irp,
    IN PVOID Context,
    IN BOOLEAN AlreadySynchronized
    );

//
//  BOOLEAN
//  FsRtlFastLock (
//      IN PFILE_LOCK FileLock,
//      IN PFILE_OBJECT FileObject,
//      IN PLARGE_INTEGER FileOffset,
//      IN PLARGE_INTEGER Length,
//      IN PEPROCESS ProcessId,
//      IN ULONG Key,
//      IN BOOLEAN FailImmediately,
//      IN BOOLEAN ExclusiveLock,
//      OUT PIO_STATUS_BLOCK Iosb,
//      IN PVOID Context OPTIONAL,
//      IN BOOLEAN AlreadySynchronized
//      );
//

#define FsRtlFastLock(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11) ( \
    FsRtlPrivateLock( A1,   /* FileLock            */       \
                      A2,   /* FileObject          */       \
                      A3,   /* FileOffset          */       \
                      A4,   /* Length              */       \
                      A5,   /* ProcessId           */       \
                      A6,   /* Key                 */       \
                      A7,   /* FailImmediately     */       \
                      A8,   /* ExclusiveLock       */       \
                      A9,   /* Iosb                */       \
                      NULL, /* Irp                 */       \
                      A10,  /* Context             */       \
                      A11   /* AlreadySynchronized */ )     \
)

//
//  BOOLEAN
//  FsRtlAreThereCurrentFileLocks (
//      IN PFILE_LOCK FileLock
//      );
//

#define FsRtlAreThereCurrentFileLocks(FL) ( \
    ((FL)->FastIoIsQuestionable))



//
//  Filesystem property tunneling, implemented in tunnel.c
//

//
//  Tunnel cache structure
//

typedef struct {

    //
    //  Mutex for cache manipulation
    //

    FAST_MUTEX          Mutex;

    //
    //  Splay Tree of tunneled information keyed by
    //  DirKey ## Name
    //

    PRTL_SPLAY_LINKS    Cache;

    //
    //  Timer queue used to age entries out of the main cache
    //

    LIST_ENTRY          TimerQueue;

    //
    //  Keep track of the number of entries in the cache to prevent
    //  excessive use of memory
    //

    USHORT              NumEntries;

} TUNNEL, *PTUNNEL;

NTKERNELAPI
VOID
FsRtlInitializeTunnelCache (
    IN TUNNEL *Cache);

NTKERNELAPI
VOID
FsRtlAddToTunnelCache (
    IN TUNNEL *Cache,
    IN ULONGLONG DirectoryKey,
    IN UNICODE_STRING *ShortName,
    IN UNICODE_STRING *LongName,
    IN BOOLEAN KeyByShortName,
    IN ULONG DataLength,
    IN VOID *Data);

NTKERNELAPI
BOOLEAN
FsRtlFindInTunnelCache (
    IN TUNNEL *Cache,
    IN ULONGLONG DirectoryKey,
    IN UNICODE_STRING *Name,
    OUT UNICODE_STRING *ShortName,
    OUT UNICODE_STRING *LongName,
    IN OUT ULONG  *DataLength,
    OUT VOID *Data);


NTKERNELAPI
VOID
FsRtlDeleteKeyFromTunnelCache (
    IN TUNNEL *Cache,
    IN ULONGLONG DirectoryKey);


NTKERNELAPI
VOID
FsRtlDeleteTunnelCache (
    IN TUNNEL *Cache);


//
//  Dbcs name support routines, implemented in DbcsName.c
//

//
//  The following enumerated type is used to denote the result of name
//  comparisons
//

typedef enum _FSRTL_COMPARISON_RESULT {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
} FSRTL_COMPARISON_RESULT;

#ifdef NLS_MB_CODE_PAGE_TAG
#undef NLS_MB_CODE_PAGE_TAG
#endif // NLS_MB_CODE_PAGE_TAG

// end_ntifs
#if defined(_NTIFS_) || defined(_NTDRIVER_)
// begin_ntifs

#define LEGAL_ANSI_CHARACTER_ARRAY        (*FsRtlLegalAnsiCharacterArray) // ntosp
#define NLS_MB_CODE_PAGE_TAG              (*NlsMbOemCodePageTag)
#define NLS_OEM_LEAD_BYTE_INFO            (*NlsOemLeadByteInfo) // ntosp

// end_ntifs
#else

#define LEGAL_ANSI_CHARACTER_ARRAY        FsRtlLegalAnsiCharacterArray
#define NLS_MB_CODE_PAGE_TAG              NlsMbOemCodePageTag
#define NLS_OEM_LEAD_BYTE_INFO            NlsOemLeadByteInfo

#endif
// begin_ntifs begin_ntosp

extern UCHAR const* const LEGAL_ANSI_CHARACTER_ARRAY;
extern PUSHORT NLS_OEM_LEAD_BYTE_INFO;  // Lead byte info. for ACP

//
//  These following bit values are set in the FsRtlLegalDbcsCharacterArray
//

#define FSRTL_FAT_LEGAL         0x01
#define FSRTL_HPFS_LEGAL        0x02
#define FSRTL_NTFS_LEGAL        0x04
#define FSRTL_WILD_CHARACTER    0x08
#define FSRTL_OLE_LEGAL         0x10
#define FSRTL_NTFS_STREAM_LEGAL (FSRTL_NTFS_LEGAL | FSRTL_OLE_LEGAL)

//
//  The following macro is used to determine if an Ansi character is wild.
//

#define FsRtlIsAnsiCharacterWild(C) (                               \
    FsRtlTestAnsiCharacter((C), FALSE, FALSE, FSRTL_WILD_CHARACTER) \
)

//
//  The following macro is used to determine if an Ansi character is Fat legal.
//

#define FsRtlIsAnsiCharacterLegalFat(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_FAT_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is Hpfs legal.
//

#define FsRtlIsAnsiCharacterLegalHpfs(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_HPFS_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is Ntfs legal.
//

#define FsRtlIsAnsiCharacterLegalNtfs(C,WILD_OK) (                 \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_LEGAL) \
)

//
//  The following macro is used to determine if an Ansi character is
//  legal in an Ntfs stream name
//

#define FsRtlIsAnsiCharacterLegalNtfsStream(C,WILD_OK) (                    \
    FsRtlTestAnsiCharacter((C), TRUE, (WILD_OK), FSRTL_NTFS_STREAM_LEGAL)   \
)

//
//  The following macro is used to determine if an Ansi character is legal,
//  according to the caller's specification.
//

#define FsRtlIsAnsiCharacterLegal(C,FLAGS) (          \
    FsRtlTestAnsiCharacter((C), TRUE, FALSE, (FLAGS)) \
)

//
//  The following macro is used to test attributes of an Ansi character,
//  according to the caller's specified flags.
//

#define FsRtlTestAnsiCharacter(C, DEFAULT_RET, WILD_OK, FLAGS) (            \
        ((SCHAR)(C) < 0) ? DEFAULT_RET :                                    \
                           FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)],         \
                                   (FLAGS) |                                \
                                   ((WILD_OK) ? FSRTL_WILD_CHARACTER : 0) ) \
)


//
//  The following two macros use global data defined in ntos\rtl\nlsdata.c
//
//  BOOLEAN
//  FsRtlIsLeadDbcsCharacter (
//      IN UCHAR DbcsCharacter
//      );
//
//  /*++
//
//  Routine Description:
//
//      This routine takes the first bytes of a Dbcs character and
//      returns whether it is a lead byte in the system code page.
//
//  Arguments:
//
//      DbcsCharacter - Supplies the input character being examined
//
//  Return Value:
//
//      BOOLEAN - TRUE if the input character is a dbcs lead and
//              FALSE otherwise
//
//  --*/
//
//

#define FsRtlIsLeadDbcsCharacter(DBCS_CHAR) (                      \
    (BOOLEAN)((UCHAR)(DBCS_CHAR) < 0x80 ? FALSE :                  \
              (NLS_MB_CODE_PAGE_TAG &&                             \
               (NLS_OEM_LEAD_BYTE_INFO[(UCHAR)(DBCS_CHAR)] != 0))) \
)

NTKERNELAPI
VOID
FsRtlDissectDbcs (
    IN ANSI_STRING InputName,
    OUT PANSI_STRING FirstPart,
    OUT PANSI_STRING RemainingPart
    );

NTKERNELAPI
BOOLEAN
FsRtlDoesDbcsContainWildCards (
    IN PANSI_STRING Name
    );

NTKERNELAPI
BOOLEAN
FsRtlIsDbcsInExpression (
    IN PANSI_STRING Expression,
    IN PANSI_STRING Name
    );

NTKERNELAPI
BOOLEAN
FsRtlIsFatDbcsLegal (
    IN ANSI_STRING DbcsName,
    IN BOOLEAN WildCardsPermissible,
    IN BOOLEAN PathNamePermissible,
    IN BOOLEAN LeadingBackslashPermissible
    );

// end_ntosp

NTKERNELAPI
BOOLEAN
FsRtlIsHpfsDbcsLegal (
    IN ANSI_STRING DbcsName,
    IN BOOLEAN WildCardsPermissible,
    IN BOOLEAN PathNamePermissible,
    IN BOOLEAN LeadingBackslashPermissible
    );


//
//  Exception filter routines, implemented in Filter.c
//

NTKERNELAPI
NTSTATUS
FsRtlNormalizeNtstatus (
    IN NTSTATUS Exception,
    IN NTSTATUS GenericException
    );

NTKERNELAPI
BOOLEAN
FsRtlIsNtstatusExpected (
    IN NTSTATUS Exception
    );

//
//  The following procedures are used to allocate executive pool and raise
//  insufficient resource status if pool isn't currently available.
//

#define FsRtlAllocatePoolWithTag(PoolType, NumberOfBytes, Tag)                \
    ExAllocatePoolWithTag((POOL_TYPE)((PoolType) | POOL_RAISE_IF_ALLOCATION_FAILURE), \
                          NumberOfBytes,                                      \
                          Tag)


#define FsRtlAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, Tag)           \
    ExAllocatePoolWithQuotaTag((POOL_TYPE)((PoolType) | POOL_RAISE_IF_ALLOCATION_FAILURE), \
                               NumberOfBytes,                                 \
                               Tag)

//
//  The following function allocates a resource from the FsRtl pool.
//

NTKERNELAPI
PERESOURCE
FsRtlAllocateResource (
    );


//
//  Large Integer Mapped Control Blocks routines, implemented in LargeMcb.c
//
//  Originally this structure was truly opaque and code outside largemcb was
//  never allowed to examine or alter the structures.  However, for performance
//  reasons we want to allow ntfs the ability to quickly truncate down the
//  mcb without the overhead of an actual call to largemcb.c.  So to do that we
//  need to export the structure.  This structure is not exact.  The Mapping field
//  is declared here as a pvoid but largemcb.c it is a pointer to mapping pairs.
//

typedef struct _LARGE_MCB {
    PFAST_MUTEX FastMutex;
    ULONG MaximumPairCount;
    ULONG PairCount;
    POOL_TYPE PoolType;
    PVOID Mapping;
} LARGE_MCB;
typedef LARGE_MCB *PLARGE_MCB;

NTKERNELAPI
VOID
FsRtlInitializeLargeMcb (
    IN PLARGE_MCB Mcb,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
VOID
FsRtlUninitializeLargeMcb (
    IN PLARGE_MCB Mcb
    );

NTKERNELAPI
VOID
FsRtlResetLargeMcb (
    IN PLARGE_MCB Mcb,
    IN BOOLEAN SelfSynchronized
    );

NTKERNELAPI
VOID
FsRtlTruncateLargeMcb (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn
    );

NTKERNELAPI
BOOLEAN
FsRtlAddLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    IN LONGLONG Lbn,
    IN LONGLONG SectorCount
    );

NTKERNELAPI
VOID
FsRtlRemoveLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    IN LONGLONG SectorCount
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    OUT PLONGLONG Lbn OPTIONAL,
    OUT PLONGLONG SectorCountFromLbn OPTIONAL,
    OUT PLONGLONG StartingLbn OPTIONAL,
    OUT PLONGLONG SectorCountFromStartingLbn OPTIONAL,
    OUT PULONG Index OPTIONAL
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupLastLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    OUT PLONGLONG Vbn,
    OUT PLONGLONG Lbn
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupLastLargeMcbEntryAndIndex (
    IN PLARGE_MCB OpaqueMcb,
    OUT PLONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn,
    OUT PULONG Index
    );

NTKERNELAPI
ULONG
FsRtlNumberOfRunsInLargeMcb (
    IN PLARGE_MCB Mcb
    );

NTKERNELAPI
BOOLEAN
FsRtlGetNextLargeMcbEntry (
    IN PLARGE_MCB Mcb,
    IN ULONG RunIndex,
    OUT PLONGLONG Vbn,
    OUT PLONGLONG Lbn,
    OUT PLONGLONG SectorCount
    );

NTKERNELAPI
BOOLEAN
FsRtlSplitLargeMcb (
    IN PLARGE_MCB Mcb,
    IN LONGLONG Vbn,
    IN LONGLONG Amount
    );


//
//  Mapped Control Blocks routines, implemented in Mcb.c
//
//  An MCB is an opaque structure but we need to declare the size of
//  it here so that users can allocate space for one.  Consequently the
//  size computation here must be updated by hand if the MCB changes.
//

typedef struct _MCB {
    LARGE_MCB DummyFieldThatSizesThisStructureCorrectly;
} MCB;
typedef MCB *PMCB;

NTKERNELAPI
VOID
FsRtlInitializeMcb (
    IN PMCB Mcb,
    IN POOL_TYPE PoolType
    );

NTKERNELAPI
VOID
FsRtlUninitializeMcb (
    IN PMCB Mcb
    );

NTKERNELAPI
VOID
FsRtlTruncateMcb (
    IN PMCB Mcb,
    IN VBN Vbn
    );

NTKERNELAPI
BOOLEAN
FsRtlAddMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    IN LBN Lbn,
    IN ULONG SectorCount
    );

NTKERNELAPI
VOID
FsRtlRemoveMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    IN ULONG SectorCount
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index
    );

NTKERNELAPI
BOOLEAN
FsRtlLookupLastMcbEntry (
    IN PMCB Mcb,
    OUT PVBN Vbn,
    OUT PLBN Lbn
    );

NTKERNELAPI
ULONG
FsRtlNumberOfRunsInMcb (
    IN PMCB Mcb
    );

NTKERNELAPI
BOOLEAN
FsRtlGetNextMcbEntry (
    IN PMCB Mcb,
    IN ULONG RunIndex,
    OUT PVBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount
    );

//
//  Fault Tolerance routines, implemented in FaultTol.c
//
//  The routines in this package implement routines that help file
//  systems interact with the FT device drivers.
//

NTKERNELAPI
NTSTATUS
FsRtlBalanceReads (
    IN PDEVICE_OBJECT TargetDevice
    );

// end_ntifs
NTKERNELAPI
NTSTATUS
FsRtlSyncVolumes (
    IN PDEVICE_OBJECT TargetDevice,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PLARGE_INTEGER ByteCount
    );

// begin_ntifs

//
//  Oplock routines, implemented in Oplock.c
//
//  An OPLOCK is an opaque structure, we declare it as a PVOID and
//  allocate the actual memory only when needed.
//

typedef PVOID OPLOCK, *POPLOCK;

typedef
VOID
(*POPLOCK_WAIT_COMPLETE_ROUTINE) (
    IN PVOID Context,
    IN PIRP Irp
    );

typedef
VOID
(*POPLOCK_FS_PREPOST_IRP) (
    IN PVOID Context,
    IN PIRP Irp
    );

NTKERNELAPI
VOID
FsRtlInitializeOplock (
    IN OUT POPLOCK Oplock
    );

NTKERNELAPI
VOID
FsRtlUninitializeOplock (
    IN OUT POPLOCK Oplock
    );

NTKERNELAPI
NTSTATUS
FsRtlOplockFsctrl (
    IN POPLOCK Oplock,
    IN PIRP Irp,
    IN ULONG OpenCount
    );

NTKERNELAPI
NTSTATUS
FsRtlCheckOplock (
    IN POPLOCK Oplock,
    IN PIRP Irp,
    IN PVOID Context,
    IN POPLOCK_WAIT_COMPLETE_ROUTINE CompletionRoutine OPTIONAL,
    IN POPLOCK_FS_PREPOST_IRP PostIrpRoutine OPTIONAL
    );

NTKERNELAPI
BOOLEAN
FsRtlOplockIsFastIoPossible (
    IN POPLOCK Oplock
    );

NTKERNELAPI
BOOLEAN
FsRtlCurrentBatchOplock (
    IN POPLOCK Oplock
    );


//
//  Volume lock/unlock notification routines, implemented in PnP.c
//
//  These routines provide PnP volume lock notification support
//  for all filesystems.
//

#define FSRTL_VOLUME_DISMOUNT           1
#define FSRTL_VOLUME_DISMOUNT_FAILED    2
#define FSRTL_VOLUME_LOCK               3
#define FSRTL_VOLUME_LOCK_FAILED        4
#define FSRTL_VOLUME_UNLOCK             5
#define FSRTL_VOLUME_MOUNT              6

NTKERNELAPI
NTSTATUS
FsRtlNotifyVolumeEvent (
    IN PFILE_OBJECT FileObject,
    IN ULONG EventCode
    );

//
//  Notify Change routines, implemented in Notify.c
//
//  These routines provide Notify Change support for all filesystems.
//  Any of the 'Full' notify routines will support returning the
//  change information into the user's buffer.
//

typedef PVOID PNOTIFY_SYNC;

typedef
BOOLEAN (*PCHECK_FOR_TRAVERSE_ACCESS) (
            IN PVOID NotifyContext,
            IN PVOID TargetContext,
            IN PSECURITY_SUBJECT_CONTEXT SubjectContext
            );

typedef
BOOLEAN (*PFILTER_REPORT_CHANGE) (
            IN PVOID NotifyContext,
            IN PVOID FilterContext
            );

NTKERNELAPI
VOID
FsRtlNotifyInitializeSync (
    IN PNOTIFY_SYNC *NotifySync
    );

NTKERNELAPI
VOID
FsRtlNotifyUninitializeSync (
    IN PNOTIFY_SYNC *NotifySync
    );

// end_ntifs
NTKERNELAPI
VOID
FsRtlNotifyChangeDirectory (
    IN PNOTIFY_SYNC NotifySync,
    IN PVOID FsContext,
    IN PSTRING FullDirectoryName,
    IN PLIST_ENTRY NotifyList,
    IN BOOLEAN WatchTree,
    IN ULONG CompletionFilter,
    IN PIRP NotifyIrp
    );

// begin_ntifs
NTKERNELAPI
VOID
FsRtlNotifyFullChangeDirectory (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PVOID FsContext,
    IN PSTRING FullDirectoryName,
    IN BOOLEAN WatchTree,
    IN BOOLEAN IgnoreBuffer,
    IN ULONG CompletionFilter,
    IN PIRP NotifyIrp,
    IN PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback OPTIONAL,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext OPTIONAL
    );

NTKERNELAPI
VOID
FsRtlNotifyFilterChangeDirectory (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PVOID FsContext,
    IN PSTRING FullDirectoryName,
    IN BOOLEAN WatchTree,
    IN BOOLEAN IgnoreBuffer,
    IN ULONG CompletionFilter,
    IN PIRP NotifyIrp,
    IN PCHECK_FOR_TRAVERSE_ACCESS TraverseCallback OPTIONAL,
    IN PSECURITY_SUBJECT_CONTEXT SubjectContext OPTIONAL,
    IN PFILTER_REPORT_CHANGE FilterCallback OPTIONAL
    );

NTKERNELAPI
VOID
FsRtlNotifyFilterReportChange (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PSTRING FullTargetName,
    IN USHORT TargetNameOffset,
    IN PSTRING StreamName OPTIONAL,
    IN PSTRING NormalizedParentName OPTIONAL,
    IN ULONG FilterMatch,
    IN ULONG Action,
    IN PVOID TargetContext,
    IN PVOID FilterContext
    );

// end_ntifs
NTKERNELAPI
VOID
FsRtlNotifyReportChange (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PSTRING FullTargetName,
    IN PSTRING TargetName,
    IN ULONG FilterMatch
    );

// begin_ntifs
NTKERNELAPI
VOID
FsRtlNotifyFullReportChange (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PSTRING FullTargetName,
    IN USHORT TargetNameOffset,
    IN PSTRING StreamName OPTIONAL,
    IN PSTRING NormalizedParentName OPTIONAL,
    IN ULONG FilterMatch,
    IN ULONG Action,
    IN PVOID TargetContext
    );

NTKERNELAPI
VOID
FsRtlNotifyCleanup (
    IN PNOTIFY_SYNC NotifySync,
    IN PLIST_ENTRY NotifyList,
    IN PVOID FsContext
    );


//
//  Unicode Name support routines, implemented in Name.c
//
//  The routines here are used to manipulate unicode names
//

//
//  The following macro is used to determine if a character is wild.
//

#define FsRtlIsUnicodeCharacterWild(C) (                                \
      (((C) >= 0x40) ? FALSE : FlagOn( LEGAL_ANSI_CHARACTER_ARRAY[(C)], \
                                       FSRTL_WILD_CHARACTER ) )         \
)

NTKERNELAPI
VOID
FsRtlDissectName (
    IN UNICODE_STRING Path,
    OUT PUNICODE_STRING FirstName,
    OUT PUNICODE_STRING RemainingName
    );

NTKERNELAPI
BOOLEAN
FsRtlDoesNameContainWildCards (
    IN PUNICODE_STRING Name
    );

NTKERNELAPI
BOOLEAN
FsRtlAreNamesEqual (
    PCUNICODE_STRING ConstantNameA,
    PCUNICODE_STRING ConstantNameB,
    IN BOOLEAN IgnoreCase,
    IN PCWCH UpcaseTable OPTIONAL
    );

NTKERNELAPI
BOOLEAN
FsRtlIsNameInExpression (
    IN PUNICODE_STRING Expression,
    IN PUNICODE_STRING Name,
    IN BOOLEAN IgnoreCase,
    IN PWCH UpcaseTable OPTIONAL
    );


//
//  Stack Overflow support routine, implemented in StackOvf.c
//

typedef
VOID
(*PFSRTL_STACK_OVERFLOW_ROUTINE) (
    IN PVOID Context,
    IN PKEVENT Event
    );

NTKERNELAPI
VOID
FsRtlPostStackOverflow (
    IN PVOID Context,
    IN PKEVENT Event,
    IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine
    );

NTKERNELAPI
VOID
FsRtlPostPagingFileStackOverflow (
    IN PVOID Context,
    IN PKEVENT Event,
    IN PFSRTL_STACK_OVERFLOW_ROUTINE StackOverflowRoutine
    );

//
// UNC Provider support
//

NTKERNELAPI
NTSTATUS
FsRtlRegisterUncProvider(
    IN OUT PHANDLE MupHandle,
    IN PUNICODE_STRING RedirectorDeviceName,
    IN BOOLEAN MailslotsSupported
    );

NTKERNELAPI
VOID
FsRtlDeregisterUncProvider(
    IN HANDLE Handle
    );
//  end_ntifs

//  begin_ntifs

//
//  File System Filter PerStream Context Support
//

//
//  Filesystem filter drivers use these APIs to associate context
//  with open streams (for filesystems that support this).
//

//
//  OwnerId should uniquely identify a particular filter driver
//  (e.g. the address of the driver's device object).
//  InstanceId can be used to distinguish distinct contexts associated
//  by a filter driver with a single stream (e.g. the address of the
//  PerStream Context structure).
//

//
//  This structure needs to be embedded within the users context that
//  they want to associate with a given stream
//

typedef struct _FSRTL_PER_STREAM_CONTEXT {
    //
    //  This is linked into the StreamContext list inside the 
    //  FSRTL_ADVANCED_FCB_HEADER structure.
    //

    LIST_ENTRY Links;

    //
    //  A Unique ID for this filter (ex: address of Driver Object, Device
    //  Object, or Device Extension)
    //

    PVOID OwnerId;

    //
    //  An optional ID to differentiate different contexts for the same
    //  filter.
    //

    PVOID InstanceId;

    //
    //  A callback routine which is called by the underlying file system
    //  when the stream is being torn down.  When this routine is called
    //  the given context has already been removed from the context linked
    //  list.  The callback routine cannot recursively call down into the
    //  filesystem or acquire any of their resources which they might hold
    //  when calling the filesystem outside of the callback.  This must
    //  be defined.
    //

    PFREE_FUNCTION FreeCallback;

} FSRTL_PER_STREAM_CONTEXT, *PFSRTL_PER_STREAM_CONTEXT;


//
//  This will initialize the given FSRTL_PER_STREAM_CONTEXT structure.  This
//  should be used before calling "FsRtlInsertPerStreamContext".
//

#define FsRtlInitPerStreamContext( _fc, _owner, _inst, _cb)   \
    ((_fc)->OwnerId = (_owner),                               \
     (_fc)->InstanceId = (_inst),                             \
     (_fc)->FreeCallback = (_cb))

//
//  Given a FileObject this will return the StreamContext pointer that
//  needs to be passed into the other FsRtl PerStream Context routines.
//

#define FsRtlGetPerStreamContextPointer(_fo) \
    ((PFSRTL_ADVANCED_FCB_HEADER)((_fo)->FsContext))

//
//  This will test to see if PerStream contexts are supported for the given
//  FileObject
//

#define FsRtlSupportsPerStreamContexts(_fo)                     \
    ((NULL != FsRtlGetPerStreamContextPointer(_fo)) &&          \
     FlagOn(FsRtlGetPerStreamContextPointer(_fo)->Flags2,       \
                    FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS))

//
//  Associate the context at Ptr with the given stream.  The Ptr structure
//  should be filled in by the caller before calling this routine (see
//  FsRtlInitPerStreamContext).  If the underlying filesystem does not support
//  filter contexts, STATUS_INVALID_DEVICE_REQUEST will be returned.
//

NTKERNELAPI
NTSTATUS
FsRtlInsertPerStreamContext (
    IN PFSRTL_ADVANCED_FCB_HEADER PerStreamContext,
    IN PFSRTL_PER_STREAM_CONTEXT Ptr
    );

//
//  Lookup a filter context associated with the stream specified.  The first
//  context matching OwnerId (and InstanceId, if present) is returned.  By not
//  specifying InstanceId, a filter driver can search for any context that it
//  has previously associated with a stream.  If no matching context is found,
//  NULL is returned.  If the file system does not support filter contexts,
//  NULL is returned.
//

NTKERNELAPI
PFSRTL_PER_STREAM_CONTEXT
FsRtlLookupPerStreamContextInternal (
    IN PFSRTL_ADVANCED_FCB_HEADER StreamContext,
    IN PVOID OwnerId OPTIONAL,
    IN PVOID InstanceId OPTIONAL
    );

#define FsRtlLookupPerStreamContext(_sc, _oid, _iid)                          \
 (((NULL != (_sc)) &&                                                         \
   FlagOn((_sc)->Flags2,FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS) &&              \
   !IsListEmpty(&(_sc)->FilterContexts)) ?                                    \
        FsRtlLookupPerStreamContextInternal((_sc), (_oid), (_iid)) :          \
        NULL)

//
//  Normally, contexts should be deleted when the file system notifies the
//  filter that the stream is being closed.  There are cases when a filter
//  may want to remove all existing contexts for a specific volume.  This
//  routine should be called at those times.  This routine should NOT be
//  called for the following cases:
//      - Inside your FreeCallback handler - The underlying file system has
//        already removed it from the linked list).
//      - Inside your IRP_CLOSE handler - If you do this then you will not
//        be notified when the stream is torn down.
//
//  This functions identically to FsRtlLookupPerStreamContext, except that the
//  returned context has been removed from the list.
//

NTKERNELAPI
PFSRTL_PER_STREAM_CONTEXT
FsRtlRemovePerStreamContext (
    IN PFSRTL_ADVANCED_FCB_HEADER StreamContext,
    IN PVOID OwnerId OPTIONAL,
    IN PVOID InstanceId OPTIONAL
    );


//
//  APIs for file systems to use for initializing and cleaning up
//  the Advaned FCB Header fields for PerStreamContext support
//

//
//  This will properly initialize the advanced header so that it can be
//  used with PerStream contexts.  
//  Note:  A fast mutex must be placed in an advanced header.  It is the
//         caller's responsibility to properly create and initialize this
//         mutex before calling this macro.  The mutex field is only set
//         if a non-NULL value is passed in.
//

#define FsRtlSetupAdvancedHeader( _advhdr, _fmutx )                         \
{                                                                           \
    SetFlag( (_advhdr)->Flags, FSRTL_FLAG_ADVANCED_HEADER );                \
    SetFlag( (_advhdr)->Flags2, FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS );     \
    InitializeListHead( &(_advhdr)->FilterContexts );                       \
    if ((_fmutx) != NULL) {                                                 \
        (_advhdr)->FastMutex = (_fmutx);                                    \
    }                                                                       \
}

//
// File systems call this API to free any filter contexts still associated
// with an FSRTL_COMMON_FCB_HEADER that they are tearing down.
// The FreeCallback routine for each filter context will be called.
//

NTKERNELAPI
VOID
FsRtlTeardownPerStreamContexts (
  IN PFSRTL_ADVANCED_FCB_HEADER AdvancedHeader
  );

//  end_ntifs


//
//  File System Filter PerFileObject Context Support
//

//
//  Filesystem filter drivers use these APIs to associate context
//  with individual open files.  For now these are only supported on file
//  objects with a FileObject extension which are only created by using
//  IoCreateFileSpecifyDeviceObjectHint.
//

//
//  OwnerId should uniquely identify a particular filter driver
//  (e.g. the address of the driver's device object).
//  InstanceId can be used to distinguish distinct contexts associated
//  by a filter driver with a single stream (e.g. the address of the
//  fileobject).
//

//
//  This structure needs to be embedded within the users context that
//  they want to associate with a given stream
//

typedef struct _FSRTL_PER_FILEOBJECT_CONTEXT {
    //
    //  This is linked into the File Object
    //

    LIST_ENTRY Links;

    //
    //  A Unique ID for this filter (ex: address of Driver Object, Device
    //  Object, or Device Extension)
    //

    PVOID OwnerId;

    //
    //  An optional ID to differentiate different contexts for the same
    //  filter.
    //

    PVOID InstanceId;

} FSRTL_PER_FILEOBJECT_CONTEXT, *PFSRTL_PER_FILEOBJECT_CONTEXT;


//
//  This will initialize the given FSRTL_PER_FILEOBJECT_CONTEXT structure.  This
//  should be used before calling "FsRtlInsertPerFileObjectContext".
//

#define FsRtlInitPerFileObjectContext( _fc, _owner, _inst )         \
    ((_fc)->OwnerId = (_owner),                                     \
     (_fc)->InstanceId = (_inst))                                   \

//
//  This will test to see if PerFileObject contexts are supported for the given
//  FileObject
//

#define FsRtlSupportsPerFileObjectContexts(_fo) \
    FlagOn((_fo)->Flags,FO_FILE_OBJECT_HAS_EXTENSION)

//
//  Associate the context at Ptr with the given FileObject.  The Ptr
//  structure should be filled in by the caller before calling this
//  routine (see FsRtlInitPerFileObjectContext).  If this file object does not
//  support filter contexts, STATUS_INVALID_DEVICE_REQUEST will be returned.
//

NTKERNELAPI
NTSTATUS
FsRtlInsertPerFileObjectContext (
    IN PFILE_OBJECT FileObject,
    IN PFSRTL_PER_FILEOBJECT_CONTEXT Ptr
    );

//
//  Lookup a filter context associated with the FileObject specified.  The first
//  context matching OwnerId (and InstanceId, if present) is returned.  By not
//  specifying InstanceId, a filter driver can search for any context that it
//  has previously associated with a stream.  If no matching context is found,
//  NULL is returned.  If the FileObject does not support contexts, 
//  NULL is returned.
//

NTKERNELAPI
PFSRTL_PER_FILEOBJECT_CONTEXT
FsRtlLookupPerFileObjectContext (
    IN PFILE_OBJECT FileObject,
    IN PVOID OwnerId OPTIONAL,
    IN PVOID InstanceId OPTIONAL
    );

//
//  Normally, contexts should be deleted when the IoManager notifies the
//  filter that the FileObject is being freed.  There are cases when a filter
//  may want to remove all existing contexts for a specific volume.  This
//  routine should be called at those times.  This routine should NOT be
//  called for the following case:
//      - Inside your FreeCallback handler - The IoManager has already removed
//        it from the linked list.
//
//  This functions identically to FsRtlLookupPerFileObjectContext, except that
//  the returned context has been removed from the list.
//

NTKERNELAPI
PFSRTL_PER_FILEOBJECT_CONTEXT
FsRtlRemovePerFileObjectContext (
    IN PFILE_OBJECT FileObject,
    IN PVOID OwnerId OPTIONAL,
    IN PVOID InstanceId OPTIONAL
    );

//
//  Internal routine to free the context control structure
//

VOID
FsRtlPTeardownPerFileObjectContexts (
  IN PFILE_OBJECT FileObject
  );


//  begin_ntifs
//++
//
//  VOID
//  FsRtlCompleteRequest (
//      IN PIRP Irp,
//      IN NTSTATUS Status
//      );
//
//  Routine Description:
//
//      This routine is used to complete an IRP with the indicated
//      status.  It does the necessary raise and lower of IRQL.
//
//  Arguments:
//
//      Irp - Supplies a pointer to the Irp to complete
//
//      Status - Supplies the completion status for the Irp
//
//  Return Value:
//
//      None.
//
//--

#define FsRtlCompleteRequest(IRP,STATUS) {         \
    (IRP)->IoStatus.Status = (STATUS);             \
    IoCompleteRequest( (IRP), IO_DISK_INCREMENT ); \
}


//++
//
//  VOID
//  FsRtlEnterFileSystem (
//      );
//
//  Routine Description:
//
//      This routine is used when entering a file system (e.g., through its
//      Fsd entry point).  It ensures that the file system cannot be suspended
//      while running and thus block other file I/O requests.  Upon exit
//      the file system must call FsRtlExitFileSystem.
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//--

#define FsRtlEnterFileSystem() { \
    KeEnterCriticalRegion();     \
}

//++
//
//  VOID
//  FsRtlExitFileSystem (
//      );
//
//  Routine Description:
//
//      This routine is used when exiting a file system (e.g., through its
//      Fsd entry point).
//
//  Arguments:
//
//  Return Value:
//
//      None.
//
//--

#define FsRtlExitFileSystem() { \
    KeLeaveCriticalRegion();    \
}


VOID
FsRtlIncrementCcFastReadNotPossible( VOID );

VOID
FsRtlIncrementCcFastReadWait( VOID );

VOID
FsRtlIncrementCcFastReadNoWait( VOID );

VOID
FsRtlIncrementCcFastReadResourceMiss( VOID );

//
//  Returns TRUE if the given fileObject represents a paging file, returns
//  FALSE otherwise.
//

LOGICAL
FsRtlIsPagingFile (
    IN PFILE_OBJECT FileObject
    );

//  end_ntifs

#endif // _FSRTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\hal.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hal.h

Abstract:

    This header file defines the Hardware Architecture Layer (HAL) interfaces
    that are exported by a system vendor to the NT system.

Author:

    David N. Cutler (davec) 25-Apr-1991


Revision History:

--*/

// begin_nthal

#ifndef _HAL_
#define _HAL_

// begin_ntosp

//
// Define OEM bitmapped font check values.
//

#define OEM_FONT_VERSION 0x200
#define OEM_FONT_TYPE 0
#define OEM_FONT_ITALIC 0
#define OEM_FONT_UNDERLINE 0
#define OEM_FONT_STRIKEOUT 0
#define OEM_FONT_CHARACTER_SET 255
#define OEM_FONT_FAMILY (3 << 4)

//
// Define OEM bitmapped font file header structure.
//
// N.B. this is a packed structure.
//

#include "pshpack1.h"
typedef struct _OEM_FONT_FILE_HEADER {
    USHORT Version;
    ULONG FileSize;
    UCHAR Copyright[60];
    USHORT Type;
    USHORT Points;
    USHORT VerticleResolution;
    USHORT HorizontalResolution;
    USHORT Ascent;
    USHORT InternalLeading;
    USHORT ExternalLeading;
    UCHAR Italic;
    UCHAR Underline;
    UCHAR StrikeOut;
    USHORT Weight;
    UCHAR CharacterSet;
    USHORT PixelWidth;
    USHORT PixelHeight;
    UCHAR Family;
    USHORT AverageWidth;
    USHORT MaximumWidth;
    UCHAR FirstCharacter;
    UCHAR LastCharacter;
    UCHAR DefaultCharacter;
    UCHAR BreakCharacter;
    USHORT WidthInBytes;
    ULONG Device;
    ULONG Face;
    ULONG BitsPointer;
    ULONG BitsOffset;
    UCHAR Filler;
    struct {
        USHORT Width;
        USHORT Offset;
    } Map[1];
} OEM_FONT_FILE_HEADER, *POEM_FONT_FILE_HEADER;
#include "poppack.h"


// end_ntosp

// begin_ntddk begin_wdm begin_ntosp
//
// Define the device description structure.
//

typedef struct _DEVICE_DESCRIPTION {
    ULONG Version;
    BOOLEAN Master;
    BOOLEAN ScatterGather;
    BOOLEAN DemandMode;
    BOOLEAN AutoInitialize;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN IgnoreCount;
    BOOLEAN Reserved1;          // must be false
    BOOLEAN Dma64BitAddresses;
    ULONG BusNumber; // unused for WDM
    ULONG DmaChannel;
    INTERFACE_TYPE  InterfaceType;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;
    ULONG MaximumLength;
    ULONG DmaPort;
} DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;

//
// Define the supported version numbers for the device description structure.
//

#define DEVICE_DESCRIPTION_VERSION  0
#define DEVICE_DESCRIPTION_VERSION1 1
#define DEVICE_DESCRIPTION_VERSION2 2

// end_ntddk end_wdm

//
// Boot record disk partition table entry structure format.
//

typedef struct _PARTITION_DESCRIPTOR {
    UCHAR ActiveFlag;               // Bootable or not
    UCHAR StartingTrack;            // Not used
    UCHAR StartingCylinderLsb;      // Not used
    UCHAR StartingCylinderMsb;      // Not used
    UCHAR PartitionType;            // 12 bit FAT, 16 bit FAT etc.
    UCHAR EndingTrack;              // Not used
    UCHAR EndingCylinderLsb;        // Not used
    UCHAR EndingCylinderMsb;        // Not used
    UCHAR StartingSectorLsb0;       // Hidden sectors
    UCHAR StartingSectorLsb1;
    UCHAR StartingSectorMsb0;
    UCHAR StartingSectorMsb1;
    UCHAR PartitionLengthLsb0;      // Sectors in this partition
    UCHAR PartitionLengthLsb1;
    UCHAR PartitionLengthMsb0;
    UCHAR PartitionLengthMsb1;
} PARTITION_DESCRIPTOR, *PPARTITION_DESCRIPTOR;

//
// Number of partition table entries
//

#define NUM_PARTITION_TABLE_ENTRIES     4

//
// Partition table record and boot signature offsets in 16-bit words.
//

#define PARTITION_TABLE_OFFSET         (0x1be / 2)
#define BOOT_SIGNATURE_OFFSET          ((0x200 / 2) - 1)

//
// Boot record signature value.
//

#define BOOT_RECORD_SIGNATURE          (0xaa55)

//
// Initial size of the Partition list structure.
//

#define PARTITION_BUFFER_SIZE          2048

//
// Partition active flag - i.e., boot indicator
//

#define PARTITION_ACTIVE_FLAG          0x80

// end_ntosp


// begin_ntddk
//
// The following function prototypes are for HAL routines with a prefix of Hal.
//
// General functions.
//

typedef
BOOLEAN
(*PHAL_RESET_DISPLAY_PARAMETERS) (
    IN ULONG Columns,
    IN ULONG Rows
    );

NTHALAPI
VOID
HalAcquireDisplayOwnership (
    IN PHAL_RESET_DISPLAY_PARAMETERS  ResetDisplayParameters
    );

// end_ntddk

NTHALAPI
VOID
HalDisplayString (
    PUCHAR String
    );

NTHALAPI
VOID
HalQueryDisplayParameters (
    OUT PULONG WidthInCharacters,
    OUT PULONG HeightInLines,
    OUT PULONG CursorColumn,
    OUT PULONG CursorRow
    );

NTHALAPI
VOID
HalSetDisplayParameters (
    IN ULONG CursorColumn,
    IN ULONG CursorRow
    );

NTHALAPI
BOOLEAN
HalInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTHALAPI
VOID
HalProcessorIdle(
    VOID
    );

NTHALAPI
VOID
HalReportResourceUsage (
    VOID
    );

NTHALAPI
ULONG
HalSetTimeIncrement (
    IN ULONG DesiredIncrement
    );

// begin_ntosp
//
// Get and set environment variable values.
//

NTHALAPI
ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    );

NTHALAPI
ARC_STATUS
HalSetEnvironmentVariable (
    IN PCHAR Variable,
    IN PCHAR Value
    );

NTHALAPI
NTSTATUS
HalGetEnvironmentVariableEx (
    IN PWSTR VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL
    );

NTSTATUS
HalSetEnvironmentVariableEx (
    IN PWSTR VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    );

NTSTATUS
HalEnumerateEnvironmentVariablesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    );

// end_ntosp

//
// Cache and write buffer flush functions.
//
//

#if defined(_ALPHA_) || defined(_IA64_)         // ntddk ntifs ntndis ntosp
                                                // ntddk ntifs ntndis ntosp

NTHALAPI
VOID
HalChangeColorPage (
    IN PVOID NewColor,
    IN PVOID OldColor,
    IN ULONG PageFrame
    );

NTHALAPI
VOID
HalFlushDcachePage (
    IN PVOID Color,
    IN ULONG PageFrame,
    IN ULONG Length
    );

// begin_ntosp
NTHALAPI
VOID
HalFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );

// begin_ntddk begin_ntifs begin_ntndis
DECLSPEC_DEPRECATED_DDK                 // Use GetDmaRequirement
NTHALAPI
ULONG
HalGetDmaAlignmentRequirement (
    VOID
    );

// end_ntosp end_ntddk end_ntifs end_ntndis
NTHALAPI
VOID
HalPurgeDcachePage (
    IN PVOID Color,
    IN ULONG PageFrame,
    IN ULONG Length
    );

NTHALAPI
VOID
HalPurgeIcachePage (
    IN PVOID Color,
    IN ULONG PageFrame,
    IN ULONG Length
    );

NTHALAPI
VOID
HalSweepDcache (
    VOID
    );

NTHALAPI
VOID
HalSweepDcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );

NTHALAPI
VOID
HalSweepIcache (
    VOID
    );

NTHALAPI
VOID
HalSweepIcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );


NTHALAPI
VOID
HalZeroPage (
    IN PVOID NewColor,
    IN PVOID OldColor,
    IN PFN_NUMBER PageFrame
    );

#endif                                          // ntddk ntifs ntndis ntosp
                                                // ntddk ntifs ntndis ntosp
#if defined(_M_IX86) || defined(_M_AMD64)       // ntddk ntifs ntndis ntosp
                                                // ntddk ntifs ntndis ntosp
#define HalGetDmaAlignmentRequirement() 1L      // ntddk ntifs ntndis ntosp

NTHALAPI
VOID
HalHandleNMI (
    IN OUT PVOID NmiInformation
    );

#if defined(_AMD64_)

NTHALAPI
VOID
HalHandleMcheck (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

#endif

//
// The following are temporary.
//

#if defined(_M_AMD64)

NTHALAPI
KIRQL
HalSwapIrql (
    IN KIRQL Irql
    );

NTHALAPI
KIRQL
HalGetCurrentIrql (
    VOID
    );

#endif

#endif                                          // ntddk ntifs ntndis ntosp
                                                // ntddk ntifs wdm ntndis

#if defined(_M_IA64)

NTHALAPI
VOID
HalSweepCacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );


NTHALAPI
LONGLONG
HalCallPal (
    IN  ULONGLONG  FunctionIndex,
    IN  ULONGLONG  Arguement1,
    IN  ULONGLONG  Arguement2,
    IN  ULONGLONG  Arguement3,
    OUT PULONGLONG ReturnValue0,
    OUT PULONGLONG ReturnValue1,
    OUT PULONGLONG ReturnValue2,
    OUT PULONGLONG ReturnValue3
    );

#endif

// begin_ntosp

NTHALAPI                                        // ntddk ntifs wdm ntndis
VOID                                            // ntddk ntifs wdm ntndis
KeFlushWriteBuffer (                            // ntddk ntifs wdm ntndis
    VOID                                        // ntddk ntifs wdm ntndis
    );                                          // ntddk ntifs wdm ntndis
                                                // ntddk ntifs wdm ntndis


#if defined(_ALPHA_)

NTHALAPI
PVOID
HalCreateQva(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN PVOID VirtualAddress
    );

NTHALAPI
PVOID
HalDereferenceQva(
    PVOID Qva,
    INTERFACE_TYPE InterfaceType,
    ULONG BusNumber
    );

#endif


#if !defined(_X86_)

NTHALAPI
BOOLEAN
HalCallBios (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp
    );

#endif
// end_ntosp

//
// Profiling functions.
//

NTHALAPI
VOID
HalCalibratePerformanceCounter (
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    );

NTHALAPI
ULONG_PTR
HalSetProfileInterval (
    IN ULONG_PTR Interval
    );


NTHALAPI
VOID
HalStartProfileInterrupt (
    KPROFILE_SOURCE ProfileSource
    );

NTHALAPI
VOID
HalStopProfileInterrupt (
    KPROFILE_SOURCE ProfileSource
    );

//
// Timer and interrupt functions.
//

// begin_ntosp
NTHALAPI
BOOLEAN
HalQueryRealTimeClock (
    OUT PTIME_FIELDS TimeFields
    );
// end_ntosp

NTHALAPI
BOOLEAN
HalSetRealTimeClock (
    IN PTIME_FIELDS TimeFields
    );

#if defined(_M_IX86) || defined(_M_AMD64)

NTHALAPI
VOID
FASTCALL
HalRequestSoftwareInterrupt (
    KIRQL RequestIrql
    );

ULONG
FASTCALL
HalSystemVectorDispatchEntry (
   IN ULONG Vector,
   OUT PKINTERRUPT_ROUTINE **FlatDispatch,
   OUT PKINTERRUPT_ROUTINE *NoConnection
   );

#endif

// begin_ntosp
//
// Firmware interface functions.
//

NTHALAPI
VOID
HalReturnToFirmware (
    IN FIRMWARE_REENTRY Routine
    );

//
// System interrupts functions.
//

NTHALAPI
VOID
HalDisableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql
    );

NTHALAPI
BOOLEAN
HalEnableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode
    );

// begin_ntddk
//
// I/O driver configuration functions.
//
#if !defined(NO_LEGACY_DRIVERS)
DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReportDetectedDevice
NTHALAPI
NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReportDetectedDevice
NTHALAPI
ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalSetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );
#endif // NO_LEGACY_DRIVERS

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

//
// Values for AddressSpace parameter of HalTranslateBusAddress
//
//      0x0         - Memory space
//      0x1         - Port space
//      0x2 - 0x1F  - Address spaces specific for Alpha
//                      0x2 - UserMode view of memory space
//                      0x3 - UserMode view of port space
//                      0x4 - Dense memory space
//                      0x5 - reserved
//                      0x6 - UserMode view of dense memory space
//                      0x7 - 0x1F - reserved
//

NTHALAPI
PVOID
HalAllocateCrashDumpRegisters(
    IN PADAPTER_OBJECT AdapterObject,
    IN OUT PULONG NumberOfMapRegisters
    );

#if !defined(NO_LEGACY_DRIVERS)
DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalGetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );
#endif // NO_LEGACY_DRIVERS

DECLSPEC_DEPRECATED_DDK                 // Use IRP_MN_QUERY_INTERFACE and IRP_MN_READ_CONFIG
NTHALAPI
ULONG
HalGetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

DECLSPEC_DEPRECATED_DDK                 // Use IoGetDmaAdapter
NTHALAPI
PADAPTER_OBJECT
HalGetAdapter(
    IN PDEVICE_DESCRIPTION DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    );

// end_ntddk end_ntosp

#if !defined(NO_LEGACY_DRIVERS)
NTHALAPI
NTSTATUS
HalAdjustResourceList (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );
#endif // NO_LEGACY_DRIVERS

// begin_ntddk begin_ntosp
//
// System beep functions.
//
#if !defined(NO_LEGACY_DRIVERS)
NTHALAPI
BOOLEAN
HalMakeBeep(
    IN ULONG Frequency
    );
#endif // NO_LEGACY_DRIVERS

//
// The following function prototypes are for HAL routines with a prefix of Io.
//
// DMA adapter object functions.
//

// end_ntddk end_ntosp

//
// Multi-Processorfunctions.
//

NTHALAPI
BOOLEAN
HalAllProcessorsStarted (
    VOID
    );

NTHALAPI
VOID
HalInitializeProcessor (
    IN ULONG Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTHALAPI
BOOLEAN
HalStartNextProcessor (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PKPROCESSOR_STATE ProcessorState
    );

NTHALAPI
VOID
HalRequestIpi (
    IN KAFFINITY Mask
    );

//
// The following function prototypes are for HAL routines with a prefix of Kd.
//
// Kernel debugger port functions.
//

NTHALAPI
BOOLEAN
KdPortInitialize (
    PDEBUG_PARAMETERS DebugParameters,
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    BOOLEAN Initialize
    );

NTHALAPI
ULONG
KdPortGetByte (
    OUT PUCHAR Input
    );

NTHALAPI
ULONG
KdPortPollByte (
    OUT PUCHAR Input
    );

NTHALAPI
VOID
KdPortPutByte (
    IN UCHAR Output
    );

NTHALAPI
VOID
KdPortRestore (
    VOID
    );

NTHALAPI
VOID
KdPortSave (
    VOID
    );

//
// The following function prototypes are for HAL routines with a prefix of Ke.
//
// begin_ntddk begin_ntifs begin_wdm  begin_ntosp
//
// Performance counter function.
//

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter (
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

// begin_ntndis
//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    );

// end_ntddk end_ntifs end_wdm end_ntndis end_ntosp


//*****************************************************************************
//
//  HAL BUS EXTENDERS

//
// Bus handlers
//

// begin_ntddk

typedef
VOID
(*PDEVICE_CONTROL_COMPLETION)(
    IN struct _DEVICE_CONTROL_CONTEXT     *ControlContext
    );

typedef struct _DEVICE_CONTROL_CONTEXT {
    NTSTATUS                Status;
    PDEVICE_HANDLER_OBJECT  DeviceHandler;
    PDEVICE_OBJECT          DeviceObject;
    ULONG                   ControlCode;
    PVOID                   Buffer;
    PULONG                  BufferLength;
    PVOID                   Context;
} DEVICE_CONTROL_CONTEXT, *PDEVICE_CONTROL_CONTEXT;

// end_ntddk

typedef struct _HAL_DEVICE_CONTROL {
    //
    // Handler this DeviceControl is for
    //
    struct _BUS_HANDLER         *Handler;
    struct _BUS_HANDLER         *RootHandler;

    //
    // Bus specific storage for this Context
    //
    PVOID                       BusExtensionData;

    //
    // Reserved for HALs use
    //
    ULONG                       HalReserved[4];

    //
    // Reserved for BusExtneder use
    //
    ULONG                       BusExtenderReserved[4];

    //
    // DeviceControl Context and the CompletionRoutine
    //
    PDEVICE_CONTROL_COMPLETION  CompletionRoutine;
    DEVICE_CONTROL_CONTEXT      DeviceControl;

} HAL_DEVICE_CONTROL_CONTEXT, *PHAL_DEVICE_CONTROL_CONTEXT;


typedef
ULONG
(*PGETSETBUSDATA)(
    IN struct _BUS_HANDLER *BusHandler,
    IN struct _BUS_HANDLER *RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef
ULONG
(*PGETINTERRUPTVECTOR)(
    IN struct _BUS_HANDLER *BusHandler,
    IN struct _BUS_HANDLER *RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

typedef
BOOLEAN
(*PTRANSLATEBUSADDRESS)(
    IN struct _BUS_HANDLER *BusHandler,
    IN struct _BUS_HANDLER *RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef NTSTATUS
(*PADJUSTRESOURCELIST)(
    IN struct _BUS_HANDLER *BusHandler,
    IN struct _BUS_HANDLER *RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

typedef PDEVICE_HANDLER_OBJECT
(*PREFERENCE_DEVICE_HANDLER)(
    IN struct _BUS_HANDLER      *BusHandler,
    IN struct _BUS_HANDLER      *RootHandler,
    IN ULONG                    SlotNumber
    );

//typedef VOID
//(*PDEREFERENCE_DEVICE_HANDLER)(
//    IN PDEVICE_HANDLER_OBJECT   DeviceHandler
//    );

typedef NTSTATUS
(*PASSIGNSLOTRESOURCES)(
    IN struct _BUS_HANDLER      *BusHandler,
    IN struct _BUS_HANDLER      *RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

typedef
NTSTATUS
(*PQUERY_BUS_SLOTS)(
    IN struct _BUS_HANDLER      *BusHandler,
    IN struct _BUS_HANDLER      *RootHandler,
    IN ULONG                    BufferSize,
    OUT PULONG                  SlotNumbers,
    OUT PULONG                  ReturnedLength
    );

typedef ULONG
(*PGET_SET_DEVICE_INSTANCE_DATA)(
    IN struct _BUS_HANDLER      *BusHandler,
    IN struct _BUS_HANDLER      *RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );


typedef
NTSTATUS
(*PDEVICE_CONTROL)(
    IN PHAL_DEVICE_CONTROL_CONTEXT Context
    );


typedef
NTSTATUS
(*PHIBERNATEBRESUMEBUS)(
    IN struct _BUS_HANDLER      *BusHandler,
    IN struct _BUS_HANDLER      *RootHandler
    );

//
// Supported range structures
//

#define BUS_SUPPORTED_RANGE_VERSION 1

typedef struct _SUPPORTED_RANGE {
    struct _SUPPORTED_RANGE     *Next;
    ULONG                       SystemAddressSpace;
    LONGLONG                    SystemBase;
    LONGLONG                    Base;
    LONGLONG                    Limit;
} SUPPORTED_RANGE, *PSUPPORTED_RANGE;

typedef struct _SUPPORTED_RANGES {
    USHORT              Version;
    BOOLEAN             Sorted;
    UCHAR               Reserved;

    ULONG               NoIO;
    SUPPORTED_RANGE     IO;

    ULONG               NoMemory;
    SUPPORTED_RANGE     Memory;

    ULONG               NoPrefetchMemory;
    SUPPORTED_RANGE     PrefetchMemory;

    ULONG               NoDma;
    SUPPORTED_RANGE     Dma;
} SUPPORTED_RANGES, *PSUPPORTED_RANGES;

//
// Bus handler structure
//

#define BUS_HANDLER_VERSION 1

typedef struct _BUS_HANDLER {
    //
    // Version of structure
    //

    ULONG                           Version;

    //
    // This bus handler structure is for the following bus
    //

    INTERFACE_TYPE                  InterfaceType;
    BUS_DATA_TYPE                   ConfigurationType;
    ULONG                           BusNumber;

    //
    // Device object for this bus extender, or NULL if it is
    // a hal internal bus extender
    //

    PDEVICE_OBJECT                  DeviceObject;

    //
    // The parent handlers for this bus
    //

    struct _BUS_HANDLER             *ParentHandler;

    //
    // Bus specific strorage
    //

    PVOID                           BusData;

    //
    // Amount of bus specific storage needed for DeviceControl function calls
    //

    ULONG                           DeviceControlExtensionSize;

    //
    // Supported address ranges this bus allows
    //

    PSUPPORTED_RANGES               BusAddresses;

    //
    // For future use
    //

    ULONG                           Reserved[4];

    //
    // Handlers for this bus
    //

    PGETSETBUSDATA                  GetBusData;
    PGETSETBUSDATA                  SetBusData;
    PADJUSTRESOURCELIST             AdjustResourceList;
    PASSIGNSLOTRESOURCES            AssignSlotResources;
    PGETINTERRUPTVECTOR             GetInterruptVector;
    PTRANSLATEBUSADDRESS            TranslateBusAddress;

    PVOID                           Spare1;
    PVOID                           Spare2;
    PVOID                           Spare3;
    PVOID                           Spare4;
    PVOID                           Spare5;
    PVOID                           Spare6;
    PVOID                           Spare7;
    PVOID                           Spare8;

} BUS_HANDLER, *PBUS_HANDLER;

VOID
HalpInitBusHandler (
    VOID
    );

typedef
NTSTATUS
(*PINSTALL_BUS_HANDLER)(
      IN PBUS_HANDLER   Bus
      );

typedef
NTSTATUS
(*pHalRegisterBusHandler)(
    IN INTERFACE_TYPE          InterfaceType,
    IN BUS_DATA_TYPE           AssociatedConfigurationSpace,
    IN ULONG                   BusNumber,
    IN INTERFACE_TYPE          ParentBusType,
    IN ULONG                   ParentBusNumber,
    IN ULONG                   SizeofBusExtensionData,
    IN PINSTALL_BUS_HANDLER    InstallBusHandlers,
    OUT PBUS_HANDLER           *BusHandler
    );

NTSTATUS
HaliRegisterBusHandler (
    IN INTERFACE_TYPE          InterfaceType,
    IN BUS_DATA_TYPE           AssociatedConfigurationSpace,
    IN ULONG                   BusNumber,
    IN INTERFACE_TYPE          ParentBusType,
    IN ULONG                   ParentBusNumber,
    IN ULONG                   SizeofBusExtensionData,
    IN PINSTALL_BUS_HANDLER    InstallBusHandlers,
    OUT PBUS_HANDLER           *BusHandler
    );

// begin_ntddk begin_ntosp
typedef
PBUS_HANDLER
(FASTCALL *pHalHandlerForBus) (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    );
// end_ntddk end_ntosp

PBUS_HANDLER
FASTCALL
HaliReferenceHandlerForBus (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    );

PBUS_HANDLER
FASTCALL
HaliHandlerForBus (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    );

typedef VOID
(FASTCALL *pHalRefernceBusHandler) (
    IN PBUS_HANDLER   BusHandler
    );

VOID
FASTCALL
HaliDerefernceBusHandler (
    IN PBUS_HANDLER   BusHandler
    );

typedef
PBUS_HANDLER
(FASTCALL *pHalHandlerForConfigSpace) (
    IN BUS_DATA_TYPE  ConfigSpace,
    IN ULONG          BusNumber
    );

PBUS_HANDLER
FASTCALL
HaliHandlerForConfigSpace (
    IN BUS_DATA_TYPE  ConfigSpace,
    IN ULONG          BusNumber
    );

// begin_ntddk begin_ntosp
typedef
VOID
(FASTCALL *pHalReferenceBusHandler) (
    IN PBUS_HANDLER   BusHandler
    );
// end_ntddk end_ntosp

VOID
FASTCALL
HaliReferenceBusHandler (
    IN PBUS_HANDLER   BusHandler
    );

VOID
FASTCALL
HaliDereferenceBusHandler (
    IN PBUS_HANDLER   BusHandler
    );


NTSTATUS
HaliQueryBusSlots (
    IN PBUS_HANDLER             BusHandler,
    IN ULONG                    BufferSize,
    OUT PULONG                  SlotNumbers,
    OUT PULONG                  ReturnedLength
    );

NTSTATUS
HaliAdjustResourceListRange (
    IN PSUPPORTED_RANGES                    SupportedRanges,
    IN PSUPPORTED_RANGE                     InterruptRanges,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

VOID
HaliLocateHiberRanges (
    IN PVOID MemoryMap
    );


typedef
VOID
(*pHalSetWakeEnable)(
    IN BOOLEAN          Enable
    );


typedef
VOID
(*pHalSetWakeAlarm)(
    IN ULONGLONG        WakeTime,
    IN PTIME_FIELDS     WakeTimeFields
    );

typedef
VOID
(*pHalLocateHiberRanges)(
    IN PVOID MemoryMap
    );


// begin_ntddk begin_ntosp

//*****************************************************************************
//      HAL Function dispatch
//

typedef enum _HAL_QUERY_INFORMATION_CLASS {
    HalInstalledBusInformation,
    HalProfileSourceInformation,
    HalInformationClassUnused1,
    HalPowerInformation,
    HalProcessorSpeedInformation,
    HalCallbackInformation,
    HalMapRegisterInformation,
    HalMcaLogInformation,               // Machine Check Abort Information
    HalFrameBufferCachingInformation,
    HalDisplayBiosInformation,
    HalProcessorFeatureInformation,
    HalNumaTopologyInterface,
    HalErrorInformation,                // General MCA, CMC, CPE Error Information.
    HalCmcLogInformation,               // Processor Corrected Machine Check Information
    HalCpeLogInformation,               // Corrected Platform Error Information
    HalQueryMcaInterface,
    HalQueryAMLIIllegalIOPortAddresses,
    HalQueryMaxHotPlugMemoryAddress,
    HalPartitionIpiInterface,
    HalPlatformInformation
    // information levels >= 0x8000000 reserved for OEM use
} HAL_QUERY_INFORMATION_CLASS, *PHAL_QUERY_INFORMATION_CLASS;


typedef enum _HAL_SET_INFORMATION_CLASS {
    HalProfileSourceInterval,
    HalProfileSourceInterruptHandler,
    HalMcaRegisterDriver,              // Registring Machine Check Abort driver
    HalKernelErrorHandler,
    HalCmcRegisterDriver,              // Registring Processor Corrected Machine Check driver
    HalCpeRegisterDriver,              // Registring Corrected Platform  Error driver
    HalMcaLog,
    HalCmcLog,
    HalCpeLog,
} HAL_SET_INFORMATION_CLASS, *PHAL_SET_INFORMATION_CLASS;


typedef
NTSTATUS
(*pHalQuerySystemInformation)(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    IN OUT PVOID Buffer,
    OUT PULONG   ReturnedLength
    );

NTSTATUS
HaliQuerySystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN OUT PVOID Buffer,
    OUT PULONG   ReturnedLength
    );
NTSTATUS
HaliHandlePCIConfigSpaceAccess(
    IN      BOOLEAN Read,
    IN      ULONG   Addr,
    IN      ULONG   Size,
    IN OUT  PULONG  pData
    );

typedef
NTSTATUS
(*pHalSetSystemInformation)(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );

NTSTATUS
HaliSetSystemInformation(
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );

typedef
VOID
(FASTCALL *pHalExamineMBR)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG MBRTypeIdentifier,
    OUT PVOID *Buffer
    );

typedef
VOID
(FASTCALL *pHalIoAssignDriveLetters)(
    IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    IN PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );

typedef
NTSTATUS
(FASTCALL *pHalIoReadPartitionTable)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );

typedef
NTSTATUS
(FASTCALL *pHalIoSetPartitionInformation)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

typedef
NTSTATUS
(FASTCALL *pHalIoWritePartitionTable)(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

typedef
NTSTATUS
(*pHalQueryBusSlots)(
    IN PBUS_HANDLER         BusHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    );

typedef
NTSTATUS
(*pHalInitPnpDriver)(
    VOID
    );

NTSTATUS
HaliInitPnpDriver(
    VOID
    );

typedef struct _PM_DISPATCH_TABLE {
    ULONG   Signature;
    ULONG   Version;
    PVOID   Function[1];
} PM_DISPATCH_TABLE, *PPM_DISPATCH_TABLE;

typedef
NTSTATUS
(*pHalInitPowerManagement)(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    );

NTSTATUS
HaliInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    );

typedef
struct _DMA_ADAPTER *
(*pHalGetDmaAdapter)(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

struct _DMA_ADAPTER *
HaliGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

typedef
NTSTATUS
(*pHalGetInterruptTranslator)(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );

NTSTATUS
HaliGetInterruptTranslator(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );

typedef
BOOLEAN
(*pHalTranslateBusAddress)(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef
NTSTATUS
(*pHalAssignSlotResources) (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

typedef
VOID
(*pHalHaltSystem) (
    VOID
    );

typedef
VOID
(*pHalResetDisplay) (
    VOID
    );

typedef
UCHAR
(*pHalVectorToIDTEntry) (
    ULONG Vector
);

typedef
BOOLEAN
(*pHalFindBusAddressTranslation) (
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

typedef
NTSTATUS
(*pHalStartMirroring)(
    VOID
    );

typedef
NTSTATUS
(*pHalEndMirroring)(
    IN ULONG PassNumber
    );

typedef
NTSTATUS
(*pHalMirrorPhysicalMemory)(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN LARGE_INTEGER NumberOfBytes
    );

typedef
NTSTATUS
(*pHalMirrorVerify)(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN LARGE_INTEGER NumberOfBytes
    );

typedef struct {
    UCHAR     Type;  //CmResourceType
    BOOLEAN   Valid;
    UCHAR     Reserved[2];
    PUCHAR    TranslatedAddress;
    ULONG     Length;
} DEBUG_DEVICE_ADDRESS, *PDEBUG_DEVICE_ADDRESS;

typedef struct {
    PHYSICAL_ADDRESS  Start;
    PHYSICAL_ADDRESS  MaxEnd;
    PVOID             VirtualAddress;
    ULONG             Length;
    BOOLEAN           Cached;
    BOOLEAN           Aligned;
} DEBUG_MEMORY_REQUIREMENTS, *PDEBUG_MEMORY_REQUIREMENTS;

typedef struct {
    ULONG     Bus;
    ULONG     Slot;
    USHORT    VendorID;
    USHORT    DeviceID;
    UCHAR     BaseClass;
    UCHAR     SubClass;
    UCHAR     ProgIf;
    BOOLEAN   Initialized;
    DEBUG_DEVICE_ADDRESS BaseAddress[6];
    DEBUG_MEMORY_REQUIREMENTS   Memory;
} DEBUG_DEVICE_DESCRIPTOR, *PDEBUG_DEVICE_DESCRIPTOR;

typedef
NTSTATUS
(*pKdSetupPciDeviceForDebugging)(
    IN     PVOID                     LoaderBlock,   OPTIONAL
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

typedef
NTSTATUS
(*pKdReleasePciDeviceForDebugging)(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

typedef
PVOID
(*pKdGetAcpiTablePhase0)(
    IN struct _LOADER_PARAMETER_BLOCK *LoaderBlock,
    IN ULONG Signature
    );

typedef
VOID
(*pKdCheckPowerButton)(
    VOID
    );

typedef
VOID
(*pHalEndOfBoot)(
    VOID
    );

typedef
PVOID
(*pKdMapPhysicalMemory64)(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    );

typedef
VOID
(*pKdUnmapVirtualAddress)(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    );


typedef struct {
    ULONG                           Version;
    pHalQuerySystemInformation      HalQuerySystemInformation;
    pHalSetSystemInformation        HalSetSystemInformation;
    pHalQueryBusSlots               HalQueryBusSlots;
    ULONG                           Spare1;
    pHalExamineMBR                  HalExamineMBR;
    pHalIoAssignDriveLetters        HalIoAssignDriveLetters;
    pHalIoReadPartitionTable        HalIoReadPartitionTable;
    pHalIoSetPartitionInformation   HalIoSetPartitionInformation;
    pHalIoWritePartitionTable       HalIoWritePartitionTable;

    pHalHandlerForBus               HalReferenceHandlerForBus;
    pHalReferenceBusHandler         HalReferenceBusHandler;
    pHalReferenceBusHandler         HalDereferenceBusHandler;

    pHalInitPnpDriver               HalInitPnpDriver;
    pHalInitPowerManagement         HalInitPowerManagement;

    pHalGetDmaAdapter               HalGetDmaAdapter;
    pHalGetInterruptTranslator      HalGetInterruptTranslator;

    pHalStartMirroring              HalStartMirroring;
    pHalEndMirroring                HalEndMirroring;
    pHalMirrorPhysicalMemory        HalMirrorPhysicalMemory;
    pHalEndOfBoot                   HalEndOfBoot;
    pHalMirrorVerify                HalMirrorVerify;

} HAL_DISPATCH, *PHAL_DISPATCH;

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

extern  PHAL_DISPATCH   HalDispatchTable;
#define HALDISPATCH     HalDispatchTable

#else

extern  HAL_DISPATCH    HalDispatchTable;
#define HALDISPATCH     (&HalDispatchTable)

#endif

#define HAL_DISPATCH_VERSION        3

#define HalDispatchTableVersion         HALDISPATCH->Version
#define HalQuerySystemInformation       HALDISPATCH->HalQuerySystemInformation
#define HalSetSystemInformation         HALDISPATCH->HalSetSystemInformation
#define HalQueryBusSlots                HALDISPATCH->HalQueryBusSlots

#define HalReferenceHandlerForBus       HALDISPATCH->HalReferenceHandlerForBus
#define HalReferenceBusHandler          HALDISPATCH->HalReferenceBusHandler
#define HalDereferenceBusHandler        HALDISPATCH->HalDereferenceBusHandler

#define HalInitPnpDriver                HALDISPATCH->HalInitPnpDriver
#define HalInitPowerManagement          HALDISPATCH->HalInitPowerManagement

#define HalGetDmaAdapter                HALDISPATCH->HalGetDmaAdapter
#define HalGetInterruptTranslator       HALDISPATCH->HalGetInterruptTranslator

#define HalStartMirroring               HALDISPATCH->HalStartMirroring
#define HalEndMirroring                 HALDISPATCH->HalEndMirroring
#define HalMirrorPhysicalMemory         HALDISPATCH->HalMirrorPhysicalMemory
#define HalEndOfBoot                    HALDISPATCH->HalEndOfBoot
#define HalMirrorVerify                 HALDISPATCH->HalMirrorVerify

// end_ntddk end_ntosp

typedef struct {
    ULONG                               Version;

    pHalHandlerForBus                   HalHandlerForBus;
    pHalHandlerForConfigSpace           HalHandlerForConfigSpace;
    pHalLocateHiberRanges               HalLocateHiberRanges;

    pHalRegisterBusHandler              HalRegisterBusHandler;

    pHalSetWakeEnable                   HalSetWakeEnable;
    pHalSetWakeAlarm                    HalSetWakeAlarm;

    pHalTranslateBusAddress             HalPciTranslateBusAddress;
    pHalAssignSlotResources             HalPciAssignSlotResources;

    pHalHaltSystem                      HalHaltSystem;

    pHalFindBusAddressTranslation       HalFindBusAddressTranslation;

    pHalResetDisplay                    HalResetDisplay;

    pKdSetupPciDeviceForDebugging       KdSetupPciDeviceForDebugging;
    pKdReleasePciDeviceForDebugging     KdReleasePciDeviceForDebugging;

    pKdGetAcpiTablePhase0               KdGetAcpiTablePhase0;
    pKdCheckPowerButton                 KdCheckPowerButton;

    pHalVectorToIDTEntry                HalVectorToIDTEntry;

    pKdMapPhysicalMemory64              KdMapPhysicalMemory64;
    pKdUnmapVirtualAddress              KdUnmapVirtualAddress;

} HAL_PRIVATE_DISPATCH, *PHAL_PRIVATE_DISPATCH;


#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

extern  PHAL_PRIVATE_DISPATCH           HalPrivateDispatchTable;
#define HALPDISPATCH                    HalPrivateDispatchTable

#else

extern  HAL_PRIVATE_DISPATCH            HalPrivateDispatchTable;
#define HALPDISPATCH                    (&HalPrivateDispatchTable)

#endif

#define HAL_PRIVATE_DISPATCH_VERSION        2

#define HalRegisterBusHandler           HALPDISPATCH->HalRegisterBusHandler
#define HalHandlerForBus                HALPDISPATCH->HalHandlerForBus
#define HalHandlerForConfigSpace        HALPDISPATCH->HalHandlerForConfigSpace
#define HalLocateHiberRanges            HALPDISPATCH->HalLocateHiberRanges
#define HalSetWakeEnable                HALPDISPATCH->HalSetWakeEnable
#define HalSetWakeAlarm                 HALPDISPATCH->HalSetWakeAlarm
#define HalHaltSystem                   HALPDISPATCH->HalHaltSystem
#define HalResetDisplay                 HALPDISPATCH->HalResetDisplay
#define KdSetupPciDeviceForDebugging    HALPDISPATCH->KdSetupPciDeviceForDebugging
#define KdReleasePciDeviceForDebugging  HALPDISPATCH->KdReleasePciDeviceForDebugging
#define KdGetAcpiTablePhase0            HALPDISPATCH->KdGetAcpiTablePhase0
#define KdCheckPowerButton              HALPDISPATCH->KdCheckPowerButton
#define HalVectorToIDTEntry             HALPDISPATCH->HalVectorToIDTEntry
#define KdMapPhysicalMemory64           HALPDISPATCH->KdMapPhysicalMemory64
#define KdUnmapVirtualAddress           HALPDISPATCH->KdUnmapVirtualAddress

// begin_ntddk begin_ntosp

//
// HAL System Information Structures.
//

// for the information class "HalInstalledBusInformation"
typedef struct _HAL_BUS_INFORMATION{
    INTERFACE_TYPE  BusType;
    BUS_DATA_TYPE   ConfigurationType;
    ULONG           BusNumber;
    ULONG           Reserved;
} HAL_BUS_INFORMATION, *PHAL_BUS_INFORMATION;

// for the information class "HalProfileSourceInformation"
typedef struct _HAL_PROFILE_SOURCE_INFORMATION {
    KPROFILE_SOURCE Source;
    BOOLEAN Supported;
    ULONG Interval;
} HAL_PROFILE_SOURCE_INFORMATION, *PHAL_PROFILE_SOURCE_INFORMATION;

typedef struct _HAL_PROFILE_SOURCE_INFORMATION_EX {
    KPROFILE_SOURCE Source;
    BOOLEAN         Supported;
    ULONG_PTR       Interval;
    ULONG_PTR       DefInterval;
    ULONG_PTR       MaxInterval;
    ULONG_PTR       MinInterval;
} HAL_PROFILE_SOURCE_INFORMATION_EX, *PHAL_PROFILE_SOURCE_INFORMATION_EX;

// for the information class "HalProfileSourceInterval"
typedef struct _HAL_PROFILE_SOURCE_INTERVAL {
    KPROFILE_SOURCE Source;
    ULONG_PTR Interval;
} HAL_PROFILE_SOURCE_INTERVAL, *PHAL_PROFILE_SOURCE_INTERVAL;

// for the information class "HalDispayBiosInformation"
typedef enum _HAL_DISPLAY_BIOS_INFORMATION {
    HalDisplayInt10Bios,
    HalDisplayEmulatedBios,
    HalDisplayNoBios
} HAL_DISPLAY_BIOS_INFORMATION, *PHAL_DISPLAY_BIOS_INFORMATION;

// for the information class "HalPowerInformation"
typedef struct _HAL_POWER_INFORMATION {
    ULONG   TBD;
} HAL_POWER_INFORMATION, *PHAL_POWER_INFORMATION;

// for the information class "HalProcessorSpeedInformation"
typedef struct _HAL_PROCESSOR_SPEED_INFO {
    ULONG   ProcessorSpeed;
} HAL_PROCESSOR_SPEED_INFORMATION, *PHAL_PROCESSOR_SPEED_INFORMATION;

// for the information class "HalCallbackInformation"
typedef struct _HAL_CALLBACKS {
    PCALLBACK_OBJECT  SetSystemInformation;
    PCALLBACK_OBJECT  BusCheck;
} HAL_CALLBACKS, *PHAL_CALLBACKS;

// for the information class "HalProcessorFeatureInformation"
typedef struct _HAL_PROCESSOR_FEATURE {
    ULONG UsableFeatureBits;
} HAL_PROCESSOR_FEATURE;

// for the information class "HalNumaTopologyInterface"

typedef ULONG HALNUMAPAGETONODE;

typedef
HALNUMAPAGETONODE
(*PHALNUMAPAGETONODE)(
    IN  ULONG_PTR   PhysicalPageNumber
    );

typedef
NTSTATUS
(*PHALNUMAQUERYPROCESSORNODE)(
    IN  ULONG       ProcessorNumber,
    OUT PUSHORT     Identifier,
    OUT PUCHAR      Node
    );

typedef struct _HAL_NUMA_TOPOLOGY_INTERFACE {
    ULONG                               NumberOfNodes;
    PHALNUMAQUERYPROCESSORNODE          QueryProcessorNode;
    PHALNUMAPAGETONODE                  PageToNode;
} HAL_NUMA_TOPOLOGY_INTERFACE;

typedef
NTSTATUS
(*PHALIOREADWRITEHANDLER)(
    IN      BOOLEAN fRead,
    IN      ULONG dwAddr,
    IN      ULONG dwSize,
    IN OUT  PULONG pdwData
    );

// for the information class "HalQueryIllegalIOPortAddresses"
typedef struct _HAL_AMLI_BAD_IO_ADDRESS_LIST
{
    ULONG                   BadAddrBegin;
    ULONG                   BadAddrSize;
    ULONG                   OSVersionTrigger;
    PHALIOREADWRITEHANDLER  IOHandler;
} HAL_AMLI_BAD_IO_ADDRESS_LIST, *PHAL_AMLI_BAD_IO_ADDRESS_LIST;

// end_ntosp

#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

//
// HalQueryMcaInterface
//

typedef
VOID
(*PHALMCAINTERFACELOCK)(
    VOID
    );

typedef
VOID
(*PHALMCAINTERFACEUNLOCK)(
    VOID
    );

typedef
NTSTATUS
(*PHALMCAINTERFACEREADREGISTER)(
    IN     UCHAR    BankNumber,
    IN OUT PVOID    Exception
    );

typedef struct _HAL_MCA_INTERFACE {
    PHALMCAINTERFACELOCK            Lock;
    PHALMCAINTERFACEUNLOCK          Unlock;
    PHALMCAINTERFACEREADREGISTER    ReadRegister;
} HAL_MCA_INTERFACE;

typedef
#if defined(_IA64_)
ERROR_SEVERITY
#else  // !_IA64_
VOID
#endif // !_IA64_
(*PDRIVER_EXCPTN_CALLBACK) (
    IN PVOID            Context,
    IN PMCA_EXCEPTION   BankLog
);

typedef PDRIVER_EXCPTN_CALLBACK  PDRIVER_MCA_EXCEPTION_CALLBACK;

//
// Structure to record the callbacks from driver
//

typedef struct _MCA_DRIVER_INFO {
    PDRIVER_MCA_EXCEPTION_CALLBACK ExceptionCallback;
    PKDEFERRED_ROUTINE             DpcCallback;
    PVOID                          DeviceContext;
} MCA_DRIVER_INFO, *PMCA_DRIVER_INFO;

// For the information class HalKernelErrorHandler
typedef BOOLEAN (*KERNEL_MCA_DELIVERY)( PVOID Reserved, PVOID Argument2 );
typedef BOOLEAN (*KERNEL_CMC_DELIVERY)( PVOID Reserved, PVOID Argument2 );
typedef BOOLEAN (*KERNEL_CPE_DELIVERY)( PVOID Reserved, PVOID Argument2 );
typedef BOOLEAN (*KERNEL_MCE_DELIVERY)( PVOID Reserved, PVOID Argument2 );

#define KERNEL_ERROR_HANDLER_VERSION 0x1
typedef struct
{
    ULONG                Version;     // Version of this structure. Required to be 1rst field.
    ULONG                Padding;
    KERNEL_MCA_DELIVERY  KernelMcaDelivery;   // Kernel callback for MCA DPC Queueing.
    KERNEL_CMC_DELIVERY  KernelCmcDelivery;   // Kernel callback for CMC DPC Queueing.
    KERNEL_CPE_DELIVERY  KernelCpeDelivery;   // Kernel callback for CPE DPC Queueing.
    KERNEL_MCE_DELIVERY  KernelMceDelivery;   // Kernel callback for CME DPC Queueing.
                                              //    Includes the kernel notifications for FW
                                              //    interfaces errors.
} KERNEL_ERROR_HANDLER_INFO, *PKERNEL_ERROR_HANDLER_INFO;

// KERNEL_MCA_DELIVERY.McaType definition
#define KERNEL_MCA_UNKNOWN   0x0
#define KERNEL_MCA_PREVIOUS  0x1
#define KERNEL_MCA_CORRECTED 0x2

// KERNEL_MCE_DELIVERY.Reserved.EVENTTYPE definitions
#define KERNEL_MCE_EVENTTYPE_MCA   0x00
#define KERNEL_MCE_EVENTTYPE_INIT  0x01
#define KERNEL_MCE_EVENTTYPE_CMC   0x02
#define KERNEL_MCE_EVENTTYPE_CPE   0x03
#define KERNEL_MCE_EVENTTYPE_MASK  0xffff
#define KERNEL_MCE_EVENTTYPE( _Reverved ) ((USHORT)(ULONG_PTR)(_Reserved))

// KERNEL_MCE_DELIVERY.Reserved.OPERATION definitions
#define KERNEL_MCE_OPERATION_CLEAR_STATE_INFO   0x1
#define KERNEL_MCE_OPERATION_GET_STATE_INFO     0x2
#define KERNEL_MCE_OPERATION_MASK               0xffff
#define KERNEL_MCE_OPERATION_SHIFT              KERNEL_MCE_EVENTTYPE_MASK
#define KERNEL_MCE_OPERATION( _Reserved )  \
   ((USHORT)((((ULONG_PTR)(_Reserved)) >> KERNEL_MCE_OPERATION_SHIFT) & KERNEL_MCE_OPERATION_MASK))

// for information class HalErrorInformation
#define HAL_ERROR_INFO_VERSION 0x2

typedef struct _HAL_ERROR_INFO {
    ULONG     Version;                 // Version of this structure
    ULONG     Reserved;                //
    ULONG     McaMaxSize;              // Maximum size of a Machine Check Abort record
    ULONG     McaPreviousEventsCount;  // Flag indicating previous or early-boot MCA event logs.
    ULONG     McaCorrectedEventsCount; // Number of corrected MCA events since boot.      approx.
    ULONG     McaKernelDeliveryFails;  // Number of Kernel callback failures.             approx.
    ULONG     McaDriverDpcQueueFails;  // Number of OEM MCA Driver Dpc queueing failures. approx.
    ULONG     McaReserved;
    ULONG     CmcMaxSize;              // Maximum size of a Corrected Machine  Check record
    ULONG     CmcPollingInterval;      // In units of seconds
    ULONG     CmcInterruptsCount;      // Number of CMC interrupts.                       approx.
    ULONG     CmcKernelDeliveryFails;  // Number of Kernel callback failures.             approx.
    ULONG     CmcDriverDpcQueueFails;  // Number of OEM CMC Driver Dpc queueing failures. approx.
    ULONG     CmcGetStateFails;        // Number of failures in getting  the log from FW.
    ULONG     CmcClearStateFails;      // Number of failures in clearing the log from FW.
    ULONG     CmcReserved;
    ULONGLONG CmcLogId;                // Last seen record identifier.
    ULONG     CpeMaxSize;              // Maximum size of a Corrected Platform Event record
    ULONG     CpePollingInterval;      // In units of seconds
    ULONG     CpeInterruptsCount;      // Number of CPE interrupts.                       approx.
    ULONG     CpeKernelDeliveryFails;  // Number of Kernel callback failures.             approx.
    ULONG     CpeDriverDpcQueueFails;  // Number of OEM CPE Driver Dpc queueing failures. approx.
    ULONG     CpeGetStateFails;        // Number of failures in getting  the log from FW.
    ULONG     CpeClearStateFails;      // Number of failures in clearing the log from FW.
    ULONG     CpeInterruptSources;     // Number of SAPIC Platform Interrupt Sources
    ULONGLONG CpeLogId;                // Last seen record identifier.
    ULONGLONG KernelReserved[4];
} HAL_ERROR_INFO, *PHAL_ERROR_INFO;

//
// Known values for HAL_ERROR_INFO.CmcPollingInterval.
//

#define HAL_CMC_INTERRUPTS_BASED  ((ULONG)-1)
#define HAL_CMC_DISABLED          ((ULONG)0)

//
// Known values for HAL_ERROR_INFO.CpePollingInterval.
//

#define HAL_CPE_INTERRUPTS_BASED  ((ULONG)-1)
#define HAL_CPE_DISABLED          ((ULONG)0)

#define HAL_MCA_INTERRUPTS_BASED  ((ULONG)-1)
#define HAL_MCA_DISABLED          ((ULONG)0)

// end_ntddk

//
// Kernel/WMI Tokens for HAL MCE Log Interfaces
//

#define McaKernelToken KernelReserved[0]
#define CmcKernelToken KernelReserved[1]
#define CpeKernelToken KernelReserved[2]

// begin_ntddk

//
// Driver Callback type for the information class "HalCmcRegisterDriver"
//

typedef
VOID
(*PDRIVER_CMC_EXCEPTION_CALLBACK) (
    IN PVOID            Context,
    IN PCMC_EXCEPTION   CmcLog
);

//
// Driver Callback type for the information class "HalCpeRegisterDriver"
//

typedef
VOID
(*PDRIVER_CPE_EXCEPTION_CALLBACK) (
    IN PVOID            Context,
    IN PCPE_EXCEPTION   CmcLog
);

//
//
// Structure to record the callbacks from driver
//

typedef struct _CMC_DRIVER_INFO {
    PDRIVER_CMC_EXCEPTION_CALLBACK ExceptionCallback;
    PKDEFERRED_ROUTINE             DpcCallback;
    PVOID                          DeviceContext;
} CMC_DRIVER_INFO, *PCMC_DRIVER_INFO;

typedef struct _CPE_DRIVER_INFO {
    PDRIVER_CPE_EXCEPTION_CALLBACK ExceptionCallback;
    PKDEFERRED_ROUTINE             DpcCallback;
    PVOID                          DeviceContext;
} CPE_DRIVER_INFO, *PCPE_DRIVER_INFO;

#endif // defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

#if defined(_IA64_)

typedef
NTSTATUS
(*HALSENDCROSSPARTITIONIPI)(
    IN USHORT ProcessorID,
    IN UCHAR  HardwareVector
    );

typedef
NTSTATUS
(*HALRESERVECROSSPARTITIONINTERRUPTVECTOR)(
    OUT PULONG Vector,
    OUT PKIRQL Irql,
    IN OUT PKAFFINITY Affinity,
    OUT PUCHAR HardwareVector
    );

typedef struct _HAL_CROSS_PARTITION_IPI_INTERFACE {
    HALSENDCROSSPARTITIONIPI HalSendCrossPartitionIpi;
    HALRESERVECROSSPARTITIONINTERRUPTVECTOR HalReserveCrossPartitionInterruptVector;
} HAL_CROSS_PARTITION_IPI_INTERFACE;

#endif

typedef struct _HAL_PLATFORM_INFORMATION {
    ULONG PlatformFlags;
} HAL_PLATFORM_INFORMATION, *PHAL_PLATFORM_INFORMATION;

//
// These platform flags are carried over from the IPPT table
// definition if appropriate.
//

#define HAL_PLATFORM_DISABLE_PTCG            0x04L
#define HAL_PLATFORM_DISABLE_UC_MAIN_MEMORY  0x08L


//  begin_wdm begin_ntndis begin_ntosp

typedef struct _SCATTER_GATHER_ELEMENT {
    PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG_PTR Reserved;
} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

#pragma warning(disable:4200)
typedef struct _SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    SCATTER_GATHER_ELEMENT Elements[];
} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;
#pragma warning(default:4200)

// end_ntndis

typedef struct _DMA_OPERATIONS *PDMA_OPERATIONS;

typedef struct _DMA_ADAPTER {
    USHORT Version;
    USHORT Size;
    PDMA_OPERATIONS DmaOperations;
    // Private Bus Device Driver data follows,
} DMA_ADAPTER, *PDMA_ADAPTER;

typedef VOID (*PPUT_DMA_ADAPTER)(
    PDMA_ADAPTER DmaAdapter
    );

typedef PVOID (*PALLOCATE_COMMON_BUFFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

typedef VOID (*PFREE_COMMON_BUFFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

typedef NTSTATUS (*PALLOCATE_ADAPTER_CHANNEL)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

typedef BOOLEAN (*PFLUSH_ADAPTER_BUFFERS)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

typedef VOID (*PFREE_ADAPTER_CHANNEL)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef VOID (*PFREE_MAP_REGISTERS)(
    IN PDMA_ADAPTER DmaAdapter,
    PVOID MapRegisterBase,
    ULONG NumberOfMapRegisters
    );

typedef PHYSICAL_ADDRESS (*PMAP_TRANSFER)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );

typedef ULONG (*PGET_DMA_ALIGNMENT)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef ULONG (*PREAD_DMA_COUNTER)(
    IN PDMA_ADAPTER DmaAdapter
    );

typedef VOID
(*PDRIVER_LIST_CONTROL)(
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    );

typedef NTSTATUS
(*PGET_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

typedef VOID
(*PPUT_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    );

typedef NTSTATUS
(*PCALCULATE_SCATTER_GATHER_LIST_SIZE)(
     IN PDMA_ADAPTER DmaAdapter,
     IN OPTIONAL PMDL Mdl,
     IN PVOID CurrentVa,
     IN ULONG Length,
     OUT PULONG  ScatterGatherListSize,
     OUT OPTIONAL PULONG pNumberOfMapRegisters
     );

typedef NTSTATUS
(*PBUILD_SCATTER_GATHER_LIST)(
     IN PDMA_ADAPTER DmaAdapter,
     IN PDEVICE_OBJECT DeviceObject,
     IN PMDL Mdl,
     IN PVOID CurrentVa,
     IN ULONG Length,
     IN PDRIVER_LIST_CONTROL ExecutionRoutine,
     IN PVOID Context,
     IN BOOLEAN WriteToDevice,
     IN PVOID   ScatterGatherBuffer,
     IN ULONG   ScatterGatherLength
     );

typedef NTSTATUS
(*PBUILD_MDL_FROM_SCATTER_GATHER_LIST)(
    IN PDMA_ADAPTER DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    );

typedef struct _DMA_OPERATIONS {
    ULONG Size;
    PPUT_DMA_ADAPTER PutDmaAdapter;
    PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
    PFREE_COMMON_BUFFER FreeCommonBuffer;
    PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel;
    PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers;
    PFREE_ADAPTER_CHANNEL FreeAdapterChannel;
    PFREE_MAP_REGISTERS FreeMapRegisters;
    PMAP_TRANSFER MapTransfer;
    PGET_DMA_ALIGNMENT GetDmaAlignment;
    PREAD_DMA_COUNTER ReadDmaCounter;
    PGET_SCATTER_GATHER_LIST GetScatterGatherList;
    PPUT_SCATTER_GATHER_LIST PutScatterGatherList;
    PCALCULATE_SCATTER_GATHER_LIST_SIZE CalculateScatterGatherList;
    PBUILD_SCATTER_GATHER_LIST BuildScatterGatherList;
    PBUILD_MDL_FROM_SCATTER_GATHER_LIST BuildMdlFromScatterGatherList;
} DMA_OPERATIONS;

// end_wdm


#if defined(_WIN64)

//
// Use __inline DMA macros (hal.h)
//
#ifndef USE_DMA_MACROS
#define USE_DMA_MACROS
#endif

//
// Only PnP drivers!
//
#ifndef NO_LEGACY_DRIVERS
#define NO_LEGACY_DRIVERS
#endif

#endif // _WIN64


#if defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_))

// begin_wdm

DECLSPEC_DEPRECATED_DDK                 // Use AllocateCommonBuffer
FORCEINLINE
PVOID
HalAllocateCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    ){

    PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
    PVOID commonBuffer;

    allocateCommonBuffer = *(DmaAdapter)->DmaOperations->AllocateCommonBuffer;
    ASSERT( allocateCommonBuffer != NULL );

    commonBuffer = allocateCommonBuffer( DmaAdapter,
                                         Length,
                                         LogicalAddress,
                                         CacheEnabled );

    return commonBuffer;
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeCommonBuffer
FORCEINLINE
VOID
HalFreeCommonBuffer(
    IN PDMA_ADAPTER DmaAdapter,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    ){

    PFREE_COMMON_BUFFER freeCommonBuffer;

    freeCommonBuffer = *(DmaAdapter)->DmaOperations->FreeCommonBuffer;
    ASSERT( freeCommonBuffer != NULL );

    freeCommonBuffer( DmaAdapter,
                      Length,
                      LogicalAddress,
                      VirtualAddress,
                      CacheEnabled );
}

DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
FORCEINLINE
NTSTATUS
IoAllocateAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    ){

    PALLOCATE_ADAPTER_CHANNEL allocateAdapterChannel;
    NTSTATUS status;

    allocateAdapterChannel =
        *(DmaAdapter)->DmaOperations->AllocateAdapterChannel;

    ASSERT( allocateAdapterChannel != NULL );

    status = allocateAdapterChannel( DmaAdapter,
                                     DeviceObject,
                                     NumberOfMapRegisters,
                                     ExecutionRoutine,
                                     Context );

    return status;
}

DECLSPEC_DEPRECATED_DDK                 // Use FlushAdapterBuffers
FORCEINLINE
BOOLEAN
IoFlushAdapterBuffers(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    ){

    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers;
    BOOLEAN result;

    flushAdapterBuffers = *(DmaAdapter)->DmaOperations->FlushAdapterBuffers;
    ASSERT( flushAdapterBuffers != NULL );

    result = flushAdapterBuffers( DmaAdapter,
                                  Mdl,
                                  MapRegisterBase,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice );
    return result;
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeAdapterChannel
FORCEINLINE
VOID
IoFreeAdapterChannel(
    IN PDMA_ADAPTER DmaAdapter
    ){

    PFREE_ADAPTER_CHANNEL freeAdapterChannel;

    freeAdapterChannel = *(DmaAdapter)->DmaOperations->FreeAdapterChannel;
    ASSERT( freeAdapterChannel != NULL );

    freeAdapterChannel( DmaAdapter );
}

DECLSPEC_DEPRECATED_DDK                 // Use FreeMapRegisters
FORCEINLINE
VOID
IoFreeMapRegisters(
    IN PDMA_ADAPTER DmaAdapter,
    IN PVOID MapRegisterBase,
    IN ULONG NumberOfMapRegisters
    ){

    PFREE_MAP_REGISTERS freeMapRegisters;

    freeMapRegisters = *(DmaAdapter)->DmaOperations->FreeMapRegisters;
    ASSERT( freeMapRegisters != NULL );

    freeMapRegisters( DmaAdapter,
                      MapRegisterBase,
                      NumberOfMapRegisters );
}


DECLSPEC_DEPRECATED_DDK                 // Use MapTransfer
FORCEINLINE
PHYSICAL_ADDRESS
IoMapTransfer(
    IN PDMA_ADAPTER DmaAdapter,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    ){

    PHYSICAL_ADDRESS physicalAddress;
    PMAP_TRANSFER mapTransfer;

    mapTransfer = *(DmaAdapter)->DmaOperations->MapTransfer;
    ASSERT( mapTransfer != NULL );

    physicalAddress = mapTransfer( DmaAdapter,
                                   Mdl,
                                   MapRegisterBase,
                                   CurrentVa,
                                   Length,
                                   WriteToDevice );

    return physicalAddress;
}

DECLSPEC_DEPRECATED_DDK                 // Use GetDmaAlignment
FORCEINLINE
ULONG
HalGetDmaAlignment(
    IN PDMA_ADAPTER DmaAdapter
    )
{
    PGET_DMA_ALIGNMENT getDmaAlignment;
    ULONG alignment;

    getDmaAlignment = *(DmaAdapter)->DmaOperations->GetDmaAlignment;
    ASSERT( getDmaAlignment != NULL );

    alignment = getDmaAlignment( DmaAdapter );
    return alignment;
}

DECLSPEC_DEPRECATED_DDK                 // Use ReadDmaCounter
FORCEINLINE
ULONG
HalReadDmaCounter(
    IN PDMA_ADAPTER DmaAdapter
    )
{
    PREAD_DMA_COUNTER readDmaCounter;
    ULONG counter;

    readDmaCounter = *(DmaAdapter)->DmaOperations->ReadDmaCounter;
    ASSERT( readDmaCounter != NULL );

    counter = readDmaCounter( DmaAdapter );
    return counter;
}

// end_wdm

#else

//
// DMA adapter object functions.
//
NTHALAPI
NTSTATUS
HalAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine
    );

DECLSPEC_DEPRECATED_DDK                 // Use AllocateCommonBuffer
NTHALAPI
PVOID
HalAllocateCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

DECLSPEC_DEPRECATED_DDK                 // Use FreeCommonBuffer
NTHALAPI
VOID
HalFreeCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

DECLSPEC_DEPRECATED_DDK                 // Use ReadDmaCounter
NTHALAPI
ULONG
HalReadDmaCounter(
    IN PADAPTER_OBJECT AdapterObject
    );

DECLSPEC_DEPRECATED_DDK                 // Use FlushAdapterBuffers
NTHALAPI
BOOLEAN
IoFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

DECLSPEC_DEPRECATED_DDK                 // Use FreeAdapterChannel
NTHALAPI
VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    );

DECLSPEC_DEPRECATED_DDK                 // Use FreeMapRegisters
NTHALAPI
VOID
IoFreeMapRegisters(
   IN PADAPTER_OBJECT AdapterObject,
   IN PVOID MapRegisterBase,
   IN ULONG NumberOfMapRegisters
   );

DECLSPEC_DEPRECATED_DDK                 // Use MapTransfer
NTHALAPI
PHYSICAL_ADDRESS
IoMapTransfer(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    );
#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_)

NTSTATUS
HalGetScatterGatherList (
    IN PADAPTER_OBJECT DmaAdapter,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    );

VOID
HalPutScatterGatherList (
    IN PADAPTER_OBJECT DmaAdapter,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    );

VOID
HalPutDmaAdapter(
    IN PADAPTER_OBJECT DmaAdapter
    );

// end_ntddk end_ntosp

#endif // _HAL_

// end_nthal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\halalpha.h ===
#if defined(_AXP64_)
#include "halpaxp64.h"
#else
#include "halpalpha.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\fwcallbk.h ===
/*++

Copyright (c) 1993  Digital Equipment Corporation

Module Name:

    fwcallbk.h

Abstract:

    This module defines the firmware vendor vector callbacks that
    will be implemented on all Alpha AXP platforms.

Author:

    John DeRosa	[DEC]	10-December-1993

Revision History:

    14-July-1994	John DeRosa [DEC]

    Added definitions for GetBusDataByOffset and SetBusDataByOffset.

--*/

#ifndef _FWCALLBK_
#define _FWCALLBK_

//
// This module contains typedefs, which are not parsable by the assembler.
//

#ifndef _LANGUAGE_ASSEMBLY

#include "arc.h"

//
// Define the structure used to pass information to the
// ECU, and other ARC applications.
//

typedef struct _ARC_INFORMATION {

    //
    // The version number of this structure definition.
    //

    ULONG Version;

    //
    // A pointer to an argv-like array.  Each entry is a search path
    // string.
    //
    // This is used to pass to the ECU a list of directories to search
    // through for configuration files.  The definition passed back to
    // the ECU depends on both the platform it is running on and the
    // operating system selection in effect at the time that the call
    // to VenReturnArcInformation is made.
    //
    // Rules:
    //
    //  1. The end of the search list is marked with a NULL.
    //  2. Each entry must be a subset of a valid FAT filesystem.
    //  3. Each entry must start with "\\".
    //  4. Each entry must end with an ECU configuration file
    //     prefix character.  (Currently, we use ! and A.)
    //
    // It is possible that other configuration utilities might want to
    // use this search path someday.
    //

    PUCHAR * SearchPath;

    PUCHAR Reserved1;
    PUCHAR Reserved2;
    PUCHAR Reserved3;
    PUCHAR Reserved4;

} ARC_INFORMATION, *PARC_INFORMATION;

#define ARC_INFORMATION_VERSION     0

//
// Structure used to return system and processor information.
//

typedef struct _EXTENDED_SYSTEM_INFORMATION {
    ULONG   ProcessorId;
    ULONG   ProcessorRevision;
    ULONG   ProcessorPageSize;
    ULONG   NumberOfPhysicalAddressBits;
    ULONG   MaximumAddressSpaceNumber;
    ULONG   ProcessorCycleCounterPeriod;
    ULONG   SystemRevision;
    UCHAR   SystemSerialNumber[16];
    UCHAR   FirmwareVersion[16];
    UCHAR   FirmwareBuildTimeStamp[12];   // yymmdd.hhmm (Available as of 5.10)
} EXTENDED_SYSTEM_INFORMATION, *PEXTENDED_SYSTEM_INFORMATION;

//
// Define structure used to call BIOS emulator.  This mimics the
// VIDEO_X86_BIOS_ARGUMENTS typedef in \nt\private\ntos\inc\video.h.
//

typedef struct X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} X86_BIOS_ARGUMENTS, *PX86_BIOS_ARGUMENTS;

//
// Define the firmware vendor specific entry point numbers that are
// common to all Alpha AXP platforms.
//

typedef enum _VENDOR_GENERIC_ENTRY {
    AllocatePoolRoutine,
    StallExecutionRoutine,
    PrintRoutine,
    ReturnExtendedSystemInformationRoutine,
    VideoDisplayInitializeRoutine,
    EISAReadRegisterBufferUCHARRoutine,
    EISAWriteRegisterBufferUCHARRoutine,
    EISAReadPortUCHARRoutine,
    EISAReadPortUSHORTRoutine,
    EISAReadPortULONGRoutine,
    EISAWritePortUCHARRoutine,
    EISAWritePortUSHORTRoutine,
    EISAWritePortULONGRoutine,
    FreePoolRoutine,
    CallBiosRoutine,
    TranslateBusAddressRoutine,
    ReadPortUCHARRoutine,
    ReadPortUSHORTRoutine,
    ReadPortULONGRoutine,
    WritePortUCHARRoutine,
    WritePortUSHORTRoutine,
    WritePortULONGRoutine,
    ReadRegisterUCHARRoutine,
    ReadRegisterUSHORTRoutine,
    ReadRegisterULONGRoutine,
    WriteRegisterUCHARRoutine,
    WriteRegisterUSHORTRoutine,
    WriteRegisterULONGRoutine,
    GetBusDataByOffsetRoutine,
    SetBusDataByOffsetRoutine,
    WidePrintRoutine,
    ReturnLanguageIdRoutine,
    GetAdapterRoutine,
    AllocateCommonBufferRoutine,
    FreeCommonBufferRoutine,
    ReturnArcInformationRoutine,
    IssueSrbDirectRoutine,
    ReservedRoutine0,
    ReadWriteErrorFrameRoutine,
    MaximumVendorRoutine
    } VENDOR_GENERIC_ENTRY;

//
// Define vendor specific routine types.
//

typedef
PVOID
(*PVEN_ALLOCATE_POOL_ROUTINE) (
    IN ULONG NumberOfBytes
    );

typedef
VOID
(*PVEN_STALL_EXECUTION_ROUTINE) (
    IN ULONG Microseconds
    );

typedef
ULONG
(*PVEN_PRINT_ROUTINE) (
    IN PCHAR Format,
    ...
    );

typedef
ULONG
(*PVEN_WIDE_PRINT_ROUTINE) (
    IN PWCHAR Format,
    ...
    );

typedef
LONG
(*PVEN_RETURN_LANGUAGE_ID_ROUTINE) (
    IN VOID
    );

typedef
VOID
(*PVEN_RETURN_EXTENDED_SYSTEM_INFORMATION_ROUTINE) (
    OUT PEXTENDED_SYSTEM_INFORMATION SystemInfo
    );

typedef
ARC_STATUS
(*PVEN_VIDEO_DISPLAY_INITIALIZE_ROUTINE) (
    OUT PVOID UnusedParameter
    );

typedef
ULONG
(*PVEN_EISA_READ_REGISTER_BUFFER_UCHAR_ROUTINE) (
    IN ULONG BusNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG Length
    );

typedef
ULONG
(*PVEN_EISA_WRITE_REGISTER_BUFFER_UCHAR_ROUTINE) (
    IN ULONG BusNumber,
    IN ULONG Offset,
    OUT PVOID Buffer,
    IN ULONG Length
    );

typedef
UCHAR
(*PVEN_EISA_READ_PORT_UCHAR_ROUTINE) (
    IN ULONG BusNumber,
    IN ULONG Offset
    );

typedef
USHORT
(*PVEN_EISA_READ_PORT_USHORT_ROUTINE) (
    IN ULONG BusNumber,
    IN ULONG Offset
    );

typedef
ULONG
(*PVEN_EISA_READ_PORT_ULONG_ROUTINE) (
    IN ULONG BusNumber,
    IN ULONG Offset
    );

typedef
VOID
(*PVEN_EISA_WRITE_PORT_UCHAR_ROUTINE) (
    IN ULONG BusNumber,
    IN ULONG Offset,
    IN UCHAR Datum
    );

typedef
VOID
(*PVEN_EISA_WRITE_PORT_USHORT_ROUTINE) (
    IN ULONG BusNumber,
    IN ULONG Offset,
    IN USHORT Datum
    );

typedef
VOID
(*PVEN_EISA_WRITE_PORT_ULONG_ROUTINE) (
    IN ULONG BusNumber,
    IN ULONG Offset,
    IN ULONG Datum
    );

typedef
VOID
(*PVEN_FREE_POOL_ROUTINE) (
    IN PVOID MemoryPointer
    );

typedef
VOID
(*PVEN_CALL_BIOS_ROUTINE) (
    IN ULONG InterruptNumber,
    IN OUT PX86_BIOS_ARGUMENTS BiosArguments
    );

typedef
BOOLEAN
(*PVEN_TRANSLATE_BUS_ADDRESS_ROUTINE) (
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

typedef
UCHAR
(*PVEN_READ_PORT_UCHAR_ROUTINE) (
    PUCHAR Port
    );

typedef
USHORT
(*PVEN_READ_PORT_USHORT_ROUTINE) (
    PUSHORT Port
    );

typedef
ULONG
(*PVEN_READ_PORT_ULONG_ROUTINE) (
    PULONG Port
    );

typedef
VOID
(*PVEN_WRITE_PORT_UCHAR_ROUTINE) (
    PUCHAR Port,
    UCHAR   Value
    );

typedef
VOID
(*PVEN_WRITE_PORT_USHORT_ROUTINE) (
    PUSHORT Port,
    USHORT  Value
    );

typedef
VOID
(*PVEN_WRITE_PORT_ULONG_ROUTINE) (
    PULONG Port,
    ULONG   Value
    );

typedef
UCHAR
(*PVEN_READ_REGISTER_UCHAR_ROUTINE) (
    PUCHAR Register
    );

typedef
USHORT
(*PVEN_READ_REGISTER_USHORT_ROUTINE) (
    PUSHORT Register
    );

typedef
ULONG
(*PVEN_READ_REGISTER_ULONG_ROUTINE) (
    PULONG Register
    );

typedef
VOID
(*PVEN_WRITE_REGISTER_UCHAR_ROUTINE) (
    PUCHAR Register,
    UCHAR   Value
    );

typedef
VOID
(*PVEN_WRITE_REGISTER_USHORT_ROUTINE) (
    PUSHORT Register,
    USHORT  Value
    );

typedef
VOID
(*PVEN_WRITE_REGISTER_ULONG_ROUTINE) (
    PULONG Register,
    ULONG   Value
    );

typedef
ULONG
(*PVEN_GET_BUS_DATA_BY_OFFSET_ROUTINE) (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef
ULONG
(*PVEN_SET_BUS_DATA_BY_OFFSET_ROUTINE) (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

typedef
PADAPTER_OBJECT
(*PVEN_GET_ADAPTER_ROUTINE) (
    IN PDEVICE_DESCRIPTION DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    );

typedef
PVOID
(*PVEN_ALLOCATE_COMMON_BUFFER_ROUTINE) (
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    );

typedef
VOID
(*PVEN_FREE_COMMON_BUFFER_ROUTINE) (
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    );

typedef
ARC_STATUS
(*PVEN_RETURN_ARC_INFORMATION_ROUTINE) (
    OUT PARC_INFORMATION ArcInformation
    );

typedef
ARC_STATUS
(*PVEN_ISSUE_SRB_DIRECT_ROUTINE) (
    UCHAR ScsiAdapterId,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR LunId,
    PVOID Srb,
    PVOID BufferAddress,
    ULONG BufferLength,
    BOOLEAN WriteToDevice
    );

typedef
ARC_STATUS
(*PVEN_READ_WRITE_ERROR_FRAME_ROUTINE) (
    ULONG ReadWrite,
    ULONG FrameType,
    PVOID FrameAddress,
    PLONG FrameSize,
    ULONG FrameNumber
    );

//
// Define the stub function prototypes necessary to interface with the
// 32-bit firmware on 64-bit systems.
//
// These routines are required for the 64-bit system until (if) 64-bit
// firmware is ever supplied.
//

#if defined(_AXP64_) && defined(_NTHAL_)

VOID
HalpVenCallBios(
   IN ULONG InterruptNumber,
   IN OUT PX86_BIOS_ARGUMENTS BiosArguments
   );

ARC_STATUS
HalpVenReadWriteErrorFrame(
    IN ULONG ReadWrite,
    IN ULONG FrameType,
    IN OUT PVOID FrameAddress,
    IN OUT PLONG FrameSize,
    IN ULONG FrameNumber
    );

VOID
HalpVenVideoDisplayInitialize(
   OUT PVOID UnusedParameter
   );

#endif

//
// Define vendor specific macros for use by programs that run on
// Alpha AXP NT firmware.
//
// These calls are guaranteed to return legitimate values.  If a function
// is not defined for a particular platform, it will return with an error
// code or just return normally, as appropriate.
//

#define VenAllocatePool(NumberOfBytes) \
    ((PVEN_ALLOCATE_POOL_ROUTINE)(SYSTEM_BLOCK->VendorVector[AllocatePoolRoutine])) \
        ((NumberOfBytes))

#define VenStallExecution(Microseconds) \
    ((PVEN_STALL_EXECUTION_ROUTINE)(SYSTEM_BLOCK->VendorVector[StallExecutionRoutine])) \
        ((Microseconds))

#define VenReturnLanguageId \
     ((PVEN_RETURN_LANGUAGE_ID_ROUTINE)(SYSTEM_BLOCK->VendorVector[ReturnLanguageIdRoutine]))

#define VenWPrint \
    ((PVEN_WIDE_PRINT_ROUTINE)(SYSTEM_BLOCK->VendorVector[WidePrintRoutine]))

#define VenPrint \
    ((PVEN_PRINT_ROUTINE)(SYSTEM_BLOCK->VendorVector[PrintRoutine]))

//
// N.B. VenPrint1 and VenPrint2 are retained here for backwards compatibility.
//

#define VenPrint1 VenPrint
#define VenPrint2 VenPrint

#define VenReturnExtendedSystemInformation(x) \
    ((PVEN_RETURN_EXTENDED_SYSTEM_INFORMATION_ROUTINE)(SYSTEM_BLOCK->VendorVector[ReturnExtendedSystemInformationRoutine]))(x)

#if defined(_AXP64_) && defined(_NTHAL_)

__inline
VOID
VenVideoDisplayInitialize(
    OUT PVOID UnusedParameter
    )

{
    KIRQL OldIrql = FwAcquireFirmwareLock();
    HalpVenVideoDisplayInitialize(UnusedParameter);
    FwReleaseFirmwareLock(OldIrql);
    return;
}

#else

#define VenVideoDisplayInitialize(x) \
    ((PVEN_VIDEO_DISPLAY_INITIALIZE_ROUTINE)(SYSTEM_BLOCK->VendorVector[VideoDisplayInitializeRoutine]))(x)

#endif

#define VenEISAReadRegisterBufferUCHAR(BusNumber, Offset, Buffer, Length) \
    ((PVEN_EISA_READ_REGISTER_BUFFER_UCHAR_ROUTINE)(SYSTEM_BLOCK->VendorVector[EISAReadRegisterBufferUCHARRoutine])) \
	((BusNumber), (Offset), (Buffer), (Length))

#define VenEISAWriteRegisterBufferUCHAR(BusNumber, Offset, Buffer, Length) \
    ((PVEN_EISA_WRITE_REGISTER_BUFFER_UCHAR_ROUTINE)(SYSTEM_BLOCK->VendorVector[EISAWriteRegisterBufferUCHARRoutine])) \
	((BusNumber), (Offset), (Buffer), (Length))

#define VenEISAReadPortUCHAR(BusNumber, Offset) \
    ((PVEN_EISA_READ_PORT_UCHAR_ROUTINE)(SYSTEM_BLOCK->VendorVector[EISAReadPortUCHARRoutine])) \
	((BusNumber), (Offset))

#define VenEISAReadPortUSHORT(BusNumber, Offset) \
    ((PVEN_EISA_READ_PORT_USHORT_ROUTINE)(SYSTEM_BLOCK->VendorVector[EISAReadPortUSHORTRoutine])) \
	((BusNumber), (Offset))

#define VenEISAReadPortULONG(BusNumber, Offset) \
    ((PVEN_EISA_READ_PORT_ULONG_ROUTINE)(SYSTEM_BLOCK->VendorVector[EISAReadPortULONGRoutine])) \
	((BusNumber), (Offset))

#define VenEISAWritePortUCHAR(BusNumber, Offset, Datum) \
    ((PVEN_EISA_WRITE_PORT_UCHAR_ROUTINE)(SYSTEM_BLOCK->VendorVector[EISAWritePortUCHARRoutine])) \
	((BusNumber), (Offset), (Datum))

#define VenEISAWritePortUSHORT(BusNumber, Offset, Datum) \
    ((PVEN_EISA_WRITE_PORT_USHORT_ROUTINE)(SYSTEM_BLOCK->VendorVector[EISAWritePortUSHORTRoutine])) \
	((BusNumber), (Offset), (Datum))

#define VenEISAWritePortULONG(BusNumber, Offset, Datum) \
    ((PVEN_EISA_WRITE_PORT_ULONG_ROUTINE)(SYSTEM_BLOCK->VendorVector[EISAWritePortULONGRoutine])) \
	((BusNumber), (Offset), (Datum))

#define VenFreePool(MemoryPointer) \
    ((PVEN_FREE_POOL_ROUTINE)(SYSTEM_BLOCK->VendorVector[FreePoolRoutine])) \
        ((MemoryPointer))

#if defined(_AXP64_) && defined(_NTHAL_)

__inline
VOID
VenCallBios(
    IN ULONG InterruptNumber,
    IN OUT PX86_BIOS_ARGUMENTS BiosArguments
    )

{
    KIRQL OldIrql = FwAcquireFirmwareLock();
    HalpVenCallBios(InterruptNumber, BiosArguments);
    FwReleaseFirmwareLock(OldIrql);
    return;
}

#else

#define VenCallBios(InterruptNumber, BiosArguments) \
    ((PVEN_CALL_BIOS_ROUTINE)(SYSTEM_BLOCK->VendorVector[CallBiosRoutine])) \
        ((InterruptNumber), (BiosArguments))
#endif

#define VenTranslateBusAddress(InterfaceType, BusNumber, BusAddress, AddressSpace, TranslatedAddress) \
    ((PVEN_TRANSLATE_BUS_ADDRESS_ROUTINE)(SYSTEM_BLOCK->VendorVector[TranslateBusAddressRoutine])) \
        ((InterfaceType), (BusNumber), (BusAddress), (AddressSpace), (TranslatedAddress))

#define VenReadPortUCHAR(Port) \
    ((PVEN_READ_PORT_UCHAR_ROUTINE)(SYSTEM_BLOCK->VendorVector[ReadPortUCHARRoutine])) \
        ((Port))

#define VenReadPortUSHORT(Port) \
    ((PVEN_READ_PORT_USHORT_ROUTINE)(SYSTEM_BLOCK->VendorVector[ReadPortUSHORTRoutine])) \
        ((Port))

#define VenReadPortULONG(Port) \
    ((PVEN_READ_PORT_ULONG_ROUTINE)(SYSTEM_BLOCK->VendorVector[ReadPortULONGRoutine])) \
        ((Port))

#define VenWritePortUCHAR(Port, Value) \
    ((PVEN_WRITE_PORT_UCHAR_ROUTINE)(SYSTEM_BLOCK->VendorVector[WritePortUCHARRoutine])) \
        ((Port), (Value))

#define VenWritePortUSHORT(Port, Value) \
    ((PVEN_WRITE_PORT_USHORT_ROUTINE)(SYSTEM_BLOCK->VendorVector[WritePortUSHORTRoutine])) \
        ((Port), (Value))

#define VenWritePortULONG(Port, Value) \
    ((PVEN_WRITE_PORT_ULONG_ROUTINE)(SYSTEM_BLOCK->VendorVector[WritePortULONGRoutine])) \
        ((Port), (Value))

#define VenReadRegisterUCHAR(Register) \
    ((PVEN_READ_REGISTER_UCHAR_ROUTINE)(SYSTEM_BLOCK->VendorVector[ReadRegisterUCHARRoutine])) \
        ((Register))

#define VenReadRegisterUSHORT(Register) \
    ((PVEN_READ_REGISTER_USHORT_ROUTINE)(SYSTEM_BLOCK->VendorVector[ReadRegisterUSHORTRoutine])) \
        ((Register))

#define VenReadRegisterULONG(Register) \
    ((PVEN_READ_REGISTER_ULONG_ROUTINE)(SYSTEM_BLOCK->VendorVector[ReadRegisterULONGRoutine])) \
        ((Register))

#define VenWriteRegisterUCHAR(Register, Value) \
    ((PVEN_WRITE_REGISTER_UCHAR_ROUTINE)(SYSTEM_BLOCK->VendorVector[WriteRegisterUCHARRoutine])) \
        ((Register), (Value))

#define VenWriteRegisterUSHORT(Register, Value) \
    ((PVEN_WRITE_REGISTER_USHORT_ROUTINE)(SYSTEM_BLOCK->VendorVector[WriteRegisterUSHORTRoutine])) \
        ((Register), (Value))

#define VenWriteRegisterULONG(Register, Value) \
    ((PVEN_WRITE_REGISTER_ULONG_ROUTINE)(SYSTEM_BLOCK->VendorVector[WriteRegisterULONGRoutine])) \
      ((Register), (Value))

#define VenGetBusDataByOffset(BusDataType, BusNumber, SlotNumber, Buffer, Offset, Length) \
    ((PVEN_GET_BUS_DATA_BY_OFFSET_ROUTINE)(SYSTEM_BLOCK->VendorVector[GetBusDataByOffsetRoutine])) \
      ((BusDataType), (BusNumber), (SlotNumber), (Buffer), (Offset), (Length))

#define VenSetBusDataByOffset(BusDataType, BusNumber, SlotNumber, Buffer, Offset, Length) \
    ((PVEN_SET_BUS_DATA_BY_OFFSET_ROUTINE)(SYSTEM_BLOCK->VendorVector[SetBusDataByOffsetRoutine])) \
      ((BusDataType), (BusNumber), (SlotNumber), (Buffer), (Offset), (Length))

#define VenGetAdapter(DeviceDescription, NumberOfMapRegisters) \
    ((PVEN_GET_ADAPTER_ROUTINE)(SYSTEM_BLOCK->VendorVector[GetAdapterRoutine])) \
      ((DeviceDescription), (NumberOfMapRegisters))

#define VenAllocateCommonBuffer(AdapterObject, Length, LogicalAddress, CacheEnabled) \
    ((PVEN_ALLOCATE_COMMON_BUFFER_ROUTINE)(SYSTEM_BLOCK->VendorVector[AllocateCommonBufferRoutine])) \
      ((AdapterObject), (Length), (LogicalAddress), (CacheEnabled))

#define VenFreeCommonBuffer(AdapterObject, Length, LogicalAddress, VirtualAddress, CacheEnabled) \
    ((PVEN_FREE_COMMON_BUFFER_ROUTINE)(SYSTEM_BLOCK->VendorVector[FreeCommonBufferRoutine])) \
      ((AdapterObject), (Length), (LogicalAddress), (VirtualAddress), (CacheEnabled))

#define VenReturnArcInformation(ArcInfo) \
    ((PVEN_RETURN_ARC_INFORMATION_ROUTINE)(SYSTEM_BLOCK->VendorVector[ReturnArcInformationRoutine])) \
      ((ArcInfo))

#define VenIssueSrbDirect(ScsiAdapterId, PathId, TargetId, LunId, Srb, BufferAddress, BufferLength, WriteToDevice) \
    ((PVEN_ISSUE_SRB_DIRECT_ROUTINE)(SYSTEM_BLOCK->VendorVector[IssueSrbDirectRoutine])) \
      ((ScsiAdapterId), (PathId), (TargetId), (LunId), (Srb), (BufferAddress), (BufferLength), (WriteToDevice))

//
// As we are extending the vendor array here. Let's check the AlphaBIOS
// has set the CDS tree up to support th extension. If not, don't do the call.
//

//
// Define the params used for the Error Logging callbacks.
//

typedef enum _VENDOR_READWRITE_TYPE {
   ReadFrame = 1,
   WriteFrame
} VENDOR_READWRITE_TYPE;

typedef enum _VENDOR_READWRITE_FRAMETYPE {
   FatalErrorFrame = 1,
   DoubleErrorFrame,
   FRUErrorFrame
} VENDOR_READWRITE_FRAMETYPE;

#if defined(_AXP64_) && defined(_NTHAL_)

__inline
ARC_STATUS
VenReadWriteErrorFrame(
    IN ULONG ReadWrite,
    IN ULONG FrameType,
    IN OUT PVOID FrameAddress,
    IN OUT PLONG FrameSize,
    IN ULONG FrameNumber
    )

{

    ARC_STATUS Status;

    KIRQL OldIrql = FwAcquireFirmwareLock();
    Status = HalpVenReadWriteErrorFrame(ReadWrite,
                                        FrameType,
                                        FrameAddress,
                                        FrameSize,
                                        FrameNumber);

    FwReleaseFirmwareLock(OldIrql);
    return Status;
}

#else

#define VenReadWriteErrorFrame(ReadWrite, Frametype, FrameAddress, FrameSizeAddress, FrameNumber) \
    (SYSTEM_BLOCK->VendorVectorLength > (ReadWriteErrorFrameRoutine * sizeof(SYSTEM_BLOCK->VendorVector[0])) ? \
    ((PVEN_READ_WRITE_ERROR_FRAME_ROUTINE)(SYSTEM_BLOCK->VendorVector[ReadWriteErrorFrameRoutine])) \
     ((ReadWrite), (Frametype), (FrameAddress), (FrameSizeAddress), (FrameNumber)) : \
      (EINVAL))  // Return bad status if vector not present.

#endif

#endif // _LANGUAGE_ASSEMBLY not defined

#endif // _FWCALLBK_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\heappage.h ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappage.h

Abstract:

    External interface for page heap manager.
    
Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
#define DEBUG_PAGE_HEAP 1
#endif

//silviuc: #include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others. It can be changed on the fly (after heap creation) to direct
//     allocations in one heap or another.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the N/A page at the beginning of the block.
//
// PAGE_HEAP_UNALIGNED_ALLOCATIONS
//
//     For historical reasons (related to RPC) by default page heap
//     aligns allocations at 8 byte boundaries. With this flag set
//     this does not happen and we can catch instantly off by one
//     errors for unaligned allocations.
//
// PAGE_HEAP_SMART_MEMORY_USAGE
//
//     This flag reduces the committed memory consumption in half
//     by using decommitted ranges (reserved virtual space) instead
//     of N/A committed pages. This flag is disabled by catch backward
//     overruns.
//
// PAGE_HEAP_USE_SIZE_RANGE
//
//     Use page heap for allocations in the size range specified by:
//     RtlpDphSizeRangeStart..RtlpDphSizeRangeEnd.
//
// PAGE_HEAP_USE_DLL_RANGE
//
//     Use page heap for allocations in the address range specified by:
//     RtlpDphDllRangeStart..RtlpDphDllRangeEnd. If the stack trace
//     of the allocation contains one address in this range then
//     allocation will be made from page heap.
//
// PAGE_HEAP_USE_RANDOM_DECISION
//
//     Use page heap if we randomly decide so.
//
// PAGE_HEAP_USE_DLL_NAMES
//
//     Use page heap if allocation call was generated from on of the
//     target dlls.
//
// PAGE_HEAP_USE_FAULT_INJECTION
//
//     Fault inject heap allocation calls based on a simple 
//     probabilistic model (see FaultProbability and FaultTimeOut).
//
// PAGE_HEAP_PROTECT_META_DATA
//
//     Keep page heap metadata read only if we are not executing inside
//     the page heap code.
//
// PAGE_CHECK_NO_SERIALIZE_ACCESS
//
//     Additional checks for multi-threaded access for no_serialize
//     heaps. This flag can trigger false positives in MPheap. It needs
//     to be used only on processes that do not use MPheap-like heaps.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_RESERVED_04               0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400
#define PAGE_HEAP_USE_FAULT_INJECTION       0x0800
#define PAGE_HEAP_PROTECT_META_DATA         0x1000
#define PAGE_HEAP_CHECK_NO_SERIALIZE_ACCESS 0x2000
#define PAGE_HEAP_NO_LOCK_CHECKS            0x4000

//
// Is page heap enabled for this process?
//

extern BOOLEAN RtlpDebugPageHeap;

//
// `RtlpDphGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation. This variable 
// might get its value from the `PageHeap' ImageFileOptions
// registry key. 
//

extern ULONG RtlpDphGlobalFlags;

//
// Page heap global flags. They might be read from the
// `ImageFileOptions' registry key.
//

extern ULONG RtlpDphSizeRangeStart;
extern ULONG RtlpDphSizeRangeEnd;
extern ULONG RtlpDphDllRangeStart;
extern ULONG RtlpDphDllRangeEnd;
extern ULONG RtlpDphRandomProbability;
extern WCHAR RtlpDphTargetDlls[];

//
// If not zero controls the probability with which
// allocations will be failed on purpose by page heap
// manager. Timeout represents the initial period during
// process initialization when faults are not allowed.
//

extern ULONG RtlpDphFaultProbability;
extern ULONG RtlpDphFaultTimeOut;

//
// Stuff needed for per dll logic implemented in the loader
//

const WCHAR *
RtlpDphIsDllTargeted (
    const WCHAR * Name
    );

VOID
RtlpDphTargetDllsLoadCallBack (
    PUNICODE_STRING Name,
    PVOID Address,
    ULONG Size
    );

//
// Functions needed to turn on/off fault injection.
// They are needed in the loader so that allocations
// succeed while in LdrLoadDll code path.
//

VOID
RtlpDphDisableFaultInjection (
    );

VOID
RtlpDphEnableFaultInjection (
    );

#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\halpnpp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1998  Microsoft Corporation

Module Name:

    halpnpp.h

Abstract:

    Private interface from 'legacy' hal to 'PnP' class drivers that support
    new functionality

Author:

    Mike Gallop (mikeg) April, 1998

Revision History:

--*/


#define ISA_FTYPE_DMA_INTERFACE_VERSION 1
#define ISA_DMA_CHANNELS 8

typedef
NTSTATUS
(*PISA_CLAIM_FTYPE_CHANNEL)(
    IN PVOID Context,
    IN ULONG Channel,
    OUT PULONG ChannelInfo
    );

typedef
NTSTATUS
(*PISA_RELEASE_FTYPE_CHANNEL)(
    IN PVOID Context,
    IN ULONG Channel
    );

/*++


Routine Description:

    This returns information about children to be enumerated by a multifunction
    driver.

Arguments:

    Context - Context from the ISA_FTYPE_DMA_INTERFACE

    Channel - Channel to try and set to F-Type DMA

    ChannelInfo - Result of the set. Returns the mask of channels set to F-Type

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NO_MORE_ENTRIES indicates that the are no more children to enumerate

--*/

typedef struct _ISA_FTYPE_DMA_INTERFACE {

    //
    // Generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    //
    //
    PISA_CLAIM_FTYPE_CHANNEL IsaSetFTypeChannel;
    PISA_RELEASE_FTYPE_CHANNEL IsaReleaseFTypeChannel;

} ISA_FTYPE_DMA_INTERFACE, *PISA_FTYPE_DMA_INTERFACE;



DEFINE_GUID(GUID_ISA_FDMA_INTERFACE,
            0xEFF58E88L, 0xCE6B, 0x11D1, 0x8B, 0xA8, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0);

DEFINE_GUID( GUID_FDMA_INTERFACE_PRIVATE,
            0x60526D5EL, 0xCF34, 0x11D1, 0x8B, 0xA8, 0x00, 0x00, 0xF8, 0x75, 0x71, 0xD0 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

typedef struct _HEAP_ENTRY {

#if !defined(_WIN64)
    union {
        struct {

            //
            //  This field gives the size of the current block in allocation
            //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
            //  equals the size in bytes).
            //
            //  Except if this is part of a virtual alloc block then this
            //  value is the difference between the commit size in the virtual
            //  alloc entry and the what the user asked for.
            //

            USHORT Size;

            //
            // This field gives the size of the previous block in allocation
            // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
            // equals the size of the previous block in bytes).
            //

            USHORT PreviousSize;
        };

        volatile PVOID SubSegment;
    };

#else
    
    USHORT Size;
    USHORT PreviousSize;

#endif

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    volatile UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

#if defined(_WIN64)
    volatile PVOID SubSegment;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
//  This block describes extra information that might be at the end of a
//  busy block.
//  Note: The heap code is assuming that:
//      sizeof( HEAP_ENTRY_EXTRA ) == sizeof( HEAP_ENTRY )
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently for free blocks these can be:
    //
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //

    UCHAR Flags;

    //
    // Two fields to encode the location of the bit in FreeListsInUse
    // array in HEAP_SEGMENT for blocks of this size.
    //

    UCHAR Index;
    UCHAR Mask;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //
    LIST_ENTRY FreeList;

#if defined(_WIN64)
    ULONGLONG Reserved1;
#endif

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
        ERESOURCE Resource;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    SIZE_T AlignRound;
    SIZE_T AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    union {

        USHORT FreeListsInUseTerminate;
        USHORT DecommitCount;
    } u2;

    USHORT AllocatorBackTraceIndex;

    ULONG NonDedicatedListLength;
    PVOID LargeBlocksIndex;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //
    
    PVOID FrontEndHeap;
    
    USHORT FrontHeapLockCount;
    UCHAR FrontEndHeapType;
    UCHAR LastSegmentIndex;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

//
// Page heap external interface.
//

#include <heappage.h>

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\hivedata.h ===
//depot/main/Base/ntos/inc/hivedata.h#9 - integrate change 19035 (text)
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    hivedata.h

Abstract:

    This module contains data structures used by the
    direct memory loaded hive manager.

Author:

    Dragos C. Sambotin (dragoss) 13-Jan-99

Revision History:



--*/

#ifndef __HIVE_DATA__
#define __HIVE_DATA__

//
// ===== Arbitrary Limits Imposed For Sanity =====
//
#define HSANE_CELL_MAX      (1024*1024)     // 1 megabyte max size for
                                            // a single cell


//
// ===== Tuning =====

#define HBIN_THRESHOLD      (HBLOCK_SIZE-512)   // If less than threshold
                                                // bytes would be left in
                                                // bin, add another page

#define HLOG_GROW           HBLOCK_SIZE         // Minimum size to grow log
                                                // by.  Can set this up
                                                // if we think it thrashes.

#define HCELL_BIG_ROUND     (HBLOCK_SIZE*3)     //
                                                // If someone tries to
                                                // allocate a very large
                                                // cell, round it up to
                                                // HBLOCK_SIZE.  This is
                                                // the rather arbitrary
                                                // define for "very large"
                                                //
//
// Never shrink the log files smaller than this, this prevents people
// from taking up all the disk space and then being unable to do
// critical registry operations (like logging on to delete some files)
//
#define HLOG_MINSIZE(Hive)  \
    ((Hive)->Cluster * HSECTOR_SIZE * 2)

//
// ===== Basic Structures and Definitions =====
//
// These are same whether on disk or in memory.
//

//
// NOTE:    Volatile == storage goes away at reboot
//          Stable == Persistent == Not Volatile
//
typedef enum {
    Stable = 0,
    Volatile = 1
} HSTORAGE_TYPE;

#define HTYPE_COUNT 2

//
// --- HCELL_INDEX ---
//
//
// Handle to a cell -> effectively the "virtual" address of the cell,
// HvMapCell converts this to a "real" address, that is, a memory
// address.  Mapping scheme is very much like that standard two level
// page table.  No mappings stored in file, they are built up when
// the file is read in.  (The INDEX in HCELL_INDEX is historical)
//
//  Bit     31  30-21   20-12   11-0
//        +----------------------------+
//        | T | Table | Block | Offset |
//        +----------------------------+
//
//  T = Type(1)= 0 for stable ("normal") storage
//               1 for volatile storage
//
//      Table(10) = Index into directory of mapping tables, selects a table.
//                  Each mapping table is an array of HMAP_ENTRY structures.
//
//      Block(9) = Index into Table, selects an HMAP_ENTRY.  HMAP_ENTRY
//                 contains address of area in memory that this HCELL_INDEX
//                 maps to.  (Base of memory copy of Block)
//
//      Offset(12) = Offset within page, of the Cell header for the cell
//                   of interest.
//
typedef ULONG HCELL_INDEX;
typedef HCELL_INDEX *PHCELL_INDEX;

#ifdef DRAGOSS_PRIVATE_DEBUG
//#undef PAGE_SIZE
//#define PAGE_SIZE 0x2000
#endif //DRAGOSS_PRIVATE_DEBUG

#define HCELL_NIL   ((HCELL_INDEX)(-1))

#define HCELL_TYPE_MASK         0x80000000
#define HCELL_TYPE_SHIFT        31

#define HCELL_TABLE_MASK        0x7fe00000
#define HCELL_TABLE_SHIFT       21

#define HCELL_BLOCK_MASK        0x001ff000
#define HCELL_BLOCK_SHIFT       12

#define HCELL_OFFSET_MASK       0x00000fff

#define HBLOCK_SIZE             0x1000                      // LOGICAL block size
                                                            // This is the size of one of
                                                            // the registry's logical/virtual
                                                            // pages.  It has no particular
                                                            // relationship to page size
                                                            // of the machine.

#define HSECTOR_SIZE            0x200                       // LOGICAL sector size
#define HSECTOR_COUNT           8                           // LOGICAL sectors / LOGICAL Block

#define HSECTOR_PER_PAGE_COUNT  (PAGE_SIZE / HSECTOR_SIZE)  // LOGICAL sectors / Physical page

#define HTABLE_SLOTS        512         // 9 bits of address
#define HDIRECTORY_SLOTS    1024        // 10 bits of address

#define HvGetCellType(Cell) ((ULONG)((Cell & HCELL_TYPE_MASK) >> HCELL_TYPE_SHIFT))

//
// --- HCELL --- an object within the hive  (A bin is filled with HCELLs)
//
// Any given item of user data must fit within a single HCELL.
// HCELLs cannot span Bins.
//
#define HCELL_PAD(Hive)         ((Hive->Version>=2) ? 8 : 16)
                                // All cells must be at least this large,
                                // All allocations on this boundary

#define HCELL_ALLOCATE_FILL 0xb2    // bz -> buzz buzz (yeah, it's a stretch)
                                    // must fill all newly allocated
                                    // cells for security reasons

#define HCELL_FREE_FILL     0xfc    // fc = HvFreeCell...

//
// Currently we support two cell formats, one with a Last backpointer (old version),
// and one without (new version)
//
// All cells in a hive must be of the same type.  Version 1 hives use the old version,
// Version 2 or greater use the new version.
//

#define USE_OLD_CELL(Hive) (Hive->Version==1)

typedef struct _HCELL {
    LONG    Size;
    union {
        struct {
            ULONG Last;
            union {
                ULONG UserData;
                HCELL_INDEX Next;   // offset of next element in freelist (not a FLink)
            } u;
        } OldCell;

        struct {
            union {
                ULONG UserData;
                HCELL_INDEX Next;    // offset of next element in freelist (not a FLink)
            } u;
        } NewCell;
    } u;
} HCELL, *PHCELL;


//
// --- HBIN ---  is a contiguous set of HBLOCKs, filled with HCELLs.
//
#define HBIN_SIGNATURE          0x6e696268      // "hbin"
#define HBIN_NIL                (-1)

#pragma pack(4)
typedef struct  _HBIN {
    ULONG       Signature;
    ULONG       FileOffset;     // Own file offset (used in checking)
    ULONG       Size;           // Size of bin in bytes, all inclusive
    ULONG       Reserved1[2];   // Old FreeSpace and FreeList (from 1.0)
    LARGE_INTEGER   TimeStamp;  // Old Link (from 1.0).  Usually trash, but
                                // first bin has valid value used for .log
                                // correspondence testing, only meaningful
                                // on disk.
    ULONG       Spare;          // this used to be MemAlloc. We don't use it anymore as we
                                // can't afford to touch the bin (it's not residing in paged-pool
                                // anymore, so touching it means modifying mnw pages).
                                // Spare is used for the ShiftFreeBins Stuff - in memory only!

    //
    // Cell data goes here
    //

} HBIN, *PHBIN;
#pragma pack()

//
// ===== On Disk Structures =====
//

//
// NOTE:    Hive storage is always allocated in units of 4K.  This size
//          must be used on all systems, regardless of page size, since
//          the file format needs to be transportable amoung systems.
//
// NOTE:    The integrity code depends on certain blocks (e.g., the
//          BASE block) being at least as large as the size of a physical
//          sector.  (Otherwise data that should be left alone will
//          be written because the FS has to block/deblock.)  This means
//          that the current code will not work with sectors > 4K.
//
// NOTE:    A hive on disk always contains at least two blocks of storage.
//          1 block for the base block, and 1 for the minimum 1 bin.
//
// NOTE:    Only modified parts of the hive get written to disk.
//          This is not just for efficiency, but also to avoid risk
//          of destruction of unlogged data.  Dirty bits keep track
//          of what has been modified, they reside in a simple
//          bit map attached to the hive.  One bit for each logical
//          sector of 512 bytes.
//
//          If the physical sector size of the machine is less than 512,
//          no matter, we'll always write in clumps of 512.  If the
//          physical sector size is greater than 512, we'll always clump
//          data together so that we log and write data
//          in chunks of that size.  Physical sector sizes > 4K will
//          not work correctly (logging will not work right, so system
//          crashes may lose data that would not otherwise be lost.)
//


//
// An on disk image of a hive looks like this:
//
//      +---------------------------------------+
//      | HBASE_BLOCK                           | 1 Hive Block == 4K
//      |                                       |
//      +---------------------------------------+ <- HBLOCK_SIZE boundary
//      | Bin - 1 to N 4K blocks                |
//      | Each contains a signature, size, and  |
//      | a boundary tag heap internal to       |
//      | itself.  Once allocated lives forever |
//      | and always at same file offset.       |
//      +---------------------------------------+ <- HBLOCK_SIZE boundary
//      | Bin ...                               |
//      +---------------------------------------+ <- HBLOCK_SIZE boundary
//              ...
//      +---------------------------------------+ <- HBLOCK_SIZE boundary
//      | Last allocated Bin, new bins are put  |
//      | immediately after this one.           |
//      +---------------------------------------+ <- HBLOCK_SIZE boundary
//
//  Hive files must allocate on HBLOCK_SIZE boundaries because they
//  might be written on many different systems, and must therefore be
//  set up for the largest cluster size we will support.
//

//
//  The log file format is:
//
//          +-------------------------------+
//          | HBASE_BLOCK copy              |
//          +-------------------------------+ <- cluster (usually 512) bound
//          | DirtyVector                   |
//          | (length computed from length  |
//          |  in the base block            |
//          | (with "DIRT" on front as a    |
//          |  signature)                   |
//          +-------------------------------+ <- cluster (usually 512) bound
//          | Dirty Data                    |
//          +-------------------------------+ <- cluster (usually 512) bound
//          | Dirty Data                    |
//          +-------------------------------+ <- cluster (usually 512) bound
//          | ...                           |
//          +-------------------------------+
//
//  Recovery consists of reading the file in, computing which clusters
//  of data are present from the dirtyvector, and where they belong in
//  the hive address space.  Position in file is by sequential count.
//
//  Logs can allocate on cluster boundaries (physical sector size of
//  host machine) because they will never be written on any machine other
//  than the one that created them.
//
//  For log to be valid:
//
//      Signature, format, major.minor must match expected values.
//      Sequence1 and Sequence2 must match.
//      CheckSum must be correct.
//      Signture on DirtyVector must be correct
//
//  For log to be applicable:
//
//      Sequence in log must match sequence in hive.
//      TimeStamp in log must match TimeStamp in hive.
//      Hive must be in mid-update state, or have bogus header.
//

//
// --- HBASE_BLOCK --- on disk description of the hive
//

//
// NOTE:    HBASE_BLOCK must be >= the size of physical sector,
//          or integrity assumptions will be violated, and crash
//          recovery may not work.
//
#define HBASE_BLOCK_SIGNATURE   0x66676572  // "regf"

#define HSYS_MAJOR              1               // Must match to read at all
#define HSYS_MINOR              3

#define HSYS_WHISTLER_BETA1     4               // Whistler Beta1 hives

#define HSYS_WHISTLER           5               // normal Whistler hives

#define HSYS_MINOR_SUPPORTED    HSYS_WHISTLER   // Must be <= to write, always
                                                // set up to writer's version.



#define HBASE_FORMAT_MEMORY 1               // Direct memory load case

#define HBASE_NAME_ALLOC    64              // 32 unicode chars

//
// Boot Type Loader <-> Kernel communication
//
#define HBOOT_NORMAL            0
#define HBOOT_REPAIR            1
#define HBOOT_BACKUP            2
#define HBOOT_SELFHEAL          4

#pragma pack(4)
typedef struct _HBASE_BLOCK {
    ULONG           Signature;
    ULONG           Sequence1;
    ULONG           Sequence2;
    LARGE_INTEGER   TimeStamp;
    ULONG           Major;
    ULONG           Minor;
    ULONG           Type;                   // HFILE_TYPE_[PRIMARY|LOG]
    ULONG           Format;
    HCELL_INDEX     RootCell;
    ULONG           Length;                 // Includes all but header
    ULONG           Cluster;                // for logs only
    UCHAR           FileName[HBASE_NAME_ALLOC];  // filename tail
    ULONG           Reserved1[99];
    ULONG           CheckSum;
    ULONG           Reserved2[128*7-2];       // subtract 2 for the volatile info
    ULONG           BootType;				// set by bootloader 
    ULONG           BootRecover;            // set to 1 by bootloader if it did hive recovery
                                            // nobody else is using this
} HBASE_BLOCK, *PHBASE_BLOCK;
#pragma pack()

#define HLOG_HEADER_SIZE  (FIELD_OFFSET(HBASE_BLOCK, Reserved2))
#define HLOG_DV_SIGNATURE   0x54524944      // "DIRT"

//
// ===== In Memory Structures =====
//

//
// In memory image of a Hive looks just like the on-disk image,
// EXCEPT that the HBIN structures can be spread throughout memory
// rather than packed together.
//
// To find an HCELL in memory, a mechanism that takes an HCELL_INDEX and
// derives a memory address from it is used.  That mechanism is very
// similar to a two level hardware paging table.
//
// A bit map is used to remember which parts of the hive are dirty.
//
// An HBLOCK can be in three different states
//  1. Present in memory.  BlockAddress and BinAddress are valid pointers.
//     This is the normal state of an HBLOCK.
//
//  2. Discardable.  The HBIN containing this HBLOCK is completely free, but
//     the bin is dirty and needs to be written to the hive file before it
//     can be free.  This is the state we will be in if somebody frees a
//     cell, causing the entire HBIN to become free.  HvpEnlistFreeCell will
//     transition all the HBLOCKs in the free HBIN to this state, but will
//     not free their memory.  After the dirty HBLOCKs are flushed to the
//     file, the memory will be freed.
//
//     Note that if we need to allocate more storage from an HBIN in this
//     state, HvAllocateCell will simply change its state back to State 1
//     and it will be usable.
//
//     An HBLOCK in this state has a valid BlockAddress and BinAddress, but
//     the HMAP_DISCARDABLE bit will be set.
//
//  3. Discarded.  The HBIN containing this HBLOCK is completely free, and
//     is not dirty (i.e. it is marked as free in the hive file as well).
//     There is no memory allocated to contain this HBIN.  After HvSyncHive
//     writes out an HBIN that is in State 2, it frees its pool and the
//     HBIN moves into this state.
//
//     In order to use this HBIN, memory must be allocated to back it, and
//     the HBIN and initial HCELL must be recreated.  (we could re-read it
//     from the hive file, but there's not much point in that since we know
//     that it is entirely free, so we might as well just recreate it and
//     save the disk i/o)
//
//     An HBLOCK in this state has a NULL BlockAddress in the map.
//     The BinAddress will contain the next HCELL in the free list, so
//     we can reconstruct this when we need it.
//     The HMAP_NEWALLOC bit will be set for the first HBLOCK in the HBIN.
//

//
// --- HMAP_ENTRY --- Holds memory location of HCELL
//
#define HMAP_FLAGS          (0xf)
#define HMAP_BASE           (~(HMAP_FLAGS))

#define HBIN_BASE(BinAddress)   (BinAddress & HMAP_BASE)
#define HBIN_FLAGS(BinAddress)  (BinAddress & HMAP_FLAGS)

#define HMAP_NEWALLOC       1               // the bin is the beginning of a new
                                            // allocation. When bin is in view this
                                            // doesn't really matter

#define HMAP_DISCARDABLE    2               // bin is discardable (i.e. is all free)
                                            // first time when we get the chance we'll
                                            // free it (if it is in paged pool)

#define HMAP_INVIEW         4               // bin is mapped in system cache

#define HMAP_INPAGEDPOOL    8               // bin is allocated from paged pool


#define BIN_MAP_ALLOCATION_TYPE(Me) (((Me)->BinAddress)&(HMAP_INPAGEDPOOL|HMAP_INVIEW))

#define ASSERT_BIN_INVIEW(Me)       ASSERT( ((Me)->BinAddress & HMAP_INVIEW) != 0 )
#define ASSERT_BIN_INPAGEDPOOL(Me)  ASSERT( ((Me)->BinAddress & HMAP_INPAGEDPOOL) != 0 )
#define ASSERT_BIN_INVALID(Me)      ASSERT( ((Me)->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) == 0 )
#define ASSERT_BIN_VALID(Me)        ASSERT( ((Me)->BinAddress & (HMAP_INPAGEDPOOL|HMAP_INVIEW)) != 0 )

struct _CM_VIEW_OF_FILE; //forward
typedef struct _HMAP_ENTRY {
    ULONG_PTR    BlockAddress;       // Low 2 bits always 0.  High bits
                                    // are memory address of HBLOCK that
                                    // HCELL starts in, add Offset to this.
                                    // (An HCELL can span several HBLOCKs)
                                    //

    ULONG_PTR    BinAddress;         // Low bit set TRUE to mark beginning
                                    // of a new allocation.
                                    // High bits are memory address of
                                    // first HBLOCK in same bin.
                                    // (A given HCELL is always contained
                                    //  in a single bin.)

// Dragos: From here start the changes!!!
    struct _CM_VIEW_OF_FILE    *CmView;    // pointer to the view; NULL when bin is not mapped

    ULONG       MemAlloc;           // we needed to move this from the bin header to the map, in
                                    // order to prevent the bin from being touched

/*
We don't really need this. Left just as a comment


    ULONG       Flags;              // tells if a bin is mapped through
                                    // a view, is allocated from paged pool
                                    // or is unmapped/unallocated


    ULONG_PTR   MappedAddress;      // temporary address inside the mapped view.

*/

} HMAP_ENTRY, *PHMAP_ENTRY;


//
// --- HMAP_TABLE --- Array of MAP_ENTRYs that point to memory HBLOCKs
//
// Each HBLOCK worth of space in the Hive image has an entry in
// an HMAP_TABLE.
//
typedef struct _HMAP_TABLE {
    HMAP_ENTRY  Table[ HTABLE_SLOTS ];
} HMAP_TABLE, *PHMAP_TABLE;


//
// --- HMAP_DIRECTORY --- Array of pointers to HMAP_TABLEs
//
typedef struct _HMAP_DIRECTORY {
    PHMAP_TABLE Directory[  HDIRECTORY_SLOTS ];
} HMAP_DIRECTORY, *PHMAP_DIRECTORY;


//
// ===== Hive Routines typedefs =====
//
struct _HHIVE; // forward

typedef
PVOID
(*PALLOCATE_ROUTINE) (
    ULONG       Length,             // Size of new block wanted
    BOOLEAN     UseForIo,            // TRUE if yes, FALSE if no
    ULONG       Tag
    );

typedef
VOID
(*PFREE_ROUTINE) (
    PVOID       MemoryBlock,
    ULONG       GlobalQuotaSize
    );

typedef
BOOLEAN
(*PFILE_SET_SIZE_ROUTINE) (
    struct _HHIVE  *Hive,
    ULONG          FileType,
    ULONG          FileSize,
    ULONG          OldFileSize
    );

typedef struct {
    ULONG  FileOffset;
    PVOID  DataBuffer;
    ULONG  DataLength;
} CMP_OFFSET_ARRAY, * PCMP_OFFSET_ARRAY;

typedef
BOOLEAN
(*PFILE_WRITE_ROUTINE) (
    struct _HHIVE  *Hive,
    ULONG       FileType,
    PCMP_OFFSET_ARRAY offsetArray,
    ULONG offsetArrayCount,
    PULONG FileOffset
    );

typedef
BOOLEAN
(*PFILE_READ_ROUTINE) (
    struct _HHIVE  *Hive,
    ULONG       FileType,
    PULONG      FileOffset,
    PVOID       DataBuffer,
    ULONG       DataLength
    );

typedef
BOOLEAN
(*PFILE_FLUSH_ROUTINE) (
    struct _HHIVE  *Hive,
    ULONG           FileType,
    PLARGE_INTEGER  FileOffset,
    ULONG           Length
    );

typedef
struct _CELL_DATA *
(*PGET_CELL_ROUTINE)(
    struct _HHIVE   *Hive,
    HCELL_INDEX Cell
    );

typedef
VOID
(*PRELEASE_CELL_ROUTINE)(
    struct _HHIVE   *Hive,
    HCELL_INDEX Cell
    );

//
// --- HHIVE --- In memory descriptor for a hive.
//

//
// HHIVE contains pointers to service procedures, and pointers to
// map structure.
//
// NOTE:    Optimization - If the size of a hive is less than what can
//          be mapped with a single HMAP_TABLE (HTABLE_SLOTS * HBLOCK_SIZE,
//          or 2 megabytes) there is no real HMAP_DIRECTORY.  Instead,
//          a single DWORD in the HHIVE acts as the 0th entry of the
//          directory.
//
// NOTE:    Free Storage Management - When a hive is loaded, we build up
//          a display (vector) of lists of free cells.  The first part
//          of this vector contains lists that only hold one size cell.
//          The size of cell on the list is HCELL_PAD * (ListIndex+1)
//          There are 15 of these lists, so all free cells between 8 and
//          120 bytes are on these lists.
//
//          The second part of this vector contains lists that hold more
//          than one size cell.  Each size bucket is twice the previous
//          size.  There are 8 of these lists, so all free cells between 136 and
//          32768 bytes are on these lists.
//
//          The last list in this vector contains all cells too large to
//          fit in any previous list.
//
//          Example:    All free cells of size 1 HCELL_PAD (8 bytes)
//                      are on the list at offset 0 in FreeDisplay.
//
//                      All free cells of size 15 HCELL_PAD (120 bytes)
//                      are on the list at offset 0xe.
//
//                      All free cells of size 16-31 HCELL_PAD (128-248 bytes)
//                      are on the list at offset 0xf
//
//                      All free cells of size 32-63 HCELL_PAD (256-506 bytes)
//                      are on the list at offset 0x10.
//
//                      All free cells of size 2048 HCELL_PAD (16384 bytes)
//                      OR greater, are on the list at offset 0x17.
//
//          FreeSummary is a bit vector, with a bit set to true for each
//          entry in FreeDisplay that is not empty.
//

#define HHIVE_SIGNATURE 0xBEE0BEE0

#define HFILE_TYPE_PRIMARY      0   // Base hive file
#define HFILE_TYPE_LOG          1   // Log (security.log)
#define HFILE_TYPE_EXTERNAL     2   // Target of savekey, etc.
#define HFILE_TYPE_MAX          3

#define HHIVE_LINEAR_INDEX      16  // All computed linear indices < HHIVE_LINEAR_INDEX are valid
#define HHIVE_EXPONENTIAL_INDEX 23  // All computed exponential indices < HHIVE_EXPONENTIAL_INDEX
                                    // and >= HHIVE_LINEAR_INDEX are valid.
#define HHIVE_FREE_DISPLAY_SIZE 24

#define HHIVE_FREE_DISPLAY_SHIFT 3  // This must be log2 of HCELL_PAD!
#define HHIVE_FREE_DISPLAY_BIAS  7  // Add to first set bit left of cell size to get exponential index


#define FREE_HBIN_DISCARDABLE   1   // the BlockAddress in HBIN points to the real bin

typedef struct _FREE_HBIN {
    LIST_ENTRY  ListEntry;
    ULONG       Size;
    ULONG       FileOffset;
    ULONG       Flags;
} FREE_HBIN, *PFREE_HBIN;

typedef struct _HHIVE {
    ULONG                   Signature;

    PGET_CELL_ROUTINE       GetCellRoutine;
    PRELEASE_CELL_ROUTINE   ReleaseCellRoutine;

    PALLOCATE_ROUTINE       Allocate;
    PFREE_ROUTINE           Free;

    PFILE_SET_SIZE_ROUTINE  FileSetSize;
    PFILE_WRITE_ROUTINE     FileWrite;
    PFILE_READ_ROUTINE      FileRead;
    PFILE_FLUSH_ROUTINE     FileFlush;

    struct _HBASE_BLOCK     *BaseBlock;

    RTL_BITMAP              DirtyVector;    // only for Stable bins
    ULONG                   DirtyCount;
    ULONG                   DirtyAlloc;     // allocated bytges for dirty vect
    ULONG                   Cluster;        // Usually 1 512 byte sector.
                                            // Set up force writes to be
                                            // done in larger units on
                                            // machines with larger sectors.
                                            // Is number of logical 512 sectors.

    BOOLEAN                 Flat;               // TRUE if FLAT
    BOOLEAN                 ReadOnly;           // TRUE if READONLY

    BOOLEAN                 Log;

    ULONG                   HiveFlags;

    ULONG                   LogSize;

    ULONG                   RefreshCount;       // debugging aid


    ULONG                   StorageTypeCount;   // 1 > Number of largest valid
                                                // type. (1 for Stable only,
                                                // 2 for stable & volatile)

    ULONG                   Version;            // hive version, to allow supporting multiple
                                                // formats simultaneously.

    struct _DUAL {
        ULONG               Length;
#ifdef  HV_TRACK_FREE_SPACE
        ULONG				FreeStorage;		// how many free space.
#endif
        PHMAP_DIRECTORY     Map;
        PHMAP_TABLE         SmallDir;
        ULONG               Guard;				// Always == -1

        RTL_BITMAP          FreeDisplay[HHIVE_FREE_DISPLAY_SIZE];   // bitmap of freecells of the corresponding size
                                                                    // for every HBLOCK_SIZE - bin in the hive, a bit
                                                                    // is set here if a free cell of the desired size
                                                                    // lies in this block

        ULONG               FreeSummary;
        LIST_ENTRY          FreeBins;           // list of freed HBINs (FREE_HBIN)

    }                       Storage[ HTYPE_COUNT ];

    //
    // Caller defined data goes here
    //

} HHIVE, *PHHIVE;


#endif // __HIVE_DATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\ia64.h ===
/*++

Module Name:

    ia64.h

Abstract:

    This module contains the IA64 hardware specific header file.

Author:

    David N. Cutler (davec) 31-Mar-1990

Revision History:

    Bernard Lint 6-Jun-1995: IA64 version based on MIPS version.

--*/

#ifndef _IA64H_
#define _IA64H_

#if !(defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_)) && !defined(_BLDR_)

#define ExRaiseException RtlRaiseException
#define ExRaiseStatus RtlRaiseStatus

#endif

//
// Interruption history
//
// N.B. Currently the history records are saved in the 2nd half of the 8K
//      PCR page.  Therefore, we can only keep track of up to the latest
//      128 interruption records, each of 32 bytes in size.  Also, the PCR
//      structure cannot be greater than 4K.  In the future, the interruption
//      history records may become part of the KPCR structure.
//

typedef struct _IHISTORY_RECORD {
    ULONGLONG InterruptionType;
    ULONGLONG IIP;
    ULONGLONG IPSR;
    ULONGLONG Extra0;
} IHISTORY_RECORD;

#define MAX_NUMBER_OF_IHISTORY_RECORDS  128

//
// For PSR bit field definitions
//
#include "kxia64.h"


// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

#if defined(_IA64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 100

//
// Indicate that the IA64 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Define intrinsic calls and their prototypes
//

#include "ia64reg.h"


#ifdef __cplusplus
extern "C" {
#endif

unsigned __int64 __getReg (int);
void __setReg (int, unsigned __int64);
void __isrlz (void);
void __dsrlz (void);
void __fwb (void);
void __mf (void);
void __mfa (void);
void __synci (void);
__int64 __thash (__int64);
__int64 __ttag (__int64);
void __ptcl (__int64, __int64);
void __ptcg (__int64, __int64);
void __ptcga (__int64, __int64);
void __ptri (__int64, __int64);
void __ptrd (__int64, __int64);
void __invalat (void);
void __break (int);
void __fc (__int64);
void __sum (int);
void __rsm (int);
void _ReleaseSpinLock( unsigned __int64 *);

#ifdef _M_IA64
#pragma intrinsic (__getReg)
#pragma intrinsic (__setReg)
#pragma intrinsic (__isrlz)
#pragma intrinsic (__dsrlz)
#pragma intrinsic (__fwb)
#pragma intrinsic (__mf)
#pragma intrinsic (__mfa)
#pragma intrinsic (__synci)
#pragma intrinsic (__thash)
#pragma intrinsic (__ttag)
#pragma intrinsic (__ptcl)
#pragma intrinsic (__ptcg)
#pragma intrinsic (__ptcga)
#pragma intrinsic (__ptri)
#pragma intrinsic (__ptrd)
#pragma intrinsic (__invalat)
#pragma intrinsic (__break)
#pragma intrinsic (__fc)
#pragma intrinsic (__sum)
#pragma intrinsic (__rsm)
#pragma intrinsic (_ReleaseSpinLock)

#endif // _M_IA64

#ifdef __cplusplus
}
#endif


// end_wdm end_ntndis

//
// Define macro to generate import names.
//

#define IMPORT_NAME(name) __imp_##name

// begin_wdm

//
// Define length of interrupt vector table.
//

#define MAXIMUM_VECTOR 256

// end_wdm


//
// IA64 specific interlocked operation result values.
//

#define RESULT_ZERO 0
#define RESULT_NEGATIVE 1
#define RESULT_POSITIVE 2

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for values are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

//
// Convert portable interlock interfaces to architecture specific interfaces.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define ExInterlockedIncrementLong(Addend, Lock) \
    ExIa64InterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend, Lock) \
    ExIa64InterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target, Value, Lock) \
    ExIa64InterlockedExchangeUlong(Target, Value)

NTKERNELAPI
INTERLOCKED_RESULT
ExIa64InterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
ExIa64InterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
ExIa64InterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

// begin_wdm

//
// IA64 Interrupt Definitions.
//
// Define length of interrupt object dispatch code in longwords.
//

#define DISPATCH_LENGTH 2*2                // Length of dispatch code template in 32-bit words

//
// Begin of a block of definitions that must be synchronized with kxia64.h.
//

//
// Define Interrupt Request Levels.
//

#define PASSIVE_LEVEL            0      // Passive release level
#define LOW_LEVEL                0      // Lowest interrupt level
#define APC_LEVEL                1      // APC interrupt level
#define DISPATCH_LEVEL           2      // Dispatcher level
#define CMC_LEVEL                3      // Correctable machine check level
#define DEVICE_LEVEL_BASE        4      // 4 - 11 - Device IRQLs
#define PC_LEVEL                12      // Performance Counter IRQL
#define IPI_LEVEL               14      // IPI IRQL
#define CLOCK_LEVEL             13      // Clock Timer IRQL
#define POWER_LEVEL             15      // Power failure level
#define PROFILE_LEVEL           15      // Profiling level
#define HIGH_LEVEL              15      // Highest interrupt level

#if defined(NT_UP)

#define SYNCH_LEVEL             DISPATCH_LEVEL  // Synchronization level - UP

#else

#define SYNCH_LEVEL             (IPI_LEVEL-1) // Synchronization level - MP

#endif

//
// The current IRQL is maintained in the TPR.mic field. The
// shift count is the number of bits to shift right to extract the
// IRQL from the TPR. See the GET/SET_IRQL macros.
//

#define TPR_MIC        4
#define TPR_IRQL_SHIFT TPR_MIC

// To go from vector number <-> IRQL we just do a shift
#define VECTOR_IRQL_SHIFT TPR_IRQL_SHIFT

//
// Interrupt Vector Definitions
//

#define APC_VECTOR          APC_LEVEL << VECTOR_IRQL_SHIFT
#define DISPATCH_VECTOR     DISPATCH_LEVEL << VECTOR_IRQL_SHIFT


//
// End of a block of definitions that must be synchronized with kxia64.h.
//

//
// Define profile intervals.
//

#define DEFAULT_PROFILE_COUNT 0x40000000 // ~= 20 seconds @50mhz
#define DEFAULT_PROFILE_INTERVAL (10 * 500) // 500 microseconds
#define MAXIMUM_PROFILE_INTERVAL (10 * 1000 * 1000) // 1 second
#define MINIMUM_PROFILE_INTERVAL (10 * 40) // 40 microseconds

#if defined(_M_IA64) && !defined(RC_INVOKED)

#define InterlockedAdd _InterlockedAdd
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd

#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64

#define InterlockedCompareExchange _InterlockedCompareExchange
#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer

#ifdef __cplusplus
extern "C" {
#endif

LONG
__cdecl
InterlockedAdd (
    LONG volatile *Addend,
    LONG Value
    );

LONGLONG
__cdecl
InterlockedAdd64 (
    LONGLONG volatile *Addend,
    LONGLONG Value
    );

LONG
__cdecl
InterlockedIncrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedDecrement(
    IN OUT LONG volatile *Addend
    );

LONG
__cdecl
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
__cdecl
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

LONG
__cdecl
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

LONGLONG
__cdecl
InterlockedIncrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedDecrement64(
    IN OUT LONGLONG volatile *Addend
    );

LONGLONG
__cdecl
InterlockedExchange64(
    IN OUT LONGLONG volatile *Target,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedExchangeAdd64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value
    );

LONGLONG
__cdecl
InterlockedCompareExchange64 (
    IN OUT LONGLONG volatile *Destination,
    IN LONGLONG ExChange,
    IN LONGLONG Comperand
    );

PVOID
__cdecl
InterlockedCompareExchangePointer (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
__cdecl
InterlockedExchangePointer(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

#pragma intrinsic(_InterlockedAdd)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedAdd64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#ifdef __cplusplus
}
#endif

#endif // defined(_M_IA64) && !defined(RC_INVOKED)

// end_ntddk end_nthal end_wdm end_ntosp

// begin_ntddk

__inline
LONG
InterlockedAnd (
    IN OUT LONG volatile *Target,
    LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i & Set,
                                       i);

    } while (i != j);

    return j;
}

__inline
LONG
InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i | Set,
                                       i);

    } while (i != j);

    return j;
}

// end_ntddk

#define KiSynchIrql SYNCH_LEVEL         // enable portable code
#define KiProfileIrql PROFILE_LEVEL     // enable portable code


//
// Sanitize FPSR based on processor mode.
//
// If kernel mode, then
//      let caller specify all bits, except reserved
//
// If user mode, then
//      let the caller specify all bits, except reserved
//

__inline
ULONG64
SANITIZE_FSR(ULONG64 fsr, MODE mode)
{
    UNREFERENCED_PARAMETER(mode);

    fsr &= ~(MASK_IA64(FPSR_MBZ0,FPSR_MBZ0_V)| MASK_IA64(FPSR_TD0, 1));

    if (((fsr >> FPSR_PC0) & 3i64) == 1) {
        fsr = fsr | (3i64 << FPSR_PC0);
    }
    if (((fsr >> FPSR_PC1) & 3i64) == 1) {
        fsr = fsr | (3i64 << FPSR_PC1);
    }
    if (((fsr >> FPSR_PC2) & 3i64) == 1) {
        fsr = fsr | (3i64 << FPSR_PC2);
    }
    if (((fsr >> FPSR_PC3) & 3i64) == 1) {
        fsr = fsr | (3i64 << FPSR_PC3);
    }

    return fsr;
}

//
// Define SANITIZE_PSR for IA64
//
// If kernel mode, then
//      force clearing of BE, SP, CPL, MC, PK, DFL, reserved (MBZ)
//      force the setting of IC, DT, DFH, DI, LP, RT, IT
//      let caller specify UP, AC, I, BN, PP, SI, DB, TB, IS, ID, DA, DD, SS, RI, ED
//
// If user mode, then
//      force clearing of MC, PK, LP, reserved
//      force the setting of BN, IC, I, DT, RT, CPL, IT
//      let caller specify BE, UP, PP, AC, DFL, DFH, SP, SI, DI, DB, TB, IS, ID, DA, DD, SS, RI, ED
//

#define PSR_KERNEL_CLR  (MASK_IA64(PSR_BE,1i64) | MASK_IA64(PSR_SP,1i64) | MASK_IA64(PSR_PK,1i64) |  \
                         MASK_IA64(PSR_CPL,0x3i64) | MASK_IA64(PSR_MC,1i64) | MASK_IA64(PSR_MBZ0,PSR_MBZ0_V) |  \
                         MASK_IA64(PSR_MBZ1,PSR_MBZ1_V) | MASK_IA64(PSR_MBZ2,PSR_MBZ2) |  \
                         MASK_IA64(PSR_DFL, 1i64))

#if defined(_IA64_PSR_DI_X86_)

#define PSR_KERNEL_SET  (MASK_IA64(PSR_IC,1i64) | MASK_IA64(PSR_DT,1i64) |  \
                         MASK_IA64(PSR_IT,1i64) | MASK_IA64(PSR_RT,1i64))

#define PSR_KERNEL_CPY  (MASK_IA64(PSR_UP,1i64) | MASK_IA64(PSR_AC,1i64) | MASK_IA64(PSR_DI,1i64) |  \
                         MASK_IA64(PSR_I,1i64) | MASK_IA64(PSR_BN,1i64)  | MASK_IA64(PSR_DFH,1i64) | \
                         MASK_IA64(PSR_PP,1i64) | MASK_IA64(PSR_SI,1i64) | MASK_IA64(PSR_DB,1i64) |  \
                         MASK_IA64(PSR_TB,1i64) | MASK_IA64(PSR_IS,1i64) | MASK_IA64(PSR_ID,1i64) |  \
                         MASK_IA64(PSR_DA,1i64) | MASK_IA64(PSR_DD,1i64) | MASK_IA64(PSR_SS,1i64) |  \
                         MASK_IA64(PSR_RI,0x3i64) | MASK_IA64(PSR_ED,1i64) | MASK_IA64(PSR_LP,1i64))

#else  // !_IA64_PSR_DI_X86_

#define PSR_KERNEL_SET  (MASK_IA64(PSR_IC,1i64) | MASK_IA64(PSR_DT,1i64) |  \
                         MASK_IA64(PSR_DI,1i64) | MASK_IA64(PSR_IT,1i64) |  \
                         MASK_IA64(PSR_RT,1i64))

#define PSR_KERNEL_CPY  (MASK_IA64(PSR_UP,1i64) | MASK_IA64(PSR_AC,1i64) |  \
                         MASK_IA64(PSR_I,1i64) | MASK_IA64(PSR_BN,1i64)  | MASK_IA64(PSR_DFH,1i64) | \
                         MASK_IA64(PSR_PP,1i64) | MASK_IA64(PSR_SI,1i64) | MASK_IA64(PSR_DB,1i64) |  \
                         MASK_IA64(PSR_TB,1i64) | MASK_IA64(PSR_IS,1i64) | MASK_IA64(PSR_ID,1i64) |  \
                         MASK_IA64(PSR_DA,1i64) | MASK_IA64(PSR_DD,1i64) | MASK_IA64(PSR_SS,1i64) |  \
                         MASK_IA64(PSR_RI,0x3i64) | MASK_IA64(PSR_ED,1i64) | MASK_IA64(PSR_LP,1i64))

#endif  // !_IA64_PSR_DI_X86_

#define PSR_USER_CLR    (MASK_IA64(PSR_MC,1i64) |  \
                         MASK_IA64(PSR_MBZ0,PSR_MBZ0_V) | MASK_IA64(PSR_PK,1i64) |  \
                         MASK_IA64(PSR_MBZ1,PSR_MBZ1_V) | MASK_IA64(PSR_MBZ2,PSR_MBZ2) |  \
                         MASK_IA64(PSR_LP,1i64))

#define PSR_USER_SET    (MASK_IA64(PSR_IC,1i64) | MASK_IA64(PSR_I,1i64)  |  \
                         MASK_IA64(PSR_DT,1i64) | MASK_IA64(PSR_BN,1i64) |  \
                         MASK_IA64(PSR_RT,1i64) |  \
                         MASK_IA64(PSR_CPL,0x3i64) | MASK_IA64(PSR_IT,1i64))

#define PSR_USER_CPY    (MASK_IA64(PSR_BE,1i64) | MASK_IA64(PSR_UP,1i64) | MASK_IA64(PSR_PP,1i64) | \
                         MASK_IA64(PSR_AC,1i64) | MASK_IA64(PSR_DFL,1i64) | MASK_IA64(PSR_DFH,1i64) |  \
                         MASK_IA64(PSR_SP,1i64) | MASK_IA64(PSR_DI,1i64) | MASK_IA64(PSR_DB,1i64) |  \
                         MASK_IA64(PSR_TB,1i64) | MASK_IA64(PSR_IS,1i64) | MASK_IA64(PSR_ID,1i64) |  \
                         MASK_IA64(PSR_DA,1i64) | MASK_IA64(PSR_DD,1i64) | MASK_IA64(PSR_SS, 1i64) |  \
                         MASK_IA64(PSR_RI,0x3i64) | MASK_IA64(PSR_ED,1i64) | MASK_IA64(PSR_SI,1i64))

#define PSR_DEBUG_SET   (MASK_IA64(PSR_DB,1i64) | MASK_IA64(PSR_SS,1i64) | MASK_IA64(PSR_TB,1i64) |  \
                         MASK_IA64(PSR_ID,1i64) | MASK_IA64(PSR_DD,1i64))

__inline
ULONG64
SANITIZE_PSR(ULONG64 psr, MODE mode){

    psr = (mode) == KernelMode ?
        (PSR_KERNEL_SET | ((psr) & (PSR_KERNEL_CPY | ~PSR_KERNEL_CLR))) :
        (PSR_USER_SET | ((psr) & (PSR_USER_CPY | ~PSR_USER_CLR)));

    if (((psr >> PSR_RI) & 3) == 3) {

        //
        // 3 is an invalid slot number; sanitize it to zero
        //

        psr &= ~(3i64 << PSR_RI);
    }

    return(psr);
}

//
// Define SANITIZE_IFS for IA64
//

__inline
ULONG64
SANITIZE_IFS(ULONG64 pfsarg, MODE mode){

    IA64_PFS pfs;
    ULONGLONG sof;

    UNREFERENCED_PARAMETER(mode);

    pfs.ull = pfsarg;

    //
    // There is no previous EC or previous privilege level in IFS
    //

    pfs.sb.pfs_pec = 0;
    pfs.sb.pfs_ppl = 0;
    pfs.sb.pfs_reserved1 = 0;
    pfs.sb.pfs_reserved2 = 0;

    //
    // Set the valid bit.
    //

    pfs.ull |= MASK_IA64(IFS_V,1i64);

    //
    // Verify the size of frame is not greater than allowed.
    //

    sof = pfs.sb.pfs_sof;
    if (sof > PFS_MAXIMUM_REGISTER_SIZE) {
        sof = PFS_MAXIMUM_REGISTER_SIZE;
        pfs.sb.pfs_sof = PFS_MAXIMUM_REGISTER_SIZE;
    }

    //
    // Verify the size of locals is not greater than size of frame.
    //

    if (sof < pfs.sb.pfs_sol) {
        pfs.sb.pfs_sol = sof;
    }

    //
    // Verify the size of locals is not greater than size of frame.
    //

    if (sof < (pfs.sb.pfs_sor * 8)) {
        pfs.sb.pfs_sor = sof / 8;
    }

    //
    // Verify rename bases are less than the size of the rotaing regions.
    //

    if (pfs.sb.pfs_rrb_gr >= (pfs.sb.pfs_sor * 8)) {
        pfs.sb.pfs_rrb_gr = 0;
    }

    if (pfs.sb.pfs_rrb_fr >= PFS_MAXIMUM_REGISTER_SIZE) {
        pfs.sb.pfs_rrb_fr = 0;
    }

    if (pfs.sb.pfs_rrb_pr >= PFS_MAXIMUM_PREDICATE_SIZE) {
        pfs.sb.pfs_rrb_pr = 0;
    }

    return(pfs.ull);

}

__inline
ULONG64
SANITIZE_PFS(ULONG64 pfsarg, MODE mode){

    IA64_PFS pfs;
    ULONGLONG sof;

    pfs.ull = pfsarg;

    if (mode != KernelMode) {
        pfs.sb.pfs_ppl = IA64_USER_PL;
    }

    pfs.sb.pfs_reserved1 = 0;
    pfs.sb.pfs_reserved2 = 0;

    //
    // Verify the size of frame is not greater than allowed.
    //

    sof = pfs.sb.pfs_sof;
    if (sof > PFS_MAXIMUM_REGISTER_SIZE) {
        sof = PFS_MAXIMUM_REGISTER_SIZE;
        pfs.sb.pfs_sof = PFS_MAXIMUM_REGISTER_SIZE;
    }

    //
    // Verify the size of locals is not greater than size of frame.
    //

    if (sof < pfs.sb.pfs_sol) {
        pfs.sb.pfs_sol = sof;
    }

    //
    // Verify the size of locals is not greater than size of frame.
    //

    if (sof < (pfs.sb.pfs_sor * 8)) {
        pfs.sb.pfs_sor = sof / 8;
    }

    //
    // Verify rename bases are less than the size of the rotaing regions.
    //

    if (pfs.sb.pfs_rrb_gr >= (pfs.sb.pfs_sor * 8)) {
        pfs.sb.pfs_rrb_gr = 0;
    }

    if (pfs.sb.pfs_rrb_fr >= PFS_MAXIMUM_REGISTER_SIZE) {
        pfs.sb.pfs_rrb_fr = 0;
    }

    if (pfs.sb.pfs_rrb_pr >= PFS_MAXIMUM_PREDICATE_SIZE) {
        pfs.sb.pfs_rrb_pr = 0;
    }

    return(pfs.ull);

}

//
// Macro used to zero the software field of RSC that contains the size of
// RSE frame to be preloaded on kernel exit
//

#define ZERO_PRELOAD_SIZE(RseRsc)  \
    (RseRsc & ~(((1i64 << RSC_LOADRS_LEN)-1) << RSC_MBZ1))

//
// Macro used to sanitize the RSC
//

#define SANITIZE_RSC(RseRsc)

extern ULONGLONG KiIA64DCR;

#define SANITIZE_DCR(dcr, mode)  \
    ((mode) == KernelMode ? dcr : KiIA64DCR)

//
// Macro to sanitize debug registers
//

#define SANITIZE_DR(dr, mode)  \
    ((mode) == KernelMode ?  \
        (dr) :  \
        (dr & ~(0x7i64 << DR_PLM0)) /* disable pl 0-2 */  \
    )




#define SANITIZE_AR21_FCR(FCR,mode) \
    (((FCR)&0x0000FFBF00001F3Fi64)|0x40i64)

#define SANITIZE_AR24_EFLAGS(EFLAGS,mode) \
    (((EFLAGS)&0x00000000003E0DD7i64)|0x02i64)

#define SANITIZE_AR27_CFLG(CFLG,mode) \
    ((CFLG)&(0x000007FFE005003Fi64))

#define SANITIZE_AR28_FSR(FSR,mode) \
    ((FSR)&0x0000FFBF5555FFFFi64)

#define SANITIZE_AR29_FIR(FIR,mode) \
    ((FIR)&0x07FFFFFFFFFFFFFFi64)

#define SANITIZE_AR30_FDR(FDR,mode) \
    ((FDR)&0x0000FFFFFFFFFFFFi64)



// begin_nthal

//
// Define interrupt request physical address (maps to HAL virtual address)
//

#define INTERRUPT_REQUEST_PHYSICAL_ADDRESS  0xFFE00000

//
// Define Address of Processor Control Registers.
//


//
// Define Pointer to Processor Control Registers.
//

#define KIPCR ((ULONG_PTR)(KADDRESS_BASE + 0xFFFF0000))            // kernel address of first PCR
#define PCR ((volatile KPCR * const)KIPCR)

//
// Define address for epc system calls
//

#define MM_EPC_VA (KADDRESS_BASE + 0xFFA00000)

//
// Define Base Address of PAL Mapping 
// 
//

#define HAL_PAL_VIRTUAL_ADDRESS (KADDRESS_BASE + 0xE0000000)


// begin_ntddk begin_wdm begin_ntosp

#define KI_USER_SHARED_DATA ((ULONG_PTR)(KADDRESS_BASE + 0xFFFE0000))
#define SharedUserData ((KUSER_SHARED_DATA * const)KI_USER_SHARED_DATA)

//
// Prototype for get current IRQL. **** TBD (read TPR)
//

NTKERNELAPI
KIRQL
KeGetCurrentIrql();

// end_wdm

//
// Get address of current processor block.
//

#define KeGetCurrentPrcb() PCR->Prcb

//
// Get address of processor control region.
//

#define KeGetPcr() PCR

//
// Get address of current kernel thread object.
//

#if defined(_M_IA64)
#define KeGetCurrentThread() PCR->CurrentThread
#endif

//
// Get current processor number.
//

#define KeGetCurrentProcessorNumber() PCR->Number

//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() PCR->DcacheFillSize

// end_ntddk end_nthal end_ntosp

//
// Test if executing a DPC.
//


BOOLEAN
KeIsExecutingDpc (
    VOID
    );


//
// Save & Restore floating point state
//
// begin_ntddk begin_wdm begin_ntosp

#define KeSaveFloatingPointState(a)         STATUS_SUCCESS
#define KeRestoreFloatingPointState(a)      STATUS_SUCCESS

// end_ntddk end_wdm end_ntosp


//++
//
//
// VOID
// KeMemoryBarrier (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function cases ordering of memory acceses as seen by other processors.
//
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#if defined (NT_UP)

#define KeMemoryBarrier()

#else

#define KE_MEMORY_BARRIER_REQUIRED

#define KeMemoryBarrier() __mf ()

#endif

// begin_ntddk begin_nthal begin_ntndis begin_wdm begin_ntosp

//
// Define the page size
//

#define PAGE_SIZE 0x2000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 13L

// end_ntddk end_nthal end_ntndis end_wdm end_ntosp

// begin_nthal
//
// IA64 hardware structures
//


//
// A Page Table Entry on an IA64 has the following definition.
//

#define _HARDWARE_PTE_WORKING_SET_BITS  11

typedef struct _HARDWARE_PTE {
    ULONG64 Valid : 1;
    ULONG64 Rsvd0 : 1;
    ULONG64 Cache : 3;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 Owner : 2;
    ULONG64 Execute : 1;
    ULONG64 Write : 1;
    ULONG64 Rsvd1 : PAGE_SHIFT - 12;
    ULONG64 CopyOnWrite : 1;
    ULONG64 PageFrameNumber : 50 - PAGE_SHIFT;
    ULONG64 Rsvd2 : 2;
    ULONG64 Exception : 1;
    ULONGLONG SoftwareWsIndex : _HARDWARE_PTE_WORKING_SET_BITS;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// Fill TB entry
//
// Filling TB entry on demand by VHPT H/W seems faster than done by s/w.
// Determining I/D side of TLB, disabling/enabling PSR.i and ic bits,
// serialization, writing to IIP, IDA, IDTR and IITR seem just too much
// compared to VHPT searching it automatically.
//

#define KiVhptEntry(va)  ((PVOID)__thash((__int64)va))
#define KiVhptEntryTag(va)  ((ULONGLONG)__ttag((__int64)va))

#define KiFlushSingleTb(Invalid, va)                   \
    __ptcl((__int64)va,PAGE_SHIFT << 2);  __isrlz()

#define KeFillEntryTb(PointerPte, Virtual, Invalid)    \
       KiFlushSingleTb(0, Virtual);                    \

#define KiFlushFixedInstTb(Invalid, va)   \
    __ptri((__int64)va, PAGE_SHIFT << 2); __isrlz()

#define KiFlushFixedDataTb(Invalid, va)   \
    __ptrd((__int64)va, PAGE_SHIFT << 2); __dsrlz()


NTKERNELAPI
VOID
KeFillLargeEntryTb (
    IN HARDWARE_PTE Pte[2],
    IN PVOID Virtual,
    IN ULONG PageSize
    );

//
// Fill TB fixed entry
//

NTKERNELAPI
VOID
KeFillFixedEntryTb (
    IN HARDWARE_PTE Pte[2],
    IN PVOID Virtual,
    IN ULONG PageSize,
    IN ULONG Index
    );

NTKERNELAPI
VOID
KeFillFixedLargeEntryTb (
    IN HARDWARE_PTE Pte[2],
    IN PVOID Virtual,
    IN ULONG PageSize,
    IN ULONG Index
    );

#define INST_TB_BASE 0x80000000
#define DATA_TB_BASE 0

#define INST_TB_KERNEL_INDEX          (INST_TB_BASE|ITR_KERNEL_INDEX)
#define INST_TB_EPC_INDEX             (INST_TB_BASE|ITR_EPC_INDEX)
#define INST_TB_HAL_INDEX             (INST_TB_BASE|ITR_HAL_INDEX)
#define INST_TB_PAL_INDEX             (INST_TB_BASE|ITR_PAL_INDEX)

#define DATA_TB_DRIVER0_INDEX         (DATA_TB_BASE|DTR_DRIVER0_INDEX)
#define DATA_TB_DRIVER1_INDEX         (DATA_TB_BASE|DTR_DRIVER1_INDEX)
#define DATA_TB_KTBASE_INDEX          (DATA_TB_BASE|DTR_KTBASE_INDEX)
#define DATA_TB_UTBASE_INDEX          (DATA_TB_BASE|DTR_UTBASE_INDEX)
#define DATA_TB_STBASE_INDEX          (DATA_TB_BASE|DTR_STBASE_INDEX)
#define DATA_TB_IOPORT_INDEX          (DATA_TB_BASE|DTR_IO_PORT_INDEX)
#define DATA_TB_KTBASE_TMP_INDEX      (DATA_TB_BASE|DTR_KTBASE_INDEX_TMP)
#define DATA_TB_UTBASE_TMP_INDEX      (DATA_TB_BASE|DTR_UTBASE_INDEX_TMP)
#define DATA_TB_HAL_INDEX             (DATA_TB_BASE|DTR_HAL_INDEX)
#define DATA_TB_PAL_INDEX             (DATA_TB_BASE|DTR_PAL_INDEX)

//
// Fill Inst TB entry
//

NTKERNELAPI
VOID
KeFillInstEntryTb (
    IN HARDWARE_PTE Pte,
    IN PVOID Virtual
    );

NTKERNELAPI
VOID
KeFlushCurrentTb (
    VOID
    );

//
// Get a VHPT entry address
//

PVOID
KiVhptEntry64(
   IN ULONG VirtualPageNumber
   );

//
// Get a VHPT entry TAG value
//

ULONGLONG
KiVhptEntryTag64(
    IN ULONG VirtualPageNumber
    );

//
// Fill a VHPT entry
//

VOID
KiFillEntryVhpt(
   IN PHARDWARE_PTE PointerPte,
   IN PVOID Virtual
   );


//
// Flush the kernel portions of Tb
//


VOID
KeFlushKernelTb(
    IN BOOLEAN AllProcessors
    );

//
// Flush the user portions of Tb
//

VOID
KeFlushUserTb(
    IN BOOLEAN AllProcessors
    );



//
// Data cache, instruction cache, I/O buffer, and write buffer flush routine
// prototypes.
//

NTKERNELAPI
VOID
KeChangeColorPage (
    IN PVOID NewColor,
    IN PVOID OldColor,
    IN ULONG PageFrame
    );

NTKERNELAPI
VOID
KeSweepDcache (
    IN BOOLEAN AllProcessors
    );

#define KeSweepCurrentDcache()

NTKERNELAPI
VOID
KeSweepIcache (
    IN BOOLEAN AllProcessors
    );

NTKERNELAPI
VOID
KeSweepIcacheRange (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );

NTKERNELAPI
VOID
KeSweepCurrentIcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );

#define KeSweepCurrentIcache()

NTKERNELAPI
VOID
KeSweepCacheRangeWithDrain (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG Length
    );

// begin_ntddk begin_ntndis begin_wdm begin_ntosp
//
// Cache and write buffer flush functions.
//

NTKERNELAPI
VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );

// end_ntddk end_ntndis end_wdm end_ntosp

//
// Clock, profile, and interprocessor interrupt functions.
//

struct _KEXCEPTION_FRAME;
struct _KTRAP_FRAME;

NTKERNELAPI
VOID
KeIpiInterrupt (
    IN struct _KTRAP_FRAME *TrapFrame
    );

#define KeYieldProcessor()

NTKERNELAPI
VOID
KeProfileInterrupt (
    IN struct _KTRAP_FRAME *TrapFrame
    );

NTKERNELAPI
VOID
KeProfileInterruptWithSource (
    IN struct _KTRAP_FRAME *TrapFrame,
    IN KPROFILE_SOURCE ProfileSource
    );

NTKERNELAPI
VOID
KeUpdateRunTime (
    IN struct _KTRAP_FRAME *TrapFrame
    );

NTKERNELAPI
VOID
KeUpdateSystemTime (
    IN struct _KTRAP_FRAME *TrapFrame,
    IN ULONG Increment
    );

//
// The following function prototypes are exported for use in MP HALs.
//

#if defined(NT_UP)

#define KiAcquireSpinLock(SpinLock)

#else

NTKERNELAPI
VOID
KiAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

#if defined(NT_UP)

#define KiReleaseSpinLock(SpinLock)

#else

VOID
KiReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

// #define KiReleaseSpinLock _ReleaseSpinLock

#endif

//
// KeTestSpinLock may be used to spin at low IRQL until the lock is
// available.  The IRQL must then be raised and the lock acquired with
// KeTryToAcquireSpinLock.  If that fails, lower the IRQL and start again.
//

#if defined(NT_UP)

#define KeTestSpinLock(SpinLock) (TRUE)

#else

BOOLEAN
KeTestSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

//
// Define cache error routine type and prototype.
//

typedef
VOID
(*PKCACHE_ERROR_ROUTINE) (
    VOID
    );

NTKERNELAPI
VOID
KeSetCacheErrorRoutine (
    IN PKCACHE_ERROR_ROUTINE Routine
    );

// begin_ntddk begin_wdm

//
// Kernel breakin breakpoint
//

VOID
KeBreakinBreakpoint (
    VOID
    );

// end_ntddk end_nthal end_wdm

//
// Define executive macros for acquiring and releasing executive spinlocks.
// These macros can ONLY be used by executive components and NOT by drivers.
// Drivers MUST use the kernel interfaces since they must be MP enabled on
// all systems.
//

#if defined(NT_UP) && !defined(_NTDDK_) && !defined(_NTIFS_)
#define ExAcquireSpinLock(Lock, OldIrql) KeRaiseIrql(DISPATCH_LEVEL, (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock)
#else

// begin_wdm begin_ntddk begin_ntosp

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

// end_wdm end_ntddk end_ntosp

#endif

//
// The acquire and release fast lock macros disable and enable interrupts
// on UP nondebug systems. On MP or debug systems, the spinlock routines
// are used.
//
// N.B. Extreme caution should be observed when using these routines.
//

#if defined(_M_IA64)

VOID
_disable (
    VOID
    );

VOID
_enable (
    VOID
    );

#pragma intrinsic(_disable)
#pragma intrinsic(_enable)

#endif

#if defined(NT_UP) && !DBG
#define ExAcquireFastLock(Lock, OldIrql) _disable()
#else
#define ExAcquireFastLock(Lock, OldIrql) \
    ExAcquireSpinLock(Lock, OldIrql)
#endif

#if defined(NT_UP) && !DBG
#define ExReleaseFastLock(Lock, OldIrql) _enable()
#else
#define ExReleaseFastLock(Lock, OldIrql) \
    ExReleaseSpinLock(Lock, OldIrql)
#endif

//
// Data and instruction bus error function prototypes.
//

BOOLEAN
KeBusError (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame,
    IN PVOID VirtualAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress
    );

VOID
KiDataBusError (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiInstructionBusError (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

//
// Define query tick count macro.
//
// begin_ntddk begin_nthal begin_ntosp

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// begin_wdm

#define KeQueryTickCount(CurrentCount ) \
    *(PULONGLONG)(CurrentCount) = **((volatile ULONGLONG **)(&KeTickCount));

// end_wdm

#else

// end_ntddk end_nthal end_ntosp

#define KiQueryTickCount(CurrentCount) \
    *(PULONGLONG)(CurrentCount) = KeTickCount.QuadPart;

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// end_ntddk end_nthal end_ntosp

//
// The following function prototypes must be in the module since they are
// machine dependent.
//

ULONG
KiEmulateBranch (
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

BOOLEAN
KiEmulateFloating (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN OUT struct _KTRAP_FRAME *TrapFrame
    );

BOOLEAN
KiEmulateReference (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN OUT struct _KTRAP_FRAME *TrapFrame
    );

ULONGLONG
KiGetRegisterValue (
    IN ULONG Register,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiSetRegisterValue (
    IN ULONG Register,
    IN ULONGLONG Value,
    OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    OUT struct _KTRAP_FRAME *TrapFrame
    );

FLOAT128
KiGetFloatRegisterValue (
    IN ULONG Register,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame,
    IN struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiSetFloatRegisterValue (
    IN ULONG Register,
    IN FLOAT128 Value,
    OUT struct _KEXCEPTION_FRAME *ExceptionFrame,
    OUT struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiAdvanceInstPointer(
    IN OUT struct _KTRAP_FRAME *TrapFrame
    );

VOID
KiRequestSoftwareInterrupt (
    KIRQL RequestIrql
    );

// begin_ntddk begin_nthal begin_ntndis begin_wdm begin_ntosp
//
// I/O space read and write macros.
//

NTHALAPI
UCHAR
READ_PORT_UCHAR (
    PUCHAR RegisterAddress
    );

NTHALAPI
USHORT
READ_PORT_USHORT (
    PUSHORT RegisterAddress
    );

NTHALAPI
ULONG
READ_PORT_ULONG (
    PULONG RegisterAddress
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR (
    PUCHAR portAddress,
    UCHAR  Data
    );

NTHALAPI
VOID
WRITE_PORT_USHORT (
    PUSHORT portAddress,
    USHORT  Data
    );

NTHALAPI
VOID
WRITE_PORT_ULONG (
    PULONG portAddress,
    ULONG  Data
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG writeBuffer,
    ULONG  writeCount
    );


#define READ_REGISTER_UCHAR(x) \
    (__mf(), *(volatile UCHAR * const)(x))

#define READ_REGISTER_USHORT(x) \
    (__mf(), *(volatile USHORT * const)(x))

#define READ_REGISTER_ULONG(x) \
    (__mf(), *(volatile ULONG * const)(x))

#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \
    PUCHAR registerBuffer = x;                                          \
    PUCHAR readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \
    PUSHORT registerBuffer = x;                                         \
    PUSHORT readBuffer = y;                                             \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \
    PULONG registerBuffer = x;                                          \
    PULONG readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \
    }                                                                   \
}

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_USHORT(x, y) {   \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_ULONG(x, y) {    \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \
    PUCHAR registerBuffer = x;                                            \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \
    PUSHORT registerBuffer = x;                                           \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \
    PULONG registerBuffer = x;                                            \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

// end_ntddk end_ntndis end_wdm end_ntosp



//
// Higher FP volatile
//
//  This structure defines the higher FP volatile registers.
//

typedef struct _KHIGHER_FP_VOLATILE {
    // volatile higher floating registers f32 - f127
    FLOAT128 FltF32;
    FLOAT128 FltF33;
    FLOAT128 FltF34;
    FLOAT128 FltF35;
    FLOAT128 FltF36;
    FLOAT128 FltF37;
    FLOAT128 FltF38;
    FLOAT128 FltF39;
    FLOAT128 FltF40;
    FLOAT128 FltF41;
    FLOAT128 FltF42;
    FLOAT128 FltF43;
    FLOAT128 FltF44;
    FLOAT128 FltF45;
    FLOAT128 FltF46;
    FLOAT128 FltF47;
    FLOAT128 FltF48;
    FLOAT128 FltF49;
    FLOAT128 FltF50;
    FLOAT128 FltF51;
    FLOAT128 FltF52;
    FLOAT128 FltF53;
    FLOAT128 FltF54;
    FLOAT128 FltF55;
    FLOAT128 FltF56;
    FLOAT128 FltF57;
    FLOAT128 FltF58;
    FLOAT128 FltF59;
    FLOAT128 FltF60;
    FLOAT128 FltF61;
    FLOAT128 FltF62;
    FLOAT128 FltF63;
    FLOAT128 FltF64;
    FLOAT128 FltF65;
    FLOAT128 FltF66;
    FLOAT128 FltF67;
    FLOAT128 FltF68;
    FLOAT128 FltF69;
    FLOAT128 FltF70;
    FLOAT128 FltF71;
    FLOAT128 FltF72;
    FLOAT128 FltF73;
    FLOAT128 FltF74;
    FLOAT128 FltF75;
    FLOAT128 FltF76;
    FLOAT128 FltF77;
    FLOAT128 FltF78;
    FLOAT128 FltF79;
    FLOAT128 FltF80;
    FLOAT128 FltF81;
    FLOAT128 FltF82;
    FLOAT128 FltF83;
    FLOAT128 FltF84;
    FLOAT128 FltF85;
    FLOAT128 FltF86;
    FLOAT128 FltF87;
    FLOAT128 FltF88;
    FLOAT128 FltF89;
    FLOAT128 FltF90;
    FLOAT128 FltF91;
    FLOAT128 FltF92;
    FLOAT128 FltF93;
    FLOAT128 FltF94;
    FLOAT128 FltF95;
    FLOAT128 FltF96;
    FLOAT128 FltF97;
    FLOAT128 FltF98;
    FLOAT128 FltF99;
    FLOAT128 FltF100;
    FLOAT128 FltF101;
    FLOAT128 FltF102;
    FLOAT128 FltF103;
    FLOAT128 FltF104;
    FLOAT128 FltF105;
    FLOAT128 FltF106;
    FLOAT128 FltF107;
    FLOAT128 FltF108;
    FLOAT128 FltF109;
    FLOAT128 FltF110;
    FLOAT128 FltF111;
    FLOAT128 FltF112;
    FLOAT128 FltF113;
    FLOAT128 FltF114;
    FLOAT128 FltF115;
    FLOAT128 FltF116;
    FLOAT128 FltF117;
    FLOAT128 FltF118;
    FLOAT128 FltF119;
    FLOAT128 FltF120;
    FLOAT128 FltF121;
    FLOAT128 FltF122;
    FLOAT128 FltF123;
    FLOAT128 FltF124;
    FLOAT128 FltF125;
    FLOAT128 FltF126;
    FLOAT128 FltF127;

} KHIGHER_FP_VOLATILE, *PKHIGHER_FP_VOLATILE;

//
// Debug registers
//
// This structure defines the hardware debug registers.
// We allow space for 4 pairs of instruction and 4 pairs of data debug registers
// The hardware may actually have more.
//

typedef struct _KDEBUG_REGISTERS {

    ULONGLONG DbI0;
    ULONGLONG DbI1;
    ULONGLONG DbI2;
    ULONGLONG DbI3;
    ULONGLONG DbI4;
    ULONGLONG DbI5;
    ULONGLONG DbI6;
    ULONGLONG DbI7;

    ULONGLONG DbD0;
    ULONGLONG DbD1;
    ULONGLONG DbD2;
    ULONGLONG DbD3;
    ULONGLONG DbD4;
    ULONGLONG DbD5;
    ULONGLONG DbD6;
    ULONGLONG DbD7;

} KDEBUG_REGISTERS, *PKDEBUG_REGISTERS;

//
// misc. application registers (mapped to IA-32 registers)
//

typedef struct _KAPPLICATION_REGISTERS {
    ULONGLONG Ar21;
    ULONGLONG Ar24;
    ULONGLONG Ar25;
    ULONGLONG Ar26;
    ULONGLONG Ar27;
    ULONGLONG Ar28;
    ULONGLONG Ar29;
    ULONGLONG Ar30;
} KAPPLICATION_REGISTERS, *PKAPPLICATION_REGISTERS;

//
// performance registers
//

typedef struct _KPERFORMANCE_REGISTERS {
    ULONGLONG Perfr0;
    ULONGLONG Perfr1;
    ULONGLONG Perfr2;
    ULONGLONG Perfr3;
    ULONGLONG Perfr4;
    ULONGLONG Perfr5;
    ULONGLONG Perfr6;
    ULONGLONG Perfr7;
} KPERFORMANCE_REGISTERS, *PKPERFORMANCE_REGISTERS;

//
// Thread State save area. Currently, beginning of Kernel Stack
//
// This structure defines the area for:
//
//      higher fp register save/restore
//      user debug register save/restore.
//
// The order of these area is significant.
//

typedef struct _KTHREAD_STATE_SAVEAREA {

    KAPPLICATION_REGISTERS AppRegisters;
    KPERFORMANCE_REGISTERS PerfRegisters;
    KHIGHER_FP_VOLATILE HigherFPVolatile;
    KDEBUG_REGISTERS DebugRegisters;

} KTHREAD_STATE_SAVEAREA, *PKTHREAD_STATE_SAVEAREA;

#define KTHREAD_STATE_SAVEAREA_LENGTH ((sizeof(KTHREAD_STATE_SAVEAREA) + 15) & ~((ULONG_PTR)15))

#define GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(StackBase)     \
    (PKHIGHER_FP_VOLATILE) &(((PKTHREAD_STATE_SAVEAREA)(((ULONG_PTR)StackBase - sizeof(KTHREAD_STATE_SAVEAREA)) & ~((ULONG_PTR)15)))->HigherFPVolatile)

#define GET_DEBUG_REGISTER_SAVEAREA()                       \
    (PKDEBUG_REGISTERS) &(((PKTHREAD_STATE_SAVEAREA)(((ULONG_PTR)KeGetCurrentThread()->StackBase - sizeof(KTHREAD_STATE_SAVEAREA)) & ~((ULONG_PTR)15)))->DebugRegisters)

#define GET_APPLICATION_REGISTER_SAVEAREA(StackBase)     \
    (PKAPPLICATION_REGISTERS) &(((PKTHREAD_STATE_SAVEAREA)(((ULONG_PTR)StackBase - sizeof(KTHREAD_STATE_SAVEAREA)) & ~((ULONG_PTR)15)))->AppRegisters)


//
// Exception frame
//
//  This frame is established when handling an exception. It provides a place
//  to save all preserved registers. The volatile registers will already
//  have been saved in a trap frame. Also used as part of switch frame built
//  at thread switch.
//
//  The frame is 16-byte aligned to maintain 16-byte alignment for the stack,
//

typedef struct _KEXCEPTION_FRAME {


    // Preserved application registers
    ULONGLONG ApEC;       // epilogue count
    ULONGLONG ApLC;       // loop count
    ULONGLONG IntNats;    // Nats for S0-S3; i.e. ar.UNAT after spill

    // Preserved (saved) interger registers, s0-s3
    ULONGLONG IntS0;
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;

    // Preserved (saved) branch registers, bs0-bs4
    ULONGLONG BrS0;
    ULONGLONG BrS1;
    ULONGLONG BrS2;
    ULONGLONG BrS3;
    ULONGLONG BrS4;

    // Preserved (saved) floating point registers, f2 - f5, f16 - f31
    FLOAT128 FltS0;
    FLOAT128 FltS1;
    FLOAT128 FltS2;
    FLOAT128 FltS3;
    FLOAT128 FltS4;
    FLOAT128 FltS5;
    FLOAT128 FltS6;
    FLOAT128 FltS7;
    FLOAT128 FltS8;
    FLOAT128 FltS9;
    FLOAT128 FltS10;
    FLOAT128 FltS11;
    FLOAT128 FltS12;
    FLOAT128 FltS13;
    FLOAT128 FltS14;
    FLOAT128 FltS15;
    FLOAT128 FltS16;
    FLOAT128 FltS17;
    FLOAT128 FltS18;
    FLOAT128 FltS19;


} KEXCEPTION_FRAME, *PKEXCEPTION_FRAME;


//
// Switch frame
//
//  This frame is established when doing a thread switch in SwapContext. It
//  provides a place to save the preserved kernel state at the point of the
//  switch registers.
//  The volatile registers are scratch across the call to SwapContext.
//
//  The frame is 16-byte aligned to maintain 16-byte alignment for the stack,
//

typedef struct _KSWITCH_FRAME {

    ULONGLONG SwitchPredicates; // Predicates for Switch
    ULONGLONG SwitchRp;         // return pointer for Switch
    ULONGLONG SwitchPFS;        // PFS for Switch
    ULONGLONG SwitchFPSR;   // ProcessorFP status at thread switch
    ULONGLONG SwitchBsp;
    ULONGLONG SwitchRnat;
    // ULONGLONG Pad;

    KEXCEPTION_FRAME SwitchExceptionFrame;

} KSWITCH_FRAME, *PKSWITCH_FRAME;

// Trap frame
//  This frame is established when handling a trap. It provides a place to
//  save all volatile registers. The nonvolatile registers are saved in an
//  exception frame or through the normal C calling conventions for saved
//  registers.  Its size must be a multiple of 16 bytes.
//
//  N.B - the 16-byte alignment is required to maintain the stack alignment.
//

#define KTRAP_FRAME_ARGUMENTS (8 * 8)       // up to 8 in-memory syscall args


typedef struct _KTRAP_FRAME {

    //
    // Reserved for additional memory arguments and stack scratch area
    // The size of Reserved[] must be a multiple of 16 bytes.
    //

    ULONGLONG Reserved[(KTRAP_FRAME_ARGUMENTS+16)/8];

    // Temporary (volatile) FP registers - f6-f15 (don't use f32+ in kernel)
    FLOAT128 FltT0;
    FLOAT128 FltT1;
    FLOAT128 FltT2;
    FLOAT128 FltT3;
    FLOAT128 FltT4;
    FLOAT128 FltT5;
    FLOAT128 FltT6;
    FLOAT128 FltT7;
    FLOAT128 FltT8;
    FLOAT128 FltT9;

    // Temporary (volatile) interger registers
    ULONGLONG IntGp;    // global pointer (r1)
    ULONGLONG IntT0;
    ULONGLONG IntT1;
                        // The following 4 registers fill in space of preserved  (S0-S3) to align Nats
    ULONGLONG ApUNAT;   // ar.UNAT on kernel entry
    ULONGLONG ApCCV;    // ar.CCV
    ULONGLONG ApDCR;    // DCR register on kernel entry
    ULONGLONG Preds;    // Predicates

    ULONGLONG IntV0;    // return value (r8)
    ULONGLONG IntT2;
    ULONGLONG IntT3;
    ULONGLONG IntT4;
    ULONGLONG IntSp;    // stack pointer (r12)
    ULONGLONG IntTeb;   // teb (r13)
    ULONGLONG IntT5;
    ULONGLONG IntT6;
    ULONGLONG IntT7;
    ULONGLONG IntT8;
    ULONGLONG IntT9;
    ULONGLONG IntT10;
    ULONGLONG IntT11;
    ULONGLONG IntT12;
    ULONGLONG IntT13;
    ULONGLONG IntT14;
    ULONGLONG IntT15;
    ULONGLONG IntT16;
    ULONGLONG IntT17;
    ULONGLONG IntT18;
    ULONGLONG IntT19;
    ULONGLONG IntT20;
    ULONGLONG IntT21;
    ULONGLONG IntT22;

    ULONGLONG IntNats;  // Temporary (volatile) registers' Nats directly from ar.UNAT at point of spill

    ULONGLONG BrRp;     // Return pointer on kernel entry

    ULONGLONG BrT0;     // Temporary (volatile) branch registers (b6-b7)
    ULONGLONG BrT1;

    // Register stack info
    ULONGLONG RsRSC;    // RSC on kernel entry
    ULONGLONG RsBSP;    // BSP on kernel entry
    ULONGLONG RsBSPSTORE; // User BSP Store at point of switch to kernel backing store
    ULONGLONG RsRNAT;   // old RNAT at point of switch to kernel backing store
    ULONGLONG RsPFS;    // PFS on kernel entry

    // Trap Status Information
    ULONGLONG StIPSR;   // Interruption Processor Status Register
    ULONGLONG StIIP;    // Interruption IP
    ULONGLONG StIFS;    // Interruption Function State
    ULONGLONG StFPSR;   // FP status
    ULONGLONG StISR;    // Interruption Status Register
    ULONGLONG StIFA;    // Interruption Data Address
    ULONGLONG StIIPA;   // Last executed bundle address
    ULONGLONG StIIM;    // Interruption Immediate
    ULONGLONG StIHA;    // Interruption Hash Address

    ULONG OldIrql;      // Previous Irql.
    ULONG PreviousMode; // Previous Mode.
    ULONGLONG TrapFrame;// Previous Trap Frame

    //
    // Exception record
    //
    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD) + 15) & (~15)];

    // End of frame marker (for debugging)
    ULONGLONG Handler;  // Handler for this trap
    ULONGLONG EOFMarker;
} KTRAP_FRAME, *PKTRAP_FRAME;

#define KTRAP_FRAME_LENGTH ((sizeof(KTRAP_FRAME) + 15) & (~15))
#define KTRAP_FRAME_ALIGN (16)
#define KTRAP_FRAME_ROUND (KTRAP_FRAME_ALIGN - 1)
#define KTRAP_FRAME_EOF 0xe0f0e0f0e0f0e000i64

//
// Use the lowest 4 bits of EOFMarker field to encode the trap frame type
//

#define SYSCALL_FRAME      0
#define INTERRUPT_FRAME    1
#define EXCEPTION_FRAME    2
#define CONTEXT_FRAME      10

#define TRAP_FRAME_TYPE(tf)  (tf->EOFMarker & 0xf)

//
// Define the kernel mode and user mode callback frame structures.
//

//
// The frame saved by KiCallUserMode is defined here to allow
// the kernel debugger to trace the entire kernel stack
// when usermode callouts are pending.
//
// N.B. The size of the following structure must be a multiple of 16 bytes
//      and it must be 16-byte aligned.
//

typedef struct _KCALLOUT_FRAME {


    ULONGLONG   BrRp;
    ULONGLONG   RsPFS;
    ULONGLONG   Preds;
    ULONGLONG   ApUNAT;
    ULONGLONG   ApLC;
    ULONGLONG   RsRNAT;
    ULONGLONG   IntNats;

    ULONGLONG   IntS0;
    ULONGLONG   IntS1;
    ULONGLONG   IntS2;
    ULONGLONG   IntS3;

    ULONGLONG   BrS0;
    ULONGLONG   BrS1;
    ULONGLONG   BrS2;
    ULONGLONG   BrS3;
    ULONGLONG   BrS4;

    FLOAT128    FltS0;          // 16-byte aligned boundary
    FLOAT128    FltS1;
    FLOAT128    FltS2;
    FLOAT128    FltS3;
    FLOAT128    FltS4;
    FLOAT128    FltS5;
    FLOAT128    FltS6;
    FLOAT128    FltS7;
    FLOAT128    FltS8;
    FLOAT128    FltS9;
    FLOAT128    FltS10;
    FLOAT128    FltS11;
    FLOAT128    FltS12;
    FLOAT128    FltS13;
    FLOAT128    FltS14;
    FLOAT128    FltS15;
    FLOAT128    FltS16;
    FLOAT128    FltS17;
    FLOAT128    FltS18;
    FLOAT128    FltS19;

    ULONGLONG   A0;             // saved argument registers a0-a2
    ULONGLONG   A1;
    ULONGLONG   CbStk;          // saved callback stack address
    ULONGLONG   InStack;        // saved initial stack address
    ULONGLONG   CbBStore;       // saved callback stack address
    ULONGLONG   InBStore;       // saved initial stack address
    ULONGLONG   TrFrame;        // saved callback trap frame address
    ULONGLONG   TrStIIP;        // saved continuation address


} KCALLOUT_FRAME, *PKCALLOUT_FRAME;


typedef struct _UCALLOUT_FRAME {
    PVOID Buffer;
    ULONG Length;
    ULONG ApiNumber;
    ULONGLONG IntSp;
    ULONGLONG RsPFS;
    ULONGLONG BrRp;
    ULONGLONG Pad;
} UCALLOUT_FRAME, *PUCALLOUT_FRAME;


// end_nthal

// begin_ntddk begin_wdm begin_ntosp
//
// Non-volatile floating point state
//

typedef struct _KFLOATING_SAVE {
    ULONG   Reserved;
} KFLOATING_SAVE, *PKFLOATING_SAVE;

// end_ntddk end_wdm end_ntosp

#define STATUS_IA64_INVALID_STACK     STATUS_BAD_STACK

//
// iA32 control bits definition
//
//
// Define constants to access the bits in CR0.
//

#define CR0_PG  0x80000000          // paging
#define CR0_ET  0x00000010          // extension type (80387)
#define CR0_TS  0x00000008          // task switched
#define CR0_EM  0x00000004          // emulate math coprocessor
#define CR0_MP  0x00000002          // math present
#define CR0_PE  0x00000001          // protection enable

//
// More CR0 bits; these only apply to the 80486.
//

#define CR0_CD  0x40000000          // cache disable
#define CR0_NW  0x20000000          // not write-through
#define CR0_AM  0x00040000          // alignment mask
#define CR0_WP  0x00010000          // write protect
#define CR0_NE  0x00000020          // numeric error

//
// Define constants to access CFLG bits
//
#define CFLG_IO 0x00000040          // IO bit map checking on
#define CFLG_IF 0x00000080          // EFLAG.if to control external interrupt
#define CFLG_II 0x00000100          // enable EFLAG.if interception

//
// CR4 bits;  These only apply to Pentium
//
#define CR4_VME 0x00000001          // V86 mode extensions
#define CR4_PVI 0x00000002          // Protected mode virtual interrupts
#define CR4_TSD 0x00000004          // Time stamp disable
#define CR4_DE  0x00000008          // Debugging Extensions
#define CR4_PSE 0x00000010          // Page size extensions
#define CR4_PAE 0x00000020          // Physical address extensions
#define CR4_MCE 0x00000040          // Machine check enable
#define CR4_PGE 0x00000080          // Page global enable
#define CR4_FXSR 0x00000200         // FXSR used by OS
#define CR4_XMMEXCPT 0x00000400     // XMMI used by OS

//
// Define constants to access ThNpxState
//

#define NPX_STATE_NOT_LOADED    (CR0_TS | CR0_MP)
#define NPX_STATE_LOADED        0

//
// begin_nthal
//
// Machine type definitions
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2

//
// PAL Interface
//
// iA-64 defined PAL function IDs in decimal format as in the PAL spec
// All PAL calls done through HAL. HAL may block some calls
//

#define PAL_CACHE_FLUSH                                       1I64
#define PAL_CACHE_INFO                                        2I64
#define PAL_CACHE_INIT                                        3I64
#define PAL_CACHE_SUMMARY                                     4I64
#define PAL_PTCE_INFO                                         6I64
#define PAL_MEM_ATTRIB                                        5I64
#define PAL_VM_INFO                                           7I64
#define PAL_VM_SUMMARY                                        8I64
#define PAL_BUS_GET_FEATURES                                  9I64
#define PAL_BUS_SET_FEATURES                                 10I64
#define PAL_DEBUG_INFO                                       11I64
#define PAL_FIXED_ADDR                                       12I64
#define PAL_FREQ_BASE                                        13I64
#define PAL_FREQ_RATIOS                                      14I64
#define PAL_PERF_MON_INFO                                    15I64
#define PAL_PLATFORM_ADDR                                    16I64
#define PAL_PROC_GET_FEATURES                                17I64
#define PAL_PROC_SET_FEATURES                                18I64
#define PAL_RSE_INFO                                         19I64
#define PAL_VERSION                                          20I64
#define PAL_MC_CLEAR_LOG                                     21I64
#define PAL_MC_DRAIN                                         22I64
#define PAL_MC_EXPECTED                                      23I64
#define PAL_MC_DYNAMIC_STATE                                 24I64
#define PAL_MC_ERROR_INFO                                    25I64
#define PAL_MC_RESUME                                        26I64
#define PAL_MC_REGISTER_MEM                                  27I64
#define PAL_HALT                                             28I64
#define PAL_HALT_LIGHT                                       29I64
#define PAL_COPY_INFO                                        30I64
#define PAL_CACHE_LINE_INIT                                  31I64
#define PAL_PMI_ENTRYPOINT                                   32I64
#define PAL_ENTER_IA_32_ENV                                  33I64
#define PAL_VM_PAGE_SIZE                                     34I64
#define PAL_MEM_FOR_TEST                                     37I64
#define PAL_CACHE_PROT_INFO                                  38I64
#define PAL_REGISTER_INFO                                    39I64
#define PAL_SHUTDOWN                                         44I64
#define PAL_PREFETCH_VISIBILITY                              41I64

#define PAL_COPY_PAL                                        256I64
#define PAL_HALT_INFO                                       257I64
#define PAL_TEST_PROC                                       258I64
#define PAL_CACHE_READ                                      259I64
#define PAL_CACHE_WRITE                                     260I64
#define PAL_VM_TR_READ                                      261I64

//
// iA-64 defined PAL return values
//

#define PAL_STATUS_INVALID_CACHELINE                          1I64
#define PAL_STATUS_SUPPORT_NOT_NEEDED                         1I64
#define PAL_STATUS_SUCCESS                                    0
#define PAL_STATUS_NOT_IMPLEMENTED                           -1I64
#define PAL_STATUS_INVALID_ARGUMENT                          -2I64
#define PAL_STATUS_ERROR                                     -3I64
#define PAL_STATUS_UNABLE_TO_INIT_CACHE_LEVEL_AND_TYPE       -4I64
#define PAL_STATUS_NOT_FOUND_IN_CACHE                        -5I64
#define PAL_STATUS_NO_ERROR_INFO_AVAILABLE                   -6I64


// end_nthal


//
// Define constants used in selector tests.
//
//  RPL_MASK is the real value for extracting RPL values.  IT IS THE WRONG
//  CONSTANT TO USE FOR MODE TESTING.
//
//  MODE_MASK is the value for deciding the current mode.
//  WARNING:    MODE_MASK assumes that all code runs at either ring-0
//              or ring-3.  Ring-1 or Ring-2 support will require changing
//              this value and all of the code that refers to it.

#define MODE_MASK    1
#define RPL_MASK     3

//
// SetProcessInformation Structure for ProcessSetIoHandlers info class
//

typedef struct _PROCESS_IO_PORT_HANDLER_INFORMATION {
    BOOLEAN Install;            // true if handlers to be installed
    ULONG NumEntries;
    ULONG Context;
    PEMULATOR_ACCESS_ENTRY EmulatorAccessEntries;
} PROCESS_IO_PORT_HANDLER_INFORMATION, *PPROCESS_IO_PORT_HANDLER_INFORMATION;

//
// Definitions that used by CSD and SSD
//
#define USER_CODE_DESCRIPTOR  0xCFBFFFFF00000000i64
#define USER_DATA_DESCRIPTOR  0xCF3FFFFF00000000i64

//
// Used for cleaning up ia32 contexts
// This is taken from i386.h
//
#define EFLAGS_DF_MASK        0x00000400L
#define EFLAGS_INTERRUPT_MASK 0x00000200L
#define EFLAGS_V86_MASK       0x00020000L
#define EFLAGS_ALIGN_CHECK    0x00040000L
#define EFLAGS_IOPL_MASK      0x00003000L
#define EFLAGS_VIF            0x00080000L
#define EFLAGS_VIP            0x00100000L
#define EFLAGS_USER_SANITIZE  0x003e0dd7L


// begin_windbgkd begin_nthal

#ifdef _IA64_

//
// Stack Registers for IA64
//

typedef struct _STACK_REGISTERS {


    ULONGLONG IntR32;
    ULONGLONG IntR33;
    ULONGLONG IntR34;
    ULONGLONG IntR35;
    ULONGLONG IntR36;
    ULONGLONG IntR37;
    ULONGLONG IntR38;
    ULONGLONG IntR39;

    ULONGLONG IntR40;
    ULONGLONG IntR41;
    ULONGLONG IntR42;
    ULONGLONG IntR43;
    ULONGLONG IntR44;
    ULONGLONG IntR45;
    ULONGLONG IntR46;
    ULONGLONG IntR47;
    ULONGLONG IntR48;
    ULONGLONG IntR49;

    ULONGLONG IntR50;
    ULONGLONG IntR51;
    ULONGLONG IntR52;
    ULONGLONG IntR53;
    ULONGLONG IntR54;
    ULONGLONG IntR55;
    ULONGLONG IntR56;
    ULONGLONG IntR57;
    ULONGLONG IntR58;
    ULONGLONG IntR59;

    ULONGLONG IntR60;
    ULONGLONG IntR61;
    ULONGLONG IntR62;
    ULONGLONG IntR63;
    ULONGLONG IntR64;
    ULONGLONG IntR65;
    ULONGLONG IntR66;
    ULONGLONG IntR67;
    ULONGLONG IntR68;
    ULONGLONG IntR69;

    ULONGLONG IntR70;
    ULONGLONG IntR71;
    ULONGLONG IntR72;
    ULONGLONG IntR73;
    ULONGLONG IntR74;
    ULONGLONG IntR75;
    ULONGLONG IntR76;
    ULONGLONG IntR77;
    ULONGLONG IntR78;
    ULONGLONG IntR79;

    ULONGLONG IntR80;
    ULONGLONG IntR81;
    ULONGLONG IntR82;
    ULONGLONG IntR83;
    ULONGLONG IntR84;
    ULONGLONG IntR85;
    ULONGLONG IntR86;
    ULONGLONG IntR87;
    ULONGLONG IntR88;
    ULONGLONG IntR89;

    ULONGLONG IntR90;
    ULONGLONG IntR91;
    ULONGLONG IntR92;
    ULONGLONG IntR93;
    ULONGLONG IntR94;
    ULONGLONG IntR95;
    ULONGLONG IntR96;
    ULONGLONG IntR97;
    ULONGLONG IntR98;
    ULONGLONG IntR99;

    ULONGLONG IntR100;
    ULONGLONG IntR101;
    ULONGLONG IntR102;
    ULONGLONG IntR103;
    ULONGLONG IntR104;
    ULONGLONG IntR105;
    ULONGLONG IntR106;
    ULONGLONG IntR107;
    ULONGLONG IntR108;
    ULONGLONG IntR109;

    ULONGLONG IntR110;
    ULONGLONG IntR111;
    ULONGLONG IntR112;
    ULONGLONG IntR113;
    ULONGLONG IntR114;
    ULONGLONG IntR115;
    ULONGLONG IntR116;
    ULONGLONG IntR117;
    ULONGLONG IntR118;
    ULONGLONG IntR119;

    ULONGLONG IntR120;
    ULONGLONG IntR121;
    ULONGLONG IntR122;
    ULONGLONG IntR123;
    ULONGLONG IntR124;
    ULONGLONG IntR125;
    ULONGLONG IntR126;
    ULONGLONG IntR127;
                                 // Nat bits for stack registers
    ULONGLONG IntNats2;          // r32-r95 in bit positions 1 to 63
    ULONGLONG IntNats3;          // r96-r127 in bit position 1 to 31


} STACK_REGISTERS, *PSTACK_REGISTERS;



//
// Special Registers for IA64
//

typedef struct _KSPECIAL_REGISTERS {

    // Kernel debug breakpoint registers

    ULONGLONG KernelDbI0;         // Instruction debug registers
    ULONGLONG KernelDbI1;
    ULONGLONG KernelDbI2;
    ULONGLONG KernelDbI3;
    ULONGLONG KernelDbI4;
    ULONGLONG KernelDbI5;
    ULONGLONG KernelDbI6;
    ULONGLONG KernelDbI7;

    ULONGLONG KernelDbD0;         // Data debug registers
    ULONGLONG KernelDbD1;
    ULONGLONG KernelDbD2;
    ULONGLONG KernelDbD3;
    ULONGLONG KernelDbD4;
    ULONGLONG KernelDbD5;
    ULONGLONG KernelDbD6;
    ULONGLONG KernelDbD7;

    // Kernel performance monitor registers

    ULONGLONG KernelPfC0;         // Performance configuration registers
    ULONGLONG KernelPfC1;
    ULONGLONG KernelPfC2;
    ULONGLONG KernelPfC3;
    ULONGLONG KernelPfC4;
    ULONGLONG KernelPfC5;
    ULONGLONG KernelPfC6;
    ULONGLONG KernelPfC7;

    ULONGLONG KernelPfD0;         // Performance data registers
    ULONGLONG KernelPfD1;
    ULONGLONG KernelPfD2;
    ULONGLONG KernelPfD3;
    ULONGLONG KernelPfD4;
    ULONGLONG KernelPfD5;
    ULONGLONG KernelPfD6;
    ULONGLONG KernelPfD7;

    // kernel bank shadow (hidden) registers

    ULONGLONG IntH16;
    ULONGLONG IntH17;
    ULONGLONG IntH18;
    ULONGLONG IntH19;
    ULONGLONG IntH20;
    ULONGLONG IntH21;
    ULONGLONG IntH22;
    ULONGLONG IntH23;
    ULONGLONG IntH24;
    ULONGLONG IntH25;
    ULONGLONG IntH26;
    ULONGLONG IntH27;
    ULONGLONG IntH28;
    ULONGLONG IntH29;
    ULONGLONG IntH30;
    ULONGLONG IntH31;

    // Application Registers

    //       - CPUID Registers - AR
    ULONGLONG ApCPUID0; // Cpuid Register 0
    ULONGLONG ApCPUID1; // Cpuid Register 1
    ULONGLONG ApCPUID2; // Cpuid Register 2
    ULONGLONG ApCPUID3; // Cpuid Register 3
    ULONGLONG ApCPUID4; // Cpuid Register 4
    ULONGLONG ApCPUID5; // Cpuid Register 5
    ULONGLONG ApCPUID6; // Cpuid Register 6
    ULONGLONG ApCPUID7; // Cpuid Register 7

    //       - Kernel Registers - AR
    ULONGLONG ApKR0;    // Kernel Register 0 (User RO)
    ULONGLONG ApKR1;    // Kernel Register 1 (User RO)
    ULONGLONG ApKR2;    // Kernel Register 2 (User RO)
    ULONGLONG ApKR3;    // Kernel Register 3 (User RO)
    ULONGLONG ApKR4;    // Kernel Register 4
    ULONGLONG ApKR5;    // Kernel Register 5
    ULONGLONG ApKR6;    // Kernel Register 6
    ULONGLONG ApKR7;    // Kernel Register 7

    ULONGLONG ApITC;    // Interval Timer Counter

    // Global control registers

    ULONGLONG ApITM;    // Interval Timer Match register
    ULONGLONG ApIVA;    // Interrupt Vector Address
    ULONGLONG ApPTA;    // Page Table Address
    ULONGLONG ApGPTA;   // ia32 Page Table Address

    ULONGLONG StISR;    // Interrupt status
    ULONGLONG StIFA;    // Interruption Faulting Address
    ULONGLONG StITIR;   // Interruption TLB Insertion Register
    ULONGLONG StIIPA;   // Interruption Instruction Previous Address (RO)
    ULONGLONG StIIM;    // Interruption Immediate register (RO)
    ULONGLONG StIHA;    // Interruption Hash Address (RO)

    //       - External Interrupt control registers (SAPIC)
    ULONGLONG SaLID;    // Local SAPIC ID
    ULONGLONG SaIVR;    // Interrupt Vector Register (RO)
    ULONGLONG SaTPR;    // Task Priority Register
    ULONGLONG SaEOI;    // End Of Interrupt
    ULONGLONG SaIRR0;   // Interrupt Request Register 0 (RO)
    ULONGLONG SaIRR1;   // Interrupt Request Register 1 (RO)
    ULONGLONG SaIRR2;   // Interrupt Request Register 2 (RO)
    ULONGLONG SaIRR3;   // Interrupt Request Register 3 (RO)
    ULONGLONG SaITV;    // Interrupt Timer Vector
    ULONGLONG SaPMV;    // Performance Monitor Vector
    ULONGLONG SaCMCV;   // Corrected Machine Check Vector
    ULONGLONG SaLRR0;   // Local Interrupt Redirection Vector 0
    ULONGLONG SaLRR1;   // Local Interrupt Redirection Vector 1

    // System Registers
    //       - Region registers
    ULONGLONG Rr0;  // Region register 0
    ULONGLONG Rr1;  // Region register 1
    ULONGLONG Rr2;  // Region register 2
    ULONGLONG Rr3;  // Region register 3
    ULONGLONG Rr4;  // Region register 4
    ULONGLONG Rr5;  // Region register 5
    ULONGLONG Rr6;  // Region register 6
    ULONGLONG Rr7;  // Region register 7

    //      - Protection Key registers
    ULONGLONG Pkr0;     // Protection Key register 0
    ULONGLONG Pkr1;     // Protection Key register 1
    ULONGLONG Pkr2;     // Protection Key register 2
    ULONGLONG Pkr3;     // Protection Key register 3
    ULONGLONG Pkr4;     // Protection Key register 4
    ULONGLONG Pkr5;     // Protection Key register 5
    ULONGLONG Pkr6;     // Protection Key register 6
    ULONGLONG Pkr7;     // Protection Key register 7
    ULONGLONG Pkr8;     // Protection Key register 8
    ULONGLONG Pkr9;     // Protection Key register 9
    ULONGLONG Pkr10;    // Protection Key register 10
    ULONGLONG Pkr11;    // Protection Key register 11
    ULONGLONG Pkr12;    // Protection Key register 12
    ULONGLONG Pkr13;    // Protection Key register 13
    ULONGLONG Pkr14;    // Protection Key register 14
    ULONGLONG Pkr15;    // Protection Key register 15

    //      -  Translation Lookaside buffers
    ULONGLONG TrI0;     // Instruction Translation Register 0
    ULONGLONG TrI1;     // Instruction Translation Register 1
    ULONGLONG TrI2;     // Instruction Translation Register 2
    ULONGLONG TrI3;     // Instruction Translation Register 3
    ULONGLONG TrI4;     // Instruction Translation Register 4
    ULONGLONG TrI5;     // Instruction Translation Register 5
    ULONGLONG TrI6;     // Instruction Translation Register 6
    ULONGLONG TrI7;     // Instruction Translation Register 7

    ULONGLONG TrD0;     // Data Translation Register 0
    ULONGLONG TrD1;     // Data Translation Register 1
    ULONGLONG TrD2;     // Data Translation Register 2
    ULONGLONG TrD3;     // Data Translation Register 3
    ULONGLONG TrD4;     // Data Translation Register 4
    ULONGLONG TrD5;     // Data Translation Register 5
    ULONGLONG TrD6;     // Data Translation Register 6
    ULONGLONG TrD7;     // Data Translation Register 7

    //      -  Machine Specific Registers
    ULONGLONG SrMSR0;   // Machine Specific Register 0
    ULONGLONG SrMSR1;   // Machine Specific Register 1
    ULONGLONG SrMSR2;   // Machine Specific Register 2
    ULONGLONG SrMSR3;   // Machine Specific Register 3
    ULONGLONG SrMSR4;   // Machine Specific Register 4
    ULONGLONG SrMSR5;   // Machine Specific Register 5
    ULONGLONG SrMSR6;   // Machine Specific Register 6
    ULONGLONG SrMSR7;   // Machine Specific Register 7

} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;


//
// Processor State structure.
//

typedef struct _KPROCESSOR_STATE {
    struct _CONTEXT ContextFrame;
    struct _KSPECIAL_REGISTERS SpecialRegisters;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _IA64_

// end_windbgkd end_nthal

// begin_nthal begin_ntddk begin_ntosp

//
// Processor Control Block (PRCB)
//

#define PRCB_MINOR_VERSION 1
#define PRCB_MAJOR_VERSION 1
#define PRCB_BUILD_DEBUG        0x0001
#define PRCB_BUILD_UNIPROCESSOR 0x0002

struct _RESTART_BLOCK;

typedef struct _KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
//

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *RESTRICTED_POINTER NextThread;
    struct _KTHREAD *IdleThread;
    CCHAR Number;
    CCHAR WakeIdle;
    USHORT BuildType;
    KAFFINITY SetMember;
    struct _RESTART_BLOCK *RestartBlock;
    ULONG_PTR PcrPage;
    ULONG Spare0[4];

//
// Processor Idendification Registers.
//

    ULONG     ProcessorModel;
    ULONG     ProcessorRevision;
    ULONG     ProcessorFamily;
    ULONG     ProcessorArchRev;
    ULONGLONG ProcessorSerialNumber;
    ULONGLONG ProcessorFeatureBits;
    UCHAR     ProcessorVendorString[16];

//
// Space reserved for the system.
//

    ULONGLONG SystemReserved[8];

//
// Space reserved for the HAL.
//

    ULONGLONG HalReserved[16];

//
// End of the architecturally defined section of the PRCB.
// end_nthal end_ntddk end_ntosp
//

    ULONG DpcTime;
    ULONG InterruptTime;
    ULONG KernelTime;
    ULONG UserTime;
    ULONG InterruptCount;
    ULONG DispatchInterruptCount;
    ULONG Spare1[5];
    ULONG PageColor;

//
// MP information.
//

    struct _KNODE * ParentNode;         // Node this processor is a member of
    PVOID Spare2;
    PVOID Spare3;
    volatile ULONG IpiFrozen;
    struct _KPROCESSOR_STATE ProcessorState;

//
//  Per-processor data for various hot code which resides in the
//  kernel image. Each processor is given it's own copy of the data
//  to lessen the cache impact of sharing the data between multiple
//  processors.
//

//
//  Spares (formerly fsrtl filelock free lists)
//

    PVOID SpareHotData[2];

//
//  Cache manager performance counters.
//

    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadNotPossible;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;

//
// Kernel performance counters.
//

    ULONG KeAlignmentFixupCount;
    ULONG KeContextSwitches;
    ULONG KeDcacheFlushCount;
    ULONG KeExceptionDispatchCount;
    ULONG KeFirstLevelTbFills;
    ULONG KeFloatingEmulationCount;
    ULONG KeIcacheFlushCount;
    ULONG KeSecondLevelTbFills;
    ULONG KeSystemCalls;

//
//  Reserved for future counters.
//

    ULONG ReservedCounter[8];

//
// I/O IRP float.
//

    LONG LookasideIrpFloat;

    UCHAR MoreSpareHotData[52];

//
// Nonpaged per processor lookaside lists.
//

    PP_LOOKASIDE_LIST PPLookasideList[16];

//
// Nonpaged per processor small pool lookaside lists.
//

    PP_LOOKASIDE_LIST PPNPagedLookasideList[POOL_SMALL_LISTS];

//
// Paged per processor small pool lookaside lists.
//

    PP_LOOKASIDE_LIST PPPagedLookasideList[POOL_SMALL_LISTS];

//
// Per processor lock queue entries.
//

    KSPIN_LOCK_QUEUE LockQueue[16];

    UCHAR ReservedPad[(3 * 8) - 4];

//
// MP interprocessor request packet barrier.
//
// N.B. This is carefully allocated in a different cache line from
//      the request packet.
//

    volatile ULONG PacketBarrier;

//
// MP interprocessor request packet and summary.
//
// N.B. This is carefully aligned to be on a cache line boundary.
//

    volatile PVOID CurrentPacket[3];
    volatile KAFFINITY TargetSet;
    volatile PKIPI_WORKER WorkerRoutine;

// N.B. Place MHz here so we can keep alignment and size
// of this structure unchanged.
    ULONG MHz;
    ULONG CachePad0;
    ULONGLONG CachePad1[10];

//
// N.B. These two longwords must be on a quadword boundary and adjacent.
//

    volatile ULONG RequestSummary;
    volatile struct _KPRCB *SignalDone;

//
// Spare counters.
//

    ULONGLONG Spare4[14];

//
// DPC interrupt requested.
//

    ULONG DpcInterruptRequested;
    ULONGLONG Spare5[15];
    ULONG MaximumDpcQueueDepth;
    ULONG MinimumDpcRate;
    ULONG AdjustDpcThreshold;
    ULONG DpcRequestRate;
    LARGE_INTEGER StartCount;

//
// DPC list head, spinlock, and count.
//

    LIST_ENTRY DpcListHead;
    KSPIN_LOCK DpcLock;
    ULONG DpcCount;
    ULONG DpcLastCount;
    ULONG QuantumEnd;
    ULONG DpcRoutineActive;
    ULONG DpcQueueDepth;

//
// Debug & Processor Information
//

    BOOLEAN SkipTick;
    UCHAR Spare6;

//
// Processor ID from HAL (ACPI ID/EID).
//

    USHORT ProcessorId;

//
// Address of MP interprocessor operation counters.
//

    PKIPI_COUNTS IpiCounts;

//
// Processors power state
//
    PROCESSOR_POWER_STATE PowerState;

// begin_nthal begin_ntddk begin_ntosp
} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

// begin_ntndis

//
// OS_MCA, OS_INIT HandOff State definitions
//
// Note: The following definitions *must* match the definiions of the
//       corresponding SAL Revision Hand-Off structures.
//

typedef struct _SAL_HANDOFF_STATE   {
    ULONGLONG     PalProcEntryPoint;
    ULONGLONG     SalProcEntryPoint;
    ULONGLONG     SalGlobalPointer;
     LONGLONG     RendezVousResult;
    ULONGLONG     SalReturnAddress;
    ULONGLONG     MinStateSavePtr;
} SAL_HANDOFF_STATE, *PSAL_HANDOFF_STATE;

typedef struct _OS_HANDOFF_STATE    {
    ULONGLONG     Result;
    ULONGLONG     SalGlobalPointer;
    ULONGLONG     MinStateSavePtr;
    ULONGLONG     SalReturnAddress;
    ULONGLONG     NewContextFlag;
} OS_HANDOFF_STATE, *POS_HANDOFF_STATE;

//
// per processor OS_MCA and OS_INIT resource structure
//


#define SER_EVENT_STACK_FRAME_ENTRIES    8

typedef struct _SAL_EVENT_RESOURCES {

    SAL_HANDOFF_STATE   SalToOsHandOff;
    OS_HANDOFF_STATE    OsToSalHandOff;
    PVOID               StateDump;
    ULONGLONG           StateDumpPhysical;
    PVOID               BackStore;
    ULONGLONG           BackStoreLimit;
    PVOID               Stack;
    ULONGLONG           StackLimit;
    PULONGLONG          PTOM;
    ULONGLONG           StackFrame[SER_EVENT_STACK_FRAME_ENTRIES];
    PVOID               EventPool;
    ULONG               EventPoolSize;
} SAL_EVENT_RESOURCES, *PSAL_EVENT_RESOURCES;

//
// PAL Mini-save area, used by MCA and INIT
//

typedef struct _PAL_MINI_SAVE_AREA {
    ULONGLONG IntNats;      //  Nat bits for r1-r31
                            //  r1-r31 in bits 1 thru 31.
    ULONGLONG IntGp;        //  r1, volatile
    ULONGLONG IntT0;        //  r2-r3, volatile
    ULONGLONG IntT1;        //
    ULONGLONG IntS0;        //  r4-r7, preserved
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;
    ULONGLONG IntV0;        //  r8, volatile
    ULONGLONG IntT2;        //  r9-r11, volatile
    ULONGLONG IntT3;
    ULONGLONG IntT4;
    ULONGLONG IntSp;        //  stack pointer (r12), special
    ULONGLONG IntTeb;       //  teb (r13), special
    ULONGLONG IntT5;        //  r14-r31, volatile
    ULONGLONG IntT6;

    ULONGLONG B0R16;        // Bank 0 registers 16-31
    ULONGLONG B0R17;        
    ULONGLONG B0R18;        
    ULONGLONG B0R19;        
    ULONGLONG B0R20;        
    ULONGLONG B0R21;        
    ULONGLONG B0R22;        
    ULONGLONG B0R23;        
    ULONGLONG B0R24;        
    ULONGLONG B0R25;        
    ULONGLONG B0R26;        
    ULONGLONG B0R27;        
    ULONGLONG B0R28;        
    ULONGLONG B0R29;        
    ULONGLONG B0R30;        
    ULONGLONG B0R31;        

    ULONGLONG IntT7;        // Bank 1 registers 16-31
    ULONGLONG IntT8;
    ULONGLONG IntT9;
    ULONGLONG IntT10;
    ULONGLONG IntT11;
    ULONGLONG IntT12;
    ULONGLONG IntT13;
    ULONGLONG IntT14;
    ULONGLONG IntT15;
    ULONGLONG IntT16;
    ULONGLONG IntT17;
    ULONGLONG IntT18;
    ULONGLONG IntT19;
    ULONGLONG IntT20;
    ULONGLONG IntT21;
    ULONGLONG IntT22;

    ULONGLONG Preds;        //  predicates, preserved
    ULONGLONG BrRp;         //  return pointer, b0, preserved
    ULONGLONG RsRSC;        //  RSE configuration, volatile
    ULONGLONG StIIP;        //  Interruption IP
    ULONGLONG StIPSR;       //  Interruption Processor Status
    ULONGLONG StIFS;        //  Interruption Function State
    ULONGLONG XIP;          //  Event IP
    ULONGLONG XPSR;         //  Event Processor Status
    ULONGLONG XFS;          //  Event Function State
    
} PAL_MINI_SAVE_AREA, *PPAL_MINI_SAVE_AREA;

//
// Define Processor Control Region Structure.
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Major and minor version numbers of the PCR.
//
    ULONG MinorVersion;
    ULONG MajorVersion;

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

//
// First and second level cache parameters.
//

    ULONG FirstLevelDcacheSize;
    ULONG FirstLevelDcacheFillSize;
    ULONG FirstLevelIcacheSize;
    ULONG FirstLevelIcacheFillSize;
    ULONG SecondLevelDcacheSize;
    ULONG SecondLevelDcacheFillSize;
    ULONG SecondLevelIcacheSize;
    ULONG SecondLevelIcacheFillSize;

//
// Data cache alignment and fill size used for cache flushing and alignment.
// These fields are set to the larger of the first and second level data
// cache fill sizes.
//

    ULONG DcacheAlignment;
    ULONG DcacheFillSize;

//
// Instruction cache alignment and fill size used for cache flushing and
// alignment. These fields are set to the larger of the first and second
// level data cache fill sizes.
//

    ULONG IcacheAlignment;
    ULONG IcacheFillSize;

//
// Processor identification from PrId register.
//

    ULONG ProcessorId;

//
// Profiling data.
//

    ULONG ProfileInterval;
    ULONG ProfileCount;

//
// Stall execution count and scale factor.
//

    ULONG StallExecutionCount;
    ULONG StallScaleFactor;

    ULONG InterruptionCount;

//
// Space reserved for the system.
//

    ULONGLONG   SystemReserved[6];

//
// Space reserved for the HAL
//

    ULONGLONG   HalReserved[64];

//
// IRQL mapping tables.
//

    UCHAR IrqlMask[64];
    UCHAR IrqlTable[64];

//
// External Interrupt vectors.
//

    PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];

//
// Reserved interrupt vector mask.
//

    ULONG ReservedVectors;

//
// Processor affinity mask.
//

    KAFFINITY SetMember;

//
// Complement of the processor affinity mask.
//

    KAFFINITY NotMember;

//
// Pointer to processor control block.
//

    struct _KPRCB *Prcb;

//
//  Shadow copy of Prcb->CurrentThread for fast access
//

    struct _KTHREAD *CurrentThread;

//
// Processor number.
//

    CCHAR Number;                        // Processor Number
    UCHAR DebugActive;                   // debug register active in user flag
    UCHAR KernelDebugActive;             // debug register active in kernel flag
    UCHAR CurrentIrql;                   // Current IRQL
    union {
        USHORT SoftwareInterruptPending; // Software Interrupt Pending Flag
        struct {
            UCHAR ApcInterrupt;          // 0x01 if APC int pending
            UCHAR DispatchInterrupt;     // 0x01 if dispatch int pending
        };
    };

//
// Address of per processor SAPIC EOI Table
//

    PVOID       EOITable;

//
// IA-64 Machine Check Events trackers
//

    UCHAR       InOsMca;
    UCHAR       InOsInit;
    UCHAR       InOsCmc;
    UCHAR       InOsCpe;
    ULONG       InOsULONG_Spare; // Spare ULONG
    PSAL_EVENT_RESOURCES OsMcaResourcePtr;
    PSAL_EVENT_RESOURCES OsInitResourcePtr;

//
// End of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

// end_nthal end_ntddk

//
// OS Part
//

//
//  Address of the thread who currently owns the high fp register set
//

    struct _KTHREAD *HighFpOwner;

//  Per processor kernel (ntoskrnl.exe) global pointer
    ULONGLONG   KernelGP;
//  Per processor initial kernel stack for current thread
    ULONGLONG   InitialStack;
//  Per processor pointer to kernel BSP
    ULONGLONG   InitialBStore;
//  Per processor kernel stack limit
    ULONGLONG   StackLimit;
//  Per processor kernel backing store limit
    ULONGLONG   BStoreLimit;
//  Per processor panic kernel stack
    ULONGLONG   PanicStack;

//
//  Save area for kernel entry/exit
//
    ULONGLONG   SavedIIM;
    ULONGLONG   SavedIFA;

    ULONGLONG   ForwardProgressBuffer[16];
    PVOID       Pcb;      // holds KPROCESS for MP region synchronization

//
//  Nt page table base addresses
//
    ULONGLONG   PteUbase;
    ULONGLONG   PteKbase;
    ULONGLONG   PteSbase;
    ULONGLONG   PdeUbase;
    ULONGLONG   PdeKbase;
    ULONGLONG   PdeSbase;
    ULONGLONG   PdeUtbase;
    ULONGLONG   PdeKtbase;
    ULONGLONG   PdeStbase;

//
//  The actual resources for the OS_INIT and OS_MCA handlers
//  are placed at the end of the PCR structure so that auto
//  can be used to get to get between the public and private
//  sections of the PCR in the traps and context routines.
//
    SAL_EVENT_RESOURCES OsMcaResource;
    SAL_EVENT_RESOURCES OsInitResource;

// begin_nthal begin_ntddk

} KPCR, *PKPCR;

// end_nthal end_ntddk end_ntosp

// begin_nthal

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT PAGE_SHIFT

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT (PTI_SHIFT + PAGE_SHIFT - PTE_SHIFT)
#define PDI1_SHIFT (PDI_SHIFT + PAGE_SHIFT - PTE_SHIFT)
#define PDI_MASK ((1 << (PAGE_SHIFT - PTE_SHIFT)) - 1)

//
// Define the number of bits to shift to left to produce page table offset
// from page table index.
//

#define PTE_SHIFT 3

//
// Define the number of bits to shift to the right justify the Page Directory
// Table Entry field.
//

#define VHPT_PDE_BITS 40

//
// Define the RID for IO Port Space.
//

#define RR_IO_PORT 6


//
// The following definitions are required for the debugger data block.
//

// begin_ntddk begin_ntosp

//
// The highest user address reserves 64K bytes for a guard page. This
// the probing of address from kernel mode to only have to check the
// starting address for structures of 64k bytes or less.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG_PTR MmUserProbeAddress;


#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_USER_PROBE_ADDRESS MmUserProbeAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS  (PVOID)((ULONG_PTR)(UADDRESS_BASE+0x00010000))

// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(PLabelAddress) \
    MmLockPagableDataSection((PVOID)(*((PULONGLONG)PLabelAddress)))

#define VRN_MASK   0xE000000000000000UI64    // Virtual Region Number mask

// end_ntddk end_wdm end_ntosp

//
// Limit the IA32 subsystem to a 2GB virtual address space.
// This means "Large Address Aware" apps are not supported in emulation mode.
//

#define MM_MAX_WOW64_ADDRESS       (0x00000000080000000UI64)

#define MI_HIGHEST_USER_ADDRESS (PVOID) (ULONG_PTR)((UADDRESS_BASE + 0x6FC00000000 - 0x10000 - 1)) // highest user address
#define MI_USER_PROBE_ADDRESS ((ULONG_PTR)(UADDRESS_BASE + 0x6FC00000000UI64 - 0x10000)) // starting address of guard page
#define MI_SYSTEM_RANGE_START (PVOID) (UADDRESS_BASE + 0x6FC00000000) // start of system space

//
// Define the page table base and the page directory base for
// the TB miss routines and memory management.
//
//
// user/kernel page table base and top addresses
//

extern ULONG_PTR KiIA64VaSignedFill;
extern ULONG_PTR KiIA64PtaSign;

#define PTA_SIGN KiIA64PtaSign
#define VA_FILL KiIA64VaSignedFill

#define SADDRESS_BASE 0x2000000000000000UI64  // session base address

#define PTE_UBASE  PCR->PteUbase
#define PTE_KBASE  PCR->PteKbase
#define PTE_SBASE  PCR->PteSbase

#define PTE_UTOP (PTE_UBASE|(((ULONG_PTR)1 << PDI1_SHIFT) - 1)) // top level PDR address (user)
#define PTE_KTOP (PTE_KBASE|(((ULONG_PTR)1 << PDI1_SHIFT) - 1)) // top level PDR address (kernel)
#define PTE_STOP (PTE_SBASE|(((ULONG_PTR)1 << PDI1_SHIFT) - 1)) // top level PDR address (session)

//
// Second level user and kernel PDR address
//

#define PDE_UBASE  PCR->PdeUbase
#define PDE_KBASE  PCR->PdeKbase
#define PDE_SBASE  PCR->PdeSbase

#define PDE_UTOP (PDE_UBASE|(((ULONG_PTR)1 << PDI_SHIFT) - 1)) // second level PDR address (user)
#define PDE_KTOP (PDE_KBASE|(((ULONG_PTR)1 << PDI_SHIFT) - 1)) // second level PDR address (kernel)
#define PDE_STOP (PDE_SBASE|(((ULONG_PTR)1 << PDI_SHIFT) - 1)) // second level PDR address (session)

//
// 8KB first level user and kernel PDR address
//

#define PDE_UTBASE PCR->PdeUtbase
#define PDE_KTBASE PCR->PdeKtbase
#define PDE_STBASE PCR->PdeStbase

#define PDE_USELFMAP (PDE_UTBASE|(PAGE_SIZE - (1<<PTE_SHIFT))) // self mapped PPE address (user)
#define PDE_KSELFMAP (PDE_KTBASE|(PAGE_SIZE - (1<<PTE_SHIFT))) // self mapped PPE address (kernel)
#define PDE_SSELFMAP (PDE_STBASE|(PAGE_SIZE - (1<<PTE_SHIFT))) // self mapped PPE address (kernel)

#define PTE_BASE    PTE_UBASE
#define PDE_BASE    PDE_UBASE
#define PDE_TBASE   PDE_UTBASE
#define PDE_SELFMAP PDE_USELFMAP

#define KSEG0_BASE (KADDRESS_BASE + 0x80000000)           // base of kernel
#define KSEG2_BASE (KADDRESS_BASE + 0xA0000000)           // end of kernel

#define KSEG3_BASE 0x8000000000000000UI64
#define KSEG3_LIMIT 0x8000100000000000UI64

#define KSEG4_BASE 0xA000000000000000UI64
#define KSEG4_LIMIT 0xA000100000000000UI64

//
//++
//PVOID
//KSEG_ADDRESS (
//    IN ULONG PAGE
//    );
//
// Routine Description:
//
//    This macro returns a KSEG virtual address which maps the page.
//
// Arguments:
//
//    PAGE - Supplies the physical page frame number
//
// Return Value:
//
//    The address of the KSEG address
//
//--

#define KSEG_ADDRESS(PAGE) ((PVOID)(KSEG3_BASE | ((ULONG_PTR)(PAGE) << PAGE_SHIFT)))

#define KSEG4_ADDRESS(PAGE) ((PVOID)(KSEG4_BASE | ((ULONG_PTR)(PAGE) << PAGE_SHIFT)))


#define MAXIMUM_FWP_BUFFER_ENTRY 8

typedef struct _REGION_MAP_INFO {
    ULONG RegionId;
    ULONG PageSize;
    ULONGLONG SequenceNumber;
} REGION_MAP_INFO, *PREGION_MAP_INFO;

// begin_ntddk begin_wdm
//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS ((PVOID)((ULONG_PTR)(KADDRESS_BASE + 0xC0C00000)))
// end_nthal end_ntddk end_wdm

#define SYSTEM_BASE (KADDRESS_BASE + 0xC3000000)          // start of system space (no typecast)

//
// Define macro to initialize directory table base.
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase, pfn)   \
    *((PULONGLONG)(dirbase)) = 0;                       \
    ((PHARDWARE_PTE)(dirbase))->PageFrameNumber = pfn;  \
    ((PHARDWARE_PTE)(dirbase))->Accessed = 1;           \
    ((PHARDWARE_PTE)(dirbase))->Dirty = 1;              \
    ((PHARDWARE_PTE)(dirbase))->Cache = 0;              \
    ((PHARDWARE_PTE)(dirbase))->Write = 1;              \
    ((PHARDWARE_PTE)(dirbase))->Valid = 1;


//
// IA64 function definitions
//

//++
//
// BOOLEAN
// KiIsThreadNumericStateSaved(
//     IN PKTHREAD Address
//     )
//
//  This call is used on a not running thread to see if it's numeric
//  state has been saved in it's context information.  On IA64 the
//  numeric state is always saved.
//
//--
#define KiIsThreadNumericStateSaved(a) TRUE

//++
//
// VOID
// KiRundownThread(
//     IN PKTHREAD Address
//     )
//
//--
#define KiRundownThread(a)

//
// ia64 Feature bit definitions
//

#define KF_BRL              0x00000001   // processor supports long branch instruction.

//
// Define macro to test if x86 feature is present.
//
// N.B. All x86 features test TRUE on IA64 systems.
//

#define Isx86FeaturePresent(_f_) TRUE


// begin_nthal begin_ntddk begin_ntndis begin_wdm begin_ntosp
#endif // defined(_IA64_)
// end_nthal end_ntddk end_ntndis end_wdm end_ntosp

#endif // _IA64H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\init.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.h

Abstract:

    Header file for the INIT subcomponent of NTOS

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

--*/

#ifndef _INIT_
#define _INIT_

// begin_ntosp
#define INIT_SYSTEMROOT_LINKNAME "\\SystemRoot"
#define INIT_SYSTEMROOT_DLLPATH  "\\SystemRoot\\System32"
#define INIT_SYSTEMROOT_BINPATH  "\\SystemRoot\\System32"
// end_ntosp

#define INIT_WINPEMODE_NONE                 0x00000000
#define INIT_WINPEMODE_REGULAR              0x00000001
#define INIT_WINPEMODE_INRAM                0x80000000
#define INIT_WINPEMODE_READONLY_MEDIA       0x00000100
#define INIT_WINPEMODE_REMOVABLE_MEDIA      0x00000200


extern UNICODE_STRING NtSystemRoot;
// begin_ntosp
extern ULONG NtBuildNumber;
// end_ntosp
extern ULONG NtMajorVersion;
extern ULONG NtMinorVersion;
extern ULONG CmNtCSDVersion;
extern ULONG CmNtCSDReleaseType;
extern UNICODE_STRING CmVersionString;
extern UNICODE_STRING CmCSDVersionString;

extern const CHAR NtBuildLab[];

extern NLSTABLEINFO InitTableInfo;
extern ULONG InitNlsTableSize;
extern PVOID InitNlsTableBase;
extern ULONG InitAnsiCodePageDataOffset;
extern ULONG InitOemCodePageDataOffset;
extern ULONG InitUnicodeCaseTableDataOffset;
extern PVOID InitNlsSectionPointer;
extern BOOLEAN InitSafeModeOptionPresent;
extern ULONG InitSafeBootMode;

extern BOOLEAN InitIsWinPEMode;
extern ULONG InitWinPEModeType;

#if defined(_M_IX86) || defined(_M_AMD64)

VOID
KiSystemStartup(
    IN PVOID LoaderBlock
    );

#else

VOID
KiSystemStartup( VOID );

#endif

VOID
Phase1Initialization(
    IN PVOID Context
    );

typedef
BOOLEAN
(*PTESTFCN)( VOID );

extern PTESTFCN TestFunction;
extern ULONG InitializationPhase;

#if DBG
extern BOOLEAN ForceNonPagedPool;
extern ULONG MmDebug;
#endif // DBG

#endif // _INIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\i386.h ===
/*++ BUILD Version: 0014    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    i386.h

Abstract:

    This module contains the i386 hardware specific header file.

Author:

    David N. Cutler (davec) 2-Aug-1989

Revision History:

    25-Jan-1990    shielint

                   Added definitions for 8259 ports and commands and
                   macros for 8259 irq# and system irql conversion.

--*/

#ifndef _i386_
#define _i386_


// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

#if defined(_X86_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1
//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

// end_ntddk end_nthal end_ntndis end_wdm end_ntosp


//  NOTE -  KiPcr is only useful for PCR references where we know we
//          won't get context switched between the call to it and the
//          variable reference, OR, were we don't care, (ie TEB pointer)

//  NOTE - bryanwi 11 june 90 - we must not macro out things we export
//      Things like KeFlushIcache and KeFlushDcache cannot be macroed
//      out because external code (like drivers) will want to import
//      them by name.  Therefore, the defines below that turn them into
//      nothing are inappropriate.  But this isn't going to hurt us right
//      now.


//
// Length on interrupt object dispatch code in longwords.
// (shielint) Reserve 9*4 space for ABIOS stack mapping.  If NO
//            ABIOS support the size of DISPATCH_LENGTH should be 74.
//

// begin_nthal

#define NORMAL_DISPATCH_LENGTH 106                  // ntddk wdm
#define DISPATCH_LENGTH NORMAL_DISPATCH_LENGTH      // ntddk wdm


//
// Define constants to access the bits in CR0.
//

#define CR0_PG  0x80000000          // paging
#define CR0_ET  0x00000010          // extension type (80387)
#define CR0_TS  0x00000008          // task switched
#define CR0_EM  0x00000004          // emulate math coprocessor
#define CR0_MP  0x00000002          // math present
#define CR0_PE  0x00000001          // protection enable

//
// More CR0 bits; these only apply to the 80486.
//

#define CR0_CD  0x40000000          // cache disable
#define CR0_NW  0x20000000          // not write-through
#define CR0_AM  0x00040000          // alignment mask
#define CR0_WP  0x00010000          // write protect
#define CR0_NE  0x00000020          // numeric error

//
// CR4 bits;  These only apply to Pentium
//
#define CR4_VME 0x00000001          // V86 mode extensions
#define CR4_PVI 0x00000002          // Protected mode virtual interrupts
#define CR4_TSD 0x00000004          // Time stamp disable
#define CR4_DE  0x00000008          // Debugging Extensions
#define CR4_PSE 0x00000010          // Page size extensions
#define CR4_PAE 0x00000020          // Physical address extensions
#define CR4_MCE 0x00000040          // Machine check enable
#define CR4_PGE 0x00000080          // Page global enable
#define CR4_FXSR 0x00000200         // FXSR used by OS
#define CR4_XMMEXCPT 0x00000400     // XMMI used by OS

// end_nthal

//
// Define constants to access ThNpxState
//

#define NPX_STATE_NOT_LOADED    (CR0_TS | CR0_MP)
#define NPX_STATE_LOADED        0

//
// External references to the labels defined in int.asm
//

extern ULONG KiInterruptTemplate[NORMAL_DISPATCH_LENGTH];
extern PULONG KiInterruptTemplateObject;
extern PULONG KiInterruptTemplateDispatch;
extern PULONG KiInterruptTemplate2ndDispatch;

// begin_ntddk begin_wdm begin_nthal begin_ntosp
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level

#define PROFILE_LEVEL 27            // timer used for profiling.
#define CLOCK1_LEVEL 28             // Interval clock 1 level - Not used on x86
#define CLOCK2_LEVEL 28             // Interval clock 2 level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level

#if defined(NT_UP)

#define SYNCH_LEVEL DISPATCH_LEVEL  // synchronization level - UP system

#else

#define SYNCH_LEVEL (IPI_LEVEL-1)   // synchronization level - MP system

#endif

// end_ntddk end_wdm end_ntosp

#define KiSynchIrql SYNCH_LEVEL     // enable portable code

//
// Machine type definitions
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2

// end_nthal
//
//  The previous values are or'ed into KeI386MachineType.
//

extern ULONG KeI386MachineType;

// begin_nthal
//
// Define constants used in selector tests.
//
//  RPL_MASK is the real value for extracting RPL values.  IT IS THE WRONG
//  CONSTANT TO USE FOR MODE TESTING.
//
//  MODE_MASK is the value for deciding the current mode.
//  WARNING:    MODE_MASK assumes that all code runs at either ring-0
//              or ring-3.  Ring-1 or Ring-2 support will require changing
//              this value and all of the code that refers to it.

#define MODE_MASK    1      // ntosp
#define RPL_MASK     3

//
// SEGMENT_MASK is used to throw away trash part of segment.  Part always
// pushes or pops 32 bits to/from stack, but if it's a segment value,
// high order 16 bits are trash.
//

#define SEGMENT_MASK    0xffff

//
// Startup count value for KeStallExecution.  This value is used
// until KiInitializeStallExecution can compute the real one.
// Pick a value long enough for very fast processors.
//

#define INITIAL_STALL_COUNT 100

// end_nthal

//
// begin_nthal
//
// Macro to extract the high word of a long offset
//

#define HIGHWORD(l) \
    ((USHORT)(((ULONG)(l)>>16) & 0xffff))

//
// Macro to extract the low word of a long offset
//

#define LOWWORD(l) \
    ((USHORT)((ULONG)l & 0x0000ffff))

//
// Macro to combine two USHORT offsets into a long offset
//

#if !defined(MAKEULONG)

#define MAKEULONG(x, y) \
    (((((ULONG)(x))<<16) & 0xffff0000) | \
    ((ULONG)(y) & 0xffff))

#endif

// end_nthal

//
// Request a software interrupt.
//

#define KiRequestSoftwareInterrupt(RequestIrql) \
    HalRequestSoftwareInterrupt( RequestIrql )

// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTKERNELAPI
UCHAR
NTAPI
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTKERNELAPI
USHORT
NTAPI
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTKERNELAPI
ULONG
NTAPI
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
NTAPI
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
NTAPI
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
NTAPI
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

// end_ntndis
//
// Get data cache fill size.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(KeGetDcacheFillSize)      // Use GetDmaAlignment
#endif

#define KeGetDcacheFillSize() 1L

// end_ntddk end_wdm end_nthal end_ntosp

//
// Fill TB entry.
//

#define KeFillEntryTb(Pte, Virtual, Invalid)    \
    if (Invalid != FALSE) {                     \
        Ke386InvalidateTb (Virtual);            \
    }

#if !defined(MIDL_PASS) && defined(_M_IX86) && !defined(_CROSS_PLATFORM_)

FORCEINLINE
VOID
NTAPI
Ke386InvalidateTb (
    IN PVOID Virtual
    )
{
    __asm {
        mov eax, Virtual
        invlpg [eax]
    }
}

#endif

NTKERNELAPI                                         // nthal
VOID                                                // nthal
KeFlushCurrentTb (                                  // nthal
    VOID                                            // nthal
    );                                              // nthal
                                                    // nthal
//
// Data cache, instruction cache, I/O buffer, and write buffer flush routine
// prototypes.
//

//  386 and 486 have transparent caches, so these are noops.

#define KeSweepDcache(AllProcessors)
#define KeSweepCurrentDcache()

#define KeSweepIcache(AllProcessors)
#define KeSweepCurrentIcache()

#define KeSweepIcacheRange(AllProcessors, BaseAddress, Length)

// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp

#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)

// end_ntddk end_wdm end_ntndis end_ntosp

#define KeYieldProcessor()    __asm { rep nop }

// end_nthal

//
// Define executive macros for acquiring and releasing executive spinlocks.
// These macros can ONLY be used by executive components and NOT by drivers.
// Drivers MUST use the kernel interfaces since they must be MP enabled on
// all systems.
//
// KeRaiseIrql is one instruction longer than KeAcquireSpinLock on x86 UP.
// KeLowerIrql and KeReleaseSpinLock are the same.
//

#if defined(NT_UP) && !DBG && !defined(_NTDDK_) && !defined(_NTIFS_)

#if !defined(_NTDRIVER_)
#define ExAcquireSpinLock(Lock, OldIrql) (*OldIrql) = KeRaiseIrqlToDpcLevel();
#define ExReleaseSpinLock(Lock, OldIrql) KeLowerIrql((OldIrql))
#else
#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#endif
#define ExAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock)

#else

//  begin_wdm begin_ntddk begin_ntosp

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

// end_wdm end_ntddk end_ntosp

#endif

//
// The acquire and release fast lock macros disable and enable interrupts
// on UP nondebug systems. On MP or debug systems, the spinlock routines
// are used.
//
// N.B. Extreme caution should be observed when using these routines.
//

#if defined(_M_IX86) && !defined(USER_MODE_CODE)

#pragma warning(disable:4164)
#pragma intrinsic(_disable)
#pragma intrinsic(_enable)
#pragma warning(default:4164)

#endif

#if defined(NT_UP) && !DBG && !defined(USER_MODE_CODE)
#define ExAcquireFastLock(Lock, OldIrql) _disable()
#else
#define ExAcquireFastLock(Lock, OldIrql) \
    ExAcquireSpinLock(Lock, OldIrql)
#endif

#if defined(NT_UP) && !DBG && !defined(USER_MODE_CODE)
#define ExReleaseFastLock(Lock, OldIrql) _enable()
#else
#define ExReleaseFastLock(Lock, OldIrql) \
    ExReleaseSpinLock(Lock, OldIrql)
#endif

//
// The following function prototypes must be in this module so that the
// above macros can call them directly.
//
// begin_nthal

VOID
FASTCALL
KiAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

VOID
FASTCALL
KiReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

// end_nthal

//
// KeTestSpinLock may be used to spin at low IRQL until the lock is
// available.  The IRQL must then be raised and the lock acquired with
// KeTryToAcquireSpinLock.  If that fails, lower the IRQL and start again.
//

#if defined(NT_UP)

#define KeTestSpinLock(SpinLock) (TRUE)

#else

BOOLEAN
FASTCALL
KeTestSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

//
// Define query tick count macro.
//
// begin_ntddk begin_nthal begin_ntosp

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// begin_wdm

#define KeQueryTickCount(CurrentCount ) { \
    volatile PKSYSTEM_TIME _TickCount = *((PKSYSTEM_TIME *)(&KeTickCount)); \
    while (TRUE) {                                                          \
        (CurrentCount)->HighPart = _TickCount->High1Time;                   \
        (CurrentCount)->LowPart = _TickCount->LowPart;                      \
        if ((CurrentCount)->HighPart == _TickCount->High2Time) break;       \
        _asm { rep nop }                                                    \
    }                                                                       \
}

// end_wdm

#else

// end_ntddk end_nthal end_ntosp

#define KiQueryTickCount(CurrentCount) \
    while (TRUE) {                                                      \
        (CurrentCount)->HighPart = KeTickCount.High1Time;               \
        (CurrentCount)->LowPart = KeTickCount.LowPart;                  \
        if ((CurrentCount)->HighPart == KeTickCount.High2Time) break;   \
        _asm { rep nop }                                                \
    }

// begin_ntddk begin_nthal begin_ntosp

VOID
NTAPI
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    );

#endif // defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_)

// end_ntddk end_nthal end_ntosp


// begin_nthal begin_ntosp
//
// 386 hardware structures
//

//
// A Page Table Entry on an Intel 386/486 has the following definition.
//
// **** NOTE A PRIVATE COPY OF THIS EXISTS IN THE MM\I386 DIRECTORY! ****
// ****  ANY CHANGES NEED TO BE MADE TO BOTH HEADER FILES.           ****
//


typedef struct _HARDWARE_PTE_X86 {
    ULONG Valid : 1;
    ULONG Write : 1;
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Accessed : 1;
    ULONG Dirty : 1;
    ULONG LargePage : 1;
    ULONG Global : 1;
    ULONG CopyOnWrite : 1; // software field
    ULONG Prototype : 1;   // software field
    ULONG reserved : 1;  // software field
    ULONG PageFrameNumber : 20;
} HARDWARE_PTE_X86, *PHARDWARE_PTE_X86;

typedef struct _HARDWARE_PTE_X86PAE {
    union {
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1; // software field
            ULONGLONG Prototype : 1;   // software field
            ULONGLONG reserved0 : 1;  // software field
            ULONGLONG PageFrameNumber : 26;
            ULONGLONG reserved1 : 26;  // software field
        };
        struct {
            ULONG LowPart;
            ULONG HighPart;
        };
    };
} HARDWARE_PTE_X86PAE, *PHARDWARE_PTE_X86PAE;

//
// Special check to work around mspdb limitation
//
#if defined (_NTSYM_HARDWARE_PTE_SYMBOL_)
#if !defined (_X86PAE_)
typedef struct _HARDWARE_PTE {
    ULONG Valid : 1;
    ULONG Write : 1;
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Accessed : 1;
    ULONG Dirty : 1;
    ULONG LargePage : 1;
    ULONG Global : 1;
    ULONG CopyOnWrite : 1; // software field
    ULONG Prototype : 1;   // software field
    ULONG reserved : 1;  // software field
    ULONG PageFrameNumber : 20;
} HARDWARE_PTE, *PHARDWARE_PTE;

#else
typedef struct _HARDWARE_PTE {
    union {
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1; // software field
            ULONGLONG Prototype : 1;   // software field
            ULONGLONG reserved0 : 1;  // software field
            ULONGLONG PageFrameNumber : 26;
            ULONGLONG reserved1 : 26;  // software field
        };
        struct {
            ULONG LowPart;
            ULONG HighPart;
        };
    };
} HARDWARE_PTE, *PHARDWARE_PTE;
#endif

#else

#if !defined (_X86PAE_)
typedef HARDWARE_PTE_X86 HARDWARE_PTE;
typedef PHARDWARE_PTE_X86 PHARDWARE_PTE;
#else
typedef HARDWARE_PTE_X86PAE HARDWARE_PTE;
typedef PHARDWARE_PTE_X86PAE PHARDWARE_PTE;
#endif
#endif

//
// GDT Entry
//

typedef struct _KGDTENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} KGDTENTRY, *PKGDTENTRY;

#define TYPE_CODE   0x10  // 11010 = Code, Readable, NOT Conforming, Accessed
#define TYPE_DATA   0x12  // 10010 = Data, ReadWrite, NOT Expanddown, Accessed
#define TYPE_TSS    0x01  // 01001 = NonBusy TSS
#define TYPE_LDT    0x02  // 00010 = LDT

#define DPL_USER    3
#define DPL_SYSTEM  0

#define GRAN_BYTE   0
#define GRAN_PAGE   1

#define SELECTOR_TABLE_INDEX 0x04

//
// Entry of Interrupt Descriptor Table (IDTENTRY)
//

typedef struct _KIDTENTRY {
   USHORT Offset;
   USHORT Selector;
   USHORT Access;
   USHORT ExtendedOffset;
} KIDTENTRY;

typedef KIDTENTRY *PKIDTENTRY;


//
// TSS (Task switch segment) NT only uses to control stack switches.
//
//  The only fields we actually care about are Esp0, Ss0, the IoMapBase
//  and the IoAccessMaps themselves.
//
//
//  N.B.    Size of TSS must be <= 0xDFFF
//

//
// The interrupt direction bitmap is used on Pentium to allow
// the processor to emulate V86 mode software interrupts for us.
// There is one for each IOPM.  It is located by subtracting
// 32 from the IOPM base in the Tss.
//
#define INT_DIRECTION_MAP_SIZE   32
typedef UCHAR   KINT_DIRECTION_MAP[INT_DIRECTION_MAP_SIZE];

#define IOPM_COUNT      1           // Number of i/o access maps that
                                    // exist (in addition to
                                    // IO_ACCESS_MAP_NONE)

#define IO_ACCESS_MAP_NONE 0

#define IOPM_SIZE           8192    // Size of map callers can set.

#define PIOPM_SIZE          8196    // Size of structure we must allocate
                                    // to hold it.

typedef UCHAR   KIO_ACCESS_MAP[IOPM_SIZE];

typedef KIO_ACCESS_MAP *PKIO_ACCESS_MAP;

typedef struct _KiIoAccessMap {
    KINT_DIRECTION_MAP DirectionMap;
    UCHAR IoMap[PIOPM_SIZE];
} KIIO_ACCESS_MAP;


typedef struct _KTSS {

    USHORT  Backlink;
    USHORT  Reserved0;

    ULONG   Esp0;
    USHORT  Ss0;
    USHORT  Reserved1;

    ULONG   NotUsed1[4];

    ULONG   CR3;
    ULONG   Eip;
    ULONG   EFlags;
    ULONG   Eax;
    ULONG   Ecx;
    ULONG   Edx;
    ULONG   Ebx;
    ULONG   Esp;
    ULONG   Ebp;
    ULONG   Esi;
    ULONG   Edi;


    USHORT  Es;
    USHORT  Reserved2;

    USHORT  Cs;
    USHORT  Reserved3;

    USHORT  Ss;
    USHORT  Reserved4;

    USHORT  Ds;
    USHORT  Reserved5;

    USHORT  Fs;
    USHORT  Reserved6;

    USHORT  Gs;
    USHORT  Reserved7;

    USHORT  LDT;
    USHORT  Reserved8;

    USHORT  Flags;

    USHORT  IoMapBase;

    KIIO_ACCESS_MAP IoMaps[IOPM_COUNT];

    //
    // This is the Software interrupt direction bitmap associated with
    // IO_ACCESS_MAP_NONE
    //
    KINT_DIRECTION_MAP IntDirectionMap;
} KTSS, *PKTSS;


#define KiComputeIopmOffset(MapNumber)          \
    (MapNumber == IO_ACCESS_MAP_NONE) ?         \
        (USHORT)(sizeof(KTSS)) :                    \
        (USHORT)(FIELD_OFFSET(KTSS, IoMaps[MapNumber-1].IoMap))

// begin_windbgkd

//
// Special Registers for i386
//

#ifdef _X86_

typedef struct _DESCRIPTOR {
    USHORT  Pad;
    USHORT  Limit;
    ULONG   Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KSPECIAL_REGISTERS {
    ULONG Cr0;
    ULONG Cr2;
    ULONG Cr3;
    ULONG Cr4;
    ULONG KernelDr0;
    ULONG KernelDr1;
    ULONG KernelDr2;
    ULONG KernelDr3;
    ULONG KernelDr6;
    ULONG KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG Reserved[6];
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

//
// Processor State frame: Before a processor freezes itself, it
// dumps the processor state to the processor state frame for
// debugger to examine.
//

typedef struct _KPROCESSOR_STATE {
    struct _CONTEXT ContextFrame;
    struct _KSPECIAL_REGISTERS SpecialRegisters;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;

#endif // _X86_

// end_windbgkd

//
// Processor Control Block (PRCB)
//

#define PRCB_MAJOR_VERSION 1
#define PRCB_MINOR_VERSION 1
#define PRCB_BUILD_DEBUG        0x0001
#define PRCB_BUILD_UNIPROCESSOR 0x0002

typedef struct _KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
    USHORT MinorVersion;
    USHORT MajorVersion;

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;

    CCHAR  Number;
    CCHAR  Reserved;
    USHORT BuildType;
    KAFFINITY SetMember;

    CCHAR   CpuType;
    CCHAR   CpuID;
    USHORT  CpuStep;

    struct _KPROCESSOR_STATE ProcessorState;

    ULONG   KernelReserved[16];         // For use by the kernel
    ULONG   HalReserved[16];            // For use by Hal

//
// Per processor lock queue entries.
//
// N.B. The following padding is such that the first lock entry falls in the
//      last eight bytes of a cache line. This makes the dispatcher lock and
//      the context swap lock lie in separate cache lines.
//

    UCHAR PrcbPad0[28 + 64];
    KSPIN_LOCK_QUEUE LockQueue[16];
    UCHAR PrcbPad1[8];

// End of the architecturally defined section of the PRCB.
// end_nthal end_ntosp

//
// Micellaneous counters - 64-byte aligned.
//

    struct _KTHREAD *NpxThread;
    ULONG   InterruptCount;
    ULONG   KernelTime;
    ULONG   UserTime;
    ULONG   DpcTime;
    ULONG   DebugDpcTime;
    ULONG   InterruptTime;
    ULONG   AdjustDpcThreshold;
    ULONG   PageColor;
    LOGICAL SkipTick;

//
// MultiThreadSetBusy is TRUE is all the processors in the set are
// not idle.   This field is only updated in the PRCB of the first
// member of the SMT set and only by members of the same set.
//

    BOOLEAN MultiThreadSetBusy;
    UCHAR   Spare2[3];
    struct _KNODE * ParentNode;         // Node this processor is a member of
    KAFFINITY MultiThreadProcessorSet;  // Processors in SMT set
    struct _KPRCB * MultiThreadSetMaster;// Pointer to first proc in SMT set
    ULONG   ThreadStartCount[2];        // perf data

//
// Performance counters - 64-byte aligned.
//
// Cache manager performance counters.
//

    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadNotPossible;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;

//
//  Kernel performance counters.
//

    ULONG KeAlignmentFixupCount;
    ULONG KeContextSwitches;
    ULONG KeDcacheFlushCount;
    ULONG KeExceptionDispatchCount;
    ULONG KeFirstLevelTbFills;
    ULONG KeFloatingEmulationCount;
    ULONG KeIcacheFlushCount;
    ULONG KeSecondLevelTbFills;
    ULONG KeSystemCalls;
    ULONG SpareCounter0[1];

//
// Nonpaged per processor lookaside lists - 64-byte aligned.
//

    PP_LOOKASIDE_LIST PPLookasideList[16];

//
// Nonpaged per processor small pool lookaside lists - 64-byte aligned.
//

    PP_LOOKASIDE_LIST PPNPagedLookasideList[POOL_SMALL_LISTS];

//
// Paged per processor small pool lookaside lists - 64-byte aligned.
//

    PP_LOOKASIDE_LIST PPPagedLookasideList[POOL_SMALL_LISTS];

//
// MP interprocessor request packet barrier - 64-byte aligned.
//

    volatile ULONG PacketBarrier;
    volatile ULONG ReverseStall;
    PVOID IpiFrame;
    UCHAR PrcbPad2[52];

//
// MP interprocessor request packet and summary - 64-byte aligned.
//

    volatile PVOID CurrentPacket[3];
    volatile KAFFINITY TargetSet;
    volatile PKIPI_WORKER WorkerRoutine;
    volatile ULONG IpiFrozen;
    UCHAR PrcbPad3[40];

//
// MP interprocessor request summary and packet address - 64-byte aligned.
//

    volatile ULONG RequestSummary;
    volatile struct _KPRCB *SignalDone;
    UCHAR PrcbPad4[56];

//
// DPC listhead, counts, and batching parameters - 64-byte aligned.
//

    LIST_ENTRY DpcListHead;
    PVOID DpcStack;
    ULONG DpcCount;
    volatile ULONG DpcQueueDepth;
    volatile ULONG DpcRoutineActive;
    volatile ULONG DpcInterruptRequested;
    ULONG DpcLastCount;
    ULONG DpcRequestRate;
    ULONG MaximumDpcQueueDepth;
    ULONG MinimumDpcRate;
    ULONG QuantumEnd;
    UCHAR PrcbPad5[16];

//
// DPC list lock - 64-byte aligned.
//

    KSPIN_LOCK DpcLock;
    UCHAR PrcbPad6[60];

//
// Per processor chained interrupt list.
//

    PVOID ChainedInterruptList;

//
// I/O IRP float.
//

    LONG LookasideIrpFloat;

//
// Spare fields.
//

    ULONG   SpareFields0[6];

//
// Processor information.
//

    UCHAR VendorString[13];
    UCHAR InitialApicId;
    UCHAR LogicalProcessorsPerPhysicalProcessor;
    ULONG MHz;
    ULONG FeatureBits;
    LARGE_INTEGER UpdateSignature;

//
// Npx save area - 16-byte aligned.
//

    FX_SAVE_AREA NpxSaveArea;

//
// Processors power state
//

    PROCESSOR_POWER_STATE PowerState;

// begin_nthal begin_ntosp

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

// end_nthal end_ntosp

//
// The offset of the PRCB in the PCR is 32 mod 64.
//
// The offset of the following structure must be 0 mod 64 except for the
// lock queue array which straddles two cache lines.
//

C_ASSERT(((FIELD_OFFSET(KPRCB, LockQueue) + sizeof(KSPIN_LOCK_QUEUE) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, NpxThread) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, CcFastReadNoWait) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, PPLookasideList) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, PPNPagedLookasideList) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, PPPagedLookasideList) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, PacketBarrier) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, CurrentPacket) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, DpcListHead) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, DpcLock) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, ChainedInterruptList) + 32) & (64 - 1)) == 0);
C_ASSERT(((FIELD_OFFSET(KPRCB, NpxSaveArea) + 32) & (16 - 1)) == 0);

// begin_nthal begin_ntddk begin_ntosp

//
// Processor Control Region Structure Definition
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    NT_TIB  NtTib;
    struct _KPCR *SelfPcr;              // flat address of this PCR
    struct _KPRCB *Prcb;                // pointer to Prcb
    KIRQL   Irql;
    ULONG   IRR;
    ULONG   IrrActive;
    ULONG   IDR;
    PVOID   KdVersionBlock;

    struct _KIDTENTRY *IDT;
    struct _KGDTENTRY *GDT;
    struct _KTSS      *TSS;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    KAFFINITY SetMember;
    ULONG   StallScaleFactor;
    UCHAR   DebugActive;
    UCHAR   Number;

// end_ntddk end_ntosp

    UCHAR   Spare0;
    UCHAR   SecondLevelCacheAssociativity;
    ULONG   VdmAlert;
    ULONG   KernelReserved[14];         // For use by the kernel
    ULONG   SecondLevelCacheSize;
    ULONG   HalReserved[16];            // For use by Hal

// End of the architecturally defined section of the PCR.
// end_nthal

    ULONG   InterruptMode;
    UCHAR   Spare1;
    ULONG   KernelReserved2[17];
    struct _KPRCB PrcbData;

// begin_nthal begin_ntddk begin_ntosp

} KPCR, *PKPCR;

// end_nthal end_ntddk end_ntosp

C_ASSERT((FIELD_OFFSET(KPCR, PrcbData) & (64 - 1)) == 32);

// begin_nthal begin_ntosp

#define EFLAGS_TF             0x00000100L
#define EFLAGS_INTERRUPT_MASK 0x00000200L
#define EFLAGS_DF_MASK        0x00000400L
#define EFLAGS_V86_MASK       0x00020000L
#define EFLAGS_ALIGN_CHECK    0x00040000L
#define EFLAGS_IOPL_MASK      0x00003000L
#define EFLAGS_VIF            0x00080000L
#define EFLAGS_VIP            0x00100000L
#define EFLAGS_USER_SANITIZE  0x003e0dd7L

// end_nthal

//
// Sanitize segCS and eFlags based on a processor mode.
//
// If kernel mode,
//      force CPL == 0
//
// If user mode,
//      force CPL == 3
//

#define SANITIZE_SEG(segCS, mode) (\
    ((mode) == KernelMode ? \
        ((0x00000000L) | ((segCS) & 0xfffc)) : \
        ((0x00000003L) | ((segCS) & 0xffff))))

//
// If kernel mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, Interrupt, AlignCheck.
//
// If user mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, AlignCheck.
//      force Interrupts on.
//


#define SANITIZE_FLAGS(eFlags, mode) (\
    ((mode) == KernelMode ? \
        ((0x00000000L) | ((eFlags) & 0x003e0fd7)) : \
        ((((eFlags) & EFLAGS_V86_MASK) && KeI386VdmIoplAllowed) ? \
        (((eFlags) & KeI386EFlagsAndMaskV86) | KeI386EFlagsOrMaskV86) : \
        ((EFLAGS_INTERRUPT_MASK) | ((eFlags) & EFLAGS_USER_SANITIZE)))))

//
// Masks for Dr7 and sanitize macros for various Dr registers.
//

#define DR6_LEGAL   0x0000e00f

#define DR7_LEGAL   0xffff0155  // R/W, LEN for Dr0-Dr4,
                                // Local enable for Dr0-Dr4,
                                // Le for "perfect" trapping

#define DR7_ACTIVE  0x00000055  // If any of these bits are set, a Dr is active

#define SANITIZE_DR6(Dr6, mode) ((Dr6 & DR6_LEGAL));

#define SANITIZE_DR7(Dr7, mode) ((Dr7 & DR7_LEGAL));

#define SANITIZE_DRADDR(DrReg, mode) (          \
    (mode) == KernelMode ?                      \
        (DrReg) :                               \
        (((PVOID)DrReg <= MM_HIGHEST_USER_ADDRESS) ?   \
            (DrReg) :                           \
            (0)                                 \
        )                                       \
    )

//
// Define macro to clear reserved bits from MXCSR so that we don't
// GP fault when doing an FRSTOR
//

extern ULONG KiMXCsrMask;

#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) & KiMXCsrMask)

//
// Nonvolatile context pointers
//
// bryanwi 21 feb 90 - This is bogus.  The 386 doesn't have
//                     enough nonvolatile context to make this
//                     structure worthwhile.  Can't declare a
//                     field to be void, so declare a Junk structure
//                     instead.

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    ULONG   Junk;
} KNONVOLATILE_CONTEXT_POINTERS,  *PKNONVOLATILE_CONTEXT_POINTERS;

// begin_nthal
//
// Trap frame
//
//  NOTE - We deal only with 32bit registers, so the assembler equivalents
//         are always the extended forms.
//
//  NOTE - Unless you want to run like slow molasses everywhere in the
//         the system, this structure must be of DWORD length, DWORD
//         aligned, and its elements must all be DWORD aligned.
//
//  NOTE WELL   -
//
//      The i386 does not build stack frames in a consistent format, the
//      frames vary depending on whether or not a privilege transition
//      was involved.
//
//      In order to make NtContinue work for both user mode and kernel
//      mode callers, we must force a canonical stack.
//
//      If we're called from kernel mode, this structure is 8 bytes longer
//      than the actual frame!
//
//  WARNING:
//
//      KTRAP_FRAME_LENGTH needs to be 16byte integral (at present.)
//

typedef struct _KTRAP_FRAME {


//
//  Following 4 values are only used and defined for DBG systems,
//  but are always allocated to make switching from DBG to non-DBG
//  and back quicker.  They are not DEVL because they have a non-0
//  performance impact.
//

    ULONG   DbgEbp;         // Copy of User EBP set up so KB will work.
    ULONG   DbgEip;         // EIP of caller to system call, again, for KB.
    ULONG   DbgArgMark;     // Marker to show no args here.
    ULONG   DbgArgPointer;  // Pointer to the actual args

//
//  Temporary values used when frames are edited.
//
//
//  NOTE:   Any code that want's ESP must materialize it, since it
//          is not stored in the frame for kernel mode callers.
//
//          And code that sets ESP in a KERNEL mode frame, must put
//          the new value in TempEsp, make sure that TempSegCs holds
//          the real SegCs value, and put a special marker value into SegCs.
//

    ULONG   TempSegCs;
    ULONG   TempEsp;

//
//  Debug registers.
//

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

//
//  Segment registers
//

    ULONG   SegGs;
    ULONG   SegEs;
    ULONG   SegDs;

//
//  Volatile registers
//

    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

//
//  Nesting state, not part of context record
//

    ULONG   PreviousPreviousMode;

    PEXCEPTION_REGISTRATION_RECORD ExceptionList;
                                            // Trash if caller was user mode.
                                            // Saved exception list if caller
                                            // was kernel mode or we're in
                                            // an interrupt.

//
//  FS is TIB/PCR pointer, is here to make save sequence easy
//

    ULONG   SegFs;

//
//  Non-volatile registers
//

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Ebp;

//
//  Control registers
//

    ULONG   ErrCode;
    ULONG   Eip;
    ULONG   SegCs;
    ULONG   EFlags;

    ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
    ULONG   HardwareSegSs;  // that involve a ring transition.

    ULONG   V86Es;          // these will be present for all transitions from
    ULONG   V86Ds;          // V86 mode
    ULONG   V86Fs;
    ULONG   V86Gs;
} KTRAP_FRAME;


typedef KTRAP_FRAME *PKTRAP_FRAME;
typedef KTRAP_FRAME *PKEXCEPTION_FRAME;

#define KTRAP_FRAME_LENGTH  (sizeof(KTRAP_FRAME))
#define KTRAP_FRAME_ALIGN   (sizeof(ULONG))
#define KTRAP_FRAME_ROUND   (KTRAP_FRAME_ALIGN-1)

//
//  Bits forced to 0 in SegCs if Esp has been edited.
//

#define FRAME_EDITED        0xfff8

// end_nthal

//
// The frame saved by KiCallUserMode is defined here to allow
// the kernel debugger to trace the entire kernel stack
// when usermode callouts are pending.
//

typedef struct _KCALLOUT_FRAME {
    ULONG   InStk;          // saved initial stack address
    ULONG   TrFr;           // saved callback trap frame
    ULONG   CbStk;          // saved callback stack address
    ULONG   Edi;            // saved nonvolatile registers
    ULONG   Esi;            //
    ULONG   Ebx;            //
    ULONG   Ebp;            //
    ULONG   Ret;            // saved return address
    ULONG   OutBf;          // address to store output buffer
    ULONG   OutLn;          // address to store output length
} KCALLOUT_FRAME;

typedef KCALLOUT_FRAME *PKCALLOUT_FRAME;


//
//  Switch Frame
//
//  386 doesn't have an "exception frame", and doesn't normally make
//  any use of nonvolatile context register structures.
//
//  However, swapcontext in ctxswap.c and KeInitializeThread in
//  thredini.c need to share common stack structure used at thread
//  startup and switch time.
//
//  This is that structure.
//

typedef struct _KSWITCHFRAME {
    ULONG   ExceptionList;
    ULONG   Eflags;
    ULONG   RetAddr;
} KSWITCHFRAME, *PKSWITCHFRAME;


//
// Various 387 defines
//

#define I386_80387_NP_VECTOR    0x07    // trap 7 when hardware not present

// begin_ntddk begin_wdm
//
// The non-volatile 387 state
//

typedef struct _KFLOATING_SAVE {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;                 // Not used in wdm
    ULONG   DataSelector;
    ULONG   Cr0NpxState;
    ULONG   Spare1;                     // Not used in wdm
} KFLOATING_SAVE, *PKFLOATING_SAVE;

// end_ntddk end_wdm end_ntosp

//
// i386 Profile values
//

#define DEFAULT_PROFILE_INTERVAL   39063

//
// The minimum acceptable profiling interval is set to 1221 which is the
// fast RTC clock rate we can get.  If this
// value is too small, the system will run very slowly.
//

#define MINIMUM_PROFILE_INTERVAL   1221


// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntosp
//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L

// end_ntndis end_wdm
//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT_X86    22
#define PDI_SHIFT_X86PAE 21

#if !defined (_X86PAE_)
#define PDI_SHIFT PDI_SHIFT_X86
#else
#define PDI_SHIFT PDI_SHIFT_X86PAE
#define PPI_SHIFT 30
#endif

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 12

//
// Define the highest user address and user probe address.
//

// end_ntddk end_nthal end_ntosp

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

// begin_ntddk begin_nthal begin_ntosp

extern PVOID *MmHighestUserAddress;
extern PVOID *MmSystemRangeStart;
extern ULONG *MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS *MmHighestUserAddress
#define MM_SYSTEM_RANGE_START *MmSystemRangeStart
#define MM_USER_PROBE_ADDRESS *MmUserProbeAddress

// end_ntddk end_nthal end_ntosp

#else

extern PVOID MmHighestUserAddress;
extern PVOID MmSystemRangeStart;
extern ULONG MmUserProbeAddress;

#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart
#define MM_USER_PROBE_ADDRESS MmUserProbeAddress

#endif

// begin_ntddk begin_nthal  begin_ntosp
//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000

//
// The lowest address for system space.
//

#if !defined (_X86PAE_)
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0800000
#else
#define MM_LOWEST_SYSTEM_ADDRESS (PVOID)0xC0C00000
#endif

// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(Address) MmLockPagableDataSection(Address)

// end_ntddk end_wdm

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT_X86    22
#define PDI_SHIFT_X86PAE 21

#if !defined (_X86PAE_)
#define PDI_SHIFT PDI_SHIFT_X86
#else
#define PDI_SHIFT PDI_SHIFT_X86PAE
#define PPI_SHIFT 30
#endif

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT 12

//
// Define page directory and page base addresses.
//

#define PDE_BASE_X86    0xc0300000
#define PDE_BASE_X86PAE 0xc0600000

#define PTE_TOP_X86     0xC03FFFFF
#define PDE_TOP_X86     0xC0300FFF

#define PTE_TOP_X86PAE  0xC07FFFFF
#define PDE_TOP_X86PAE  0xC0603FFF


#if !defined (_X86PAE_)
#define PDE_BASE PDE_BASE_X86
#define PTE_TOP  PTE_TOP_X86
#define PDE_TOP  PDE_TOP_X86
#else
#define PDE_BASE PDE_BASE_X86PAE
#define PTE_TOP  PTE_TOP_X86PAE
#define PDE_TOP  PDE_TOP_X86PAE
#endif
#define PTE_BASE 0xc0000000

// end_nthal end_ntosp

//
// Define virtual base and alternate virtual base of kernel.
//

#define KSEG0_BASE 0x80000000
#define ALTERNATE_BASE (0xe1000000 - 16 * 1024 * 1024)

//
// Define macro to initialize directory table base.
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase,pfn) \
     *((PULONG)(dirbase)) = ((pfn) << PAGE_SHIFT)


// begin_nthal
//
// Location of primary PCR (used only for UP kernel & hal code)
//

// addressed from 0xffdf0000 - 0xffdfffff are reserved for the system
// (ie, not for use by the hal)

#define KI_BEGIN_KERNEL_RESERVED    0xffdf0000
#define KIP0PCRADDRESS              0xffdff000  // ntddk wdm ntosp

// begin_ntddk  begin_ntosp

#define KI_USER_SHARED_DATA         0xffdf0000
#define SharedUserData  ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)

//
// Result type definition for i386.  (Machine specific enumerate type
// which is return type for portable exinterlockedincrement/decrement
// procedures.)  In general, you should use the enumerated type defined
// in ex.h instead of directly referencing these constants.
//

// Flags loaded into AH by LAHF instruction

#define EFLAG_SIGN      0x8000
#define EFLAG_ZERO      0x4000
#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO     ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)

//
// Convert various portable ExInterlock APIs into their architectural
// equivalents.
//

#if PRAGMA_DEPRECATED_DDK
#pragma deprecated(ExInterlockedIncrementLong)      // Use InterlockedIncrement
#pragma deprecated(ExInterlockedDecrementLong)      // Use InterlockedDecrement
#pragma deprecated(ExInterlockedExchangeUlong)      // Use InterlockedExchange
#endif

#define ExInterlockedIncrementLong(Addend,Lock) \
        Exfi386InterlockedIncrementLong(Addend)

#define ExInterlockedDecrementLong(Addend,Lock) \
        Exfi386InterlockedDecrementLong(Addend)

#define ExInterlockedExchangeUlong(Target,Value,Lock) \
        Exfi386InterlockedExchangeUlong(Target,Value)

//  begin_wdm

#define ExInterlockedAddUlong           ExfInterlockedAddUlong
#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList
#define ExInterlockedPopEntryList       ExfInterlockedPopEntryList
#define ExInterlockedPushEntryList      ExfInterlockedPushEntryList

//  end_wdm

//
// Prototypes for architectural specific versions of Exi386 Api
//

//
// Interlocked result type is portable, but its values are machine specific.
// Constants for value are in i386.h, mips.h, etc.
//

typedef enum _INTERLOCKED_RESULT {
    ResultNegative = RESULT_NEGATIVE,
    ResultZero     = RESULT_ZERO,
    ResultPositive = RESULT_POSITIVE
} INTERLOCKED_RESULT;

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedIncrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
INTERLOCKED_RESULT
FASTCALL
Exfi386InterlockedDecrementLong (
    IN PLONG Addend
    );

NTKERNELAPI
ULONG
FASTCALL
Exfi386InterlockedExchangeUlong (
    IN PULONG Target,
    IN ULONG Value
    );

// end_ntddk end_nthal end_ntosp

//
// UP/MP versions of interlocked intrinsics
//
// N.B. FASTCALL does NOT work with inline functions.
//

#if !defined(_WINBASE_) && !defined(NONTOSPINTERLOCK) // ntosp ntddk nthal
#if defined(_M_IX86)

#pragma warning(disable:4035)               // wdm re-enable below

// begin_ntddk begin_nthal begin_ntosp
#if !defined(MIDL_PASS) // wdm
#if defined(NO_INTERLOCKED_INTRINSICS) || defined(_CROSS_PLATFORM_)
//  begin_wdm

NTKERNELAPI
LONG
FASTCALL
InterlockedIncrement(
    IN LONG volatile *Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedDecrement(
    IN LONG volatile *Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#define InterlockedCompareExchange64(Destination, ExChange, Comperand) \
    ExfInterlockedCompareExchange64(Destination, &(ExChange), &(Comperand))

NTKERNELAPI
LONGLONG
FASTCALL
ExfInterlockedCompareExchange64(
    IN OUT LONGLONG volatile *Destination,
    IN PLONGLONG ExChange,
    IN PLONGLONG Comperand
    );

//  end_wdm

#else       // NO_INTERLOCKED_INCREMENTS || _CROSS_PLATFORM_

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)Target, (LONG)Value)

// end_ntddk end_nthal end_ntosp

#if defined(NT_UP) && !defined (_NTDDK_) && !defined(_NTIFS_)

#define InterlockedIncrement(Addend) (InterlockedExchangeAdd (Addend, 1)+1)
#define InterlockedDecrement(Addend) (InterlockedExchangeAdd (Addend, -1)-1)

//FORCEINLINE
//LONG
//FASTCALL
//InterlockedIncrement(
//    IN PLONG Addend
//    )
//{
//    __asm {
//        mov     eax, 1
//        mov     ecx, Addend
//        xadd    [ecx], eax
//        inc     eax
//    }
//}

//FORCEINLINE
//LONG
//FASTCALL
//InterlockedDecrement(
//    IN PLONG Addend
//    )
//{
//    __asm {
//        mov     eax, -1
//        mov     ecx, Addend
//        xadd    [ecx], eax
//        dec     eax
//    }
//}

FORCEINLINE
LONG
FASTCALL
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    )
{
    __asm {
        mov     eax, Value
        mov     ecx, Target
        xchg    [ecx], eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    )
{
    __asm {
        mov     eax, Increment
        mov     ecx, Addend
        xadd    [ecx], eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT LONG volatile *Destination,
    IN LONG Exchange,
    IN LONG Comperand
    )
{
    __asm {
        mov     eax, Comperand
        mov     ecx, Destination
        mov     edx, Exchange
        cmpxchg [ecx], edx
    }
}

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#define InterlockedCompareExchange64(Destination, ExChange, Comperand) \
    ExfInterlockedCompareExchange64(Destination, &(ExChange), &(Comperand))

LONGLONG
FASTCALL
ExfInterlockedCompareExchange64(
    IN OUT LONGLONG volatile *Destination,
    IN PLONGLONG ExChange,
    IN PLONGLONG Comperand
    );

#else   // NT_UP

// begin_ntosp begin_ntddk begin_nthal

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

#pragma intrinsic (_InterlockedExchange)
#define InterlockedExchange _InterlockedExchange
#else
FORCEINLINE
LONG
FASTCALL
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    )
{
    __asm {
        mov     eax, Value
        mov     ecx, Target
        xchg    [ecx], eax
    }
}
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedIncrement(
    IN LONG volatile *Addend
    );

#pragma intrinsic (_InterlockedIncrement)
#define InterlockedIncrement _InterlockedIncrement
#else
#define InterlockedIncrement(Addend) (InterlockedExchangeAdd (Addend, 1)+1)
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedDecrement(
    IN LONG volatile *Addend
    );

#pragma intrinsic (_InterlockedDecrement)
#define InterlockedDecrement _InterlockedDecrement
#else
#define InterlockedDecrement(Addend) (InterlockedExchangeAdd (Addend, -1)-1)
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    );

#pragma intrinsic (_InterlockedExchangeAdd)
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#else
// begin_wdm
FORCEINLINE
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Increment
    )
{
    __asm {
         mov     eax, Increment
         mov     ecx, Addend
    lock xadd    [ecx], eax
    }
}
// end_wdm
#endif

#if (_MSC_FULL_VER > 13009037)
LONG
__cdecl
_InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#pragma intrinsic (_InterlockedCompareExchange)
#define InterlockedCompareExchange (LONG)_InterlockedCompareExchange
#else
FORCEINLINE
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT LONG volatile *Destination,
    IN LONG Exchange,
    IN LONG Comperand
    )
{
    __asm {
        mov     eax, Comperand
        mov     ecx, Destination
        mov     edx, Exchange
   lock cmpxchg [ecx], edx
    }
}
#endif

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#define InterlockedCompareExchange64(Destination, ExChange, Comperand) \
    ExfInterlockedCompareExchange64(Destination, &(ExChange), &(Comperand))

NTKERNELAPI
LONGLONG
FASTCALL
ExfInterlockedCompareExchange64(
    IN OUT LONGLONG volatile *Destination,
    IN PLONGLONG ExChange,
    IN PLONGLONG Comperand
    );

// end_ntosp end_ntddk end_nthal
#endif      // NT_UP
// begin_ntddk begin_nthal begin_ntosp
#endif      // INTERLOCKED_INTRINSICS || _CROSS_PLATFORM_
// begin_wdm
#endif      // MIDL_PASS
// end_ntosp end_ntddk end_nthal
#pragma warning(default:4035)
// end_wdm
#endif      // _M_IX86 && !CROSS_PLATFORM
// begin_ntddk begin_nthal begin_ntosp
#endif      // __WINBASE__ && !NONTOSPINTERLOCK
// end_ntosp end_ntddk end_nthal

// begin_nthal begin_ntddk

//
// Turn these instrinsics off until the compiler can handle them
//
#if (_MSC_FULL_VER > 13009037)

LONG
_InterlockedOr (
    IN OUT PLONG Target,
    IN LONG Set
    );

#pragma intrinsic (_InterlockedOr)

#define InterlockedOr _InterlockedOr

LONG
_InterlockedAnd (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

#pragma intrinsic (_InterlockedAnd)

#define InterlockedAnd _InterlockedAnd

LONG
_InterlockedXor (
    IN OUT LONG volatile Target,
    IN LONG Set
    );

#pragma intrinsic (_InterlockedXor)

#define InterlockedXor _InterlockedXor

#else // compiler version

FORCEINLINE
LONG
InterlockedAnd (
    IN OUT LONG volatile *Target,
    LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i & Set,
                                       i);

    } while (i != j);

    return j;
}

FORCEINLINE
LONG
InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    )
{
    LONG i;
    LONG j;

    j = *Target;
    do {
        i = j;
        j = InterlockedCompareExchange(Target,
                                       i | Set,
                                       i);

    } while (i != j);

    return j;
}

#endif // compiler version

// end_nthal end_ntddk

//
// Structure for Ldt information in x86 processes
//
typedef struct _LDTINFORMATION {
    ULONG Size;
    ULONG AllocatedSize;
    PLDT_ENTRY Ldt;
} LDTINFORMATION, *PLDTINFORMATION;

//
// SetProcessInformation Structure for ProcessSetIoHandlers info class
//

// begin_ntosp

typedef struct _PROCESS_IO_PORT_HANDLER_INFORMATION {
    BOOLEAN Install;            // true if handlers to be installed
    ULONG NumEntries;
    ULONG Context;
    PEMULATOR_ACCESS_ENTRY EmulatorAccessEntries;
} PROCESS_IO_PORT_HANDLER_INFORMATION, *PPROCESS_IO_PORT_HANDLER_INFORMATION;


//
//    Vdm Objects and Io handling structure
//

typedef struct _VDM_IO_HANDLER_FUNCTIONS {
    PDRIVER_IO_PORT_ULONG  UlongIo;
    PDRIVER_IO_PORT_ULONG_STRING UlongStringIo;
    PDRIVER_IO_PORT_USHORT UshortIo[2];
    PDRIVER_IO_PORT_USHORT_STRING UshortStringIo[2];
    PDRIVER_IO_PORT_UCHAR UcharIo[4];
    PDRIVER_IO_PORT_UCHAR_STRING UcharStringIo[4];
} VDM_IO_HANDLER_FUNCTIONS, *PVDM_IO_HANDLER_FUNCTIONS;

typedef struct _VDM_IO_HANDLER {
    struct _VDM_IO_HANDLER *Next;
    ULONG PortNumber;
    VDM_IO_HANDLER_FUNCTIONS IoFunctions[2];
} VDM_IO_HANDLER, *PVDM_IO_HANDLER;



// begin_nthal begin_ntddk begin_wdm


#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//

#pragma warning(disable:4035)               // re-enable below

// end_wdm

#if NT_UP
    #define _PCR   ds:[KIP0PCRADDRESS]
#else
    #define _PCR   fs:[0]
#endif

// end_ntddk end_ntosp

//
// Get address of current processor block.
//
// WARNING: This inline macro can only be used by the kernel or hal
//
#define KiPcr() KeGetPcr()
FORCEINLINE
PKPCR
NTAPI
KeGetPcr(VOID)
{
#if NT_UP
    __asm {  mov eax, KIP0PCRADDRESS }
#else
    __asm {  mov eax, _PCR KPCR.SelfPcr  }
#endif
}

// begin_ntosp

//
// Get address of current processor block.
//
// WARNING: This inline macro can only be used by the kernel or hal
//
FORCEINLINE
PKPRCB
NTAPI
KeGetCurrentPrcb (VOID)
{
    __asm {  mov eax, _PCR KPCR.Prcb     }
}

// begin_ntddk begin_wdm

//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

NTHALAPI
KIRQL
NTAPI
KeGetCurrentIrql();

// end_wdm
//
// Get the current processor number
//

FORCEINLINE
ULONG
NTAPI
KeGetCurrentProcessorNumber(VOID)
{
    __asm {  movzx eax, _PCR KPCR.Number  }
}

// end_nthal end_ntddk end_ntosp
//
// Get address of current kernel thread object.
//
// WARNING: This inline macro can not be used for device drivers or HALs
// they must call the kernel function KeGetCurrentThread.
// WARNING: This inline macro is always MP enabled because filesystems
// utilize it
//
//
FORCEINLINE
struct _KTHREAD *
NTAPI KeGetCurrentThread (VOID)
{
    __asm {  mov eax, fs:[0] KPCR.PrcbData.CurrentThread }
}

//
// If processor executing DPC?
// WARNING: This inline macro is always MP enabled because filesystems
// utilize it
//
FORCEINLINE
ULONG
NTAPI
KeIsExecutingDpc(VOID)
{
    __asm {  mov eax, fs:[0] KPCR.PrcbData.DpcRoutineActive }
}

// begin_nthal begin_ntddk begin_ntosp

#pragma warning(default:4035)

// begin_wdm
#endif // !defined(MIDL_PASS) && defined(_M_IX86)

// end_nthal end_ntddk end_wdm end_ntosp

//++
//
//
// VOID
// KeMemoryBarrier (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function cases ordering of memory acceses as seen by other processors.
//    Memory ordering isn't an issue on x86.
//
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeMemoryBarrier()

// begin_nthal
//
// Macro to set address of a trap/interrupt handler to IDT
//
#define KiSetHandlerAddressToIDT(Vector, HandlerAddress) {\
    UCHAR IDTEntry = HalVectorToIDTEntry(Vector); \
    ULONG Ha = (ULONG)HandlerAddress; \
    KeGetPcr()->IDT[IDTEntry].ExtendedOffset = HIGHWORD(Ha); \
    KeGetPcr()->IDT[IDTEntry].Offset = LOWWORD(Ha); \
}

//
// Macro to return address of a trap/interrupt handler in IDT
//
#define KiReturnHandlerAddressFromIDT(Vector) \
   MAKEULONG(KiPcr()->IDT[HalVectorToIDTEntry(Vector)].ExtendedOffset, KiPcr()->IDT[HalVectorToIDTEntry(Vector)].Offset)

// end_nthal

//++
//
// BOOLEAN
// KiIsThreadNumericStateSaved(
//     IN PKTHREAD Address
//     )
//
//--
#define KiIsThreadNumericStateSaved(a) \
    (a->NpxState != NPX_STATE_LOADED)

//++
//
// VOID
// KiRundownThread(
//     IN PKTHREAD Address
//     )
//
//--

#if defined(NT_UP)

//
// On UP x86 systems, FP state is lazy saved and loaded.  If this
// thread owns the current FP context, clear the ownership field
// so we will not try to save to this thread after it has been
// terminated.
//

#define KiRundownThread(a)                          \
    if (KeGetCurrentPrcb()->NpxThread == (a))   {   \
        KeGetCurrentPrcb()->NpxThread = NULL;       \
    }

#else

#define KiRundownThread(a)

#endif

//
// functions specific to 386 structure
//

VOID
NTAPI
KiSetIRR (
    IN ULONG SWInterruptMask
    );

//
// Procedures to support frame manipulation
//

ULONG
NTAPI
KiEspFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    );

VOID
NTAPI
KiEspToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG Esp
    );

ULONG
NTAPI
KiSegSsFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    );

VOID
NTAPI
KiSegSsToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG SegSs
    );

//
// Define prototypes for i386 specific clock and profile interrupt routines.
//

VOID
NTAPI
KiUpdateRunTime (
    VOID
    );

VOID
NTAPI
KiUpdateSystemTime (
    VOID
    );

// begin_ntddk begin_wdm begin_ntosp

NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );

// end_ntddk end_wdm
// begin_nthal

NTKERNELAPI
VOID
NTAPI
KeProfileInterruptWithSource (
    IN struct _KTRAP_FRAME *TrapFrame,
    IN KPROFILE_SOURCE ProfileSource
    );

// end_ntosp

VOID
NTAPI
KeProfileInterrupt (
    IN KIRQL OldIrql,
    IN KTRAP_FRAME TrapFrame
    );

VOID
NTAPI
KeUpdateRuntime (
    IN KIRQL OldIrql,
    IN KTRAP_FRAME TrapFrame
    );

VOID
NTAPI
KeUpdateSystemTime (
    IN KIRQL OldIrql,
    IN KTRAP_FRAME TrapFrame
    );

// begin_ntddk begin_wdm begin_ntndis begin_ntosp

#endif // defined(_X86_)

// end_nthal end_ntddk end_wdm end_ntndis end_ntosp

// begin_nthal begin_ntddk

// Use the following for kernel mode runtime checks of X86 system architecture

#ifdef _X86_

#ifdef IsNEC_98
#undef IsNEC_98
#endif

#ifdef IsNotNEC_98
#undef IsNotNEC_98
#endif

#ifdef SetNEC_98
#undef SetNEC_98
#endif

#ifdef SetNotNEC_98
#undef SetNotNEC_98
#endif

#define IsNEC_98     (SharedUserData->AlternativeArchitecture == NEC98x86)
#define IsNotNEC_98  (SharedUserData->AlternativeArchitecture != NEC98x86)
#define SetNEC_98    SharedUserData->AlternativeArchitecture = NEC98x86
#define SetNotNEC_98 SharedUserData->AlternativeArchitecture = StandardDesign

#endif

// end_nthal end_ntddk

//
// i386 arch. specific kernel functions.
//

// begin_ntosp
#ifdef _X86_
VOID
NTAPI
Ke386SetLdtProcess (
    struct _KPROCESS  *Process,
    PLDT_ENTRY  Ldt,
    ULONG       Limit
    );

VOID
NTAPI
Ke386SetDescriptorProcess (
    struct _KPROCESS  *Process,
    ULONG       Offset,
    LDT_ENTRY   LdtEntry
    );

VOID
NTAPI
Ke386GetGdtEntryThread (
    struct _KTHREAD *Thread,
    ULONG Offset,
    PKGDTENTRY Descriptor
    );

BOOLEAN
NTAPI
Ke386SetIoAccessMap (
    ULONG               MapNumber,
    PKIO_ACCESS_MAP     IoAccessMap
    );

BOOLEAN
NTAPI
Ke386QueryIoAccessMap (
    ULONG              MapNumber,
    PKIO_ACCESS_MAP    IoAccessMap
    );

BOOLEAN
NTAPI
Ke386IoSetAccessProcess (
    struct _KPROCESS    *Process,
    ULONG       MapNumber
    );

VOID
NTAPI
Ke386SetIOPL(
    struct _KPROCESS    *Process
    );

NTSTATUS
NTAPI
Ke386CallBios (
    IN ULONG BiosCommand,
    IN OUT PCONTEXT BiosArguments
    );

VOID
NTAPI
KiEditIopmDpc (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
NTAPI
Ki386GetSelectorParameters(
    IN USHORT Selector,
    OUT PULONG Flags,
    OUT PULONG Base,
    OUT PULONG Limit
    );

ULONG
Ki386DispatchOpcodeV86 (
    IN PKTRAP_FRAME TrapFrame
    );

NTSTATUS
NTAPI
Ke386SetVdmInterruptHandler (
    IN struct _KPROCESS *Process,
    IN ULONG Interrupt,
    IN USHORT Selector,
    IN ULONG  Offset,
    IN BOOLEAN Gate32
    );
#endif //_X86_
// end_ntosp
//
// i386 ABIOS specific routines.
//

NTSTATUS
NTAPI
KeI386GetLid(
    IN USHORT DeviceId,
    IN USHORT RelativeLid,
    IN BOOLEAN SharedLid,
    IN struct _DRIVER_OBJECT *DeviceObject,
    OUT PUSHORT LogicalId
    );

NTSTATUS
NTAPI
KeI386ReleaseLid(
    IN USHORT LogicalId,
    IN struct _DRIVER_OBJECT *DeviceObject
    );

NTSTATUS
NTAPI
KeI386AbiosCall(
    IN USHORT LogicalId,
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PUCHAR RequestBlock,
    IN USHORT EntryPoint
    );

//
// i386 misc routines
//
NTSTATUS
NTAPI
KeI386AllocateGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    );

VOID
NTAPI
KeI386Call16BitFunction (
    IN OUT PCONTEXT Regs
    );

USHORT
NTAPI
KeI386Call16BitCStyleFunction (
    IN ULONG EntryOffset,
    IN ULONG EntrySelector,
    IN PUCHAR Parameters,
    IN ULONG Size
    );

NTSTATUS
NTAPI
KeI386FlatToGdtSelector(
    IN ULONG SelectorBase,
    IN USHORT Length,
    IN USHORT Selector
    );

NTSTATUS
NTAPI
KeI386ReleaseGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    );

NTSTATUS
NTAPI
KeI386SetGdtSelector (
    ULONG       Selector,
    PKGDTENTRY  GdtValue
    );


VOID
NTAPI
KeOptimizeProcessorControlState (
    VOID
    );

//
// Vdm specific functions.
//

BOOLEAN
NTAPI
KeVdmInsertQueueApc (
    IN PKAPC             Apc,
    IN struct _KTHREAD  *Thread,
    IN KPROCESSOR_MODE   ApcMode,
    IN PKKERNEL_ROUTINE  KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE  NormalRoutine OPTIONAL,
    IN PVOID             NormalContext OPTIONAL,
    IN KPRIORITY         Increment
    );

FORCEINLINE
VOID
NTAPI
KeVdmClearApcThreadAddress (
    IN PKAPC Apc
    )

{
    if (Apc->Inserted == FALSE) {
        Apc->Thread = NULL;
    }
}

VOID
NTAPI
KeI386VdmInitialize (
    VOID
    );

//
// x86 functions for special instructions
//

VOID
NTAPI
CPUID (
    ULONG   InEax,
    PULONG  OutEax,
    PULONG  OutEbx,
    PULONG  OutEcx,
    PULONG  OutEdx
    );

LONGLONG
NTAPI
RDTSC (
    VOID
    );

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrRegister
    );

VOID
NTAPI
WRMSR (
    IN ULONG MsrRegister,
    IN ULONGLONG MsrValue
    );

//
// i386 Vdm specific data
//
extern ULONG KeI386EFlagsAndMaskV86;
extern ULONG KeI386EFlagsOrMaskV86;
extern BOOLEAN KeI386VdmIoplAllowed;
extern ULONG KeI386VirtualIntExtensions;


extern ULONG KeI386CpuType;
extern ULONG KeI386CpuStep;
extern BOOLEAN KeI386NpxPresent;
extern BOOLEAN KeI386FxsrPresent;


//
// i386 Feature bit definitions
//

#define KF_V86_VIS          0x00000001
#define KF_RDTSC            0x00000002
#define KF_CR4              0x00000004
#define KF_CMOV             0x00000008
#define KF_GLOBAL_PAGE      0x00000010
#define KF_LARGE_PAGE       0x00000020
#define KF_MTRR             0x00000040
#define KF_CMPXCHG8B        0x00000080
#define KF_MMX              0x00000100
#define KF_WORKING_PTE      0x00000200
#define KF_PAT              0x00000400
#define KF_FXSR             0x00000800
#define KF_FAST_SYSCALL     0x00001000
#define KF_XMMI             0x00002000
#define KF_3DNOW            0x00004000
#define KF_AMDK6MTRR        0x00008000
#define KF_XMMI64           0x00010000
#define KF_DTS              0x00020000
#define KF_SMT              0x00040000

//
// Define macro to test if x86 feature is present.
//

extern ULONG KiBootFeatureBits;

#define Isx86FeaturePresent(_f_) ((KiBootFeatureBits & (_f_)) != 0)

#endif // _i386_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\intrlk.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2001  Microsoft Corporation

Module Name:

    intrlk.h

Abstract:

    This module contains platform independent interlocked functions.

Author:

    David N. Cutler (davec) 15-Feb-2001

Revision History:

--*/

#ifndef _INTRLK_
#define _INTRLK_

//
// The following functions implement interlocked singly linked lists.
//
// WARNING: These lists can only be used when it is known that the ABA
//          removal problem cannot occur. If the ABA problem can occur,
//          then SLIST's should be used.
//

FORCEINLINE
PSINGLE_LIST_ENTRY
InterlockedPopEntrySingleList (
    IN PSINGLE_LIST_ENTRY ListHead
    )

/*

Routine Description:

    This function pops an entry from the front of a singly linked list.

Arguments:

    ListHead - Supplies a pointer to the listhead of a singly linked list.

Return Value:

    If the list is empty, then NULL is returned. Otherwise, the address of the
    first entry removed from the list is returned as the function
    value.

*/

{

    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY NextEntry;

    FirstEntry = ListHead->Next;
    do {
        if (FirstEntry == NULL) {
            return NULL;
        }

        NextEntry = FirstEntry;
        FirstEntry =
            (PSINGLE_LIST_ENTRY)InterlockedCompareExchangePointer((PVOID *)ListHead,
                                                                  FirstEntry->Next,
                                                                  FirstEntry);

    } while (FirstEntry != NextEntry);
    return FirstEntry;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
InterlockedPushEntrySingleList (
    IN PSINGLE_LIST_ENTRY ListHead,
    IN PSINGLE_LIST_ENTRY Entry
    )

/*

Routine Description:

    This function pushes an entry onto the front of a singly linked list.

Arguments:

    ListHead - Supplies a pointer to the listhead of a singly linked list.

    Entry - Supplies a pointer to a single list entry.

Return Value:

    The previous contents of the listhead are returned as the function value.
    If NULL is returned, then the list transitioned for an empty to a non
    empty state.

*/

{

    PSINGLE_LIST_ENTRY FirstEntry;
    PSINGLE_LIST_ENTRY NextEntry;

    FirstEntry = ListHead->Next;
    do {
        Entry->Next = FirstEntry;
        NextEntry = FirstEntry;
        FirstEntry =
            (PSINGLE_LIST_ENTRY)InterlockedCompareExchangePointer((PVOID *)ListHead,
                                                                  Entry,
                                                                  FirstEntry);

    } while (FirstEntry != NextEntry);
    return FirstEntry;
}

FORCEINLINE
PSINGLE_LIST_ENTRY
InterlockedFlushSingleList (
    IN PSINGLE_LIST_ENTRY ListHead
    )

/*

Routine Description:

    This function pops the entire list from the front of a singly linked list.

Arguments:

    ListHead - Supplies a pointer to the listhead of a singly linked list.

Return Value:

    If the list is empty, then NULL is returned. Otherwise, the address of the
    first entry removed from the list is returned as the function
    value.

*/

{

    return (PSINGLE_LIST_ENTRY)InterlockedExchangePointer((PVOID *)ListHead,
                                                          NULL);
}

#endif // _INTRLK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\inc\io.h ===
/*++ BUILD Version: 0013    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    io.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 12-Apr-1989


Revision History:


--*/

#ifndef _IO_
#define _IO_

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis begin_ntosp
//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d


//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

// end_wdm end_ntndis
//
// Directory control minor function codes
//

#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02

//
// File system control minor function codes.  Note that "user request" is
// assumed to be zero by both the I/O system and file systems.  Do not change
// this value.
//

#define IRP_MN_USER_FS_REQUEST          0x00
#define IRP_MN_MOUNT_VOLUME             0x01
#define IRP_MN_VERIFY_VOLUME            0x02
#define IRP_MN_LOAD_FILE_SYSTEM         0x03
#define IRP_MN_TRACK_LINK               0x04    // To be obsoleted soon
#define IRP_MN_KERNEL_CALL              0x04

//
// Lock control minor function codes
//

#define IRP_MN_LOCK                     0x01
#define IRP_MN_UNLOCK_SINGLE            0x02
#define IRP_MN_UNLOCK_ALL               0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY        0x04

//
// Read and Write minor function codes for file systems supporting Lan Manager
// software.  All of these subfunction codes are invalid if the file has been
// opened with FO_NO_INTERMEDIATE_BUFFERING.  They are also invalid in combi-
// nation with synchronous calls (Irp Flag or file open option).
//
// Note that "normal" is assumed to be zero by both the I/O system and file
// systems.  Do not change this value.
//

#define IRP_MN_NORMAL                   0x00
#define IRP_MN_DPC                      0x01
#define IRP_MN_MDL                      0x02
#define IRP_MN_COMPLETE                 0x04
#define IRP_MN_COMPRESSED               0x08

#define IRP_MN_MDL_DPC                  (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL             (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC         (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)

// begin_wdm
//
// Device Control Request minor function codes for SCSI support. Note that
// user requests are assumed to be zero.
//

#define IRP_MN_SCSI_CLASS               0x01

//
// PNP minor function codes.
//

#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06

#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D

#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17
// end_wdm
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
// begin_wdm

//
// POWER minor function codes
//
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03

// begin_ntminiport
//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09
// Minor code 0x0a is reserved
#define IRP_MN_REGINFO_EX                   0x0b

// end_ntminiport
// end_wdm end_ntddk end_nthal end_ntifs end_ntosp

// The following minor code is reserved as a private WMI minor function
// For drivers who cannot include io.h, please see wmikm.h
//
// begin_wmikm
#define IRP_MN_SET_TRACE_NOTIFY             0x0A

// end_wmikm
// begin_wdm begin_ntddk begin_nthal begin_ntifs begin_ntosp

//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
// end_ntddk end_wdm end_nthal end_ntosp

#define IO_OPEN_PAGING_FILE             0x0002
#define IO_OPEN_TARGET_DIRECTORY        0x0004

//
// Flags not passed to driver
//

// begin_ntddk begin_wdm begin_ntosp
#define IO_NO_PARAMETER_CHECKING        0x0100

//
// Define Information fields for whether or not a REPARSE or a REMOUNT has
// occurred in the file system.
//

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1

// end_ntddk end_wdm

#define IO_CHECK_CREATE_PARAMETERS      0x0200
#define IO_ATTACH_DEVICE                0x0400

// end_ntosp

// begin_ntifs begin_ntosp

//
//  This flag is only meaning full to IoCreateFileSpecifyDeviceObjectHint.
//  FileHandles created using IoCreateFileSpecifyDeviceObjectHint with this
//  flag set will bypass ShareAccess checks on this file.
//

#define IO_IGNORE_SHARE_ACCESS_CHECK    0x0800  // Ignores share access checks on opens.

// end_ntifs end_ntosp

// Define kernel-only, internal option flags
//

#define IO_ATTACH_DEVICE_API            0x80000000


// end_ntifs

//
// Define the driver interfaces required to write memory dumps.
//

//
// Define stall routine type for the dump driver.
//
// begin_ntosp
typedef
VOID
(*PSTALL_ROUTINE) (
    IN ULONG Delay
    );

//
// Define the interfaces for the dump driver's routines.
//

typedef
BOOLEAN
(*PDUMP_DRIVER_OPEN) (
    IN LARGE_INTEGER PartitionOffset
    );

typedef
NTSTATUS
(*PDUMP_DRIVER_WRITE) (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    );

//
// Actions accepted by DRIVER_WRITE_PENDING
//
#define IO_DUMP_WRITE_FULFILL   0   // fulfill IO request as if DRIVER_WAIT
#define IO_DUMP_WRITE_START     1   // start new IO
#define IO_DUMP_WRITE_RESUME    2   // resume pending IO
#define IO_DUMP_WRITE_FINISH    3   // finish pending IO
#define IO_DUMP_WRITE_INIT      4   // initialize locals

// size of data used by WRITE_PENDING that should be preserved
// between the calls
#define IO_DUMP_WRITE_DATA_PAGES 2
#define IO_DUMP_WRITE_DATA_SIZE (IO_DUMP_WRITE_DATA_PAGES << PAGE_SHIFT)

typedef
NTSTATUS
(*PDUMP_DRIVER_WRITE_PENDING) (
    IN LONG Action,
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl,
    IN PVOID LocalData
    );


typedef
VOID
(*PDUMP_DRIVER_FINISH) (
    VOID
    );

struct _ADAPTER_OBJECT;

//
// This is the information passed from the system to the disk dump driver
// during the driver's initialization.
//

typedef struct _DUMP_INITIALIZATION_CONTEXT {
    ULONG Length;
    ULONG Reserved;             // Was MBR Checksum. Should be zero now.
    PVOID MemoryBlock;
    PVOID CommonBuffer[2];
    PHYSICAL_ADDRESS PhysicalAddress[2];
    PSTALL_ROUTINE StallRoutine;
    PDUMP_DRIVER_OPEN OpenRoutine;
    PDUMP_DRIVER_WRITE WriteRoutine;
    PDUMP_DRIVER_FINISH FinishRoutine;
    struct _ADAPTER_OBJECT *AdapterObject;
    PVOID MappedRegisterBase;
    PVOID PortConfiguration;
    BOOLEAN CrashDump;
    ULONG MaximumTransferSize;
    ULONG CommonBufferSize;
    PVOID TargetAddress; //Opaque pointer to target address structure
    PDUMP_DRIVER_WRITE_PENDING WritePendingRoutine;
    ULONG PartitionStyle;
    union {
        struct {
            ULONG Signature;
            ULONG CheckSum;
        } Mbr;
        struct {
            GUID DiskId;
        } Gpt;
    } DiskInfo;
} DUMP_INITIALIZATION_CONTEXT, *PDUMP_INITIALIZATION_CONTEXT;


// begin_ntddk
//
// Define callout routine type for use in IoQueryDeviceDescription().
//

typedef NTSTATUS (*PIO_QUERY_DEVICE_ROUTINE)(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );


// Defines the order of the information in the array of
// PKEY_VALUE_FULL_INFORMATION.
//

typedef enum _IO_QUERY_DEVICE_DATA_FORMAT {
    IoQueryDeviceIdentifier = 0,
    IoQueryDeviceConfigurationData,
    IoQueryDeviceComponentInformation,
    IoQueryDeviceMaxData
} IO_QUERY_DEVICE_DATA_FORMAT, *PIO_QUERY_DEVICE_DATA_FORMAT;

// begin_wdm begin_ntifs
//
// Define the objects that can be created by IoCreateFile.
//

typedef enum _CREATE_FILE_TYPE {
    CreateFileTypeNone,
    CreateFileTypeNamedPipe,
    CreateFileTypeMailslot
} CREATE_FILE_TYPE;

// end_ntddk end_wdm end_ntifs

//
// Define the named pipe create parameters structure used for internal calls
// to IoCreateFile when a named pipe is being created.  This structure allows
// code invoking this routine to pass information specific to this function
// when creating a named pipe.
//

typedef struct _NAMED_PIPE_CREATE_PARAMETERS {
    ULONG NamedPipeType;
    ULONG ReadMode;
    ULONG CompletionMode;
    ULONG MaximumInstances;
    ULONG InboundQuota;
    ULONG OutboundQuota;
    LARGE_INTEGER DefaultTimeout;
    BOOLEAN TimeoutSpecified;
} NAMED_PIPE_CREATE_PARAMETERS, *PNAMED_PIPE_CREATE_PARAMETERS;

// end_ntosp

//
// Define the mailslot create parameters structure used for internal calls
// to IoCreateFile when a mailslot is being created.  This structure allows
// code invoking this routine to pass information specific to this function
// when creating a mailslot.
//

typedef struct _MAILSLOT_CREATE_PARAMETERS {
    ULONG MailslotQuota;
    ULONG MaximumMessageSize;
    LARGE_INTEGER ReadTimeout;
    BOOLEAN TimeoutSpecified;
} MAILSLOT_CREATE_PARAMETERS, *PMAILSLOT_CREATE_PARAMETERS;

//
// Define the dump driver stack context structure
//

typedef struct DUMP_STACK_IMAGE{
    LIST_ENTRY                  Link;
    PLDR_DATA_TABLE_ENTRY       Image;
    PVOID                       ImageBase;
    ULONG                       SizeOfImage;
} DUMP_STACK_IMAGE, *PDUMP_STACK_IMAGE;

typedef struct _DUMP_STACK_CONTEXT {
    DUMP_INITIALIZATION_CONTEXT Init;
    LARGE_INTEGER               PartitionOffset;
    PVOID                       DumpPointers;
    ULONG                       PointersLength;
    PWCHAR                      ModulePrefix;
    LIST_ENTRY                  DriverList;
    ANSI_STRING                 InitMsg;
    ANSI_STRING                 ProgMsg;
    ANSI_STRING                 DoneMsg;
    PVOID                       FileObject;
    enum _DEVICE_USAGE_NOTIFICATION_TYPE    UsageType;
} DUMP_STACK_CONTEXT, *PDUMP_STACK_CONTEXT;

#define IO_DUMP_MAX_MDL_PAGES           8
#define IO_DUMP_MEMORY_BLOCK_PAGES      8
#define IO_DUMP_COMMON_BUFFER_SIZE      0x2000

NTSTATUS
IoGetDumpStack(
    IN PWCHAR ModulePrefix,
    OUT PDUMP_STACK_CONTEXT *DumpStack,
    IN enum _DEVICE_USAGE_NOTIFICATION_TYPE UsageType,
    IN ULONG IgnoreDeviceUsageFailure
    );

NTSTATUS
IoInitializeDumpStack(
    IN PDUMP_STACK_CONTEXT  DumpStack,
    IN PUCHAR               MessageBuffer OPTIONAL
    );

typedef enum _CRASHDUMP_CONFIGURATION {
    CrashDumpDisable = 0,
    CrashDumpReconfigure
} CRASHDUMP_CONFIGURATION;

NTSTATUS
IoConfigureCrashDump(
    CRASHDUMP_CONFIGURATION Config
    );

BOOLEAN
IoInitializeCrashDump(
    IN HANDLE Pagefile
    );

VOID
IoGetDumpHiberRanges (
    IN PVOID                    HiberContext,
    IN PDUMP_STACK_CONTEXT      DumpStack
    );

NTKERNELAPI
BOOLEAN
IoWriteCrashDump(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4,
    IN PVOID ContextSave,
    IN PKTHREAD Thread,
    OUT PBOOLEAN Reboot
    );

BOOLEAN
IoIsTriageDumpEnabled(
    VOID
    );

BOOLEAN
IoAddTriageDumpDataBlock(
    IN PVOID Address,
    IN ULONG Length
    );


VOID
IoFreeDumpStack(
    IN PDUMP_STACK_CONTEXT DumpStack
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp
//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;
struct _SCATTER_GATHER_LIST;

//
// Define the I/O version of a DPC routine.
//

typedef
VOID
(*PIO_DPC_ROUTINE) (
    IN PKDPC Dpc,
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID Context
    );

//
// Define driver timer routine type.
//

typedef
VOID
(*PIO_TIMER_ROUTINE) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN PVOID Context
    );

//
// Define driver initialization routine type.
//
typedef
NTSTATUS
(*PDRIVER_INITIALIZE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

// end_wdm
//
// Define driver reinitialization routine type.
//

typedef
VOID
(*PDRIVER_REINITIALIZE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN PVOID Context,
    IN ULONG Count
    );

// begin_wdm begin_ntndis
//
// Define driver cancel routine type.
//

typedef
VOID
(*PDRIVER_CANCEL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver unload routine type.
//
typedef
VOID
(*PDRIVER_UNLOAD) (
    IN struct _DRIVER_OBJECT *DriverObject
    );
//
// Define driver AddDevice routine type.
//

typedef
NTSTATUS
(*PDRIVER_ADD_DEVICE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN struct _DEVICE_OBJECT *PhysicalDeviceObject
    );

// end_ntddk end_wdm end_nthal end_ntndis end_ntosp

//
// Define driver FS notification change routine type.
//

typedef
VOID
(*PDRIVER_FS_NOTIFICATION) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN BOOLEAN FsActive
    );

// begin_ntddk begin_wdm begin_ntosp

//
// Define fast I/O procedure prototypes.
//
// Fast I/O read and write procedures.
//

typedef
BOOLEAN
(*PFAST_IO_CHECK_IF_POSSIBLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O query basic and standard information procedures.
//

typedef
BOOLEAN
(*PFAST_IO_QUERY_BASIC_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_QUERY_STANDARD_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O lock and unlock procedures.
//

typedef
BOOLEAN
(*PFAST_IO_LOCK) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_SINGLE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_ALL) (
    IN struct _FILE_OBJECT *FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_UNLOCK_ALL_BY_KEY) (
    IN struct _FILE_OBJECT *FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Fast I/O device control procedure.
//

typedef
BOOLEAN
(*PFAST_IO_DEVICE_CONTROL) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define callbacks for NtCreateSection to synchronize correctly with
// the file system.  It pre-acquires the resources that will be needed
// when calling to query and set file/allocation size in the file system.
//

typedef
VOID
(*PFAST_IO_ACQUIRE_FILE) (
    IN struct _FILE_OBJECT *FileObject
    );

typedef
VOID
(*PFAST_IO_RELEASE_FILE) (
    IN struct _FILE_OBJECT *FileObject
    );

//
// Define callback for drivers that have device objects attached to lower-
// level drivers' device objects.  This callback is made when the lower-level
// driver is deleting its device object.
//

typedef
VOID
(*PFAST_IO_DETACH_DEVICE) (
    IN struct _DEVICE_OBJECT *SourceDevice,
    IN struct _DEVICE_OBJECT *TargetDevice
    );

//
// This structure is used by the server to quickly get the information needed
// to service a server open call.  It is takes what would be two fast io calls
// one for basic information and the other for standard information and makes
// it into one call.
//

typedef
BOOLEAN
(*PFAST_IO_QUERY_NETWORK_OPEN_INFO) (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT struct _FILE_NETWORK_OPEN_INFORMATION *Buffer,
    OUT struct _IO_STATUS_BLOCK *IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
//  Define Mdl-based routines for the server to call
//

typedef
BOOLEAN
(*PFAST_IO_MDL_READ) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_READ_COMPLETE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_PREPARE_MDL_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_WRITE_COMPLETE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

typedef
NTSTATUS
(*PFAST_IO_ACQUIRE_FOR_MOD_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER EndingOffset,
    OUT struct _ERESOURCE **ResourceToRelease,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
NTSTATUS
(*PFAST_IO_RELEASE_FOR_MOD_WRITE) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _ERESOURCE *ResourceToRelease,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

//
//  If this routine is present, it will be called by FsRtl
//  to acquire the file for the mapped page writer.
//

typedef
NTSTATUS
(*PFAST_IO_ACQUIRE_FOR_CCFLUSH) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
NTSTATUS
(*PFAST_IO_RELEASE_FOR_CCFLUSH) (
    IN struct _FILE_OBJECT *FileObject,
    IN struct _DEVICE_OBJECT *DeviceObject
             );

typedef
BOOLEAN
(*PFAST_IO_READ_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_WRITE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_READ_COMPLETE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED) (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

typedef
BOOLEAN
(*PFAST_IO_QUERY_OPEN) (
    IN struct _IRP *Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define the structure to describe the Fast I/O dispatch routines.  Any
// additions made to this structure MUST be added monotonically to the end
// of the structure, and fields CANNOT be removed from the middle.
//

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible;
    PFAST_IO_READ FastIoRead;
    PFAST_IO_WRITE FastIoWrite;
    PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo;
    PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo;
    PFAST_IO_LOCK FastIoLock;
    PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle;
    PFAST_IO_UNLOCK_ALL FastIoUnlockAll;
    PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey;
    PFAST_IO_DEVICE_CONTROL FastIoDeviceControl;
    PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection;
    PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection;
    PFAST_IO_DETACH_DEVICE FastIoDetachDevice;
    PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo;
    PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite;
    PFAST_IO_MDL_READ MdlRead;
    PFAST_IO_MDL_READ_COMPLETE MdlReadComplete;
    PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite;
    PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete;
    PFAST_IO_READ_COMPRESSED FastIoReadCompressed;
    PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed;
    PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed;
    PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;
    PFAST_IO_QUERY_OPEN FastIoQueryOpen;
    PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite;
    PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush;
    PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

// end_ntddk end_wdm end_ntosp

//
//  Valid values for FS_FILTER_PARAMETERS.AcquireForSectionSynchronization.SyncType
//

typedef enum _FS_FILTER_SECTION_SYNC_TYPE {
    SyncTypeOther = 0,
    SyncTypeCreateSection
} FS_FILTER_SECTION_SYNC_TYPE, *PFS_FILTER_SECTION_SYNC_TYPE;

//
//  Parameters union for the operations that
//  are exposed to the filters through the
//  FsFilterCallbacks registration mechanism.
//

typedef union _FS_FILTER_PARAMETERS {

    //
    //  AcquireForModifiedPageWriter
    //

    struct {
        PLARGE_INTEGER EndingOffset;
    } AcquireForModifiedPageWriter;

    //
    //  ReleaseForModifiedPageWriter
    //

    struct {
        PERESOURCE ResourceToRelease;
    } ReleaseForModifiedPageWriter;

    //
    //  AcquireForSectionSynchronization
    //

    struct {
        FS_FILTER_SECTION_SYNC_TYPE SyncType;
        ULONG PageProtection;
    } AcquireForSectionSynchronization;

    //
    //  Other
    //

    struct {
        PVOID Argument1;
        PVOID Argument2;
        PVOID Argument3;
        PVOID Argument4;
        PVOID Argument5;
    } Others;

} FS_FILTER_PARAMETERS, *PFS_FILTER_PARAMETERS;

//
//  These are the valid values for the Operation field
//  of the FS_FILTER_CALLBACK_DATA structure.
//

#define FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION      (UCHAR)-1
#define FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION      (UCHAR)-2
#define FS_FILTER_ACQUIRE_FOR_MOD_WRITE                    (UCHAR)-3
#define FS_FILTER_RELEASE_FOR_MOD_WRITE                    (UCHAR)-4
#define FS_FILTER_ACQUIRE_FOR_CC_FLUSH                     (UCHAR)-5
#define FS_FILTER_RELEASE_FOR_CC_FLUSH                     (UCHAR)-6

typedef struct _FS_FILTER_CALLBACK_DATA {

    ULONG SizeOfFsFilterCallbackData;
    UCHAR Operation;
    UCHAR Reserved;

    struct _DEVICE_OBJECT *DeviceObject;
    struct _FILE_OBJECT *FileObject;

    FS_FILTER_PARAMETERS Parameters;

} FS_FILTER_CALLBACK_DATA, *PFS_FILTER_CALLBACK_DATA;

//
//  Prototype for the callbacks received before an operation
//  is passed to the base file system.
//
//  A filter can fail this operation, but consistant failure
//  will halt system progress.
//

typedef
NTSTATUS
(*PFS_FILTER_CALLBACK) (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    );

//
//  Prototype for the completion callback received after an
//  operation is completed.
//

typedef
VOID
(*PFS_FILTER_COMPLETION_CALLBACK) (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    );

//
//  This is the structure that the file system filter fills in to
//  receive notifications for these locking operations.
//
//  A filter should set the field to NULL for any notification callback
//  it doesn't wish to receive.
//

typedef struct _FS_FILTER_CALLBACKS {

    ULONG SizeOfFsFilterCallbacks;
    ULONG Reserved; //  For alignment

    PFS_FILTER_CALLBACK PreAcquireForSectionSynchronization;
    PFS_FILTER_COMPLETION_CALLBACK PostAcquireForSectionSynchronization;
    PFS_FILTER_CALLBACK PreReleaseForSectionSynchronization;
    PFS_FILTER_COMPLETION_CALLBACK PostReleaseForSectionSynchronization;
    PFS_FILTER_CALLBACK PreAcquireForCcFlush;
    PFS_FILTER_COMPLETION_CALLBACK PostAcquireForCcFlush;
    PFS_FILTER_CALLBACK PreReleaseForCcFlush;
    PFS_FILTER_COMPLETION_CALLBACK PostReleaseForCcFlush;
    PFS_FILTER_CALLBACK PreAcquireForModifiedPageWriter;
    PFS_FILTER_COMPLETION_CALLBACK PostAcquireForModifiedPageWriter;
    PFS_FILTER_CALLBACK PreReleaseForModifiedPageWriter;
    PFS_FILTER_COMPLETION_CALLBACK PostReleaseForModifiedPageWriter;

} FS_FILTER_CALLBACKS, *PFS_FILTER_CALLBACKS;

NTKERNELAPI
NTSTATUS
FsRtlRegisterFileSystemFilterCallbacks (
    IN struct _DRIVER_OBJECT *FilterDriverObject,
    IN PFS_FILTER_CALLBACKS Callbacks
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp
//
// Define the actions that a driver execution routine may request of the
// adapter/controller allocation routines upon return.
//

typedef enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject,
    DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION, *PIO_ALLOCATION_ACTION;

//
// Define device driver adapter/controller execution routine.
//

typedef
IO_ALLOCATION_ACTION
(*PDRIVER_CONTROL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

//
// Define the I/O system's structure for a connected interrupt.  This is
// useful for connecting an ISR to several different processors.
//

typedef struct _IO_INTERRUPT_STRUCTURE {
    KINTERRUPT InterruptObject;
    PKINTERRUPT InterruptArray[MAXIMUM_PROCESSORS];
    KSPIN_LOCK SpinLock;
} IO_INTERRUPT_STRUCTURE, *PIO_INTERRUPT_STRUCTURE;

// begin_ntddk begin_wdm begin_ntifs begin_ntosp
//
// Define the I/O system's security context type for use by file system's
// when checking access to volumes, files, and directories.
//

typedef struct _IO_SECURITY_CONTEXT {
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    PACCESS_STATE AccessState;
    ACCESS_MASK DesiredAccess;
    ULONG FullCreateOptions;
} IO_SECURITY_CONTEXT, *PIO_SECURITY_CONTEXT;

// end_ntddk end_wdm end_ntifs end_ntosp

//
// Define the I/O system's version of a timer.
//

typedef struct _IO_TIMER {
    CSHORT Type;
    CSHORT TimerFlag;
    LIST_ENTRY TimerList;
    PIO_TIMER_ROUTINE TimerRoutine;
    PVOID Context;
    struct _DEVICE_OBJECT *DeviceObject;
} IO_TIMER, *PIO_TIMER;

//
// Define the client driver object extension header.
//

typedef struct _IO_CLIENT_EXTENSION {
    struct _IO_CLIENT_EXTENSION *NextExtension;
    PVOID ClientIdentificationAddress;
} IO_CLIENT_EXTENSION, *PIO_CLIENT_EXTENSION;

// begin_ntddk begin_nthal begin_ntifs begin_ntosp
//
// Define Volume Parameter Block (VPB) flags.
//

#define VPB_MOUNTED                     0x00000001
#define VPB_LOCKED                      0x00000002
#define VPB_PERSISTENT                  0x00000004
#define VPB_REMOVE_PENDING              0x00000008
#define VPB_RAW_MOUNT                   0x00000010


//
// Volume Parameter Block (VPB)
//

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;


#if defined(_WIN64)

//
// Use __inline DMA macros (hal.h)
//
#ifndef USE_DMA_MACROS
#define USE_DMA_MACROS
#endif

//
// Only PnP drivers!
//
#ifndef NO_LEGACY_DRIVERS
#define NO_LEGACY_DRIVERS
#endif

#endif // _WIN64


#if defined(USE_DMA_MACROS) && (defined(_NTDDK_) || defined(_NTDRIVER_) || defined(_NTOSP_))

//  begin_wdm
//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _DMA_ADAPTER *PADAPTER_OBJECT;

// end_wdm
#else

//
// Define object type specific fields of various objects used by the I/O system
//

typedef struct _ADAPTER_OBJECT *PADAPTER_OBJECT; // ntndis

#endif // USE_DMA_MACROS && (_NTDDK_ || _NTDRIVER_ || _NTOSP_)

//  begin_wdm
//
// Define Wait Context Block (WCB)
//

typedef struct _WAIT_CONTEXT_BLOCK {
    KDEVICE_QUEUE_ENTRY WaitQueueEntry;
    PDRIVER_CONTROL DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

// end_wdm

typedef struct _CONTROLLER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PVOID ControllerExtension;
    KDEVICE_QUEUE DeviceWaitQueue;

    ULONG Spare1;
    LARGE_INTEGER Spare2;

} CONTROLLER_OBJECT, *PCONTROLLER_OBJECT;

// begin_wdm
//
// Define Device Object (DO) flags
//
// end_wdm end_ntddk end_nthal end_ntifs

#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
#define DO_XIP                          0x00020000

// begin_wdm begin_ntddk begin_nthal begin_ntifs
//
// Device Object structure definition
//

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *NextDevice;
    struct _DEVICE_OBJECT *AttachedDevice;
    struct _IRP *CurrentIrp;
    PIO_TIMER Timer;
    ULONG Flags;                                // See above:  DO_...
    ULONG Characteristics;                      // See ntioapi:  FILE_...
    PVPB Vpb;
    PVOID DeviceExtension;
    DEVICE_TYPE DeviceType;
    CCHAR StackSize;
    union {
        LIST_ENTRY ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KDPC Dpc;

    //
    //  The following field is for exclusive use by the filesystem to keep
    //  track of the number of Fsp threads currently using the device
    //

    ULONG ActiveThreadCount;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    KEVENT DeviceLock;

    USHORT SectorSize;
    USHORT Spare1;

    struct _DEVOBJ_EXTENSION  *DeviceObjectExtension;
    PVOID  Reserved;
} DEVICE_OBJECT;

typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; // ntndis

// end_ntddk end_nthal end_ntifs end_wdm end_ntosp
//
// Define the Device Object Extension Flags
//

#define DOE_UNLOAD_PENDING              0x00000001
#define DOE_DELETE_PENDING              0x00000002
#define DOE_REMOVE_PENDING              0x00000004
#define DOE_REMOVE_PROCESSED            0x00000008
#define DOE_START_PENDING               0x00000010
#define DOE_STARTIO_REQUESTED           0x00000020
#define DOE_STARTIO_REQUESTED_BYKEY     0x00000040
#define DOE_STARTIO_CANCELABLE          0x00000080
#define DOE_STARTIO_DEFERRED            0x00000100  // Use non-recursive startio
#define DOE_STARTIO_NO_CANCEL           0x00000200  // Pass non-cancelable IRP to startio

// begin_ntddk begin_nthal begin_ntifs begin_wdm begin_ntosp

struct  _DEVICE_OBJECT_POWER_EXTENSION;

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object

// end_ntddk end_nthal end_ntifs end_wdm end_ntosp

    //
    // Universal Power Data - all device objects must have this
    //

    ULONG           PowerFlags;             // see ntos\po\pop.h
                                            // WARNING: Access via PO macros
                                            // and with PO locking rules ONLY.

    //
    // Pointer to the non-universal power data
    //  Power data that only some device objects need is stored in the
    //  device object power extension -> DOPE
    //  see po.h
    //

    struct          _DEVICE_OBJECT_POWER_EXTENSION  *Dope;

    //
    // power state information
    //

    //
    // Device object extension flags.  Protected by the IopDatabaseLock.
    //

    ULONG ExtensionFlags;

    //
    // PnP manager fields
    //

    PVOID           DeviceNode;

    //
    // AttachedTo is a pointer to the device object that this device
    // object is attached to.  The attachment chain is now doubly
    // linked: this pointer and DeviceObject->AttachedDevice provide the
    // linkage.
    //

    PDEVICE_OBJECT  AttachedTo;

    //
    // The next two fields are used to prevent recursion in IoStartNextPacket
    // interfaces.
    //

    LONG           StartIoCount;       // Used to keep track of number of pending start ios.
    LONG           StartIoKey;         // Next startio key
    ULONG          StartIoFlags;       // Start Io Flags. Need a separate flag so that it can be accessed without locks
    PVPB           Vpb;                // If not NULL contains the VPB of the mounted volume.
                                       // Set in the filesystem's volume device object.
                                       // This is a reverse VPB pointer.

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

//
// Define Driver Object (DRVO) flags
//

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr
// end_wdm
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040
// end_ntddk end_nthal end_ntifs end_ntosp
#define DRVO_BASE_FILESYSTEM_DRIVER     0x00000080   // A driver that is at the bottom of the filesystem stack.
// begin_ntddk begin_nthal begin_ntifs begin_ntosp

// begin_wdm

typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PDRIVER_ADD_DEVICE AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

    //
    // Note: any new shared fields get added here.
    //

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

    //
    // The client driver object extension field is used by class driver
    // to store per driver information.
    //

    PIO_CLIENT_EXTENSION ClientDriverExtension;

    //
    //  The file system filter callback extension field is used
    //  to safely notify filters of system operations that were
    //  previously not shown to file system filters.
    //

    PFS_FILTER_CALLBACKS FsFilterCallbacks;

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

} DRIVER_EXTENSION, *PDRIVER_EXTENSION;


typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection;
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_INITIALIZE DriverInit;
    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_UNLOAD DriverUnload;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis


// end_ntddk end_wdm end_ntifs end_ntosp

//
// Device Handler Object.   There is one of these objects per PnP
// device.  This object is given to the device driver as a PVOID
// and is used by the driver to refer to a particular device.
//

typedef struct _DEVICE_HANDLER_OBJECT {
    CSHORT Type;
    USHORT Size;

    //
    // Indentifies which bus extender this device handler
    // object is associated with
    //

    struct _BUS_HANDLER *BusHandler;

    //
    // The associated SlotNumber for this device handler
    //

    ULONG SlotNumber;

// end_nthal

    //
    // System internal fields
    //

    //
    // Pnp stuff
    //

    UNICODE_STRING ServiceKeyName;
    ULONG InstanceOrdinal;

// begin_nthal


} DEVICE_HANDLER_OBJECT, *PDEVICE_HANDLER_OBJECT;

// begin_ntddk begin_wdm begin_ntifs begin_ntosp

//
// The following structure is pointed to by the SectionObject pointer field
// of a file object, and is allocated by the various NT file systems.
//

typedef struct _SECTION_OBJECT_POINTERS {
    PVOID DataSectionObject;
    PVOID SharedCacheMap;
    PVOID ImageSectionObject;
} SECTION_OBJECT_POINTERS;
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

//
// Define File Object (FO) flags
//

#define FO_FILE_OPEN                    0x00000001
#define FO_SYNCHRONOUS_IO               0x00000002
#define FO_ALERTABLE_IO                 0x00000004
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000008
#define FO_WRITE_THROUGH                0x00000010
#define FO_SEQUENTIAL_ONLY              0x00000020
#define FO_CACHE_SUPPORTED              0x00000040
#define FO_NAMED_PIPE                   0x00000080
#define FO_STREAM_FILE                  0x00000100
#define FO_MAILSLOT                     0x00000200
#define FO_GENERATE_AUDIT_ON_CLOSE      0x00000400
#define FO_DIRECT_DEVICE_OPEN           0x00000800
#define FO_FILE_MODIFIED                0x00001000
#define FO_FILE_SIZE_CHANGED            0x00002000
#define FO_CLEANUP_COMPLETE             0x00004000
#define FO_TEMPORARY_FILE               0x00008000
#define FO_DELETE_ON_CLOSE              0x00010000
#define FO_OPENED_CASE_SENSITIVE        0x00020000
#define FO_HANDLE_CREATED               0x00040000
#define FO_FILE_FAST_IO_READ            0x00080000
#define FO_RANDOM_ACCESS                0x00100000
#define FO_FILE_OPEN_CANCELLED          0x00200000
#define FO_VOLUME_OPEN                  0x00400000
#define FO_FILE_OBJECT_HAS_EXTENSION    0x00800000
#define FO_REMOTE_ORIGIN                0x01000000

typedef struct _FILE_OBJECT {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT DeviceObject;
    PVPB Vpb;
    PVOID FsContext;
    PVOID FsContext2;
    PSECTION_OBJECT_POINTERS SectionObjectPointer;
    PVOID PrivateCacheMap;
    NTSTATUS FinalStatus;
    struct _FILE_OBJECT *RelatedFileObject;
    BOOLEAN LockOperation;
    BOOLEAN DeletePending;
    BOOLEAN ReadAccess;
    BOOLEAN WriteAccess;
    BOOLEAN DeleteAccess;
    BOOLEAN SharedRead;
    BOOLEAN SharedWrite;
    BOOLEAN SharedDelete;
    ULONG Flags;
    UNICODE_STRING FileName;
    LARGE_INTEGER CurrentByteOffset;
    ULONG Waiters;
    ULONG Busy;
    PVOID LastLock;
    KEVENT Lock;
    KEVENT Event;
    PIO_COMPLETION_CONTEXT CompletionContext;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; // ntndis

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_ASSOCIATED_IRP              0x00000008
#define IRP_BUFFERED_IO                 0x00000010
#define IRP_DEALLOCATE_BUFFER           0x00000020
#define IRP_INPUT_OPERATION             0x00000040
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040
#define IRP_CREATE_OPERATION            0x00000080
#define IRP_READ_OPERATION              0x00000100
#define IRP_WRITE_OPERATION             0x00000200
#define IRP_CLOSE_OPERATION             0x00000400
// end_wdm

#define IRP_DEFER_IO_COMPLETION         0x00000800
#define IRP_OB_QUERY_NAME               0x00001000
#define IRP_HOLD_DEVICE_QUEUE           0x00002000
#define IRP_RETRY_IO_COMPLETION         0x00004000
#define IRP_CLASS_CACHE_OPERATION       0x00008000

#define IRP_SET_USER_EVENT              IRP_CLOSE_OPERATION

// begin_wdm
//
// Define I/O request packet (IRP) alternate flags for allocation control.
//

#define IRP_QUOTA_CHARGED               0x01
#define IRP_ALLOCATED_MUST_SUCCEED      0x02
#define IRP_ALLOCATED_FIXED_SIZE        0x04
#define IRP_LOOKASIDE_ALLOCATION        0x08

//
// I/O Request Packet (IRP) definition
//

typedef struct _IRP {
    CSHORT Type;
    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Define a pointer to the Memory Descriptor List (MDL) for this I/O
    // request.  This field is only used if the I/O is "direct I/O".
    //

    PMDL MdlAddress;

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // The following union is used for one of three purposes:
    //
    //    1. This IRP is an associated IRP.  The field is a pointer to a master
    //       IRP.
    //
    //    2. This is the master IRP.  The field is the count of the number of
    //       IRPs which must complete (associated IRPs) before the master can
    //       complete.
    //
    //    3. This operation is being buffered and the field is the address of
    //       the system space buffer.
    //

    union {
        struct _IRP *MasterIrp;
        LONG IrpCount;
        PVOID SystemBuffer;
    } AssociatedIrp;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Requestor mode - mode of the original requestor of this operation.
    //

    KPROCESSOR_MODE RequestorMode;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // Cancel Irql - Irql at which the cancel spinlock was acquired.
    //

    KIRQL CancelIrql;

    //
    // ApcEnvironment - Used to save the APC environment at the time that the
    // packet was initialized.
    //

    CCHAR ApcEnvironment;

    //
    // Allocation control flags.
    //

    UCHAR AllocationFlags;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            PIO_APC_ROUTINE UserApcRoutine;
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // CancelRoutine - Used to contain the address of a cancel routine supplied
    // by a device driver when the IRP is in a cancelable state.
    //

    PDRIVER_CANCEL CancelRoutine;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[4];

                } ;

            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // Auxiliary buffer - pointer to any auxiliary buffer that is
            // required to pass information to a driver that is not contained
            // in a normal buffer.
            //

            PCHAR AuxiliaryBuffer;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
(*PIO_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_PAGING_FILE             0x02
#define SL_OPEN_TARGET_DIRECTORY        0x04

#define SL_CASE_SENSITIVE               0x80

//
// Read / Write
//

#define SL_KEY_SPECIFIED                0x01
#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_WRITE_THROUGH                0x04
#define SL_FT_SEQUENTIAL_WRITE          0x08

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

#define SL_READ_ACCESS_GRANTED          0x01
#define SL_WRITE_ACCESS_GRANTED         0x04    // Gap for SL_OVERRIDE_VERIFY_VOLUME

//
// Lock
//

#define SL_FAIL_IMMEDIATELY             0x01
#define SL_EXCLUSIVE_LOCK               0x02

//
// QueryDirectory / QueryEa / QueryQuota
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// NotifyDirectory
//

#define SL_WATCH_TREE                   0x01

//
// FileSystemControl
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

//
// Define PNP/POWER types required by IRP_MJ_PNP/IRP_MJ_POWER.
//

typedef enum _DEVICE_RELATION_TYPE {
    BusRelations,
    EjectionRelations,
    PowerRelations,
    RemovalRelations,
    TargetDeviceRelation,
    SingleBusRelations
} DEVICE_RELATION_TYPE, *PDEVICE_RELATION_TYPE;

typedef struct _DEVICE_RELATIONS {
    ULONG Count;
    PDEVICE_OBJECT Objects[1];  // variable length
} DEVICE_RELATIONS, *PDEVICE_RELATIONS;

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined,
    DeviceUsageTypePaging,
    DeviceUsageTypeHibernation,
    DeviceUsageTypeDumpFile
} DEVICE_USAGE_NOTIFICATION_TYPE;

// begin_ntminiport

// workaround overloaded definition (rpc generated headers all define INTERFACE
// to match the class name).
#undef INTERFACE

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;

// end_ntminiport

typedef struct _DEVICE_CAPABILITIES {
    USHORT Size;
    USHORT Version;  // the version documented here is version 1
    ULONG DeviceD1:1;
    ULONG DeviceD2:1;
    ULONG LockSupported:1;
    ULONG EjectSupported:1; // Ejectable in S0
    ULONG Removable:1;
    ULONG DockDevice:1;
    ULONG UniqueID:1;
    ULONG SilentInstall:1;
    ULONG RawDeviceOK:1;
    ULONG SurpriseRemovalOK:1;
    ULONG WakeFromD0:1;
    ULONG WakeFromD1:1;
    ULONG WakeFromD2:1;
    ULONG WakeFromD3:1;
    ULONG HardwareDisabled:1;
    ULONG NonDynamic:1;
    ULONG WarmEjectSupported:1;
    ULONG NoDisplayInUI:1;
    ULONG Reserved:14;

    ULONG Address;
    ULONG UINumber;

    DEVICE_POWER_STATE DeviceState[POWER_SYSTEM_MAXIMUM];
    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;
    ULONG D1Latency;
    ULONG D2Latency;
    ULONG D3Latency;
} DEVICE_CAPABILITIES, *PDEVICE_CAPABILITIES;

typedef struct _POWER_SEQUENCE {
    ULONG SequenceD1;
    ULONG SequenceD2;
    ULONG SequenceD3;
} POWER_SEQUENCE, *PPOWER_SEQUENCE;

typedef enum {
    BusQueryDeviceID = 0,       // <Enumerator>\<Enumerator-specific device id>
    BusQueryHardwareIDs = 1,    // Hardware ids
    BusQueryCompatibleIDs = 2,  // compatible device ids
    BusQueryInstanceID = 3,     // persistent id for this instance of the device
    BusQueryDeviceSerialNumber = 4    // serial number for this device
} BUS_QUERY_ID_TYPE, *PBUS_QUERY_ID_TYPE;

typedef ULONG PNP_DEVICE_STATE, *PPNP_DEVICE_STATE;

#define PNP_DEVICE_DISABLED                      0x00000001
#define PNP_DEVICE_DONT_DISPLAY_IN_UI            0x00000002
#define PNP_DEVICE_FAILED                        0x00000004
#define PNP_DEVICE_REMOVED                       0x00000008
#define PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED 0x00000010
#define PNP_DEVICE_NOT_DISABLEABLE               0x00000020

typedef enum {
    DeviceTextDescription = 0,            // DeviceDesc property
    DeviceTextLocationInformation = 1     // DeviceLocation property
} DEVICE_TEXT_TYPE, *PDEVICE_TEXT_TYPE;

//
// Define I/O Request Packet (IRP) stack locations
//

#if !defined(_AMD64_) && !defined(_IA64_)
#include "pshpack4.h"
#endif

// begin_ntndis

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

// end_ntndis

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT ShareAccess;
            ULONG POINTER_ALIGNMENT EaLength;
        } Create;

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

        //
        // System service parameters for:  NtCreateNamedPipeFile
        //
        // Notice that the fields in the following parameter structure must
        // match those for the create structure other than the last longword.
        // This is so that no distinctions need be made by the I/O system's
        // parse routine other than for the last longword.
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT Reserved;
            USHORT ShareAccess;
            PNAMED_PIPE_CREATE_PARAMETERS Parameters;
        } CreatePipe;

        //
        // System service parameters for:  NtCreateMailslotFile
        //
        // Notice that the fields in the following parameter structure must
        // match those for the create structure other than the last longword.
        // This is so that no distinctions need be made by the I/O system's
        // parse routine other than for the last longword.
        //

        struct {
            PIO_SECURITY_CONTEXT SecurityContext;
            ULONG Options;
            USHORT POINTER_ALIGNMENT Reserved;
            USHORT ShareAccess;
            PMAILSLOT_CREATE_PARAMETERS Parameters;
        } CreateMailslot;

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } Write;

// end_ntddk end_wdm end_nthal

        //
        // System service parameters for:  NtQueryDirectoryFile
        //

        struct {
            ULONG Length;
            PSTRING FileName;
            FILE_INFORMATION_CLASS FileInformationClass;
            ULONG POINTER_ALIGNMENT FileIndex;
        } QueryDirectory;

        //
        // System service parameters for:  NtNotifyChangeDirectoryFile
        //

        struct {
            ULONG Length;
            ULONG POINTER_ALIGNMENT CompletionFilter;
        } NotifyDirectory;

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
            PFILE_OBJECT FileObject;
            union {
                struct {
                    BOOLEAN ReplaceIfExists;
                    BOOLEAN AdvanceOnly;
                };
                ULONG ClusterCount;
                HANDLE DeleteHandle;
            };
        } SetFile;

// end_ntddk end_wdm end_nthal end_ntosp

        //
        // System service parameters for:  NtQueryEaFile
        //

        struct {
            ULONG Length;
            PVOID EaList;
            ULONG EaListLength;
            ULONG POINTER_ALIGNMENT EaIndex;
        } QueryEa;

        //
        // System service parameters for:  NtSetEaFile
        //

        struct {
            ULONG Length;
        } SetEa;

// begin_ntddk begin_wdm begin_nthal begin_ntosp

        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } QueryVolume;

// end_ntddk end_wdm end_nthal end_ntosp

        //
        // System service parameters for:  NtSetVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } SetVolume;
// begin_ntosp
        //
        // System service parameters for:  NtFsControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;
            PVOID Type3InputBuffer;
        } FileSystemControl;
        //
        // System service parameters for:  NtLockFile/NtUnlockFile
        //

        struct {
            PLARGE_INTEGER Length;
            ULONG POINTER_ALIGNMENT Key;
            LARGE_INTEGER ByteOffset;
        } LockControl;

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //

// end_ntddk end_wdm end_nthal
// end_ntosp

        //
        // System service parameters for:  NtCancelIoFile
        //
        // No extra user-supplied parameters.
        //

// begin_ntddk begin_wdm begin_nthal begin_ntosp

        //
        // System service parameters for:  NtDeviceIoControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
            PVOID Type3InputBuffer;
        } DeviceIoControl;

// end_wdm
        //
        // System service parameters for:  NtQuerySecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG POINTER_ALIGNMENT Length;
        } QuerySecurity;

        //
        // System service parameters for:  NtSetSecurityObject
        //

        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;

// begin_wdm
        //
        // Non-system service parameters.
        //
        // Parameters for MountVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } MountVolume;

        //
        // Parameters for VerifyVolume
        //

        struct {
            PVPB Vpb;
            PDEVICE_OBJECT DeviceObject;
        } VerifyVolume;

        //
        // Parameters for Scsi with internal device contorl.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;

// end_ntddk end_wdm end_nthal end_ntosp

        //
        // System service parameters for:  NtQueryQuotaInformationFile
        //

        struct {
            ULONG Length;
            PSID StartSid;
            PFILE_GET_QUOTA_INFORMATION SidList;
            ULONG SidListLength;
        } QueryQuota;

        //
        // System service parameters for:  NtSetQuotaInformationFile
        //

        struct {
            ULONG Length;
        } SetQuota;

// begin_ntddk begin_wdm begin_nthal begin_ntosp

        //
        // Parameters for IRP_MN_QUERY_DEVICE_RELATIONS
        //

        struct {
            DEVICE_RELATION_TYPE Type;
        } QueryDeviceRelations;

        //
        // Parameters for IRP_MN_QUERY_INTERFACE
        //

        struct {
            CONST GUID *InterfaceType;
            USHORT Size;
            USHORT Version;
            PINTERFACE Interface;
            PVOID InterfaceSpecificData;
        } QueryInterface;

// end_ntifs

        //
        // Parameters for IRP_MN_QUERY_CAPABILITIES
        //

        struct {
            PDEVICE_CAPABILITIES Capabilities;
        } DeviceCapabilities;

        //
        // Parameters for IRP_MN_FILTER_RESOURCE_REQUIREMENTS
        //

        struct {
            PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList;
        } FilterResourceRequirements;

        //
        // Parameters for IRP_MN_READ_CONFIG and IRP_MN_WRITE_CONFIG
        //

        struct {
            ULONG WhichSpace;
            PVOID Buffer;
            ULONG Offset;
            ULONG POINTER_ALIGNMENT Length;
        } ReadWriteConfig;

        //
        // Parameters for IRP_MN_SET_LOCK
        //

        struct {
            BOOLEAN Lock;
        } SetLock;

        //
        // Parameters for IRP_MN_QUERY_ID
        //

        struct {
            BUS_QUERY_ID_TYPE IdType;
        } QueryId;

        //
        // Parameters for IRP_MN_QUERY_DEVICE_TEXT
        //

        struct {
            DEVICE_TEXT_TYPE DeviceTextType;
            LCID POINTER_ALIGNMENT LocaleId;
        } QueryDeviceText;

        //
        // Parameters for IRP_MN_DEVICE_USAGE_NOTIFICATION
        //

        struct {
            BOOLEAN InPath;
            BOOLEAN Reserved[3];
            DEVICE_USAGE_NOTIFICATION_TYPE POINTER_ALIGNMENT Type;
        } UsageNotification;

        //
        // Parameters for IRP_MN_WAIT_WAKE
        //

        struct {
            SYSTEM_POWER_STATE PowerState;
        } WaitWake;

        //
        // Parameter for IRP_MN_POWER_SEQUENCE
        //

        struct {
            PPOWER_SEQUENCE PowerSequence;
        } PowerSequence;

        //
        // Parameters for IRP_MN_SET_POWER and IRP_MN_QUERY_POWER
        //

        struct {
            ULONG SystemContext;
            POWER_STATE_TYPE POINTER_ALIGNMENT Type;
            POWER_STATE POINTER_ALIGNMENT State;
            POWER_ACTION POINTER_ALIGNMENT ShutdownType;
        } Power;

        //
        // Parameters for StartDevice
        //

        struct {
            PCM_RESOURCE_LIST AllocatedResources;
            PCM_RESOURCE_LIST AllocatedResourcesTranslated;
        } StartDevice;

// begin_ntifs
        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

        //
        // WMI Irps
        //

        struct {
            ULONG_PTR ProviderId;
            PVOID DataPath;
            ULONG BufferSize;
            PVOID Buffer;
        } WMI;

        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;
#if !defined(_AMD64_) && !defined(_IA64_)
#include "poppack.h"
#endif

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    ULONG Deleters;
    ULONG SharedRead;
    ULONG SharedWrite;
    ULONG SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

// end_wdm

//
// The following structure is used by drivers that are initializing to
// determine the number of devices of a particular type that have already
// been initialized.  It is also used to track whether or not the AtDisk
// address range has already been claimed.  Finally, it is used by the
// NtQuerySystemInformation system service to return device type counts.
//

typedef struct _CONFIGURATION_INFORMATION {

    //
    // This field indicates the total number of disks in the system.  This
    // number should be used by the driver to determine the name of new
    // disks.  This field should be updated by the driver as it finds new
    // disks.
    //

    ULONG DiskCount;                // Count of hard disks thus far
    ULONG FloppyCount;              // Count of floppy disks thus far
    ULONG CdRomCount;               // Count of CD-ROM drives thus far
    ULONG TapeCount;                // Count of tape drives thus far
    ULONG ScsiPortCount;            // Count of SCSI port adapters thus far
    ULONG SerialCount;              // Count of serial devices thus far
    ULONG ParallelCount;            // Count of parallel devices thus far

    //
    // These next two fields indicate ownership of one of the two IO address
    // spaces that are used by WD1003-compatable disk controllers.
    //

    BOOLEAN AtDiskPrimaryAddressClaimed;    // 0x1F0 - 0x1FF
    BOOLEAN AtDiskSecondaryAddressClaimed;  // 0x170 - 0x17F

    //
    // Indicates the structure version, as anything value belong this will have been added.
    // Use the structure size as the version.
    //

    ULONG Version;

    //
    // Indicates the total number of medium changer devices in the system.
    // This field will be updated by the drivers as it determines that
    // new devices have been found and will be supported.
    //

    ULONG MediumChangerCount;

} CONFIGURATION_INFORMATION, *PCONFIGURATION_INFORMATION;

// end_ntddk end_nthal end_ntosp

//
// The following are global counters used by the I/O system to indicate the
// amount of I/O being performed in the system.  The first three counters
// are just that, counts of operations that have been requested, while the
// last three counters track the amount of data transferred for each type
// of I/O request.
//

extern KSPIN_LOCK IoStatisticsLock;
extern ULONG IoReadOperationCount;
extern ULONG IoWriteOperationCount;
extern ULONG IoOtherOperationCount;
extern LARGE_INTEGER IoReadTransferCount;
extern LARGE_INTEGER IoWriteTransferCount;
extern LARGE_INTEGER IoOtherTransferCount;

//
// It is difficult for cached file systems to properly charge quota
// for the storage that they allocate on behalf of user file handles,
// so the following amount of additional quota is charged against each
// handle as a "best guess" as to the amount of quota the file system
// will allocate on behalf of this handle.
//

//
// These numbers are totally arbitrary, and can be changed if it turns out
// that the file systems actually allocate more (or less) on behalf of
// their file objects.  The non-paged pool charge constant is added to the
// size of a FILE_OBJECT to get the actual charge amount.
//

#define IO_FILE_OBJECT_NON_PAGED_POOL_CHARGE    64
#define IO_FILE_OBJECT_PAGED_POOL_CHARGE        1024


// begin_ntddk begin_wdm begin_nthal begin_ntosp
//
// Public I/O routine definitions
//

NTKERNELAPI
VOID
IoAcquireCancelSpinLock(
    OUT PKIRQL Irql
    );

// end_ntddk end_wdm end_nthal end_ntosp

NTKERNELAPI
VOID
IoAcquireVpbSpinLock(
    OUT PKIRQL Irql
    );

// begin_ntddk  begin_nthal end_ntifs begin_ntosp

DECLSPEC_DEPRECATED_DDK                 // Use AllocateAdapterChannel
NTKERNELAPI
NTSTATUS
IoAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoAllocateController(
    IN PCONTROLLER_OBJECT ControllerObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

//  begin_wdm

NTKERNELAPI
NTSTATUS
IoAllocateDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress,
    IN ULONG DriverObjectExtensionSize,
    OUT PVOID *DriverObjectExtension
    );

// begin_ntifs

NTKERNELAPI
PVOID
IoAllocateErrorLogEntry(
    IN PVOID IoObject,
    IN UCHAR EntrySize
    );

NTKERNELAPI
PIRP
IoAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    );

NTKERNELAPI
PMDL
IoAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp OPTIONAL
    );

// end_wdm end_ntifs
//++
//
// VOID
// IoAssignArcName(
//     IN PUNICODE_STRING ArcName,
//     IN PUNICODE_STRING DeviceName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers of bootable media to create a symbolic
//     link between the ARC name of their device and its NT name.  This allows
//     the system to determine which device in the system was actually booted
//     from since the ARC firmware only deals in ARC names, and NT only deals
//     in NT names.
//
// Arguments:
//
//     ArcName - Supplies the Unicode string representing the ARC name.
//
//     DeviceName - Supplies the name to which the ARCname refers.
//
// Return Value:
//
//     None.
//
//--

#define IoAssignArcName( ArcName, DeviceName ) (  \
    IoCreateSymbolicLink( (ArcName), (DeviceName) ) )

DECLSPEC_DEPRECATED_DDK                 // Use Pnp or IoReprtDetectedDevice
NTKERNELAPI
NTSTATUS
IoAssignResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PIO_RESOURCE_REQUIREMENTS_LIST RequestedResources,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

// end_ntddk end_nthal end_ntosp

NTKERNELAPI
NTSTATUS
IoAsynchronousPageWrite(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PIO_APC_ROUTINE ApcRoutine,
    IN PVOID ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PIRP *Irp OPTIONAL
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

NTKERNELAPI
NTSTATUS
IoAttachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PUNICODE_STRING TargetDevice,
    OUT PDEVICE_OBJECT *AttachedDevice
    );

// end_wdm

DECLSPEC_DEPRECATED_DDK                 // Use IoAttachDeviceToDeviceStack
NTKERNELAPI
NTSTATUS
IoAttachDeviceByPointer(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

// begin_wdm

NTKERNELAPI
PDEVICE_OBJECT
IoAttachDeviceToDeviceStack(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );

NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
VOID
IoBuildPartialMdl(
    IN PMDL SourceMdl,
    IN OUT PMDL TargetMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length
    );

typedef struct _BOOTDISK_INFORMATION {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
} BOOTDISK_INFORMATION, *PBOOTDISK_INFORMATION;

//
// This structure should follow the previous structure field for field.
//
typedef struct _BOOTDISK_INFORMATION_EX {
    LONGLONG BootPartitionOffset;
    LONGLONG SystemPartitionOffset;
    ULONG BootDeviceSignature;
    ULONG SystemDeviceSignature;
    GUID BootDeviceGuid;
    GUID SystemDeviceGuid;
    BOOLEAN BootDeviceIsGpt;
    BOOLEAN SystemDeviceIsGpt;
} BOOTDISK_INFORMATION_EX, *PBOOTDISK_INFORMATION_EX;

NTKERNELAPI
NTSTATUS
IoGetBootDiskInformation(
    IN OUT PBOOTDISK_INFORMATION BootDiskInformation,
    IN ULONG Size
    );

// end_ntddk end_nthal end_wdm end_ntifs end_ntosp

NTSTATUS
IoBuildPoDeviceNotifyList (
    IN OUT PVOID Order
    );

VOID
IoMovePoNotifyChildren(
    IN PVOID Notify,
    IN PVOID Order
    );

PVOID
IoGetPoNotifyParent(
    PVOID Notify
    );

NTSTATUS
IoNotifyPowerOperationVetoed(
    IN POWER_ACTION             VetoedPowerOperation,
    IN PDEVICE_OBJECT           TargetedDeviceObject    OPTIONAL,
    IN PDEVICE_OBJECT           VetoingDeviceObject
    );

// begin_ntddk begin_nthal begin_wdm begin_ntifs begin_ntosp

NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)

NTKERNELAPI
BOOLEAN
IoCancelIrp(
    IN PIRP Irp
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

NTKERNELAPI
VOID
IoCancelThreadIo(
    IN PETHREAD Thread
    );

// begin_ntifs

NTKERNELAPI
NTSTATUS
IoCheckDesiredAccess(
    IN OUT PACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess
    );

NTKERNELAPI
NTSTATUS
IoCheckEaBufferValidity(
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    OUT PULONG ErrorOffset
    );

NTKERNELAPI
NTSTATUS
IoCheckFunctionAccess(
    IN ACCESS_MASK GrantedAccess,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN ULONG IoControlCode,
    IN PVOID Arg1 OPTIONAL,
    IN PVOID Arg2 OPTIONAL
    );


NTKERNELAPI
NTSTATUS
IoCheckQuerySetFileInformation(
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    IN BOOLEAN SetOperation
    );

NTKERNELAPI
NTSTATUS
IoCheckQuerySetVolumeInformation(
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    IN BOOLEAN SetOperation
    );


NTKERNELAPI
NTSTATUS
IoCheckQuotaBufferValidity(
    IN PFILE_QUOTA_INFORMATION QuotaBuffer,
    IN ULONG QuotaLength,
    OUT PULONG ErrorOffset
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp

NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    );

//
// This value should be returned from completion routines to continue
// completing the IRP upwards. Otherwise, STATUS_MORE_PROCESSING_REQUIRED
// should be returned.
//
#define STATUS_CONTINUE_COMPLETION      STATUS_SUCCESS

//
// Completion routines can also use this enumeration in place of status codes.
//
typedef enum _IO_COMPLETION_ROUTINE_RESULT {

    ContinueCompletion = STATUS_CONTINUE_COMPLETION,
    StopCompletion = STATUS_MORE_PROCESSING_REQUIRED

} IO_COMPLETION_ROUTINE_RESULT, *PIO_COMPLETION_ROUTINE_RESULT;

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)

// end_ntifs

NTKERNELAPI
NTSTATUS
IoConnectInterrupt(
    OUT PKINTERRUPT *InterruptObject,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN KAFFINITY ProcessorEnableMask,
    IN BOOLEAN FloatingSave
    );

//  end_wdm

NTKERNELAPI
PCONTROLLER_OBJECT
IoCreateController(
    IN ULONG Size
    );

//  begin_wdm begin_ntifs

NTKERNELAPI
NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN PUNICODE_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );

#define WDM_MAJORVERSION        0x01
#define WDM_MINORVERSION        0x20

NTKERNELAPI
BOOLEAN
IoIsWdmVersionAvailable(
    IN UCHAR MajorVersion,
    IN UCHAR MinorVersion
    );

// end_nthal

NTKERNELAPI
NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options
    );

// end_ntddk end_wdm end_ntosp

NTKERNELAPI
PFILE_OBJECT
IoCreateStreamFileObject(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    );

NTKERNELAPI
PFILE_OBJECT
IoCreateStreamFileObjectEx(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    OUT PHANDLE FileObjectHandle OPTIONAL
    );

NTKERNELAPI
PFILE_OBJECT
IoCreateStreamFileObjectLite(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    );

// begin_nthal begin_ntddk begin_wdm begin_ntosp

NTKERNELAPI
PKEVENT
IoCreateNotificationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    );

NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    );

NTKERNELAPI
PKEVENT
IoCreateSynchronizationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    );

NTKERNELAPI
NTSTATUS
IoCreateUnprotectedSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    );

//  end_wdm

//++
//
// VOID
// IoDeassignArcName(
//     IN PUNICODE_STRING ArcName
//     )
//
// Routine Description:
//
//     This routine is invoked by drivers to deassign an ARC name that they
//     created to a device.  This is generally only called if the driver is
//     deleting the device object, which means that the driver is probably
//     unloading.
//
// Arguments:
//
//     ArcName - Supplies the ARC name to be removed.
//
// Return Value:
//
//     None.
//
//--

#define IoDeassignArcName( ArcName ) (  \
    IoDeleteSymbolicLink( (ArcName) ) )

// end_ntifs

NTKERNELAPI
VOID
IoDeleteController(
    IN PCONTROLLER_OBJECT ControllerObject
    );

//  begin_wdm begin_ntifs

NTKERNELAPI
VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName
    );

NTKERNELAPI
VOID
IoDetachDevice(
    IN OUT PDEVICE_OBJECT TargetDevice
    );

// end_ntifs

NTKERNELAPI
VOID
IoDisconnectInterrupt(
    IN PKINTERRUPT InterruptObject
    );

// end_ntddk end_wdm end_nthal

NTKERNELAPI
VOID
IoEnqueueIrp(
    IN PIRP Irp
    );
// end_ntosp

NTKERNELAPI                                             // ntifs
BOOLEAN                                                 // ntifs
IoFastQueryNetworkAttributes(                           // ntifs
    IN POBJECT_ATTRIBUTES ObjectAttributes,             // ntifs
    IN ACCESS_MASK DesiredAccess,                       // ntifs
    IN ULONG OpenOptions,                               // ntifs
    OUT PIO_STATUS_BLOCK IoStatus,                      // ntifs
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer           // ntifs
    );                                                  // ntifs

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
VOID
IoFreeController(
    IN PCONTROLLER_OBJECT ControllerObject
    );

//  begin_wdm begin_ntifs

NTKERNELAPI
VOID
IoFreeIrp(
    IN PIRP Irp
    );

NTKERNELAPI
VOID
IoFreeMdl(
    IN PMDL Mdl
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

VOID
IoFreePoDeviceNotifyList (
    IN OUT PVOID Order
    );

NTSTATUS
IoGetDeviceInstanceName(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PUNICODE_STRING InstanceName
    );

NTSTATUS
IoGetLegacyVetoList(
    OUT PWSTR *VetoList OPTIONAL,
    OUT PPNP_VETO_TYPE VetoType
    );

// begin_ntifs begin_ntosp

NTKERNELAPI
PDEVICE_OBJECT
IoGetAttachedDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI                                 // ntddk wdm nthal
PDEVICE_OBJECT                              // ntddk wdm nthal
IoGetAttachedDeviceReference(               // ntddk wdm nthal
    IN PDEVICE_OBJECT DeviceObject          // ntddk wdm nthal
    );                                      // ntddk wdm nthal
                                            // ntddk wdm nthal
NTKERNELAPI
PDEVICE_OBJECT
IoGetBaseFileSystemDeviceObject(
    IN PFILE_OBJECT FileObject
    );

NTKERNELAPI                                 // ntddk nthal ntosp
PCONFIGURATION_INFORMATION                  // ntddk nthal ntosp
IoGetConfigurationInformation( VOID );      // ntddk nthal ntosp

// begin_ntddk begin_wdm begin_nthal

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )

// end_nthal end_wdm

NTKERNELAPI
PDEVICE_OBJECT
IoGetDeviceToVerify(
    IN PETHREAD Thread
    );

//  begin_wdm

NTKERNELAPI
PVOID
IoGetDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress
    );

NTKERNELAPI
PEPROCESS
IoGetCurrentProcess(
    VOID
    );

// begin_nthal

NTKERNELAPI
NTSTATUS
IoGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTKERNELAPI
struct _DMA_ADAPTER *
IoGetDmaAdapter(
    IN PDEVICE_OBJECT PhysicalDeviceObject,           OPTIONAL // required for PnP drivers
    IN struct _DEVICE_DESCRIPTION *DeviceDescription,
    IN OUT PULONG NumberOfMapRegisters
    );

NTKERNELAPI
BOOLEAN
IoForwardIrpSynchronously(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#define IoForwardAndCatchIrp IoForwardIrpSynchronously

//  end_wdm

NTKERNELAPI
PGENERIC_MAPPING
IoGetFileObjectGenericMapping(
    VOID
    );

// end_nthal


// begin_wdm

//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     IN ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )

// begin_nthal

NTKERNELAPI
PVOID
IoGetInitialStack(
    VOID
    );

NTKERNELAPI
VOID
IoGetStackLimits (
    OUT PULONG_PTR LowLimit,
    OUT PULONG_PTR HighLimit
    );

//
//  The following function is used to tell the caller how much stack is available
//

FORCEINLINE
ULONG_PTR
IoGetRemainingStackSize (
    VOID
    )
{
    ULONG_PTR Top;
    ULONG_PTR Bottom;

    IoGetStackLimits( &Bottom, &Top );
    return((ULONG_PTR)(&Top) - Bottom );
}

//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )

NTKERNELAPI
PDEVICE_OBJECT
IoGetRelatedDeviceObject(
    IN PFILE_OBJECT FileObject
    );

// end_ntddk end_wdm end_nthal

NTKERNELAPI
ULONG
IoGetRequestorProcessId(
    IN PIRP Irp
    );

NTKERNELAPI
PEPROCESS
IoGetRequestorProcess(
    IN PIRP Irp
    );

// end_ntosp

NTKERNELAPI
PIRP
IoGetTopLevelIrp(
    VOID
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp

//++
//
// VOID
// IoInitializeDpcRequest(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIO_DPC_ROUTINE DpcRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to initialize the DPC in a device object for a
//     device driver during its initialization routine.  The DPC is used later
//     when the driver interrupt service routine requests that a DPC routine
//     be queued for later execution.
//
// Arguments:
//
//     DeviceObject - Pointer to the device object that the request is for.
//
//     DpcRoutine - Address of the driver's DPC routine to be executed when
//         the DPC is dequeued for processing.
//
// Return Value:
//
//     None.
//
//--

#define IoInitializeDpcRequest( DeviceObject, DpcRoutine ) (\
    KeInitializeDpc( &(DeviceObject)->Dpc,                  \
                     (PKDEFERRED_ROUTINE) (DpcRoutine),     \
                     (DeviceObject) ) )

NTKERNELAPI
VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    );

NTKERNELAPI
NTSTATUS
IoInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    );

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

// begin_ntddk begin_wdm begin_ntifs begin_ntosp

NTKERNELAPI
VOID
IoReuseIrp(
    IN OUT PIRP Irp,
    IN NTSTATUS Iostatus
    );

// end_wdm

NTKERNELAPI
VOID
IoCancelFileOpen(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PFILE_OBJECT    FileObject
    );
// end_ntddk end_ntifs end_ntosp

NTKERNELAPI
BOOLEAN
IoInitSystem(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))

// end_ntddk end_wdm end_nthal end_ntosp

//++
//
// BOOLEAN
// IoIsFileOpenedExclusively(
//     IN PFILE_OBJECT FileObject
//     )
//
// Routine Description:
//
//     This routine is invoked to determine whether the file open represented
//     by the specified file object is opened exclusively.
//
// Arguments:
//
//     FileObject - Pointer to the file object that represents the open instance
//         of the target file to be tested for exclusive access.
//
// Return Value:
//
//     The function value is TRUE if the open instance of the file is exclusive;
//     otherwise FALSE is returned.
//
//--

#define IoIsFileOpenedExclusively( FileObject ) (\
    (BOOLEAN) !((FileObject)->SharedRead || (FileObject)->SharedWrite || (FileObject)->SharedDelete))

NTKERNELAPI
BOOLEAN
IoIsOperationSynchronous(
    IN PIRP Irp
    );

NTKERNELAPI
BOOLEAN
IoIsSystemThread(
    IN PETHREAD Thread
    );

NTKERNELAPI
BOOLEAN
IoIsValidNameGraftingBuffer(
    IN PIRP Irp,
    IN PREPARSE_DATA_BUFFER ReparseBuffer
    );

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
PIRP
IoMakeAssociatedIrp(
    IN PIRP Irp,
    IN CCHAR StackSize
    );

//  begin_wdm

//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )

// end_ntddk end_wdm end_nthal end_ntifs end_ntosp

NTKERNELAPI
BOOLEAN
IoPageFileCreated(
    IN HANDLE FileHandle
    );

NTKERNELAPI                                             // ntifs
NTSTATUS                                                // ntifs
IoPageRead(                                             // ntifs
    IN PFILE_OBJECT FileObject,                         // ntifs
    IN PMDL MemoryDescriptorList,                       // ntifs
    IN PLARGE_INTEGER StartingOffset,                   // ntifs
    IN PKEVENT Event,                                   // ntifs
    OUT PIO_STATUS_BLOCK IoStatusBlock                  // ntifs
    );                                                  // ntifs

NTKERNELAPI
NTSTATUS
IoAsynchronousPageRead(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

// begin_ntddk begin_ntosp
DECLSPEC_DEPRECATED_DDK                 // Use IoGetDeviceProperty
NTKERNELAPI
NTSTATUS
IoQueryDeviceDescription(
    IN PINTERFACE_TYPE BusType OPTIONAL,
    IN PULONG BusNumber OPTIONAL,
    IN PCONFIGURATION_TYPE ControllerType OPTIONAL,
    IN PULONG ControllerNumber OPTIONAL,
    IN PCONFIGURATION_TYPE PeripheralType OPTIONAL,
    IN PULONG PeripheralNumber OPTIONAL,
    IN PIO_QUERY_DEVICE_ROUTINE CalloutRoutine,
    IN PVOID Context
    );

// end_ntddk end_ntosp


// begin_ntifs

NTSTATUS
IoQueryFileDosDeviceName(
    IN PFILE_OBJECT FileObject,
    OUT POBJECT_NAME_INFORMATION *ObjectNameInformation
    );

NTKERNELAPI
NTSTATUS
IoQueryFileInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    );

NTKERNELAPI
NTSTATUS
IoQueryVolumeInformation(
    IN PFILE_OBJECT FileObject,
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    OUT PVOID FsInformation,
    OUT PULONG ReturnedLength
    );

// begin_ntosp
NTKERNELAPI
VOID
IoQueueThreadIrp(
    IN PIRP Irp
    );
// end_ntosp

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
VOID
IoRaiseHardError(
    IN PIRP Irp,
    IN PVPB Vpb OPTIONAL,
    IN PDEVICE_OBJECT RealDeviceObject
    );

NTKERNELAPI
BOOLEAN
IoRaiseInformationalHardError(
    IN NTSTATUS ErrorStatus,
    IN PUNICODE_STRING String OPTIONAL,
    IN PKTHREAD Thread OPTIONAL
    );

NTKERNELAPI
BOOLEAN
IoSetThreadHardErrorMode(
    IN BOOLEAN EnableHardErrors
    );

NTKERNELAPI
VOID
IoRegisterBootDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    );

NTKERNELAPI
VOID
IoRegisterDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    );

// end_ntddk end_nthal end_ntosp

NTKERNELAPI
VOID
IoRegisterFileSystem(
    IN OUT PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoRegisterFsRegistrationChange(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    );

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
NTSTATUS
IoRegisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoRegisterLastChanceShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

// begin_wdm

NTKERNELAPI
VOID
IoReleaseCancelSpinLock(
    IN KIRQL Irql
    );

// end_ntddk end_nthal end_wdm end_ntosp

NTKERNELAPI
VOID
IoReleaseVpbSpinLock(
    IN KIRQL Irql
    );

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

// end_ntddk end_ntifs end_ntosp

NTKERNELAPI
NTSTATUS
IoReportHalResourceUsage(
    IN PUNICODE_STRING HalName,
    IN PCM_RESOURCE_LIST RawResourceList,
    IN PCM_RESOURCE_LIST TranslatedResourceList,
    IN ULONG ResourceListSize
    );

// begin_ntddk begin_ntifs begin_ntosp

DECLSPEC_DEPRECATED_DDK                 // Use IoReportResourceForDetection
NTKERNELAPI
NTSTATUS
IoReportResourceUsage(
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    );

//  begin_wdm

//++
//
// VOID
// IoRequestDpc(
//     IN PDEVICE_OBJECT DeviceObject,
//     IN PIRP Irp,
//     IN PVOID Context
//     )
//
// Routine Description:
//
//     This routine is invoked by the device driver's interrupt service routine
//     to request that a DPC routine be queued for later execution at a lower
//     IRQL.
//
// Arguments:
//
//     DeviceObject - Device object for which the request is being processed.
//
//     Irp - Pointer to the current I/O Request Packet (IRP) for the specified
//         device.
//
//     Context - Provides a general context parameter to be passed to the
//         DPC routine.
//
// Return Value:
//
//     None.
//
//--

#define IoRequestDpc( DeviceObject, Irp, Context ) ( \
    KeInsertQueueDpc( &(DeviceObject)->Dpc, (Irp), (Context) ) )

//++
//
// PDRIVER_CANCEL
// IoSetCancelRoutine(
//     IN PIRP Irp,
//     IN PDRIVER_CANCEL CancelRoutine
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a cancel routine which
//     is to be invoked when an I/O packet has been canceled.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CancelRoutine - Address of the cancel routine that is to be invoked
//         if the IRP is cancelled.
//
// Return Value:
//
//     Previous value of CancelRoutine field in the IRP.
//
//--

#define IoSetCancelRoutine( Irp, NewCancelRoutine ) (  \
    (PDRIVER_CANCEL) InterlockedExchangePointer( (PVOID *) &(Irp)->CancelRoutine, (PVOID) (NewCancelRoutine) ) )

//++
//
// VOID
// IoSetCompletionRoutine(
//     IN PIRP Irp,
//     IN PIO_COMPLETION_ROUTINE CompletionRoutine,
//     IN PVOID Context,
//     IN BOOLEAN InvokeOnSuccess,
//     IN BOOLEAN InvokeOnError,
//     IN BOOLEAN InvokeOnCancel
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--

#define IoSetCompletionRoutine( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \
    PIO_STACK_LOCATION __irpSp;                                               \
    ASSERT( (Success) | (Error) | (Cancel) ? (Routine) != NULL : TRUE );    \
    __irpSp = IoGetNextIrpStackLocation( (Irp) );                             \
    __irpSp->CompletionRoutine = (Routine);                                   \
    __irpSp->Context = (CompletionContext);                                   \
    __irpSp->Control = 0;                                                     \
    if ((Success)) { __irpSp->Control = SL_INVOKE_ON_SUCCESS; }               \
    if ((Error)) { __irpSp->Control |= SL_INVOKE_ON_ERROR; }                  \
    if ((Cancel)) { __irpSp->Control |= SL_INVOKE_ON_CANCEL; } }

NTSTATUS
IoSetCompletionRoutineEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context,
    IN BOOLEAN InvokeOnSuccess,
    IN BOOLEAN InvokeOnError,
    IN BOOLEAN InvokeOnCancel
    );


// end_ntddk end_wdm end_nthal end_ntosp

NTKERNELAPI
VOID
IoSetDeviceToVerify(
    IN PETHREAD Thread,
    IN PDEVICE_OBJECT DeviceObject
    );

// begin_ntddk begin_nthal begin_ntosp

NTKERNELAPI
VOID
IoSetHardErrorOrVerifyDevice(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject
    );

// end_ntddk end_nthal

NTKERNELAPI
NTSTATUS
IoSetInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    IN PVOID FileInformation
    );

// end_ntosp

// begin_ntddk begin_wdm begin_nthal begin_ntosp

//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

//++
//
// VOID
// IoCopyCurrentIrpStackLocationToNext(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to copy the IRP stack arguments and file
//     pointer from the current IrpStackLocation to the next
//     in an I/O Request Packet (IRP).
//
//     If the caller wants to call IoCallDriver with a completion routine
//     but does not wish to change the arguments otherwise,
//     the caller first calls IoCopyCurrentIrpStackLocationToNext,
//     then IoSetCompletionRoutine, then IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None.
//
//--

#define IoCopyCurrentIrpStackLocationToNext( Irp ) { \
    PIO_STACK_LOCATION __irpSp; \
    PIO_STACK_LOCATION __nextIrpSp; \
    __irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \
    __nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \
    RtlCopyMemory( __nextIrpSp, __irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \
    __nextIrpSp->Control = 0; }

//++
//
// VOID
// IoSkipCurrentIrpStackLocation (
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to increment the current stack location of
//     a given IRP.
//
//     If the caller wishes to call the next driver in a stack, and does not
//     wish to change the arguments, nor does he wish to set a completion
//     routine, then the caller first calls IoSkipCurrentIrpStackLocation
//     and the calls IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None
//
//--

#define IoSkipCurrentIrpStackLocation( Irp ) { \
    (Irp)->CurrentLocation++; \
    (Irp)->Tail.Overlay.CurrentStackLocation++; }


NTKERNELAPI
VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    );

// end_ntddk end_wdm end_nthal end_ntosp

NTKERNELAPI
VOID
IoSetTopLevelIrp(
    IN PIRP Irp
    );

// end_ntifs

// begin_ntddk begin_wdm begin_ntosp


typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK * PIO_REMOVE_LOCK_TRACKING_BLOCK;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
    BOOLEAN     Removed;
    BOOLEAN     Reserved [3];
    LONG        IoCount;
    KEVENT      RemoveEvent;

} IO_REMOVE_LOCK_COMMON_BLOCK;

typedef struct _IO_REMOVE_LOCK_DBG_BLOCK {
    LONG        Signature;
    LONG        HighWatermark;
    LONGLONG    MaxLockedTicks;
    LONG        AllocateTag;
    LIST_ENTRY  LockList;
    KSPIN_LOCK  Spin;
    LONG        LowMemoryCount;
    ULONG       Reserved1[4];
    PVOID       Reserved2;
    PIO_REMOVE_LOCK_TRACKING_BLOCK Blocks;
} IO_REMOVE_LOCK_DBG_BLOCK;

typedef struct _IO_REMOVE_LOCK {
    IO_REMOVE_LOCK_COMMON_BLOCK Common;
#if DBG
    IO_REMOVE_LOCK_DBG_BLOCK Dbg;
#endif
} IO_REMOVE_LOCK, *PIO_REMOVE_LOCK;

#define IoInitializeRemoveLock(Lock, Tag, Maxmin, HighWater) \
        IoInitializeRemoveLockEx (Lock, Tag, Maxmin, HighWater, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoInitializeRemoveLockEx(
    IN  PIO_REMOVE_LOCK Lock,
    IN  ULONG   AllocateTag, // Used only on checked kernels
    IN  ULONG   MaxLockedMinutes, // Used only on checked kernels
    IN  ULONG   HighWatermark, // Used only on checked kernels
    IN  ULONG   RemlockSize // are we checked or free
    );
//
//  Initialize a remove lock.
//
//  Note: Allocation for remove locks needs to be within the device extension,
//  so that the memory for this structure stays allocated until such time as the
//  device object itself is deallocated.
//

#define IoAcquireRemoveLock(RemoveLock, Tag) \
        IoAcquireRemoveLockEx(RemoveLock, Tag, __FILE__, __LINE__, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
NTSTATUS
NTAPI
IoAcquireRemoveLockEx (
    IN PIO_REMOVE_LOCK RemoveLock,
    IN OPTIONAL PVOID   Tag, // Optional
    IN PCSTR            File,
    IN ULONG            Line,
    IN ULONG            RemlockSize // are we checked or free
    );

//
// Routine Description:
//
//    This routine is called to acquire the remove lock for a device object.
//    While the lock is held, the caller can assume that no pending pnp REMOVE
//    requests will be completed.
//
//    The lock should be acquired immediately upon entering a dispatch routine.
//    It should also be acquired before creating any new reference to the
//    device object if there's a chance of releasing the reference before the
//    new one is done, in addition to references to the driver code itself,
//    which is removed from memory when the last device object goes.
//
//    Arguments:
//
//    RemoveLock - A pointer to an initialized REMOVE_LOCK structure.
//
//    Tag - Used for tracking lock allocation and release.  The same tag
//          specified when acquiring the lock must be used to release the lock.
//          Tags are only checked in checked versions of the driver.
//
//    File - set to __FILE__ as the location in the code where the lock was taken.
//
//    Line - set to __LINE__.
//
// Return Value:
//
//    Returns whether or not the remove lock was obtained.
//    If successful the caller should continue with work calling
//    IoReleaseRemoveLock when finished.
//
//    If not successful the lock was not obtained.  The caller should abort the
//    work but not call IoReleaseRemoveLock.
//

#define IoReleaseRemoveLock(RemoveLock, Tag) \
        IoReleaseRemoveLockEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockEx(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID            Tag, // Optional
    IN ULONG            RemlockSize // are we checked or free
    );
//
//
// Routine Description:
//
//    This routine is called to release the remove lock on the device object.  It
//    must be called when finished using a previously locked reference to the
//    device object.  If an Tag was specified when acquiring the lock then the
//    same Tag must be specified when releasing the lock.
//
//    When the lock count reduces to zero, this routine will signal the waiting
//    event to release the waiting thread deleting the device object protected
//    by this lock.
//
// Arguments:
//
//    DeviceObject - the device object to lock
//
//    Tag - The TAG (if any) specified when acquiring the lock.  This is used
//          for lock tracking purposes
//
// Return Value:
//
//    none
//

#define IoReleaseRemoveLockAndWait(RemoveLock, Tag) \
        IoReleaseRemoveLockAndWaitEx(RemoveLock, Tag, sizeof (IO_REMOVE_LOCK))

NTSYSAPI
VOID
NTAPI
IoReleaseRemoveLockAndWaitEx(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID            Tag,
    IN ULONG            RemlockSize // are we checked or free
    );
//
//
// Routine Description:
//
//    This routine is called when the client would like to delete the
//    remove-locked resource.  This routine will block until all the remove
//    locks have released.
//
//    This routine MUST be called after acquiring the lock.
//
// Arguments:
//
//    RemoveLock
//
// Return Value:
//
//    none
//

// end_ntddk end_wdm end_ntosp

NTKERNELAPI
VOID
IoShutdownSystem(
    IN ULONG Phase
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

// end_ntifs


NTKERNELAPI
VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable
    );

NTKERNELAPI
VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable,
    IN ULONG Key
    );

NTKERNELAPI
VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    );

VOID
IoSetStartIoAttributes(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeferredStartIo,
    IN BOOLEAN NonCancelable
    );

// begin_ntifs

NTKERNELAPI
VOID
IoStartTimer(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoStopTimer(
    IN PDEVICE_OBJECT DeviceObject
    );

// end_ntddk end_wdm end_nthal end_ntosp

NTKERNELAPI
NTSTATUS
IoSynchronousPageWrite(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

// begin_ntosp

NTKERNELAPI
PEPROCESS
IoThreadToProcess(
    IN PETHREAD Thread
    );

// end_ntosp

NTKERNELAPI
VOID
IoUnregisterFileSystem(
    IN OUT PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoUnregisterFsRegistrationChange(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    );

// begin_ntddk begin_wdm begin_nthal begin_ntosp

NTKERNELAPI
VOID
IoUnregisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    );

//  end_wdm

NTKERNELAPI
VOID
IoUpdateShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

// end_ntddk end_nthal

NTKERNELAPI
NTSTATUS
IoVerifyVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount
    );


NTKERNELAPI                                     // ntddk wdm nthal
VOID                                            // ntddk wdm nthal
IoWriteErrorLogEntry(                           // ntddk wdm nthal
    IN PVOID ElEntry                            // ntddk wdm nthal
    );                                          // ntddk wdm nthal

// end_ntifs end_ntosp


typedef BOOLEAN (*PIO_TRAVERSE_WORKER)(
    IN ULONG                Level,
    IN PVOID                DeviceNode,
    IN PDEVICE_OBJECT       DeviceObject,
    IN PVOID                Context
    );

typedef BOOLEAN (*PIO_LEVEL_END_WORKER)(
    IN ULONG                Level,
    IN PVOID                Context
    );

//
// Used by PO to traverse DevNode tree
//

VOID
IoTraverseDeviceTree(
    IN BOOLEAN                  Inverted,
    IN LONG                     CurrentLevel,
    IN PIO_TRAVERSE_WORKER      WorkerFunction,
    IN PIO_LEVEL_END_WORKER     LevelEndFunction,
    IN PVOID                    Context
    );

// begin_nthal begin_ntosp

NTKERNELAPI
NTSTATUS
IoCreateDriver (
    IN PUNICODE_STRING DriverName,   OPTIONAL
    IN PDRIVER_INITIALIZE InitializationFunction
    );

NTKERNELAPI
VOID
IoDeleteDriver (
    IN PDRIVER_OBJECT DriverObject
    );

// end_nthal end_ntosp

#define _WMIKM_

//
// This defines the codes used to define what a request must do
//

typedef enum tagWMIACTIONCODE
{
    WmiGetAllData = IRP_MN_QUERY_ALL_DATA,
    WmiGetSingleInstance = IRP_MN_QUERY_SINGLE_INSTANCE,
    WmiChangeSingleInstance = IRP_MN_CHANGE_SINGLE_INSTANCE,
    WmiChangeSingleItem = IRP_MN_CHANGE_SINGLE_ITEM,
    WmiEnableEvents = IRP_MN_ENABLE_EVENTS,
    WmiDisableEvents  = IRP_MN_DISABLE_EVENTS,
    WmiEnableCollection = IRP_MN_ENABLE_COLLECTION,
    WmiDisableCollection = IRP_MN_DISABLE_COLLECTION,
    WmiRegisterInfo = IRP_MN_REGINFO,
    WmiExecuteMethodCall = IRP_MN_EXECUTE_METHOD
} WMIACTIONCODE;


//
// This is the prototype for the callback WMI will make to a data provider
//

typedef NTSTATUS (*WMIENTRY)(
    IN WMIACTIONCODE ActionCode,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer,
    IN PVOID Context,
    OUT PULONG Size
    );

#define WMIREG_FLAG_CALLBACK        0x80000000
// begin_wmikm
//
// The following is set for a KM provider who is considered private to
// kernel tracing
//
#define WMIREG_FLAG_TRACE_PROVIDER          0x00010000

//
// The following mask is to extract the trace callout class
//
#define WMIREG_FLAG_TRACE_NOTIFY_MASK       0x00F00000

//
// We use 4 bits for the trace callout classes.
//
#define WMIREG_NOTIFY_DISK_IO               1 << 20
#define WMIREG_NOTIFY_TDI_IO                2 << 20

// end_wmikm

// begin_ntddk begin_wdm begin_ntifs begin_ntosp begin_ntosp

typedef struct _IO_WORKITEM *PIO_WORKITEM;

typedef
VOID
(*PIO_WORKITEM_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

PIO_WORKITEM
IoAllocateWorkItem(
    PDEVICE_OBJECT DeviceObject
    );

VOID
IoFreeWorkItem(
    PIO_WORKITEM IoWorkItem
    );

VOID
IoQueueWorkItem(
    IN PIO_WORKITEM IoWorkItem,
    IN PIO_WORKITEM_ROUTINE WorkerRoutine,
    IN WORK_QUEUE_TYPE QueueType,
    IN PVOID Context
    );


NTKERNELAPI
NTSTATUS
IoWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Action
);

//
// Action code for IoWMIRegistrationControl api
//

#define WMIREG_ACTION_REGISTER      1
#define WMIREG_ACTION_DEREGISTER    2
#define WMIREG_ACTION_REREGISTER    3
#define WMIREG_ACTION_UPDATE_GUIDS  4
#define WMIREG_ACTION_BLOCK_IRPS    5

//
// Code passed in IRP_MN_REGINFO WMI irp
//

#define WMIREGISTER                 0
#define WMIUPDATE                   1

NTKERNELAPI
NTSTATUS
IoWMIAllocateInstanceIds(
    IN GUID *Guid,
    IN ULONG InstanceCount,
    OUT ULONG *FirstInstanceId
    );

NTKERNELAPI
NTSTATUS
IoWMISuggestInstanceName(
    IN PDEVICE_OBJECT PhysicalDeviceObject OPTIONAL,
    IN PUNICODE_STRING SymbolicLinkName OPTIONAL,
    IN BOOLEAN CombineNames,
    OUT PUNICODE_STRING SuggestedInstanceName
    );

NTKERNELAPI
NTSTATUS
IoWMIWriteEvent(
    IN PVOID WnodeEventItem
    );

#if defined(_WIN64)
NTKERNELAPI
ULONG IoWMIDeviceObjectToProviderId(
    PDEVICE_OBJECT DeviceObject
    );
#else
#define IoWMIDeviceObjectToProviderId(DeviceObject) ((ULONG)(DeviceObject))
#endif

NTKERNELAPI
NTSTATUS IoWMIOpenBlock(
    IN GUID *DataBlockGuid,
    IN ULONG DesiredAccess,
    OUT PVOID *DataBlockObject
    );


NTKERNELAPI
NTSTATUS IoWMIQueryAllData(
    IN PVOID DataBlockObject,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);


NTKERNELAPI
NTSTATUS
IoWMIQueryAllDataMultiple(
    IN PVOID *DataBlockObjectList,
    IN ULONG ObjectCount,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);


NTKERNELAPI
NTSTATUS
IoWMIQuerySingleInstance(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);

NTKERNELAPI
NTSTATUS
IoWMIQuerySingleInstanceMultiple(
    IN PVOID *DataBlockObjectList,
    IN PUNICODE_STRING InstanceNames,
    IN ULONG ObjectCount,
    IN OUT ULONG *InOutBufferSize,
    OUT /* non paged */ PVOID OutBuffer
);

NTKERNELAPI
NTSTATUS
IoWMISetSingleInstance(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

NTKERNELAPI
NTSTATUS
IoWMISetSingleItem(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG DataItemId,
    IN ULONG Version,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

NTKERNELAPI
NTSTATUS
IoWMIExecuteMethod(
    IN PVOID DataBlockObject,
    IN PUNICODE_STRING InstanceName,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN OUT PULONG OutBufferSize,
    IN OUT PUCHAR InOutBuffer
    );



typedef VOID (*WMI_NOTIFICATION_CALLBACK)(
    PVOID Wnode,
    PVOID Context
    );

NTKERNELAPI
NTSTATUS
IoWMISetNotificationCallback(
    IN PVOID Object,
    IN WMI_NOTIFICATION_CALLBACK Callback,
    IN PVOID Context
    );

NTKERNELAPI
NTSTATUS
IoWMIHandleToInstanceName(
    IN PVOID DataBlockObject,
    IN HANDLE FileHandle,
    OUT PUNICODE_STRING InstanceName
    );

NTKERNELAPI
NTSTATUS
IoWMIDeviceObjectToInstanceName(
    IN PVOID DataBlockObject,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUNICODE_STRING InstanceName
    );

// end_ntddk end_wdm end_ntifs end_ntosp



NTKERNELAPI
BOOLEAN
WMIInitialize(
    ULONG Phase,
    PVOID LoaderBlock
    );

//
// IoRemoteBootClient indicates whether the system was booted as a remote
// boot client.
//

extern BOOLEAN IoRemoteBootClient;
#if defined(REMOTE_BOOT)
extern BOOLEAN IoCscInitializationFailed;
#endif // defined(REMOTE_BOOT)

// Used to convert a handle to a device stack.
NTSTATUS
IoGetRelatedTargetDevice(
    IN PFILE_OBJECT FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    );

// begin_ntosp
NTKERNELAPI
NTSTATUS
IoSetIoCompletion (
    IN PVOID IoCompletion,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation,
    IN BOOLEAN Quota
    );


// end_ntosp

//
// Safeboot definitions - placeholder until a home can be found.
//

typedef struct _BOOT_LOG_RECORD {
    UNICODE_STRING LoadedString;
    UNICODE_STRING NotLoadedString;
    UNICODE_STRING LogFileName;
    UNICODE_STRING HeaderString;
    ERESOURCE Resource;
    ULONG NextKey;
    BOOLEAN FileLogging;
} BOOT_LOG_RECORD, *PBOOT_LOG_RECORD;

VOID
IopCopyBootLogRegistryToFile(
    VOID
    );

VOID
IopInitializeBootLogging(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PCHAR HeaderString
    );

VOID
IopBootLog(
    PUNICODE_STRING LogEntry,
    BOOLEAN Loaded
    );

NTSTATUS
IopSetRegistryStringValue(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN PUNICODE_STRING ValueData
    );

NTKERNELAPI
NTSTATUS
IoGetRequestorSessionId(
    IN PIRP Irp,
    OUT PULONG pSessionId
    );

NTSTATUS
IoShutdownPnpDevices(
    VOID
    );


VOID
IovFreeIrp(
    IN  PIRP    Irp
    );

PIRP
IovAllocateIrp(
    IN  CCHAR   StackSize,
    IN  BOOLEAN ChargeQuota
    );

VOID
IoVerifierInit(
    IN ULONG VerifierFlags
    );

NTSTATUS
FASTCALL
IovCallDriver(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  OUT PIRP    Irp
    );

VOID
FASTCALL
IovCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

PIRP
IovBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );


PIRP
IovBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTSTATUS
IovInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    );


NTKERNELAPI
PVOID
IoAllocateGenericErrorLogEntry(
    IN UCHAR EntrySize
    );

VOID
IoRetryIrpCompletions(
    VOID
    );

// begin_ntddk begin_wdm begin_ntifs begin_ntosp
#if defined(_WIN64)
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp
    );
#endif
// end_ntddk end_wdm end_ntifs end_ntosp

// begin_ntosp
NTKERNELAPI
VOID
FASTCALL
IoAssignDriveLetters(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );
// end_ntosp


// begin_ntddk
NTKERNELAPI
VOID
FASTCALL
HalExamineMBR(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG MBRTypeIdentifier,
    OUT PVOID *Buffer
    );

DECLSPEC_DEPRECATED_DDK                 // Use IoReadPartitionTableEx
NTKERNELAPI
NTSTATUS
FASTCALL
IoReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT struct _DRIVE_LAYOUT_INFORMATION **PartitionBuffer
    );

DECLSPEC_DEPRECATED_DDK                 // Use IoSetPartitionInformationEx
NTKERNELAPI
NTSTATUS
FASTCALL
IoSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

// begin_ntosp
DECLSPEC_DEPRECATED_DDK                 // Use IoWritePartitionTableEx
NTKERNELAPI
NTSTATUS
FASTCALL
IoWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN struct _DRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

NTKERNELAPI
NTSTATUS
IoCreateDisk(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _CREATE_DISK* Disk
    );

NTKERNELAPI
NTSTATUS
IoReadPartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _DRIVE_LAYOUT_INFORMATION_EX** DriveLayout
    );

NTKERNELAPI
NTSTATUS
IoWritePartitionTableEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _DRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    );

NTKERNELAPI
NTSTATUS
IoSetPartitionInformationEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG PartitionNumber,
    IN struct _SET_PARTITION_INFORMATION_EX* PartitionInfo
    );

NTKERNELAPI
NTSTATUS
IoUpdateDiskGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN struct _DISK_GEOMETRY_EX* OldDiskGeometry,
    IN struct _DISK_GEOMETRY_EX* NewDiskGeometry
    );

NTKERNELAPI
NTSTATUS
IoVerifyPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FixErrors
    );

typedef struct _DISK_SIGNATURE {
    ULONG PartitionStyle;
    union {
        struct {
            ULONG Signature;
            ULONG CheckSum;
        } Mbr;

        struct {
            GUID DiskId;
        } Gpt;
    };
} DISK_SIGNATURE, *PDISK_SIGNATURE;

NTKERNELAPI
NTSTATUS
IoReadDiskSignature(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG BytesPerSector,
    OUT PDISK_SIGNATURE Signature
    );

// end_ntosp
// end_ntddk

// begin_ntosp begin_ntifs begin_ntddk

NTSTATUS
IoVolumeDeviceToDosName(
    IN  PVOID           VolumeDeviceObject,
    OUT PUNICODE_STRING DosName
    );
// end_ntosp end_ntifs end_ntddk

// begin_ntosp begin_ntifs
NTSTATUS
IoEnumerateDeviceObjectList(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  *DeviceObjectList,
    IN  ULONG           DeviceObjectListSize,
    OUT PULONG          ActualNumberDeviceObjects
    );

PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    );

PDEVICE_OBJECT
IoGetDeviceAttachmentBaseRef(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IoGetDiskDeviceObject(
    IN  PDEVICE_OBJECT  FileSystemDeviceObject,
    OUT PDEVICE_OBJECT  *DiskDeviceObject
    );

// end_ntosp end_ntifs

// begin_ntosp begin_ntifs begin_ntddk

NTSTATUS
IoSetSystemPartition(
    PUNICODE_STRING VolumeNameString
    );

// begin_wdm
VOID
IoFreeErrorLogEntry(
    PVOID ElEntry
    );

// Cancel SAFE API set start
//
// The following APIs are to help ease the pain of writing queue packages that
// handle the cancellation race well. The idea of this set of APIs is to not
// force a single queue data structure but allow the cancel logic to be hidden
// from the drivers. A driver implements a queue and as part of its header
// includes the IO_CSQ structure. In its initialization routine it calls
// IoInitializeCsq. Then in the dispatch routine when the driver wants to
// insert an IRP into the queue it calls IoCsqInsertIrp. When the driver wants
// to remove something from the queue it calls IoCsqRemoveIrp. Note that Insert
// can fail if the IRP was cancelled in the meantime. Remove can also fail if
// the IRP was already cancelled.
//
// There are typically two modes where drivers queue IRPs. These two modes are
// covered by the cancel safe queue API set.
//
// Mode 1:
// One is where the driver queues the IRP and at some later
// point in time dequeues an IRP and issues the IO request.
// For this mode the driver should use IoCsqInsertIrp and IoCsqRemoveNextIrp.
// The driver in this case is expected to pass NULL to the irp context
// parameter in IoInsertIrp.
//
// Mode 2:
// In this the driver queues theIRP, issues the IO request (like issuing a DMA
// request or writing to a register) and when the IO request completes (either
// using a DPC or timer) the driver dequeues the IRP and completes it. For this
// mode the driver should use IoCsqInsertIrp and IoCsqRemoveIrp. In this case
// the driver should allocate an IRP context and pass it in to IoCsqInsertIrp.
// The cancel API code creates an association between the IRP and the context
// and thus ensures that when the time comes to remove the IRP it can ascertain
// correctly.
//
// Note that the cancel API set assumes that the field DriverContext[3] is
// always available for use and that the driver does not use it.
//


//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ IO_CSQ, *PIO_CSQ;

#define IO_TYPE_CSQ_IRP_CONTEXT 1
#define IO_TYPE_CSQ             2

//
// IRP context structure. This structure is necessary if the driver is using
// the second mode.
//


typedef struct _IO_CSQ_IRP_CONTEXT {
    ULONG   Type;
    PIRP    Irp;
    PIO_CSQ Csq;
} IO_CSQ_IRP_CONTEXT, *PIO_CSQ_IRP_CONTEXT;

//
// Routines that insert/remove IRP
//

typedef VOID
(*PIO_CSQ_INSERT_IRP)(
    IN str