NVALID_HANDLE - The handle passed is invalid.  This may be
        because someone has deleted the group while it was open.

    STATUS_SPECIAL_ACCOUNT - The group specified is a special group and
        cannot be operated on in the requested fashion.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{

    UNICODE_STRING          GroupName;
    NTSTATUS                NtStatus, TmpStatus;
    PSAMP_OBJECT            AccountContext = (PSAMP_OBJECT)(*GroupHandle);
    PSAMP_DEFINED_DOMAINS   Domain;
    PSID                    AccountSid=NULL;
    SAMP_OBJECT_TYPE        FoundType;
    PULONG                  PrimaryMembers=NULL;
    BOOLEAN                 fLockAcquired = FALSE;
    ULONG                   MemberCount,
                            ObjectRid,
                            DomainIndex,
                            PrimaryMemberCount=0;
    DECLARE_CLIENT_REVISION(*GroupHandle);


    SAMTRACE_EX("SamrDeleteGroup");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidDeleteGroup
                   );

    //
    // Grab the lock
    //

    NtStatus = SampMaybeAcquireWriteLock(AccountContext, &fLockAcquired);
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }



    //
    // Validate type of, and access to object.
    //

    NtStatus = SampLookupContext(
                   AccountContext,
                   DELETE,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );

   
    if (NT_SUCCESS(NtStatus)) {

        ObjectRid = AccountContext->TypeBody.Group.Rid;

        //
        // Get a pointer to the domain this object is in.
        // This is used for auditing.
        //

        DomainIndex = AccountContext->DomainIndex;
        Domain = &SampDefinedDomains[ DomainIndex ];

        //
        // Make sure the account is one that can be deleted.
        // Can't be a built-in account, unless the caller is trusted.
        //

        if ( !AccountContext->TrustedClient ) {

            NtStatus = SampIsAccountBuiltIn( ObjectRid );
        }


        if (NT_SUCCESS( NtStatus)) {


            if (!IsDsObject(AccountContext))
            {
                //
                // and it can't have any members
                //

                NtStatus = SampRetrieveGroupMembers(
                           AccountContext,
                           &MemberCount,
                           NULL              // Only need member count (not list)
                           );

                if (MemberCount != 0)
                {
                    NtStatus = STATUS_MEMBER_IN_GROUP;
                }
            }
            else
            {
                //
                // In DS mode we should have no primary members
                //

                 NtStatus = SampDsGetPrimaryGroupMembers(
                                DomainObjectFromAccountContext(AccountContext),
                                AccountContext->TypeBody.Group.Rid,
                                &PrimaryMemberCount,
                                &PrimaryMembers
                                );

                if ((NT_SUCCESS(NtStatus)) && (PrimaryMemberCount>0))
                {
                    //
                    // We should ideally add a new error code to distinguish 
                    // this behaviour but applications only know to deal with
                    // STATUS_MEMBER_IN_GROUP. Secondly we do not want to 
                    // Create any special Caveats for "Primary members" as we
                    // want to remove that concept anyway in the long term.
                    //

                    NtStatus = STATUS_MEMBER_IN_GROUP;

                }
            }
        }



        if (NT_SUCCESS(NtStatus)) {

            //
            // Remove this account from all aliases, for the Registry Case
            //


            NtStatus = SampCreateAccountSid(AccountContext, &AccountSid);

            if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(AccountContext))) {

                //
                // Only for the Registry case , go and remove all the references
                // to the Account Sid , in the given domain.
                //

                NtStatus = SampRemoveAccountFromAllAliases(
                               AccountSid,
                               NULL,
                               FALSE,
                               NULL,
                               NULL,
                               NULL );
            }
        }


        //
        // Looks promising.

        if (NT_SUCCESS(NtStatus)) {

            //
            // First get and save the account name for
            // I_NetNotifyLogonOfDelta.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_GROUP_NAME,
                           TRUE,    // Make copy
                           &GroupName
                           );

            if (NT_SUCCESS(NtStatus)) {

                //
                // This must be done before we invalidate contexts, because our
                // own handle to the group gets closed as well.
                //

                if (IsDsObject(AccountContext))
                {
                    //
                    // For Ds Case Delete the Object in the Ds.
                    //

                    NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs, 
                                                  0         //  delete the object itself
                                                  );
                                                  
                    //
                    // In Windows 2000 (NT5), an object has children cannot be
                    // deleted till its children are deleted first. Thus for 
                    // Net API compatibility, we have to change the 
                    // delete behavior from a delete object to delete tree.
                    // 
                    
                    if ((!AccountContext->LoopbackClient) &&
                        (STATUS_DS_CANT_ON_NON_LEAF == NtStatus)
                       )
                    {
                        //
                        // We only checked the right and access control for
                        // deleting the object itself, not check the right to 
                        // delete all the children underneath, so turn off fDSA
                        // here, let core DS do the rest of check.
                        // 
                        
                        SampSetDsa(FALSE);
                        
                        NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs, 
                                                      SAM_DELETE_TREE
                                                      );
                    }
                    
                    if (NT_SUCCESS(NtStatus) && (!IsDsObject(AccountContext)) )
                    {
                        //
                        // Decrement the group count
                        //

                        NtStatus = SampAdjustAccountCount(SampGroupObjectType, FALSE);
                    }


                }
                else
                {

                    //
                    // Registry Case Delete Keys
                    //

                    NtStatus = SampDeleteGroupKeys( AccountContext );
                }

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // We must invalidate any open contexts to this group.
                    // This will close all handles to the group's keys.
                    // THIS IS AN IRREVERSIBLE PROCESS.
                    //

                    SampInvalidateObjectContexts( AccountContext, ObjectRid );


                    //
                    // Commit the whole mess
                    //

                    NtStatus = SampCommitAndRetainWriteLock();

                    if ( NT_SUCCESS( NtStatus ) ) {

                        SAMP_ACCOUNT_DISPLAY_INFO AccountInfo;

                        //
                        // Update the Cached Alias Information in Registry Mode
                        // In DS Mode, Alias Information is invalidated through
                        // SampNotifyReplicatedInChange
                        //

                        if (!IsDsObject(AccountContext))
                        {
                            NtStatus = SampAlRemoveAccountFromAllAliases(
                                           AccountSid,
                                           FALSE,
                                           NULL,
                                           NULL,
                                           NULL
                                           );

                            //
                            // Update the display information ONLY in Registry Case
                            //
                
                            AccountInfo.Name = GroupName;
                            AccountInfo.Rid = ObjectRid;
                            AccountInfo.AccountControl = 0; // Don't care about this value for delete
                            RtlInitUnicodeString(&AccountInfo.Comment, NULL);
                            RtlInitUnicodeString(&AccountInfo.FullName, NULL);

                            TmpStatus = SampUpdateDisplayInformation(
                                                        &AccountInfo,
                                                        NULL,
                                                        SampGroupObjectType
                                                        );
                            ASSERT(NT_SUCCESS(TmpStatus));
                        }

                        //
                        // Audit the deletion before we free the write lock
                        // so that we have access to the context block.
                        //

                        //
                        // N.B. Deletion audits in the DS are performed in 
                        // the notification routine on transaction commit.
                        //
                        if (SampDoAccountAuditing(DomainIndex) &&
                            (!IsDsObject(AccountContext)) &&
                            NT_SUCCESS(NtStatus) ) {

                            SampAuditGroupDelete(DomainIndex,
                                                 &GroupName,
                                                 &ObjectRid,
                                                 GROUP_TYPE_ACCOUNT_GROUP |
                                                 GROUP_TYPE_SECURITY_ENABLED);

                        }

                        //
                        // Do delete auditing
                        //

                        if (NT_SUCCESS(NtStatus)) {
                            (VOID) NtDeleteObjectAuditAlarm(
                                        &SampSamSubsystem,
                                        *GroupHandle,
                                        AccountContext->AuditOnClose
                                        );
                        }

                        //
                        // Notify netlogon of the change
                        //

                        if (AccountContext->TypeBody.Group.SecurityEnabled)
                        {
                            SampNotifyNetlogonOfDelta(
                                SecurityDbDelete,
                                SecurityDbObjectSamGroup,
                                ObjectRid,
                                &GroupName,
                                (DWORD) FALSE,   // Replicate immediately
                                NULL             // Delta data
                                );
                        }
                    }


                }

                SampFreeUnicodeString( &GroupName );
            }
        }



        //
        // De-reference the object, discarding changes
        //

        TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(TmpStatus));


        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // If we actually deleted the group, delete the context and
            // let RPC know that the handle is invalid.
            //

            SampDeleteContext( AccountContext );

            (*GroupHandle) = NULL;
        }

    } //end_if

    //
    // Free the lock -
    //
    // Everything has already been committed above, so we must indicate
    // no additional changes have taken place.
    //
    //
    //


    TmpStatus = SampMaybeReleaseWriteLock( fLockAcquired, FALSE );

    if (NtStatus == STATUS_SUCCESS) {
        NtStatus = TmpStatus;
    }

    if (AccountSid!=NULL)
        MIDL_user_free(AccountSid);

    if (NULL!=PrimaryMembers)
        MIDL_user_free(PrimaryMembers);

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:
    
    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidDeleteGroup
                   );

    return(NtStatus);

}


NTSTATUS
SamrRemoveMemberFromGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN ULONG MemberId
    )

/*++

Routine Description:

    This service

Arguments:

    ????

Return Value:


    ????


--*/
{
    NTSTATUS                NtStatus, TmpStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    UNICODE_STRING         GroupName;
    DECLARE_CLIENT_REVISION(GroupHandle);



    SAMTRACE_EX("SamrRemoveMemberFromGroup");

    //
    // Do a start type WMI event trace
    // 
    
    SampTraceEvent(EVENT_TRACE_TYPE_START, 
                   SampGuidRemoveMemberFromGroup
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );
        
    //
    // Initialize buffers we will cleanup at the end
    //

    RtlInitUnicodeString(&GroupName, NULL);
    
    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto SamrRemoveMemberFromGroupError;
    }

    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)(GroupHandle);

    NtStatus = SampLookupContext(
                   AccountContext,
                   GROUP_REMOVE_MEMBER,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );
  
    if (NT_SUCCESS(NtStatus)) {

        //
        // Call the actual worker routine
        //

        NtStatus = SampRemoveSameDomainMemberFromGlobalOrUniversalGroup(
                        AccountContext,
                        MemberId,
                        NULL
                        );

         if (NT_SUCCESS(NtStatus)) {

            //
            // Get and save the account name for
            // I_NetNotifyLogonOfDelta.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_GROUP_NAME,
                           TRUE,    // Make copy
                           &GroupName
                           );

            if (!NT_SUCCESS(NtStatus)) {
                RtlInitUnicodeString(&GroupName, NULL);
            }
        }


        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //

            NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        } else {

            //
            // De-reference the object, ignore changes
            //

            TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(TmpStatus));
        }
    }


    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampCommitAndRetainWriteLock();

        if (( NT_SUCCESS( NtStatus ) )
            && (AccountContext->TypeBody.Group.SecurityEnabled)) {

            SAM_DELTA_DATA DeltaData;

            //
            // Fill in id of member being deleted
            //

            DeltaData.GroupMemberId.MemberRid = MemberId;


            if (AccountContext->TypeBody.Group.SecurityEnabled)
            {
                SampNotifyNetlogonOfDelta(
                    SecurityDbChangeMemberDel,
                    SecurityDbObjectSamGroup,
                    AccountContext->TypeBody.Group.Rid,
                    &GroupName,
                    (DWORD) FALSE,  // Replicate immediately
                    &DeltaData
                    );
            }
        }
    }


    //
    // Free up the group name
    //

    SampFreeUnicodeString(&GroupName);

     //
    // Release the Lock
    //


    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    
SamrRemoveMemberFromGroupError:
    
    //
    // Do a end type WMI event trace
    //
    
    SampTraceEvent(EVENT_TRACE_TYPE_END, 
                   SampGuidRemoveMemberFromGroup
                   );

    return(NtStatus);
}



NTSTATUS
SamrGetMembersInGroup(
    IN SAMPR_HANDLE GroupHandle,
    OUT PSAMPR_GET_MEMBERS_BUFFER *GetMembersBuffer
    )

/*++

Routine Description:

    This API lists all the members in a group.  This API may be called
    repeatedly, passing a returned context handle, to retrieve large
    amounts of data.  This API requires GROUP_LIST_MEMBERS access to the
    group.




Parameters:

    GroupHandle - The handle of an opened group to operate on.
        GROUP_LIST_MEMBERS access is needed to the group.

    GetMembersBuffer - Receives a pointer to a set of returned structures
        with the following format:

                         +-------------+
               --------->| MemberCount |
                         |-------------+                    +-------+
                         |  Members  --|------------------->| Rid-0 |
                         |-------------|   +------------+   |  ...  |
                         |  Attributes-|-->| Attribute0 |   |       |
                         +-------------+   |    ...     |   | Rid-N |
                                           | AttributeN |   +-------+
                                           +------------+

        Each block individually allocated with MIDL_user_allocate.



Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no addition entries.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.
    This service



--*/
{

    NTSTATUS                    NtStatus;
    NTSTATUS                    IgnoreStatus;
    ULONG                       i;
    ULONG                       ObjectRid;
    PSAMP_OBJECT                AccountContext;
    SAMP_OBJECT_TYPE            FoundType;
    BOOLEAN                     fLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(GroupHandle);

    SAMTRACE_EX("SamrGetMembersInGroup");

    //
    // Do a start type WMI event trace
    // 
    
    SampTraceEvent(EVENT_TRACE_TYPE_START, 
                   SampGuidGetMembersInGroup
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (GetMembersBuffer != NULL);

    if ((*GetMembersBuffer) != NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    
    

    //
    // Allocate the first of the return buffers
    //

    (*GetMembersBuffer) = MIDL_user_allocate( sizeof(SAMPR_GET_MEMBERS_BUFFER) );

    if ( (*GetMembersBuffer) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    RtlZeroMemory((*GetMembersBuffer), sizeof(SAMPR_GET_MEMBERS_BUFFER));

    //
    // Acquire the Read lock if necessary
    //
    AccountContext = (PSAMP_OBJECT)GroupHandle;
    SampMaybeAcquireReadLock(AccountContext,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // Validate type of, and access to object.
    //

   
    ObjectRid = AccountContext->TypeBody.Group.Rid;
    NtStatus = SampLookupContext(
                   AccountContext,
                   GROUP_LIST_MEMBERS,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampRetrieveGroupMembers(
                       AccountContext,
                       &(*GetMembersBuffer)->MemberCount,
                       &(*GetMembersBuffer)->Members
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Allocate a buffer for the attributes - which we get from
            // the individual user records
            //

            (*GetMembersBuffer)->Attributes = MIDL_user_allocate((*GetMembersBuffer)->MemberCount * sizeof(ULONG) );
            if ((*GetMembersBuffer)->Attributes == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            for ( i=0; (i<((*GetMembersBuffer)->MemberCount) && NT_SUCCESS(NtStatus)); i++) {

                if (IsDsObject(AccountContext))
                {
                    //
                    // Currently the attributes of the group are hardwired.
                    // Therefore instead of calling the UserGroupAttributes
                    // function whack the attrbutes straight away. In case of
                    // it becomes necessary to support these attributes the
                    // retrive group members will obtain the attributes also
                    // making one pass on the DS
                    //

                    (*GetMembersBuffer)->Attributes[i] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;

                }
                else
                {
                    NtStatus = SampRetrieveUserGroupAttribute(
                                   (*GetMembersBuffer)->Members[i],
                                   ObjectRid,
                                   &(*GetMembersBuffer)->Attributes[i]
                                );

                    if ( STATUS_NO_SUCH_USER == NtStatus )
                    {
                        (*GetMembersBuffer)->Attributes[i] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
                        NtStatus = STATUS_SUCCESS;
                    }
                }
            }

        }


        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);


    if (!NT_SUCCESS(NtStatus) || ((*GetMembersBuffer)->MemberCount == 0)){

        (*GetMembersBuffer)->MemberCount = 0;
        if ((*GetMembersBuffer)->Members)
        {
            MIDL_user_free((*GetMembersBuffer)->Members);
            (*GetMembersBuffer)->Members     = NULL;
        }

        if ((*GetMembersBuffer)->Attributes)
        {
            MIDL_user_free((*GetMembersBuffer)->Attributes);
            (*GetMembersBuffer)->Attributes  = NULL;
        }
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // Do an end type WMI event trace
    // 
    
    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetMembersInGroup
                   );

    return( NtStatus );
}


NTSTATUS
SamrSetMemberAttributesOfGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
    )

/*++

Routine Description:


    This routine modifies the group attributes of a member of the group.
    This routine is a NO - OP for the DS case



Parameters:

    GroupHandle - The handle of an opened group to operate on.

    MemberId - Contains the relative ID of member whose attributes
        are to be modified.

    Attributes - The group attributes to set for the member.  These
        attributes must not conflict with the attributes of the group
        as a whole.  See SamAddMemberToGroup() for more information
        on compatible attribute settings.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no addition entries.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_USER - The user specified does not exist.

    STATUS_MEMBER_NOT_IN_GROUP - Indicates the specified relative ID
        is not a member of the group.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/

{

    NTSTATUS                NtStatus, TmpStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    ULONG                   ObjectRid;
    DECLARE_CLIENT_REVISION(GroupHandle);



    SAMTRACE_EX("SamrSetMemberAttributesOfGroup");

    //
    // WMI event trace
    // 
    
    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetMemberAttributesOfGroup
                   );


    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }




    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)(GroupHandle);
    ObjectRid = AccountContext->TypeBody.Group.Rid;
    NtStatus = SampLookupContext(
                   AccountContext,
                   GROUP_ADD_MEMBER,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );

    if ((NT_SUCCESS(NtStatus))&& (!IsDsObject(AccountContext))) {

        //
        // Update user object
        //

        NtStatus = SampSetGroupAttributesOfUser(
                       ObjectRid,
                       Attributes,
                       MemberId
                       );

        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //

            NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        } else {

            //
            // De-reference the object, ignore changes
            //

            TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(TmpStatus));
        }

    }


    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampCommitAndRetainWriteLock();

        if (( NT_SUCCESS( NtStatus ) )
            && (AccountContext->TypeBody.Group.SecurityEnabled)) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChange,
                SecurityDbObjectSamGroup,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,  // Replicate immediately
                NULL            // Delta data
                );
        }
    }

    TmpStatus = SampReleaseWriteLock( FALSE );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // WMI event trace
    // 
    
    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetMemberAttributesOfGroup
                   );

    return(NtStatus);
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal Services Available For Use in Other SAM Modules                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampValidateDSName(
    IN PSAMP_OBJECT AccountContext,
    IN DSNAME * DSName,
    OUT PSID    * Sid,
    OUT DSNAME  **ImprovedDSName
    )
/*++

    Routine Description:

        Validates and DSNAME, and improves it based upon any lookups either performed
        locally or on the G.C

    Arguments:

          AccountContext    The Account Context of the group or Alias Object that the
                            DSName is being made a member of.
          DSName            The DSNAME to be validated
       
          Sid               Is filled in with a pointer to the SID of the object upon return

          ImprovedDSName    If the DSName was found in the GC Verify Cache, the improved DSName
                            from the GC Verify Cache is passed in here. Else this is filled in
                            with the input DSName
    Return Values:

           STATUS_SUCCESS   Successful validation

--*/

{

    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DSNAME      * GCVerifiedName = NULL;
    ENTINF      *EntInf = NULL;
    PDSNAME     *rgDSNames = NULL;


   //
   // Initialize return Values
   //

   
   *Sid = NULL;
   *ImprovedDSName = DSName;


   //
   // Lookup the name in the GC Verify Cache
   //

   EntInf = GCVerifyCacheLookup(DSName);
   if (NULL!=EntInf)
   {
       GCVerifiedName = EntInf->pName;
   }

   if ((NULL!=GCVerifiedName)&& (GCVerifiedName->SidLen>0))
   {
       //
       // Found in the cache, This name corresponds to a DS Name
       // that has been verified at the G.C. Therefore this
       // DS Name corresponds to an Object belonging to a Domain
       // in the enterprise.

       //
       // Fill in the improved DS Name. The core DS expects that
       // the string name is present when a DS Named valued attribute
       // is specified. The input name need not have a string name,
       // but the name in the GC verify cache will have all components
       // of the name. So pass this back to the caller, so that he may
       // use this name while making core DS calls
       //

       *ImprovedDSName = GCVerifiedName;


       //
       // Try to obtain the SID of the object
       // from the SID field in the DS Name
       //

       if (GCVerifiedName->SidLen >0)
       {

            *Sid = &(GCVerifiedName->Sid);
       }
   }
   else
   {
        //
        // Not Found in the Cache. This name is a name that either
        // did not resolve at the G.C, or is a local name that
        // was never remoted to the G.C, or a SID describing a foreign
        // object on which no resoultion was attempted.
        //

        if ((DSName->SidLen>0)
             && (RtlValidSid(&DSName->Sid)))
        {
            // Name contains a valid SID, keep that SID
            *Sid = &DSName->Sid;
        }
        else if ((!fNullUuid(&DSName->Guid))
                || (DSName->NameLen>0))
        {
            // String Name or GUID has been specified, try
            // retrieving SID from the database
            *Sid = SampDsGetObjectSid(DSName);
        }
        else
        {
            // No name, guid, or valid SID

            NtStatus = STATUS_INVALID_MEMBER;
            goto Error;
        }
   }

 
Error:


   return NtStatus;
}


NTSTATUS
SampAddUserToGroup(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG GroupRid,
    IN ULONG UserRid
    )

/*++

Routine Description:

    This service is expected to be used when a user is being created.
    It is used to add that user as a member to a specified group.
    This is done by simply adding the user's ID to the list of IDs
    in the MEMBERS sub-key of the the specified group.


    The caller of this service is expected to be in the middle of a
    RXACT transaction.  This service simply adds some actions to that
    RXACT transaction.


    If the group is the DOMAIN_ADMIN group, the caller is responsible
    for updating the ActiveAdminCount (if appropriate).



Arguments:

    GroupRid - The RID of the group the user is to be made a member of.

    UserRid - The RID of the user being added as a new member.

Return Value:


    STATUS_SUCCESS - The user has been added.



--*/
{
    NTSTATUS                NtStatus;
    PSAMP_OBJECT            GroupContext;

    SAMTRACE("SampAddUserToGroup");


    NtStatus = SampCreateAccountContext2(
                    AccountContext,             // Passedin Context
                    SampGroupObjectType,        // object type
                    GroupRid,                   // object ID
                    NULL,                       // user account control
                    (PUNICODE_STRING)NULL,      // account name
                    AccountContext->ClientRevision, // Client Revision
                    TRUE,                           // We're trusted
                    AccountContext->LoopbackClient, // Loopback client
                    FALSE,                      // createdByPrivilege
                    TRUE,                       // account exists
                    FALSE,                      // OverrideLockGroupCheck
                    NULL,                       // group type
                    &GroupContext               // returned context
                    );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Turn Off Buffer Writes, so that member ship change won't be cached.
        // And we don't need to CommitBufferedWrites()
        // 
        GroupContext->BufferWrites = FALSE;


        //
        // Add the user to the group member list.
        //

        NtStatus = SampAddAccountToGroupMembers(
                        GroupContext,
                        UserRid,
                        NULL
                        );

        //
        // Write out any changes to the group account
        // Don't use the open key handle since we'll be deleting the context.
        //

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampStoreObjectAttributes(GroupContext, FALSE);
        }

        //
        // Clean up the group context
        //

        SampDeleteContext(GroupContext);

    }

    return(NtStatus);
}



NTSTATUS
SampRemoveUserFromGroup(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG GroupRid,
    IN ULONG UserRid
    )

/*++

Routine Description:

    This routine is used to Remove a user from a specified group.
    This is done by simply Removing the user's ID From the list of IDs
    in the MEMBERS sub-key of the the specified group.

    It is the caller's responsibility to know that the user is, in fact,
    currently a member of the group.


    The caller of this service is expected to be in the middle of a
    RXACT transaction.  This service simply adds some actions to that
    RXACT transaction.


    If the group is the DOMAIN_ADMIN group, the caller is responsible
    for updating the ActiveAdminCount (if appropriate).



Arguments:

    GroupRid - The RID of the group the user is to be removed from.

    UserRid - The RID of the user being Removed.

Return Value:


    STATUS_SUCCESS - The user has been Removed.



--*/
{
    NTSTATUS                NtStatus;
    PSAMP_OBJECT            GroupContext;

    SAMTRACE("SampRemoveUserFromGroup");

    NtStatus = SampCreateAccountContext2(
                    AccountContext,         // Context
                    SampGroupObjectType,    // Object Type
                    GroupRid,               // Object ID
                    NULL,                   // UserAccountControl,
                    (PUNICODE_STRING) NULL, // AccountName,
                    AccountContext->ClientRevision, // Client Revision
                    TRUE,                   // Trusted Client
                    AccountContext->LoopbackClient, // Loopback Client
                    FALSE,                  // Create by Privilege
                    TRUE,                   // Account exists
                    FALSE,                  // OverrideLocalGroupCheck
                    NULL,                   // Group Type
                    &GroupContext           // return Context
                    );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Turn Off Buffer Writes, so that member ship change won't be cached.
        // And we don't need to CommitBufferedWrites()
        // 
        GroupContext->BufferWrites = FALSE;

        //
        // Remove the user from the group member list.
        //

        NtStatus = SampRemoveAccountFromGroupMembers(
                        GroupContext,
                        UserRid,
                        NULL
                        );

        //
        // Write out any changes to the group account
        // Don't use the open key handle since we'll be deleting the context.
        //

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampStoreObjectAttributes(GroupContext, FALSE);
        }

        //
        // Clean up the group context
        //

        SampDeleteContext(GroupContext);

    }

    return(NtStatus);
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Private to this file                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampRetrieveGroupV1Fixed(
    IN PSAMP_OBJECT GroupContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed
    )

/*++

Routine Description:

    This service retrieves the V1 fixed length information related to
    a specified group.


Arguments:

    GroupRootKey - Root key for the group whose V1_FIXED information is
        to be retrieved.

    V1Fixed - Is a buffer into which the information is to be returned.



Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    Other status values that may be returned are those returned
    by:

            SampGetFixedAttributes()



--*/
{
    NTSTATUS    NtStatus;
    PVOID       FixedData;

    SAMTRACE("SampRetrieveGroupV1Fixed");


    NtStatus = SampGetFixedAttributes(
                   GroupContext,
                   FALSE, // Don't make copy
                   &FixedData
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Copy data into return buffer
        // *V1Fixed = *((PSAMP_V1_0A_FIXED_LENGTH_GROUP)FixedData);
        //

        RtlMoveMemory(
            V1Fixed,
            FixedData,
            sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP)
            );
    }


    return( NtStatus );

}




NTSTATUS
SampReplaceGroupV1Fixed(
    IN PSAMP_OBJECT Context,
    IN PSAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed
    )

/*++

Routine Description:

    This service replaces the current V1 fixed length information related to
    a specified group.

    The change is made to the in-memory object data only.


Arguments:

    Context - Points to the account context whose V1_FIXED information is
        to be replaced.

    V1Fixed - Is a buffer containing the new V1_FIXED information.



Return Value:


    STATUS_SUCCESS - The information has been replaced.

    Other status values that may be returned are those returned
    by:

            SampSetFixedAttributes()



--*/
{
    NTSTATUS    NtStatus;

    SAMTRACE("SampReplaceGroupV1Fixed");

    NtStatus = SampSetFixedAttributes(
                   Context,
                   (PVOID)V1Fixed
                   );

    return( NtStatus );
}



NTSTATUS
SampRetrieveGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN PULONG MemberCount,
    IN PULONG  *Members OPTIONAL
    )

/*++
Routine Description:

    This service retrieves the number of members in a group.  If desired,
    it will also retrieve an array of RIDs of the members of the group.


Arguments:

    GroupContext - Group context block

    MemberCount - Receives the number of members currently in the group.

    Members - (Optional) Receives a pointer to a buffer containing an array
        of member Relative IDs.  If this value is NULL, then this information
        is not returned.  The returned buffer is allocated using
        MIDL_user_allocate() and must be freed using MIDL_user_free() when
        no longer needed.

        The Members array returned always includes space for one new entry.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        string to be returned in.

    Other status values that may be returned are those returned
    by:

            SampGetUlongArrayAttribute()



--*/
{
    NTSTATUS    NtStatus;
    PULONG      Array;
    ULONG       LengthCount;

    SAMTRACE("SampRetrieveGroupMembers");

    //
    // Do Different things for DS and Registry Cases
    //

    if (IsDsObject(GroupContext))
    {
        SAMP_V1_0A_FIXED_LENGTH_GROUP  GroupV1Fixed;

        //
        // DS case, this routine in DS layer does all the
        // work
        //

         if (ARGUMENT_PRESENT(Members))
         {
            *Members = NULL;
         };

         *MemberCount = 0;

         NtStatus = SampRetrieveGroupV1Fixed(
                        GroupContext,
                        &GroupV1Fixed
                        );

         if (NT_SUCCESS(NtStatus))
         {
            NtStatus = SampDsGetGroupMembershipList(
                        DomainObjectFromAccountContext(GroupContext),
                        GroupContext->ObjectNameInDs,
                        GroupV1Fixed.RelativeId,
                        Members,
                        MemberCount
                        );
         }
    }
    else
    {

        //
        // Registry Case
        //


        NtStatus = SampGetUlongArrayAttribute(
                            GroupContext,
                            SAMP_GROUP_MEMBERS,
                            FALSE, // Reference data directly
                            &Array,
                            MemberCount,
                            &LengthCount
                            );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Fill in return info
            //

            if (Members != NULL) {

                //
                // Allocate a buffer large enough to hold the existing membership
                // data plus one.
                //

                ULONG BytesNow = (*MemberCount) * sizeof(ULONG);
                ULONG BytesRequired = BytesNow + sizeof(ULONG);

                *Members = MIDL_user_allocate(BytesRequired);

                if (*Members == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlCopyMemory(*Members, Array, BytesNow);
                }
            }
        }
    }

    return( NtStatus );
}



NTSTATUS
SampReplaceGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG MemberCount,
    IN PULONG Members
    )

/*++
Routine Description:

    This service sets the members of a group.

    The information is updated in the in-memory copy of the group's data only.
    The data is not written out by this routine.


Arguments:

    GroupContext - The group whose member list is to be replaced

    MemberCount - The number of new members

    Membership - A pointer to a buffer containing an array of account rids.


Return Value:


    STATUS_SUCCESS - The information has been set.

    Other status values that may be returned are those returned
    by:

            SampSetUlongArrayAttribute()



--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PULONG      LocalMembers;
    ULONG       LengthCount;
    ULONG       SmallListGrowIncrement = 25;
    ULONG       BigListGrowIncrement = 250;
    ULONG       BigListSize = 800;

    SAMTRACE("SampReplaceGroupMembers");

    //
    // ASSERT that this is never called on a  DS case
    //

    ASSERT(!(IsDsObject(GroupContext)));


    //
    // These group user lists can get pretty big, and grow many
    // times by a very small amount as each user is added.  The
    // registry doesn't like that kind of behaviour (it tends to
    // eat up free space something fierce) so we'll try to pad
    // out the list size.
    //

    if ( MemberCount < BigListSize ) {

        //
        // If less than 800 users, make the list size the smallest
        // possible multiple of 25 users.
        //

        LengthCount = ( ( MemberCount + SmallListGrowIncrement - 1 ) /
                      SmallListGrowIncrement ) *
                      SmallListGrowIncrement;

    } else {

        //
        // If 800 users or more, make the list size the smallest
        // possible multiple of 250 users.
        //

        LengthCount = ( ( MemberCount + BigListGrowIncrement - 1 ) /
                      BigListGrowIncrement ) *
                      BigListGrowIncrement;
    }

    ASSERT( LengthCount >= MemberCount );

    if ( LengthCount == MemberCount ) {

        //
        // Just the right size.  Use the buffer that was passed in.
        //

        LocalMembers = Members;

    } else {

        //
        // We need to allocate a larger buffer before we set the attribute.
        //

        LocalMembers = MIDL_user_allocate( LengthCount * sizeof(ULONG));

        if ( LocalMembers == NULL ) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // Copy the old buffer to the larger buffer, and zero out the
            // empty stuff at the end.
            //

            RtlCopyMemory( LocalMembers, Members, MemberCount * sizeof(ULONG));

            RtlZeroMemory(
                (LocalMembers + MemberCount),
                (LengthCount - MemberCount) * sizeof(ULONG)
                );
        }
    }

    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SampSetUlongArrayAttribute(
                            GroupContext,
                            SAMP_GROUP_MEMBERS,
                            LocalMembers,
                            MemberCount,
                            LengthCount
                            );
    }

    if ( LocalMembers != Members ) {

        //
        // We must have allocated a larger local buffer, so free it.
        //

        MIDL_user_free( LocalMembers );
    }

    return( NtStatus );
}



NTSTATUS
SampDeleteGroupKeys(
    IN PSAMP_OBJECT Context
    )

/*++
Routine Description:

    This service deletes all registry keys related to a group object.


Arguments:

    Context - Points to the group context whose registry keys are
        being deleted.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    ULONG                   Rid;
    UNICODE_STRING          AccountName, KeyName;

    SAMTRACE("SampDeleteGroupKeys");


    Rid = Context->TypeBody.Group.Rid;


    //
    // Groups are arranged as follows:
    //
    //  +-- Groups [Count]
    //      ---+--
    //         +--  Names
    //         |    --+--
    //         |      +--  (GroupName) [GroupRid,]
    //         |
    //         +--  (GroupRid) [Revision,SecurityDescriptor]
    //               ---+-----
    //                  +--  V1_Fixed [,SAM_V1_0A_FIXED_LENGTH_GROUP]
    //                  +--  Name [,Name]
    //                  +--  AdminComment [,unicode string]
    //                  +--  Members [Count,(Member0Rid, (...), MemberX-1Rid)]
    //
    // This all needs to be deleted from the bottom up.
    //


    //
    // Decrement the group count
    //

    NtStatus = SampAdjustAccountCount(SampGroupObjectType, FALSE);




    //
    // Delete the registry key that has the group's name to RID mapping.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get the name
        //

        NtStatus = SampGetUnicodeStringAttribute(
                       Context,
                       SAMP_GROUP_NAME,
                       TRUE,    // Make copy
                       &AccountName
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampBuildAccountKeyName(
                           SampGroupObjectType,
                           &KeyName,
                           &AccountName
                           );

            SampFreeUnicodeString( &AccountName );


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlAddActionToRXact(
                               SampRXactContext,
                               RtlRXactOperationDelete,
                               &KeyName,
                               0,
                               NULL,
                               0
                               );

                SampFreeUnicodeString( &KeyName );
            }
        }
    }




    //
    // Delete the attribute keys
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampDeleteAttributeKeys(
                        Context
                        );
    }




    //
    // Delete the RID key
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampBuildAccountSubKeyName(
                       SampGroupObjectType,
                       &KeyName,
                       Rid,
                       NULL
                       );

        if (NT_SUCCESS(NtStatus)) {


            NtStatus = RtlAddActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationDelete,
                           &KeyName,
                           0,
                           NULL,
                           0
                           );
            SampFreeUnicodeString( &KeyName );
        }


    }



    return( NtStatus );

}




NTSTATUS
SampChangeGroupAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    OUT PUNICODE_STRING OldAccountName
    )

/*++
Routine Description:

    This routine changes the account name of a group account.

    IN THE REGISTRY CASE THIS SERVICE MUST BE 
    CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    Context - Points to the group context whose name is to be changed.

    NewAccountName - New name to give this account

    OldAccountName - old name is returned here. The buffer should be freed
                     by calling MIDL_user_free.

Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        SampGetUnicodeStringAttribute()
        SampSetUnicodeStringAttribute()
        SampValidateAccountNameChange()
        RtlAddActionToRXact()



--*/
{

    NTSTATUS        NtStatus;
    UNICODE_STRING  KeyName;

    SAMTRACE("SampChangeGroupAccountName");

    /////////////////////////////////////////////////////////////
    // There are two copies of the name of each account.       //
    // one is under the DOMAIN\(domainName)\GROUP\NAMES key,   //
    // one is the value of the                                 //
    // DOMAIN\(DomainName)\GROUP\(rid)\NAME key                //
    /////////////////////////////////////////////////////////////

    //
    // Get the current name so we can delete the old Name->Rid
    // mapping key.
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   Context,
                   SAMP_GROUP_NAME,
                   TRUE, // Make copy
                   OldAccountName
                   );

    //
    // Make sure the name is valid and not already in use
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampValidateAccountNameChange(
                       Context,
                       NewAccountName,
                       OldAccountName,
                       SampGroupObjectType
                       );

        if (!IsDsObject(Context))
        {
            //
            // For Registry Case Re-Create Keys
            //

            //
            // Delete the old name key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampGroupObjectType,
                               &KeyName,
                               OldAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationDelete,
                                   &KeyName,
                                   0,
                                   NULL,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );
                }

            }

            //
            //
            // Create the new Name->Rid mapping key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampGroupObjectType,
                               &KeyName,
                               NewAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    ULONG GroupRid = Context->TypeBody.Group.Rid;

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &KeyName,
                                   GroupRid,
                                   (PVOID)NULL,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );
                }
            }

        }


        //
        // replace the account's name
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampSetUnicodeStringAttribute(
                           Context,
                           SAMP_GROUP_NAME,
                           NewAccountName
                           );
        }

        //
        // Free up the old account name if we failed
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampFreeUnicodeString(OldAccountName);
        }

    }


    return(NtStatus);
}


NTSTATUS
SampAddAccountToGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG AccountRid,
    IN DSNAME * MemberDsName OPTIONAL
    )

/*++

Routine Description:

    This service adds the specified account rid to the member list
    for the specified group. This is a low-level function that
    simply edits the member attribute of the group context passed.

Arguments:

    GroupContext - The group whose member list will be modified

    AccountRid - The RID of the account being added as a new member.

    MemberDsName -- Optional Parameter specifies the DS Name of the
                    member, if already known. Saves a Search.

Return Value:


    STATUS_SUCCESS - The account has been added.

    STATUS_MEMBER_IN_GROUP - The account is already a member

--*/
{
    NTSTATUS                NtStatus=STATUS_SUCCESS;
    ULONG                   MemberCount, i;
    PULONG                  MemberArray;
    PWCHAR                  MemberStringName = NULL;

    SAMTRACE("SampAddAccountToGroupMembers");

    //
    // Do different things for DS and Registry
    //

    if (IsDsObject(GroupContext))
    {
        DSNAME * DsNameOfAccount = NULL;

        //
        // DS based Domain, either the RID or the DSNAME should be 
        // present
        //

        ASSERT((ARGUMENT_PRESENT(MemberDsName)) || (0!=AccountRid));


        if (!ARGUMENT_PRESENT(MemberDsName))
        {

            //
            // Get the DSNAME corresponding to the given SID.
            //

            NtStatus = SampDsLookupObjectByRid(
                            DomainObjectFromAccountContext(GroupContext),
                            AccountRid,
                            &DsNameOfAccount
                            );

            if (NT_SUCCESS(NtStatus))
            {
                MemberDsName = DsNameOfAccount;
            }
        }

        if NT_SUCCESS(NtStatus)
        {
            //
            // Get Member String Name if available
            // 
            if (MemberDsName->NameLen && MemberDsName->StringName)
            {
                MemberStringName = MemberDsName->StringName;
            }
            //
            // Add this entry to the Ds. In Lookback case, buffer the membership operaion in 
            // object context. By doing so, we can speed up multiple membership add / remove
            // operaions.
            //

            if (GroupContext->BufferWrites)
            {
                NtStatus = SampDsAddMembershipOperationToCache(
                                            GroupContext, 
                                            ADD_VALUE,
                                            MemberDsName
                                            );
            }
            else
            {
                NtStatus = SampDsAddMembershipAttribute(
                                GroupContext->ObjectNameInDs,
                                SampGroupObjectType,
                                MemberDsName
                                );
            }
            
            //
            // Re-Map any necessary Error Codes
            //

            if (STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS==NtStatus)
            {
                NtStatus = STATUS_MEMBER_IN_GROUP;
            }

            if (NULL!=DsNameOfAccount)
            {
                MIDL_user_free(DsNameOfAccount);
            }
        }

    }
    else
    {
        //
        // Registry Case
        //

        //
        // Get the existing member list
        // Note that the member array always includes space
        // for one new member
        //

        NtStatus = SampRetrieveGroupMembers(
                        GroupContext,
                        &MemberCount,
                        &MemberArray
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Fail if the account is already a member
            //

            for (i = 0; i<MemberCount ; i++ ) {

                if ( MemberArray[i] == AccountRid ) {

                    ASSERT(FALSE);
                    NtStatus = STATUS_MEMBER_IN_GROUP;
                }
            }


            if (NT_SUCCESS(NtStatus)) {

                //
                // Add the user's RID to the end of the list
                //

                MemberArray[MemberCount] = AccountRid;
                MemberCount += 1;

                //
                // Set the new group member list
                //

                NtStatus = SampReplaceGroupMembers(
                                GroupContext,
                                MemberCount,
                                MemberArray
                                );


            }

            //
            // Free up the member list
            //

            MIDL_user_free( MemberArray );

        }
    }

    //
    // audit this, if necessary.
    //

    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(GroupContext->DomainIndex)) {

        SampAuditGroupMemberChange(GroupContext,    // Group Context
                                   TRUE,            // Add member
                                   MemberStringName,// Member Name
                                   &AccountRid,     // Member RID
                                   NULL             // Member SID
                                   );
    }


    return(NtStatus);
}


NTSTATUS
SampRemoveAccountFromGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG AccountRid,
    IN DSNAME * MemberDsName OPTIONAL
    )

/*++

Routine Description:

    This service removes the specified account from the member list
    for the specified group. This is a low-level function that
    simply edits the member attribute of the group context passed.
    The change is audited in the SAM account management audit.

Arguments:

    GroupContext - The group whose member list will be modified

    AccountRid - The RID of the account being added as a new member.

    MemberDsName -- The DS Name of the member if already known

Return Value:


    STATUS_SUCCESS - The account has been added.

    STATUS_MEMBER_NOT_IN_GROUP - The account is not a member of the group.

--*/
{
    NTSTATUS                NtStatus=STATUS_SUCCESS;
    ULONG                   MemberCount, i;
    PULONG                  MemberArray;
    PWCHAR                  MemberStringName = NULL;

    SAMTRACE("SampRemoveAccountFromGroupMembers");

    //
    // Do different things for registry and DS cases
    //

    if (IsDsObject(GroupContext))
    {
        DSNAME * DsNameOfAccount = NULL;

        //
        // DS based Domain
        //

        ASSERT((ARGUMENT_PRESENT(MemberDsName)) || (0!=AccountRid));

        if (!ARGUMENT_PRESENT(MemberDsName))
        {
            //
            // Get the DSNAME corresponding to the given SID.
            // This may result in a call to the GC server.
            //

            NtStatus = SampDsLookupObjectByRid(
                        DomainObjectFromAccountContext(GroupContext),
                        AccountRid,
                        &DsNameOfAccount
                        );

            if (NT_SUCCESS(NtStatus))
            {
                MemberDsName = DsNameOfAccount;
            }
        }
        if NT_SUCCESS(NtStatus)
        {
            //
            //  Get the Member Name if it is available.
            //
            if (MemberDsName->NameLen && MemberDsName->StringName)
            {
                MemberStringName = MemberDsName->StringName;
            }

            //
            // Add this entry to the Ds
            //

            if (GroupContext->BufferWrites)
            {
                NtStatus = SampDsAddMembershipOperationToCache(
                                            GroupContext, 
                                            REMOVE_VALUE,
                                            MemberDsName
                                            );
            }
            else 
            {
                NtStatus = SampDsRemoveMembershipAttribute(
                            GroupContext->ObjectNameInDs,
                            SampGroupObjectType,
                            MemberDsName
                            );
            }

            //
            // Re-Map any necessary Error Codes
            //

            if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
            {
                NtStatus = STATUS_MEMBER_NOT_IN_GROUP;
            }

            if (NULL!=DsNameOfAccount)
            {
                MIDL_user_free(DsNameOfAccount);
            }
        }

    }

    else
    {

        //
        // Registry based Domain
        //

        //
        // Get the existing member list
        //


        NtStatus = SampRetrieveGroupMembers(
                        GroupContext,
                        &MemberCount,
                        &MemberArray
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Remove the account
            //

            NtStatus = STATUS_MEMBER_NOT_IN_GROUP;

            for (i = 0; i<MemberCount ; i++ ) {

                if (MemberArray[i] == AccountRid) {

                    MemberArray[i] = MemberArray[MemberCount-1];
                    MemberCount -=1;

                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Set the new group member list
                //

                NtStatus = SampReplaceGroupMembers(
                                GroupContext,
                                MemberCount,
                                MemberArray
                                );

            }

        //
        // Free up the member list
        //

        MIDL_user_free( MemberArray );
        }

    }

    //
    // audit this, if necessary.
    //

    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(GroupContext->DomainIndex)) {

        SampAuditGroupMemberChange(GroupContext,    // Group Context
                                   FALSE,           // Remove Member
                                   MemberStringName,// Member Name
                                   &AccountRid,     // Member RID
                                   NULL             // Member SID (not used)
                                   );

    }


    return(NtStatus);
}


NTSTATUS
SampEnforceSameDomainGroupMembershipChecks(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG MemberRid
    )
/*++

  Routine Description:

   Validates wether the (potential) group object ( of may be any type
   in the same domain ) can be a member of the group ( of may be any
   type ) described by AccountContext
   This routine checks the account/ resource / unversal / local group
   restrictions

  Arguments:

    AccountContext -- The Object that is being operated upon. Can be a group
                      or alias context

    MemberRid - The relative ID of the user.

  Return Values

     STATUS_SUCCESS
     Various error codes to describe that group membership and nesting
     rules are being violated. Each unique group nesting rule has its own
     error code

  --*/
{

    NTSTATUS        NtStatus = STATUS_SUCCESS;
    PSAMP_OBJECT    MemberContext=NULL;
    NT4_GROUP_TYPE  NT4GroupType;
    NT5_GROUP_TYPE  NT5GroupType;
    BOOLEAN         SecurityEnabled;


    ASSERT(IsDsObject(AccountContext));

    if ( AccountContext->TrustedClient )
    {
        return(STATUS_SUCCESS);
    }

    if (SampAliasObjectType==AccountContext->ObjectType)
    {
        NT4GroupType = AccountContext->TypeBody.Alias.NT4GroupType;
        NT5GroupType = AccountContext->TypeBody.Alias.NT5GroupType;
        SecurityEnabled = AccountContext->TypeBody.Alias.SecurityEnabled;
    }
    else if (SampGroupObjectType == AccountContext->ObjectType)
    {
        NT4GroupType = AccountContext->TypeBody.Group.NT4GroupType;
        NT5GroupType = AccountContext->TypeBody.Group.NT5GroupType;
        SecurityEnabled = AccountContext->TypeBody.Group.SecurityEnabled;
    }
    else
    {
        ASSERT(FALSE && "Invalid Object Type");
        return STATUS_INTERNAL_ERROR;
    }


    //
    // At this point we know that the member specified is not a User.
    // The member specified may be a group .
    //

    NtStatus = SampCreateAccountContext2(
                    AccountContext,         // Group Context
                    SampGroupObjectType,    // Member Object Type 
                    MemberRid,              // Member Object Id
                    NULL,                   // User Account Control
                    NULL,                   // Account Name
                    AccountContext->ClientRevision, // Client Revision
                    TRUE,                   // We're trusted
                    AccountContext->LoopbackClient, // Loopback client
                    FALSE,                  // Create by privilege
                    TRUE,                   // Account exists
                    TRUE,                   // Override local group check
                    NULL, // No creation involved, don't specify a group type
                    &MemberContext
                    );

    if (STATUS_NO_SUCH_GROUP==NtStatus)
    {
        //
        // If the operation failed because the group did not exist
        // whack the status code to STATUS_NO_SUCH_USER. This error code
        // will be better understood by downlevel clients. This is because
        // the actual position at this time is that neither a user, nor a
        // group of the given RID exists. The check for the user was done
        // by an earlier routine. This position is equally well described by
        // an error code that informs that the user does not exist.
        //

        NtStatus = STATUS_NO_SUCH_USER;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // Group Object Could not be created. This may be because either
        // no group / localgroup corresponding to Rid exists or because of
        // resource failures
        //

        goto Error;
    }

    //
    // Now several checks
    //

    //
    // In mixed domain no nesting of global groups if group is security enabled
    //
     if ((DownLevelDomainControllersPresent(AccountContext->DomainIndex))
          && (SecurityEnabled)
          && (NT4GroupType == NT4GlobalGroup))
    {
        //
        // We can concievably add a new error code. However that will still confuse
        // down level clients
        //

        NtStatus = STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN;
        goto Error;
    }

    //
    // In a mixed domain mode, cannot nest local groups with other local groups.
    // if the group is security enabled
    //

    if ((DownLevelDomainControllersPresent(AccountContext->DomainIndex))
          && (SecurityEnabled)
          && (MemberContext->TypeBody.Group.NT4GroupType == NT4LocalGroup)
          && (NT4GroupType == NT4LocalGroup))
    {
        //
        // We can concievably add a new error code. However that will still confuse
        // down level clients
        //

        NtStatus = STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN;
        goto Error;
    }

    //
    // Cannot ever add a resource(local) group as a member of an 
    // account(global) group 
    //

    if ((NT5GroupType==NT5AccountGroup)
        && (MemberContext->TypeBody.Group.NT5GroupType == NT5ResourceGroup))
    {
        NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER;
        goto Error;
    }

    //
    // Cannot ever add a universal group as a member of an account group
    //

    if ((NT5GroupType==NT5AccountGroup)
        && (MemberContext->TypeBody.Group.NT5GroupType==NT5UniversalGroup))
    {
        NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER;
        goto Error;
    }

    //
    // Cannot add a resource group as a member of a  universal group
    //

     if ((NT5GroupType==NT5UniversalGroup)
        && (MemberContext->TypeBody.Group.NT5GroupType==NT5ResourceGroup))
    {
        NtStatus = STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER;
        goto Error;
    }

Error:

    if (NULL!=MemberContext)
    {

        SampDeleteContext(MemberContext);
    }

    return NtStatus;
}


NTSTATUS
SampEnforceCrossDomainGroupMembershipChecks(
    IN PSAMP_OBJECT     AccountContext,
    IN PSID             MemberSid,
    IN DSNAME           *MemberName
    )
/*++

    This routine enforces cross domain group membership checks
    by looking up the member in the GC verify cache, obtaining the
    group Type and enforcing the checks pertaining to "limited groups".

    Parameters:
        AccountContext  SAM context to the account
        MemberSid       The Sid of the member
        MemberName      The DSNAME of the member. Note that we pass in
                        both DSNAME and Sid. This is because there is
                        no DSNAME in the workstation case. Passing in the
                        SID allows the routine to be easily extended to
                        the workstation case if necessary, in which case
                        the MemberName parameter will become an OPTIONAL
                        parameter.

    Return Values

        STATUS_SUCCESS
        STATUS_INVALID_MEMBER --- Note Comment above regarding downlevel
                                  compatibility applies here too.

--*/

{
    NTSTATUS        NtStatus;
    NT4_GROUP_TYPE  NT4GroupType;
    NT5_GROUP_TYPE  NT5GroupType;
    BOOLEAN         SecurityEnabled;
    ENTINF          *pEntinf;
    ULONG           MemberGroupType;
    ATTR            *GroupTypeAttr;
    ATTR            *ObjectClassAttr;
    BOOLEAN         LocalSid=FALSE;
    BOOLEAN         WellKnownSid=FALSE;
    BOOLEAN         ForeignSid = FALSE;
    BOOLEAN         EnterpriseSid = FALSE;
    BOOLEAN         BuiltinDomainSid = FALSE;
    BOOLEAN         IsGroup = FALSE;
    ULONG           i;


    ASSERT(IsDsObject(AccountContext));

    if ( AccountContext->TrustedClient )
    {
        return(STATUS_SUCCESS);
    }

    //
    // Get the type of the group that we are modifying
    //

    if (SampAliasObjectType==AccountContext->ObjectType)
    {
        NT4GroupType = AccountContext->TypeBody.Alias.NT4GroupType;
        NT5GroupType = AccountContext->TypeBody.Alias.NT5GroupType;
        SecurityEnabled = AccountContext->TypeBody.Alias.SecurityEnabled;
    }
    else if (SampGroupObjectType == AccountContext->ObjectType)
    {
        NT4GroupType = AccountContext->TypeBody.Group.NT4GroupType;
        NT5GroupType = AccountContext->TypeBody.Group.NT5GroupType;
        SecurityEnabled = AccountContext->TypeBody.Group.SecurityEnabled;
    }
    else
    {
        ASSERT(FALSE && "Invalid Object Type");
        return STATUS_INTERNAL_ERROR;
    }

    //
    // An account group cannot have a cross domain member
    //

    if (NT5AccountGroup == NT5GroupType)
        return STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER;

    //
    // A security enabled NT4 Global group cannot have cross domain member
    // in a mixed domain
    //

    if ((DownLevelDomainControllersPresent(AccountContext->DomainIndex))
        && (NT4GlobalGroup == NT4GroupType)
        && (SecurityEnabled))
        return STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER;

    //
    // Examine the SID of the member
    //

    NtStatus = SampDsExamineSid(
                    MemberSid,
                    &WellKnownSid,
                    &BuiltinDomainSid,
                    &LocalSid,
                    &ForeignSid,
                    &EnterpriseSid
                    );

    if (!NT_SUCCESS(NtStatus))
        return NtStatus;

    if ((WellKnownSid) && (!IsBuiltinDomain(AccountContext->DomainIndex)))
    {
        //
        // A SID like everyone sid cannot be
        // a member of a group other than the builtin domain groups
        //

        return (STATUS_INVALID_MEMBER);
    }
    else if ( BuiltinDomainSid)
    {
        //
        // Group like Administrators etc cannot be a member of
        // anything else
        //

        return ( STATUS_INVALID_MEMBER);
    }
    else if ((ForeignSid) || (WellKnownSid)) 
    {
        
        if (NT5ResourceGroup==NT5GroupType)
        {
            //
            // These will be added as an FPO to resource groups
            //

            return (STATUS_SUCCESS);
        }
        else if (NT5UniversalGroup==NT5GroupType)
        {
            //
            // Universal groups cannot have foriegn Security 
            // prinicpals as members
            //

            return (STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS);
        }
        else
        {
            //
            // Must be a account group, no memberships from other
            // domains
            //

            return(STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER);
        }
    }
    

    //
    // By the time we reach here the member cannot be
    // anything other than the 2 below
    //

    ASSERT(LocalSid||EnterpriseSid);

    //
    // The DS Name of the member must be known 
    //

    ASSERT(NULL!=MemberName);

    //
    // If either the member is local or if we are a GC, then
    // do the check locally
    //

    if ((SampAmIGC()) || (LocalSid))
    {
        ATTRTYP RequiredAttrTyp[] = {
                                     SAMP_FIXED_GROUP_OBJECTCLASS,
                                     SAMP_FIXED_GROUP_TYPE
                                    };
        ATTRVAL RequiredAttrVal[] = {{0,NULL},{0,NULL}};
        DEFINE_ATTRBLOCK2(RequiredAttrs,RequiredAttrTyp,RequiredAttrVal);
        ATTRBLOCK   ReadAttrs;

        //
        // If we are the GC ourselves try to read the group type
        // and object class properties from the local DS.
        //

        NtStatus = SampDsRead(
                    MemberName,
                    0,
                    SampGroupObjectType,
                    &RequiredAttrs,
                    &ReadAttrs
                    );

        if (!NT_SUCCESS(NtStatus))
        {
            return STATUS_DS_INVALID_GROUP_TYPE;
        }

        GroupTypeAttr = SampDsGetSingleValuedAttrFromAttrBlock(
                            SAMP_FIXED_GROUP_TYPE,
                            &ReadAttrs
                            );
        for (i=0;i<ReadAttrs.attrCount;i++)
        {
            if (ReadAttrs.pAttr[i].attrTyp==SAMP_FIXED_GROUP_OBJECTCLASS)
            {
               ObjectClassAttr = &(ReadAttrs.pAttr[i]);
               break;
            }
        }


    }
    else
    {

        //
        // Check the verify cache for the attributes
        //

        pEntinf = GCVerifyCacheLookup(MemberName);
        if (NULL==pEntinf)
        {
            //
            // Verfiy Cache lookup failed
            //

            return STATUS_DS_INVALID_GROUP_TYPE;
        }

        GroupTypeAttr = SampDsGetSingleValuedAttrFromAttrBlock(
                            SampDsAttrFromSamAttr(SampGroupObjectType,
                                            SAMP_FIXED_GROUP_TYPE),
                            &pEntinf->AttrBlock
                            );

        for (i=0;i<pEntinf->AttrBlock.attrCount;i++)
        {
            if (pEntinf->AttrBlock.pAttr[i].attrTyp==ATT_OBJECT_CLASS)
            {
               ObjectClassAttr = &(pEntinf->AttrBlock.pAttr[i]);
               break;
            }
        }
    }

    ASSERT(NULL!=ObjectClassAttr);

    //
    // Check if the object is derived from group or is of class group
    //

    for (i=0;i<ObjectClassAttr->AttrVal.valCount;i++)
    {
        if ((ObjectClassAttr->AttrVal.pAVal[i].valLen) &&
           (NULL!=ObjectClassAttr->AttrVal.pAVal[i].pVal) &&
           (CLASS_GROUP == * ((UNALIGNED ULONG *)ObjectClassAttr->AttrVal.pAVal[i].pVal)) ) 
        {
            IsGroup = TRUE;
            break;
        }
    }

    if (!IsGroup)
    {
        //
        // Assume for now that the member is not a group.
        // therefore return success.
        //

        return STATUS_SUCCESS;
    }

    ASSERT(NULL!=GroupTypeAttr && "Groups must have a group type");
    if (NULL==GroupTypeAttr)
    {
         return(STATUS_INVALID_MEMBER);
    }

    MemberGroupType = * ((UNALIGNED ULONG *)GroupTypeAttr->AttrVal.pAVal[0].pVal);

    //
    // An universal group cannot have a resource group as a member
    //

    if ((NT5UniversalGroup==NT5GroupType)
            && (MemberGroupType & GROUP_TYPE_RESOURCE_GROUP))
    {
        return STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER;
    }

    //
    // A Resource group cannot have another cross domain resource
    // group as a member
    //


    if ((NT5ResourceGroup==NT5GroupType)
            && (MemberGroupType & GROUP_TYPE_RESOURCE_GROUP))
    {
        return STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER;
    }

    return STATUS_SUCCESS;
}




NTSTATUS
SampAddSameDomainMemberToGlobalOrUniversalGroup(
    IN  PSAMP_OBJECT AccountContext,
    IN  ULONG        MemberId,
    IN  ULONG        Attributes,
    IN  DSNAME       *MemberDsName OPTIONAL
    )
/*++
    Routine Description:

    This routine is used add a member from the
    same domain for globalgroups and universal groups. It performs
    the same domain group consistency checks and the primary group 
    id related optimization/consistency checks.


Parameters:

    AccountContext - The handle of an opened group to operate on.

    MemberId - Relative ID of the member to add.

    Attributes - The attributes of the group assigned to the user.
        The attributes assigned here may have any value.  However,
        at logon time these attributes are minimized by the
        attributes of the group as a whole.

    MemberDsName -- The DS name of the member if already known. Saves
                    a lookup by RID

Return Values:

    STATUS_SUCCESS - The Service completed successfully.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_MEMBER - The member specified is unknown.

    STATUS_MEMBER_IN_GROUP - The member already belongs to the group.

    STATUS_INVALID_GROUP_ATTRIBUTES - Indicates the group attribute
        values being assigned to the member are not compatible with
        the attribute values of the group as a whole.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    SAMP_V1_0A_FIXED_LENGTH_GROUP  GroupV1Fixed;
    NTSTATUS                NtStatus, TmpStatus;
    BOOLEAN                 UserAccountActive;
    BOOLEAN                 PrimaryGroup;
    ULONG                   ObjectRid = AccountContext->TypeBody.Group.Rid;



    NtStatus = SampRetrieveGroupV1Fixed(
                   AccountContext,
                   &GroupV1Fixed
                   );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Perform the user object side of things
        //

        //
        // Add Group to User Membership Checks for the existance of the user
        // and then depending upon DS/Registry case adds the group to the
        // user's reverse membership. The reverse membership addition is not
        // done in the DS case
        //

        NtStatus = SampAddGroupToUserMembership(
                       AccountContext,
                       ObjectRid,
                       Attributes,
                       MemberId,
                       (GroupV1Fixed.AdminCount == 0) ? NoChange : AddToAdmin,
                       (GroupV1Fixed.OperatorCount == 0) ? NoChange : AddToAdmin,
                       &UserAccountActive,
                       &PrimaryGroup
                       );

       if ((NtStatus == STATUS_NO_SUCH_USER)
            &&  ( IsDsObject(AccountContext)))
       {
           //
           // It is not an User Object. It can be a group Object
           // as from NT5 Onwards we support adding groups to group
           // memberships. This must be done only for the DS case.
           // There are several restrictions depending upon the type of
           // the group, and these will need to be check for
           //

           NtStatus = SampEnforceSameDomainGroupMembershipChecks(
                            AccountContext,
                            MemberId
                            );
       }
       else if (   (NT_SUCCESS(NtStatus))
                && (IsDsObject(AccountContext))
                && (PrimaryGroup))
       {
           //
           // In the DS the group membership in the primary group is
           // maintained implicitly in the primary group Id property.
           // therefore we will fail the call with a status member in
           // group
           //

           NtStatus = STATUS_MEMBER_IN_GROUP;
       }


        //
        // Now perform the group side of things
        //

        if (NT_SUCCESS(NtStatus)) {


            //
            // Add the user to the group (should not fail)
            // This addition is not done in the DS case, if the group
            // specified is the primary group of the user. This is because the
            // primarly group membership is maintained implicitly in the primary
            // group id property.
            //



            NtStatus = SampAddAccountToGroupMembers(
                           AccountContext,
                           MemberId,
                           MemberDsName
                           );

        }
    }
    
    return NtStatus;
}


NTSTATUS
SampRemoveSameDomainMemberFromGlobalOrUniversalGroup(
    IN  PSAMP_OBJECT AccountContext,
    IN  ULONG        MemberId,
    IN  DSNAME       *MemberDsName OPTIONAL
    )
/*++
    Routine Description:

    This is the actual worker routine for removing a member from a
    global/universal group in the same domain.


    WARNING : THIS ROUTINE MUST BE CALLED WITH THE WRITELOCK HELD
              IN THE REGISTY CASE
Parameters:

    AccountContext - The handle of an opened group to operate on.

    MemberId - Relative ID of the member to add.

    MemberDsName -- The DS Name of the member, if already known

Return Values:

    STATUS_SUCCESS - The Service completed successfully.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_MEMBER - The member specified is unknown.

    STATUS_MEMBER_IN_GROUP - The member already belongs to the group.



    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    SAMP_V1_0A_FIXED_LENGTH_GROUP  GroupV1Fixed;
    NTSTATUS                NtStatus, TmpStatus;
    ULONG                   ObjectRid;
    BOOLEAN                 UserAccountActive;
    UNICODE_STRING          GroupName;



    

    ObjectRid = AccountContext->TypeBody.Group.Rid;


    NtStatus = SampRetrieveGroupV1Fixed(
                   AccountContext,
                   &GroupV1Fixed
                   );


    if (NT_SUCCESS(NtStatus)) {


        //
        // Perform the user object side of things
        //

        NtStatus = SampRemoveMembershipUser(
                       AccountContext,
                       ObjectRid,
                       MemberId,
                       (GroupV1Fixed.AdminCount == 0) ? NoChange : RemoveFromAdmin,
                       (GroupV1Fixed.OperatorCount == 0) ? NoChange : RemoveFromAdmin,
                       &UserAccountActive
                       );
       if ((NtStatus == STATUS_NO_SUCH_USER)
                && (IsDsObject(AccountContext)))
       {
           //
           // It is not an User Object. It can be a group Object
           // as from win2k onwards, Therefore reset the status
           // code
           //



            NtStatus = STATUS_SUCCESS;
       }


        //
        // Now perform the group side of things
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Remove the user from the group
            //

            NtStatus = SampRemoveAccountFromGroupMembers(
                           AccountContext,
                           MemberId,
                           MemberDsName
                           );
        }
    }


   

    return NtStatus;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Services Available to NT5 SAM In process clients                        //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamIAddDSNameToGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN DSNAME   *   DSName
    )
/*
    Routine Description

        Adds the given DSNAME to membership list of the group specified by
        Group Handle

    Arguments:

        GroupHandle -- SAMPR_HANDLE returned by an Open Group
        DSName      -- Pointer to a DSNAME structure. The caller is responsible for
                       Allocating / freeing this structure

    Return Values:

            STATUS_SUCCESS
            Other error codes from DsLayer

*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            TmpStatus;
    PSAMP_OBJECT        AccountContext;
    SAMP_OBJECT_TYPE    FoundType;
    PSID                Sid = NULL;
    DSNAME              *ImprovedDSName = NULL;


    SAMTRACE("SamIAddDSNameToGroup");

        
    SampTraceEvent(EVENT_TRACE_TYPE_START, 
                   SampGuidAddMemberToGroup
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

   

    //
    // Reference the context
    //

    AccountContext = (PSAMP_OBJECT)(GroupHandle);
    SampReferenceContext(AccountContext);

                   
    if (IsDsObject(AccountContext))
    {
       //
       // See what the DSNAME represents.
       //

       NtStatus = SampValidateDSName(
                    AccountContext,
                    DSName,
                    &Sid,
                    &ImprovedDSName
                    );

       if ( NT_SUCCESS(NtStatus))
       {

           if (NULL!=Sid)
           {
                
               //
               // This is the case of a security prinicipal,
               // split the SID into a DomainSid and a Rid.
               //

               ULONG Rid;
               PSID  DomainSid = NULL;

               NtStatus = SampSplitSid(Sid, &DomainSid, &Rid);


               if (NT_SUCCESS(NtStatus))
               {

                   if (RtlEqualSid(DomainSid,
                        DomainSidFromAccountContext(AccountContext)))
                   {

                        //
                        // Member to be added is in the same domain.
                        // Add the member to the group
                        // The below routine is common code path with
                        // the downlevel SamrAddMemberToGroup routine.
                        // Specifically the routine will call the 
                        // Same Domain Consistency Check routine,
                        // enforce constraints such as primary group etc
                        // and then add the member to the group.
                        //

                        NtStatus = 
                           SampAddSameDomainMemberToGlobalOrUniversalGroup(
                                        AccountContext,
                                        Rid,
                                        0,
                                        ImprovedDSName
                                        );

                       
                   }
                   else
                   {
                         //
                        // The member to be added belongs to a different
                        // domain than which the group belongs to
                        //

                        NtStatus = SampEnforceCrossDomainGroupMembershipChecks(
                                        AccountContext,
                                        Sid,
                                        ImprovedDSName
                                        );

                        //
                        // Add the member to the group
                        //

                        if (NT_SUCCESS(NtStatus))
                        {
                             
                            NtStatus = SampAddAccountToGroupMembers(
                                            AccountContext,
                                            0,
                                            ImprovedDSName
                                            );
                        }
                   }


                   MIDL_user_free(DomainSid);
                   DomainSid = NULL;
               }
                        
           }
           else
           {


               //
               // No further checks are performed for the case of a non security 
               // principal, simply add the member and audit
               //
                
               NtStatus = SampAddAccountToGroupMembers(
                                AccountContext,
                                0,
                                ImprovedDSName
                                );
           }

       }
    }
    else
    {
       //
       // Should never expect to hit this call in registry mode
       //

       ASSERT(FALSE && "SamIAddDSNameToGroup in Registry Mode !!!!");

       NtStatus = STATUS_INVALID_PARAMETER;
    }

   

    //
    // Dereference the context
    //

    if (NT_SUCCESS(NtStatus))
    {
        SampDeReferenceContext(AccountContext,TRUE);
    }
    else
    {
        SampDeReferenceContext(AccountContext,FALSE);
    }
    
    
    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidAddMemberToGroup
                   );

    return NtStatus;

}

NTSTATUS
SamIRemoveDSNameFromGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN DSNAME   *   DSName
    )
/*
    Routine Description

        Removes the given DSNAME to membership list of the group specified by
        Group Handle

    Arguments:

        GroupHandle -- SAMPR_HANDLE returned by an Open Group
        DSName      -- Pointer to a DSNAME structure. The caller is responsible for
                       Allocating / freeing this structure

    Return Values:

            STATUS_SUCCESS
            Other error codes from DsLayer

*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            TmpStatus;
    PSAMP_OBJECT        AccountContext;
    SAMP_OBJECT_TYPE    FoundType;
    PSID                Sid = NULL;
    DSNAME              *ImprovedDSName = NULL;


    SAMTRACE("SamIRemoveDSNameFromGroup");
    
    
    SampTraceEvent(EVENT_TRACE_TYPE_START, 
                   SampGuidRemoveMemberFromGroup
                   );
                   

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );
        

   
    //
    // Reference the context. The handle is being assumed to be
    // valid -- called from ntdsa - trusted code.
    //
    AccountContext = (PSAMP_OBJECT)(GroupHandle);
    SampReferenceContext(AccountContext
                     );

   if (IsDsObject(AccountContext))
   {

       //
       // See what the DSNAME represents.
       //

       NtStatus = SampValidateDSName(
                    AccountContext,
                    DSName,
                    &Sid,
                    &ImprovedDSName
                    );

       if ( NT_SUCCESS(NtStatus))
       {
           BOOLEAN fMemberRemoved = FALSE;

           if (NULL!=Sid)
           {
               PSID DomainSid = NULL;
               ULONG Rid;


               //
               // This is a security principal
               //

               NtStatus = SampSplitSid(Sid,&DomainSid,&Rid);
               

               if (NT_SUCCESS(NtStatus))
               {

                    if ( RtlEqualSid(DomainSid,
                            DomainSidFromAccountContext(AccountContext))) 
                    {
        

                      //
                      // Member to be removed is in the same domain.
                      // In this case do exactly what the downlevel
                      // API SamrRemoveMemberFromGroup did.
                      //

              

                      NtStatus = 
                      SampRemoveSameDomainMemberFromGlobalOrUniversalGroup(
                                        GroupHandle,
                                        Rid,
                                        ImprovedDSName
                                        );
                      fMemberRemoved = TRUE;
                    }


                    MIDL_user_free(DomainSid);
                    DomainSid = NULL;
               }
           }


           if ((NT_SUCCESS(NtStatus))
               && (!fMemberRemoved))
           {
             

               //
               // This is the case of either a security principal from a 
               // different domain , or a non security principal
               // Remove the Membership by making direct calls to the DS.
               //


                
               NtStatus = SampRemoveAccountFromGroupMembers(
                                AccountContext,
                                0,
                                ImprovedDSName
                                );

              
           }

       }
   }
   else
   {
       //
       // Should never expect to hit this call in registry mode
       //

       ASSERT(FALSE && "SamIAddDSNameToGroup in Registry Mode !!!!");
       NtStatus = STATUS_INVALID_PARAMETER;
   }

    //
    // Dereference the context
    //

    if (NT_SUCCESS(NtStatus))
    {
        SampDeReferenceContext(AccountContext,TRUE);
    }
    else
    {
        SampDeReferenceContext(AccountContext,FALSE);
    }

    SampTraceEvent(EVENT_TRACE_TYPE_END, 
                   SampGuidRemoveMemberFromGroup
                   );

    return NtStatus;

}


NTSTATUS
SampCheckAccountToUniversalConversion(
    DSNAME * GroupToBeConverted
    )
/*++

    Routine Description

        This routine Looks at the group membership list and determines
        if the group can be converted from a Account to a Universal Group.


    Parameters

        GroupToBeConverted - This is the group that we will change from an  account group
                             To a universal group.

    Return Values

        STATUS_SUCCESS
        STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER
--*/
{
    NTSTATUS    NtStatus = STATUS_NOT_SUPPORTED;
    ATTRTYP     MemberType[] = {SAMP_FIXED_GROUP_MEMBER_OF};
    ATTRVAL     MemberVal[] = {0,NULL};
    DEFINE_ATTRBLOCK1(MemberAttrBlock,MemberType,MemberVal);
    ATTRTYP     GroupTypeAttrs[]  = {SAMP_FIXED_GROUP_TYPE,
                                     SAMP_FIXED_GROUP_OBJECTCLASS };
    ATTRVAL     GroupTypeVal[] = {{0,NULL},{0,NULL}};
    DEFINE_ATTRBLOCK2(GroupTypeAttrBlock,GroupTypeAttrs,GroupTypeVal);
    ATTRBLOCK    ReadMemberAttrBlock, ReadGroupAttrBlock;
    ULONG        memberCount;
    ULONG        i;



    // Get the membership list of the group
    //

    NtStatus = SampDsRead(
                GroupToBeConverted,
                0,
                SampGroupObjectType,
                &MemberAttrBlock,
                &ReadMemberAttrBlock
                );


    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
    {
        //
        // For the case of the empty group no further checks need
        // be enforced.
        //

        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    ASSERT(ReadMemberAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_MEMBER_OF);
    ASSERT(ReadMemberAttrBlock.attrCount==1);
    ASSERT(ReadMemberAttrBlock.pAttr[0].AttrVal.valCount>0);

    memberCount = ReadMemberAttrBlock.pAttr[0].AttrVal.valCount;
    ASSERT(memberCount>=1);

    //
    // For each of the members in the membership list read the
    // group type and Object Class
    //

    for (i=0; (i<memberCount);i++)
    {
        DSNAME * MemberName;

        MemberName = (DSNAME *)ReadMemberAttrBlock.pAttr[0].AttrVal.pAVal[i].pVal;

        NtStatus = SampDsRead(
                     MemberName,
                     0,
                     SampGroupObjectType,
                     &GroupTypeAttrBlock,
                     &ReadGroupAttrBlock
                    );

        if ((NT_SUCCESS(NtStatus))
            && (2==ReadGroupAttrBlock.attrCount))
        {

            //
            // Must be a group, read both Group type and object class,
            // member must be a group
            //

            ULONG            GroupType;
            ULONG            ObjectClass;
            NT4_GROUP_TYPE   Nt4GroupType;
            NT5_GROUP_TYPE   Nt5GroupType;
            BOOLEAN          SecurityEnabled;

            //
            // Assert that DS results are consistent with what we expect
            //

            ASSERT(ReadGroupAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_TYPE);
            ASSERT(ReadGroupAttrBlock.pAttr[1].attrTyp == SAMP_FIXED_GROUP_OBJECTCLASS);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.valCount==1);
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.valCount>=1);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].valLen==sizeof(ULONG));
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].valLen==sizeof(ULONG));

            GroupType =
                *((ULONG *) ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
            ObjectClass =
                *((ULONG *) ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

            //
            // Compute the type of the group
            //

            NtStatus = SampComputeGroupType(
                            ObjectClass,
                            GroupType,
                            &Nt4GroupType,
                            &Nt5GroupType,
                            &SecurityEnabled
                            );

            if (NT_SUCCESS(NtStatus))
            {
                if (NT5AccountGroup == Nt5GroupType)
                {
                    NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER;
                    break;
                }
            }
        }

    } // End of For

Error:

    return NtStatus;

}

NTSTATUS
SampCheckResourceToUniversalConversion(
    DSNAME * GroupToBeConverted
    )
/*++

    Routine Description

        This routine Looks at the group membership list and determines
        if the group can be converted from a Resource to a Universal Group.

        An Universal group can have as members anything except resource groups
        and can be the member of any group.

        A resource group can have account and universal groups from anywhere and
        resource groups from the same domain.

        For a resource group to be converted to a universal group, it is only
        necessary to check that none of the members are resource groups

    Parameters

        GroupObjectToBeConveted -- The DSNAME of the group object to be converted

    Return Values

        STATUS_SUCCESS
        STATUS_NOT_SUPPORTED
--*/
{
    NTSTATUS    NtStatus = STATUS_NOT_SUPPORTED;
    ATTRTYP     MemberType[] = {SAMP_GROUP_MEMBERS};
    ATTRVAL     MemberVal[] = {0,NULL};
    DEFINE_ATTRBLOCK1(MemberAttrBlock,MemberType,MemberVal);
    ATTRTYP     GroupTypeAttrs[]  = {SAMP_FIXED_GROUP_TYPE,
                                SAMP_FIXED_GROUP_OBJECTCLASS };
    ATTRVAL     GroupTypeVal[] = {{0,NULL},{0,NULL}};
    DEFINE_ATTRBLOCK2(GroupTypeAttrBlock,GroupTypeAttrs,GroupTypeVal);
    ATTRBLOCK    ReadMemberAttrBlock, ReadGroupAttrBlock;
    ULONG        memberCount;
    ULONG        i;



    // Get the membership list of the group
    //

    NtStatus = SampDsRead(
                GroupToBeConverted,
                0,
                SampGroupObjectType,
                &MemberAttrBlock,
                &ReadMemberAttrBlock
                );


    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
    {
        //
        // For the case of the empty group no further checks need
        // be enforced.
        //

        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    ASSERT(ReadMemberAttrBlock.pAttr[0].attrTyp == SAMP_GROUP_MEMBERS);
    ASSERT(ReadMemberAttrBlock.attrCount==1);
    ASSERT(ReadMemberAttrBlock.pAttr[0].AttrVal.valCount>0);

    memberCount = ReadMemberAttrBlock.pAttr[0].AttrVal.valCount;
    ASSERT(memberCount>=1);

    //
    // For each of the members in the membership list read the
    // group type and Object Class
    //

    for (i=0; (i<memberCount);i++)
    {
        DSNAME * MemberName;

        MemberName = (DSNAME *)ReadMemberAttrBlock.pAttr[0].AttrVal.pAVal[i].pVal;

        NtStatus = SampDsRead(
                     MemberName,
                     0,
                     SampGroupObjectType,
                     &GroupTypeAttrBlock,
                     &ReadGroupAttrBlock
                    );

        if ((NT_SUCCESS(NtStatus))
            && (2==ReadGroupAttrBlock.attrCount))
        {

            //
            // Must be a group, read both Group type and object class,
            // member must be a group
            //

            ULONG            GroupType;
            ULONG            ObjectClass;
            NT4_GROUP_TYPE   Nt4GroupType;
            NT5_GROUP_TYPE   Nt5GroupType;
            BOOLEAN          SecurityEnabled;

            //
            // Assert that DS results are consistent with what we expect
            //

            ASSERT(ReadGroupAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_TYPE);
            ASSERT(ReadGroupAttrBlock.pAttr[1].attrTyp == SAMP_FIXED_GROUP_OBJECTCLASS);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.valCount==1);
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.valCount>=1);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].valLen==sizeof(ULONG));
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].valLen==sizeof(ULONG));

            GroupType =
                *((ULONG *) ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
            ObjectClass =
                *((ULONG *) ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

            //
            // Compute the type of the group
            //

            NtStatus = SampComputeGroupType(
                            ObjectClass,
                            GroupType,
                            &Nt4GroupType,
                            &Nt5GroupType,
                            &SecurityEnabled
                            );

            if (NT_SUCCESS(NtStatus))
            {
                if (NT5ResourceGroup == Nt5GroupType)
                {
                    NtStatus = STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER;
                    break;
                }
            }
        }
        else if (((NT_SUCCESS(NtStatus))
                   && (1==ReadGroupAttrBlock.attrCount))) 
        {

            //
            // The read succeeded. Must be able to retrive the object class
            // but not the group type
            //

            ULONG            ObjectClass;

            ASSERT(1==ReadGroupAttrBlock.attrCount);
            ASSERT(ReadGroupAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_OBJECTCLASS);

            ObjectClass =
                *((ULONG *) ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);


            if (CLASS_FOREIGN_SECURITY_PRINCIPAL==ObjectClass)
            {
                NtStatus = STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS;
                break;
            }
            else
            {
                NtStatus  = STATUS_SUCCESS;
            }
        }
        else if ((STATUS_OBJECT_NAME_NOT_FOUND==NtStatus) 
                 || (STATUS_NOT_FOUND==NtStatus))
        {
            //
            // We have positioned on a phantom maybe, its O.K proceed through
            //

            NtStatus = STATUS_SUCCESS;
        }
        else
        {
            //
            // Some other resource failure has occured. Fail the operation
            //

            break;
        }
    } // End of For

Error:

    return NtStatus;

}

NTSTATUS
SampCheckUniversalToAccountConversion(
    DSNAME * GroupToBeConverted
    )
/*++

    Routine Description

        This routine Looks at the group membership list and determines
        if the group can be converted from a Universal Group to an account group.

        An account group can have only other account group and users from the
        same domain as members.

        An universal group can have account and universal groups and users from anywhere 
        as members.

        For a universal group to be converted to a account group, it is necessary
        to check that its members are
            1. From the same domain
            2. Are account groups/users

    Parameters

        GroupObjectToBeConveted -- The DSNAME of the group object to be converted

    Return Values

        STATUS_SUCCESS
        STATUS_NOT_SUPPORTED
--*/
{
    NTSTATUS    NtStatus = STATUS_NOT_SUPPORTED;
    ATTRTYP     MemberType[] = {SAMP_GROUP_MEMBERS};
    ATTRVAL     MemberVal[] = {0,NULL};
    DEFINE_ATTRBLOCK1(MemberAttrBlock,MemberType,MemberVal);
    ATTRTYP     GroupTypeAttrs[]  = {SAMP_FIXED_GROUP_TYPE,
                                SAMP_FIXED_GROUP_OBJECTCLASS };
    ATTRVAL     GroupTypeVal[] = {{0,NULL},{0,NULL}};
    DEFINE_ATTRBLOCK2(GroupTypeAttrBlock,GroupTypeAttrs,GroupTypeVal);
    ATTRBLOCK    ReadMemberAttrBlock, ReadGroupAttrBlock;
    ULONG        memberCount;
    ULONG        i;



    // Get the membership list of the group
    //

    NtStatus = SampDsRead(
                GroupToBeConverted,
                0,
                SampGroupObjectType,
                &MemberAttrBlock,
                &ReadMemberAttrBlock
                );


    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
    {
        //
        // For the case of the empty group no further checks need
        // be enforced.
        //

        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    ASSERT(ReadMemberAttrBlock.pAttr[0].attrTyp == SAMP_GROUP_MEMBERS);
    ASSERT(ReadMemberAttrBlock.attrCount==1);
    ASSERT(ReadMemberAttrBlock.pAttr[0].AttrVal.valCount>0);

    memberCount = ReadMemberAttrBlock.pAttr[0].AttrVal.valCount;
    ASSERT(memberCount>=1);

    //
    // For each of the members in the membership list read the
    // group type and Object Class
    //

    for (i=0; (i<memberCount);i++)
    {
        DSNAME * MemberName;

        MemberName = (DSNAME *)ReadMemberAttrBlock.pAttr[0].AttrVal.pAVal[i].pVal;

        //
        // First do the SID check
        //

        if (MemberName->SidLen>0)
        {
            //
            // Member is a security principal, as the member has a SID. 
            // 

            if (!RtlEqualPrefixSid(&MemberName->Sid,&GroupToBeConverted->Sid))
            {
                //
                // Have a member from a different domain, cannot be converted
                //

                NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER;
                goto Error;
            }
        }
        else
        {
            //
            // Member has no SID, no need for further checks on this member
            //

            continue;
        }

        //
        // Read the group type attribute
        //

        NtStatus = SampDsRead(
                     MemberName,
                     0,
                     SampGroupObjectType,
                     &GroupTypeAttrBlock,
                     &ReadGroupAttrBlock
                    );

        if ((NT_SUCCESS(NtStatus))
            && (2==ReadGroupAttrBlock.attrCount))
        {

            ULONG            GroupType;
            ULONG            ObjectClass;
            NT4_GROUP_TYPE   Nt4GroupType;
            NT5_GROUP_TYPE   Nt5GroupType;
            BOOLEAN          SecurityEnabled;

            //
            // Assert that DS results are consistent with what we expect
            //

            ASSERT(ReadGroupAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_TYPE);
            ASSERT(ReadGroupAttrBlock.pAttr[1].attrTyp == SAMP_FIXED_GROUP_OBJECTCLASS);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.valCount==1);
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.valCount>=1);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].valLen==sizeof(ULONG));
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].valLen==sizeof(ULONG));

            GroupType =
                *((ULONG *) ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
            ObjectClass =
                *((ULONG *) ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

            //
            // Compute the type of the group
            //

            NtStatus = SampComputeGroupType(
                            ObjectClass,
                            GroupType,
                            &Nt4GroupType,
                            &Nt5GroupType,
                            &SecurityEnabled
                            );

            if (NT_SUCCESS(NtStatus))
            {
                if (NT5AccountGroup != Nt5GroupType)
                {

                    //
                    // Universal groups should only have other universal groups
                    // and global groups as members
                    //

                    ASSERT(NT5UniversalGroup==Nt5GroupType);

                    if (NT5UniversalGroup==Nt5GroupType)
                    {
                        NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER;
                    }
                    else if (NT5ResourceGroup == Nt5GroupType)
                    {
                        NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER;
                    }
                    else
                    {
                        NtStatus = STATUS_NOT_SUPPORTED;
                    }

                    break;
                }
            }
        }
        else
        {
            //
            // member is not a group, continue iterating over other members
            //

            NtStatus  = STATUS_SUCCESS;
        }
    } // End of For

Error:

    return NtStatus;

}

NTSTATUS
SampCheckUniversalToResourceConversion(
    DSNAME * GroupToBeConverted
    )
/*++

    Routine Description

        This routine Looks at the group's  is member of attribue and determines
        if the group can be converted from a Universal Group to an resource group.

        A resource group can be a member of only other resource groups in the same 
        domain

        A universal group can be a member of any universal / resource group anywhere

        For a universal group to be converted to a resource group, it is necessary
        to check that its a member of same domain resource groups only. Since the
        entire reverse membership is available only at a GC, this conversion can be
        performed only on a G.C


    Parameters

        GroupObjectToBeConveted -- The DSNAME of the group object to be converted

    Return Values

        STATUS_SUCCESS
        STATUS_NOT_SUPPORTED
--*/
{
    NTSTATUS    NtStatus = STATUS_NOT_SUPPORTED;
    ATTRTYP     MemberType[] = {SAMP_FIXED_GROUP_MEMBER_OF};
    ATTRVAL     MemberVal[] = {0,NULL};
    DEFINE_ATTRBLOCK1(MemberAttrBlock,MemberType,MemberVal);
    ATTRTYP     GroupTypeAttrs[]  = {SAMP_FIXED_GROUP_TYPE,
                                SAMP_FIXED_GROUP_OBJECTCLASS };
    ATTRVAL     GroupTypeVal[] = {{0,NULL},{0,NULL}};
    DEFINE_ATTRBLOCK2(GroupTypeAttrBlock,GroupTypeAttrs,GroupTypeVal);
    ATTRBLOCK    ReadMemberAttrBlock, ReadGroupAttrBlock;
    ULONG        memberCount;
    ULONG        i;



    //
    // Am I a GC ?
    //

    if (!SampAmIGC())
    {
        NtStatus = STATUS_DS_GC_REQUIRED;
        goto Error;
    }

    //
    // Get the membership list of the group
    //

    NtStatus = SampDsRead(
                GroupToBeConverted,
                0,
                SampGroupObjectType,
                &MemberAttrBlock,
                &ReadMemberAttrBlock
                );


    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
    {
        //
        // For the case of the empty reverse membership no further checks need
        // be enforced.
        //

        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    ASSERT(ReadMemberAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_MEMBER_OF);
    ASSERT(ReadMemberAttrBlock.attrCount==1);
    ASSERT(ReadMemberAttrBlock.pAttr[0].AttrVal.valCount>0);

    memberCount = ReadMemberAttrBlock.pAttr[0].AttrVal.valCount;
    ASSERT(memberCount>=1);

    //
    // For each of the members in the membership list read the
    // group type and Object Class
    //

    for (i=0; (i<memberCount);i++)
    {
        DSNAME * MemberName;

        MemberName = (DSNAME *)ReadMemberAttrBlock.pAttr[0].AttrVal.pAVal[i].pVal;

        //
        // First do the SID check
        //

        if (MemberName->SidLen>0)
        {
            //
            // Member is a security principal, as the member has a SID. 
            // 

            if (!RtlEqualPrefixSid(&MemberName->Sid,&GroupToBeConverted->Sid))
            {
                //
                // This group is a member of a  group in a different domain. 
                // A resource group can be a member of only resource groups in
                // the same domain. Therefore fail this call.
                //

                NtStatus = STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY;
                goto Error;
            }
        }
        else
        {
            //
            // Member has no SID, no need for further checks on this member
            //

            continue;
        }

        //
        // Read the group type attribute
        //

        NtStatus = SampDsRead(
                     MemberName,
                     0,
                     SampGroupObjectType,
                     &GroupTypeAttrBlock,
                     &ReadGroupAttrBlock
                    );

        if ((NT_SUCCESS(NtStatus))
            && (2==ReadGroupAttrBlock.attrCount))
        {

            ULONG            GroupType;
            ULONG            ObjectClass;
            NT4_GROUP_TYPE   Nt4GroupType;
            NT5_GROUP_TYPE   Nt5GroupType;
            BOOLEAN          SecurityEnabled;

            //
            // Assert that DS results are consistent with what we expect
            //

            ASSERT(ReadGroupAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_TYPE);
            ASSERT(ReadGroupAttrBlock.pAttr[1].attrTyp == SAMP_FIXED_GROUP_OBJECTCLASS);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.valCount==1);
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.valCount>=1);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].valLen==sizeof(ULONG));
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].valLen==sizeof(ULONG));

            GroupType =
                *((ULONG *) ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
            ObjectClass =
                *((ULONG *) ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

            //
            // Compute the type of the group
            //

            NtStatus = SampComputeGroupType(
                            ObjectClass,
                            GroupType,
                            &Nt4GroupType,
                            &Nt5GroupType,
                            &SecurityEnabled
                            );

            if (NT_SUCCESS(NtStatus))
            {
                //
                // This group is a member of something other than a resource
                // group in the same domain. Fail the call saying a resource
                // can be members of only other resource groups in the same
                // domain
                //
                if (NT5ResourceGroup != Nt5GroupType)
                {
                    NtStatus = STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY;
                    break;
                }
            }
        }
        else
        {
            //
            // member is not a group, continue iterating over other members
            //

            NtStatus  = STATUS_SUCCESS;
        }
    } // End of For

   



    

Error:

    return NtStatus;

}
NTSTATUS
SampCheckGroupTypeBits(
    IN BOOLEAN MixedDomain,
    IN ULONG   GroupType
    )
/*++
    Routine Description

    This routine checks whether the group type bits are
    really valid.

    Parameters:

    MixedDomain -- BOOLEAN indicating that the domain is in mixed mode
    GroupType   -- The grouptype that is being set.

    Return Values

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER

--*/
{

    //
    // One and only one group type bit can be set
    //

    switch(GroupType & (GROUP_TYPE_RESOURCE_GROUP|GROUP_TYPE_ACCOUNT_GROUP|GROUP_TYPE_UNIVERSAL_GROUP))
    {
    case GROUP_TYPE_RESOURCE_GROUP:
    case GROUP_TYPE_ACCOUNT_GROUP:
    case GROUP_TYPE_UNIVERSAL_GROUP:
        break;
    default:
        return (STATUS_DS_INVALID_GROUP_TYPE);
    }

    //
    // In Mixed domains dis-allow security enabled universal group creation
    //

    if ((GroupType & GROUP_TYPE_UNIVERSAL_GROUP) && (GroupType & GROUP_TYPE_SECURITY_ENABLED)
        && (MixedDomain))
    {
        return(STATUS_DS_INVALID_GROUP_TYPE);
    }

    //
    // Clients cannot set the BUILTIN_LOCAL_GROUP bit
    //

    if (GroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
    {
        return(STATUS_DS_INVALID_GROUP_TYPE);
    }

    return(STATUS_SUCCESS);
}




NTSTATUS
SampWriteGroupType(
    IN SAMPR_HANDLE GroupHandle,
    IN ULONG    GroupType,
    BOOLEAN     SkipChecks
    )
/*++

    Routine Description

        This routine first validates the group type and
        then writes it as part of the database for the group
        in question. It then updates the handle with the appropriate
        information. No action is taken on other open group Handles.
        In addition the sam account type property is changed such that
        groups that are not security enabled do not show up in any of
        the SAM enumeration or Display Information API. This is so that
        NT4 domain controllers do not recieve any information about
        non security enabled groups.

    Parameters:

        GroupHandle -- Handle to the Group ( or Local Group) in Question
        GroupType   -- Value of the Group Type property
        SkipChecks  -- Used by trusted callers to skip checks

    Return Values

        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/

{
    PSAMP_OBJECT GroupContext = (PSAMP_OBJECT) GroupHandle;
    NTSTATUS     NtStatus=STATUS_SUCCESS, IgnoreStatus;
    ULONG        SamAccountType;
    ATTRTYP      GroupTypeAttr[] = {SAMP_FIXED_GROUP_TYPE,
                                    SAMP_GROUP_ACCOUNT_TYPE};
    ATTRVAL      GroupTypeAttrVal[] = {
                                        {sizeof(ULONG), (UCHAR *)&GroupType},
                                        {sizeof(ULONG), (UCHAR *) &SamAccountType}
                                      };
    DEFINE_ATTRBLOCK2(GroupTypeAttrBlock,GroupTypeAttr,GroupTypeAttrVal);

    NT4_GROUP_TYPE NewNT4GroupType;
    NT5_GROUP_TYPE NewNT5GroupType;
    BOOLEAN        NewSecurityEnabled;
    NT4_GROUP_TYPE *OldNT4GroupType = NULL;
    NT5_GROUP_TYPE *OldNT5GroupType = NULL;
    BOOLEAN         *OldSecurityEnabled = NULL;
    BOOLEAN         fWriteLockAcquired = FALSE;
    BOOLEAN         fDeReferenceContext = FALSE;
    SAMP_OBJECT_TYPE ActualObjectType;
    ULONG             Rid;
    ULONG             PrimaryMemberCount=0;
    PULONG            PrimaryMembers=NULL;

    NtStatus = SampMaybeAcquireWriteLock(GroupContext, &fWriteLockAcquired);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    NtStatus = SampLookupContext(
                    GroupContext,
                    0,
                    SampGroupObjectType,
                    &ActualObjectType
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        NtStatus = SampLookupContext(
                      GroupContext,
                      0,
                      SampAliasObjectType,
                      &ActualObjectType
                      );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    fDeReferenceContext = TRUE;


    if (!IsDsObject(GroupContext))
    {
        //
        // We should be getting this call only in
        // DS Mode
        //

        ASSERT(FALSE && "DS Mode Required");
        NtStatus = STATUS_INTERNAL_ERROR;
        goto Error;
    }

    

    if (!SkipChecks)
    {
        //
        // Check for Valid Combinations of Group Type Bits
        //

        NtStatus = SampCheckGroupTypeBits(
                    DownLevelDomainControllersPresent(GroupContext->DomainIndex),
                    GroupType
                    );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }

    if (SampGroupObjectType==GroupContext->ObjectType)
    {
        OldNT4GroupType = &GroupContext->TypeBody.Group.NT4GroupType;
        OldNT5GroupType = &GroupContext->TypeBody.Group.NT5GroupType;
        OldSecurityEnabled = &GroupContext->TypeBody.Group.SecurityEnabled;
        Rid = GroupContext->TypeBody.Group.Rid;
    }
    else
    {
        OldNT4GroupType = &GroupContext->TypeBody.Alias.NT4GroupType;
        OldNT5GroupType = &GroupContext->TypeBody.Alias.NT5GroupType;
        OldSecurityEnabled = &GroupContext->TypeBody.Alias.SecurityEnabled;
        Rid = GroupContext->TypeBody.Alias.Rid;
    }


    NtStatus = SampComputeGroupType(
                GroupContext->DsClassId,
                GroupType,
                &NewNT4GroupType,
                &NewNT5GroupType,
                &NewSecurityEnabled
                );

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    if (!SkipChecks)
    {
        //
        // Cannot do anything in a mixed domain environment
        //

        if (DownLevelDomainControllersPresent(GroupContext->DomainIndex))
        {

            //
            // Mixed domain case cannot do anything
            //

            if ((*OldSecurityEnabled!=NewSecurityEnabled)
                || (*OldNT4GroupType!=NewNT4GroupType)
                || (*OldNT5GroupType!=NewNT5GroupType))
            {
                NtStatus = STATUS_DS_INVALID_GROUP_TYPE;
                goto Error;
            }
        }
        else
        {

            //
            // Check if some changes are attempted
            //

            if ((*OldSecurityEnabled!=NewSecurityEnabled)
                || (*OldNT4GroupType!=NewNT4GroupType)
                || (*OldNT5GroupType!=NewNT5GroupType))
            {

                //
                // If changes are attempted then
                // Check to see that it is not a builtin account
                // If the caller is a trusted client then he is granted 
                // the privilege of modifying even builtin groups
                // 
                // Allow the cert admins group to be converted 
                // as this may be required in upgrade cases -- the cert
                // group goofed their initial choice of group -- chose a
                // global instead of a domain local and hence we require this
                // change
                //

                if ((!GroupContext->TrustedClient) && (Rid!=DOMAIN_GROUP_RID_CERT_ADMINS))
                {

                    NtStatus = SampIsAccountBuiltIn(Rid);
                    if (!NT_SUCCESS(NtStatus))
                    {
                        goto Error;
                    }
                }

                //
                // If we are going from a Security Enabled to a
                // Security Disabled Group, check that we have no
                // primary members
                //

                if ((*OldSecurityEnabled)
                     && (!NewSecurityEnabled))
                {
                    NtStatus = SampDsGetPrimaryGroupMembers(
                                    DomainObjectFromAccountContext(GroupContext),
                                    Rid,
                                    &PrimaryMemberCount,
                                    &PrimaryMembers
                                    );

                    if (!NT_SUCCESS(NtStatus))
                        goto Error;

                    if (PrimaryMemberCount>0)
                    {
                    
                        NtStatus = STATUS_DS_HAVE_PRIMARY_MEMBERS;
                        goto Error;
                    }
                }
                //
                // Changing Security Enabled is always a legal change
                // Check wether the NT5GroupType changes and whether
                // the change is legal. The NT4GroupType will always
                // depend upon the NT5GroupType, and therefore verifying
                // NT5 GroupType should be sufficient
                //

                if (*OldNT5GroupType!=NewNT5GroupType)
                {
                    if ((*OldNT5GroupType == NT5AccountGroup)
                        && (NewNT5GroupType == NT5UniversalGroup))
                    {
                        //
                        // Account==> Universal;
                        // Need to check the membership lists
                        //

                        NtStatus = SampCheckAccountToUniversalConversion(
                                   GroupContext->ObjectNameInDs
                                   );

                        if (!NT_SUCCESS(NtStatus))
                            goto Error;
                    }
                    else if ((*OldNT5GroupType == NT5ResourceGroup)
                        && (NewNT5GroupType == NT5UniversalGroup))
                    {
                        //
                        // Resource ==> Universal;
                        // Need to check the membership lists
                        //

                        NtStatus = SampCheckResourceToUniversalConversion(
                                        GroupContext->ObjectNameInDs
                                        );

                        if (!NT_SUCCESS(NtStatus))
                            goto Error;
                    }
                    else if  ((*OldNT5GroupType == NT5UniversalGroup)
                        && (NewNT5GroupType == NT5AccountGroup))
                    {
                        //
                        // Universal = > account
                        // Need to check the membership list to see
                        // if there are any cross domain members
                        //

                        NtStatus = SampCheckUniversalToAccountConversion(
                                        GroupContext->ObjectNameInDs
                                        );
                        if (!NT_SUCCESS(NtStatus))
                            goto Error;
                    }
                    else if  ((*OldNT5GroupType == NT5UniversalGroup)
                        && (NewNT5GroupType == NT5ResourceGroup))
                    {
                        NtStatus = SampCheckUniversalToResourceConversion(
                                        GroupContext->ObjectNameInDs
                                        );
                        if (!NT_SUCCESS(NtStatus))
                            goto Error;
                    }
                    else
                    {
                        NtStatus = STATUS_NOT_SUPPORTED;
                        goto Error;
                    }
                }
            }
        }
    }

    //
    // Set the correct Sam account type, to match the security enabl'd
    // ness and local'group ness of the object
    //

    if (NewSecurityEnabled && (NewNT4GroupType==NT4LocalGroup))
    {
        SamAccountType = SAM_ALIAS_OBJECT;
    }
    else if (!NewSecurityEnabled && (NewNT4GroupType==NT4LocalGroup))
    {
        SamAccountType = SAM_NON_SECURITY_ALIAS_OBJECT;
    }
    else if (NewSecurityEnabled && (NewNT4GroupType==NT4GlobalGroup))
    {
        SamAccountType = SAM_GROUP_OBJECT;
    }
    else
    {
        SamAccountType = SAM_NON_SECURITY_GROUP_OBJECT;
    }


    NtStatus = SampDsSetAttributes(
                    GroupContext->ObjectNameInDs,
                    0,
                    REPLACE_ATT,
                    SampGroupObjectType,
                    &GroupTypeAttrBlock
                    );


Error:

    if ( (NT_SUCCESS(NtStatus)) && 
         (SampDoAccountAuditing(GroupContext->DomainIndex)) &&
         ((NULL != OldSecurityEnabled) && (NULL != OldNT5GroupType)) &&  
         ((*OldSecurityEnabled != NewSecurityEnabled) ||
                   (*OldNT5GroupType != NewNT5GroupType)) 
       )
    {
        SampAuditGroupTypeChange(GroupContext, 
                                 *OldSecurityEnabled, 
                                 NewSecurityEnabled, 
                                 *OldNT5GroupType, 
                                 NewNT5GroupType
                                 );
    }


    if (fDeReferenceContext)
    {
        if (NT_SUCCESS(NtStatus))
            IgnoreStatus = SampDeReferenceContext(GroupContext,TRUE);
        else
            IgnoreStatus = SampDeReferenceContext(GroupContext,FALSE);
    }
    ASSERT(NT_SUCCESS(IgnoreStatus));


    IgnoreStatus = SampMaybeReleaseWriteLock(fWriteLockAcquired, FALSE);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    // cleanup

    if (NULL!=PrimaryMembers)
    {
        MIDL_user_free(PrimaryMembers);
        PrimaryMembers = NULL;
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\notify.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    This file contains services which load notification packages and call
    them when passwords are changed using the SamChangePasswordUser2 API.


Author:

    Mike Swift      (MikeSw)    30-December-1994

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <nlrepl.h>
#include <dbgutilp.h>
#include <attids.h>
#include <dslayer.h>
#include <sddl.h> 
#include "notify.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private prototypes                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampConfigurePackage(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SampPasswordChangeNotifyWorker(
    IN ULONG Flags,
    IN PUNICODE_STRING UserName,
    IN ULONG RelativeId,
    IN PUNICODE_STRING NewPassword
    );

NTSTATUS
SampSetPasswordInfoOnPdcWorker(
    IN SAMPR_HANDLE SamDomainHandle,
    IN PSAMI_PASSWORD_INFO PasswordInfo,
    IN ULONG BufferLength
    );

NTSTATUS
SampResetBadPwdCountOnPdcWorker(
    IN SAMPR_HANDLE SamDomainHandle,
    IN PSAMI_BAD_PWD_COUNT_INFO BadPwdCountInfo
    );

NTSTATUS
SampPrivatePasswordUpdate(
    IN SAMPR_HANDLE     SamDomainHandle,
    IN ULONG            Flags,
    IN ULONG            AccountRid,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN BOOLEAN          PasswordExpired
    );


NTSTATUS
SampIncreaseBadPwdCountLoopback(
    IN PUNICODE_STRING  UserName
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service data and types                                            //
// move typedef SAMP_NOTIFICATION_PACKAGE to notify.h
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



PSAMP_NOTIFICATION_PACKAGE SampNotificationPackages = NULL;

RTL_QUERY_REGISTRY_TABLE SampRegistryConfigTable [] = {
    {SampConfigurePackage, 0, L"Notification Packages",
        NULL, REG_NONE, NULL, 0},
    {NULL, 0, NULL,
        NULL, REG_NONE, NULL, 0}
    };


typedef enum
{
    SampNotifyPasswordChange = 0,
    SampIncreaseBadPasswordCount,
    SampDeleteAccountNameTableElement,
    SampGenerateLoopbackAudit

} SAMP_LOOPBACK_TASK_TYPE;

typedef struct
{
    ULONG           Flags;
    UNICODE_STRING  UserName;
    ULONG           RelativeId;
    UNICODE_STRING  NewPassword;

} SAMP_PASSWORD_CHANGE_INFO, *PSAMP_PASSWORD_CHANGE_INFO;

typedef struct
{
    UNICODE_STRING  UserName;
} SAMP_BAD_PASSWORD_COUNT_INFO, *PSAMP_BAD_PASSWORD_COUNT_INFO;

typedef struct
{
    UNICODE_STRING  AccountName;
    SAMP_OBJECT_TYPE    ObjectType;
} SAMP_ACCOUNT_INFO, *PSAMP_ACCOUNT_INFO;

typedef struct
{
    NTSTATUS             NtStatus;      // Event Type
    ULONG                AuditId;       // Audit ID
    PSID                 DomainSid;     // Domain SID
    PUNICODE_STRING      AdditionalInfo;// Additional Info
    PULONG               MemberRid;     // Member Rid
    PSID                 MemberSid;     // Member Sid
    PUNICODE_STRING      AccountName;   // Account Name
    PUNICODE_STRING      DomainName;    // Domain Name
    PULONG               AccountRid;    // Account Rid  
    PPRIVILEGE_SET       Privileges;    // Privilege

} SAMP_AUDIT_INFO, *PSAMP_AUDIT_INFO;


typedef struct
{
    SAMP_LOOPBACK_TASK_TYPE  Type;

    BOOLEAN fCommit:1;

    union
    {
        SAMP_PASSWORD_CHANGE_INFO       PasswordChange;
        SAMP_BAD_PASSWORD_COUNT_INFO    BadPasswordCount;
        SAMP_ACCOUNT_INFO               Account;
        SAMP_AUDIT_INFO                 AuditInfo;

    } NotifyInfo;

} SAMP_LOOPBACK_TASK_ITEM, *PSAMP_LOOPBACK_TASK_ITEM;


VOID
SampFreeLoopbackAuditInfo(
    PSAMP_AUDIT_INFO    AuditInfo
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampConfigurePackage(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    This routine loads a notification package by loading its DLL and getting
    the address of the notification routine.

Arguments:
    ValueName - Contains the name of the registry value, ignored.
    ValueType - Contains type of Value, must be REG_SZ.
    ValueData - Contains the package name null-terminated string.
    ValueLength - Length of package name and null terminator, in bytes.
    Context - Passed from caller of RtlQueryRegistryValues, ignored
    EntryContext - Ignored



Return Value:

--*/
{
    UNICODE_STRING PackageName;
    STRING NotificationRoutineName;
    PSAMP_NOTIFICATION_PACKAGE NewPackage = NULL;
    PVOID ModuleHandle = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG PackageSize;
    PSAM_INIT_NOTIFICATION_ROUTINE InitNotificationRoutine = NULL;
    PSAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE CredentialRegisterRoutine = NULL;
    UNICODE_STRING CredentialName;
    SAMTRACE("SampConfigurePackage");

    RtlInitUnicodeString(&CredentialName, NULL);

    //
    // Make sure we got a string.
    //

    if (ValueType != REG_SZ) {
        return(STATUS_SUCCESS);
    }

    //
    // Build the package name from the value data.
    //

    PackageName.Buffer = (LPWSTR) ValueData;
    PackageName.Length = (USHORT) (ValueLength - sizeof( UNICODE_NULL ));
    PackageName.MaximumLength = (USHORT) ValueLength;

    //
    // Build the package structure.
    //

    PackageSize = sizeof(SAMP_NOTIFICATION_PACKAGE) + ValueLength;
    NewPackage = (PSAMP_NOTIFICATION_PACKAGE) RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                0,
                                                PackageSize
                                                );
    if (NewPackage == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(
        NewPackage,
        PackageSize
        );

    //
    // Copy in the package name.
    //

    NewPackage->PackageName = PackageName;

    NewPackage->PackageName.Buffer = (LPWSTR) (NewPackage + 1);


        RtlCopyUnicodeString(
            &NewPackage->PackageName,
            &PackageName
            );

    //
    // Load the notification library.
    //

    NtStatus = LdrLoadDll(
                NULL,
                NULL,
                &PackageName,
                &ModuleHandle
                );


    if (NT_SUCCESS(NtStatus)) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_INIT_NOTIFICATION_ROUTINE
            );

        NtStatus = LdrGetProcedureAddress(
                        ModuleHandle,
                        &NotificationRoutineName,
                        0,
                        (PVOID *) &InitNotificationRoutine
                        );
        if (NT_SUCCESS(NtStatus)) {
            ASSERT(InitNotificationRoutine != NULL);

            //
            // Call the init routine. If it returns false, unload this
            // DLL and continue on.
            //

            if (!InitNotificationRoutine()) {
                NtStatus = STATUS_INTERNAL_ERROR;
            }

        } else {
            //
            // This call isn't required, so reset the status to
            // STATUS_SUCCESS.
            //

            NtStatus = STATUS_SUCCESS;
        }

    }



    //
    // Get the Password Notification Routine
    //

    if (NT_SUCCESS(NtStatus)) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_PASSWORD_CHANGE_NOTIFY_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->PasswordNotificationRoutine
                    );

    }

    //
    // Get the Delta Change Notification Routine
    //

    if (NT_SUCCESS(NtStatus)) {
        RtlInitString(
            &NotificationRoutineName,
            SAM_DELTA_NOTIFY_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->DeltaNotificationRoutine
                    );
    }

    //
    // Get the Password Filter Routine
    //

    if (NT_SUCCESS(NtStatus)) {
        RtlInitString(
            &NotificationRoutineName,
            SAM_PASSWORD_FILTER_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->PasswordFilterRoutine
                    );
    }

    //
    // Get the UserParms Convert Notification Routine
    //     and UserParms Attribute Block Free Routine
    //

    if (NT_SUCCESS(NtStatus)) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_USERPARMS_CONVERT_NOTIFICATION_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->UserParmsConvertNotificationRoutine
                    );

        RtlInitString(
            &NotificationRoutineName,
            SAM_USERPARMS_ATTRBLOCK_FREE_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->UserParmsAttrBlockFreeRoutine
                    );

    }

    //
    // See if it supports the Credential Update Notify registration
    //
    if (NT_SUCCESS(NtStatus)) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE
            );

        NtStatus = LdrGetProcedureAddress(
                        ModuleHandle,
                        &NotificationRoutineName,
                        0,
                        (PVOID *) &CredentialRegisterRoutine
                        );
        if (NT_SUCCESS(NtStatus)) {

            BOOLEAN fStatus;
            ASSERT(CredentialRegisterRoutine != NULL);

            //
            // Call the init routine. If it returns false, unload this
            // DLL and continue on.
            //
            fStatus = CredentialRegisterRoutine(&CredentialName);

            if (!fStatus) {
                NtStatus = STATUS_INTERNAL_ERROR;
            }

        } else {
            //
            // This call isn't required, so reset the status to
            // STATUS_SUCCESS.
            //

            NtStatus = STATUS_SUCCESS;
        }
    }

    //
    // Get the Credential Update routine
    //

    if ( NT_SUCCESS(NtStatus) 
     && CredentialRegisterRoutine ) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->CredentialUpdateNotifyRoutine
                    );
    }

    if ( NT_SUCCESS(NtStatus) 
     && CredentialRegisterRoutine ) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_CREDENTIAL_UPDATE_FREE_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->CredentialUpdateFreeRoutine
                    );
    }

    if (NewPackage->CredentialUpdateNotifyRoutine) {

        //
        // There should be a CredentialName and a Free routine
        //
        if (   (NULL == CredentialName.Buffer)
            || (0 == CredentialName.Length) 
            || (NULL == NewPackage->CredentialUpdateFreeRoutine)) {
            NtStatus = STATUS_INTERNAL_ERROR;
        }


        if (NT_SUCCESS(NtStatus)) {
            NewPackage->Parameters.CredentialUpdateNotify.CredentialName = CredentialName;
        }
    }


    //
    //  At least one of the 4 functions must be present
    //  also we require the UserParmsConvertNotificationRoutine
    //  and UserParmsAttrBlockFreeRoutine must be present together.
    //

    if ((NewPackage->PasswordNotificationRoutine == NULL) &&
        (NewPackage->DeltaNotificationRoutine == NULL) &&
        (NewPackage->CredentialUpdateNotifyRoutine == NULL) &&
        (NewPackage->PasswordFilterRoutine == NULL) &&
        ((NewPackage->UserParmsConvertNotificationRoutine == NULL) ||
         (NewPackage->UserParmsAttrBlockFreeRoutine == NULL))
       )
    {

        NtStatus = STATUS_INTERNAL_ERROR;
    }

    //
    // If all this succeeded, add the routine to the global list.
    //


    if (NT_SUCCESS(NtStatus)) {


        NewPackage->Next = SampNotificationPackages;
        SampNotificationPackages = NewPackage;

        //
        // Notify the auditing code to record this event.
        //

        LsaIAuditNotifyPackageLoad(
            &PackageName
            );


    } else {

        //
        // Otherwise delete the entry.
        //

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            NewPackage
            );

        if (ModuleHandle != NULL) {
            (VOID) LdrUnloadDll( ModuleHandle );
        }
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
SampLoadNotificationPackages(
    )
/*++

Routine Description:

    This routine retrieves the list of packages to be notified during
    password change.

Arguments:

    none


Return Value:

--*/
{
    NTSTATUS NtStatus;

    SAMTRACE("SampLoadNotificationPackages");

    NtStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_CONTROL,
                L"Lsa",
                SampRegistryConfigTable,
                NULL,   // no context
                NULL    // no enviroment
                );
    //
    // Always return STATUS_SUCCESS so we don't block the system from
    // booting.
    //


    return(STATUS_SUCCESS);
}

NTSTATUS
SamISetPasswordInfoOnPdc(
    IN SAMPR_HANDLE SamDomainHandle,
    IN LPBYTE OpaqueBuffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    When an account changes its password on a BDC, the password change is
    propagated to the PDC as quickly as possible, via NetLogon. NetLogon
    calls this routine in order to change the password on the PDC.

    This routine unbundles the opaque buffer from NetLogon, on the PDC, and
    sets the SAM password information accordingly.

Arguments:

    SamHandle - Handle, an open and valid SAM context block.

    OpaqueBuffer - Pointer, password-change information from the BDC.

    BufferLength - Length of the buffer in bytes.

Return Value:

    STATUS_SUCCESS if the password was successfully sent to the PDC, else
        error codes from SamrSetInformationUser.

    STATUS_UNKNOWN_REVISION: this server doesn't understand the blob that
    was send to us

    STATUS_REVISION_MISMATCH: this server understands the blob but not
    the revision of the particular blob


--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMI_SECURE_CHANNEL_BLOB SecureChannelBlob = NULL;

    //
    // Sanity check some parameters
    //
    if ((NULL == SamDomainHandle) ||
        (NULL == OpaqueBuffer) ||
        (0 == BufferLength))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    SecureChannelBlob = (PSAMI_SECURE_CHANNEL_BLOB)OpaqueBuffer;

    //
    // See what message is being passed to us
    //
    switch ( SecureChannelBlob->Type )
    {
        case SamPdcPasswordNotification:

            NtStatus =  SampSetPasswordInfoOnPdcWorker( SamDomainHandle,
                                                        (PSAMI_PASSWORD_INFO) SecureChannelBlob->Data,
                                                        SecureChannelBlob->DataSize );

            break;

        case SamPdcResetBadPasswordCount:

            NtStatus = SampResetBadPwdCountOnPdcWorker( SamDomainHandle,
                                                        (PSAMI_BAD_PWD_COUNT_INFO) SecureChannelBlob->Data
                                                        );

            break;

        default:

            NtStatus = STATUS_UNKNOWN_REVISION;

            break;
    }

    return NtStatus;

}


NTSTATUS
SamIResetBadPwdCountOnPdc(
    IN SAMPR_HANDLE SamUserHandle
    )
/*++
Routine Description: 

    When a client successfully logon on a BDC, and if the previous bad
    password count of this account is not zero (mistakenly type the 
    wrong password, etc), authentication package will need to reset
    the bad password count to 0 on both BDC and PDC.

    In Windows 2000, NTLM and Kerberos reset the bad password count 
    to zero on PDC by forwarding the authentication to PDC, which 
    is expensive. To eliminate the extra authentication, we will send 
    a bad password count reset operation request to PDC directly, 
    through Net Logon Secure Channel. On the PDC side, once NetLogon 
    receives this request, it will let SAM modify bad password count to 
    zero on this particular account.


Parameter:

    SamUserHandle - Handle to the SAM User Account

Return Value:

    NTSTATUS Code
    STATUS_UNKNONW_REVISION - PDC is still running Windows 2000

    Caller can choose to ignore the return code, but they need to 
    deal with STATUS_UNKNOWN_REVISION and switch to the old behavior.

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    PSAMP_OBJECT    UserContext = NULL;
    NT_PRODUCT_TYPE NtProductType = 0;
    ULONG           TotalSize;
    PSAMI_BAD_PWD_COUNT_INFO    BadPwdCountInfo;
    PSAMI_SECURE_CHANNEL_BLOB   SecureChannelBlob = NULL;

    //
    // Check parameter
    // 
    if (NULL == SamUserHandle)
    {
        ASSERT(FALSE && "Invalid SAM Handle\n");
        goto Error;
    }
    UserContext = (PSAMP_OBJECT) SamUserHandle;



    // 
    // Only allow this call to be made from a BDC to the PDC.
    // 

    RtlGetNtProductType(&NtProductType);

    if ( (!IsDsObject(UserContext)) ||
         (NtProductLanManNt != NtProductType) || 
         (DomainServerRoleBackup != SampDefinedDomains[DOMAIN_START_DS + 1].ServerRole) )
    {
        // if this isn't a BDC,  there's nothing to do here. fail silently.
        NtStatus = STATUS_SUCCESS;
        goto Error;
    }
    

    //
    // prepare the secure channel blob 
    // 

    TotalSize = sizeof(SAMI_SECURE_CHANNEL_BLOB) +      // size of the header 
                sizeof(SAMI_BAD_PWD_COUNT_INFO) -       // size of the real data
                sizeof(DWORD);                          // minus the first dword taken by the Data[0]

    SecureChannelBlob = MIDL_user_allocate( TotalSize );

    if (NULL == SecureChannelBlob)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    memset(SecureChannelBlob, 0, TotalSize);

    SecureChannelBlob->Type = SamPdcResetBadPasswordCount;
    SecureChannelBlob->DataSize = sizeof(SAMI_BAD_PWD_COUNT_INFO);

    BadPwdCountInfo = (PSAMI_BAD_PWD_COUNT_INFO) &SecureChannelBlob->Data[0];
    BadPwdCountInfo->ObjectGuid = UserContext->ObjectNameInDs->Guid;

    //
    // Send the bad password count reset request to PDC. This routine is 
    // synchronous and may take a few minutes, in the worst case, to return.
    // Caller might choose to ignore the error code, because the PDC may 
    // not be available, or the account may not yet exist on the PDC due
    // to replicataion latency, etc. But Failure like STATUS_UNKNOWN_REVISION
    // should be taken cared of by caller, thus that caller can switch 
    // to the old behavior.
    // 

    NtStatus = I_NetLogonSendToSamOnPdc(NULL, 
                                        (PUCHAR)SecureChannelBlob, 
                                        TotalSize
                                        );


    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                   "UserId:0x%x sending BadPasswordCount reset to PDC (status 0x%x)\n",
                   UserContext->TypeBody.User.Rid,
                   NtStatus));
Error:

    if (SecureChannelBlob) {
        MIDL_user_free( SecureChannelBlob );
    }

    return( NtStatus );
}


NTSTATUS
SampResetBadPwdCountOnPdcWorker(
    IN SAMPR_HANDLE SamDomainHandle,
    IN PSAMI_BAD_PWD_COUNT_INFO BadPwdCountInfo
    )
/*++
Routine Description:

    This is the worker routine to set account bad password count to zero
    on PDC. 

    It does it by starting a DS transaction, modifying bad password
    count to zero on the DS object.
    
Parameters:

    SamDomainHandle - SAM Domain Handle, igonred by this routine.
    
    BadPwdCountInfo - Indicate which account (by object GUID)

Return Value:

    NTSTATUS Code

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    MODIFYARG       ModArg;
    MODIFYRES       *pModRes = NULL;
    COMMARG         *pCommArg = NULL;
    ULONG           RetCode;
    ULONG           BadPasswordCount = 0;
    ATTR            Attr;
    ATTRVAL         AttrVal;
    ATTRVALBLOCK    AttrValBlock;
    DSNAME          ObjectDsName;

    if (NULL == BadPwdCountInfo)
    {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // begin a new DS transaction
    // 

    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);

    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    //
    // get the object GUID and prepare DSName
    // 
    memset( &ObjectDsName, 0, sizeof(ObjectDsName) );
    ObjectDsName.structLen = DSNameSizeFromLen( 0 ); 
    ObjectDsName.Guid = BadPwdCountInfo->ObjectGuid; 

    //
    // prepare modify arg
    // 
    memset( &ModArg, 0, sizeof(ModArg) );
    ModArg.pObject = &ObjectDsName;

    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = sizeof(ULONG);
    AttrVal.pVal = (PUCHAR) &BadPasswordCount;

    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;

    Attr.attrTyp = ATT_BAD_PWD_COUNT;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    pCommArg = &(ModArg.CommArg);
    
    BuildStdCommArg(pCommArg);

    //
    // using lazy commit
    // 
    pCommArg->fLazyCommit = TRUE;


    //
    // this request is coming from subauth packages, they are trusted clients
    // 
    SampSetDsa( TRUE );

    //
    // call into DS routine
    // 
    RetCode = DirModifyEntry(&ModArg, &pModRes);

    if (NULL == pModRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
    }

    //
    // end the DS transaction 
    // 
    NtStatus = SampMaybeEndDsTransaction(NT_SUCCESS(NtStatus) ? 
                                         TransactionCommit:TransactionAbort
                                         );

    {
        //
        // Log that the Bad Password Count has been zero'ed
        // 
        LPSTR UserString = NULL;
        LPSTR UnknownUser = "Unknown";
        BOOL  fLocalFree = FALSE;
        if (  (ModArg.pObject->SidLen > 0)
           && ConvertSidToStringSidA(&ModArg.pObject->Sid, &UserString) ) {
            fLocalFree = TRUE;
        } else {
            UuidToStringA(&ModArg.pObject->Guid, &UserString);
        }
        if (UserString == NULL) {
            UserString = UnknownUser;
        }

        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                       "UserId: %s  BadPasswordCount reset to 0 (status : 0x%x)\n",
                       UserString, NtStatus));

        if (UserString != UnknownUser) {
            if (fLocalFree) {
                LocalFree(UserString);
            } else {
                RpcStringFreeA(&UserString);
            }
        }
    }

    return( NtStatus );
}




NTSTATUS
SampSetPasswordInfoOnPdcWorker(
    IN SAMPR_HANDLE SamDomainHandle,
    IN PSAMI_PASSWORD_INFO PasswordInfo,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    When an account changes its password on a BDC, the password change is
    propagated to the PDC as quickly as possible, via NetLogon. NetLogon
    calls this routine in order to change the password on the PDC.

    This routine unbundles the opaque buffer from NetLogon, on the PDC, and
    sets the SAM password information accordingly.

Arguments:

    SamHandle - Handle, an open and valid SAM context block.

    PasswordInfo - Pointer, password-change information from the BDC.

    BufferLength - Length of the buffer in bytes.

Return Value:

    STATUS_SUCCESS if the password was successfully sent to the PDC, else
        error codes from SamrSetInformationUser.

    STATUS_REVISION_MISMATCH - not enough fields were present for us to
                               make sense of

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG Index = 0;
    USHORT Offset = 0;
    USHORT Length = 0;
    PLM_OWF_PASSWORD LmOwfPassword;
    PNT_OWF_PASSWORD NtOwfPassword;
    ACCESS_MASK DesiredAccess = USER_WRITE_ACCOUNT | USER_CHANGE_PASSWORD;
    SAMPR_HANDLE UserHandle=NULL;
    ULONG Flags = 0;
    PSAMI_PASSWORD_INDEX PasswordIndex = NULL;
    UCHAR *DataStart = NULL;

    if ((NULL == SamDomainHandle) ||
        (NULL == PasswordInfo) ||
        (0 == BufferLength))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    Flags = PasswordInfo->Flags;

    if ( 0 == Flags )
    {
        // Boundary case; the caller did not send any info!
        return STATUS_SUCCESS;
    }

    if ((Flags & SAM_VALID_PDC_PUSH_FLAGS) != Flags) {
        //
        // The caller is requesting something we can't support
        //
        return STATUS_REVISION_MISMATCH;
    }

    //
    // We have enough information to set the password
    //
    
    PasswordIndex = (PSAMI_PASSWORD_INDEX) &PasswordInfo->DataIndex[0];
    DataStart = ((UCHAR*)PasswordInfo) + PasswordInfo->Size;
    
    //
    // Setup the LM OWF password.
    //
    Index = SampPositionOfHighestBit( SAM_LM_OWF_PRESENT ) - 1;
    Length = (USHORT)(PasswordIndex[Index].Length);
    Offset = (USHORT)(PasswordIndex[Index].Offset);
    LmOwfPassword = (PLM_OWF_PASSWORD)(DataStart + Offset);
    
    //
    // Setup the NT OWF password.
    //
    Index = SampPositionOfHighestBit( SAM_NT_OWF_PRESENT ) - 1;
    Length = (USHORT)(PasswordIndex[Index].Length);
    Offset = (USHORT)(PasswordIndex[Index].Offset);
    NtOwfPassword = (PNT_OWF_PASSWORD)(DataStart + Offset);
    
    NtStatus = SampPrivatePasswordUpdate( SamDomainHandle,
                                          Flags,
                                          PasswordInfo->AccountRid,
                                          LmOwfPassword,
                                          NtOwfPassword,
                                          PasswordInfo->PasswordExpired);


    SampDiagPrint( DISPLAY_LOCKOUT,
                 ( "SAMSS: PDC password notify for rid %d, status: 0x%x\n",
                 PasswordInfo->AccountRid,
                 NtStatus ));


    return(NtStatus);
}

NTSTATUS
SampPasswordChangeNotifyPdc(
    IN ULONG Flags,
    IN PUNICODE_STRING UserName,
    IN ULONG RelativeId,
    IN PUNICODE_STRING NewPassword
    )

/*++

Routine Description:

    This routine forwards password modifications from a BDC to the domain PDC
    so that the PDC's notion of the account password is synchronized with the
    recent change. The user name, account ID, clear-text password, LM and NT
    OWF passwords are sent to the PDC via NetLogon.

Arguments:

    UserName - Pointer, SAM account name.

    RelativeId - SAM account identifier.

    NewPassword - Pointer, clear-text password, from which LM and NT OWF pass-
        words are calculated.

Return Value:

    STATUS_SUCCESS if the password was successfully sent to the PDC, else
        error codes from SampCalculateLmAndNtOwfPasswords or NetLogon.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    ULONG NameBufferLength = 0;                     // Aligned buffer length
    ULONG NameLength = UserName->Length;            // Actual data length

    ULONG BufferLength = 0;                         // Aligned buffer length
    ULONG DataLength = 0;                           // Actual data length

    ULONG LmBufferLength = 0;                       // Aligned buffer length
    ULONG LmDataLength = sizeof(LM_OWF_PASSWORD);   // Actual data length

    ULONG NtBufferLength = 0;                       // Aligned buffer length
    ULONG NtDataLength = sizeof(NT_OWF_PASSWORD);   // Actual data length

    ULONG PasswordHeaderSize = 0;
    ULONG BlobHeaderSize = 0;
    ULONG TotalSize = 0;
    PSAMI_PASSWORD_INDEX PasswordIndex = 0;
    ULONG DataSize = 0;

    ULONG CurrentOffset = 0;
    ULONG ElementCount = 0;
    ULONG Index = 0;

    ULONG Where = 0;

    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;

    PSAMI_SECURE_CHANNEL_BLOB SecureChannelBlob = NULL;
    PSAMI_PASSWORD_INFO PasswordInfo = NULL;
    PBYTE DataPtr = NULL, DataStart = NULL;

    BOOLEAN LmPasswordPresent = FALSE;


    // This is bogus, but SAM calls itself passing a NULL UNICODE_STRING arg
    // from SamrChangePasswordUser, instead of passing the clear-text pwd or
    // a valid UNICODE_STRING with zero length. Just return an error in this
    // case as the NULL is meaningless for purposes of notification.
    //
    // Also return an error if the new-password buffer happens to be NULL, so
    // that it is not referenced below in RtlCopyMemory.
    if ( (Flags & SAM_NT_OWF_PRESENT) 
      && (!NewPassword || !NewPassword->Buffer) )
    {
        return STATUS_SUCCESS;
    }

    if ( 0 == Flags )
    {
        return STATUS_SUCCESS;
    }

    //
    // Get the name length
    //
    ASSERT( UserName );
    NameLength = UserName->Length;

    if (Flags & SAM_NT_OWF_PRESENT) {

        // Calculate the Lanman and NT one-way function (LmOwf, NtOwf) passwords
        // from the clear-text password.
        RtlZeroMemory(&LmOwfPassword, LmDataLength);
        RtlZeroMemory(&NtOwfPassword, NtDataLength);
    
        NtStatus = SampCalculateLmAndNtOwfPasswords(NewPassword,
                                                    &LmPasswordPresent,
                                                    &LmOwfPassword,
                                                    &NtOwfPassword);
        if ( !NT_SUCCESS( NtStatus ) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampCalculateLmAndNtOwfPasswords status = 0x%lx\n",
                       NtStatus));
    
            goto Exit;
        }
    } else {

        //
        // No passwords to send
        //
        LmDataLength = 0;
        NtDataLength = 0;
    }
    
    //
    // Get the aligned sizes
    //
    NameBufferLength = SampDwordAlignUlong(NameLength);
    LmBufferLength   = SampDwordAlignUlong(LmDataLength);
    NtBufferLength   = SampDwordAlignUlong(NtDataLength);

    //
    // Calculate the size of the entire buffer
    //

    // The secure channel blob
    BlobHeaderSize = sizeof( SAMI_SECURE_CHANNEL_BLOB );

    // The header info for the password
    ElementCount = SampPositionOfHighestBit( Flags );
    ASSERT( ElementCount > 0 );

    //
    // N.B. ElementCount-1 is used since SAMI_PASSWORD_INFO already has
    // one SAMI_PASSWORD_INDEX
    //
    PasswordHeaderSize = sizeof( SAMI_PASSWORD_INFO )
                      + (sizeof( SAMI_PASSWORD_INDEX ) * (ElementCount-1));

    // The data of the password change
    DataSize = 0;
    DataSize += NameBufferLength;
    DataSize += LmBufferLength;
    DataSize += NtBufferLength;

    // That's it
    TotalSize =  BlobHeaderSize
               + PasswordHeaderSize
               + DataSize;

    SecureChannelBlob = MIDL_user_allocate(TotalSize);

    if ( !SecureChannelBlob )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Exit;
    }
    RtlZeroMemory(SecureChannelBlob, TotalSize);

    //
    // Set up the SecureChannelBlob
    //
    SecureChannelBlob->Type = SamPdcPasswordNotification;
    SecureChannelBlob->DataSize = PasswordHeaderSize + DataSize;

    //
    // Set up the password info
    //
    PasswordInfo = (PSAMI_PASSWORD_INFO) &SecureChannelBlob->Data[0];
    PasswordInfo->Flags = Flags;
    PasswordInfo->Size = PasswordHeaderSize;
    PasswordInfo->AccountRid = RelativeId;
    PasswordInfo->PasswordExpired = (Flags & SAM_MANUAL_PWD_EXPIRY) ? TRUE : FALSE;

    //
    // Set up the indices
    //

    //
    // First the lengths
    //
    PasswordIndex = &PasswordInfo->DataIndex[0];
    PasswordIndex[ SampPositionOfHighestBit(SAM_ACCOUNT_NAME_PRESENT)-1 ].Length
         = NameBufferLength;
    PasswordIndex[ SampPositionOfHighestBit(SAM_NT_OWF_PRESENT)-1 ].Length
         = NtBufferLength;
    PasswordIndex[ SampPositionOfHighestBit(SAM_LM_OWF_PRESENT)-1 ].Length
         = LmBufferLength;

    //
    // Now the offsets
    //
    CurrentOffset = 0;
    for ( Index = 0; Index < ElementCount; Index++ )
    {
        PasswordIndex[ Index ].Offset = CurrentOffset;
        CurrentOffset += PasswordIndex[ Index ].Length;
    }

    //
    // Copy in the data
    //
    DataStart = ((UCHAR*)PasswordInfo) + PasswordHeaderSize;

    Index = SampPositionOfHighestBit(SAM_ACCOUNT_NAME_PRESENT)-1;
    DataPtr = DataStart + PasswordIndex[Index].Offset;
    RtlCopyMemory( DataPtr, UserName->Buffer, NameLength );

    Index = SampPositionOfHighestBit(SAM_LM_OWF_PRESENT)-1;
    DataPtr = DataStart + PasswordIndex[ Index ].Offset;
    RtlCopyMemory( DataPtr, &LmOwfPassword, LmDataLength );

    Index = SampPositionOfHighestBit(SAM_NT_OWF_PRESENT)-1;
    DataPtr = DataStart + PasswordIndex[ Index ].Offset;
    RtlCopyMemory( DataPtr, &NtOwfPassword, NtDataLength );

    // Send the password information to the PDC. This routine is
    // synchronous and may take a few minutes, in the worst case,
    // to return. The error code is ignored (except for debug
    // message purposes) because it is benign. This call can fail
    // because the PDC is unavailable, the account may not yet
    // exist on the PDC due to replication latency, etc. Failure
    // to propagate the password to the PDC is not a critical
    // error.

    NtStatus = I_NetLogonSendToSamOnPdc(NULL,
                                       (PUCHAR)SecureChannelBlob,
                                       TotalSize);


    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                   "UserId: 0x%x  PDC forward, Password=%s, Expire=%s, Unlock=%s  (status 0x%x)\n",
                   RelativeId, 
                   ((Flags & SAM_NT_OWF_PRESENT) ? "TRUE" : "FALSE"),
                   ((Flags & SAM_MANUAL_PWD_EXPIRY) ? "TRUE" : "FALSE"),
                   ((Flags & SAM_ACCOUNT_UNLOCKED) ? "TRUE" : "FALSE"),
                   NtStatus));

    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: I_NetLogonSendToSamOnPdc status = 0x%lx\n",
                   NtStatus));

        NtStatus = STATUS_SUCCESS;
    }

    MIDL_user_free(SecureChannelBlob);


Exit:

    return(NtStatus);
}


NTSTATUS
SampPasswordChangeNotify(
    IN ULONG            Flags,
    IN PUNICODE_STRING  UserName,
    IN ULONG            RelativeId,
    IN PUNICODE_STRING  NewPassword,
    IN BOOLEAN          Loopback
    )
/*++

Routine Description:

    This routine notifies packages of a password change.  It requires that
    the user no longer be locked so that other packages can write to the
    user parameters field.


Arguments:

    Flags - what has changed

    UserName - Name of user whose password changed

    RelativeId - RID of the user whose password changed

    NewPassword - Cleartext new password for the user
    
    Loopback    - Indicates that this is loopback ... ie transaction may not
                  have committed and will be commited by ntdsa later.

Return Value:

    STATUS_SUCCESS only - errors from packages are ignored.

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOL     fStatus;

    PSAMP_LOOPBACK_TASK_ITEM  Item = NULL;
    PUNICODE_STRING           TempUserName = NULL;
    PUNICODE_STRING           TempNewPassword = NULL;
    ULONG                     Size;

    if ( SampUseDsData && Loopback )
    {

        //
        // The ds has the lock. Can't talk to the pdc right now. Store the
        // information in the thread state to be processed when all
        // transactions and locks  are freed.
        //

        //
        // Allocate the space
        //
        Item = THAlloc( sizeof( SAMP_LOOPBACK_TASK_ITEM ) );
        if ( !Item )
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        RtlZeroMemory( Item, sizeof( SAMP_LOOPBACK_TASK_ITEM ) );

        TempUserName    = &(Item->NotifyInfo.PasswordChange.UserName);
        TempNewPassword = &(Item->NotifyInfo.PasswordChange.NewPassword);

        //
        // Setup the name
        //
        Size = UserName->MaximumLength;
        TempUserName->Buffer = THAlloc( Size );
        if (NULL == TempUserName->Buffer)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        TempUserName->Length = 0;
        TempUserName->MaximumLength = (USHORT) Size;
        RtlCopyUnicodeString( TempUserName, UserName );

        //
        // Setup the password, if present
        //
        if (Flags & SAMP_PWD_NOTIFY_PWD_CHANGE) {

            Size = NewPassword->MaximumLength;
            TempNewPassword->Buffer = THAlloc( Size );
            TempNewPassword->Length = 0;
            TempNewPassword->MaximumLength = (USHORT) Size;
            RtlCopyUnicodeString( TempNewPassword, NewPassword );

        }

        //
        // Set the item up
        //
        Item->Type = SampNotifyPasswordChange;
        Item->fCommit = TRUE;

        //
        // And the rid
        //
        Item->NotifyInfo.PasswordChange.RelativeId = RelativeId;
        Item->NotifyInfo.PasswordChange.Flags = Flags;

        fStatus = SampAddLoopbackTask( Item );

        if ( !fStatus )
        {
            NtStatus = STATUS_NO_MEMORY;
        }

    }
    else
    {
        NtStatus = SampPasswordChangeNotifyWorker( Flags,
                                                   UserName,
                                                   RelativeId,
                                                   NewPassword );

        SampDiagPrint( DISPLAY_LOCKOUT,
                     ( "SAMSS: Password notify for %ls (%d) status: 0x%x\n",
                     UserName->Buffer,
                     RelativeId,
                     NtStatus ));
    }

Cleanup:

    if ( !NT_SUCCESS( NtStatus ) )
    {
        if ( TempUserName && TempUserName->Buffer )
        {
            THFree( TempUserName->Buffer );
        }
        if ( TempNewPassword && TempNewPassword->Buffer )
        {
            THFree( TempNewPassword->Buffer );
        }
        if ( Item )
        {
            THFree( Item );
        }
    }

    return NtStatus;
}

NTSTATUS
SampPasswordChangeNotifyWorker(
    IN ULONG Flags,
    IN PUNICODE_STRING UserName,
    IN ULONG RelativeId,
    IN PUNICODE_STRING NewPassword
    )
/*++

Routine Description:

    This routine notifies packages of a password change.  It requires that
    the user no longer be locked so that other packages can write to the
    user parameters field.


Arguments:

    Flags -    //
               // Indicates that what has changed
               //
            SAMP_PWD_NOTIFY_MANUAL_EXPIRE
            SAMP_PWD_NOTIFY_UNLOCKED
            SAMP_PWD_NOTIFY_PWD_CHANGE
            SAMP_PWD_NOTIFY_MACHINE_ACCOUNT
                     
    UserName - Name of user whose password changed

    RelativeId - RID of the user whose password changed

    NewPassword - Cleartext new password for the user
    
Return Value:

    STATUS_SUCCESS only - errors from packages are ignored.

--*/
{
    NTSTATUS NtStatus;
    PSAMP_NOTIFICATION_PACKAGE Package;
    NT_PRODUCT_TYPE NtProductType = 0;
    PSAMP_OBJECT DomainContext = NULL;
    PVOID *pTHState = NULL;

    SAMTRACE("SampPasswordChangeNotify");

    //
    // Suspend the thread state since the packages may call back into
    // SAM
    //
    if ( SampUseDsData
      && THQuery() ) {
        pTHState = THSave();
        ASSERT( pTHState );
    }

    //
    // The lock should not be held
    //
    ASSERT( !SampCurrentThreadOwnsLock() );

    if (Flags & SAMP_PWD_NOTIFY_PWD_CHANGE) {

        //
        // Notify the packages
        //
        Package = SampNotificationPackages;
    
        while (Package != NULL) {
            if ( Package->PasswordNotificationRoutine != NULL ) {
                try {
                    NtStatus = Package->PasswordNotificationRoutine(
                                    UserName,
                                    RelativeId,
                                    NewPassword
                                    );
                    if (!NT_SUCCESS(NtStatus)) {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "Package %wZ failed to accept password change for user %wZ\n",
                                   &Package->PackageName, UserName));
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "Exception thrown in Password Notification Routine: 0x%x (%d)\n",
                               GetExceptionCode(),
                               GetExceptionCode()));
    
                    NtStatus = STATUS_ACCESS_VIOLATION;
                }
            }
    
            Package = Package->Next;
    
        }

    }

    // Errors from packages are ignored; always notify the PDC of a password
    // change. Because the PDC may not be available, or reachable, the return
    // status can be ignored here. It is not essential that the PDC receive
    // the password-change information right away--replication will ultimately
    // get the information to the PDC. Only make this call on a BDC in order
    // to propagate the password information to the PDC. Since the routine
    // SampPasswordChangeNotify is also called on the PDC when the password
    // information is set there, we don't want to recursively call the routine
    // SampPasswordChangeNotifyPdc on the PDC.

    //
    // Don't notify the PDC on password set.  A common situation is for an
    // admin to reset the password and then expire it (which writes to the
    // PasswordLastSet attributes).  Pushing the password to the PDC will
    // cause the PasswordLastSet to have an originating write which can 
    // overwrite the expiration attempt.  (Windows bug 352242).
    //

    RtlGetNtProductType(&NtProductType);

    if ( (NtProductLanManNt == NtProductType)
     &&  ((Flags & SAMP_PWD_NOTIFY_MACHINE_ACCOUNT) == 0)
     &&  (DomainServerRoleBackup == SampDefinedDomains[DOMAIN_START_DS + 1].ServerRole) )
    {
        // Only allow this call to be made from a BDC to the PDC.
        ULONG PdcFlags = SAM_ACCOUNT_NAME_PRESENT;
        
        
        if (Flags & SAMP_PWD_NOTIFY_PWD_CHANGE) {
            PdcFlags |= SAM_NT_OWF_PRESENT | SAM_LM_OWF_PRESENT;
        }
        if (Flags & SAMP_PWD_NOTIFY_UNLOCKED) {
            PdcFlags |= SAM_ACCOUNT_UNLOCKED;
        }
        if (Flags & SAMP_PWD_NOTIFY_MANUAL_EXPIRE) {
            PdcFlags |= SAM_MANUAL_PWD_EXPIRY;
        }

        NtStatus = SampPasswordChangeNotifyPdc(PdcFlags,
                                               UserName,
                                               RelativeId,
                                               NewPassword);
    }

    //
    // Restore the thread state
    //
    if ( pTHState ) {

        THRestore( pTHState );

    }

    // Failure return codes from SampPasswordChangeNotifyPdc or from the
    // security packages are treated as benign errors. These errors should
    // should not prevent the password from being changed locally on this
    // DC.

    return(STATUS_SUCCESS);
}

NTSTATUS
SampPasswordChangeFilter(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING FullName,
    IN PUNICODE_STRING NewPassword,
    IN OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL,
    IN BOOLEAN SetOperation
    )
/*++

Routine Description:

    This routine notifies packages of a password change.  It requires that
    the user no longer be locked so that other packages can write to the
    user parameters field.


Arguments:

    UserName - Name of user whose password changed

    FullName - Full name of the user whose password changed

    NewPassword - Cleartext new password for the user

    SetOperation - TRUE if the password was SET rather than CHANGED

Return Value:

    Status codes from the notification packages.

--*/
{
    PSAMP_NOTIFICATION_PACKAGE Package;
    BOOLEAN Result;
    NTSTATUS Status;

    Package = SampNotificationPackages;

    while (Package != NULL) {
        if ( Package->PasswordFilterRoutine != NULL ) {
            try {
                Result = Package->PasswordFilterRoutine(
                            UserName,
                            FullName,
                            NewPassword,
                            SetOperation
                            );
                if (!Result)
                {
                    Status = STATUS_PASSWORD_RESTRICTION;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "Exception thrown in Password Filter Routine: 0x%x (%d)\n",
                           GetExceptionCode(),
                           GetExceptionCode() ));

                //
                // Set result to FALSE so the change fails.
                //

                Status = STATUS_ACCESS_VIOLATION;
                Result = FALSE;
            }

            if (!Result) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "Package %wZ failed to accept password change for user %wZ: 0x%x\n",
                           &Package->PackageName,
                           UserName,
                           Status));

                if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
                {
                    NTSTATUS    IgnoreStatus;

                    PasswordChangeFailureInfo->ExtendedFailureReason 
                                        = SAM_PWD_CHANGE_FAILED_BY_FILTER;
                    RtlInitUnicodeString(&PasswordChangeFailureInfo->FilterModuleName,
                                         NULL);
                    IgnoreStatus = SampDuplicateUnicodeString(
                                        &PasswordChangeFailureInfo->FilterModuleName,
                                        &Package->PackageName
                                        );
                }

                return(Status);
            }

        }

        Package = Package->Next;


    }
    return(STATUS_SUCCESS);
}


NTSTATUS
SampDeltaChangeNotify(
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )
/*++

Routine Description:

    This routine notifies packages of a change to the SAM database.  The
    database is still locked for write access so it requires that nothing
    it calls try to lock the database.

Arguments:

    DomainSid - SID of domain for delta

    DeltaType - Type of delta (change, add ,delete)

    ObjectType - Type of object changed (user, alias, group ...)

    ObjectRid - ID of object changed

    ObjectName - Name of object changed

    ModifiedCount - Serial number of database after this last change

    DeltaData - Data describing the exact modification.

Return Value:

    STATUS_SUCCESS only - errors from packages are ignored.

--*/
{
    PSAMP_NOTIFICATION_PACKAGE Package;
    NTSTATUS NtStatus;

    SAMTRACE("SampDeltaChangeNotify");

    Package = SampNotificationPackages;

    while (Package != NULL) {


        if (Package->DeltaNotificationRoutine != NULL) {
            try {
                NtStatus = Package->DeltaNotificationRoutine(
                                DomainSid,
                                DeltaType,
                                ObjectType,
                                ObjectRid,
                                ObjectName,
                                ModifiedCount,
                                DeltaData
                                );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "Exception thrown in Delta Notificateion Routine: 0x%x (%d)\n",
                           GetExceptionCode(),
                           GetExceptionCode()));

                NtStatus = STATUS_ACCESS_VIOLATION;
            }

            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "Package %wZ failed to accept deltachange for object %wZ\n",
                           &Package->PackageName,
                           ObjectName));
            }
        }

        Package = Package->Next;


    }
    return(STATUS_SUCCESS);
}



NTSTATUS
SampAbortSingleLoopbackTask(
    IN OUT PVOID * VoidNotifyItem
    )
/*++
Routine Description:

    this routine marks fCommit (of the passed in Loopback Task Item) to FALSE.
    
Parameters:
    
    VoidNotifyItem - pointer to a SAM Loopback task item
    
Return Values:

    STATUS_SUCCESS or STATUS_INVALID_PARAMETER

--*/
{
    PSAMP_LOOPBACK_TASK_ITEM NotifyItem;

    if ( !VoidNotifyItem )
    {
        return STATUS_INVALID_PARAMETER;
    }

    NotifyItem = (PSAMP_LOOPBACK_TASK_ITEM) VoidNotifyItem;

    switch (NotifyItem->Type)
    {
    case SampIncreaseBadPasswordCount:
    case SampNotifyPasswordChange:
    case SampDeleteAccountNameTableElement:
    case SampGenerateLoopbackAudit:
        NotifyItem->fCommit = FALSE;
        break;
    default:
        ASSERT( !"Invalid switch statement" );
        return( STATUS_INVALID_PARAMETER );
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
SampProcessSingleLoopbackTask(
    IN PVOID   *VoidNotifyItem
    )
/*++

Routine Description:

    This rouinte handles the passed in Loopback Task Item. Depends on fCommit 
    in each item's structure, SAM will either ignore it or do the task. 
 

Arguments:

    VoidNotifyItem - pointer to a SAM Loopback task item

Return Value:

    STATUS_SUCCESS only - errors from packages are ignored.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_LOOPBACK_TASK_ITEM NotifyItem;

    if ( !VoidNotifyItem )
    {
        return STATUS_INVALID_PARAMETER;
    }

    NotifyItem = (PSAMP_LOOPBACK_TASK_ITEM) VoidNotifyItem;

    switch ( NotifyItem->Type )
    {
        case SampNotifyPasswordChange:
        {
            PSAMP_PASSWORD_CHANGE_INFO PasswordChangeInfo;

            PasswordChangeInfo = (PSAMP_PASSWORD_CHANGE_INFO)
                                 &(NotifyItem->NotifyInfo.PasswordChange);

            // 
            // process NotifyPasswordChange Task Item ONLY when fCommit if TRUE
            // 
            if ( NotifyItem->fCommit )
            {
                NtStatus = SampPasswordChangeNotifyWorker(
                                                PasswordChangeInfo->Flags,
                                                &PasswordChangeInfo->UserName,
                                                PasswordChangeInfo->RelativeId,
                                                &PasswordChangeInfo->NewPassword
                                                );

                SampDiagPrint( DISPLAY_LOCKOUT,
                             ( "SAMSS: Loopback password notify for %ls (%d) status: 0x%x\n",
                             PasswordChangeInfo->UserName.Buffer,
                             PasswordChangeInfo->RelativeId,
                             NtStatus ));
            }

            if ( PasswordChangeInfo->UserName.Buffer )
            {
                THFree( PasswordChangeInfo->UserName.Buffer );
            }

            if ( PasswordChangeInfo->NewPassword.Buffer )
            {
                THFree( PasswordChangeInfo->NewPassword.Buffer );
            }
        }
        break;

        case SampIncreaseBadPasswordCount:
        {
            PSAMP_BAD_PASSWORD_COUNT_INFO   BadPwdCountInfo = NULL;

            BadPwdCountInfo = (PSAMP_BAD_PASSWORD_COUNT_INFO)
                                &(NotifyItem->NotifyInfo.BadPasswordCount);

            //
            // Always Increase Bad Password Count no matter commit or not.
            // 

            NtStatus = SampIncreaseBadPwdCountLoopback(
                                &(BadPwdCountInfo->UserName)
                                );

            //
            // Note: 
            // We don't sleep 3 second to prevent dictionary attacks. 
            // that is due to limited # of ATQ threads in ldap. 
            // If the thread doesn't return asap, then we will block
            // other ldap client. 
            // 

            if (BadPwdCountInfo->UserName.Buffer)
            {
                THFree( BadPwdCountInfo->UserName.Buffer );
                BadPwdCountInfo->UserName.Buffer = NULL;
            }
        }
        break;

        case SampDeleteAccountNameTableElement:
        {
            PSAMP_ACCOUNT_INFO      AccountInfo = NULL;

            AccountInfo = (PSAMP_ACCOUNT_INFO)
                            &(NotifyItem->NotifyInfo.Account);

            NtStatus = SampDeleteElementFromAccountNameTable(
                            &(AccountInfo->AccountName),
                            AccountInfo->ObjectType
                            );

            if (AccountInfo->AccountName.Buffer)
            {
                THFree( AccountInfo->AccountName.Buffer );
                AccountInfo->AccountName.Buffer = NULL;
            }
                        
        }
        break;

        case SampGenerateLoopbackAudit:
        {
            PSAMP_AUDIT_INFO    AuditInfo = NULL;

            AuditInfo = (PSAMP_AUDIT_INFO)
                            &(NotifyItem->NotifyInfo.AuditInfo);

            if ( NotifyItem->fCommit )
            {
                //
                // Audit this SAM event only if the 
                // transaction was committed
                // 

                LsaIAuditSamEvent(AuditInfo->NtStatus,
                                  AuditInfo->AuditId,
                                  AuditInfo->DomainSid,
                                  AuditInfo->AdditionalInfo,
                                  AuditInfo->MemberRid,
                                  AuditInfo->MemberSid,
                                  AuditInfo->AccountName,
                                  AuditInfo->DomainName,
                                  AuditInfo->AccountRid,
                                  AuditInfo->Privileges
                                  );
            }

            //
            // Free memory
            //

            SampFreeLoopbackAuditInfo(AuditInfo);
        }
        break;

        default:
            ASSERT( !"Invalid switch statement" );
            NtStatus =  STATUS_INVALID_PARAMETER;
    }


    THFree( NotifyItem );

    return NtStatus;
}


NTSTATUS
SampPrivatePasswordUpdate(
    SAMPR_HANDLE     DomainHandle,
    ULONG            Flags,
    ULONG            AccountRid,
    PLM_OWF_PASSWORD LmOwfPassword,
    PNT_OWF_PASSWORD NtOwfPassword,
    BOOLEAN          PasswordExpired
    )
/*++

Routine Description:

    This routine writes the passwords to the user's account without
    updating the password history

    It will also set if the password is expired or if the account has
    become unlocked.

Arguments:

    DomainHandle : the handle of the domain of AccountRid

    AccountRid : the account to apply the change

    LmOwfPassword : non-NULL pointer to the lm password

    NtOwfPassword : non-NULL pointer to the nt password

    PasswordExpired : is the password expired
    
Return Value:

    STATUS_SUCCESS if the password was successfully set

--*/
{
    NTSTATUS NtStatus  = STATUS_SUCCESS;
    BOOLEAN  fLockHeld = FALSE;
    BOOLEAN  fCommit   = FALSE;
    BOOLEAN  fDerefDomain = FALSE;

    PSAMP_OBJECT        AccountContext = 0;
    PSAMP_OBJECT        DomainContext = 0;
    SAMP_OBJECT_TYPE    FoundType;

    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;

    ASSERT( NULL != DomainHandle );

    //
    // Grab lock
    //
    NtStatus = SampAcquireWriteLock();
    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                     ( "SAMSS: SampAcquireWriteLock returned 0x%x\n",
                      NtStatus ));

        goto Cleanup;
    }
    fLockHeld = TRUE;

    //
    // Reference the domain so SampCreateAccountContext has the correct
    // transactional domain.
    //
    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   0,                   // DesiredAccess
                   SampDomainObjectType,            // ExpectedType
                   &FoundType
                   );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                     ( "SAMSS: SampLookupContext returned 0x%x\n",
                      NtStatus ));

        goto Cleanup;
    }
    fDerefDomain = TRUE;

    //
    // Create a context
    //
    NtStatus = SampCreateAccountContext( SampUserObjectType,
                                         AccountRid,
                                         TRUE,  // trusted client
                                         FALSE, // loopback
                                         TRUE,  // account exists
                                         &AccountContext );

    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                ( "SAMSS: SampCreateAccountContext for rid 0x%x returned 0x%x\n",
                      AccountRid, NtStatus ));

        goto Cleanup;
    }

    SampReferenceContext( AccountContext );


    if (Flags & SAM_NT_OWF_PRESENT) {

        //
        // Store the passwords
        //
        NtStatus = SampStoreUserPasswords( AccountContext,
                                           LmOwfPassword,
                                           TRUE,   // LmOwfPassword present
                                           NtOwfPassword,
                                           TRUE,   // NtOwfPassword present
                                           FALSE,  // don't check history
                                           PasswordPushPdc,
                                           NULL,
                                           NULL
                                           );
    
        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint( DISPLAY_LOCKOUT,
                         ( "SAMSS: SampStoreUserPasswords returned 0x%x\n",
                          NtStatus ));
    
            goto Cleanup;
        }
    }

    //
    // Set the password last set
    //
    if ((Flags & SAM_NT_OWF_PRESENT)
     || (Flags & SAM_MANUAL_PWD_EXPIRY)  ) {
        NtStatus = SampRetrieveUserV1aFixed( AccountContext,
                                             &V1aFixed );
    
        if ( NT_SUCCESS( NtStatus ) ) {
        
            NtStatus = SampComputePasswordExpired(PasswordExpired,
                                                  &V1aFixed.PasswordLastSet);
    
            if (NT_SUCCESS(NtStatus)) {
    
                NtStatus = SampReplaceUserV1aFixed( AccountContext,
                                                   &V1aFixed );
            }
        }

        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint( DISPLAY_LOCKOUT,
                         ( "SAMSS: Setting the last time returned 0x%x\n",
                          NtStatus ));
    
            goto Cleanup;
        }
    }

    //
    // Finally see if we need to unlock the account
    //
    if (Flags & SAM_ACCOUNT_UNLOCKED) {

        RtlZeroMemory(&AccountContext->TypeBody.User.LockoutTime,sizeof(LARGE_INTEGER) );
        
        NtStatus = SampDsUpdateLockoutTimeEx(AccountContext, FALSE);

        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint( DISPLAY_LOCKOUT,
                         ( "SAMSS: Setting the last time returned 0x%x\n",
                          NtStatus ));
    
            goto Cleanup;
        }
    }

    fCommit = TRUE;

    //
    //  That's it; fall through to cleanup
    //

Cleanup:

    if ( AccountContext )
    {
        //
        //  Dereference the context to make the changes
        //
        NtStatus = SampDeReferenceContext( AccountContext, fCommit );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint( DISPLAY_LOCKOUT,
                         ( "SAMSS: SampDeReferenceContext returned 0x%x\n",
                          NtStatus ));

            if ( fCommit )
            {
                // Since we couldn't write the changes, don't commit
                // the transaction
                fCommit = FALSE;
            }
        }

        SampDeleteContext( AccountContext );
        AccountContext = 0;
    }

    if ( fDerefDomain )
    {
        SampDeReferenceContext( DomainContext, FALSE );
    }

    if ( fLockHeld )
    {
        SampReleaseWriteLock( fCommit );
        fLockHeld = FALSE;
    }


    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                   "UserId: 0x%x  PDC update, Password=%s, Expire=%s, Unlock=%s  (status 0x%x)\n",
                   AccountRid, 
                   (Flags & SAM_NT_OWF_PRESENT ? "TRUE" : "FALSE"),
                   (PasswordExpired ? "TRUE" : "FALSE"),
                   ((Flags & SAM_ACCOUNT_UNLOCKED) ? "TRUE" : "FALSE"),
                   NtStatus));

    return NtStatus;

}


VOID
SampAddLoopbackTaskForBadPasswordCount(
    IN PUNICODE_STRING AccountName
    )
/*++
Routine Description:

    This routine adds a work item (increment Bad Password Count) 
    into the SAM Loopback tasks. Also this routine stores all necessary
    informatin (AccountName). The reasons why we have to add a task item
    into loopback tasks are: 
    
    1) sleep 3 seconds after releasing SAM lock. 
    2) open a new transaction after Changing Password transaction aborted, 
       if we increase bad password count in the same transaction as 
       changing password. Everything will be aborted. So we have to do it
       in a separate transaction, but still in the same thread 
       (synchronously). 

Arguments:

    AccountName - User Account Name.

Return Values:

    none.

--*/
{
    PSAMP_LOOPBACK_TASK_ITEM    Item = NULL;
    WCHAR   *Temp = NULL;

    SAMTRACE("SampAddLoopbackTaskForBadPasswordCount");


    ASSERT(SampUseDsData);

    Item = THAlloc( sizeof( SAMP_LOOPBACK_TASK_ITEM ) );
    if (Item)
    {
        RtlZeroMemory(Item, sizeof( SAMP_LOOPBACK_TASK_ITEM ));

        Temp = THAlloc( AccountName->MaximumLength );

        if (Temp)
        {
            Item->NotifyInfo.BadPasswordCount.UserName.Buffer = Temp;
            Item->NotifyInfo.BadPasswordCount.UserName.Length = 0;
            Item->NotifyInfo.BadPasswordCount.UserName.MaximumLength = 
                                     AccountName->MaximumLength;

            //
            // copy the account name
            // 
            RtlCopyUnicodeString( &(Item->NotifyInfo.BadPasswordCount.UserName), 
                                  AccountName);

            Item->Type = SampIncreaseBadPasswordCount;
            Item->fCommit = TRUE;

            // 
            // add to the thread state
            // 
            SampAddLoopbackTask( Item );
        }
    }

    return;
}

NTSTATUS
SampAddLoopbackTaskDeleteTableElement(
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    )
{
    PSAMP_LOOPBACK_TASK_ITEM    Item = NULL;
    WCHAR   *Temp = NULL;

    SAMTRACE("SampAddLoopbackTaskDeleteTableElement");

    Item = THAlloc( sizeof( SAMP_LOOPBACK_TASK_ITEM ) );

    if (Item)
    {
        RtlZeroMemory(Item, sizeof(SAMP_LOOPBACK_TASK_ITEM));

        Temp = THAlloc( AccountName->MaximumLength );

        if (Temp)
        {
            Item->NotifyInfo.Account.AccountName.Buffer = Temp;
            Item->NotifyInfo.Account.AccountName.Length = 0;
            Item->NotifyInfo.Account.AccountName.MaximumLength = 
                                AccountName->MaximumLength;

            Item->NotifyInfo.Account.ObjectType = ObjectType;

            //
            // copy the account name
            // 
            RtlCopyUnicodeString( &(Item->NotifyInfo.Account.AccountName), 
                                  AccountName );

            Item->Type = SampDeleteAccountNameTableElement;
            Item->fCommit = TRUE;

            //
            // Add to the thread state
            // 
            if ( !SampAddLoopbackTask(Item) )
            {
                return( STATUS_INTERNAL_ERROR );
            }
        }
        else
        {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    }
    else
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    return( STATUS_SUCCESS );
}

NTSTATUS
SampIncreaseBadPwdCountLoopback(
    IN PUNICODE_STRING  UserName
    )
/*++
Routine Description:

Parameters:

Return Values:



--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        IgnoreStatus = STATUS_SUCCESS;
    SAMPR_HANDLE    UserHandle = NULL;
    PSAMP_OBJECT    AccountContext = NULL;
    BOOLEAN         AccountLockedOut;
    SAMP_OBJECT_TYPE FoundType;
    SAMP_V1_0A_FIXED_LENGTH_USER    V1aFixed;
    PVOID           *pTHState = NULL;
    BOOLEAN         fLockAcquired = FALSE;

    SAMTRACE("SampIncreaseBadPwdCountLoopback");

    //
    // Suspend the thread state
    // 
    if ( SampUseDsData && THQuery() )
    {
        pTHState = THSave();
        ASSERT( pTHState );
    }

    //
    // The lock should not be held
    // 
    ASSERT( !SampCurrentThreadOwnsLock() );

    //
    // Open the User
    // 

    NtStatus = SampOpenUserInServer(UserName, 
                                    TRUE,       // Unicode String, not OEM
                                    TRUE,       // TrustedClient
                                    &UserHandle
                                    );
                    
    if (!NT_SUCCESS(NtStatus)) {
        goto RestoreAndLeave;
    }

    //
    // Grab the lock
    // 

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        goto RestoreAndLeave;
    }
    fLockAcquired = TRUE;

    //
    // Validate type of, and access to object.
    // 

    AccountContext = (PSAMP_OBJECT) UserHandle;

    NtStatus = SampLookupContext(AccountContext, 
                                 USER_CHANGE_PASSWORD,
                                 SampUserObjectType,
                                 &FoundType
                                 );

    if (!NT_SUCCESS(NtStatus)) {
        goto RestoreAndLeave;
    }

    //
    // Get the V1aFixed so we can update the bad password count
    // 

    NtStatus = SampRetrieveUserV1aFixed(AccountContext, 
                                        &V1aFixed
                                        );

    if (NT_SUCCESS(NtStatus)) 
    {

        //
        // Increment BadPasswordCount (might lockout account)
        // 

        AccountLockedOut = SampIncrementBadPasswordCount(
                               AccountContext,
                               &V1aFixed,
                               NULL
                               );

        //
        // update V1aFixed 
        //      

        NtStatus = SampReplaceUserV1aFixed(AccountContext, 
                                           &V1aFixed
                                           );

    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampCommitAndRetainWriteLock();
        }
    }
    else
    {
        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

RestoreAndLeave:
    //
    // Release the write lock if necessary
    // 
    if (fLockAcquired)
    {
        IgnoreStatus = SampReleaseWriteLock( FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (UserHandle) 
    {
        SamrCloseHandle(&UserHandle);
    }

    ASSERT(!SampExistsDsTransaction());

    if ( pTHState )
    {
        THRestore( pTHState );
    }

    //
    // The lock should be released
    // 
    ASSERT( !SampCurrentThreadOwnsLock() );

    return( NtStatus );
}


NTSTATUS
SampLoopbackTaskDupSid(
    PSID    *ppSid,
    PSID    sourceSid OPTIONAL
    )
{
    PSID       Temp = NULL;
    ULONG       Length;

    *ppSid = NULL;

    if (!ARGUMENT_PRESENT(sourceSid))
        return(STATUS_SUCCESS);

    Length = RtlLengthSid(sourceSid);

    Temp = THAlloc(Length);
    if (!Temp)
        return(STATUS_INSUFFICIENT_RESOURCES);

    RtlZeroMemory(Temp, Length);
    RtlCopyMemory(Temp, sourceSid, Length);

    *ppSid = Temp;

    return(STATUS_SUCCESS);
}


NTSTATUS
SampLoopbackTaskDupUlong(
    PULONG  *ppULong,
    PULONG  sourceUlong OPTIONAL
    )
{
    PULONG   Temp = NULL;

    *ppULong = NULL;

    if (!ARGUMENT_PRESENT(sourceUlong))
        return(STATUS_SUCCESS);

    Temp = THAlloc(sizeof(ULONG));
    if (!Temp)
        return(STATUS_INSUFFICIENT_RESOURCES);


    *Temp = *sourceUlong;
    *ppULong = Temp;

    return(STATUS_SUCCESS);
}

NTSTATUS
SampLoopbackTaskDupUnicodeString(
    PUNICODE_STRING *ppUnicodeString,
    PUNICODE_STRING sourceUnicodeString OPTIONAL
    )
{
    PUNICODE_STRING   Temp = NULL;
    PWSTR   Buffer = NULL;

    *ppUnicodeString = NULL;

    if (!ARGUMENT_PRESENT(sourceUnicodeString))
        return(STATUS_SUCCESS);

    Temp = THAlloc(sizeof(UNICODE_STRING));
    if (!Temp)
        return(STATUS_INSUFFICIENT_RESOURCES);

    RtlZeroMemory(Temp, sizeof(UNICODE_STRING));

    Buffer = THAlloc(sourceUnicodeString->Length);
    if (!Buffer)
    {
        THFree(Temp);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory(Buffer, sourceUnicodeString->Length);
    RtlCopyMemory(Buffer, 
                  sourceUnicodeString->Buffer, 
                  sourceUnicodeString->Length);

    Temp->Buffer = Buffer;
    Temp->Length = sourceUnicodeString->Length;
    Temp->MaximumLength = sourceUnicodeString->MaximumLength;

    *ppUnicodeString = Temp;

    return(STATUS_SUCCESS);
}

NTSTATUS
SampLoopbackTaskDupPrivileges(
    PPRIVILEGE_SET  *ppPrivileges,
    PPRIVILEGE_SET sourcePrivileges OPTIONAL
    )
{
    ULONG   Length = 0;
    PPRIVILEGE_SET  Temp = NULL;

    *ppPrivileges = NULL;

    if (!ARGUMENT_PRESENT(sourcePrivileges))
        return( STATUS_SUCCESS );

    Length = sizeof(PRIVILEGE_SET) + 
             sourcePrivileges->PrivilegeCount * sizeof(LUID_AND_ATTRIBUTES);

    Temp = THAlloc(Length);
    if (!Temp)
        return(STATUS_INSUFFICIENT_RESOURCES);

    RtlZeroMemory(Temp, Length);
    RtlCopyMemory(Temp, sourcePrivileges, Length);
    

    *ppPrivileges = Temp;

    return( STATUS_SUCCESS );
}

VOID
SampFreeLoopbackAuditInfo(
    PSAMP_AUDIT_INFO    AuditInfo
    )
{
    if (AuditInfo)
    {
        if (AuditInfo->DomainSid)
        {
            THFree(AuditInfo->DomainSid);
        }

        if (AuditInfo->AdditionalInfo)
        {
            if (AuditInfo->AdditionalInfo->Buffer)
            {
                THFree(AuditInfo->AdditionalInfo->Buffer);
            }
            THFree(AuditInfo->AdditionalInfo);
        }

        if (AuditInfo->MemberRid)
        {
            THFree(AuditInfo->MemberRid);
        }

        if (AuditInfo->MemberSid)
        {
            THFree(AuditInfo->MemberSid);
        }

        if (AuditInfo->AccountName)
        {
            if (AuditInfo->AccountName->Buffer)
            {
                THFree(AuditInfo->AccountName->Buffer);
            }
            THFree(AuditInfo->AccountName);
        }

        if (AuditInfo->DomainName)
        {
            if (AuditInfo->DomainName->Buffer)
            {
                THFree(AuditInfo->DomainName->Buffer);
            }
            THFree(AuditInfo->DomainName);
        }

        if (AuditInfo->AccountRid)
        {
            THFree(AuditInfo->AccountRid);
        }

        if (AuditInfo->Privileges)
        {
            THFree(AuditInfo->Privileges);
        }


        RtlZeroMemory(AuditInfo, sizeof(SAMP_AUDIT_INFO));
    }
}


NTSTATUS
SampAddLoopbackTaskForAuditing(
    IN NTSTATUS             PassedStatus,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_LOOPBACK_TASK_ITEM    Item = NULL;
    WCHAR       *Temp = NULL;
    ULONG       Length;
    

    Item = THAlloc( sizeof(SAMP_LOOPBACK_TASK_ITEM) );

    if (Item)
    {
        RtlZeroMemory(Item, sizeof(SAMP_LOOPBACK_TASK_ITEM));

        Item->fCommit = TRUE;

        Item->Type = SampGenerateLoopbackAudit;

        Item->NotifyInfo.AuditInfo.NtStatus = PassedStatus;

        Item->NotifyInfo.AuditInfo.AuditId = AuditId;

        ASSERT(NULL!=DomainSid);
        NtStatus = SampLoopbackTaskDupSid(
                        &(Item->NotifyInfo.AuditInfo.DomainSid),
                        DomainSid
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;


        NtStatus = SampLoopbackTaskDupUnicodeString(
                        &(Item->NotifyInfo.AuditInfo.AdditionalInfo),
                        AdditionalInfo
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        NtStatus = SampLoopbackTaskDupUlong(
                        &(Item->NotifyInfo.AuditInfo.MemberRid),
                        MemberRid
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        NtStatus = SampLoopbackTaskDupSid(
                        &(Item->NotifyInfo.AuditInfo.MemberSid),
                        MemberSid
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        NtStatus = SampLoopbackTaskDupUnicodeString(
                        &(Item->NotifyInfo.AuditInfo.AccountName),
                        AccountName
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        ASSERT(NULL != DomainName);
        NtStatus = SampLoopbackTaskDupUnicodeString(
                        &(Item->NotifyInfo.AuditInfo.DomainName),
                        DomainName
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        NtStatus = SampLoopbackTaskDupUlong(
                        &(Item->NotifyInfo.AuditInfo.AccountRid),
                        AccountRid
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        NtStatus = SampLoopbackTaskDupPrivileges(
                        &(Item->NotifyInfo.AuditInfo.Privileges),
                        Privileges
                        );

        if (!NT_SUCCESS(NtStatus))
            goto Error;

        //
        // Add to the thread state
        // 
        if ( !SampAddLoopbackTask(Item) )
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

Error:

    if (!NT_SUCCESS(NtStatus) && Item)
    {
        SampFreeLoopbackAuditInfo(&(Item->NotifyInfo.AuditInfo));
        THFree(Item);
    }

    return( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\log.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    log.c

Abstract:

    Implementation of the internal debug and support routines

Author:

    Colin Brace              April 26, 2001

Environment:

    User Mode

Revision History:

--*/

#include <samsrvp.h>

//
// Global handle to the log file
//
HANDLE SampLogFile = NULL;
CRITICAL_SECTION SampLogFileCriticalSection;

#define LockLogFile()    RtlEnterCriticalSection( &SampLogFileCriticalSection );
#define UnlockLogFile()  RtlLeaveCriticalSection( &SampLogFileCriticalSection );

NTSTATUS
SampEnableLogging(
    VOID
    );

VOID
SampDisableLogging(
    VOID
    );

//
// log file name
//
#define SAMP_LOGNAME L"\\debug\\sam.log"


NTSTATUS
SampInitLogging(
    VOID
    )
/*++

Routine Description:

    This routine initalizes the resources necessary for logging support.

Arguments:

    None.

Return Value:

    None.            

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    __try
    {
        NtStatus = RtlInitializeCriticalSection(
                        &SampLogFileCriticalSection
                        );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return NtStatus;
}

VOID
SampLogLevelChange(
    HANDLE hLsaKey
    )
/*++

Routine Description:

    This routine is called when the configuration section in the registry
    for SAM is changed.  The logging level is read in and adjusted in
    memory if necessary.

Arguments:

    hLsaKey -- a valid registry key

Return Value:

    None.

--*/
{
    DWORD WinError;
    DWORD dwSize, dwType, dwValue;
    ULONG PreviousLogLevel = SampLogLevel;

    dwSize = sizeof(dwValue);
    WinError = RegQueryValueExA(hLsaKey,
                               "SamLogLevel",
                               NULL,
                               &dwType,
                               (LPBYTE)&dwValue,
                               &dwSize);
    if ((ERROR_SUCCESS == WinError) &&
        (REG_DWORD == dwType)) {
    
        SampLogLevel = dwValue;

    } else {

        SampLogLevel = 0;

    }

    if (PreviousLogLevel != SampLogLevel) {

        //
        // Settings have changed
        //
        if (SampLogLevel == 0) {
    
            //
            // Logging has been turned off; close log file
            //
            SampDisableLogging();

        } else if (PreviousLogLevel == 0) {
            //
            // Logging has been turned on; open log file
            //
            SampEnableLogging();
        }
    }

    return;

}


NTSTATUS
SampEnableLogging(
    VOID
    )
/*++

Routine Description:

    Initializes the debugging log file.
    
Arguments:

    None

Returns:

    STATUS_SUCCESS, STATUS_UNSUCCESSFUL
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;

    WCHAR LogFileName[ MAX_PATH + 1 ];
    BOOLEAN fSuccess;

    LockLogFile();

    if (SampLogFile == NULL) {

        //
        // Construct the log file name
        //
        if ( !GetWindowsDirectoryW(LogFileName, ARRAY_COUNT(LogFileName))) {
            WinError = GetLastError();
            goto Exit;
        }
        wcscat( LogFileName, SAMP_LOGNAME );
    
        //
        // Open the file, ok if it already exists
        //
        SampLogFile = CreateFileW( LogFileName,
                                   GENERIC_WRITE,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL );
    
        if ( SampLogFile == INVALID_HANDLE_VALUE ) {
            WinError = GetLastError();
            SampLogFile = NULL;
            goto Exit;
        }
    
        //
        // Goto to the end of the file
        //
        if( SetFilePointer( SampLogFile,
                            0, 
                            0,
                            FILE_END ) == 0xFFFFFFFF ) {
    
            WinError = GetLastError();
            goto Exit;
        }
    }

Exit:

    if ( (ERROR_SUCCESS != WinError)
      && (NULL != SampLogFile)   ) {

        CloseHandle( SampLogFile );
        SampLogFile = NULL;
        
    }

    UnlockLogFile();

    return (WinError == ERROR_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}

VOID
SampDisableLogging(
    VOID
    )
/*++

Routine Description:

    Closes the debugging log file.

Arguments:

    None.

Returns:

    None.

--*/
{
    LockLogFile();

    if (SampLogFile != NULL) {
        FlushFileBuffers( SampLogFile );
        CloseHandle( SampLogFile );
        SampLogFile = NULL;
    }

    UnlockLogFile();
}

VOID
SampDebugDumpRoutine(
    IN ULONG LogLevel,
    IN LPSTR Format,
    va_list arglist
    )
/*++

Routine Description:

    This routine dumps the string specified by the caller to the log file
    if open.
    
Arguments:

    LogLevel -- the component making to request
                          
    Format, arglist -- arguments for a formatted output routine.

Return Value:

    None.
    
--*/

{
    CHAR OutputBuffer[1024];
    ULONG length;
    DWORD BytesWritten;
    SYSTEMTIME SystemTime;
    static BeginningOfLine = TRUE;

    length = 0;


    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        CHAR  *Prolog;

        if (LogLevel & SAMP_LOG_ACCOUNT_LOCKOUT) {
            Prolog = "Lockout: ";
        } else {
            Prolog = "";
        }

        //
        // Put the timestamp at the begining of the line.
        //
        GetLocalTime( &SystemTime );
        length += (ULONG) sprintf( &OutputBuffer[length],
                                   "%02u/%02u %02u:%02u:%02u %s",
                                   SystemTime.wMonth,
                                   SystemTime.wDay,
                                   SystemTime.wHour,
                                   SystemTime.wMinute,
                                   SystemTime.wSecond,
                                   Prolog );
    }

    //
    // Put a the information requested by the caller onto the line
    //
    length += (ULONG) vsprintf(&OutputBuffer[length],
                               Format, 
                               arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == L'\n' );
    if ( BeginningOfLine ) {

        OutputBuffer[length-1] = L'\r';
        OutputBuffer[length] = L'\n';
        OutputBuffer[length+1] = L'\0';
        length++;
    }

    ASSERT( length <= sizeof( OutputBuffer ) / sizeof( WCHAR ) );

    //
    // Grab the lock
    //
    LockLogFile();

    //
    // Write the debug info to the log file.
    //
    if (SampLogFile) {

        WriteFile( SampLogFile,
                   OutputBuffer,
                   length*sizeof(CHAR),
                   &BytesWritten,
                   NULL 
                   );
    }

    //
    // Release the lock
    //
    UnlockLogFile();

    return;

}

VOID
SampLogPrint(
    IN ULONG LogLevel,
    IN LPSTR Format,
    ...
    )
/*++

Routine Description:
    
    This routine is small variable argument wrapper for SampDebugDumpRoutine.        

Arguments:

    LogLevel -- the component making the logging request
                          
    Format, ... -- input to a format string routine.

Return Value:

    None.
    
--*/
{
    va_list arglist;

    va_start(arglist, Format);

    SampDebugDumpRoutine( LogLevel, Format, arglist );
    
    va_end(arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\notify.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    notify.h

Abstract:

    This file contains the byte stream definition used by SAM to pass
    information from a BDC to a PDC. The byte stream is passed along
    netlogon's secure channel mechanism.

    Currently, only password notification uses this stream.

Author:

    Colin Brace      (ColinBr)    28-April-98

Environment:

    User Mode - Win32

Revision History:


--*/

//
// This is the type data contained in the stream.  Each type
// is responsible for its own versioning.
//
typedef enum
{
    SamPdcPasswordNotification,
    SamPdcResetBadPasswordCount

} SAMI_BLOB_TYPE;


typedef struct _SAMI_SECURE_CHANNEL_BLOB
{
    SAMI_BLOB_TYPE  Type;      // One of the enums above
    ULONG           DataSize;  // sizeof Data in bytes
    DWORD           Data[1];   // The start of the data

} SAMI_SECURE_CHANNEL_BLOB, *PSAMI_SECURE_CHANNEL_BLOB;

//
// Password notification blobs
//

//
// Complementary flags defining what fields are present in the
// password notification
//
#define SAM_ACCOUNT_NAME_PRESENT        ((ULONG)0x00000001)
#define SAM_CLEAR_TEXT_PRESENT          ((ULONG)0x00000002)
#define SAM_LM_OWF_PRESENT              ((ULONG)0x00000004)
#define SAM_NT_OWF_PRESENT              ((ULONG)0x00000008)
#define SAM_ACCOUNT_UNLOCKED            ((ULONG)0x00000010)
#define SAM_MANUAL_PWD_EXPIRY           ((ULONG)0x00000020)

#define SAM_VALID_PDC_PUSH_FLAGS        (SAM_ACCOUNT_NAME_PRESENT |     \
                                         SAM_CLEAR_TEXT_PRESENT   |     \
                                         SAM_LM_OWF_PRESENT       |     \
                                         SAM_NT_OWF_PRESENT       |     \
                                         SAM_ACCOUNT_UNLOCKED     |     \
                                         SAM_MANUAL_PWD_EXPIRY)
typedef struct _SAMI_PASSWORD_INDEX
{
    ULONG               Offset;  // offset from SAMI_PASSWORD_INFO::Data
    ULONG               Length;  // length in bytes

} SAMI_PASSWORD_INDEX, *PSAMI_PASSWORD_INDEX;

typedef struct _SAMI_PASSWORD_INFO
{
    ULONG               Flags;         // Bits describing what fields are filled in
    ULONG               Size;          // Size in bytes of this header, including
                                       // tailing dynamic array
    ULONG               AccountRid;
    BOOLEAN             PasswordExpired;
    SAMI_PASSWORD_INDEX DataIndex[1];  // Dynamic array of SAMI_PASSWORD_INDEX

} SAMI_PASSWORD_INFO, *PSAMI_PASSWORD_INFO;

typedef struct _SAMI_BAD_PWD_COUNT_INFO
{
    GUID                ObjectGuid;
} SAMI_BAD_PWD_COUNT_INFO, *PSAMI_BAD_PWD_COUNT_INFO;

//
// moved out from notify.c
// private service type, used by notify.c and usrparms.c only.
// 

typedef struct _SAMP_CREDENTIAL_UPDATE_NOTIFY_PARAMS
{
    UNICODE_STRING CredentialName;

}SAMP_CREDENTIAL_UPDATE_NOTIFY_PARAMS, *PSAMP_CREDENTIAL_UPDATE_NOTIFY_PARAMS;

typedef struct _SAMP_NOTIFICATION_PACKAGE {
    struct _SAMP_NOTIFICATION_PACKAGE * Next;
    UNICODE_STRING PackageName;

    union {

        SAMP_CREDENTIAL_UPDATE_NOTIFY_PARAMS CredentialUpdateNotify;

    } Parameters;

    PSAM_PASSWORD_NOTIFICATION_ROUTINE PasswordNotificationRoutine;
    PSAM_DELTA_NOTIFICATION_ROUTINE DeltaNotificationRoutine;
    PSAM_PASSWORD_FILTER_ROUTINE PasswordFilterRoutine;
    PSAM_USERPARMS_CONVERT_NOTIFICATION_ROUTINE UserParmsConvertNotificationRoutine;
    PSAM_USERPARMS_ATTRBLOCK_FREE_ROUTINE UserParmsAttrBlockFreeRoutine;
    PSAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE CredentialUpdateNotifyRoutine;
    PSAM_CREDENTIAL_UPDATE_FREE_ROUTINE CredentialUpdateFreeRoutine;
} SAMP_NOTIFICATION_PACKAGE, *PSAMP_NOTIFICATION_PACKAGE;


extern PSAMP_NOTIFICATION_PACKAGE SampNotificationPackages;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\nametbl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    nametbl.c

Abstract:

    This file contains routines to manage SAM Account Name Table

    SAM Account Name Table is used to maintain SAM Account Name Uniqueness.
    The way it works is described as follows. 
    
    We will use SAM AccountNameTable to store the AccountNames which are 
    picked up by those non-committed threads. When a client wants to create a 
    new SAM account with name A, SAM server should first scan AccountNameTable, 
    to see whether name A has been in the table already or not yet. 
    If name A has been in AccountNameTable already, that means the this 
    particular account Name has been used by another client, even the other 
    client doesn't commit yet. Then SAM returns STATUS_USER_EXISTS (or 
    STATUS_GROUP_EXISTS respectly) immediately. Otherwise if the account name 
    is not in the table, we will insert Name A into the AccountNameTable. 
    Then continue to do a DS Search based on the new AccountName ( Name A )
    against the DS database. 

    Once we have done with the account creation, either succeed or fail for
    some reason, SAM needs to remove the account name from AccountNameTable
    if necessary.

    1. The above scheme works in both loopback case and down-level APIs.
    
    2. SAM Account Name Table is only being used in DS case

    3. The AccountNameTable should be protected by a critical section to 
       serialize all in-memory operation.  The actual implementation will use 
       RtlGenericTable2. 


Author:

    Shaohua Yin    (ShaoYin)  01-March-2000

Environment:

    User Mode - Win32

Revision History:

    01-March-2000: SHAOYIN  Create init file


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>
#include <mappings.h>
#include <ntlsa.h>
#include <nlrepl.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()
#include <sdconvrt.h>
#include <ridmgr.h>
#include <malloc.h>
#include <setupapi.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>





PVOID
SampAccountNameTableAllocate(
    ULONG   BufferSize
    )
/*++
Routine Description:

    This routine is used by RtlGenericTable2 to allocate memory
    
Parameters:

    BufferSize
    
Return Value:

    Address of the allocated memory        
--*/
{
    PVOID   Buffer = NULL;

    Buffer = MIDL_user_allocate(BufferSize);

    return( Buffer );
}

VOID
SampAccountNameTableFree(
    PVOID   Buffer
    )
/*++

Routine Description:

    RtlGenericTable2 memory release routine

--*/
{
    MIDL_user_free(Buffer);

    return;
}


RTL_GENERIC_COMPARE_RESULTS
SampAccountNameTableCompare(
    PVOID   Node1,
    PVOID   Node2
    )
/*++

Routine Description:

    RtlGenericTable2 node comparsion routine
    
Parameters:

    Node1 - pointer to the first element 
    
    Node2 - pointer the the second element to compare

Return Value:

    GenericGreaterThan
    GenericLessThan
    GenericEqual    

--*/
{
    PUNICODE_STRING AccountName1 = NULL;
    PUNICODE_STRING AccountName2 = NULL;
    LONG    NameComparison;

    AccountName1 = (PUNICODE_STRING) 
                    &(((SAMP_ACCOUNT_NAME_TABLE_ELEMENT *)Node1)->AccountName);
    AccountName2 = (PUNICODE_STRING) 
                    &(((SAMP_ACCOUNT_NAME_TABLE_ELEMENT *)Node2)->AccountName);

    NameComparison = SampCompareDisplayStrings(AccountName1, 
                                               AccountName2, 
                                               TRUE
                                               );

    if (NameComparison > 0) {
        return(GenericGreaterThan);
    }

    if (NameComparison < 0) {
        return(GenericLessThan);
    }

    return(GenericEqual);

}



NTSTATUS
SampInitializeAccountNameTable(
    )
/*++
Routine Description:

    This routine initializes the SAM AccountNameTable
    
    1. Initialize Critical Section
    
    2. Initialize AccountNameTable

Parameter:

    None
    
Return Value:

    NTSTATUS Code    

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

    SampAccountNameTableCritSect = &SampAccountNameTableCriticalSection;

    __try
    {
        NtStatus = RtlInitializeCriticalSectionAndSpinCount(
                        SampAccountNameTableCritSect,
                        100
                        );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    IgnoreStatus = RtlEnterCriticalSection( SampAccountNameTableCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    RtlInitializeGenericTable2(
                &SampAccountNameTable, 
                SampAccountNameTableCompare, 
                SampAccountNameTableAllocate,
                SampAccountNameTableFree
                );

    IgnoreStatus = RtlLeaveCriticalSection( SampAccountNameTableCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    return( NtStatus );
}


NTSTATUS
SampDeleteElementFromAccountNameTable(
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    )
/*++

Routine Description:

    This routine deletes an element from the SAMAccountNameTable based upon
    the account name. So find the element first based on the account name, 
    then remove it. Don't forget to release memory.    

    
Parameters:

    AccountName -- AccountName of the element to remove     

    ObjectType -- Object Type of the element to remove

Return Value:
    
    NTSTATUS Code    

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     Success = FALSE;


    NtStatus = RtlEnterCriticalSection( SampAccountNameTableCritSect );
    ASSERT(NT_SUCCESS(NtStatus));

    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }

    __try
    {
        SAMP_ACCOUNT_NAME_TABLE_ELEMENT Element;
        SAMP_ACCOUNT_NAME_TABLE_ELEMENT *TempElement = NULL;

        //
        // fill the Element need to be looked up
        // 
        Element.AccountName.Length = AccountName->Length;
        Element.AccountName.Buffer = AccountName->Buffer;
        Element.AccountName.MaximumLength = AccountName->MaximumLength;
        Element.ObjectType = ObjectType;

        //
        // Lookup the AccountName in table
        // 
        TempElement = RtlLookupElementGenericTable2(
                            &SampAccountNameTable,
                            &Element
                            );
        ASSERT(TempElement && "Account Name is not in the AccountNameTable");

        if (TempElement)
        {
            //
            // We got the Account Name, it should match the object type
            // 
            ASSERT(ObjectType == TempElement->ObjectType);

            //
            // go ahead remove the element from the table
            // 
            Success = RtlDeleteElementGenericTable2(
                            &SampAccountNameTable,
                            &Element 
                            );
            ASSERT(Success);
            
            //
            // free memory
            // 
            MIDL_user_free(TempElement->AccountName.Buffer);
            MIDL_user_free(TempElement);
        }
    }
    __finally
    {
        RtlLeaveCriticalSection( SampAccountNameTableCritSect );
    }

    return(NtStatus);
}



NTSTATUS
SampCheckAccountNameTable(
    IN PSAMP_OBJECT    Context,
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    )
/*++

Routine Description:

    This routines checks the existence of the AccountName against the 
    SAMAccountNameTable by inserting the AccountName into the table. 

    if the insertion succeeded, that means no duplicate AccountName 
    in the table, return success after registrying "remove account name
    from table" task. 
    
    if the insertion failed, then lookup the duplicate element, get it's
    object type, return error code based upon the object type. 
    
    Explanation about "remove account name from table" task. Once this 
    routine inserts the AccountName into the table, we have to remember
    to clean it up once we finish this transaction no matter the 
    transaction is committed or aborted. 
        

Paramenters:

    Context - Object Context
    
    AccountName - Account Name of the target object
    
    ObjectType - Object Type of the target object 

Return Values:

    NTSTATUS Code

    STATUS_SUCCESS
    STATUS_USER_EXISTS
    STATUS_GROUP_EXISTS
    STATUS_ALIAS_EXISTS
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     fNewElement = TRUE;
    BOOLEAN     Success = FALSE;
    SAMP_ACCOUNT_NAME_TABLE_ELEMENT *Element = NULL;

    //
    // allocate memory
    // 
    Element = MIDL_user_allocate(sizeof(SAMP_ACCOUNT_NAME_TABLE_ELEMENT));
    
    if (NULL == Element)
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    RtlZeroMemory(Element, sizeof(SAMP_ACCOUNT_NAME_TABLE_ELEMENT));

    //
    // dup the account name
    // 
    NtStatus = SampDuplicateUnicodeString(&(Element->AccountName), 
                                          AccountName
                                          );
    
    if (!NT_SUCCESS(NtStatus))
    {
        MIDL_user_free(Element);
        return( NtStatus );
    }

    //
    // Set the object Type
    // 
    Element->ObjectType = ObjectType;


    // 
    // enter critical section
    // 
    NtStatus = RtlEnterCriticalSection( SampAccountNameTableCritSect );
    ASSERT(NT_SUCCESS(NtStatus));

    if (!NT_SUCCESS(NtStatus))
    {
        MIDL_user_free(Element->AccountName.Buffer);
        MIDL_user_free(Element);
        return( NtStatus );
    }

    __try {

        (VOID) RtlInsertElementGenericTable2(
                    &SampAccountNameTable, 
                    Element,
                    &fNewElement
                    );


        if (!fNewElement)
        {
            SAMP_ACCOUNT_NAME_TABLE_ELEMENT *OldElement = NULL;
            //
            // someone either has used this Account Name already, 
            // Lookup the table, get the object type, so that we
            // can return clear error code.
            // 
            OldElement = RtlLookupElementGenericTable2(
                                &SampAccountNameTable,
                                Element
                                );
            ASSERT(OldElement && "AccountNameTable Lookup Failed");

            if (OldElement)
            {
                switch (OldElement->ObjectType)
                {
                case SampUserObjectType:

                    NtStatus = STATUS_USER_EXISTS;
                    break;

                case SampGroupObjectType:

                    NtStatus = STATUS_GROUP_EXISTS;
                    break;

                case SampAliasObjectType:

                    NtStatus = STATUS_ALIAS_EXISTS;
                    break;

                default:

                    ASSERT(FALSE && "Wrong Object Type in Account Name Table");
                    NtStatus = STATUS_USER_EXISTS;
                }
            }
            else
            {
                //
                // We were told the Account Name already exists, but 
                // can't find the element in the table, so just
                // return the following (not precious) error code.
                // 
                NtStatus = STATUS_USER_EXISTS;
            }
            MIDL_user_free(Element->AccountName.Buffer);
            MIDL_user_free(Element);
        }
        else
        {
            //
            // Loopback clients need to remove the account name
            // from the table when they either commit or abort 
            // the DS transaction. 
            // 
            // The caller of this routine should do the job
            //

            if (Context->LoopbackClient)
            {
                NtStatus = SampAddLoopbackTaskDeleteTableElement(
                                AccountName, 
                                ObjectType
                                );

                if (!NT_SUCCESS(NtStatus))
                {
                    SAMP_ACCOUNT_NAME_TABLE_ELEMENT *TempElement = NULL;

                    //
                    // if failed, need to remove the account
                    // name from the table and release the resources
                    // 

                    TempElement = RtlLookupElementGenericTable2(
                                        &SampAccountNameTable,
                                        Element
                                        );
                    ASSERT(TempElement);

                    if (TempElement)
                    {
                        Success = RtlDeleteElementGenericTable2(
                                        &SampAccountNameTable,
                                        Element
                                        );
                        ASSERT(Success);

                        MIDL_user_free(TempElement->AccountName.Buffer);
                        MIDL_user_free(TempElement);
                    }

                }
            }
            else
            {
                // 
                // Mark the variable in Context to TRUE, so that
                // the caller will remove the name from table 
                // before exit.
                //  
                Context->RemoveAccountNameFromTable = TRUE;
            }
        }
    }
    __finally
    {
        RtlLeaveCriticalSection( SampAccountNameTableCritSect );
    }

    return( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\lsathunk.h ===
/*++

lsathunk.h

Header file for the thunk layer for accessing the LSA through the 
published NTLSAPI when SAM runs in user mode. User mode SAM is acomplished
by building with USER_MODE_SAM enabled. This causes all the SAM calls to
the LSA be remoted through the published NTLSAPI.

Author: Murlis 4/30/96

Revision History
   Murlis 4/30/96  
        Created

--*/

#ifndef	_LSATHUNK_
#define _LSATHUNK_

#ifdef USER_MODE_SAM


#define LSAPR_HANDLE      LSA_HANDLE
#define PLSAPR_HANDLE     PLSA_HANDLE
// Why is this void'ed?
// #define PLSAPR_POLICY_INFORMATION       PVOID

//++ Function prototypes for the Thunk Layer.

NTSTATUS	LsaThunkIAuditSamEvent(
						IN NTSTATUS             PassedStatus,
						IN ULONG                AuditId,
						IN PSID                 DomainSid,
						IN PULONG               MemberRid         OPTIONAL,
						IN PSID                 MemberSid         OPTIONAL,
						IN PUNICODE_STRING      AccountName       OPTIONAL,
						IN PUNICODE_STRING      DomainName,
						IN PULONG               AccountRid        OPTIONAL,
						IN PPRIVILEGE_SET       Privileges        OPTIONAL
						);

NTSTATUS	LsaThunkIOpenPolicyTrusted(
						OUT PLSAPR_HANDLE PolicyHandle
						);


NTSTATUS	LsaThunkIFree_LSAPR_POLICY_INFORMATION(
						POLICY_INFORMATION_CLASS InformationClass,
						PLSAPR_POLICY_INFORMATION PolicyInformation
						);

 
NTSTATUS	LsaThunkIAuditNotifyPackageLoad(
						PUNICODE_STRING PackageFileName
						);


NTSTATUS	LsaThunkrQueryInformationPolicy(
						IN LSAPR_HANDLE PolicyHandle,
						IN POLICY_INFORMATION_CLASS InformationClass,
						OUT PLSAPR_POLICY_INFORMATION *Buffer
						);

NTSTATUS	LsaThunkrClose(
						IN OUT LSAPR_HANDLE *ObjectHandle
						);

NTSTATUS	LsaThunkIQueryInformationPolicyTrusted(
						IN POLICY_INFORMATION_CLASS InformationClass,
						OUT PLSAPR_POLICY_INFORMATION *Buffer
						);

NTSTATUS	LsaThunkIHealthCheck(
						IN  ULONG CallerId
						);

// Redifine the SAM functions that call LSA to go through
// the thunk layer.

	
#define LsaIAuditSamEvent(\
							PassedStatus,\
							AuditId,\
							DomainSid,\
							MemberRid,\
							MemberSid,\
							AccountName,\
                            Domain,\
							AccountRid,\
							Privileges)\
		LsaThunkIAuditSamEvent(\
							PassedStatus,\
							AuditId,\
							DomainSid,\
							MemberRid,\
							MemberSid,\
							AccountName,\
                            Domain,\
							AccountRid,\
							Privileges)

#define LsaIOpenPolicyTrusted(\
							PolicyHandle)\
		LsaThunkIOpenPolicyTrusted(\
							PolicyHandle)

	
#define LsaIFree_LSAPR_POLICY_INFORMATION(\
							InformationClass,\
							PolicyInformation)\
		LsaThunkIFree_LSAPR_POLICY_INFORMATION(\
							InformationClass,\
							PolicyInformation)
 
	
#define LsaIAuditNotifyPackageLoad(\
							PackageFileName)\
		LsaThunkIAuditNotifyPackageLoad(\
							PackageFileName)
 
	
#define LsarQueryInformationPolicy(\
							PolicyHandle,\
							InformationClass,\
							Buffer)\
		LsaThunkrQueryInformationPolicy(\
							PolicyHandle,\
							InformationClass,\
							Buffer)


	 
#define LsarClose(\
			ObjectHandle)\
		LsaThunkrClose(\
			ObjectHandle)
    
#define LsaIQueryInformationPolicyTrusted(\
									InformationClass,\
									Buffer)\
		LsaThunkIQueryInformationPolicyTrusted(\
									InformationClass,\
									Buffer)
#define LsaIHealthCheck(\
			CallerId)\
		LsaThunkIHealthCheck(\
			CallerId)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\lock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    lock.c

Abstract:

    This file contains routines to manage SAM Lock, these services (acquire / 
    release lock) are used by the rest of SAM.

    Below is the theory which describes the transaction mode 

    1) For loopback clients, they are limited to 3 SAM operations only,

            1. Account Creation
            2. Account Modification 
            3. Account Removal

        Because the transaction is originated and committed / aborted 
        (controlled) by DS, so SAM doesn't need to maintain the transaction. 
        Therefore SAM Lock is not required when doing the above three loopback 
        operations.  

        So in the corresponding SAM code path, we should always use 
        SampMaybeAcquireWriteLock() and SampMaybeReleaseWriteLock(). 

        In the middle of transaction (for loopback client), if the caller 
        needs to read account information, SampMaybeAcquireReadLock() and
        SampMaybeReleaseReadLock() should be used. 

        However, loopback clients still need to access certain SAM global 
        (or in memory) information, such as SampDefinedDomains[]. If the 
        information is initialized during system startup time, and never
        change afterworth, loopback clients can retrieve them without SAM
        lock. Otherwise, if the global information could be updated by 
        other threads, then loopback clients has to grab SAM lock before 
        any read / write operation. In this case, SampAcquireSamLockExclusive()
        and SampReleaseSamLockExclusive() should be used.  

            Correct Sequence
                
                Begin DS transaction (by Loopback)
                SampMaybeAcquireWriteLock() 
                SampMaybeReleaseWriteLock() pair
                End DS transaction (by loopback) 

            Usually, caller should not try to acquire SAM lock if he has 
            an open DS transaction. If SAM lock is required to hold to 
            access SAM database, then SampAcquireSamLockExclusive() should
            be used. 

        Note: Should not SampTransactionWithinDomain in loopback case.
         

    2) For all the other clients

       The transaction is maintained by SAM.

       READ - If the service doesn't refer to any global (or in memory) SAM
              information, such as SampDefinedDomains[], the caller needs to 
              use SampMaybeAcquireReadLock() and SampMaybeReleaseReadLock().
              In the other words, those callers do not set 
              TransactionWithinDomain. described in detail 

                  Registry Mode: 

                      SAM Lock is always acquired 

                  DS Mode:

                      user / group / alias object are marked NotSharedByMultiThreads, 
                      so SAM Lock is not required. Also SAM Lock is not required 
                      for reading domain object info. 


              If the service DOES refer to the global SAM variables and
              requires the SampTransactionWithinDomain to be set. Then in 
              those code path, SampAcquireReadLock() and SampReleaseReadLock()
              need to be used. So that we can make sure 
              1. no other thread will update the variables being referenced. 
              2. SAM maintains the transaction for the whole READ operation.
              

       WRITE - Since SAM is responsible to maintain the transaction, either
               commit if success or rollback for any failure. SAM Lock is 
               always a requirement. It will simplify the following problems

               1. usage of SampTransactionWithinDomain
               2. Write Conflict of global SAM variable

           Correct Sequence
           
               SampAcquireReadLock() or SampAcquireWriteLock()
               Begin Transaction (RXAct or DS Transaction)
               End Transaction (either commit or abort)
               SampReleaseReadLock() or SampReleaseWriteLock()

        For the correct usage of SampTransactionWithinDomain, please refer to 
        SampTransactionWithinDomainFn() in utility.c  
         
              
               
    

Author:

    Shaohua Yin    (ShaoYin)  01-March-2000

Environment:

    User Mode - Win32

Revision History:

    01-March-2000: SHAOYIN  Moved SAM Lock routines from utility.c


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>
#include <mappings.h>
#include <ntlsa.h>
#include <nlrepl.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()
#include <sdconvrt.h>
#include <ridmgr.h>
#include <malloc.h>
#include <setupapi.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Globals                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// Variables for tracking Sam Lock Usage
//

ULONG   SamLockQueueLength=0;
ULONG   SamLockAverageWaitingTime=0; // in ticks
ULONG   SamLockTotalAquisitions=0;
ULONG   SamCumulativeWaitTime=0;
ULONG   SamCumulativeHoldTime=0;
ULONG   SamLockCurrentHoldStartTime=0; // Tickcount just after acquire
ULONG   SamLockAverageHoldTime=0; // in ticks



//
// Macros for acquring Sam lock statistics
//

#define SAMLOCK_STATISTICS_BEFORE_ACQUIRE(WaitInterval)\
    _SamLockStatisticsBeforeAcquire(WaitInterval)

VOID
_SamLockStatisticsBeforeAcquire(PULONG WaitInterval)
{
    *WaitInterval = GetTickCount();
    InterlockedIncrement(&SamLockQueueLength);
}

#define SAMLOCK_STATISTICS_AFTER_ACQUIRE(WaitInterval)\
    _SamLockStatisticsAfterAcquire(WaitInterval)

VOID
_SamLockStatisticsAfterAcquire(ULONG WaitInterval)
{
    InterlockedDecrement(&SamLockQueueLength);
    SamLockCurrentHoldStartTime = GetTickCount();
    WaitInterval = SamLockCurrentHoldStartTime-WaitInterval;
    SamLockTotalAquisitions++;
    if ((WaitInterval>0) && (SamLockTotalAquisitions!=0))
    {
        SamCumulativeWaitTime+=WaitInterval;
        SamLockAverageWaitingTime=
            SamCumulativeWaitTime/SamLockTotalAquisitions;
    }
}

#define SAMLOCK_STATISTICS_BEFORE_RELEASE _SamLockStatisticsBeforeRelease()

VOID
_SamLockStatisticsBeforeRelease()
{
    LONG HoldInterval = GetTickCount();
    HoldInterval = HoldInterval - SamLockCurrentHoldStartTime;
    if ((HoldInterval>0) && (SamLockTotalAquisitions!=0))
    {
        SamCumulativeHoldTime+=HoldInterval;
        SamLockAverageHoldTime=
            SamCumulativeHoldTime/SamLockTotalAquisitions;
    }
}





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Database/registry access lock services                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




VOID
SampAcquireReadLock(
    VOID
    )

/*++

Routine Description:

    This routine obtains read access to the SAM data structures and
    backing store.

    Despite its apparent implications, read access is an exclusive access.
    This is to support the model set up in which global variables are used
    to track the "current" domain.  In the future, if performance warrants,
    a read lock could imply shared access to SAM data structures.

    The primary implication of a read lock at this time is that no
    changes to the SAM database will be made which require a backing
    store update.


Arguments:

    None.

Return Value:


    None.


--*/
{
    BOOLEAN Success;

    SAMTRACE("SampAcquireReadLock");

    if ( !SampUseDsData || !SampIsWriteLockHeldByDs() ) {

        //
        // Before changing this to a non-exclusive lock, the display information
        // module must be changed to use a separate locking mechanism. Davidc 5/12/92
        //
        LONG WaitInterval;
        SAMLOCK_STATISTICS_BEFORE_ACQUIRE(&WaitInterval);

        Success = RtlAcquireResourceExclusive( &SampLock, TRUE );

        SAMLOCK_STATISTICS_AFTER_ACQUIRE(WaitInterval);

        ASSERT(Success);
        ASSERT(SampLockHeld==FALSE);
        ASSERT((!SampUseDsData)||(!SampExistsDsTransaction()));
        SampLockHeld = TRUE;

        SampDsTransactionType = TransactionRead;

    }

    return;
}


VOID
SampReleaseReadLock(
    VOID
    )

/*++

Routine Description:

    This routine releases shared read access to the SAM  data structures and
    backing store.


Arguments:

    None.

Return Value:


    None.


--*/
{

    NTSTATUS   IgnoreStatus;

    SAMTRACE("SampReleaseReadLock");

    ASSERT(SampLockHeld==TRUE);

    if ( SampUseDsData && SampIsWriteLockHeldByDs() ) {

        //
        // If write lock is held, only reset domain transaction flag.
        //

        SampSetTransactionWithinDomain(FALSE);

    } else {

        SampSetTransactionWithinDomain(FALSE);
        SampLockHeld = FALSE;

        //
        // Commit the transaction, Commit is faster than Rollback
        // so we always prefer a commit even though there are no
        // changes
        //

        if (SampDsInitialized) {
            IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        SAMLOCK_STATISTICS_BEFORE_RELEASE ;

        RtlReleaseResource( &SampLock );
    }

    return;
}

VOID
SampMaybeAcquireReadLock(
    IN PSAMP_OBJECT Context,
    IN ULONG  Control,
    OUT BOOLEAN * fLockAcquired
    )
/*++

Routine Description

    This routine encapsulate all the logic for a conditional SAM lock acquire. If the
    following conditions are satisfied, then we do not acquire the lock. 
    
    1. Context that is passed in is marked NotSharedByMultiThreads in DS Mode.
       
    2. OR it is a domain object in DS case and the caller routine explicitly 
       indicates the lock is not required. 
    
Parameters

    Context - SAM context, used to decide if the lock is supposed to be acquired

    Control - Runtime variable that allow the caller to control how SAM lock is 
              acquired 
    
    fLockAcquired -- Out parameter, a boolean indicating whether the SAM lock was indeed acquired

Return Value

    None    

--*/
{
    NTSTATUS NtStatus;
    BOOLEAN NoNeedToAcquireLock = FALSE;
    BOOLEAN ContextValid = TRUE;

    *fLockAcquired = FALSE;

    //
    // Make sure the passed context address is (still) valid.
    //

    NtStatus = SampValidateContextAddress( Context );
    if ( !NT_SUCCESS(NtStatus) ) {
        ContextValid = FALSE;
    }

    //
    // The lock is aquired provided any of the following is satisfied
    //


    if (ContextValid)
    {
        //
        // NotSharedByMultiTheads is always set for loopback client
        //

        ASSERT( !Context->LoopbackClient || Context->NotSharedByMultiThreads );

        // 
        // NotSharedByMultiThreads will be set for all User, Group and Alias contexts, 
        // and all domain and server contexts that do not originate from in 
        // process callers that share handles amongst threads. Routines 
        // manipulating a domain context that is shared across multiple threads, 
        // but do no real work on the domain context can still choose not to 
        // lock and be careful about Derefernce, those callers should use 
        // SampDeReferenceContext2.
        // 

        //
        // Based upon the above definition of NotSharedByMultiThreads, we
        // will not acquire SAM Lock for NotSharedByMultiThreads Contexts in DS mode. 
        // Lock is still acquired in Registry Mode to achieve transaction control. 
        // 
        // For routines manipulating a domain context that is shared across 
        // multi threads, they can choose not to acquire lock by indicating so, 
        // but they need to be very careful.
        // 

        NoNeedToAcquireLock = ((IsDsObject(Context) && Context->NotSharedByMultiThreads) || 
                               (IsDsObject(Context) 
                                    && (Control == DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED) 
                                    && (SampDomainObjectType == Context->ObjectType))
                               );
    }

    if (!NoNeedToAcquireLock || !ContextValid )
    {

        //
        // Its not a thread safe context, so just acquire the lock
        //

        SampAcquireReadLock();
        *fLockAcquired = TRUE;
    }
    else
    {
        //
        // We must be in DS mode
        //

        ASSERT(SampUseDsData);

        //
        // The context must be a DS mode context
        //

        ASSERT(IsDsObject(Context));


        ASSERT(!SampIsWriteLockHeldByDs());

        //
        // Increment the active thread count, so that we consider this thread
        // at shutdown time
        //

        SampIncrementActiveThreads();

    }
}





VOID
SampMaybeReleaseReadLock(
    IN BOOLEAN fLockAcquired
    )
/*++

    Releases the Read Lock if it had been acquired. Also ends any open transactions subject to
    loopback. This is the complementary function for SampMaybeReleaseReadLock

    Parameters

    fLockAcquired -- Tells if the lock had been acquired

--*/
{
    NTSTATUS    IgnoreStatus;

    if (fLockAcquired)
    {
        //
        // If the lock was acquired then just release the lock
        //

        SampReleaseReadLock();
    }
    else
    {
        //
        // Case of a thread Safe context.
        //

        //
        // We must be in DS mode
        //

        ASSERT(SampUseDsData);

        //
        // End the transaction. We should never fail to commit a
        // read only transaction.
        //

        IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Let shutdown handling logic know that we are done
        //

        SampDecrementActiveThreads();
    }
}



NTSTATUS
SampAcquireWriteLock(
    VOID
    )

/*++

Routine Description:

    This routine acquires exclusive access to the SAM  data structures and
    backing store.

    This access is needed to perform a write operation.

    This routine also initiates a new transaction for the write operation.


    NOTE:  It is not acceptable to acquire this lock recursively.  An
           attempt to do so will fail.


Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Indicates the write lock was acquired and the transaction
        was successfully started.

    Other values may be returned as a result of failure to initiate the
    transaction.  These include any values returned by RtlStartRXact().



--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampAcquireWriteLock");

    if ( SampUseDsData && SampIsWriteLockHeldByDs() ) {

        //
        // If write lock is held, only reset domain transaction flag.
        //

        SampSetTransactionWithinDomain(FALSE);

    } else {

        LONG WaitInterval;
        SAMLOCK_STATISTICS_BEFORE_ACQUIRE(&WaitInterval);

        (VOID)RtlAcquireResourceExclusive( &SampLock, TRUE );

        SAMLOCK_STATISTICS_AFTER_ACQUIRE(WaitInterval);

        ASSERT(SampLockHeld==FALSE);
        ASSERT((!SampUseDsData)||(!SampExistsDsTransaction()));

        SampLockHeld = TRUE;
        SampDsTransactionType = TransactionWrite;

        SampSetTransactionWithinDomain(FALSE);

        //
        // if we are not in DS mode Start the registry Transaction
        //

        if (!SampUseDsData)
        {
            NtStatus = RtlStartRXact( SampRXactContext );

            if (!NT_SUCCESS(NtStatus))
                goto Error;
        }

        return(NtStatus);


    Error:

        //
        // If the transaction failed, release the lock.
        //

        SampLockHeld = FALSE;

        SAMLOCK_STATISTICS_BEFORE_RELEASE ;

        (VOID)RtlReleaseResource( &SampLock );

        DbgPrint("SAM: StartRxact failed, status = 0x%lx\n", NtStatus);
    }

    return(NtStatus);
}



NTSTATUS
SampReleaseWriteLock(
    IN BOOLEAN Commit
    )

/*++

Routine Description:

    This routine releases exclusive access to the SAM  data structures and
    backing store.

    If any changes were made to the backstore while exclusive access
    was held, then this service commits those changes.  Otherwise, the
    transaction started when exclusive access was obtained is rolled back.

    If the operation was within a domain (which would have been indicated
    via the SampSetTransactionDomain() api), then the CurrentFixed field for
    that domain is added to the transaction before the transaction is
    committed.

    NOTE: Write operations within a domain do not have to worry about
          updating the modified count for that domain.  This routine
          will automatically increment the ModifiedCount for a domain
          when a commit is requested within that domain.



Arguments:

    Commit - A boolean value indicating whether modifications need to be
        committed in the backing store.  A value of TRUE indicates the
        transaction should be committed.  A value of FALSE indicates the
        transaction should be aborted (rolled-back).

Return Value:

    STATUS_SUCCESS - Indicates the write lock was released and the transaction
        was successfully commited or rolled back.

    Other values may be returned as a result of failure to commit or
    roll-back the transaction.  These include any values returned by
    RtlApplyRXact() or RtlAbortRXact().  In the case of a commit, it
    may also represent errors returned by RtlAddActionToRXact().




--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    ULONG           i;

    SAMTRACE("SampReleaseWriteLock");


    if ( SampUseDsData && SampIsWriteLockHeldByDs() ) {


        //
        // Logic should be same as commit and retain write lock
        //

        if (Commit)
            NtStatus = SampCommitAndRetainWriteLock();

        //
        // Reset domain transaction flag.
        //

        SampSetTransactionWithinDomain(FALSE);

    } else {

        //
        // Commit or rollback the transaction based upon the Commit parameter...
        //

        ASSERT(SampLockHeld==TRUE);

        if (Commit == TRUE) {

            NtStatus = SampCommitChanges();

        } else {

            // Rollback in either DS and registry
            if (SampUseDsData)
            {
                NtStatus = SampMaybeEndDsTransaction(TransactionAbort);
                ASSERT(NT_SUCCESS(NtStatus));
            }
            else
            {
                NtStatus = RtlAbortRXact( SampRXactContext );
                ASSERT(NT_SUCCESS(NtStatus));
            }
        }

        SampSetTransactionWithinDomain(FALSE);

        //
        // And free the  lock...
        //

        SampLockHeld = FALSE;

        SAMLOCK_STATISTICS_BEFORE_RELEASE ;

        (VOID)RtlReleaseResource( &SampLock );
    }

    return(NtStatus);
}



NTSTATUS
SampMaybeAcquireWriteLock(
    IN PSAMP_OBJECT Context,
    OUT BOOLEAN * fLockAcquired
    )
/*++

Routine Description


    This routine encapsulate all the logic for a conditional SAM lock acquire. If the
    following conditions are satisfied, then we do not acquire the lock. 
    
    1. Context that is passed in is marked Loopback Client then we do not 
       acquire the lock.
    
    This routine acquires exclusive access to the SAM  data structures and
    backing store if it is desired.


    If SAM Write Lock is required, this routine will also initiates a new 
    transaction for the write operation. 
    
    If SAM lock is not required, then we will increment SAM active thread count, 
    so that this thread will be considered at shutdown time. 
    

Parameters

    Context - SAM context, used to decide if the lock is supposed to be acquired
    fLockAcquired -- Out parameter, a boolean indicating whether the SAM 
                     lock was indeed acquired

Return Value

    NTSTATUS Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     NoNeedToAcquireLock = FALSE;
    BOOLEAN     ContextValid = TRUE;

    *fLockAcquired = FALSE;

    //
    // Make sure teh passed context address is (still) valid
    // 

    NtStatus = SampValidateContextAddress( Context );
    if (!NT_SUCCESS(NtStatus)) {
        ContextValid = FALSE;
    }

    //
    // The lock is acquired provided any of the following is satisfied
    //

    if (ContextValid)
    {
        NoNeedToAcquireLock = IsDsObject(Context) && (Context->LoopbackClient);
    }

    if (!NoNeedToAcquireLock || !ContextValid)
    {
        //
        // It's not a thread safe context, so just aquire the lock
        // 

        NtStatus = SampAcquireWriteLock();
        *fLockAcquired = TRUE;
    }
    else
    {
        //
        // We must be in DS mode
        // 
        ASSERT(SampUseDsData);

        //
        // The context must be a DS mode context
        // 
        ASSERT(IsDsObject(Context));


        // 
        // Increment the active thread count, so that we consider this thread
        // at shutdown time
        // 

        NtStatus = SampIncrementActiveThreads();
    }

    return( NtStatus );
}

NTSTATUS
SampMaybeReleaseWriteLock(
    IN BOOLEAN fLockAcquired,
    IN BOOLEAN Commit
    )
/*++

Routine Description:

    Releases the exclusive Write Lock if it had been acquired. 
    Also ends (either commit or abort) any open transactions.
    This is the complementary function for SampMaybeReleaseWriteLock

    If Commit is TRUE, then this service commits all changes. Otherwise, 
    all changes since the transaction is started would be rolled back. 


Arguments:

    fLockAcquired -- Tells if the lock had been acquired

    Commit - A boolean value indicating whether modifications need to be
        committed in the backing store.  A value of TRUE indicates the
        transaction should be committed.  A value of FALSE indicates the
        transaction should be aborted (rolled-back).

Return Value:

    STATUS_SUCCESS - Indicates the write lock was released and the transaction
        was successfully commited or rolled back.

    Other values may be returned as a result of failure to commit or
    roll-back the transaction.  These include any values returned by
    RtlApplyRXact() or RtlAbortRXact().  In the case of a commit, it
    may also represent errors returned by RtlAddActionToRXact().


--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

    if (fLockAcquired)
    {
        //
        // if the lock was acquired then just release the write lock
        //

        ASSERT(SampCurrentThreadOwnsLock());

        NtStatus = SampReleaseWriteLock( Commit );;
    }
    else
    {
        //
        // Case of thread safe context.
        //  

        //
        // We must be in DS mode
        // 

        ASSERT(SampUseDsData);
        
        //
        // We do not hold lock
        // 

        ASSERT(!SampCurrentThreadOwnsLock());

        //
        // Commit or rollback the transaction based on the Commit parameter.
        // 

        if (TRUE == Commit)
        {
            NtStatus = SampCommitChanges();
        }
        else
        {
            NtStatus = SampMaybeEndDsTransaction(TransactionAbort);
            ASSERT(NT_SUCCESS(NtStatus));
        }

        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Let shutdown handling logic know that we are done
        // 
        
        SampDecrementActiveThreads();
    }

    return( NtStatus );
}


VOID
SampAcquireSamLockExclusive()
/*++
    Routine Description:

    This function grabs the SAM lock for exclusive access. It is different
    from the SampAcquireWriteLock function by the fact that it has no
    transaction semantics associated with it.

    Parameters;
        None

    Return Values:
        None
--*/
{
    if ( !SampUseDsData || !SampIsWriteLockHeldByDs() )
    {
        LONG WaitInterval;

        SAMLOCK_STATISTICS_BEFORE_ACQUIRE(&WaitInterval);

        (VOID) RtlAcquireResourceExclusive(&SampLock,TRUE);

        SAMLOCK_STATISTICS_AFTER_ACQUIRE(WaitInterval);

        ASSERT(SampLockHeld==FALSE);
        SampLockHeld = TRUE;
    }
}


VOID
SampReleaseSamLockExclusive()
/*++
    Routine Description:

    This function releases the SAM lock from exclusive access. It is different
    from the SampReleaseWriteLock function by the fact that it has no
    transaction semantics associated with it.

    Parameters;
        None

    Return Values:
        None
--*/
{
    if ( !SampUseDsData || !SampIsWriteLockHeldByDs() )
    {

        ASSERT(SampLockHeld==TRUE);
        SampLockHeld = FALSE;

        SAMLOCK_STATISTICS_BEFORE_RELEASE ;

        (VOID) RtlReleaseResource(&SampLock);
    }
}






NTSTATUS
SampCommitChanges(
    )

/*++

Routine Description:

    Thie service commits any changes made to the backstore while exclusive
    access was held.

    If the operation was within a domain (which would have been indicated
    via the SampSetTransactionDomain() api), then the CurrentFixed field for
    that domain is added to the transaction before the transaction is
    committed.

    NOTE: Write operations within a domain do not have to worry about
          updating the modified count for that domain.  This routine
          will automatically increment the ModifiedCount for a domain
          when a commit is requested within that domain.

    NOTE: When this routine returns any transaction will have either been
          committed or aborted. i.e. there will be no transaction in progress.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was successfully commited.

    Other values may be returned as a result of commital failure.

--*/

{
    NTSTATUS NtStatus, IgnoreStatus;
    BOOLEAN DomainInfoChanged = FALSE;
    BOOLEAN AbortDone = FALSE;
    BOOLEAN DsTransaction = FALSE;


    SAMTRACE("SampCommitChanges");

    NtStatus = STATUS_SUCCESS;

    //
    // If this transaction was within a domain then we have to:
    //
    //         (1) Update the ModifiedCount of that domain,
    //
    //         (2) Write out the CurrentFixed field for that
    //             domain (using RtlAddActionToRXact(), so that it
    //             is part of the current transaction).
    //
    //         (3) Commit the RXACT.
    //
    //         (4) If the commit is successful, then update the
    //             in-memory copy of the un-modified fixed-length data.
    //
    // Otherwise, we just do the commit.
    //

    if (SampTransactionWithinDomain == TRUE) {


            // It is a DS transaction if Its a Transaction within Domain
            // and the Domain object is a DS Object

        DsTransaction = IsDsObject(((SampDefinedDomains[SampTransactionDomainIndex]).Context));

        if ((SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ServerRole
            != DomainServerRoleBackup) && (!DsTransaction)) {

            //
            // Don't update the netlogon change log serial number on backup controllers;
            // the replicator will explicitly set the modified count. Do not update them
            // in DS mode either. The DS will provide change notifcations when the change
            // is actually commited. This will provide us with the notification.
            //

            SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart =
                SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart +
                1;




            //
            // Need to update the domain modified count
            //

            SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ModifiedCount =
                     SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber;


        }

        //
        // See if the domain information changed - if it did, we
        // need to add code to flush the change to disk
        //

        if ( RtlCompareMemory(
            &SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed,
            &SampDefinedDomains[SampTransactionDomainIndex].UnmodifiedFixed,
            sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN) ) !=
                sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN) ) {

            DomainInfoChanged = TRUE;
        }

        if ( DomainInfoChanged ) {

            //
            // The domain object's fixed information has changed, so set
            // the changes in the domain object's private data.
            //

            NtStatus = SampSetFixedAttributes(
                           SampDefinedDomains[SampTransactionDomainIndex].
                               Context,
                           &SampDefinedDomains[SampTransactionDomainIndex].
                               CurrentFixed
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Normally when we dereference the context,
                // SampStoreObjectAttributes() is called to add the
                // latest change to the RXACT.  But that won't happen
                // for the domain object's change since this is the
                // commit code, so we have to flush it by hand here.
                //

                NtStatus = SampStoreObjectAttributes(
                      SampDefinedDomains[SampTransactionDomainIndex].Context,
                               TRUE // Use the existing key handle
                               );

            }
        }
    }


    //
    // If we still have no errors, try to commit the whole mess

    if ( NT_SUCCESS(NtStatus))
    {

        // We have the following cases here
        // 1. SampTransactionWithin Domain is never set. A commit with this condition
        //    will happens in upgrade of pre 4.0 NT databases in Registry Mode.
        //    In DS mode this will occur when the
        //    final call from loopback commits
        // 2. DS mode SampTransactionWithinDomain is set. This is the normal commit
        //    path in DS mode through SAM.
        // 3. Registry Mode SampTransactionWithinDomain Is Set.

        if (!SampTransactionWithinDomain)
        {

            if (!SampUseDsData)
            {
                //
                // Registry Case, this happens while upgrading an NT 3.51 Database
                // The 3.51 Upgrader code resets the SampTransactionDomain flag
                // in order to prevent changes from propagating to Other domain
                // controllers that replicate via Pre NT 5.0 Replication.
                //

                SampCommitChangesToRegistry(&AbortDone);
            }
            else
            {

                // Ds Case, this can happen during loopback
                // At this moment a thread state exists, but open transactions
                // may not exist depending upon the logic in clean return in
                // the DS.


                NtStatus = SampMaybeEndDsTransaction(TransactionCommit);

            }
        }
        else if (DsTransaction)
        {
            // case 2 , commit the DS transaction. The DS transaction
            // may or may not exist. It may not exist on cases where a change
            // is made to the domain object and the changed value is the same
            // as the previous value. The domain object is flushed only on
            // cases where a change is detected on an explicit memory comparison.

            ASSERT(TRUE==SampUseDsData);

            NtStatus = SampMaybeEndDsTransaction(TransactionCommit);

            if (NT_SUCCESS(NtStatus))
            {
                //
                // The transaction was successfully commited. Set the Unmodified
                // fixed field in the domain object to the current fixed field
                //

                SampDefinedDomains[SampTransactionDomainIndex].UnmodifiedFixed =
                    SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed;
            }


        }
        else
        {
            // case 3, commit the Registry Transaction

            ASSERT(FALSE==SampUseDsData);

            NtStatus = SampCommitChangesToRegistry(&AbortDone);
        }
    }

    //
    // Always abort the transaction on failure
    //


    if ( !NT_SUCCESS(NtStatus) && !AbortDone) {


        if (!SampUseDsData)
        {
            //
            // In registry mode, abort the Registry Transaction
            //

            IgnoreStatus = RtlAbortRXact( SampRXactContext );
        }
        else
        {
            // In DS mode Abort the DS transaction, if the writelock is not
            // held by the DS. In the case where the write lock is held by
            // the DS, the DS will abort the transaction, when it releases the
            // write lock

            if (!SampIsWriteLockHeldByDs())
            {
                IgnoreStatus = SampMaybeEndDsTransaction(TransactionAbort);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }
        }

    }

    return( NtStatus );
}





NTSTATUS
SampCommitAndRetainWriteLock(
    VOID
    )

/*++

Routine Description:

    This routine attempts to commit all changes made so far.  The write-lock
    is held for the duration of the commit and is retained by the caller upon
    return.

    The transaction domain is left intact as well.

    NOTE: Write operations within a domain do not have to worry about
          updating the modified count for that domain.  This routine
          will automatically increment the ModifiedCount for a domain
          when a commit is requested within that domain.



Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was successfully commited.


    Other values may be returned as a result of failure to commit or
    roll-back the transaction.  These include any values returned by
    RtlApplyRXact() or RtlAddActionToRXact().




--*/

{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        TempStatus = STATUS_SUCCESS;

    SAMTRACE("SampCommitAndRetainWriteLock");

    NtStatus = SampCommitChanges();

    //
    // If we are in registry mode start another transaction
    //

    if (!SampUseDsData)
    {

        //
        // Start another transaction, since we're retaining the write lock.
        // Note we do this even if the commit failed so that cleanup code
        // won't get confused by the lack of a transaction.  This is true
        // for the registry transaction but not for DS transactions.  In
        // the DS case, once you commit, the transaction and threads state
        // are gone for good.
        //

        TempStatus = RtlStartRXact( SampRXactContext );
        ASSERT(NT_SUCCESS(TempStatus));

        //
        // Return the worst status
        //

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = TempStatus;
        }

    }



    return(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\oldstub.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    oldstub.c

Abstract:

    This file contains functions generated by midl v1.0.  These
    function were designed to only be called by the stubs, but
    these paticular functions are called by user code.  This
    file is needed in order to compile sam with midl v2.0 which
    doesn't generated these paticular functions anymore.

Author:

    Mario Goertzel      (MarioGo)    Jan 10, 1994

Environment:

    User Mode - Win32

Revision History:


--*/

#include <samrpc.h>

/* routine that frees graph for struct _RPC_UNICODE_STRING */
void _fgs__RPC_UNICODE_STRING (RPC_UNICODE_STRING  * _source)
  {
  if (_source->Buffer !=0)
    {
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

/* routine that frees a string containing security sensitive info */

void SampFreeSensitiveUnicodeString(RPC_UNICODE_STRING  * _source)
 {
 if (_source->Buffer!=0)
    {
    memset(_source->Buffer,0,_source->Length);
    _fgs__RPC_UNICODE_STRING (_source);
    }
 }

/* routine that frees graph for struct _SAMPR_RID_ENUMERATION */
void _fgs__SAMPR_RID_ENUMERATION (SAMPR_RID_ENUMERATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Name);
  }

/* routine that frees graph for struct _SAMPR_ENUMERATION_BUFFER */
void _fgs__SAMPR_ENUMERATION_BUFFER (SAMPR_ENUMERATION_BUFFER  * _source)
  {
  if (_source->Buffer !=0)
    {
      {
      unsigned long _sym9;
      for (_sym9 = 0; _sym9 < (unsigned long )(0 + _source->EntriesRead); _sym9++)
        {
        _fgs__SAMPR_RID_ENUMERATION ((SAMPR_RID_ENUMERATION *)&_source->Buffer[_sym9]);
        }
      }
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

/* routine that frees graph for struct _SAMPR_SR_SECURITY_DESCRIPTOR */
void _fgs__SAMPR_SR_SECURITY_DESCRIPTOR (SAMPR_SR_SECURITY_DESCRIPTOR  * _source)
  {
  if (_source->SecurityDescriptor !=0)
    {
    MIDL_user_free((void  *)(_source->SecurityDescriptor));
    }
  }

/* routine that frees graph for struct _SAMPR_GET_GROUPS_BUFFER */
void _fgs__SAMPR_GET_GROUPS_BUFFER (SAMPR_GET_GROUPS_BUFFER  * _source)
  {
  if (_source->Groups !=0)
    {
    MIDL_user_free((void  *)(_source->Groups));
    }
  }

/* routine that frees graph for struct _SAMPR_GET_MEMBERS_BUFFER */
void _fgs__SAMPR_GET_MEMBERS_BUFFER (SAMPR_GET_MEMBERS_BUFFER  * _source)
  {
  if (_source->Members !=0)
    {
    MIDL_user_free((void  *)(_source->Members));
    }
  if (_source->Attributes !=0)
    {
    MIDL_user_free((void  *)(_source->Attributes));
    }
  }

/* routine that frees graph for struct _SAMPR_LOGON_HOURS */
void _fgs__SAMPR_LOGON_HOURS (SAMPR_LOGON_HOURS  * _source)
  {
  if (_source->LogonHours !=0)
    {
    MIDL_user_free((void  *)(_source->LogonHours));
    }
  }

/* routine that frees graph for struct _SAMPR_ULONG_ARRAY */
void _fgs__SAMPR_ULONG_ARRAY (SAMPR_ULONG_ARRAY  * _source)
  {
  if (_source->Element !=0)
    {
    MIDL_user_free((void  *)(_source->Element));
    }
  }

/* routine that frees graph for struct _SAMPR_SID_INFORMATION */
void _fgs__SAMPR_SID_INFORMATION (SAMPR_SID_INFORMATION  * _source)
  {
  if (_source->SidPointer !=0)
    {
    MIDL_user_free((void  *)(_source->SidPointer));
    }
  }

/* routine that frees graph for struct _SAMPR_PSID_ARRAY */
void _fgs__SAMPR_PSID_ARRAY (SAMPR_PSID_ARRAY  * _source)
  {
  if (_source->Sids !=0)
    {
    MIDL_user_free((void  *)(_source->Sids));
    }
  }


/* routine that frees graph for struct _SAMPR_RETURNED_USTRING_ARRAY */
void _fgs__SAMPR_RETURNED_USTRING_ARRAY (SAMPR_RETURNED_USTRING_ARRAY  * _source)
  {
  if (_source->Element !=0)
    {
      {
      unsigned long _sym26;
      for (_sym26 = 0; _sym26 < (unsigned long )(0 + _source->Count); _sym26++)
        {
        _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Element[_sym26]);
        }
      }
    MIDL_user_free((void  *)(_source->Element));
    }
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_GENERAL_INFORMATION */
void _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION (SAMPR_DOMAIN_GENERAL_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->OemInformation);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->DomainName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ReplicaSourceNodeName);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_GENERAL_INFORMATION2 */
void _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION2 (SAMPR_DOMAIN_GENERAL_INFORMATION2  * _source)
  {
  _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION ((SAMPR_DOMAIN_GENERAL_INFORMATION *)&_source->I1);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_OEM_INFORMATION */
void _fgs__SAMPR_DOMAIN_OEM_INFORMATION (SAMPR_DOMAIN_OEM_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->OemInformation);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_NAME_INFORMATION */
void _fgs__SAMPR_DOMAIN_NAME_INFORMATION (SAMPR_DOMAIN_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->DomainName);
  }

/* routine that frees graph for struct SAMPR_DOMAIN_REPLICATION_INFORMATION */
void _fgs_SAMPR_DOMAIN_REPLICATION_INFORMATION (SAMPR_DOMAIN_REPLICATION_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ReplicaSourceNodeName);
  }

/* routine that frees graph for union _SAMPR_DOMAIN_INFO_BUFFER */
void _fgu__SAMPR_DOMAIN_INFO_BUFFER (SAMPR_DOMAIN_INFO_BUFFER  * _source, DOMAIN_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case DomainPasswordInformation :
      {
      break;
      }
    case DomainGeneralInformation :
      {
      _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION ((SAMPR_DOMAIN_GENERAL_INFORMATION *)&_source->General);
      break;
      }
    case DomainLogoffInformation :
      {
      break;
      }
    case DomainOemInformation :
      {
      _fgs__SAMPR_DOMAIN_OEM_INFORMATION ((SAMPR_DOMAIN_OEM_INFORMATION *)&_source->Oem);
      break;
      }
    case DomainNameInformation :
      {
      _fgs__SAMPR_DOMAIN_NAME_INFORMATION ((SAMPR_DOMAIN_NAME_INFORMATION *)&_source->Name);
      break;
      }
    case DomainServerRoleInformation :
      {
      break;
      }
    case DomainReplicationInformation :
      {
      _fgs_SAMPR_DOMAIN_REPLICATION_INFORMATION ((SAMPR_DOMAIN_REPLICATION_INFORMATION *)&_source->Replication);
      break;
      }
    case DomainModifiedInformation :
      {
      break;
      }
    case DomainStateInformation :
      {
      break;
      }
    case DomainGeneralInformation2 :
      {
      _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION2 ((SAMPR_DOMAIN_GENERAL_INFORMATION2 *)&_source->General2);
      break;
      }
    case DomainLockoutInformation :
      {
      break;
      }
    case DomainModifiedInformation2 :
      {
      break;
      }
    }
  }

/* routine that frees graph for struct _SAMPR_GROUP_GENERAL_INFORMATION */
void _fgs__SAMPR_GROUP_GENERAL_INFORMATION (SAMPR_GROUP_GENERAL_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Name);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  }

/* routine that frees graph for struct _SAMPR_GROUP_NAME_INFORMATION */
void _fgs__SAMPR_GROUP_NAME_INFORMATION (SAMPR_GROUP_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Name);
  }

/* routine that frees graph for struct _SAMPR_GROUP_ADM_COMMENT_INFORMATION */
void _fgs__SAMPR_GROUP_ADM_COMMENT_INFORMATION (SAMPR_GROUP_ADM_COMMENT_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  }

/* routine that frees graph for union _SAMPR_GROUP_INFO_BUFFER */
void _fgu__SAMPR_GROUP_INFO_BUFFER (SAMPR_GROUP_INFO_BUFFER  * _source, GROUP_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case GroupGeneralInformation :
    case GroupReplicationInformation :
      {
      _fgs__SAMPR_GROUP_GENERAL_INFORMATION ((SAMPR_GROUP_GENERAL_INFORMATION *)&_source->General);
      break;
      }
    case GroupNameInformation :
      {
      _fgs__SAMPR_GROUP_NAME_INFORMATION ((SAMPR_GROUP_NAME_INFORMATION *)&_source->Name);
      break;
      }
    case GroupAttributeInformation :
      {
      break;
      }
    case GroupAdminCommentInformation :
      {
      _fgs__SAMPR_GROUP_ADM_COMMENT_INFORMATION ((SAMPR_GROUP_ADM_COMMENT_INFORMATION *)&_source->AdminComment);
      break;
      }
    }
  }

/* routine that frees graph for struct _SAMPR_ALIAS_GENERAL_INFORMATION */
void _fgs__SAMPR_ALIAS_GENERAL_INFORMATION (SAMPR_ALIAS_GENERAL_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Name);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  }

/* routine that frees graph for struct _SAMPR_ALIAS_NAME_INFORMATION */
void _fgs__SAMPR_ALIAS_NAME_INFORMATION (SAMPR_ALIAS_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Name);
  }

/* routine that frees graph for struct _SAMPR_ALIAS_ADM_COMMENT_INFORMATION */
void _fgs__SAMPR_ALIAS_ADM_COMMENT_INFORMATION (SAMPR_ALIAS_ADM_COMMENT_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  }

/* routine that frees graph for union _SAMPR_ALIAS_INFO_BUFFER */
void _fgu__SAMPR_ALIAS_INFO_BUFFER (SAMPR_ALIAS_INFO_BUFFER  * _source, ALIAS_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case AliasGeneralInformation :
    case AliasReplicationInformation :
      {
      _fgs__SAMPR_ALIAS_GENERAL_INFORMATION ((SAMPR_ALIAS_GENERAL_INFORMATION *)&_source->General);
      break;
      }
    case AliasNameInformation :
      {
      _fgs__SAMPR_ALIAS_NAME_INFORMATION ((SAMPR_ALIAS_NAME_INFORMATION *)&_source->Name);
      break;
      }
    case AliasAdminCommentInformation :
      {
      _fgs__SAMPR_ALIAS_ADM_COMMENT_INFORMATION ((SAMPR_ALIAS_ADM_COMMENT_INFORMATION *)&_source->AdminComment);
      break;
      }
    }
  }

/* routine that frees graph for struct _SAMPR_USER_ALL_INFORMATION */
void _fgs__SAMPR_USER_ALL_INFORMATION (SAMPR_USER_ALL_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectory);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectoryDrive);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ScriptPath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ProfilePath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->WorkStations);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Parameters);


  //
  // Password info should be zero'd before freeing.
  //

  //_fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->LmOwfPassword);

  SampFreeSensitiveUnicodeString((RPC_UNICODE_STRING *)&_source->LmOwfPassword);

  //_fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->NtOwfPassword);

  SampFreeSensitiveUnicodeString((RPC_UNICODE_STRING *)&_source->NtOwfPassword);

  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->PrivateData);
  _fgs__SAMPR_SR_SECURITY_DESCRIPTOR ((SAMPR_SR_SECURITY_DESCRIPTOR *)&_source->SecurityDescriptor);
  _fgs__SAMPR_LOGON_HOURS ((SAMPR_LOGON_HOURS *)&_source->LogonHours);
  }

/* routine that frees graph for struct _SAMPR_USER_INTERNAL3_INFORMATION */
void _fgs__SAMPR_USER_INTERNAL3_INFORMATION (SAMPR_USER_INTERNAL3_INFORMATION  * _source)
  {
  _fgs__SAMPR_USER_ALL_INFORMATION ((SAMPR_USER_ALL_INFORMATION *)&_source->I1);
  }

/* routine that frees graph for struct _SAMPR_USER_GENERAL_INFORMATION */
void _fgs__SAMPR_USER_GENERAL_INFORMATION (SAMPR_USER_GENERAL_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserComment);
  }

/* routine that frees graph for struct _SAMPR_USER_PREFERENCES_INFORMATION */
void _fgs__SAMPR_USER_PREFERENCES_INFORMATION (SAMPR_USER_PREFERENCES_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Reserved1);
  }

/* routine that frees graph for struct _SAMPR_USER_PARAMETERS_INFORMATION */
void _fgs__SAMPR_USER_PARAMETERS_INFORMATION (SAMPR_USER_PARAMETERS_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Parameters);
  }

/* routine that frees graph for struct _SAMPR_USER_LOGON_INFORMATION */
void _fgs__SAMPR_USER_LOGON_INFORMATION (SAMPR_USER_LOGON_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectory);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectoryDrive);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ScriptPath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ProfilePath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->WorkStations);
  _fgs__SAMPR_LOGON_HOURS ((SAMPR_LOGON_HOURS *)&_source->LogonHours);
  }

/* routine that frees graph for struct _SAMPR_USER_ACCOUNT_INFORMATION */
void _fgs__SAMPR_USER_ACCOUNT_INFORMATION (SAMPR_USER_ACCOUNT_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectory);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectoryDrive);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ScriptPath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ProfilePath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->WorkStations);
  _fgs__SAMPR_LOGON_HOURS ((SAMPR_LOGON_HOURS *)&_source->LogonHours);
  }

/* routine that frees graph for struct _SAMPR_USER_A_NAME_INFORMATION */
void _fgs__SAMPR_USER_A_NAME_INFORMATION (SAMPR_USER_A_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  }

/* routine that frees graph for struct _SAMPR_USER_F_NAME_INFORMATION */
void _fgs__SAMPR_USER_F_NAME_INFORMATION (SAMPR_USER_F_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  }

/* routine that frees graph for struct _SAMPR_USER_NAME_INFORMATION */
void _fgs__SAMPR_USER_NAME_INFORMATION (SAMPR_USER_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  }

/* routine that frees graph for struct _SAMPR_USER_HOME_INFORMATION */
void _fgs__SAMPR_USER_HOME_INFORMATION (SAMPR_USER_HOME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectory);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectoryDrive);
  }

/* routine that frees graph for struct _SAMPR_USER_SCRIPT_INFORMATION */
void _fgs__SAMPR_USER_SCRIPT_INFORMATION (SAMPR_USER_SCRIPT_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ScriptPath);
  }

/* routine that frees graph for struct _SAMPR_USER_PROFILE_INFORMATION */
void _fgs__SAMPR_USER_PROFILE_INFORMATION (SAMPR_USER_PROFILE_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ProfilePath);
  }

/* routine that frees graph for struct _SAMPR_USER_ADMIN_COMMENT_INFORMATION */
void _fgs__SAMPR_USER_ADMIN_COMMENT_INFORMATION (SAMPR_USER_ADMIN_COMMENT_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  }

/* routine that frees graph for struct _SAMPR_USER_WORKSTATIONS_INFORMATION */
void _fgs__SAMPR_USER_WORKSTATIONS_INFORMATION (SAMPR_USER_WORKSTATIONS_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->WorkStations);
  }

/* routine that frees graph for struct _SAMPR_USER_LOGON_HOURS_INFORMATION */
void _fgs__SAMPR_USER_LOGON_HOURS_INFORMATION (SAMPR_USER_LOGON_HOURS_INFORMATION  * _source)
  {
  _fgs__SAMPR_LOGON_HOURS ((SAMPR_LOGON_HOURS *)&_source->LogonHours);
  }

/* routine that frees graph for union _SAMPR_USER_INFO_BUFFER */
void _fgu__SAMPR_USER_INFO_BUFFER (SAMPR_USER_INFO_BUFFER  * _source, USER_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case UserGeneralInformation :
      {
      _fgs__SAMPR_USER_GENERAL_INFORMATION ((SAMPR_USER_GENERAL_INFORMATION *)&_source->General);
      break;
      }
    case UserPreferencesInformation :
      {
      _fgs__SAMPR_USER_PREFERENCES_INFORMATION ((SAMPR_USER_PREFERENCES_INFORMATION *)&_source->Preferences);
      break;
      }
    case UserLogonInformation :
      {
      _fgs__SAMPR_USER_LOGON_INFORMATION ((SAMPR_USER_LOGON_INFORMATION *)&_source->Logon);
      break;
      }
    case UserLogonHoursInformation :
      {
      _fgs__SAMPR_USER_LOGON_HOURS_INFORMATION ((SAMPR_USER_LOGON_HOURS_INFORMATION *)&_source->LogonHours);
      break;
      }
    case UserAccountInformation :
      {
      _fgs__SAMPR_USER_ACCOUNT_INFORMATION ((SAMPR_USER_ACCOUNT_INFORMATION *)&_source->Account);
      break;
      }
    case UserNameInformation :
      {
      _fgs__SAMPR_USER_NAME_INFORMATION ((SAMPR_USER_NAME_INFORMATION *)&_source->Name);
      break;
      }
    case UserAccountNameInformation :
      {
      _fgs__SAMPR_USER_A_NAME_INFORMATION ((SAMPR_USER_A_NAME_INFORMATION *)&_source->AccountName);
      break;
      }
    case UserFullNameInformation :
      {
      _fgs__SAMPR_USER_F_NAME_INFORMATION ((SAMPR_USER_F_NAME_INFORMATION *)&_source->FullName);
      break;
      }
    case UserPrimaryGroupInformation :
      {
      break;
      }
    case UserHomeInformation :
      {
      _fgs__SAMPR_USER_HOME_INFORMATION ((SAMPR_USER_HOME_INFORMATION *)&_source->Home);
      break;
      }
    case UserScriptInformation :
      {
      _fgs__SAMPR_USER_SCRIPT_INFORMATION ((SAMPR_USER_SCRIPT_INFORMATION *)&_source->Script);
      break;
      }
    case UserProfileInformation :
      {
      _fgs__SAMPR_USER_PROFILE_INFORMATION ((SAMPR_USER_PROFILE_INFORMATION *)&_source->Profile);
      break;
      }
    case UserAdminCommentInformation :
      {
      _fgs__SAMPR_USER_ADMIN_COMMENT_INFORMATION ((SAMPR_USER_ADMIN_COMMENT_INFORMATION *)&_source->AdminComment);
      break;
      }
    case UserWorkStationsInformation :
      {
      _fgs__SAMPR_USER_WORKSTATIONS_INFORMATION ((SAMPR_USER_WORKSTATIONS_INFORMATION *)&_source->WorkStations);
      break;
      }
    case UserControlInformation :
      {
      break;
      }
    case UserExpiresInformation :
      {
      break;
      }
    case UserInternal1Information :
      {
      break;
      }
    case UserInternal2Information :
      {
      break;
      }
    case UserParametersInformation :
      {
      _fgs__SAMPR_USER_PARAMETERS_INFORMATION ((SAMPR_USER_PARAMETERS_INFORMATION *)&_source->Parameters);
      break;
      }
    case UserAllInformation :
      {
      _fgs__SAMPR_USER_ALL_INFORMATION ((SAMPR_USER_ALL_INFORMATION *)&_source->All);
      break;
      }
    case UserInternal3Information :
      {
      _fgs__SAMPR_USER_INTERNAL3_INFORMATION ((SAMPR_USER_INTERNAL3_INFORMATION *)&_source->Internal3);
      break;
      }
    }
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_USER */
void _fgs__SAMPR_DOMAIN_DISPLAY_USER (SAMPR_DOMAIN_DISPLAY_USER  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->LogonName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_MACHINE */
void _fgs__SAMPR_DOMAIN_DISPLAY_MACHINE (SAMPR_DOMAIN_DISPLAY_MACHINE  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Machine);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Comment);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_GROUP */
void _fgs__SAMPR_DOMAIN_DISPLAY_GROUP (SAMPR_DOMAIN_DISPLAY_GROUP  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Group);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Comment);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_USER_BUFFER */
void _fgs__SAMPR_DOMAIN_DISPLAY_USER_BUFFER (SAMPR_DOMAIN_DISPLAY_USER_BUFFER  * _source)
  {
  if (_source->Buffer !=0)
    {
      {
      unsigned long _sym32;
      for (_sym32 = 0; _sym32 < (unsigned long )(0 + _source->EntriesRead); _sym32++)
        {
        _fgs__SAMPR_DOMAIN_DISPLAY_USER ((SAMPR_DOMAIN_DISPLAY_USER *)&_source->Buffer[_sym32]);
        }
      }
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER */
void _fgs__SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER (SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER  * _source)
  {
  if (_source->Buffer !=0)
    {
      {
      unsigned long _sym38;
      for (_sym38 = 0; _sym38 < (unsigned long )(0 + _source->EntriesRead); _sym38++)
        {
        _fgs__SAMPR_DOMAIN_DISPLAY_MACHINE ((SAMPR_DOMAIN_DISPLAY_MACHINE *)&_source->Buffer[_sym38]);
        }
      }
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER */
void _fgs__SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER (SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER  * _source)
  {
  if (_source->Buffer !=0)
    {
      {
      unsigned long _sym44;
      for (_sym44 = 0; _sym44 < (unsigned long )(0 + _source->EntriesRead); _sym44++)
        {
        _fgs__SAMPR_DOMAIN_DISPLAY_GROUP ((SAMPR_DOMAIN_DISPLAY_GROUP *)&_source->Buffer[_sym44]);
        }
      }
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

/* routine that frees graph for union _SAMPR_DISPLAY_INFO_BUFFER */
void _fgu__SAMPR_DISPLAY_INFO_BUFFER (SAMPR_DISPLAY_INFO_BUFFER  * _source, DOMAIN_DISPLAY_INFORMATION _branch)
  {
  switch (_branch)
    {
    case DomainDisplayUser :
      {
      _fgs__SAMPR_DOMAIN_DISPLAY_USER_BUFFER ((SAMPR_DOMAIN_DISPLAY_USER_BUFFER *)&_source->UserInformation);
      break;
      }
    case DomainDisplayMachine :
      {
      _fgs__SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER ((SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER *)&_source->MachineInformation);
      break;
      }
    case DomainDisplayGroup :
      {
      _fgs__SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER ((SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER *)&_source->GroupInformation);
      break;
      }
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\ntdsguid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       ntdsguid.c
//
//--------------------------------------------------------------------------


/*++
 File:    NTDSGUID.C
 Purpose: Contains the Schema Guids for the Attributes and Class
          Schema Objects in NTDS.
 Creator: Automatically generated on
 Date:    Sat May 12 11:43:18 2001

 ** This is a Generated File From Schema.INI **

--*/

#include <ntdspch.h>
#include <ntdsguid.h>

// 
// The List of GUID Controls used in DS
// 

const GUID GUID_CONTROL_DomainListAccounts     = {0xab721a50,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_DomainLookup           = {0xab721a51,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_DomainAdministerServer = {0xab721a52,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_UserChangePassword     = {0xab721a53,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_UserForceChangePassword = {0x299570,0x246d, 0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   
const GUID GUID_CONTROL_SendAs                 = {0xab721a54,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_SendTo                 = {0xab721a55,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_ReceiveAs              = {0xab721a56,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_ListGroupMembership    = {0x65be5d30,0x20cf,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   
const GUID GUID_CONTROL_DsInstallReplica       = {0x9923a32a,0x3607,0x11d2,0xb9,0xbe,0x00,0x00,0xf8,0x7a,0x36,0xb2} ;   
const GUID GUID_CONTROL_DsSamEnumEntireDomain  = {0x91d67418,0x0135,0x4acc,0x8d,0x79,0xc0,0x8e,0x85,0x7c,0xfb,0xec} ;   


// 
// The List of Property Set GUIDS used by SAM
// 

const GUID GUID_PS_DOMAIN_PASSWORD              = {0xc7407360,0x20bf,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   
const GUID GUID_PS_GENERAL_INFO                 = {0x59ba2f42,0x79a2,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd3,0xcf} ;   
const GUID GUID_PS_USER_ACCOUNT_RESTRICTIONS    = {0x4c164200,0x20c0,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   
const GUID GUID_PS_USER_LOGON                   = {0x5f202010,0x79a5,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd4,0xcf} ;   
const GUID GUID_PS_MEMBERSHIP                   = {0xbc0ac240,0x79a9,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd4,0xcf} ;   
const GUID GUID_PS_DOMAIN_OTHER_PARAMETERS      = {0xb8119fd0,0x04f6,0x4762,0xab,0x7a,0x49,0x86,0xc7,0x6b,0x3f,0x9a} ;   


// 
// The list of Property Set GUIDS used by LSA
// 

const GUID GUID_PS_PASSWORD_POLICY              = {0xa29b89fb,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_LOCKOUT_POLICY               = {0xa29b89fc,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_DOMAIN_CONFIGURATION         = {0xa29b89fd,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_DOMAIN_POLICY                = {0xa29b89fe,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_PRIVILEGES                   = {0xa29b89ff,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_ADMINISTRATIVE_ACCESS        = {0xa29b8a00,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_LOCAL_POLICY                 = {0xa29b8a01,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_AUDIT                        = {0xa29b8a02,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_BUILTIN_LOCAL_GROUPS         = {0xa29b8a03,0xc738,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   



//--------------------------------------
// ATTRIBUTE SCHEMA GUIDS
//--------------------------------------
const GUID GUID_A_ACCOUNT_EXPIRES                = {0xbf967915,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ACCOUNT_NAME_HISTORY           = {0x031952ec,0x3b72,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_AGGREGATE_TOKEN_RATE_PER_USER = {0x7f56127d,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_ALLOCABLE_RSVP_BANDWIDTH   = {0x7f561283,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_CACHE_TIMEOUT              = {0x1cb355a1,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_DIRECTION                  = {0x7f56127a,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_DSBM_DEADTIME              = {0x1cb355a0,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_DSBM_PRIORITY              = {0x1cb3559e,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_DSBM_REFRESH               = {0x1cb3559f,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_ENABLE_ACS_SERVICE         = {0x7f561287,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_ENABLE_RSVP_ACCOUNTING     = {0xf072230e,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_ENABLE_RSVP_MESSAGE_LOGGING = {0x7f561285,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_EVENT_LOG_LEVEL            = {0x7f561286,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_IDENTITY_NAME              = {0xdab029b6,0xddf7,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER = {0xf072230c,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_DURATION_PER_FLOW      = {0x7f56127e,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_NO_OF_ACCOUNT_FILES    = {0xf0722310,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_NO_OF_LOG_FILES        = {0x1cb3559c,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_PEAK_BANDWIDTH         = {0x7f561284,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW = {0x7f56127c,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE = {0xf0722311,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_SIZE_OF_RSVP_LOG_FILE  = {0x1cb3559d,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_TOKEN_BUCKET_PER_FLOW  = {0x81f6e0df,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_MAX_TOKEN_RATE_PER_FLOW    = {0x7f56127b,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAXIMUM_SDU_SIZE           = {0x87a2d8f9,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_MINIMUM_DELAY_VARIATION    = {0x9c65329b,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_MINIMUM_LATENCY            = {0x9517fefb,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_MINIMUM_POLICED_SIZE       = {0x8d0e7195,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_NON_RESERVED_MAX_SDU_SIZE  = {0xaec2cfe3,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_NON_RESERVED_MIN_POLICED_SIZE = {0xb6873917,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_NON_RESERVED_PEAK_RATE     = {0xa331a73f,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_NON_RESERVED_TOKEN_SIZE    = {0xa916d7c9,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_NON_RESERVED_TX_LIMIT      = {0x1cb355a2,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_NON_RESERVED_TX_SIZE       = {0xf072230d,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_PERMISSION_BITS            = {0x7f561282,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_POLICY_NAME                = {0x1cb3559a,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_PRIORITY                   = {0x7f561281,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_RSVP_ACCOUNT_FILES_LOCATION = {0xf072230f,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_RSVP_LOG_FILES_LOCATION    = {0x1cb3559b,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_SERVICE_TYPE               = {0x7f56127f,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_TIME_OF_DAY                = {0x7f561279,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_TOTAL_NO_OF_FLOWS          = {0x7f561280,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_SERVER_LIST                = {0x7cbd59a5,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ADDITIONAL_INFORMATION         = {0x6d05fb41,0x246b,0x11d0,0xa9,0xc8,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADDITIONAL_TRUSTED_SERVICE_NAMES = {0x032160be,0x9824,0x11d1,0xae,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ADDRESS                        = {0xf0f8ff84,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADDRESS_BOOK_ROOTS             = {0xf70b6e48,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_ADDRESS_ENTRY_DISPLAY_TABLE    = {0x5fd42461,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS = {0x5fd42462,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADDRESS_HOME                   = {0x16775781,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ADDRESS_SYNTAX                 = {0x5fd42463,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADDRESS_TYPE                   = {0x5fd42464,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADMIN_CONTEXT_MENU             = {0x553fd038,0xf32e,0x11d0,0xb0,0xbc,0x00,0xc0,0x4f,0xd8,0xdc,0xa6} ;
const GUID GUID_A_ADMIN_COUNT                    = {0xbf967918,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ADMIN_DESCRIPTION              = {0xbf967919,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ADMIN_DISPLAY_NAME             = {0xbf96791a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ADMIN_MULTISELECT_PROPERTY_PAGES = {0x18f9b67d,0x5ac6,0x4b3b,0x97,0xdb,0xd0,0xa4,0x06,0xaf,0xb7,0xba} ;
const GUID GUID_A_ADMIN_PROPERTY_PAGES           = {0x52458038,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ALLOWED_ATTRIBUTES             = {0x9a7ad940,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ALLOWED_ATTRIBUTES_EFFECTIVE   = {0x9a7ad941,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ALLOWED_CHILD_CLASSES          = {0x9a7ad942,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ALLOWED_CHILD_CLASSES_EFFECTIVE = {0x9a7ad943,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ALT_SECURITY_IDENTITIES        = {0x00fbf30c,0x91fe,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ANR                            = {0x45b01500,0xc419,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_APP_SCHEMA_VERSION             = {0x96a7dd65,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_APPLICATION_NAME               = {0xdd712226,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_APPLIES_TO                     = {0x8297931d,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_ASSET_NUMBER                   = {0xba305f75,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_ASSISTANT                      = {0x0296c11c,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ASSOC_NT_ACCOUNT               = {0x398f63c0,0xca60,0x11d1,0xbb,0xd1,0x00,0x00,0xf8,0x1f,0x10,0xc0} ;
const GUID GUID_A_ATTRIBUTECERTIFICATEATTRIBUTE  = {0xFA4693BB,0x7BC2,0x4cb9,0x81,0xA8,0xC9,0x9C,0x43,0xB7,0x90,0x5E} ;
const GUID GUID_A_ATTRIBUTE_DISPLAY_NAMES        = {0xcb843f80,0x48d9,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ATTRIBUTE_ID                   = {0xbf967922,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ATTRIBUTE_SECURITY_GUID        = {0xbf967924,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ATTRIBUTE_SYNTAX               = {0xbf967925,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ATTRIBUTE_TYPES                = {0x9a7ad944,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_AUDIO                          = {0xD0E1D224,0xE1A0,0x42ce,0xA2,0xDA,0x79,0x3B,0xA5,0x24,0x4F,0x35} ;
const GUID GUID_A_AUDITING_POLICY                = {0x6da8a4fe,0x0e52,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_AUTHENTICATION_OPTIONS         = {0xbf967928,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_AUTHORITY_REVOCATION_LIST      = {0x1677578d,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_AUXILIARY_CLASS                = {0xbf96792c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BAD_PASSWORD_TIME              = {0xbf96792d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BAD_PWD_COUNT                  = {0xbf96792e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BIRTH_LOCATION                 = {0x1f0075f9,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_BRIDGEHEAD_SERVER_LIST_BL      = {0xd50c2cdb,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_BRIDGEHEAD_TRANSPORT_LIST      = {0xd50c2cda,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_BUILTIN_CREATION_TIME          = {0xbf96792f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BUILTIN_MODIFIED_COUNT         = {0xbf967930,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BUSINESS_CATEGORY              = {0xbf967931,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BYTES_PER_MINUTE               = {0xba305f76,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CA_CERTIFICATE                 = {0xbf967932,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_CA_CERTIFICATE_DN              = {0x963d2740,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CA_CONNECT                     = {0x963d2735,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CA_USAGES                      = {0x963d2738,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CA_WEB_URL                     = {0x963d2736,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CAN_UPGRADE_SCRIPT             = {0xd9e18314,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CANONICAL_NAME                 = {0x9a7ad945,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_CARLICENSE                     = {0xD4159C92,0x957D,0x4a87,0x8A,0x67,0x8D,0x29,0x34,0xE0,0x16,0x49} ;
const GUID GUID_A_CATALOGS                       = {0x7bfdcb81,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CATEGORIES                     = {0x7bfdcb7e,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CATEGORY_ID                    = {0x7d6c0e94,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CERTIFICATE_AUTHORITY_OBJECT   = {0x963d2732,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CERTIFICATE_REVOCATION_LIST    = {0x1677579f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CERTIFICATE_TEMPLATES          = {0x2a39c5b1,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CLASS_DISPLAY_NAME             = {0x548e1c22,0xdea6,0x11d0,0xb0,0x10,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CODE_PAGE                      = {0xbf967938,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_CLASSID                    = {0xbf96793b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_CLSID                      = {0x281416d9,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_INTERFACEID                = {0xbf96793c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_OTHER_PROG_ID              = {0x281416dd,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_PROGID                     = {0xbf96793d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_TREAT_AS_CLASS_ID          = {0x281416db,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_TYPELIB_ID                 = {0x281416de,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_UNIQUE_LIBID               = {0x281416da,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COMMENT                        = {0xbf96793e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COMMON_NAME                    = {0xbf96793f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COMPANY                        = {0xf0f8ff88,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_CONTENT_INDEXING_ALLOWED       = {0xbf967943,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_CONTEXT_MENU                   = {0x4d8601ee,0xac85,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CONTROL_ACCESS_RIGHTS          = {0x6da8a4fc,0x0e52,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COST                           = {0xbf967944,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COUNTRY_CODE                   = {0x5fd42471,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_COUNTRY_NAME                   = {0xbf967945,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_CREATE_DIALOG                  = {0x2b09958a,0x8931,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CREATE_TIME_STAMP              = {0x2df90d73,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_CREATE_WIZARD_EXT              = {0x2b09958b,0x8931,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CREATION_TIME                  = {0xbf967946,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_CREATION_WIZARD                = {0x4d8601ed,0xac85,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CREATOR                        = {0x7bfdcb85,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CRL_OBJECT                     = {0x963d2737,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CRL_PARTITIONED_REVOCATION_LIST = {0x963d2731,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CROSS_CERTIFICATE_PAIR         = {0x167757b2,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CURR_MACHINE_ID                = {0x1f0075fe,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CURRENT_LOCATION               = {0x1f0075fc,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CURRENT_PARENT_CA              = {0x963d273f,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CURRENT_VALUE                  = {0xbf967947,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DBCS_PWD                       = {0xbf96799c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DEFAULT_CLASS_STORE            = {0xbf967948,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DEFAULT_GROUP                  = {0x720bc4e2,0xa54a,0x11d0,0xaf,0xdf,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DEFAULT_HIDING_VALUE           = {0xb7b13116,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DEFAULT_LOCAL_POLICY_OBJECT    = {0xbf96799f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DEFAULT_OBJECT_CATEGORY        = {0x26d97367,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DEFAULT_PRIORITY               = {0x281416c8,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DEFAULT_SECURITY_DESCRIPTOR    = {0x807a6d30,0x1669,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_DELTA_REVOCATION_LIST          = {0x167757b5,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DEPARTMENT                     = {0xbf96794f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DEPARTMENTNUMBER               = {0xBE9EF6EE,0xCBC7,0x4f22,0xB2,0x7B,0x96,0x96,0x7E,0x7E,0xE5,0x85} ;
const GUID GUID_A_DESCRIPTION                    = {0xbf967950,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DESKTOP_PROFILE                = {0xeea65906,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DESTINATION_INDICATOR          = {0xbf967951,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DHCP_CLASSES                   = {0x963d2750,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_FLAGS                     = {0x963d2741,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_IDENTIFICATION            = {0x963d2742,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_MASK                      = {0x963d2747,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_MAXKEY                    = {0x963d2754,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_OBJ_DESCRIPTION           = {0x963d2744,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_OBJ_NAME                  = {0x963d2743,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_OPTIONS                   = {0x963d274f,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_PROPERTIES                = {0x963d2753,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_RANGES                    = {0x963d2748,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_RESERVATIONS              = {0x963d274a,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_SERVERS                   = {0x963d2745,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_SITES                     = {0x963d2749,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_STATE                     = {0x963d2752,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_SUBNETS                   = {0x963d2746,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_TYPE                      = {0x963d273b,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_UNIQUE_KEY                = {0x963d273a,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_UPDATE_TIME               = {0x963d2755,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DISPLAY_NAME                   = {0xbf967953,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DISPLAY_NAME_PRINTABLE         = {0xbf967954,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DIT_CONTENT_RULES              = {0x9a7ad946,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_DIVISION                       = {0xfe6136a0,0x2073,0x11d0,0xa9,0xc2,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_DMD_LOCATION                   = {0xf0f8ff8b,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_DMD_NAME                       = {0x167757b9,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DN_REFERENCE_UPDATE            = {0x2df90d86,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_DNS_ALLOW_DYNAMIC              = {0xe0fa1e65,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DNS_ALLOW_XFR                  = {0xe0fa1e66,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DNS_HOST_NAME                  = {0x72e39547,0x7b18,0x11d1,0xad,0xef,0x00,0xc0,0x4f,0xd8,0xd5,0xcd} ;
const GUID GUID_A_DNS_NOTIFY_SECONDARIES         = {0xe0fa1e68,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DNS_PROPERTY                   = {0x675a15fe,0x3b70,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_DNS_RECORD                     = {0xe0fa1e69,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DNS_ROOT                       = {0xbf967959,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DNS_SECURE_SECONDARIES         = {0xe0fa1e67,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DNS_TOMBSTONED                 = {0xd5eb2eb7,0xbe4e,0x463b,0xa2,0x14,0x63,0x4a,0x44,0xd7,0x39,0x2e} ;
const GUID GUID_A_DOMAIN_CERTIFICATE_AUTHORITIES = {0x7bfdcb7a,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DOMAIN_COMPONENT               = {0x19195a55,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DOMAIN_CROSS_REF               = {0xb000ea7b,0xa086,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DOMAIN_ID                      = {0x963d2734,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DOMAIN_IDENTIFIER              = {0x7f561278,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DOMAIN_POLICY_OBJECT           = {0xbf96795d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DOMAIN_POLICY_REFERENCE        = {0x80a67e2a,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DOMAIN_REPLICA                 = {0xbf96795e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DOMAIN_WIDE_POLICY             = {0x80a67e29,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DRIVER_NAME                    = {0x281416c5,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DRIVER_VERSION                 = {0xba305f6e,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DS_CORE_PROPAGATION_DATA       = {0xd167aa4b,0x8b08,0x11d2,0x99,0x39,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_DS_HEURISTICS                  = {0xf0f8ff86,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_DS_UI_ADMIN_MAXIMUM            = {0xee8d0ae0,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_DS_UI_ADMIN_NOTIFICATION       = {0xf6ea0a94,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_DS_UI_SHELL_MAXIMUM            = {0xfcca766a,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_DSA_SIGNATURE                  = {0x167757bc,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DYNAMIC_LDAP_SERVER            = {0x52458021,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_E_MAIL_ADDRESSES               = {0xbf967961,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_EFSPOLICY                      = {0x8e4eb2ec,0x4712,0x11d0,0xa1,0xa0,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_EMPLOYEE_ID                    = {0xbf967962,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_EMPLOYEE_NUMBER                = {0xa8df73ef,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_EMPLOYEE_TYPE                  = {0xa8df73f0,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ENABLED                        = {0xa8df73f2,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ENABLED_CONNECTION             = {0xbf967963,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ENROLLMENT_PROVIDERS           = {0x2a39c5b3,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ENTRY_TTL                      = {0xd213decc,0xd81a,0x4384,0xaa,0xc2,0xdc,0xfc,0xfd,0x63,0x1c,0xf8} ;
const GUID GUID_A_EXTENDED_ATTRIBUTE_INFO        = {0x9a7ad947,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_EXTENDED_CHARS_ALLOWED         = {0xbf967966,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_EXTENDED_CLASS_INFO            = {0x9a7ad948,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_EXTENSION_NAME                 = {0xbf967972,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_EXTRA_COLUMNS                  = {0xd24e2846,0x1dd9,0x4bcf,0x99,0xd7,0xa6,0x22,0x7c,0xc8,0x6d,0xa7} ;
const GUID GUID_A_FACSIMILE_TELEPHONE_NUMBER     = {0xbf967974,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_FILE_EXT_PRIORITY              = {0xd9e18315,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FLAGS                          = {0xbf967976,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_FLAT_NAME                      = {0xb7b13117,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FORCE_LOGOFF                   = {0xbf967977,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_FOREIGN_IDENTIFIER             = {0x3e97891e,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRIENDLY_NAMES                 = {0x7bfdcb88,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FROM_ENTRY                     = {0x9a7ad949,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_FROM_SERVER                    = {0xbf967979,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_FRS_COMPUTER_REFERENCE         = {0x2a132578,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_COMPUTER_REFERENCE_BL      = {0x2a132579,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_CONTROL_DATA_CREATION      = {0x2a13257a,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_CONTROL_INBOUND_BACKLOG    = {0x2a13257b,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_CONTROL_OUTBOUND_BACKLOG   = {0x2a13257c,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_DIRECTORY_FILTER           = {0x1be8f171,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_DS_POLL                    = {0x1be8f177,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_EXTENSIONS                 = {0x52458020,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_FAULT_CONDITION            = {0x1be8f178,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_FILE_FILTER                = {0x1be8f170,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_FLAGS                      = {0x2a13257d,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_LEVEL_LIMIT                = {0x5245801e,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_MEMBER_REFERENCE           = {0x2a13257e,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_MEMBER_REFERENCE_BL        = {0x2a13257f,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_PARTNER_AUTH_LEVEL         = {0x2a132580,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_PRIMARY_MEMBER             = {0x2a132581,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_REPLICA_SET_GUID           = {0x5245801a,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_REPLICA_SET_TYPE           = {0x26d9736b,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_ROOT_PATH                  = {0x1be8f174,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_ROOT_SECURITY              = {0x5245801f,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_SERVICE_COMMAND            = {0xddac0cee,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_SERVICE_COMMAND_STATUS     = {0x2a132582,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_STAGING_PATH               = {0x1be8f175,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_TIME_LAST_COMMAND          = {0x2a132583,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_TIME_LAST_CONFIG_CHANGE    = {0x2a132584,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_UPDATE_TIMEOUT             = {0x1be8f172,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_VERSION                    = {0x2a132585,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_VERSION_GUID               = {0x26d9736c,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_WORKING_PATH               = {0x1be8f173,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FSMO_ROLE_OWNER                = {0x66171887,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_GARBAGE_COLL_PERIOD            = {0x5fd424a1,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_GENERATED_CONNECTION           = {0xbf96797a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_GENERATION_QUALIFIER           = {0x16775804,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GIVEN_NAME                     = {0xf0f8ff8e,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_GLOBAL_ADDRESS_LIST            = {0xf754c748,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_GOVERNS_ID                     = {0xbf96797d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_GP_LINK                        = {0xf30e3bbe,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GP_OPTIONS                     = {0xf30e3bbf,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GPC_FILE_SYS_PATH              = {0xf30e3bc1,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GPC_FUNCTIONALITY_VERSION      = {0xf30e3bc0,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GPC_MACHINE_EXTENSION_NAMES    = {0x32ff8ecc,0x783f,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_GPC_USER_EXTENSION_NAMES       = {0x42a75fc6,0x783f,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_GPC_WQL_FILTER                 = {0x7bd4c7a6,0x1add,0x4436,0x8c,0x04,0x39,0x99,0xa8,0x80,0x15,0x4c} ;
const GUID GUID_A_GROUP_ATTRIBUTES               = {0xbf96797e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_GROUP_MEMBERSHIP_SAM           = {0xbf967980,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_GROUP_PRIORITY                 = {0xeea65905,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_GROUP_TYPE                     = {0x9a9a021e,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GROUPS_TO_IGNORE               = {0xeea65904,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_HAS_MASTER_NCS                 = {0xbf967982,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_HAS_PARTIAL_REPLICA_NCS        = {0xbf967981,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_HELP_DATA16                    = {0x5fd424a7,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_HELP_DATA32                    = {0x5fd424a8,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_HELP_FILE_NAME                 = {0x5fd424a9,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_HIDE_FROM_AB                   = {0xEC05B750,0xA977,0x4efe,0x8E,0x8D,0xBA,0x6C,0x1A,0x6E,0x33,0xA8} ;
const GUID GUID_A_HOME_DIRECTORY                 = {0xbf967985,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_HOME_DRIVE                     = {0xbf967986,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ICON_PATH                      = {0xf0f8ff83,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_IMPLEMENTED_CATEGORIES         = {0x7d6c0e92,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_INDEXEDSCOPES                  = {0x7bfdcb87,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_INITIAL_AUTH_INCOMING          = {0x52458023,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_INITIAL_AUTH_OUTGOING          = {0x52458024,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_INITIALS                       = {0xf0f8ff90,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_INSTALL_UI_LEVEL               = {0x96a7dd64,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_INSTANCE_TYPE                  = {0xbf96798c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_INTER_SITE_TOPOLOGY_FAILOVER   = {0xb7c69e60,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08} ;
const GUID GUID_A_INTER_SITE_TOPOLOGY_GENERATOR  = {0xb7c69e5e,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08} ;
const GUID GUID_A_INTER_SITE_TOPOLOGY_RENEW      = {0xb7c69e5f,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08} ;
const GUID GUID_A_INTERNATIONAL_ISDN_NUMBER      = {0xbf96798d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_INVOCATION_ID                  = {0xbf96798e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_IPSEC_DATA                     = {0xb40ff81f,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_DATA_TYPE                = {0xb40ff81e,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_FILTER_REFERENCE         = {0xb40ff823,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_ID                       = {0xb40ff81d,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_ISAKMP_REFERENCE         = {0xb40ff820,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_NAME                     = {0xb40ff81c,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_ACTION = {0x07383075,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_REFERENCE = {0xb40ff822,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_TYPE  = {0x07383074,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_NFA_REFERENCE            = {0xb40ff821,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_OWNERS_REFERENCE         = {0xb40ff824,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_POLICY_REFERENCE         = {0xb7b13118,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IS_CRITICAL_SYSTEM_OBJECT      = {0x00fbf30d,0x91fe,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IS_DEFUNCT                     = {0x28630ebe,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IS_DELETED                     = {0xbf96798f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_IS_EPHEMERAL                   = {0xf4c453f0,0xc5f1,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_IS_MEMBER_OF_DL                = {0xbf967991,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET = {0x19405b9d,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IS_PRIVILEGE_HOLDER            = {0x19405b9c,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IS_SINGLE_VALUED               = {0xbf967992,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_JPEGPHOTO                      = {0xBAC80572,0x09C4,0x4fa9,0x9A,0xE6,0x76,0x28,0xD7,0xAD,0xBE,0x0E} ;
const GUID GUID_A_KEYWORDS                       = {0xbf967993,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_KNOWLEDGE_INFORMATION          = {0x1677581f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LABELEDURI                     = {0xC569BB46,0xC680,0x44bc,0xA2,0x73,0xE6,0xC2,0x27,0xD7,0x1B,0x45} ;
const GUID GUID_A_LAST_BACKUP_RESTORATION_TIME   = {0x1fbb0be8,0xba63,0x11d0,0xaf,0xef,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LAST_CONTENT_INDEXED           = {0xbf967995,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LAST_KNOWN_PARENT              = {0x52ab8670,0x5709,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LAST_LOGOFF                    = {0xbf967996,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LAST_LOGON                     = {0xbf967997,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LAST_LOGON_TIMESTAMP           = {0xc0e20a04,0x0e5a,0x4ff3,0x94,0x82,0x5e,0xfe,0xae,0xcd,0x70,0x60} ;
const GUID GUID_A_LAST_SET_TIME                  = {0xbf967998,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LAST_UPDATE_SEQUENCE           = {0x7d6c0e9c,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_LDAP_ADMIN_LIMITS              = {0x7359a352,0x90f7,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LDAP_DISPLAY_NAME              = {0xbf96799a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LDAP_IPDENY_LIST               = {0x7359a353,0x90f7,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LEGACY_EXCHANGE_DN             = {0x28630ebc,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LINK_ID                        = {0xbf96799b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LINK_TRACK_SECRET              = {0x2ae80fe2,0x47b4,0x11d0,0xa1,0xa4,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_LM_PWD_HISTORY                 = {0xbf96799d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCAL_POLICY_FLAGS             = {0xbf96799e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCAL_POLICY_REFERENCE         = {0x80a67e4d,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_LOCALE_ID                      = {0xbf9679a1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCALITY_NAME                  = {0xbf9679a2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCALIZED_DESCRIPTION          = {0xd9e18316,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LOCALIZATION_DISPLAY_ID        = {0xa746f0d1,0x78d0,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_LOCATION                       = {0x09dcb79f,0x165f,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_LOCK_OUT_OBSERVATION_WINDOW    = {0xbf9679a4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCKOUT_DURATION               = {0xbf9679a5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCKOUT_THRESHOLD              = {0xbf9679a6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCKOUT_TIME                   = {0x28630ebf,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LOGO                           = {0xbf9679a9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOGON_COUNT                    = {0xbf9679aa,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOGON_HOURS                    = {0xbf9679ab,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOGON_WORKSTATION              = {0xbf9679ac,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LSA_CREATION_TIME              = {0xbf9679ad,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LSA_MODIFIED_COUNT             = {0xbf9679ae,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MACHINE_ARCHITECTURE           = {0xbf9679af,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MACHINE_PASSWORD_CHANGE_INTERVAL = {0xc9b6358e,0xbb38,0x11d0,0xaf,0xef,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MACHINE_ROLE                   = {0xbf9679b2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MACHINE_WIDE_POLICY            = {0x80a67e4f,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_MANAGED_BY                     = {0x0296c120,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MANAGED_OBJECTS                = {0x0296c124,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MANAGER                        = {0xbf9679b5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MAPI_ID                        = {0xbf9679b7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MARSHALLED_INTERFACE           = {0xbf9679b9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MASTERED_BY                    = {0xe48e64e0,0x12c9,0x11d3,0x91,0x02,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MAX_PWD_AGE                    = {0xbf9679bb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MAX_RENEW_AGE                  = {0xbf9679bc,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MAX_STORAGE                    = {0xbf9679bd,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MAX_TICKET_AGE                 = {0xbf9679be,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MAY_CONTAIN                    = {0xbf9679bf,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MEETINGADVERTISESCOPE          = {0x11b6cc8b,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGAPPLICATION             = {0x11b6cc83,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGBANDWIDTH               = {0x11b6cc92,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGBLOB                    = {0x11b6cc93,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGCONTACTINFO             = {0x11b6cc87,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGDESCRIPTION             = {0x11b6cc7e,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGENDTIME                 = {0x11b6cc91,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGID                      = {0x11b6cc7c,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGIP                      = {0x11b6cc89,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGISENCRYPTED             = {0x11b6cc8e,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGKEYWORD                 = {0x11b6cc7f,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGLANGUAGE                = {0x11b6cc84,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGLOCATION                = {0x11b6cc80,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGMAXPARTICIPANTS         = {0x11b6cc85,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGNAME                    = {0x11b6cc7d,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGORIGINATOR              = {0x11b6cc86,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGOWNER                   = {0x11b6cc88,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGPROTOCOL                = {0x11b6cc81,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGRATING                  = {0x11b6cc8d,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGRECURRENCE              = {0x11b6cc8f,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGSCOPE                   = {0x11b6cc8a,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGSTARTTIME               = {0x11b6cc90,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGTYPE                    = {0x11b6cc82,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGURL                     = {0x11b6cc8c,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEMBER                         = {0xbf9679c0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MHS_OR_ADDRESS                 = {0x0296c122,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MIN_PWD_AGE                    = {0xbf9679c2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MIN_PWD_LENGTH                 = {0xbf9679c3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MIN_TICKET_AGE                 = {0xbf9679c4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MODIFIED_COUNT                 = {0xbf9679c5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MODIFIED_COUNT_AT_LAST_PROM    = {0xbf9679c6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MODIFY_TIME_STAMP              = {0x9a7ad94a,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MONIKER                        = {0xbf9679c7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MONIKER_DISPLAY_NAME           = {0xbf9679c8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MOVE_TREE_STATE                = {0x1f2ac2c8,0x3b71,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MS_COM_DEFAULTPARTITIONLINK    = {0x998b10f7,0xaa1a,0x4364,0xb8,0x67,0x75,0x3d,0x19,0x7f,0xe6,0x70} ;
const GUID GUID_A_MS_COM_OBJECTID                = {0x430f678b,0x889f,0x41f2,0x98,0x43,0x20,0x3b,0x5a,0x65,0x57,0x2f} ;
const GUID GUID_A_MS_COM_PARTITIONLINK           = {0x09abac62,0x043f,0x4702,0xac,0x2b,0x6c,0xa1,0x5e,0xee,0x57,0x54} ;
const GUID GUID_A_MS_COM_PARTITIONSETLINK        = {0x67f121dc,0x7d02,0x4c7d,0x82,0xf5,0x9a,0xd4,0xc9,0x50,0xac,0x34} ;
const GUID GUID_A_MS_COM_USERLINK                = {0x9e6f3a4d,0x242c,0x4f37,0xb0,0x68,0x36,0xb5,0x7f,0x9f,0xc8,0x52} ;
const GUID GUID_A_MS_COM_USERPARTITIONSETLINK    = {0x8e940c8a,0xe477,0x4367,0xb0,0x8d,0xff,0x2f,0xf9,0x42,0xdc,0xd7} ;
const GUID GUID_A_MS_DS_ADDITIONAL_DNS_HOST_NAME = {0x80863791,0xDBE9,0x4eb8,0x83,0x7E,0x7F,0x0A,0xB5,0x5D,0x9A,0xC7} ;
const GUID GUID_A_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME = {0x975571DF,0xA4D5,0x429a,0x9F,0x59,0xCD,0xC6,0x58,0x1D,0x91,0xE6} ;
const GUID GUID_A_MS_DS_ALL_USERS_TRUST_QUOTA    = {0xD3AA4A5C,0x4E03,0x4810,0x97,0xAA,0x2B,0x33,0x9E,0x7A,0x43,0x4B} ;
const GUID GUID_A_MS_DS_ALLOWED_DNS_SUFFIXES     = {0x8469441b,0x9ac4,0x4e45,0x82,0x05,0xbd,0x21,0x9d,0xbf,0x67,0x2d} ;
const GUID GUID_A_MS_DS_ALLOWED_TO_DELEGATE_TO   = {0x800D94D7,0xB7A1,0x42a1,0xB1,0x4D,0x7C,0xAE,0x14,0x23,0xD0,0x7F} ;
const GUID GUID_A_MS_DS_AUXILIARY_CLASSES        = {0xc4af1073,0xee50,0x4be0,0xb8,0xc0,0x89,0xa4,0x1f,0xe9,0x9a,0xbe} ;
const GUID GUID_A_MS_DS_APPROX_IMMED_SUBORDINATES = {0xe185d243,0xf6ce,0x4adb,0xb4,0x96,0xb0,0xc0,0x05,0xd7,0x82,0x3c} ;
const GUID GUID_A_MS_DS_BEHAVIOR_VERSION         = {0xd31a8757,0x2447,0x4545,0x80,0x81,0x3b,0xb6,0x10,0xca,0xcb,0xf2} ;
const GUID GUID_A_MS_DS_CACHED_MEMBERSHIP        = {0x69cab008,0xcdd4,0x4bc9,0xba,0xb8,0x0f,0xf3,0x7e,0xfe,0x1b,0x20} ;
const GUID GUID_A_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP = {0x3566bf1f,0xbeee,0x4dcb,0x8a,0xbe,0xef,0x89,0xfc,0xfe,0xc6,0xc1} ;
const GUID GUID_A_MS_DS_CONSISTENCY_GUID         = {0x23773dc2,0xb63a,0x11d2,0x90,0xe1,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MS_DS_CONSISTENCY_CHILD_COUNT  = {0x178b7bc2,0xb63a,0x11d2,0x90,0xe1,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MS_DS_CREATOR_SID              = {0xc5e60132,0x1480,0x11d3,0x91,0xc1,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_DS_DNSROOTALIAS             = {0x2143ACCA,0xEEAD,0x4d29,0xB5,0x91,0x85,0xFA,0x49,0xCE,0x91,0x73} ;
const GUID GUID_A_MS_DS_ENTRY_TIME_TO_DIE        = {0xe1e9bad7,0xc6dd,0x4101,0xa8,0x43,0x79,0x4c,0xec,0x85,0xb0,0x38} ;
const GUID GUID_A_MS_DS_EXECUTESCRIPTPASSWORD    = {0x9D054A5A,0xD187,0x46c1,0x9D,0x85,0x42,0xDF,0xC4,0x4A,0x56,0xDD} ;
const GUID GUID_A_MS_DS_FILTER_CONTAINERS        = {0xfb00dcdf,0xac37,0x483a,0x9c,0x12,0xac,0x53,0xa6,0x60,0x30,0x33} ;
const GUID GUID_A_MS_DS_HAS_INSTANTIATED_NCS     = {0x11e9a5bc,0x4517,0x4049,0xaf,0x9c,0x51,0x55,0x4f,0xb0,0xfc,0x09} ;
const GUID GUID_A_MS_DS_INTID                    = {0xBC60096A,0x1B47,0x4b30,0x88,0x77,0x60,0x2C,0x93,0xF5,0x65,0x32} ;
const GUID GUID_A_MS_DS_LOGON_TIME_SYNC_INTERVAL = {0xAD7940F8,0xE43A,0x4a42,0x83,0xBC,0xD6,0x88,0xE5,0x9E,0xA6,0x05} ;
const GUID GUID_A_MS_DS_TRUST_FOREST_TRUST_INFO  = {0x29cc866e,0x49d3,0x4969,0x94,0x2e,0x1d,0xbc,0x09,0x25,0xd1,0x83} ;
const GUID GUID_A_MS_DS_MACHINE_ACCOUNT_QUOTA    = {0xd064fb68,0x1480,0x11d3,0x91,0xc1,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_DS_OTHER_SETTINGS           = {0x79d2f34c,0x9d7d,0x42bb,0x83,0x8f,0x86,0x6b,0x3e,0x44,0x00,0xe2} ;
const GUID GUID_A_MS_DS_NC_REPL_CURSORS          = {0x8a167ce4,0xf9e8,0x47eb,0x8d,0x78,0xf7,0xfe,0x80,0xab,0xb2,0xcc} ;
const GUID GUID_A_MS_DS_NC_REPL_INBOUND_NEIGHBORS = {0x9edba85a,0x3e9e,0x431b,0x9b,0x1a,0xa5,0xb6,0xe9,0xed,0xa7,0x96} ;
const GUID GUID_A_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS = {0x855f2ef5,0xa1c5,0x4cc4,0xba,0x6d,0x32,0x52,0x28,0x48,0xb6,0x1f} ;
const GUID GUID_A_MS_DS_NC_REPLICA_LOCATIONS     = {0x97de9615,0xb537,0x46bc,0xac,0x0f,0x10,0x72,0x0f,0x39,0x09,0xf3} ;
const GUID GUID_A_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES = {0x2de144fc,0x1f52,0x486f,0xbd,0xf4,0x16,0xfc,0xc3,0x08,0x4e,0x54} ;
const GUID GUID_A_MS_DS_PER_USER_TRUST_QUOTA     = {0xD161ADF0,0xCA24,0x4993,0xA3,0xAA,0x8B,0x2C,0x98,0x13,0x02,0xE8} ;
const GUID GUID_A_MS_DS_PER_USER_TRUST_TOMBSTONES_QUOTA = {0x8B70A6C6,0x50F9,0x4fa3,0xA7,0x1E,0x1C,0xE0,0x30,0x40,0x44,0x9B} ;
const GUID GUID_A_MS_DS_PREFERRED_GC_SITE        = {0xd921b50a,0x0ab2,0x42cd,0x87,0xf6,0x09,0xcf,0x83,0xa9,0x18,0x54} ;
const GUID GUID_A_MS_DS_REPL_ATTRIBUTE_META_DATA = {0xd7c53242,0x724e,0x4c39,0x9d,0x4c,0x2d,0xf8,0xc9,0xd6,0x6c,0x7a} ;
const GUID GUID_A_MS_DS_REPL_VALUE_META_DATA     = {0x2f5c8145,0xe1bd,0x410b,0x89,0x57,0x8b,0xfa,0x81,0xd5,0xac,0xfd} ;
const GUID GUID_A_MS_DS_REPLICATES_NC_REASON     = {0x0ea12b84,0x08b3,0x11d3,0x91,0xbc,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY = {0x85abd4f4,0x0a89,0x4e49,0xbd,0xec,0x6f,0x35,0xbb,0x25,0x62,0xba} ;
const GUID GUID_A_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY = {0xd63db385,0xdd92,0x4b52,0xb1,0xd8,0x0d,0x3e,0xcc,0x0e,0x86,0xb6} ;
const GUID GUID_A_MS_DS_REPLICATIONEPOCH         = {0x08E3AA79,0xEB1C,0x45b5,0xAF,0x7B,0x8F,0x94,0x24,0x6C,0x8E,0x41} ;
const GUID GUID_A_MS_DS_SCHEMA_EXTENSIONS        = {0xb39a61be,0xed07,0x4cab,0x9a,0x4a,0x49,0x63,0xed,0x01,0x41,0xe1} ;
const GUID GUID_A_MS_DS_SD_REFERENCE_DOMAIN      = {0x4c51e316,0xf628,0x43a5,0xb0,0x6b,0xff,0xb6,0x95,0xfc,0xb4,0xf3} ;
const GUID GUID_A_MS_DS_SECURITY_GROUP_EXTRA_CLASSES = {0x4f146ae8,0xa4fe,0x4801,0xa7,0x31,0xf5,0x18,0x48,0xa4,0xf4,0xe4} ;
const GUID GUID_A_MS_DS_SETTINGS                 = {0x0e1b47d7,0x40a3,0x4b48,0x8d,0x1b,0x4c,0xac,0x0c,0x1c,0xdf,0x21} ;
const GUID GUID_A_MS_DS_SITE_AFFINITY            = {0xc17c5602,0xbcb7,0x46f0,0x96,0x56,0x63,0x70,0xca,0x88,0x4b,0x72} ;
const GUID GUID_A_MS_DS_SPN_SUFFIXES             = {0x789EE1EB,0x8C8E,0x4e4c,0x8C,0xEC,0x79,0xB3,0x1B,0x76,0x17,0xB5} ;
const GUID GUID_A_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED = {0x2cc4b836,0xb63f,0x4940,0x8d,0x23,0xea,0x7a,0xcf,0x06,0xaf,0x56} ;
const GUID GUID_A_MS_DS_UPDATESCRIPT             = {0x146EB639,0xBB9F,0x4fc1,0xA8,0x25,0xE2,0x9E,0x00,0xC7,0x79,0x20} ;
const GUID GUID_A_MS_EXCH_ASSISTANT_NAME         = {0xa8df7394,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MS_EXCH_LABELEDURI             = {0x16775820,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MS_EXCH_OWNER_BL               = {0xbf9679f4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MS_FRS_HUB_MEMBER              = {0x5643ff81,0x35b6,0x4ca9,0x95,0x12,0xba,0xf0,0xbd,0x0a,0x27,0x72} ;
const GUID GUID_A_MS_FRS_TOPOLOGY_PREF           = {0x92aa27e0,0x5c50,0x402d,0x9e,0xc1,0xee,0x84,0x7d,0xef,0x97,0x88} ;
const GUID GUID_A_MS_IIS_FTP_DIR                 = {0x8A5C99E9,0x2230,0x46eb,0xB8,0xE8,0xE5,0x9D,0x71,0x2E,0xB9,0xEE} ;
const GUID GUID_A_MS_IIS_FTP_ROOT                = {0x2A7827A4,0x1483,0x49a5,0x9D,0x84,0x52,0xE3,0x81,0x21,0x56,0xB4} ;
const GUID GUID_A_MS_MMS_DATA                    = {0x2C932A0A,0x3A6A,0x4355,0xA8,0x29,0xAA,0xE7,0xC0,0x96,0x64,0xE2} ;
const GUID GUID_A_MS_MMS_INDEX                   = {0x6A0241A0,0x5113,0x401e,0x80,0x29,0x12,0x8A,0xCA,0x66,0x3A,0xD3} ;
const GUID GUID_A_MS_MMS_INDICE                  = {0x88324E04,0xB40E,0x4db8,0xB2,0x12,0xDC,0x9F,0xAA,0x13,0xDC,0xA1} ;
const GUID GUID_A_MS_MMS_XML                     = {0xF095AD85,0x9640,0x4854,0xB5,0x46,0xDE,0x1C,0x68,0x83,0xCF,0x8C} ;
const GUID GUID_A_MS_MMS_JOIN_LINK               = {0xF97A615E,0x53C2,0x4ff9,0x88,0x56,0xA4,0xE2,0xF7,0x49,0xA3,0x1F} ;
const GUID GUID_A_MS_MMS_LINEAGE                 = {0x986CF685,0xC959,0x491e,0x93,0x3F,0xB7,0xAD,0x14,0xD7,0x5F,0x80} ;
const GUID GUID_A_MS_MMS_PROV_STATUS             = {0xC4A8A988,0xAAC8,0x4923,0x84,0x07,0xFA,0x6E,0xD0,0xC6,0x10,0x8F} ;
const GUID GUID_A_MS_MMS_SYNC_STATUS             = {0x33EF0752,0xDB35,0x42a8,0xB9,0xED,0x5E,0x8A,0x80,0x06,0x25,0xA9} ;
const GUID GUID_A_MS_MMS_PARTITION               = {0x1639D32A,0xDCBF,0x4a7f,0xA5,0xF8,0xB2,0xBF,0x06,0xF7,0xD7,0x28} ;
const GUID GUID_A_MS_MMS_MA_STAGING_LINK         = {0x0213CC88,0x9DF3,0x4c67,0xA7,0xCC,0x39,0xA0,0x1F,0x25,0x3A,0x6B} ;
const GUID GUID_A_MS_MMS_MA_STAGING_BL           = {0x81E8AD0E,0x8A80,0x4095,0x87,0x26,0x2C,0xD4,0xFD,0x2B,0xE5,0x17} ;
const GUID GUID_A_MS_MMS_PROVISIONING_LINK       = {0xC0F22151,0x7939,0x4558,0xA5,0x9A,0xBB,0xFB,0xD4,0x7E,0x4C,0xA3} ;
const GUID GUID_A_MS_MMS_PROVISIONING_BL         = {0x5F37DD5B,0x9627,0x4929,0x9D,0x1A,0x2E,0xE6,0xA7,0xC9,0xCD,0xAD} ;
const GUID GUID_A_MS_MMS_ASSOCIATED_LINK         = {0xB81B5468,0x5322,0x46c3,0x91,0xC2,0x91,0xC1,0x40,0xD9,0xBB,0x2F} ;
const GUID GUID_A_MS_MMS_ASSOCIATED_BL           = {0xC11DABEC,0x18C4,0x4483,0xAF,0x39,0x95,0x37,0x1F,0xA5,0x6F,0xE8} ;
const GUID GUID_A_MS_MMS_SCOPE_LINK              = {0x64A713D0,0x7ADC,0x4336,0x81,0xD1,0xD1,0x81,0x84,0x55,0xED,0xCE} ;
const GUID GUID_A_MS_MMS_SCOPE_BL                = {0x8222552D,0xBBE0,0x4415,0xB6,0x21,0xBA,0x73,0x7C,0x09,0x81,0xD7} ;
const GUID GUID_A_MS_MMS_CRITERIA                = {0xAD16C1ED,0x7D82,0x4281,0xA2,0x6D,0x7D,0x26,0x41,0x68,0xCD,0x7A} ;
const GUID GUID_A_MS_MMS_DOMAIN_CONTROLLER       = {0x58279508,0x8E8D,0x4a22,0x9C,0xE2,0xB8,0x44,0xD4,0xD4,0x9D,0x44} ;
const GUID GUID_A_MS_MMS_SERVICE_NAME            = {0x600D5CD3,0xB7CE,0x4b81,0xBE,0xB6,0xFE,0x42,0x15,0x6F,0x6D,0x21} ;
const GUID GUID_A_MS_MMS_INSTANCE_CONFIGURATION  = {0xC63CB54F,0x271B,0x4bb5,0x91,0xB2,0x6D,0x5E,0xAC,0xBF,0xA9,0xCA} ;
const GUID GUID_A_MS_MMS_TOOLS_CONFIGURATION     = {0x8B38FB1C,0x1332,0x4d7d,0x97,0x9E,0xD4,0x6F,0x81,0x74,0xBF,0x67} ;
const GUID GUID_A_MS_MMS_INSTANCE_RULE           = {0xDEF7933A,0xB535,0x495b,0xBB,0x81,0xC4,0x28,0x67,0xCB,0xD6,0x2D} ;
const GUID GUID_A_MS_MMS_INSTALL_STATUS          = {0x630BE6FA,0x4F78,0x48fe,0x8F,0x8E,0x48,0x98,0xC8,0x17,0xE1,0x49} ;
const GUID GUID_A_MS_MMS_VERSION                 = {0xC0CC1BAA,0x2DDA,0x468b,0x95,0x19,0x4D,0xD2,0x91,0xEE,0xA2,0x47} ;
const GUID GUID_A_MS_MMS_CONNECTOR_SPACE         = {0xFE6460D3,0x600F,0x4c6b,0x92,0xCF,0x48,0xD9,0x05,0xC8,0x55,0x7F} ;
const GUID GUID_A_MS_MMS_SCOPE                   = {0xBF202F6C,0xAE12,0x4d83,0xBE,0x91,0x9D,0x99,0x45,0xE9,0xF9,0x62} ;
const GUID GUID_A_MS_MMS_INSTANCE_SCHEDULE       = {0x971D8AB5,0x66F5,0x4aa0,0xA5,0x71,0xF5,0xCB,0xCC,0x04,0xA4,0xA6} ;
const GUID GUID_A_MS_MMS_INSTANCE_INFO           = {0x95C40C18,0x37B8,0x4f9c,0xBB,0x0A,0x55,0xFE,0xB9,0x39,0xC8,0xFF} ;
const GUID GUID_A_MS_MMS_MA_CONFIGURATION        = {0xBD5295BF,0x20D1,0x4ff5,0x88,0x72,0x2C,0xB7,0xA1,0x5E,0x03,0xBB} ;
const GUID GUID_A_MS_MMS_MA_CONFIGURATION_PRIVATE = {0x64DE5AA1,0x0754,0x400e,0xB7,0xC4,0x38,0x01,0x6A,0x11,0x35,0xDD} ;
const GUID GUID_A_MS_MMS_MA_SCHEMA               = {0xB264965C,0x8B1B,0x4bbc,0x9F,0x68,0x6F,0xD7,0xDD,0x3C,0xDC,0xB0} ;
const GUID GUID_A_MS_MMS_MA_MAP                  = {0x521FA005,0x13F0,0x46fe,0x80,0x6D,0xC2,0x62,0xE4,0x3F,0x34,0xD2} ;
const GUID GUID_A_MS_MMS_MA_CAPABILITY           = {0xF27723A6,0xEB6D,0x4d07,0x8E,0xF2,0xE1,0xE4,0x79,0xC7,0x70,0x79} ;
const GUID GUID_A_MS_MMS_MA_EXECUTION_HISTORY    = {0x3B3F3C6F,0xCA7B,0x43dd,0xB4,0xCD,0x3F,0x4F,0x0B,0xBD,0xD9,0xB0} ;
const GUID GUID_A_MS_MMS_MA_CATEGORY             = {0x7D154627,0xDDFB,0x4ae1,0xBC,0x81,0x24,0x64,0x5A,0x22,0x2F,0x72} ;
const GUID GUID_A_MS_MMS_MA_AD_INFO              = {0x152CE635,0x902E,0x4426,0x90,0x95,0xA1,0xF7,0x53,0x8A,0x12,0xA4} ;
const GUID GUID_A_MS_MMS_MA_CD_INFO              = {0xEF8AC6B5,0xDE40,0x46b6,0x85,0x28,0x3F,0x4A,0x12,0x04,0x2C,0xFF} ;
const GUID GUID_A_MS_MMS_MA_PROCESS_INFO         = {0x1099BEB7,0x62E5,0x4db5,0xB9,0x67,0x0D,0x4F,0xB1,0xFD,0xA6,0xB9} ;
const GUID GUID_A_MS_MMS_MA_SCRIPT_INFO          = {0x5874362D,0x2263,0x4c0e,0x94,0x74,0x2E,0x62,0xAD,0xA6,0xFF,0x1D} ;
const GUID GUID_A_MS_MMS_MA_SYSTEM               = {0xFC147801,0x50BC,0x4225,0x8D,0x94,0xDA,0x3E,0x6F,0x56,0x69,0x79} ;
const GUID GUID_A_MS_MMS_MA_SYNCHRONIZATION      = {0xB202FD78,0xEEA9,0x4d0b,0xB3,0xEF,0x91,0x4B,0xAC,0x57,0x5D,0xE8} ;
const GUID GUID_A_MS_MMS_JOIN_BL                 = {0xCF7F5403,0x0DDE,0x45cf,0xA2,0x30,0x31,0x77,0xF5,0x87,0x51,0x63} ;
const GUID GUID_A_MS_MMS_ANCHOR                  = {0x09557524,0x668E,0x4385,0xB5,0x90,0x22,0x1E,0xD9,0xBC,0xBF,0x81} ;
const GUID GUID_A_MS_MMS_EXPORT_KEY              = {0xBAFDD6B6,0xE4F7,0x4f21,0x8E,0xC7,0x13,0x74,0x23,0x17,0x70,0xCC} ;
const GUID GUID_A_MS_MMS_IMPORT_KEY              = {0x14B28420,0x8959,0x4c29,0xB2,0xC8,0x70,0x79,0x12,0x75,0x30,0x91} ;
const GUID GUID_A_MS_MMS_STATE                   = {0xA18DA401,0xCEDA,0x40da,0x84,0x04,0xEB,0x00,0x59,0x7E,0x02,0xD2} ;
const GUID GUID_A_MS_MMS_HOLOGRAM                = {0xF3D35AE9,0x1B03,0x49d7,0x95,0x3E,0x73,0x96,0x2B,0xF8,0x21,0xF4} ;
const GUID GUID_A_MS_MMS_DELTA_HOLOGRAM          = {0x8F8F8DEE,0xA76C,0x4738,0xB3,0xB9,0xD0,0xED,0x37,0x21,0xF1,0x34} ;
const GUID GUID_A_MS_MMS_PROVISIONING_CONFIGURATION = {0x474CD358,0x2582,0x439a,0x8A,0xFB,0x0B,0xFF,0xAA,0x12,0x62,0x98} ;
const GUID GUID_A_MS_MMS_PROVISIONING_CONFIGURATION_PRIVATE = {0xF49566C7,0xC975,0x4ddf,0xA1,0x91,0xBA,0xDD,0x50,0x9C,0x7D,0xE5} ;
const GUID GUID_A_MS_MMS_PROVISIONING_AD_INFO    = {0xADC14CAB,0x63EA,0x4844,0xB2,0x98,0xB7,0xC4,0xB8,0x69,0x2B,0xF6} ;
const GUID GUID_A_MS_MMS_PROVISIONING_SYSTEM     = {0xC2C53322,0x32EB,0x455a,0x90,0xD3,0x8F,0x89,0x32,0x7F,0xAA,0xA9} ;
const GUID GUID_A_MS_MMS_PROVISIONING_STATUS_XML = {0x3A04642D,0x5131,0x43bf,0xA1,0x12,0xAF,0xE5,0x34,0x2B,0x34,0x20} ;
const GUID GUID_A_MS_MMS_PROVISIONING_STATUS_BINARY = {0xA9E63C54,0x2787,0x467a,0x8B,0x49,0x6F,0x41,0x91,0x29,0xAD,0xDB} ;
const GUID GUID_A_MS_PKI_CERT_TEMPLATE_OID       = {0x3164c36a,0xba26,0x468c,0x8b,0xda,0xc1,0xe5,0xcc,0x25,0x67,0x28} ;
const GUID GUID_A_MS_PKI_CERTIFICATE_APPLICATION_POLICY = {0xdbd90548,0xaa37,0x4202,0x99,0x66,0x8c,0x53,0x7b,0xa5,0xce,0x32} ;
const GUID GUID_A_MS_PKI_CERTIFICATE_NAME_FLAG   = {0xea1dddc4,0x60ff,0x416e,0x8c,0xc0,0x17,0xce,0xe5,0x34,0xbc,0xe7} ;
const GUID GUID_A_MS_PKI_CERTIFICATE_POLICY      = {0x38942346,0xcc5b,0x424b,0xa7,0xd8,0x6f,0xfd,0x12,0x02,0x9c,0x5f} ;
const GUID GUID_A_MS_PKI_ENROLLMENT_FLAG         = {0xd15ef7d8,0xf226,0x46db,0xae,0x79,0xb3,0x4e,0x56,0x0b,0xd1,0x2c} ;
const GUID GUID_A_MS_PKI_MINIMAL_KEY_SIZE        = {0xe96a63f5,0x417f,0x46d3,0xbe,0x52,0xdb,0x77,0x03,0xc5,0x03,0xdf} ;
const GUID GUID_A_MS_PKI_OID_ATTRIBUTE           = {0x8c9e1288,0x5028,0x4f4f,0xa7,0x04,0x76,0xd0,0x26,0xf2,0x46,0xef} ;
const GUID GUID_A_MS_PKI_OID_CPS                 = {0x5f49940e,0xa79f,0x4a51,0xbb,0x6f,0x3d,0x44,0x6a,0x54,0xdc,0x6b} ;
const GUID GUID_A_MS_PKI_OID_LOCALIZEDNAME       = {0x7d59a816,0xbb05,0x4a72,0x97,0x1f,0x5c,0x13,0x31,0xf6,0x75,0x59} ;
const GUID GUID_A_MS_PKI_OID_USER_NOTICE         = {0x04c4da7a,0xe114,0x4e69,0x88,0xde,0xe2,0x93,0xf2,0xd3,0xb3,0x95} ;
const GUID GUID_A_MS_PKI_PRIVATE_KEY_FLAG        = {0xbab04ac2,0x0435,0x4709,0x93,0x07,0x28,0x38,0x0e,0x7c,0x70,0x01} ;
const GUID GUID_A_MS_PKI_SUPERSEDE_TEMPLATES     = {0x9de8ae7d,0x7a5b,0x421d,0xb5,0xe4,0x06,0x1f,0x79,0xdf,0xd5,0xd7} ;
const GUID GUID_A_MS_PKI_TEMPLATE_MINOR_REVISION = {0x13f5236c,0x1884,0x46b1,0xb5,0xd0,0x48,0x4e,0x38,0x99,0x0d,0x58} ;
const GUID GUID_A_MS_PKI_TEMPLATE_SCHEMA_VERSION = {0x0c15e9f5,0x491d,0x4594,0x91,0x8f,0x32,0x81,0x3a,0x09,0x1d,0xa9} ;
const GUID GUID_A_MS_PKI_RA_APPLICATION_POLICIES = {0x3c91fbbf,0x4773,0x4ccd,0xa8,0x7b,0x85,0xd5,0x3e,0x7b,0xcf,0x6a} ;
const GUID GUID_A_MS_PKI_RA_POLICIES             = {0xd546ae22,0x0951,0x4d47,0x81,0x7e,0x1c,0x9f,0x96,0xfa,0xad,0x46} ;
const GUID GUID_A_MS_PKI_RA_SIGNATURE            = {0xfe17e04b,0x937d,0x4f7e,0x8e,0x0e,0x92,0x92,0xc8,0xd5,0x68,0x3e} ;
const GUID GUID_A_MS_RRAS_ATTRIBUTE              = {0xf39b98ad,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY = {0xf39b98ac,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MS_SQL_NAME                    = {0x3532dfd8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_REGISTEREDOWNER         = {0x48fd44ea,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_CONTACT                 = {0x4f6cbdd8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_LOCATION                = {0x561c9644,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_MEMORY                  = {0x5b5d448c,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_BUILD                   = {0x603e94c4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_SERVICEACCOUNT          = {0x64933a3e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_CHARACTERSET            = {0x696177a6,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_SORTORDER               = {0x6ddc42c0,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_UNICODESORTORDER        = {0x72dc918a,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_CLUSTERED               = {0x7778bd90,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_NAMEDPIPE               = {0x7b91c840,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_MULTIPROTOCOL           = {0x8157fa38,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_SPX                     = {0x86b08004,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_TCPIP                   = {0x8ac263a6,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_APPLETALK               = {0x8fda89f4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_VINES                   = {0x94c56394,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_STATUS                  = {0x9a7d4770,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_LASTUPDATEDDATE         = {0x9fcc43d4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_INFORMATIONURL          = {0xa42cd510,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_CONNECTIONURL           = {0xa92d23da,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_PUBLICATIONURL          = {0xae0c11b8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_GPSLATITUDE             = {0xb222ba0e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_GPSLONGITUDE            = {0xb7577c94,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_GPSHEIGHT               = {0xbcdd4f0e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_VERSION                 = {0xc07cc1d0,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_LANGUAGE                = {0xc57f72f4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_DESCRIPTION             = {0x8386603c,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_TYPE                    = {0xca48eba8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_INFORMATIONDIRECTORY    = {0xd0aedb2e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_DATABASE                = {0xd5a0dbdc,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION = {0xdb77be4a,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALIAS                   = {0xe0c6baae,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_SIZE                    = {0xe9098084,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_CREATIONDATE            = {0xede14754,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_LASTBACKUPDATE          = {0xf2b6abca,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_LASTDIAGNOSTICDATE      = {0xf6d6dd88,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_APPLICATIONS            = {0xfbcda2ea,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_KEYWORDS                = {0x01e9a98a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_PUBLISHER               = {0xc1676858,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION = {0xc3bb7054,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTION = {0xc4186b6e,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION = {0xc458ca80,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING = {0xc49b8be8,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_THIRDPARTY              = {0xc4e311fc,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_TAPI_CONFERENCE_BLOB        = {0x4cc4601e,0x7201,0x4141,0xab,0xc8,0x3e,0x52,0x9a,0xe8,0x88,0x63} ;
const GUID GUID_A_MS_TAPI_IP_ADDRESS             = {0xefd7d7f7,0x178e,0x4767,0x87,0xfa,0xf8,0xa1,0x6b,0x84,0x05,0x44} ;
const GUID GUID_A_MS_TAPI_PROTOCOL_ID            = {0x89c1ebcf,0x7a5f,0x41fd,0x99,0xca,0xc9,0x00,0xb3,0x22,0x99,0xab} ;
const GUID GUID_A_MS_TAPI_UNIQUE_IDENTIFIER      = {0x70a4e7ea,0xb3b9,0x4643,0x89,0x18,0xe6,0xdd,0x24,0x71,0xbf,0xd4} ;
const GUID GUID_A_MS_WMI_AUTHOR                  = {0x6366c0c1,0x6972,0x4e66,0xb3,0xa5,0x1d,0x52,0xad,0x0c,0x05,0x47} ;
const GUID GUID_A_MS_WMI_CHANGEDATE              = {0xf9cdf7a0,0xec44,0x4937,0xa7,0x9b,0xcd,0x91,0x52,0x2b,0x3a,0xa8} ;
const GUID GUID_A_MS_WMI_CLASS                   = {0x90c1925f,0x4a24,0x4b07,0xb2,0x02,0xbe,0x32,0xeb,0x3c,0x8b,0x74} ;
const GUID GUID_A_MS_WMI_CLASSDEFINITION         = {0x2b9c0ebc,0xc272,0x45cb,0x99,0xd2,0x4d,0x0e,0x69,0x16,0x32,0xe0} ;
const GUID GUID_A_MS_WMI_CREATIONDATE            = {0x748b0a2e,0x3351,0x4b3f,0xb1,0x71,0x2f,0x17,0x41,0x4e,0xa7,0x79} ;
const GUID GUID_A_MS_WMI_GENUS                   = {0x50c8673a,0x8f56,0x4614,0x93,0x08,0x9e,0x13,0x40,0xfb,0x9a,0xf3} ;
const GUID GUID_A_MS_WMI_ID                      = {0x9339a803,0x94b8,0x47f7,0x91,0x23,0xa8,0x53,0xb9,0xff,0x7e,0x45} ;
const GUID GUID_A_MS_WMI_INTDEFAULT              = {0x1b0c07f8,0x76dd,0x4060,0xa1,0xe1,0x70,0x08,0x46,0x19,0xdc,0x90} ;
const GUID GUID_A_MS_WMI_INTFLAGS1               = {0x18e006b9,0x6445,0x48e3,0x9d,0xcf,0xb5,0xec,0xfb,0xc4,0xdf,0x8e} ;
const GUID GUID_A_MS_WMI_INTFLAGS2               = {0x075a42c9,0xc55a,0x45b1,0xac,0x93,0xeb,0x08,0x6b,0x31,0xf6,0x10} ;
const GUID GUID_A_MS_WMI_INTFLAGS3               = {0xf29fa736,0xde09,0x4be4,0xb2,0x3a,0xe7,0x34,0xc1,0x24,0xba,0xcc} ;
const GUID GUID_A_MS_WMI_INTFLAGS4               = {0xbd74a7ac,0xc493,0x4c9c,0xbd,0xfa,0x5c,0x7b,0x11,0x9c,0xa6,0xb2} ;
const GUID GUID_A_MS_WMI_INTMAX                  = {0xfb920c2c,0xf294,0x4426,0x8a,0xc1,0xd2,0x4b,0x42,0xaa,0x2b,0xce} ;
const GUID GUID_A_MS_WMI_INTMIN                  = {0x68c2e3ba,0x9837,0x4c70,0x98,0xe0,0xf0,0xc3,0x36,0x95,0xd0,0x23} ;
const GUID GUID_A_MS_WMI_INTVALIDVALUES          = {0x6af565f6,0xa749,0x4b72,0x96,0x34,0x3c,0x5d,0x47,0xe6,0xb4,0xe0} ;
const GUID GUID_A_MS_WMI_INT8DEFAULT             = {0xf4d8085a,0x8c5b,0x4785,0x95,0x9b,0xdc,0x58,0x55,0x66,0xe4,0x45} ;
const GUID GUID_A_MS_WMI_INT8MAX                 = {0xe3d8b547,0x003d,0x4946,0xa3,0x2b,0xdc,0x7c,0xed,0xc9,0x6b,0x74} ;
const GUID GUID_A_MS_WMI_INT8MIN                 = {0xed1489d1,0x54cc,0x4066,0xb3,0x68,0xa0,0x0d,0xaa,0x26,0x64,0xf1} ;
const GUID GUID_A_MS_WMI_INT8VALIDVALUES         = {0x103519a9,0xc002,0x441b,0x98,0x1a,0xb0,0xb3,0xe0,0x12,0xc8,0x03} ;
const GUID GUID_A_MS_WMI_MOF                     = {0x6736809f,0x2064,0x443e,0xa1,0x45,0x81,0x26,0x2b,0x1f,0x13,0x66} ;
const GUID GUID_A_MS_WMI_NAME                    = {0xc6c8ace5,0x7e81,0x42af,0xad,0x72,0x77,0x41,0x2c,0x59,0x41,0xc4} ;
const GUID GUID_A_MS_WMI_NORMALIZEDCLASS         = {0xeaba628f,0xeb8e,0x4fe9,0x83,0xfc,0x69,0x3b,0xe6,0x95,0x55,0x9b} ;
const GUID GUID_A_MS_WMI_PARM1                   = {0x27e81485,0xb1b0,0x4a8b,0xbe,0xdd,0xce,0x19,0xa8,0x37,0xe2,0x6e} ;
const GUID GUID_A_MS_WMI_PARM2                   = {0x0003508e,0x9c42,0x4a76,0xa8,0xf4,0x38,0xbf,0x64,0xba,0xb0,0xde} ;
const GUID GUID_A_MS_WMI_PARM3                   = {0x45958fb6,0x52bd,0x48ce,0x9f,0x9f,0xc2,0x71,0x2d,0x9f,0x2b,0xfc} ;
const GUID GUID_A_MS_WMI_PARM4                   = {0x3800d5a3,0xf1ce,0x4b82,0xa5,0x9a,0x15,0x28,0xea,0x79,0x5f,0x59} ;
const GUID GUID_A_MS_WMI_PROPERTYNAME            = {0xab920883,0xe7f8,0x4d72,0xb4,0xa0,0xc0,0x44,0x98,0x97,0x50,0x9d} ;
const GUID GUID_A_MS_WMI_QUERY                   = {0x65fff93e,0x35e3,0x45a3,0x85,0xae,0x87,0x6c,0x67,0x18,0x29,0x7f} ;
const GUID GUID_A_MS_WMI_QUERYLANGUAGE           = {0x7d3cfa98,0xc17b,0x4254,0x8b,0xd7,0x4d,0xe9,0xb9,0x32,0xa3,0x45} ;
const GUID GUID_A_MS_WMI_SCOPEGUID               = {0x87b78d51,0x405f,0x4b7f,0x80,0xed,0x2b,0xd2,0x87,0x86,0xf4,0x8d} ;
const GUID GUID_A_MS_WMI_SOURCEORGANIZATION      = {0x34f7ed6c,0x615d,0x418d,0xaa,0x00,0x54,0x9a,0x7d,0x7b,0xe0,0x3e} ;
const GUID GUID_A_MS_WMI_STRINGDEFAULT           = {0x152e42b6,0x37c5,0x4f55,0xab,0x48,0x16,0x06,0x38,0x4a,0x9a,0xea} ;
const GUID GUID_A_MS_WMI_STRINGVALIDVALUES       = {0x37609d31,0xa2bf,0x4b58,0x8f,0x53,0x2b,0x64,0xe5,0x7a,0x07,0x6d} ;
const GUID GUID_A_MS_WMI_TARGETCLASS             = {0x95b6d8d6,0xc9e8,0x4661,0xa2,0xbc,0x6a,0x5c,0xab,0xc0,0x4c,0x62} ;
const GUID GUID_A_MS_WMI_TARGETNAMESPACE         = {0x1c4ab61f,0x3420,0x44e5,0x84,0x9d,0x8b,0x5d,0xbf,0x60,0xfe,0xb7} ;
const GUID GUID_A_MS_WMI_TARGETOBJECT            = {0xc44f67a5,0x7de5,0x4a1f,0x92,0xd9,0x66,0x2b,0x57,0x36,0x4b,0x77} ;
const GUID GUID_A_MS_WMI_TARGETPATH              = {0x5006a79a,0x6bfe,0x4561,0x9f,0x52,0x13,0xcf,0x4d,0xd3,0xe5,0x60} ;
const GUID GUID_A_MS_WMI_TARGETTYPE              = {0xca2a281e,0x262b,0x4ff7,0xb4,0x19,0xbc,0x12,0x33,0x52,0xa4,0xe9} ;
const GUID GUID_A_MSCOPE_ID                      = {0x963d2751,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MSI_FILE_LIST                  = {0x7bfdcb7d,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MSI_SCRIPT                     = {0xd9e18313,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MSI_SCRIPT_NAME                = {0x96a7dd62,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MSI_SCRIPT_PATH                = {0xbf967937,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MSI_SCRIPT_SIZE                = {0x96a7dd63,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MSMQ_AUTHENTICATE              = {0x9a0dc326,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_BASE_PRIORITY             = {0x9a0dc323,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_COMPUTER_TYPE             = {0x9a0dc32e,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_COMPUTER_TYPE_EX          = {0x18120de8,0xf4c4,0x4341,0xbd,0x95,0x32,0xeb,0x5b,0xcf,0x7c,0x80} ;
const GUID GUID_A_MSMQ_COST                      = {0x9a0dc33a,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_CSP_NAME                  = {0x9a0dc334,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_DEPENDENT_CLIENT_SERVICE  = {0x2df90d83,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_DEPENDENT_CLIENT_SERVICES = {0x2df90d76,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_DIGESTS                   = {0x9a0dc33c,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_DIGESTS_MIG               = {0x0f71d8e0,0xda3b,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_DS_SERVICE                = {0x2df90d82,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_DS_SERVICES               = {0x2df90d78,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_ENCRYPT_KEY               = {0x9a0dc331,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_FOREIGN                   = {0x9a0dc32f,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_IN_ROUTING_SERVERS        = {0x9a0dc32c,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_INTERVAL1                 = {0x8ea825aa,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_INTERVAL2                 = {0x99b88f52,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_JOURNAL                   = {0x9a0dc321,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_JOURNAL_QUOTA             = {0x9a0dc324,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_LABEL                     = {0x9a0dc325,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_LABEL_EX                  = {0x4580ad25,0xd407,0x48d2,0xad,0x24,0x43,0xe6,0xe5,0x67,0x93,0xd7} ;
const GUID GUID_A_MSMQ_LONG_LIVED                = {0x9a0dc335,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_MIGRATED                  = {0x9a0dc33f,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_MULTICAST_ADDRESS         = {0x1d2f4412,0xf10d,0x4337,0x9b,0x48,0x6e,0x5b,0x12,0x5c,0xd2,0x65} ;
const GUID GUID_A_MSMQ_NAME_STYLE                = {0x9a0dc333,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_NT4_FLAGS                 = {0xeb38a158,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_NT4_STUB                  = {0x6f914be6,0xd57e,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_OS_TYPE                   = {0x9a0dc330,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_OUT_ROUTING_SERVERS       = {0x9a0dc32b,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_OWNER_ID                  = {0x9a0dc328,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_PREV_SITE_GATES           = {0x2df90d75,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_PRIVACY_LEVEL             = {0x9a0dc327,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_QM_ID                     = {0x9a0dc33e,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_QUEUE_JOURNAL_QUOTA       = {0x8e441266,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_QUEUE_NAME_EXT            = {0x2df90d87,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_QUEUE_QUOTA               = {0x3f6b8e12,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_QUEUE_TYPE                = {0x9a0dc320,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_QUOTA                     = {0x9a0dc322,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_RECIPIENT_FORMATNAME      = {0x3bfe6748,0xb544,0x485a,0xb0,0x67,0x1b,0x31,0x0c,0x43,0x34,0xbf} ;
const GUID GUID_A_MSMQ_ROUTING_SERVICE           = {0x2df90d81,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_ROUTING_SERVICES          = {0x2df90d77,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_SECURED_SOURCE            = {0x8bf0221b,0x7a06,0x4d63,0x91,0xf0,0x14,0x99,0x94,0x18,0x13,0xd3} ;
const GUID GUID_A_MSMQ_SERVICE_TYPE              = {0x9a0dc32d,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SERVICES                  = {0x9a0dc33d,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SIGN_CERTIFICATES         = {0x9a0dc33b,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SIGN_CERTIFICATES_MIG     = {0x3881b8ea,0xda3b,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_SIGN_KEY                  = {0x9a0dc332,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SITE_1                    = {0x9a0dc337,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SITE_2                    = {0x9a0dc338,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SITE_FOREIGN              = {0xfd129d8a,0xd57e,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_SITE_GATES                = {0x9a0dc339,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SITE_GATES_MIG            = {0xe2704852,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_SITE_ID                   = {0x9a0dc340,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SITE_NAME                 = {0xffadb4b2,0xde39,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_SITE_NAME_EX              = {0x422144fa,0xc17f,0x4649,0x94,0xd6,0x97,0x31,0xed,0x27,0x84,0xed} ;
const GUID GUID_A_MSMQ_SITES                     = {0x9a0dc32a,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_TRANSACTIONAL             = {0x9a0dc329,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_USER_SID                  = {0xc58aae32,0x56f9,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_VERSION                   = {0x9a0dc336,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSNPALLOWDIALIN                = {0xdb0c9085,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSNPCALLEDSTATIONID            = {0xdb0c9089,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSNPCALLINGSTATIONID           = {0xdb0c908a,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSNPSAVEDCALLINGSTATIONID      = {0xdb0c908e,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRADIUSCALLBACKNUMBER         = {0xdb0c909c,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRADIUSFRAMEDIPADDRESS        = {0xdb0c90a4,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRADIUSFRAMEDROUTE            = {0xdb0c90a9,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRADIUSSERVICETYPE            = {0xdb0c90b6,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRASSAVEDCALLBACKNUMBER       = {0xdb0c90c5,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRASSAVEDFRAMEDIPADDRESS      = {0xdb0c90c6,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRASSAVEDFRAMEDROUTE          = {0xdb0c90c7,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MUST_CONTAIN                   = {0xbf9679d3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NAME_SERVICE_FLAGS             = {0x80212840,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NC_NAME                        = {0xbf9679d6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NETBIOS_NAME                   = {0xbf9679d8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NETBOOT_ALLOW_NEW_CLIENTS      = {0x07383076,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_ANSWER_ONLY_VALID_CLIENTS = {0x0738307b,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_ANSWER_REQUESTS        = {0x0738307a,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_CURRENT_CLIENT_COUNT   = {0x07383079,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_GUID                   = {0x3e978921,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_NETBOOT_INITIALIZATION         = {0x3e978920,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_NETBOOT_INTELLIMIRROR_OSES     = {0x0738307e,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_LIMIT_CLIENTS          = {0x07383077,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_LOCALLY_INSTALLED_OSES = {0x07383080,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_MACHINE_FILE_PATH      = {0x3e978923,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_NETBOOT_MAX_CLIENTS            = {0x07383078,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_MIRROR_DATA_FILE       = {0x2df90d85,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_NETBOOT_NEW_MACHINE_NAMING_POLICY = {0x0738307c,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_NEW_MACHINE_OU         = {0x0738307d,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_SCP_BL                 = {0x07383082,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_SERVER                 = {0x07383081,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_SIF_FILE               = {0x2df90d84,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_NETBOOT_TOOLS                  = {0x0738307f,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETWORK_ADDRESS                = {0xbf9679d9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NEXT_LEVEL_STORE               = {0xbf9679da,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NEXT_RID                       = {0xbf9679db,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NON_SECURITY_MEMBER            = {0x52458018,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NON_SECURITY_MEMBER_BL         = {0x52458019,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NOTIFICATION_LIST              = {0x19195a56,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_NT_GROUP_MEMBERS               = {0xbf9679df,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NT_MIXED_DOMAIN                = {0x3e97891f,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_NT_PWD_HISTORY                 = {0xbf9679e2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NT_SECURITY_DESCRIPTOR         = {0xbf9679e3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJ_DIST_NAME                  = {0xbf9679e4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJECT_CATEGORY                = {0x26d97369,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_OBJECT_CLASS                   = {0xbf9679e5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJECT_CLASS_CATEGORY          = {0xbf9679e6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJECT_CLASSES                 = {0x9a7ad94b,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_OBJECT_COUNT                   = {0x34aaa216,0xb699,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_OBJECT_GUID                    = {0xbf9679e7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJECT_SID                     = {0xbf9679e8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJECT_VERSION                 = {0x16775848,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_OEM_INFORMATION                = {0xbf9679ea,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OM_OBJECT_CLASS                = {0xbf9679ec,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OM_SYNTAX                      = {0xbf9679ed,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OMT_GUID                       = {0xddac0cf3,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OMT_INDX_GUID                  = {0x1f0075fa,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPERATING_SYSTEM               = {0x3e978925,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPERATING_SYSTEM_HOTFIX        = {0xbd951b3c,0x9c96,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPERATING_SYSTEM_SERVICE_PACK  = {0x3e978927,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPERATING_SYSTEM_VERSION       = {0x3e978926,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPERATOR_COUNT                 = {0xbf9679ee,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OPTION_DESCRIPTION             = {0x963d274d,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_OPTIONS                        = {0x19195a53,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPTIONS_LOCATION               = {0x963d274e,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ORGANIZATION_NAME              = {0xbf9679ef,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ORGANIZATIONAL_UNIT_NAME       = {0xbf9679f0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ORIGINAL_DISPLAY_TABLE         = {0x5fd424ce,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ORIGINAL_DISPLAY_TABLE_MSDOS   = {0x5fd424cf,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_OTHER_LOGIN_WORKSTATIONS       = {0xbf9679f1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OTHER_MAILBOX                  = {0x0296c123,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_OTHER_NAME                     = {0xbf9679f2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OTHER_WELL_KNOWN_OBJECTS       = {0x1ea64e5d,0xac0f,0x11d2,0x90,0xdf,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_OWNER                          = {0xbf9679f3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PACKAGE_FLAGS                  = {0x7d6c0e99,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PACKAGE_NAME                   = {0x7d6c0e98,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PACKAGE_TYPE                   = {0x7d6c0e96,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PARENT_CA                      = {0x5245801b,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PARENT_CA_CERTIFICATE_CHAIN    = {0x963d2733,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PARENT_GUID                    = {0x2df90d74,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_PARTIAL_ATTRIBUTE_DELETION_LIST = {0x28630ec0,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PARTIAL_ATTRIBUTE_SET          = {0x19405b9e,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PEK_KEY_CHANGE_INTERVAL        = {0x07383084,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PEK_LIST                       = {0x07383083,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PENDING_CA_CERTIFICATES        = {0x963d273c,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PENDING_PARENT_CA              = {0x963d273e,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PER_MSG_DIALOG_DISPLAY_TABLE   = {0x5fd424d3,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PER_RECIP_DIALOG_DISPLAY_TABLE = {0x5fd424d4,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PERSONAL_TITLE                 = {0x16775858,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_FAX_OTHER                = {0x0296c11d,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_HOME_OTHER               = {0xf0f8ffa2,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHONE_HOME_PRIMARY             = {0xf0f8ffa1,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHONE_IP_OTHER                 = {0x4d146e4b,0x48d4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_IP_PRIMARY               = {0x4d146e4a,0x48d4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_ISDN_PRIMARY             = {0x0296c11f,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_MOBILE_OTHER             = {0x0296c11e,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_MOBILE_PRIMARY           = {0xf0f8ffa3,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHONE_OFFICE_OTHER             = {0xf0f8ffa5,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHONE_PAGER_OTHER              = {0xf0f8ffa4,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHONE_PAGER_PRIMARY            = {0xf0f8ffa6,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHOTO                          = {0x9C979768,0xBA1A,0x4c08,0x96,0x32,0xC6,0xA5,0xC1,0xED,0x64,0x9A} ;
const GUID GUID_A_PHYSICAL_DELIVERY_OFFICE_NAME  = {0xbf9679f7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PHYSICAL_LOCATION_OBJECT       = {0xb7b13119,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PICTURE                        = {0x8d3bca50,0x1d7e,0x11d0,0xa0,0x81,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PKI_CRITICAL_EXTENSIONS        = {0xfc5a9106,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_DEFAULT_CSPS               = {0x1ef6336e,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_DEFAULT_KEY_SPEC           = {0x426cae6e,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_ENROLLMENT_ACCESS          = {0x926be278,0x56f9,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_EXPIRATION_PERIOD          = {0x041570d2,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_EXTENDED_KEY_USAGE         = {0x18976af6,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_KEY_USAGE                  = {0xe9b0a87e,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_MAX_ISSUING_DEPTH          = {0xf0bfdefa,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_OVERLAP_PERIOD             = {0x1219a3ec,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKT                            = {0x8447f9f1,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PKT_GUID                       = {0x8447f9f0,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_POLICY_REPLICATION_FLAGS       = {0x19405b96,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PORT_NAME                      = {0x281416c4,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_POSS_SUPERIORS                 = {0xbf9679fa,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_POSSIBLE_INFERIORS             = {0x9a7ad94c,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_POST_OFFICE_BOX                = {0xbf9679fb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_POSTAL_ADDRESS                 = {0xbf9679fc,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_POSTAL_CODE                    = {0xbf9679fd,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PREFERRED_DELIVERY_METHOD      = {0xbf9679fe,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PREFERREDLANGUAGE              = {0x856BE0D0,0x18E7,0x46e1,0x8F,0x5F,0x7E,0xE4,0xD9,0x02,0x0E,0x0D} ;
const GUID GUID_A_PREFERRED_OU                   = {0xbf9679ff,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PREFIX_MAP                     = {0x52458022,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRESENTATION_ADDRESS           = {0xa8df744b,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_PREVIOUS_CA_CERTIFICATES       = {0x963d2739,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PREVIOUS_PARENT_CA             = {0x963d273d,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRIMARY_GROUP_ID               = {0xbf967a00,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRIMARY_GROUP_TOKEN            = {0xc0ed8738,0x7efd,0x4481,0x84,0xd9,0x66,0xd2,0xdb,0x8b,0xe3,0x69} ;
const GUID GUID_A_PRINT_ATTRIBUTES               = {0x281416d7,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_BIN_NAMES                = {0x281416cd,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_COLLATE                  = {0x281416d2,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_COLOR                    = {0x281416d3,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_DUPLEX_SUPPORTED         = {0x281416cc,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_END_TIME                 = {0x281416ca,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_FORM_NAME                = {0x281416cb,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_KEEP_PRINTED_JOBS        = {0xba305f6d,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_LANGUAGE                 = {0x281416d6,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_MAC_ADDRESS              = {0xba305f7a,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MAX_COPIES               = {0x281416d1,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_MAX_RESOLUTION_SUPPORTED = {0x281416cf,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_MAX_X_EXTENT             = {0xba305f6f,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MAX_Y_EXTENT             = {0xba305f70,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MEDIA_READY              = {0x3bcbfcf5,0x4d3d,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MEDIA_SUPPORTED          = {0x244b296f,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MEMORY                   = {0xba305f74,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MIN_X_EXTENT             = {0xba305f71,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MIN_Y_EXTENT             = {0xba305f72,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_NETWORK_ADDRESS          = {0xba305f79,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_NOTIFY                   = {0xba305f6a,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_NUMBER_UP                = {0x3bcbfcf4,0x4d3d,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_ORIENTATIONS_SUPPORTED   = {0x281416d0,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_OWNER                    = {0xba305f69,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_PAGES_PER_MINUTE         = {0x19405b97,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRINT_RATE                     = {0xba305f77,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_RATE_UNIT                = {0xba305f78,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_SEPARATOR_FILE           = {0x281416c6,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_SHARE_NAME               = {0xba305f68,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_SPOOLING                 = {0xba305f6c,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_STAPLING_SUPPORTED       = {0xba305f73,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_START_TIME               = {0x281416c9,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_STATUS                   = {0xba305f6b,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINTER_NAME                   = {0x244b296e,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRIOR_SET_TIME                 = {0xbf967a01,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRIOR_VALUE                    = {0xbf967a02,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRIORITY                       = {0x281416c7,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRIVATE_KEY                    = {0xbf967a03,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRIVILEGE_ATTRIBUTES           = {0x19405b9a,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRIVILEGE_DISPLAY_NAME         = {0x19405b98,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRIVILEGE_HOLDER               = {0x19405b9b,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRIVILEGE_VALUE                = {0x19405b99,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRODUCT_CODE                   = {0xd9e18317,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PROFILE_PATH                   = {0xbf967a05,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PROXIED_OBJECT_NAME            = {0xe1aea402,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PROXY_ADDRESSES                = {0xbf967a06,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PROXY_GENERATION_ENABLED       = {0x5fd424d6,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PROXY_LIFETIME                 = {0xbf967a07,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PUBLIC_KEY_POLICY              = {0x80a67e28,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PURPORTED_SEARCH               = {0xb4b54e50,0x943a,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PWD_HISTORY_LENGTH             = {0xbf967a09,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PWD_LAST_SET                   = {0xbf967a0a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PWD_PROPERTIES                 = {0xbf967a0b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_QUALITY_OF_SERVICE             = {0x80a67e4e,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_QUERY_FILTER                   = {0xcbf70a26,0x7e78,0x11d2,0x99,0x21,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_QUERY_POLICY_BL                = {0xe1aea404,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_QUERY_POLICY_OBJECT            = {0xe1aea403,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_QUERYPOINT                     = {0x7bfdcb86,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_RANGE_LOWER                    = {0xbf967a0c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RANGE_UPPER                    = {0xbf967a0d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RDN                            = {0xbf967a0e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RDN_ATT_ID                     = {0xbf967a0f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REGISTERED_ADDRESS             = {0xbf967a10,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REMOTE_SERVER_NAME             = {0xbf967a12,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REMOTE_SOURCE                  = {0xbf967a14,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REMOTE_SOURCE_TYPE             = {0xbf967a15,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REMOTE_STORAGE_GUID            = {0x2a39c5b0,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_REPL_PROPERTY_META_DATA        = {0x281416c0,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REPL_TOPOLOGY_STAY_OF_EXECUTION = {0x7bfdcb83,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_REPL_UPTODATE_VECTOR           = {0xbf967a16,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REPLICA_SOURCE                 = {0xbf967a18,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REPORTS                        = {0xbf967a1c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REPL_INTERVAL                  = {0x45ba9d1a,0x56fa,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_REPS_FROM                      = {0xbf967a1d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REPS_TO                        = {0xbf967a1e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REQUIRED_CATEGORIES            = {0x7d6c0e93,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RETIRED_REPL_DSA_SIGNATURES    = {0x7bfdcb7f,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TOKEN_GROUPS                   = {0xb7c69e6d,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08} ;
const GUID GUID_A_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL = {0x46a9b11d,0x60ae,0x405a,0xb7,0xe8,0xff,0x8a,0x58,0xd4,0x56,0xd2} ;
const GUID GUID_A_TOKEN_GROUPS_NO_GC_ACCEPTABLE  = {0x040fc392,0x33df,0x11d2,0x98,0xb2,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_REVISION                       = {0xbf967a21,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RID                            = {0xbf967a22,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RID_ALLOCATION_POOL            = {0x66171889,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RID_AVAILABLE_POOL             = {0x66171888,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RID_MANAGER_REFERENCE          = {0x66171886,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RID_NEXT_RID                   = {0x6617188c,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RID_PREVIOUS_ALLOCATION_POOL   = {0x6617188a,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RID_SET_REFERENCES             = {0x7bfdcb7b,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_RID_USED_POOL                  = {0x6617188b,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RIGHTS_GUID                    = {0x8297931c,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_ROLE_OCCUPANT                  = {0xa8df7465,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ROOMNUMBER                     = {0x81D7F8C2,0xE327,0x4a0d,0x91,0xC6,0xB4,0x2D,0x40,0x09,0x11,0x5F} ;
const GUID GUID_A_ROOT_TRUST                     = {0x7bfdcb80,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_RPC_NS_ANNOTATION              = {0x88611bde,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RPC_NS_BINDINGS                = {0xbf967a23,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RPC_NS_CODESET                 = {0x7a0ba0e0,0x8e98,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RPC_NS_ENTRY_FLAGS             = {0x80212841,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_RPC_NS_GROUP                   = {0xbf967a24,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RPC_NS_INTERFACE_ID            = {0xbf967a25,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RPC_NS_OBJECT_ID               = {0x29401c48,0x7a27,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RPC_NS_PRIORITY                = {0xbf967a27,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RPC_NS_PROFILE_ENTRY           = {0xbf967a28,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RPC_NS_TRANSFER_SYNTAX         = {0x29401c4a,0x7a27,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SAM_ACCOUNT_NAME               = {0x3e0abfd0,0x126a,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_SAM_ACCOUNT_TYPE               = {0x6e7b626c,0x64f2,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SCHEDULE                       = {0xdd712224,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_SCHEMA_FLAGS_EX                = {0xbf967a2b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SCHEMA_ID_GUID                 = {0xbf967923,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SCHEMA_INFO                    = {0xf9fb64ae,0x93b4,0x11d2,0x99,0x45,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_SCHEMA_UPDATE                  = {0x1e2d06b4,0xac8f,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SCHEMA_VERSION                 = {0xbf967a2c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SCOPE_FLAGS                    = {0x16f3a4c2,0x7e79,0x11d2,0x99,0x21,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_SCRIPT_PATH                    = {0xbf9679a8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SD_RIGHTS_EFFECTIVE            = {0xc3dbafa6,0x33df,0x11d2,0x98,0xb2,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_SEARCH_FLAGS                   = {0xbf967a2d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SEARCH_GUIDE                   = {0xbf967a2e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SECRETARY                      = {0x01072D9A,0x98AD,0x4a53,0x97,0x44,0xE8,0x3E,0x28,0x72,0x78,0xFB} ;
const GUID GUID_A_SECURITY_IDENTIFIER            = {0xbf967a2f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SEE_ALSO                       = {0xbf967a31,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SEQ_NOTIFICATION               = {0xddac0cf2,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SERIAL_NUMBER                  = {0xbf967a32,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVER_NAME                    = {0x09dcb7a0,0x165f,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_SERVER_REFERENCE               = {0x26d9736d,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVER_REFERENCE_BL            = {0x26d9736e,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVER_ROLE                    = {0xbf967a33,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVER_STATE                   = {0xbf967a34,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVICE_BINDING_INFORMATION    = {0xb7b1311c,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVICE_CLASS_ID               = {0xbf967a35,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVICE_CLASS_INFO             = {0xbf967a36,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVICE_CLASS_NAME             = {0xb7b1311d,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVICE_DNS_NAME               = {0x28630eb8,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVICE_DNS_NAME_TYPE          = {0x28630eba,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVICE_INSTANCE_VERSION       = {0xbf967a37,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVICE_PRINCIPAL_NAME         = {0xf3a64788,0x5306,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SETUP_COMMAND                  = {0x7d6c0e97,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SHELL_CONTEXT_MENU             = {0x553fd039,0xf32e,0x11d0,0xb0,0xbc,0x00,0xc0,0x4f,0xd8,0xdc,0xa6} ;
const GUID GUID_A_SHELL_PROPERTY_PAGES           = {0x52458039,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SHORT_SERVER_NAME              = {0x45b01501,0xc419,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_SHOW_IN_ADDRESS_BOOK           = {0x3e74f60e,0x3e73,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SHOW_IN_ADVANCED_VIEW_ONLY     = {0xbf967984,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SID_HISTORY                    = {0x17eb4278,0xd167,0x11d0,0xb0,0x02,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SIGNATURE_ALGORITHMS           = {0x2a39c5b2,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SITE_GUID                      = {0x3e978924,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SITE_LINK_LIST                 = {0xd50c2cdd,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SITE_LIST                      = {0xd50c2cdc,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SITE_OBJECT                    = {0x3e10944c,0xc354,0x11d0,0xaf,0xf8,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SITE_OBJECT_BL                 = {0x3e10944d,0xc354,0x11d0,0xaf,0xf8,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SITE_SERVER                    = {0x1be8f17c,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SMTP_MAIL_ADDRESS              = {0x26d9736f,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SPN_MAPPINGS                   = {0x2ab0e76c,0x7041,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_STATE_OR_PROVINCE_NAME         = {0xbf967a39,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_STREET_ADDRESS                 = {0xbf967a3a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_STRUCTURAL_OBJECT_CLASS        = {0x3860949f,0xf6a8,0x4b38,0x99,0x50,0x81,0xec,0xb6,0xbc,0x29,0x82} ;
const GUID GUID_A_SUB_CLASS_OF                   = {0xbf967a3b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SUB_REFS                       = {0xbf967a3c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SUBSCHEMASUBENTRY              = {0x9a7ad94d,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_SUPER_SCOPE_DESCRIPTION        = {0x963d274c,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SUPER_SCOPES                   = {0x963d274b,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SUPERIOR_DNS_ROOT              = {0x5245801d,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SUPPLEMENTAL_CREDENTIALS       = {0xbf967a3f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SUPPORTED_APPLICATION_CONTEXT  = {0x1677588f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SURNAME                        = {0xbf967a41,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SYNC_ATTRIBUTES                = {0x037651e4,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SYNC_MEMBERSHIP                = {0x037651e3,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SYNC_WITH_OBJECT               = {0x037651e2,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SYNC_WITH_SID                  = {0x037651e5,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SYSTEM_AUXILIARY_CLASS         = {0xbf967a43,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SYSTEM_FLAGS                   = {0xe0fa1e62,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SYSTEM_MAY_CONTAIN             = {0xbf967a44,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SYSTEM_MUST_CONTAIN            = {0xbf967a45,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SYSTEM_ONLY                    = {0xbf967a46,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SYSTEM_POSS_SUPERIORS          = {0xbf967a47,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TELEPHONE_NUMBER               = {0xbf967a49,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TELETEX_TERMINAL_IDENTIFIER    = {0xbf967a4a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TELEX_NUMBER                   = {0xbf967a4b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TELEX_PRIMARY                  = {0x0296c121,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TEMPLATE_ROOTS                 = {0xed9de9a0,0x7041,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_TERMINAL_SERVER                = {0x6db69a1c,0x9422,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TEXT_COUNTRY                   = {0xf0f8ffa7,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_TEXT_ENCODED_OR_ADDRESS        = {0xa8df7489,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_TIME_REFRESH                   = {0xddac0cf1,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_TIME_VOL_CHANGE                = {0xddac0cf0,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_TITLE                          = {0xbf967a55,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TOMBSTONE_LIFETIME             = {0x16c3a860,0x1273,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_TRANSPORT_ADDRESS_ATTRIBUTE    = {0xc1dc867c,0xa261,0x11d1,0xb6,0x06,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TRANSPORT_DLL_NAME             = {0x26d97372,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TRANSPORT_TYPE                 = {0x26d97374,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TREAT_AS_LEAF                  = {0x8fd044e3,0x771f,0x11d1,0xae,0xae,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TREE_NAME                      = {0x28630ebd,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TRUST_ATTRIBUTES               = {0x80a67e5a,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_TRUST_AUTH_INCOMING            = {0xbf967a59,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TRUST_AUTH_OUTGOING            = {0xbf967a5f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TRUST_DIRECTION                = {0xbf967a5c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TRUST_PARENT                   = {0xb000ea7a,0xa086,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_TRUST_PARTNER                  = {0xbf967a5d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TRUST_POSIX_OFFSET             = {0xbf967a5e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TRUST_TYPE                     = {0xbf967a60,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_UAS_COMPAT                     = {0xbf967a61,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_UID                            = {0x0BB0FCA0,0x1E89,0x429f,0x90,0x1A,0x14,0x13,0x89,0x4D,0x9F,0x59} ;
const GUID GUID_A_UNC_NAME                       = {0xbf967a64,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_UNICODE_PWD                    = {0xbf9679e1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_UNIQUEMEMBER                   = {0x8F888726,0xF80A,0x44d7,0xB1,0xEE,0xCB,0x9D,0xF2,0x13,0x92,0xC8} ;
const GUID GUID_A_UNSTRUCTUREDADDRESS            = {0x50950839,0xCC4C,0x4491,0x86,0x3A,0xFC,0xF9,0x42,0xD6,0x84,0xB7} ;
const GUID GUID_A_UNSTRUCTUREDNAME               = {0x9C8EF177,0x41CF,0x45c9,0x96,0x73,0x77,0x16,0xC0,0xC8,0x90,0x1B} ;
const GUID GUID_A_UPGRADE_PRODUCT_CODE           = {0xd9e18312,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_UPN_SUFFIXES                   = {0x032160bf,0x9824,0x11d1,0xae,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_USER_ACCOUNT_CONTROL           = {0xbf967a68,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USER_CERT                      = {0xbf967a69,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USER_COMMENT                   = {0xbf967a6a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USER_PARAMETERS                = {0xbf967a6d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USER_PASSWORD                  = {0xbf967a6e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USERPKCS12                     = {0x23998AB5,0x70F8,0x4007,0xA4,0xC1,0xA8,0x4A,0x38,0x31,0x1F,0x9A} ;
const GUID GUID_A_USER_PRINCIPAL_NAME            = {0x28630ebb,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_USER_SHARED_FOLDER             = {0x9a9a021f,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_USER_SHARED_FOLDER_OTHER       = {0x9a9a0220,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_USER_SMIME_CERTIFICATE         = {0xe16a9db2,0x403c,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_USER_WORKSTATIONS              = {0xbf9679d7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USN_CHANGED                    = {0xbf967a6f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USN_CREATED                    = {0xbf967a70,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USN_DSA_LAST_OBJ_REMOVED       = {0xbf967a71,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USN_INTERSITE                  = {0xa8df7498,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_USN_LAST_OBJ_REM               = {0xbf967a73,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USN_SOURCE                     = {0x167758ad,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_VALID_ACCESSES                 = {0x4d2fa380,0x7f54,0x11d2,0x99,0x2a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_VENDOR                         = {0x281416df,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_VERSION_NUMBER                 = {0xbf967a76,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_VERSION_NUMBER_HI              = {0x7d6c0e9a,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_VERSION_NUMBER_LO              = {0x7d6c0e9b,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_VOL_TABLE_GUID                 = {0x1f0075fd,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_VOL_TABLE_IDX_GUID             = {0x1f0075fb,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_VOLUME_COUNT                   = {0x34aaa217,0xb699,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_WBEM_PATH                      = {0x244b2970,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_WELL_KNOWN_OBJECTS             = {0x05308983,0x7688,0x11d1,0xad,0xed,0x00,0xc0,0x4f,0xd8,0xd5,0xcd} ;
const GUID GUID_A_WHEN_CHANGED                   = {0xbf967a77,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_WHEN_CREATED                   = {0xbf967a78,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_WINSOCK_ADDRESSES              = {0xbf967a79,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_WWW_HOME_PAGE                  = {0xbf967a7a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_WWW_PAGE_OTHER                 = {0x9a9a0221,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_X121_ADDRESS                   = {0xbf967a7b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_X500UNIQUEIDENTIFIER           = {0xD07DA11F,0x8A3D,0x42b6,0xB0,0xAA,0x76,0xC9,0x62,0xBE,0x71,0x9A} ;
const GUID GUID_A_X509_CERT                      = {0xbf967a7f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;


//--------------------------------------
// CLASS SCHEMA GUIDS
//--------------------------------------
const GUID GUID_C_ACS_POLICY                     = {0x7f561288,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_ACS_RESOURCE_LIMITS            = {0x2e899b04,0x2834,0x11d3,0x91,0xd4,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_ACS_SUBNET                     = {0x7f561289,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_ADDRESS_BOOK_CONTAINER         = {0x3e74f60f,0x3e73,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_ADDRESS_TEMPLATE               = {0x5fd4250a,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_APPLICATION_ENTITY             = {0x3fdfee4f,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_APPLICATION_PROCESS            = {0x5fd4250b,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_APPLICATION_SETTINGS           = {0xf780acc1,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_APPLICATION_SITE_SETTINGS      = {0x19195a5c,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_APPLICATION_VERSION            = {0xddc790ac,0xaf4d,0x442a,0x8f,0x0f,0xa1,0xd4,0xca,0xa7,0xdd,0x92};
const GUID GUID_C_ATTRIBUTE_SCHEMA               = {0xbf967a80,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_BUILTIN_DOMAIN                 = {0xbf967a81,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CATEGORY_REGISTRATION          = {0x7d6c0e9d,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_CERTIFICATION_AUTHORITY        = {0x3fdfee50,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_CLASS_REGISTRATION             = {0xbf967a82,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CLASS_SCHEMA                   = {0xbf967a83,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CLASS_STORE                    = {0xbf967a84,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_COM_CONNECTION_POINT           = {0xbf967a85,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_COMPUTER                       = {0xbf967a86,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CONFIGURATION                  = {0xbf967a87,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CONNECTION_POINT               = {0x5cb41ecf,0x0e4c,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CONTACT                        = {0x5cb41ed0,0x0e4c,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CONTAINER                      = {0xbf967a8b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CONTROL_ACCESS_RIGHT           = {0x8297931e,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_COUNTRY                        = {0xbf967a8c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CRL_DISTRIBUTION_POINT         = {0x167758ca,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_CROSS_REF                      = {0xbf967a8d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CROSS_REF_CONTAINER            = {0xef9e60e0,0x56f7,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_DEVICE                         = {0xbf967a8e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_DFS_CONFIGURATION              = {0x8447f9f2,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_DHCP_CLASS                     = {0x963d2756,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_DISPLAY_SPECIFIER              = {0xe0fa1e8a,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_DISPLAY_TEMPLATE               = {0x5fd4250c,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_DMD                            = {0xbf967a8f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_DNS_NODE                       = {0xe0fa1e8c,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_DNS_ZONE                       = {0xe0fa1e8b,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_DOMAIN                         = {0x19195a5a,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_DOMAIN_DNS                     = {0x19195a5b,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_DOMAIN_POLICY                  = {0xbf967a99,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_DS_UI_SETTINGS                 = {0x09b10f14,0x6f93,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_DSA                            = {0x3fdfee52,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_DYNAMIC_OBJECT                 = {0x66d51249,0x3355,0x4c1f,0xb2,0x4e,0x81,0xf2,0x52,0xac,0xa2,0x3b};
const GUID GUID_C_FILE_LINK_TRACKING             = {0xdd712229,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_FILE_LINK_TRACKING_ENTRY       = {0x8e4eb2ed,0x4712,0x11d0,0xa1,0xa0,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_FOREIGN_SECURITY_PRINCIPAL     = {0x89e31c12,0x8530,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_FT_DFS                         = {0x8447f9f3,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_GROUP                          = {0xbf967a9c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_GROUP_OF_NAMES                 = {0xbf967a9d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_GROUPOFUNIQUENAMES             = {0x0310A911,0x93A3,0x4e21,0xA7,0xA3,0x55,0xD8,0x5A,0xB2,0xC4,0x8B};
const GUID GUID_C_GROUP_POLICY_CONTAINER         = {0xf30e3bc2,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_INDEX_SERVER_CATALOG           = {0x7bfdcb8a,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_INETORGPERSON                  = {0x4828CC14,0x1437,0x45bc,0x9B,0x07,0xAD,0x6F,0x01,0x5E,0x5F,0x28};
const GUID GUID_C_INFRASTRUCTURE_UPDATE          = {0x2df90d89,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a};
const GUID GUID_C_INTELLIMIRROR_GROUP            = {0x07383086,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_INTELLIMIRROR_SCP              = {0x07383085,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_INTER_SITE_TRANSPORT           = {0x26d97376,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_INTER_SITE_TRANSPORT_CONTAINER = {0x26d97375,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_BASE                     = {0xb40ff825,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_FILTER                   = {0xb40ff826,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_ISAKMP_POLICY            = {0xb40ff828,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_NEGOTIATION_POLICY       = {0xb40ff827,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_NFA                      = {0xb40ff829,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_POLICY                   = {0xb7b13121,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_LEAF                           = {0xbf967a9e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_LICENSING_SITE_SETTINGS        = {0x1be8f17d,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_LINK_TRACK_OBJECT_MOVE_TABLE   = {0xddac0cf5,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_LINK_TRACK_OMT_ENTRY           = {0xddac0cf7,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_LINK_TRACK_VOL_ENTRY           = {0xddac0cf6,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_LINK_TRACK_VOLUME_TABLE        = {0xddac0cf4,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_LOCALITY                       = {0xbf967aa0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_LOST_AND_FOUND                 = {0x52ab8671,0x5709,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_MAIL_RECIPIENT                 = {0xbf967aa1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_MEETING                        = {0x11b6cc94,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_MS_COM_PARTITION               = {0xc9010e74,0x4e58,0x49f7,0x8a,0x89,0x5e,0x3e,0x23,0x40,0xfc,0xf8};
const GUID GUID_C_MS_COM_PARTITIONSET            = {0x250464ab,0xc417,0x497a,0x97,0x5a,0x9e,0x0d,0x45,0x9a,0x7c,0xa1};
const GUID GUID_C_MS_DS_APP_CONFIGURATION        = {0x90df3c3e,0x1854,0x4455,0xa5,0xd7,0xca,0xd4,0x0d,0x56,0x65,0x7a};
const GUID GUID_C_MS_EXCH_CONFIGURATION_CONTAINER = {0xd03d6858,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a};
const GUID GUID_C_MS_MMS_MANAGEMENT_AGENT        = {0x82CFE3D5,0x52C0,0x4d32,0xB6,0x52,0x64,0x41,0x46,0x3D,0x5D,0xF9};
const GUID GUID_C_MS_MMS_INSTANCE                = {0x04882B44,0x7446,0x4504,0x9A,0xAF,0x00,0x56,0xB6,0xFC,0xF1,0x75};
const GUID GUID_C_MS_MMS_OBJECT                  = {0x20AE32EF,0x7CDD,0x45bb,0xBD,0xCB,0xE5,0x55,0x22,0x4B,0x98,0xA7};
const GUID GUID_C_MS_MMS_MANAGEMENT_AGENT_HISTORY = {0x829E42B3,0x1EC8,0x4dbc,0xB9,0x94,0x68,0x4C,0xBF,0x1D,0x0F,0x3F};
const GUID GUID_C_MS_MMS_CONNECTOR               = {0xE0871E35,0xCF22,0x423b,0x8F,0x0B,0x04,0xB3,0xBF,0xB9,0xF1,0x64};
const GUID GUID_C_MS_MMS_PROVISIONING_SERVICE    = {0xFE6482F4,0x0801,0x4bca,0xA7,0x28,0x50,0xE7,0x6E,0x55,0x3D,0xD4};
const GUID GUID_C_MS_MMS_PROVISIONING_SERVICE_HISTORY = {0x6E9EEE9C,0x02E9,0x4ec3,0xA9,0xDA,0x50,0x64,0x6B,0xF6,0xB5,0xA0};
const GUID GUID_C_MS_MMS_WORKFLOW                = {0x1254B720,0x8C8F,0x4817,0x8D,0x11,0x61,0x62,0x61,0xF6,0x6C,0xE2};
const GUID GUID_C_MS_MMS_PROVISIONING_STATUS     = {0xC9AD99CA,0xA3AB,0x416c,0xB3,0x23,0xAD,0xFA,0xDA,0x96,0xA5,0x1B};
const GUID GUID_C_MS_MMS_EVENT_ASSOCIATION       = {0xC6FF63E8,0x5DEF,0x495f,0xAD,0x04,0x58,0x37,0x41,0xFE,0x4D,0x2E};
const GUID GUID_C_MS_PKI_ENTERPRISE_OID          = {0x37cfd85c,0x6719,0x4ad8,0x8f,0x9e,0x86,0x78,0xba,0x62,0x75,0x63};
const GUID GUID_C_MS_PKI_KEY_RECOVERY_AGENT      = {0x26ccf238,0xa08e,0x4b86,0x9a,0x82,0xa8,0xc9,0xac,0x7e,0xe5,0xcb};
const GUID GUID_C_MS_SQL_SQLSERVER               = {0x05f6c878,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_OLAPSERVER              = {0x0c7e18ea,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_SQLREPOSITORY           = {0x11d43c5c,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_SQLPUBLICATION          = {0x17c2f64e,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_SQLDATABASE             = {0x1d08694a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_OLAPDATABASE            = {0x20af031a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_OLAPCUBE                = {0x09f0506a,0xcd28,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_TAPI_RT_CONFERENCE          = {0xca7b9735,0x4b2a,0x4e49,0x89,0xc3,0x99,0x02,0x53,0x34,0xdc,0x94};
const GUID GUID_C_MS_TAPI_RT_PERSON              = {0x53ea1cb5,0xb704,0x4df9,0x81,0x8f,0x5c,0xb4,0xec,0x86,0xca,0xc1};
const GUID GUID_C_MS_WMI_INTRANGEPARAM           = {0x50ca5d7d,0x5c8b,0x4ef3,0xb9,0xdf,0x5b,0x66,0xd4,0x91,0xe5,0x26};
const GUID GUID_C_MS_WMI_INTSETPARAM             = {0x292f0d9a,0xcf76,0x42b0,0x84,0x1f,0xb6,0x50,0xf3,0x31,0xdf,0x62};
const GUID GUID_C_MS_WMI_MERGEABLEPOLICYTEMPLATE = {0x07502414,0xfdca,0x4851,0xb0,0x4a,0x13,0x64,0x5b,0x11,0xd2,0x26};
const GUID GUID_C_MS_WMI_OBJECTENCODING          = {0x55dd81c9,0xc312,0x41f9,0xa8,0x4d,0xc6,0xad,0xbd,0xf1,0xe8,0xe1};
const GUID GUID_C_MS_WMI_POLICYTEMPLATE          = {0xe2bc80f1,0x244a,0x4d59,0xac,0xc6,0xca,0x5c,0x4f,0x82,0xe6,0xe1};
const GUID GUID_C_MS_WMI_POLICYTYPE              = {0x595b2613,0x4109,0x4e77,0x90,0x13,0xa3,0xbb,0x4e,0xf2,0x77,0xc7};
const GUID GUID_C_MS_WMI_RANGEPARAM              = {0x45fb5a57,0x5018,0x4d0f,0x90,0x56,0x99,0x7c,0x8c,0x91,0x22,0xd9};
const GUID GUID_C_MS_WMI_REALRANGEPARAM          = {0x6afe8fe2,0x70bc,0x4cce,0xb1,0x66,0xa9,0x6f,0x73,0x59,0xc5,0x14};
const GUID GUID_C_MS_WMI_RULE                    = {0x3c7e6f83,0xdd0e,0x481b,0xa0,0xc2,0x74,0xcd,0x96,0xef,0x2a,0x66};
const GUID GUID_C_MS_WMI_SHADOWOBJECT            = {0xf1e44bdf,0x8dd3,0x4235,0x9c,0x86,0xf9,0x1f,0x31,0xf5,0xb5,0x69};
const GUID GUID_C_MS_WMI_SIMPLEPOLICYTEMPLATE    = {0x6cc8b2b5,0x12df,0x44f6,0x83,0x07,0xe7,0x4f,0x5c,0xde,0xe3,0x69};
const GUID GUID_C_MS_WMI_SOM                     = {0xab857078,0x0142,0x4406,0x94,0x5b,0x34,0xc9,0xb6,0xb1,0x33,0x72};
const GUID GUID_C_MS_WMI_STRINGSETPARAM          = {0x0bc579a2,0x1da7,0x4cea,0xb6,0x99,0x80,0x7f,0x3b,0x9d,0x63,0xa4};
const GUID GUID_C_MS_WMI_UINTRANGEPARAM          = {0xd9a799b2,0xcef3,0x48b3,0xb5,0xad,0xfb,0x85,0xf8,0xdd,0x32,0x14};
const GUID GUID_C_MS_WMI_UINTSETPARAM            = {0x8f4beb31,0x4e19,0x46f5,0x93,0x2e,0x5f,0xa0,0x3c,0x33,0x9b,0x1d};
const GUID GUID_C_MS_WMI_UNKNOWNRANGEPARAM       = {0xb82ac26b,0xc6db,0x4098,0x92,0xc6,0x49,0xc1,0x8a,0x33,0x36,0xe1};
const GUID GUID_C_MS_WMI_WMIGPO                  = {0x05630000,0x3927,0x4ede,0xbf,0x27,0xca,0x91,0xf2,0x75,0xc2,0x6f};
const GUID GUID_C_MSMQ_CONFIGURATION             = {0x9a0dc344,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_MSMQ_CUSTOM_RECIPIENT          = {0x876d6817,0x35cc,0x436c,0xac,0xea,0x5e,0xf7,0x17,0x4d,0xd9,0xbe};
const GUID GUID_C_MSMQ_ENTERPRISE_SETTINGS       = {0x9a0dc345,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_MSMQ_GROUP                     = {0x46b27aac,0xaafa,0x4ffb,0xb7,0x73,0xe5,0xbf,0x62,0x1e,0xe8,0x7b};
const GUID GUID_C_MSMQ_MIGRATED_USER             = {0x50776997,0x3c3d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1};
const GUID GUID_C_MSMQ_QUEUE                     = {0x9a0dc343,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_MSMQ_SETTINGS                  = {0x9a0dc347,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_MSMQ_SITE_LINK                 = {0x9a0dc346,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_NTDS_CONNECTION                = {0x19195a60,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_NTDS_DSA                       = {0xf0f8ffab,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_NTDS_SERVICE                   = {0x19195a5f,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_NTDS_SITE_SETTINGS             = {0x19195a5d,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_NTFRS_MEMBER                   = {0x2a132586,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_NTFRS_REPLICA_SET              = {0x5245803a,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_NTFRS_SETTINGS                 = {0xf780acc2,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_NTFRS_SUBSCRIBER               = {0x2a132588,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_NTFRS_SUBSCRIPTIONS            = {0x2a132587,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_ORGANIZATION                   = {0xbf967aa3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_ORGANIZATIONAL_PERSON          = {0xbf967aa4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_ORGANIZATIONAL_ROLE            = {0xa8df74bf,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_ORGANIZATIONAL_UNIT            = {0xbf967aa5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_PACKAGE_REGISTRATION           = {0xbf967aa6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_PERSON                         = {0xbf967aa7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_PHYSICAL_LOCATION              = {0xb7b13122,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_PKI_CERTIFICATE_TEMPLATE       = {0xe5209ca2,0x3bba,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1};
const GUID GUID_C_PKI_ENROLLMENT_SERVICE         = {0xee4aa692,0x3bba,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1};
const GUID GUID_C_MS_PKI_PRIVATE_KEY_RECOVERY_AGENT = {0x1562a632,0x44b9,0x4a7e,0xa2,0xd3,0xe4,0x26,0xc9,0x6a,0x3a,0xcc};
const GUID GUID_C_PRINT_QUEUE                    = {0xbf967aa8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_QUERY_POLICY                   = {0x83cc7075,0xcca7,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_REMOTE_MAIL_RECIPIENT          = {0xbf967aa9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_REMOTE_STORAGE_SERVICE_POINT   = {0x2a39c5bd,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_RESIDENTIAL_PERSON             = {0xa8df74d6,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_RID_MANAGER                    = {0x6617188d,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RID_SET                        = {0x7bfdcb89,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_RPC_CONTAINER                  = {0x80212842,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_RPC_ENTRY                      = {0xbf967aac,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_RPC_GROUP                      = {0x88611bdf,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RPC_PROFILE                    = {0x88611be1,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RPC_PROFILE_ELEMENT            = {0xf29653cf,0x7ad0,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RPC_SERVER                     = {0x88611be0,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RPC_SERVER_ELEMENT             = {0xf29653d0,0x7ad0,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RRAS_ADMINISTRATION_CONNECTION_POINT = {0x2a39c5be,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_RRAS_ADMINISTRATION_DICTIONARY = {0xf39b98ae,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SAM_DOMAIN                     = {0xbf967a90,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SAM_DOMAIN_BASE                = {0xbf967a91,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SAM_SERVER                     = {0xbf967aad,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SECRET                         = {0xbf967aae,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SECURITY_OBJECT                = {0xbf967aaf,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SECURITY_PRINCIPAL             = {0xbf967ab0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SERVER                         = {0xbf967a92,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SERVERS_CONTAINER              = {0xf780acc0,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SERVICE_ADMINISTRATION_POINT   = {0xb7b13123,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SERVICE_CLASS                  = {0xbf967ab1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SERVICE_CONNECTION_POINT       = {0x28630ec1,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SERVICE_INSTANCE               = {0xbf967ab2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SITE                           = {0xbf967ab3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SITE_LINK                      = {0xd50c2cde,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SITE_LINK_BRIDGE               = {0xd50c2cdf,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SITES_CONTAINER                = {0x7a4117da,0xcd67,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_STORAGE                        = {0xbf967ab5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SUBNET                         = {0xb7b13124,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SUBNET_CONTAINER               = {0xb7b13125,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SUBSCHEMA                      = {0x5a8b3261,0xc38d,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_TOP                            = {0xbf967ab7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_TRUSTED_DOMAIN                 = {0xbf967ab8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_TYPE_LIBRARY                   = {0x281416e2,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_USER                           = {0xbf967aba,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_VOLUME                         = {0xbf967abb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\ridmgr.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ridmgr.h

Abstract:

    This file contains definitions, constants, etc. for the NT Security
    Accounts Manager (SAM) Relative Identifier (RID) manager.

Author:

    Chris Mayhall (ChrisMay) 05-Nov-1996

Environment:

    User Mode - Win32

Revision History:

    ChrisMay        05-Nov-1996
        Created.
    ChrisMay        05-Jan-1997
        Updated forward declarations, etc.

--*/

// Constants and Macros

// BUG: Temporary error codes, should be corrected and moved into ntstatus.h.

#define STATUS_NO_RIDS_ALLOCATED    STATUS_DS_NO_RIDS_ALLOCATED
#define STATUS_NO_MORE_RIDS         STATUS_DS_NO_MORE_RIDS
#define SAMP_INCORRECT_ROLE_OWNER   STATUS_DS_INCORRECT_ROLE_OWNER
#define SAMP_RID_MGR_INIT_ERROR     STATUS_DS_RIDMGR_INIT_ERROR

// 0xFFFFFF - SAMP_RESTRICTED_ACCOUNT_COUNT = 16,777,215 - 1000 =  16,776,215
// possible account RID's per domain. Note that the top byte is reserved for
// POSIX, Netware, and Macintosh compatibility. In NT4 (and prior releases)
// the first 1000 RID's were reserved (SAMP_RESTRICTED_ACCOUNT_COUNT) for the
// Builtin accounts.

// The minimum domain RID is incremented by 100,000 to handle NT4-to-NT5 up-
// grades. NT4 DC's are limited to approximately 30,000 accounts (and with
// some deletion) 100,000 should be well above any NT4 RID currently in use.
// Otherwise there will be a RID re-usage problem when the NT4 DC is upgraded
// to NT5.

// #define SAMP_MINIMUM_DOMAIN_RID     (SAMP_RESTRICTED_ACCOUNT_COUNT + 100000)
#define SAMP_MINIMUM_DOMAIN_RID     SAMP_RESTRICTED_ACCOUNT_COUNT
#define SAMP_MAXIMUM_DOMAIN_RID     0x3FFFFFFF
// Test Case Size: #define SAMP_MAXIMUM_DOMAIN_RID     (SAMP_MINIMUM_DOMAIN_RID + SAMP_DOMAIN_BLOCK_SIZE)

// RID block size is the increment amount for allocating new RID blocks. Note
// that 16,776,115 divided by SAMP_RID_BLOCK_SIZE yields the maximum number of
// DC's that can be present in a single domain.
// Note:- When a DC is restored, the DC will abandon the current rid-block and request
//        get a new rid-block allocated for future account creations. This is so that
//        we can avoid creating duplicate accounts with same RID. Keeping the RID block
//        size too low will result in frequent FSMO operations and too high will result
//        in potential wastage of RIDs during restore. Block size of 500 is a reasonable 
//        trade-off.

#define SAMP_RID_BLOCK_SIZE         500

// RID threshold is the number of remaining RID's on any DC (remaining in
// the allocated pool) before that pool is exhausted.

#define SAMP_RID_THRESHOLD   (SAMP_RID_BLOCK_SIZE -\
                             ((ULONG)(SAMP_RID_BLOCK_SIZE * 0.80)))

// In-memory cache of RIDs, used to reduce the number of updates to the back-
// in store's available RID pool. Setting this to 0 disables the RID cache

#define SAMP_RID_CACHE_SIZE         10

// This NT status code is returned from the creation routines in the event
// that the object already exists (hence, don't reset NextRid, etc. to the
// initialization values).

#define SAMP_OBJ_EXISTS             STATUS_USER_EXISTS

// Maximum number of attributes on any one class of RID-management object--
// used for contiguous DSATTR allocation blocks, faster allocation.

#define SAMP_RID_ATTR_MAX           8

// Opcodes for floating single master operation (FSMO) to either obtain a new
// RID pool or request to change the current RID manager to another DSA.

#define SAMP_REQUEST_RID_POOL       2
#define SAMP_CHANGE_RID_MANAGER     3

// retry interval if rid pool request failed ( 30 s )
#define SAMP_RID_DEFAULT_RETRY_INTERVAL 30000
// retry interval if local update of a rid pool request failed ( 30 min)
#define SAMP_RID_LOCAL_UPDATER_ERROR_RETRY_INTERVAL 1800000
// retry count when we start applying the above 30 min interval
#define SAMP_RID_LOCAL_UPDATE_RETRY_CUTOFF 3

// Private attribute flags used only in this module.

#define RID_REFERENCE               0x00000001
#define RID_ROLE_OWNER              0x00000010
#define RID_AVAILABLE_POOL          0x00000020
#define RID_DC_COUNT                0x00000040
#define RID_ALLOCATED_POOL          0x00001000
#define RID_PREV_ALLOC_POOL         0x00002000
#define RID_USED_POOL               0x00004000
#define RID_NEXT_RID                0x00008000

// Type Definitions and Enums

typedef ULONG RIDFLAG;
typedef ULONG *PRIDFLAG;

typedef struct _RIDINFO
{
    // Since DSNAME's are variable-length structs, maintain pointers to the
    // DSNAME's in this structure.

    // Note, the DSNAMEs currently only contain the distinguished name (DN)
    // of the object, but do NOT contain the GUID, SID, or length data--
    // this can be added later if necessary. The DN is copied into the
    // StringName member of the DSNAME.

    PDSNAME         RidManagerReference; // DSNAME of the RID Manager
    PDSNAME         RoleOwner;           // Current RID Manager
    ULARGE_INTEGER  RidPoolAvailable;    // Global RID pool for the domain
    ULONG           RidDcCount;          // Number of DC's in the domain
    ULARGE_INTEGER  RidPoolAllocated;    // Current RID pool in use by the DSA
    ULARGE_INTEGER  RidPoolPrevAlloc;    // Previous RID pool used by the DSA
    ULARGE_INTEGER  RidPoolUsed;         // RID high water mark
    ULONG           NextRid;             // The Next RID to use
    RIDFLAG         Flags;               // RID operation desired
} RIDINFO;

typedef struct _RIDINFO *PRIDINFO;

typedef enum _RID_OBJECT_TYPE
{
    RidManagerReferenceType = 1,
    RidManagerType,
    RidObjectType
} RID_OBJECT_TYPE;

// Global Data

extern CRITICAL_SECTION RidMgrCriticalSection;
extern PCRITICAL_SECTION RidMgrCritSect;

// extern BOOLEAN SampDcHasInitialRidPool;
extern BOOLEAN fRidFSMOOpInProgress;

// Forward declarations for RID management

NTSTATUS
SampInitDomainNextRid(
    IN OUT PULONG NextRid
    );

NTSTATUS
SampCreateRidManagerReference(
    IN PWCHAR NamePrefix,
    IN ULONG NamePrefixLength,
    IN PDSNAME RidMgr,
    OUT PDSNAME RidMgrRef
    );

NTSTATUS
SampCreateRidManager(
    IN PDSNAME RidMgr
    );

NTSTATUS
SampUpdateRidManagerReference(
    IN PDSNAME RidMgrRef,
    IN PDSNAME RidMgr
    );

VOID
SampSetRoleOwner(
    PRIDINFO RidInfo,
    PDSNAME RidObject
    );

VOID
SampSetRidPoolAvailable(
    PRIDINFO RidInfo,
    ULONG high,
    ULONG low
    );

VOID
SampSetRidFlags(
    PRIDINFO RidInfo,
    RIDFLAG Flags
    );

NTSTATUS
SampUpdateRidManager(
    IN PDSNAME RidMgr,
    IN PRIDINFO RidInfo
    );

VOID
SampSetRidPoolAllocated(
    PRIDINFO RidInfo,
    ULONG high,
    ULONG low
    );

VOID
SampSetRidPoolPrevAlloc(
    PRIDINFO RidInfo,
    ULONG high,
    ULONG low
    );

VOID
SampSetRidPoolUsed(
    PRIDINFO RidInfo,
    ULONG high,
    ULONG low
    );

VOID
SampSetRid(
    PRIDINFO RidInfo,
    ULONG NextRid
    );

NTSTATUS
SampUpdateRidObject(
    IN PDSNAME RidObj,
    IN PRIDINFO RidInfo,
    IN BOOLEAN fLazyCommit,
    IN BOOLEAN fAuthoritative
    );

NTSTATUS
SampReadRidManagerInfo(
    IN PDSNAME RidMgr,
    OUT PRIDINFO RidInfo
    );

VOID
SampDumpRidInfo(
    PRIDINFO RidInfo
    );

NTSTATUS
SampReadRidObjectInfo(
    IN PDSNAME RidObj,
    OUT PRIDINFO RidInfo
    );

NTSTATUS
SampReadRidManagerReferenceInfo(
    IN PDSNAME RidMgrRef,
    OUT PRIDINFO RidInfo
    );

NTSTATUS
SampGetNextRid(
    IN PSAMP_OBJECT DomainContext,
    PULONG Rid
    );

NTSTATUS
SampDomainRidInitialization(
    IN BOOLEAN fSynchronous
    );

NTSTATUS
SampDomainAsyncRidInitialization(
    PVOID p OPTIONAL
    );

NTSTATUS
SampDomainRidUninitialization(
    VOID
    );

NTSTATUS
SampGetNextRid(
    IN PSAMP_OBJECT DomainContext,
    OUT PULONG Rid
    );

NTSTATUS
SampAllowAccountCreation(
    IN PSAMP_OBJECT Context,
    IN NTSTATUS FailureStatus
    );

NTSTATUS
SampAllowAccountModification(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampAllowAccountDeletion(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SamIFloatingSingleMasterOp(
    IN PDSNAME RidManager,
    IN ULONG OpCode
    );

NTSTATUS
SamIFloatingSingleMasterOpEx(
    IN  PDSNAME  RidManager,
    IN  PDSNAME  TargetDsa,
    IN  ULONG    OpCode,
    IN  ULARGE_INTEGER *ClientAllocPool,
    OUT PDSNAME **ObjectArray OPTIONAL
    );

NTSTATUS
SamIDomainRidInitialization(
    VOID
    );

NTSTATUS
SamIGetNextRid(
    IN SAMPR_HANDLE DomainHandle,
    OUT PULONG Rid
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\rng.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

//
// This file exports four functions: InitializeRNG, ShutdownRNG, GenRandom, and
// GenerateRandomBits, which are used to generate random sequences of bytes.
//

#include <windows.h>
#include <rng.h>
#include <rc4.h>
#include <sha.h>

#define A_SHA_DIGEST_LEN    20
#define RAND_CTXT_LEN       60
#define RC4_REKEY_PARAM     500     // rekey every 500 bytes

#define UNLEN	MAX_PATH

typedef struct _RandContext
{
    DWORD dwBitsFilled;
    BYTE  rgbBitBuffer[RAND_CTXT_LEN];
} RandContext;

#if 0
CRITICAL_SECTION    csRNG;

#define LockRNG()   EnterCriticalSection( &csRNG )
#define UnlockRNG() LeaveCriticalSection( &csRNG )
#else
#define LockRNG()
#define UnlockRNG()
#endif

unsigned char g_rgbStaticBits[A_SHA_DIGEST_LEN];
static DWORD         g_dwRC4BytesUsed = RC4_REKEY_PARAM;     // initially force rekey
static struct RC4_KEYSTRUCT g_rc4key;

static BOOL RandomFillBuffer(BYTE *pbBuffer, DWORD *pdwLength);
static void GatherRandomBits(RandContext *prandContext);
static void AppendRand(RandContext* prandContext, void* pv, DWORD dwSize);

/*****************************************************************************/
VOID STInitializeRNG(VOID)
{
    DWORD dwType;
    DWORD dwSize;

    LONG err;

#if 0
    
    InitializeCriticalSection( &csRNG );

    LockRNG();

    // grab seed from persistent storage

//    SPQueryPersistentSeed(g_rgbStaticBits, A_SHA_DIGEST_LEN);
#endif
    
    g_dwRC4BytesUsed = RC4_REKEY_PARAM;

#if 0
    UnlockRNG();
#endif

    return;
}

VOID ShutdownRNG(VOID)
{

#if 0
    DeleteCriticalSection( &csRNG );
#endif
    
    // put seed into persistent storage

//    SPSetPersistentSeed(g_rgbStaticBits, A_SHA_DIGEST_LEN);

    return;
}

/*****************************************************************************/
int STGenRandom(PVOID Reserved,
              UCHAR *pbBuffer,
              size_t dwLength)
{
    STGenerateRandomBits(pbBuffer, dwLength);
    return TRUE;
}

/************************************************************************/
/* GenerateRandomBits generates a specified number of random bytes and        */
/* places them into the specified buffer.                                */
/************************************************************************/
/*                                                                      */
/* Pseudocode logic flow:                                               */
/*                                                                      */
/* if (bits streamed > threshold)                                       */
/* {                                                                    */
/*  Gather_Bits()                                                       */
/*  SHAMix_Bits(User, Gathered, Static -> Static)                       */
/*  RC4Key(Static -> newRC4Key)                                         */
/*  SHABits(Static -> Static)      // hash after RC4 key generation     */
/* }                                                                    */
/* else                                                                 */
/* {                                                                    */
/*  SHAMix_Bits(User, Static -> Static)                                 */
/* }                                                                    */
/*                                                                      */
/* RC4(newRC4Key -> outbuf)                                             */
/* bits streamed += sizeof(outbuf)                                      */
/*                                                                      */
/************************************************************************/
VOID STGenerateRandomBits(PUCHAR pbBuffer,
                        ULONG  dwLength)
{
    DWORD dwBytesThisPass;
    DWORD dwFilledBytes = 0;

    // break request into chunks that we rekey between

    LockRNG();

    while(dwFilledBytes < dwLength)
    {
        dwBytesThisPass = dwLength - dwFilledBytes;

        RandomFillBuffer(pbBuffer + dwFilledBytes, &dwBytesThisPass);
        dwFilledBytes += dwBytesThisPass;
    }

    UnlockRNG();
}

/*****************************************************************************/
static BOOL RandomFillBuffer(BYTE *pbBuffer, DWORD *pdwLength)
{
    // Variables from loading and storing the registry...
    DWORD   cbDataLen;

    cbDataLen = A_SHA_DIGEST_LEN;

    if(g_dwRC4BytesUsed >= RC4_REKEY_PARAM) {
        // if we need to rekey

        RandContext randContext;
        randContext.dwBitsFilled = 0;

        GatherRandomBits(&randContext);

        // Mix all bits
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // SHA the gathered bits
            A_SHAUpdate(&SHACtx, randContext.rgbBitBuffer, randContext.dwBitsFilled);

            // SHA the user-supplied bits
            A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }

        // Create RC4 key
        g_dwRC4BytesUsed = 0;
        rc4_key(&g_rc4key, A_SHA_DIGEST_LEN, g_rgbStaticBits);

        // Mix RC4 key bits around
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }

    } else {
        // Use current RC4 key, but capture any user-supplied bits.

        // Mix input bits
        {
            A_SHA_CTX SHACtx;
            A_SHAInit(&SHACtx);

            // SHA the static bits
            A_SHAUpdate(&SHACtx, g_rgbStaticBits, A_SHA_DIGEST_LEN);

            // SHA the user-supplied bits
            A_SHAUpdate(&SHACtx, pbBuffer, *pdwLength);

            // output back out to static bits
            A_SHAFinal(&SHACtx, g_rgbStaticBits);
        }
    }

    // only use RC4_REKEY_PARAM bytes from each RC4 key
    {
        DWORD dwMaxPossibleBytes = RC4_REKEY_PARAM - g_dwRC4BytesUsed;
        if(*pdwLength > dwMaxPossibleBytes) {
                *pdwLength = dwMaxPossibleBytes;
        }
    }

    FillMemory(pbBuffer, *pdwLength, 0);
    rc4(&g_rc4key, *pdwLength, pbBuffer);

    g_dwRC4BytesUsed += *pdwLength;

    return TRUE;
}

/*****************************************************************************/
static void GatherRandomBits(RandContext *prandContext)
{
    DWORD   dwTmp;
    WORD    wTmp;
    BYTE    bTmp;

    // ** indicates US DoD's specific recommendations for password generation

    // proc id
    dwTmp = GetCurrentProcessId();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // thread id
    dwTmp = GetCurrentThreadId();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // ** ticks since boot (system clock)
    dwTmp = GetTickCount();
    AppendRand(prandContext, &dwTmp, sizeof(dwTmp));

    // cursor position
    {
        POINT                        point;
        GetCursorPos(&point);
        bTmp = LOBYTE(point.x) ^ HIBYTE(point.x);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
        bTmp = LOBYTE(point.y) ^ HIBYTE(point.y);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // ** system time, in ms, sec, min (date & time)
    {
        SYSTEMTIME                sysTime;
        GetLocalTime(&sysTime);
        AppendRand(prandContext, &sysTime.wMilliseconds, sizeof(sysTime.wMilliseconds));
        bTmp = LOBYTE(sysTime.wSecond) ^ LOBYTE(sysTime.wMinute);
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // ** hi-res performance counter (system counters)
    {
        LARGE_INTEGER        liPerfCount;
        if(QueryPerformanceCounter(&liPerfCount)) {
            bTmp = LOBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = HIBYTE(LOWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = LOBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
            bTmp = HIBYTE(HIWORD(liPerfCount.LowPart)) ^ LOBYTE(LOWORD(liPerfCount.HighPart));
            AppendRand(prandContext, &bTmp, sizeof(BYTE));
        }
    }

    // memory status
    {
        MEMORYSTATUS        mstMemStat;
        mstMemStat.dwLength = sizeof(MEMORYSTATUS);     // must-do
        GlobalMemoryStatus(&mstMemStat);
        wTmp = HIWORD(mstMemStat.dwAvailPhys);          // low words seem to be always zero
        AppendRand(prandContext, &wTmp, sizeof(WORD));
        wTmp = HIWORD(mstMemStat.dwAvailPageFile);
        AppendRand(prandContext, &wTmp, sizeof(WORD));
        bTmp = LOBYTE(HIWORD(mstMemStat.dwAvailVirtual));
        AppendRand(prandContext, &bTmp, sizeof(BYTE));
    }

    // free disk clusters
    {
        DWORD dwSectorsPerCluster, dwBytesPerSector, dwNumberOfFreeClusters, dwTotalNumberOfClusters;
        if(GetDiskFreeSpace(NULL, &dwSectorsPerCluster, &dwBytesPerSector,     &dwNumberOfFreeClusters, &dwTotalNumberOfClusters)) {
            AppendRand(prandContext, &dwNumberOfFreeClusters, sizeof(dwNumberOfFreeClusters));
            AppendRand(prandContext, &dwTotalNumberOfClusters, sizeof(dwTotalNumberOfClusters));
            AppendRand(prandContext, &dwBytesPerSector, sizeof(dwBytesPerSector));
        }
    }

    // last messages' timestamp
    {
        LONG lTime;
        lTime = GetMessageTime();
        AppendRand(prandContext, &lTime, sizeof(lTime));
    }

    {
        static DWORD dwComputerNameSize;
        static DWORD dwUserNameSize;
        static char lpComputerName [MAX_COMPUTERNAME_LENGTH + 1];
        static char lpUserName [UNLEN + 1];

        //
        // note use of two temp DWORDs - that's to keep the static DWORDs
        // thread safe
        //

        // **SystemID
        if(dwComputerNameSize == 0) {
            DWORD dwTempComputerNameSize = MAX_COMPUTERNAME_LENGTH + 1;

            if(GetComputerName(lpComputerName, &dwTempComputerNameSize))
                dwComputerNameSize = dwTempComputerNameSize;
        }

        if(dwComputerNameSize != 0) {
            // dwComputerNameSize = len not including null termination
            AppendRand(prandContext, lpComputerName, dwComputerNameSize);
        }

        // **UserID
        if(dwUserNameSize == 0) {
            DWORD dwTempUserNameSize = UNLEN + 1;

            if(GetUserName(lpUserName, &dwTempUserNameSize)) {
                // dwUserNameSize = len including null termination
                dwUserNameSize = dwTempUserNameSize - 1;
            }
        }

        if(dwUserNameSize != 0) {
            AppendRand(prandContext, lpUserName, dwUserNameSize);
        }
    }
}

/*****************************************************************************/
static void AppendRand(RandContext* prandContext, void* pv, DWORD dwSize)
{
    DWORD dwBitsLeft = (RAND_CTXT_LEN - prandContext->dwBitsFilled);

    if(dwBitsLeft > 0) {
        if(dwSize > dwBitsLeft) {
            dwSize = dwBitsLeft;
        }

        CopyMemory(prandContext->rgbBitBuffer + prandContext->dwBitsFilled, pv, dwSize);
        prandContext->dwBitsFilled += dwSize;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\promote.c ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    promote.c

Abstract:

    This file contains the dll entrypoints that handle the SAM account
    transitions for promotion and demotion. See spec\nt5\ds\promote.doc
    and spec\nt5\ds\install.doc for high level details.


    Promotion
    ---------

    The following role transitions are supported by SAM

    Nt5 stand alone server -> Nt5 DC, first in new domain
    Nt5 member server      -> Nt5 DC, replica in existing domain

    Nt4 PDC upgrade        -> Nt5 DC, first in existing NT4 domain
    Nt5 BDC upgrade        -> Nt5 DC, replica in mixed domain

    The arrows are performed by initiated a promotion.

    Promotion is a two phase operation for SAM.

    Phase 1 is completed by SamIPromote().  It initializes the directory service,
    upgrades any existing security pricipals (creates new ones if necessary)
    and then leaves the directory service running so the LSA can do what it has
    to do to the ds and then the lsa shuts the directory service down.  Also
    a registry key is created so the function SampIsRebootAfterPromotion() can
    return TRUE on the next reboot.  SampIsRebootAfterPromotion() is called during
    SampInitialize() so SampPerformPromotePhase2() can be called.

    1) verifies the current enviroment supports the requested operation
      (listed above)

    2) initializes the ds, via SampDsInitialize()

    3)a) if this is a new domain, SamIPromote creates new Lsa Primary and
         Account domain information structures to define the new domain.  This
         involves creating a new guid.  SampInitializeRegistry() is then called
         with this information, and a new set of registry hives are created.
         These hives are then read, placed into the DS, and deleted.

      b) if this is an Nt4 PDC upgrade, the existing hives are placed into
         the DS

      c) all other cases are replica installs; nothing SAM wise is done here.

    4) create a well known registry key so SAM will know to perform phase 2
    after the reboot.  The function SampIsRebootAfterPromotion() is called from
    SampInitialize so phase2 can be performed.

    Phase 2, SampPerformPromotePhase2(), occurs on the reboot after
    SamIPromote() has successfully run. This phase does the following

    For the first dc in a domain:

    1) creates a (SAM) machine account for the server if one does not exist
    2) creates a krbtgt account (for the kerberos security system).  There is
    only one of these accounts per domain.

    For a replica dc in a domain:

    1) nothing!


    Demotion
    ________


    1) create a registry sam account database for either a standalone or
       member server


Author:

    Colin Brace    (ColinBr)  6-May-1997

Environment:

    User Mode - Nt

Revision History:

    ColinBrace        6-May-97
        Created initial file.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#include <samsrvp.h>
#include <dslayer.h>
#include <dsconfig.h>
#include <ntverp.h>
#include <samisrv.h>
#include <dns.h>
#include <setupapi.h>
#include <attids.h>
#include <malloc.h>
#include <dsmember.h>
#include <pek.h>
#include <lmcons.h>
#include <logonmsv.h>
#include <cryptdll.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private declarations                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// This defines the currect role of the server
//
typedef enum
{
    SampMemberServer = 0,
    SampStandaloneServer,

    SampDownlevelPDC,         // downlevel means Nt4 and below
    SampDownlevelBDC,

    SampDSDC,                 // DSDC means NT5 and above DC

    SampInvalidRoleConfiguration

}SAMP_ROLE_CONFIGURATION, *PSAMP_ROLE_CONFIGURATION;

//
// Local constants
//

//
// Miscellaneous string values for saving and loading downlevel hives
//

// This is the hive created by SamISaveDownlevelDatabase by the replace
#define SAMP_DOWNLEVEL_DB_FILENAME         L"\\SAM.UPG"

// This is the new account database created in SamISaveDownlevelDatabase
#define SAMP_NEW_DB_FILENAME               L"\\SAM.TMP"

// This is the hive created by base nt setup - we use it as a backup
#define SAMP_DOWNLEVEL_DB_FILENAME_BACKUP  L"\\SAM.SAV"

// This is the registry key that is used to load the saved hive into the
// registry
#define SAMP_DOWNLEVEL_DB_KEYNAME          L"SAMUPGRADE"

//
// This is used to store the value name for the admin's password to be set
// during the reboot of a promoted server
//
#define SAMP_ADMIN_INFO_NAME L"AdminInfo"

//
// This is used to store the ds directories to be deleted after a demote
//
#define SAMP_DS_DIRS_INFO_NAME L"DsDirs"

//
// This is the location of where information that SAM needs at the next reboot
// is keep (in the registry)
//
#define SAMP_REBOOT_INFO_KEY  L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\SAMSS"

//
// Password for krbtgt account
//

WCHAR DOMAIN_KRBTGT_ACCOUNT_NAME_W[] = L"krbtgt";

//
// These strings exist in case the resource retrieval fails
//
WCHAR SampDefaultKrbtgtWarningString[] =
     L"The account krbtgt was renamed to %ws to allow NT5 Kerberos to install.";

WCHAR SampDefaultKrbtgtCommentString[] =
     L"Key Distribution Center Service Account";

WCHAR SampDefaultBlankAdminPasswordWarningString[] =
    L"Setting the administrator's password to the string you specified failed.\
      Upon reboot the password will be blank; please reset once logged on.";

NTSTATUS
SampCheckPromoteEnvironment(
    IN  ULONG PromoteFlags
    );

NTSTATUS
SampCreateFirstMachineAccount(
    IN SAMPR_HANDLE DomainHandle
    );

NTSTATUS
SampAddWellKnownAccounts(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN ULONG        Flags
    );

NTSTATUS
SampApplyWellKnownMemberships(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN PSID         DomainSid,
    IN ULONG        Flags
    );

NTSTATUS
SampAddAnonymousToPreW2KCompAlias(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle
    );

NTSTATUS
SampCreateKeyForPostBootPromote(
    IN ULONG PromoteFlags
    );

NTSTATUS
SampRetrieveKeyForPostBootPromote(
    OUT PULONG PromoteFlags
    );

NTSTATUS
SampDeleteKeyForPostBootPromote(
    VOID
    );

NTSTATUS
SampSetPassword(
    IN SAMPR_HANDLE    UserHandle,
    IN PUNICODE_STRING AccountName,
    IN ULONG           AccountRid, OPTIONAL
    IN WCHAR          *Password
    );

NTSTATUS
SampPerformFirstDcPromotePhase2(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN ULONG        Flags
    );

NTSTATUS
SampPerformReplicaDcPromotePhase2(
    SAMPR_HANDLE DomainHandle
    );

NTSTATUS
SampRegistryDelnode(
    IN WCHAR* KeyPath
    );

NTSTATUS
SampRenameKrbtgtAccount(
    VOID
    );

WCHAR*
SampGetKrbtgtRenameWarning(
    WCHAR* NewName
    );

WCHAR*
SampGetKrbtgtCommentString(
    VOID
    );


NTSTATUS
SampSetAdminPasswordInRegistry(
    IN BOOLEAN         fUseCurrentAdmin,
    IN PUNICODE_STRING Password
    );


NTSTATUS
SampSetAdminPassword(
    IN SAMPR_HANDLE DomainHandle
    );

NTSTATUS
SampRemoveAdminPasswordFromRegistry(
    VOID
    );

NTSTATUS
SampPerformNewServerPhase2(
    SAMPR_HANDLE DomainHandle,
    BOOLEAN      fMemberServer
    );

NTSTATUS
SampPerformTempUpgradeWork(
    SAMPR_HANDLE DomainHandle
    );

WCHAR*
SampGetBlankAdminPasswordWarning(
    VOID
    );

NTSTATUS
SampSetSingleWellKnownAccountMembership(
    IN HANDLE            AccountHandle,
    IN SAMP_OBJECT_TYPE  GroupType,  // group or alias
    IN PSID              GroupSid
    );

NTSTATUS
SampStoreDsDirsToDelete(
    VOID
    );

NTSTATUS
SampProcessDsDirsToDelete(
    IN WCHAR *pPathArray,
    IN DWORD  Size
    );

NTSTATUS
SampCreateDsDirsToDeleteKey(
    IN WCHAR *PathArray,
    IN DWORD Size
    );

NTSTATUS
SampRetrieveDsDirsToDeleteKey(
    OUT WCHAR **PathArray,
    OUT DWORD *Size
    );

NTSTATUS
SampDeleteDsDirsToDeleteKey(
    VOID
    );

DWORD
SampClearDirectory(
    IN WCHAR *DirectoryName
    );

DWORD
SampSetMachineAccountSecret(
    LPWSTR SecretValue
    );

NTSTATUS
SampAddEnterpriseAdminsToAdministrators(
    VOID
    );

NTSTATUS
SampSetSafeModeAdminPassword(
    VOID
    );

VOID
SampGenerateRandomPassword(
    IN LPWSTR Password,
    IN ULONG  Length
    );

NTSTATUS
SampDsSetServerRevision(
    ULONG   DsRevision
    );


//
// from dsupgrad/convert.cxx
//

NTSTATUS
GetRdnForSamObject(IN WCHAR* SamAccountName,
                   IN SAMP_OBJECT_TYPE SampObjectType,
                   OUT WCHAR* RdnBuffer,
                   IN OUT ULONG* Size
                   );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Routines                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamIPromote(
    IN  ULONG                        PromoteFlags,
    IN  PPOLICY_PRIMARY_DOMAIN_INFO  NewPrimaryDomainInfo  OPTIONAL,
    IN  PUNICODE_STRING              AdminPassword         OPTIONAL,
    IN  PUNICODE_STRING              SafeModeAdminPassword OPTIONAL
    )
/*++

Description:

    This routine performs phase 1 of a promotion.  See module header
    for more details.

Parameters:

    PromoteFlags            : Flags indicating the type of the promotion

    NewPrimaryDomainInfo    : new security information, if PrincipalAction is
                              to create new security principals

    AdminPassword           : password for new domain;

    SafeModeAdminPassword   : password for safe mode boot: NOT CURRENTLY SUPPORTED

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_INVALID_SERVER_STATE - illegal promotion was requested

--*/
{
    NTSTATUS NtStatus, IgnoreStatus;
    DWORD    WinError;

    OBJECT_ATTRIBUTES TempSamKey;
    UNICODE_STRING    TempSamKeyName;
    HANDLE            TempSamKeyHandle;

    NT_PRODUCT_TYPE        DatabaseProductType;
    POLICY_LSA_SERVER_ROLE DatabaseServerRole;

    POLICY_ACCOUNT_DOMAIN_INFO  NewAccountDomainInfo;

    PSID                   Sid;

    WCHAR                 *WarningString = NULL;
    BOOLEAN                fStatus;

    WCHAR                 SamUpgradeKeyPath[ MAX_PATH ];


    SAMTRACE_EX("SamIPromote");

    //
    // If the SAM server is not initialized, reject this call
    //

    if (SampServiceState != SampServiceEnabled) {

        return(STATUS_INVALID_SERVER_STATE);
    }

    //
    // Parameter checks
    //

    //
    // Make sure we are in an environment that we can handle.  Also determine
    // the role configuration
    //
    NtStatus = SampCheckPromoteEnvironment(PromoteFlags);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampCheckPromoteEnvironment failed with 0x%x\n",
                   NtStatus));

        return NtStatus;
    }

    //
    // We are in a state that we understand, and the requested operation
    // is valid.  Attempt to create the security principals
    //
    NtStatus = STATUS_UNSUCCESSFUL;

    if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) )
    {
        //
        // Replica install, nothing to do
        //
        NtStatus = STATUS_SUCCESS;
    }
    else if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_UPGRADE ) )
    {
        //
        // Set the global variable
        //
        SampNT4UpgradeInProgress = TRUE;

        //
        // Use the previously saved off hives
        //

        //
        // Create the key name
        //
        wcscpy( SamUpgradeKeyPath, L"\\Registry\\Machine\\" );
        wcscat( SamUpgradeKeyPath, SAMP_DOWNLEVEL_DB_KEYNAME );
        wcscat( SamUpgradeKeyPath, L"\\SAM" );

        //
        // Use the existing downlevel hives
        //
        NtStatus = SampRegistryToDsUpgrade( SamUpgradeKeyPath );


        //
        // Unload the hive
        //
        IgnoreStatus = SamIUnLoadDownlevelDatabase( NULL );
        ASSERT( NT_SUCCESS( IgnoreStatus ) );

        //
        // turn off it
        //
        SampNT4UpgradeInProgress = FALSE;

        if ( !NT_SUCCESS(NtStatus) ) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampRegistryToDsUpgrade failed with 0x%x\n",
                       NtStatus));

            return NtStatus;
        }

    } else if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_MIGRATE ) )
    {
        //
        // Prepare the current hives
        //
        NtStatus = SampRenameKrbtgtAccount();

        if ( !NT_SUCCESS(NtStatus) ) {

            //
            // This is not a fatal error
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampRenameKrbtgtAccount failed with 0x%x\n",
                       NtStatus));

            NtStatus = STATUS_SUCCESS;
        }

        NtStatus = NtFlushKey( SampKey );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            //
            // This is not a fatal error
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "NtFlushKey returned 0x%x\n",
                       NtStatus));

            NtStatus = STATUS_SUCCESS;
        }

        NtStatus = SampRegistryToDsUpgrade( L"\\Registry\\Machine\\SAM\\SAM" );

        if ( !NT_SUCCESS(NtStatus) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampRegistryToDsUpgrade failed with 0x%x\n",
                       NtStatus));

            return NtStatus;
        }

    } else if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_CREATE ))
    {
        //
        // Create new domain hives
        //

        //
        // Make sure there is nothing in the temporary location
        //
        RtlInitUnicodeString(&TempSamKeyName, L"\\Registry\\Machine\\SAM\\NT5");
        InitializeObjectAttributes(&TempSamKey,
                                   &TempSamKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        NtStatus = NtOpenKey(&TempSamKeyHandle,
                             KEY_ALL_ACCESS,
                             &TempSamKey);

        if ( NT_SUCCESS(NtStatus) ) {
            //
            // There is something here - delete it
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Deleting keys under SAM\\NT5\n"));

            NtClose(TempSamKeyHandle);

            NtStatus = SampRegistryDelnode(TempSamKeyName.Buffer);

            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Deletion failed; erroring out\n"));

                return NtStatus;
            }
        }

        DatabaseProductType = NtProductLanManNt;

        //
        // We are the first DC in this domain so make us the primary
        //
        DatabaseServerRole  = PolicyServerRolePrimary;

        //
        // Make the account domain information the same as the
        // primary domain information
        //
        NewAccountDomainInfo.DomainSid = NewPrimaryDomainInfo->Sid;
        NewAccountDomainInfo.DomainName = NewPrimaryDomainInfo->Name;

        //
        // Now create the temporary set of hives
        //
        NtStatus = SampInitializeRegistry(L"\\Registry\\Machine\\SAM\\NT5",
                                          &DatabaseProductType,
                                          &DatabaseServerRole,
                                          &NewAccountDomainInfo,
                                          NewPrimaryDomainInfo,
                                          FALSE
                                          );


        __try
        {

            if (NT_SUCCESS(NtStatus)) {

                //
                // Now transfer these new accounts into the ds
                //

                NtStatus = SampRegistryToDsUpgrade(L"\\Registry\\Machine\\SAM\\NT5\\SAM");
                if (!NT_SUCCESS(NtStatus)) {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SampRegistryToDsUpgrade failed with 0x%x\n",
                               NtStatus));
                }

            } else {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SampInitializeRegistry failed with 0x%x\n",
                           NtStatus));
            }

        }
        __finally
        {
            //
            // Delete the temporary hive
            //
            IgnoreStatus = SampRegistryDelnode(TempSamKeyName.Buffer);

            if (!NT_SUCCESS(IgnoreStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Deletion of temporary hive failed 0x%x; \n",
                           IgnoreStatus));
            }

        }
    } else
    {
        return STATUS_INVALID_PARAMETER;
    }

    if ( NT_SUCCESS(NtStatus) ) {

        UNICODE_STRING p;
        BOOLEAN fUseCurrentAdmin = ((PromoteFlags & SAMP_PROMOTE_DFLT_REPAIR_PWD)
                                   ? TRUE : FALSE);


        //
        // Ok, the principals are in the ds - now set the user supplied
        // admin password if supplied - it will be blank otherwise
        //

        //
        // N.B.  There should always be a value written to the registry
        // this will help determine if the database needs to be
        // recreated
        //

        if ( SafeModeAdminPassword ) {

            RtlCopyMemory( &p, SafeModeAdminPassword, sizeof(UNICODE_STRING) );

        } else {

            RtlZeroMemory( &p, sizeof(UNICODE_STRING) );

        }


        //
        // Setting the password is a difficult operation here because it
        // needs to be set in the ds, but sam is not running on the ds.
        // So, we take the clear text password, owf it and store a blob
        // in the registry containing the owf'ed password.  Upon reboot,
        // this blob will be read in and then set on the admin account
        // just before SamIInitialize() returns.
        //

        NtStatus = SampSetAdminPasswordInRegistry(fUseCurrentAdmin,
                                                  &p);

        if ( !NT_SUCCESS(NtStatus) ) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Unable to save admin password 0x%x; \n",
                       NtStatus));

            //
            // Fail the call.  This is a bit harsh but there is
            // no way to tell the user to use a blank password.
            // The call to set the admin password is not expected
            // to fail.  The password most likely could not
            // be owf'ed.  Encourage the user to try another.
            //
            NtStatus = STATUS_ILL_FORMED_PASSWORD;

        } // set password failed

    } // there is a password to set


    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Everything completed successfully; prepare for phase 2
        // on the next reboot
        //
        NtStatus =  SampCreateKeyForPostBootPromote(PromoteFlags);
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampCreateKeyForPostBootPromote failed with 0x%x\n",
                       NtStatus));
        }

    }


    return NtStatus;
}


NTSTATUS
SamIPromoteUndo(
    VOID
    )
/*++

Description:

    This routine undoes any persistent data left by SamIPromote.

Parameters:

    None

Return Values:

    An ntstatus resulting from a failure system service

--*/
{
    NTSTATUS NtStatus;

    NtStatus = SampDeleteKeyForPostBootPromote();
    if ( !NT_SUCCESS( NtStatus ) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampRemoveKeyForPostBootPromote failed with 0x%x\n",
                   NtStatus));
    }

    NtStatus = SampRemoveAdminPasswordFromRegistry();
    if ( !NT_SUCCESS( NtStatus ) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampRemoveAdminPasswordFromRegistry failed with 0x%x\n",
                   NtStatus));
    }



    return STATUS_SUCCESS;
}


NTSTATUS
SamIDemote(
    IN DWORD                        DemoteFlags,
    IN PPOLICY_ACCOUNT_DOMAIN_INFO  NewAccountDomainInfo,
    IN LPWSTR                       AdminPassword  OPTIONAL
    )
/*++

Description:

    This routine prepares SAM to use the registry as its database on the next reboot.

Parameters:

    fLastDcInDomain:  if TRUE then prepare for standalone; otherwise member server

    AdminPassword  :  the admin password upon reboot

    NewAccountDomainInfo :  the identification of the new domain

Return Values:

    An ntstatus resulting from a failure system service

--*/
{
    NTSTATUS               NtStatus = STATUS_SUCCESS;
    UNICODE_STRING         Password;

    //
    // Parameter checks
    //
    if ( !NewAccountDomainInfo )
    {
        //
        // Unused for now
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Bad parameter to SamIDemote\n" ));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Sanity check that we are really using the ds
    //
    ASSERT( SampUsingDsData() );

    //
    // Set the admin password
    //
    RtlInitUnicodeString( &Password, AdminPassword );
    NtStatus =  SampSetAdminPasswordInRegistry( FALSE, &Password );
    if ( !NT_SUCCESS(NtStatus) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetAdminPasswordInRegistry failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Save off the ds paths to delete
    //
    NtStatus = SampStoreDsDirsToDelete();
    if ( !NT_SUCCESS(NtStatus) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampStoreDsDirsToDelete failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    NtStatus = SampCreateKeyForPostBootPromote( DemoteFlags );
    if ( !NT_SUCCESS(NtStatus) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampCreateKeyForPostBootPromote failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Ok, make sure all current clients have left and then disable SAM
    //
    NtStatus = SampAcquireWriteLock();
    ASSERT( NT_SUCCESS( NtStatus ) );

    //
    // No more clients allowed
    //
    SampServiceState = SampServiceDemoted;

    SampReleaseWriteLock( FALSE );


Cleanup:

    if ( !NT_SUCCESS( NtStatus ) )
    {
        // leave no traces
        SampRemoveAdminPasswordFromRegistry();
        SampDeleteDsDirsToDeleteKey();
        SampDeleteKeyForPostBootPromote();
    }

    return NtStatus;
}


NTSTATUS
SamIDemoteUndo(
    VOID
    )
/*++

Routine Description

    This routine undoes the effect of SamIDemote.

    Currently this means:

    o   Removing the "subsequent boot key"
    o   Removing the admin password stored in the registry
    o   Removing the ds directories to delete

Parameters

    None.

Return Values

    STATUS_SUCCESS, if if an error occurs, the function still continues cleaning
    up as best it can.

--*/
{
    NTSTATUS NtStatus;

    //
    // Keys for managing the registry database
    //
    UNICODE_STRING         SamKeyName;
    OBJECT_ATTRIBUTES      SamKey;
    HANDLE                 SamKeyHandle;

    //
    // Remove the post boot key
    //
    NtStatus =  SampDeleteKeyForPostBootPromote();
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampDeleteKeyForPostBootPromote failed with 0x%x\n",
                   NtStatus));
    }
    ASSERT(NT_SUCCESS(NtStatus));

    // Continue on, regardless of error
    NtStatus = STATUS_SUCCESS;

    //
    // Remove the admin temporarily stored in the registry
    //
    NtStatus = SampRemoveAdminPasswordFromRegistry();
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampRemoveAdminPasswordFromRegistry failed with 0x%x\n",
                   NtStatus));

    }

    NtStatus = SampDeleteDsDirsToDeleteKey();
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampDeleteDsDirsToDeleteKey failed with 0x%x\n",
                   NtStatus));
    }

    // Continue on, regardless of error
    NtStatus = STATUS_SUCCESS;


    //
    // Turn SAM back on
    //
    SampServiceState = SampServiceEnabled;

    return NtStatus;
}


BOOL
SampIsRebootAfterPromotion(
    OUT PULONG PromoteData
    )
/*++

Routine Description

    This routine checks to see if a particular key exists, created by SamIPromote,
    to determine if the current boot sequence is the one just after the ds
    in installed.

Parameters

    PromoteData  : this will hold whatever value was stored in the key

Return Values

    TRUE if such a key was found; FALSE otherwise


--*/
{
    NTSTATUS NtStatus;

    ASSERT(PromoteData);
    if ( PromoteData )
    {
        *PromoteData = 0;
    }

    NtStatus =  SampRetrieveKeyForPostBootPromote( PromoteData );

    if ( NT_SUCCESS(NtStatus) )
    {
        //
        // Make sure the promote data matches what we think we
        // should be doing
        //
        if (  FLAG_ON( (*PromoteData), SAMP_PROMOTE_DOMAIN )
           || FLAG_ON( (*PromoteData), SAMP_PROMOTE_REPLICA ) )
        {
            //
            // We think we are the reboot after a promotion
            //
            if ( SampProductType == NtProductLanManNt )
            {
                return TRUE;
            }

            //
            // Even if Ds Repair mode there is work to do --
            // namely setting the ds repair admin password
            //
            if ( (SampProductType == NtProductServer) 
              &&  LsaISafeMode()  ) {

                return TRUE;

            }
        }
        else if (  FLAG_ON( (*PromoteData), SAMP_DEMOTE_STANDALONE )
                || FLAG_ON( (*PromoteData), SAMP_DEMOTE_MEMBER ) )
        {
            //
            // This is a reboot after demotion
            //
            if ( SampProductType == NtProductServer )
            {
                return TRUE;
            }
        }
        else if ( FLAG_ON( (*PromoteData), SAMP_TEMP_UPGRADE ) )
        {
            //
            // This is a reboot after gui mode setup of nt4 upgrade
            //
            if ( SampProductType == NtProductServer )
            {
                return TRUE;
            }
        }

    }

    return FALSE;

}


NTSTATUS
SamIReplaceDownlevelDatabase(
    IN  PPOLICY_ACCOUNT_DOMAIN_INFO  NewAccountDomainInfo,
    IN  LPWSTR                       NewAdminPassword,
    OUT ULONG                        *ExtendedWinError OPTIONAL
    )
/*++

Routine Description:

    This routine prepares the currently loaded pre-nt5 dc hive to be upgraded
    for the ds in nt5.  Currently this means, renaming any account with
    the name "krbtgt" and then saving the hive off to a file.

    N.B. This function was delibrately not split up into helper functions
    for debugging ease.

Parameters:

    NewAccountDomainInfo : non null pointer to the new account domain info

    NewAdminPassword: the password for the new admin account

    ExtendedWinError : on error the win32 error that caused the problem

Return Values:

    STATUS_SUCCESS, or system service error.

--*/
{
    NTSTATUS NtStatus, IgnoreStatus;
    DWORD    WinError, IgnoreWinError;
    BOOL     fStatus;

    WCHAR    DownLevelDatabaseFilePath[ MAX_PATH ];
    WCHAR    NewDatabaseFilePath[ MAX_PATH ];

    WCHAR*   FileName = SAMP_DOWNLEVEL_DB_FILENAME;
    WCHAR*   NewFileName = SAMP_NEW_DB_FILENAME;

    WCHAR*   SystemRoot = L"systemroot";
    WCHAR*   ConfigDirectoryPath = L"\\system32\\config";

    WCHAR    SystemRootPath[ MAX_PATH ];
    ULONG    Size;

    NT_PRODUCT_TYPE             DatabaseProductType = NtProductServer;
    POLICY_LSA_SERVER_ROLE      DatabaseServerRole  = PolicyServerRolePrimary;
    POLICY_PRIMARY_DOMAIN_INFO  NewPrimaryDomainInfo;

    HKEY KeyHandle;

    BOOLEAN  fWasEnabled;

    UNICODE_STRING  AdminPassword;

    SAMTRACE_EX( "SamISaveDownlevelDatabase" );

    //
    // Clear the extended error
    //
    WinError = ERROR_SUCCESS;

    //
    // Parameter sanity check
    //
    if ( !NewAccountDomainInfo )
    {
        *ExtendedWinError = ERROR_INVALID_PARAMETER;
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Environment sanity check
    //
    if ( !SampIsDownlevelDcUpgrade() )
    {
        *ExtendedWinError = ERROR_INVALID_SERVER_STATE;
        return STATUS_INVALID_SERVER_STATE;
    }

    //
    // Construct the file names
    //
    RtlZeroMemory( SystemRootPath, sizeof( SystemRootPath ) );
    Size = sizeof( SystemRootPath ) / sizeof(WCHAR) ;
    Size = GetEnvironmentVariable( SystemRoot,
                                   SystemRootPath,
                                   Size );

    RtlZeroMemory( DownLevelDatabaseFilePath, sizeof(DownLevelDatabaseFilePath) );
    wcscpy( DownLevelDatabaseFilePath, SystemRootPath );
    wcscat( DownLevelDatabaseFilePath, ConfigDirectoryPath );
    wcscat( DownLevelDatabaseFilePath, FileName );

    wcscpy( NewDatabaseFilePath, SystemRootPath );
    wcscat( NewDatabaseFilePath, ConfigDirectoryPath );
    wcscat( NewDatabaseFilePath, NewFileName );

    //
    // Delete any previous versions of the files
    //
    fStatus = DeleteFile( DownLevelDatabaseFilePath );

    if ( !fStatus )
    {
        WinError = GetLastError();
        if ( ERROR_FILE_NOT_FOUND != WinError )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Delete File failed with %d\n",
                       GetLastError()));
        }
        //
        // Oh well, continue on
        //
        WinError = ERROR_SUCCESS;

    }

    fStatus = DeleteFile( NewDatabaseFilePath );

    if ( !fStatus )
    {
        WinError = GetLastError();
        if ( ERROR_FILE_NOT_FOUND != WinError )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Delete File failed with %d\n",
                       GetLastError()));
        }
        //
        // Oh well, continue on
        //
        WinError = ERROR_SUCCESS;
    }

    //
    // Prepare the downlevel hive to be saved off
    //

    //
    //  First rename any krbtgt accounts
    //
    NtStatus = SampRenameKrbtgtAccount();
    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // This is not a fatal error
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampRenameKrbtgtAccount failed with 0x%x\n",
                   NtStatus));

        NtStatus = STATUS_SUCCESS;
    }

    //
    // Make sure the current handle to the database is valid
    //
    ASSERT( SampKey && (INVALID_HANDLE_VALUE != SampKey) );

    //
    // Flush any outstanding changes
    //
    NtStatus = NtFlushKey( SampKey );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "NtFlushKey returned 0x%x\n",
                   NtStatus));

        NtStatus = STATUS_SUCCESS;
    }

    //
    // Prepare the new member server account database
    //
    IgnoreStatus = SampRegistryDelnode( L"\\Registry\\Machine\\SOFTWARE\\TEMPSAM" );

    //
    // If we are syskeyed DC, we call SampInitializeRegistry with the flag
    // to let us know that we need to preserve the Syskey settings. This results
    // in persisting a flag indicating that we need to hold the syskey in memory
    // next time at reboot and also copying our current syskey type into the new
    // database.
    //

    NtStatus = SampInitializeRegistry(L"\\Registry\\Machine\\SOFTWARE\\TEMPSAM",
                                      &DatabaseProductType,
                                      &DatabaseServerRole,
                                      NewAccountDomainInfo,
                                      NULL,
                                      SampSecretEncryptionEnabled
                                     );  // call into lsa to the primary domain info

    if ( NT_SUCCESS( NtStatus ) )
    {
        //
        // Open a handle to the key
        //
        WinError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 L"SOFTWARE\\TEMPSAM",
                                 0,  // reserved
                                 KEY_ALL_ACCESS,
                                 &KeyHandle );

        if ( ERROR_SUCCESS == WinError )
        {
            //
            // Save the hive
            //

            IgnoreStatus = RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                                               TRUE,           // Enable
                                               FALSE,          // not client; process wide
                                               &fWasEnabled );
            ASSERT( NT_SUCCESS( IgnoreStatus ) );

            WinError = RegSaveKey( KeyHandle,
                                   NewDatabaseFilePath,
                                   NULL );

            IgnoreStatus = RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                                               FALSE,          // Disable
                                               FALSE,          // not client; process wide
                                               &fWasEnabled );
            ASSERT( NT_SUCCESS( IgnoreStatus ) );

            //
            // We no longer need an open key
            //
            IgnoreWinError = RegCloseKey( KeyHandle );
            ASSERT( IgnoreWinError == ERROR_SUCCESS );

            if ( ERROR_SUCCESS == WinError )
            {

                //
                // Replace the SAM key with the SAM hive
                //
                IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                                   TRUE,           // Enable
                                                   FALSE,          // not client; process wide
                                                   &fWasEnabled );
                ASSERT( NT_SUCCESS( IgnoreStatus ) );

                WinError = RegReplaceKey( HKEY_LOCAL_MACHINE,
                                          L"SAM",
                                          NewDatabaseFilePath,
                                          DownLevelDatabaseFilePath );

                IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                                   FALSE,          // Disable
                                                   FALSE,          // not client; process wide
                                                   &fWasEnabled );
                ASSERT( NT_SUCCESS( IgnoreStatus ) );

                if ( ERROR_SUCCESS != WinError )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "RegReplaceKey returned %d\n",
                               WinError));
                }
            }
            else
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "RegSaveKey returned %d\n",
                           WinError));
            }

            //
            // Delete the temporary hive
            //
            IgnoreStatus = SampRegistryDelnode( L"\\Registry\\Machine\\SOFTWARE\\TEMPSAM" );

        }
        else
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "RegOpenKeyEx returned %d\n",
                       WinError));
        }

        if ( ERROR_SUCCESS != WinError )
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SampInitializeRegistry returned 0x%x\n",
                   NtStatus));
    }

    if ( NT_SUCCESS( NtStatus ) && NewAdminPassword )
    {
        RtlInitUnicodeString( &AdminPassword, NewAdminPassword );
        NtStatus = SampSetAdminPasswordInRegistry( FALSE, &AdminPassword );

        if ( NT_SUCCESS( NtStatus ) )
        {
            NtStatus = SampCreateKeyForPostBootPromote( SAMP_TEMP_UPGRADE );
        }
        WinError = RtlNtStatusToDosError( NtStatus );
    }

    //
    // Done
    //
    if ( ExtendedWinError )
    {
        *ExtendedWinError = WinError;
    }

    return NtStatus;
}


NTSTATUS
SamILoadDownlevelDatabase(
    OUT ULONG *ExtendedWinError OPTIONAL
    )
/*++

Routine Description:

    This routine attempts to load the hive saved off by
    SamILoadDownlevelDatabase.

Parameters:

    ExtendedWinError : on error the win32 error that caused the problem

Return Values:

    STATUS_INVALID_SERVER_STATE, STATUS_SUCCESS, or system service error.

--*/
{


    NTSTATUS NtStatus, IgnoreStatus;
    DWORD    WinError;
    BOOL     fStatus;

    WCHAR    FilePath[ MAX_PATH ];
    WCHAR    BackupFilePath[ MAX_PATH ];

    WCHAR*   FileName = SAMP_DOWNLEVEL_DB_FILENAME;
    WCHAR*   BackupFileName = SAMP_DOWNLEVEL_DB_FILENAME_BACKUP;

    WCHAR*   SystemRoot = L"systemroot";
    WCHAR*   ConfigDirectoryPath = L"\\system32\\config";

    WCHAR    SystemRootPath[ MAX_PATH ];
    ULONG    Size;

    WCHAR*   SamUpgradeKey = SAMP_DOWNLEVEL_DB_KEYNAME;
    WCHAR    SamUpgradeKeyPath[ MAX_PATH ];


    BOOLEAN        fWasEnabled;

    SAMTRACE_EX( "SamILoadDownlevelDatabase" );

    wcscpy( SamUpgradeKeyPath, L"\\Registry\\Machine\\" );
    wcscat( SamUpgradeKeyPath, SamUpgradeKey );

    //
    // Delete any old info in registry
    //
    NtStatus = SampRegistryDelnode( SamUpgradeKeyPath );
    if (   !NT_SUCCESS( NtStatus )
        && STATUS_OBJECT_NAME_NOT_FOUND != NtStatus )
    {
        //
        // Oh well, try to continue on
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SampRegistryDelnode failed with 0x%x\n",
                   NtStatus));

    }
    NtStatus = STATUS_SUCCESS;

    //
    // Construct the file names
    //
    RtlZeroMemory( SystemRootPath, sizeof( SystemRootPath ) );
    Size = sizeof( SystemRootPath ) / sizeof(WCHAR);
    Size = GetEnvironmentVariable( SystemRoot,
                                   SystemRootPath,
                                   Size );

    RtlZeroMemory( FilePath, sizeof(FilePath) );
    wcscpy( FilePath, SystemRootPath );
    wcscat( FilePath, ConfigDirectoryPath );
    wcscat( FilePath, FileName );

    RtlZeroMemory( BackupFilePath, sizeof(BackupFilePath) );
    wcscpy( BackupFilePath, SystemRootPath );
    wcscat( BackupFilePath, ConfigDirectoryPath );
    wcscat( BackupFilePath, BackupFileName );

    //
    // Enable restore privilege
    //
    IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                       TRUE,           // Enable
                                       FALSE,          // not client; process wide
                                       &fWasEnabled );
    ASSERT( NT_SUCCESS( IgnoreStatus ) );

    //
    // Load the info
    //
    WinError = RegLoadKey(  HKEY_LOCAL_MACHINE,
                            SamUpgradeKey,
                            FilePath );

    if ( ERROR_SUCCESS != WinError )
    {
        //
        // Ok, our attempt to load the hive we created failed
        // Try the base nt saved off copy
        //
        WinError = RegLoadKey(  HKEY_LOCAL_MACHINE,
                                SamUpgradeKey,
                                BackupFilePath );

    }

    //
    // Disable the restore privilege
    //
    IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                       FALSE,          // Disable
                                       FALSE,          // not client; process wide
                                       &fWasEnabled );

    ASSERT( NT_SUCCESS( IgnoreStatus ) );

    if ( ERROR_SUCCESS != WinError )
    {
        //
        // This isn't good - what to do?
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "RegLoadKey returned %d\n",
                   WinError));

        NtStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Done
    //

    if ( ExtendedWinError )
    {
        *ExtendedWinError = WinError;
    }

    return NtStatus;
}


NTSTATUS
SamIUnLoadDownlevelDatabase(
    OUT ULONG *ExtendedWinError OPTIONAL
    )
/*++

Routine Description:

    This routine unloads the "temporarily" loaded downlevel hive from
    the registry.

Parameters:

    ExtendedWinError : on error the win32 error that caused the problem

Return Values:

    STATUS_SUCCESS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    DWORD    WinError;
    BOOLEAN  fWasEnabled;

    //
    // Enable restore privilege
    //
    IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                       TRUE,           // Enable
                                       FALSE,          // not client; process wide
                                       &fWasEnabled );
    ASSERT( NT_SUCCESS( IgnoreStatus ) );

    //
    // Unload the hive
    //
    WinError = RegUnLoadKey( HKEY_LOCAL_MACHINE, SAMP_DOWNLEVEL_DB_KEYNAME );
    if ( ERROR_SUCCESS != WinError )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RegUnLoadKey failed with %d\n",
                   WinError));

        NtStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Disble restore privilege
    //
    IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                       FALSE,          // Disable
                                       FALSE,          // not client; process wide
                                       &fWasEnabled );
    ASSERT( NT_SUCCESS( IgnoreStatus ) );

    if ( ExtendedWinError )
    {
        *ExtendedWinError = WinError;
    }

    return NtStatus;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampCheckPromoteEnvironment(
    IN  ULONG PromoteFlags
    )
/*++

Routine Description:

    This routine first queries LSA and the system to determine our
    current role.  Then the two operations that are passed in and
    verified to be valid operations for the server's current role.
    See module header for supported promotions.

Parameters:

    PromoteFlags:  the callers desired role change

Return Values:

    STATUS_INVALID_SERVER_STATE, STATUS_SUCCESS, or system service error.

--*/
{


    NTSTATUS                     NtStatus = STATUS_SUCCESS;

    SAMP_ROLE_CONFIGURATION      RoleConfiguration = SampMemberServer;

    OSVERSIONINFO                VersionInformation;
    NT_PRODUCT_TYPE              NtProductType;
    PLSAPR_POLICY_INFORMATION    PolicyInfo;
    BOOLEAN                      fSetupInProgress;
    BOOLEAN                      fUpgradeInProgress;


    //
    // Sanity check the flags
    //
#if DBG

    if  ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_ENTERPRISE ) )
    {
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) );
        ASSERT( FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) );
    }
    if  ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) )
    {
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_ENTERPRISE ) );
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) );
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_UPGRADE ) );
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_MIGRATE ) );
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_CREATE ) );
    }
    if  ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) )
    {
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) );
        ASSERT( FLAG_ON( PromoteFlags, SAMP_PROMOTE_UPGRADE )
             || FLAG_ON( PromoteFlags, SAMP_PROMOTE_MIGRATE )
             || FLAG_ON( PromoteFlags, SAMP_PROMOTE_CREATE ) );
    }

#endif

    //
    // Are running during setup?
    //
    fSetupInProgress = SampIsSetupInProgress(&fUpgradeInProgress);

    if (!RtlGetNtProductType(&NtProductType)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RtlGetNtProductType failed\n"));

        return STATUS_UNSUCCESSFUL;
    }

    switch (NtProductType) {

        case NtProductWinNt:
            //
            // This is a workstation - illegal
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Illegal to promote a workstation\n"));

            NtStatus = STATUS_INVALID_SERVER_STATE;
            break;


        case NtProductLanManNt:

            //
            // This is a DC - only legal when running during gui mode
            // setup.
            //
            ASSERT(fSetupInProgress);
            ASSERT(fUpgradeInProgress);

            if (SampUsingDsData()) {

                //
                // Definately not legal to promote when the ds is already
                // running!
                //

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Trying to promote when ds is already running!\n"));

                NtStatus = STATUS_INVALID_SERVER_STATE;
                break;

            }


            //
            // This is domain controller - what role are we?
            //
            NtStatus = LsaIQueryInformationPolicyTrusted(
                                     PolicyLsaServerRoleInformation,
                                     &PolicyInfo);

            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "LsaIQueryInformationPolicyTrusted returned 0x%x\n",
                           NtStatus));

                break;
            }

            if (PolicyServerRolePrimary == PolicyInfo->PolicyServerRoleInfo.LsaServerRole) {

                RoleConfiguration = SampDownlevelPDC;

            } else if (PolicyServerRoleBackup == PolicyInfo->PolicyServerRoleInfo.LsaServerRole){

                RoleConfiguration = SampDownlevelBDC;

            } else {

                ASSERT(!"SAMSS: Bad server role from Lsa\n");
                NtStatus = STATUS_UNSUCCESSFUL;
                break;
            }

            LsaIFree_LSAPR_POLICY_INFORMATION(PolicyLsaServerRoleInformation,
                                              PolicyInfo);

            break;


        case NtProductServer:

            //
            // This either a standalone or member server - determine
            // which one
            //

            RtlZeroMemory(&PolicyInfo, sizeof(PolicyInfo));
            NtStatus = LsaIQueryInformationPolicyTrusted(
                                     PolicyPrimaryDomainInformation,
                                     &PolicyInfo);
            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "LsaIQueryInformationPolicyTrusted returned 0x%x\n",
                           NtStatus));

                break;
            }

            if (NULL == PolicyInfo->PolicyAccountDomainInfo.DomainSid) {
                //
                // No Domain sid - this is a standalone server
                //
                RoleConfiguration = SampStandaloneServer;
            } else {
                //
                // Domain sid - this is a member server
                //
                RoleConfiguration = SampMemberServer;
            }

            LsaIFree_LSAPR_POLICY_INFORMATION(PolicyPrimaryDomainInformation,
                                              PolicyInfo);

            break;

        default:

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Bad product type\n"));

            NtStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // If error an occured at this point, there is no point in continuing
    //
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Now some analysis
    //
    NtStatus = STATUS_INVALID_SERVER_STATE;
    switch (RoleConfiguration) {

        case SampStandaloneServer:

            //
            // Can only promote to a DC in a new domain
            //
            if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) )
            {
                NtStatus = STATUS_SUCCESS;
            }

            break;

        case SampMemberServer:

            //
            // Can only be a DC in the domain that server is currently
            // joined to
            //
            if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) )
            {
                NtStatus = STATUS_SUCCESS;
            }

             // In case of a new domain install on a stand-alone
             // server, we set the domain-sid early so that
             // the text SDs from schema.ini, that may have groups
             // like domain-admin etc. that require domain-sids,
             // can be converted correcly by MacM's SD-conversion
             // api's.
             if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) )
             {
                 NtStatus = STATUS_SUCCESS;
             }

            break;

        case SampDownlevelPDC:
        case SampDownlevelBDC:

            //
            // Not supported
            //

        default:

            NtStatus = STATUS_INVALID_SERVER_STATE;

    }

    return NtStatus;

}


NTSTATUS
SampPerformPromotePhase2(
    IN ULONG PromoteFlags
    )
/*++

Routine Description

    This routine is called during the boot sequence following a successful
    promotion.  If successful, this routine will delete the registry key
    so that SampIsRebootAfterPromotion() will return FALSE.

Parameters

    PromoteFlags:  this is value indicates whether this is the first dc in a
                   new domain or a replica.

Return Values

    STATUS_SUCCESS; a system service error otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Resources that need to be cleaned up
    //
    SAMPR_HANDLE ServerHandle = 0;
    SAMPR_HANDLE DomainHandle = 0;
    SAMPR_HANDLE BuiltinDomainHandle = 0;
    PPOLICY_ACCOUNT_DOMAIN_INFO  DomainInfo = NULL;


    //
    // We should not performing operations here in repair mode
    // other than a group upgrade

    ASSERT( (!LsaISafeMode()) || (SAMP_PROMOTE_INTERNAL_UPGRADE==PromoteFlags) );

    //
    // Open the server
    //
    NtStatus = SampConnect(NULL,           // server name, this is ignored
                           &ServerHandle,
                           SAM_CLIENT_LATEST,
                           GENERIC_ALL,    // all access
                           TRUE,           // trusted client
                           FALSE,
                           FALSE,          // NotSharedByMultiThreads 
                           TRUE
                           );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamIConnect failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }


    //
    // Get the current domain's sid
    //
    NtStatus = SampGetAccountDomainInfo(&DomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampGetAccountDomainInfo failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }
    ASSERT(DomainInfo);
    ASSERT(DomainInfo->DomainSid);

    //
    // Open the current domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              DomainInfo->DomainSid,
                              &DomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrOpenDomain failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Open the builtin domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              SampBuiltinDomainSid,
                              &BuiltinDomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrOpenDomain (Builtin) failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) )
    {

        NtStatus = SampPerformReplicaDcPromotePhase2(DomainHandle);
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampPerformReplicaDcPromotePhase2 function failed with 0x%x\n",
                       NtStatus));
        }
    }
    else if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) )
    {
        NtStatus = SampPerformFirstDcPromotePhase2(DomainHandle,
                                                   BuiltinDomainHandle,
                                                   PromoteFlags );

    }
    else if ( FLAG_ON( PromoteFlags, SAMP_DEMOTE_MEMBER ) )
    {
        NtStatus = SampPerformNewServerPhase2( DomainHandle,
                                               TRUE );
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampPerformNewServerPhase2 function failed with 0x%x\n",
                       NtStatus));
        }
    }
    else if ( FLAG_ON( PromoteFlags, SAMP_DEMOTE_STANDALONE ) )
    {
        NtStatus = SampPerformNewServerPhase2( DomainHandle,
                                               FALSE );
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampPerformNewServerPhase2 function failed with 0x%x\n",
                       NtStatus));
        }
    }
    else if ( FLAG_ON( PromoteFlags, SAMP_TEMP_UPGRADE ) )
    {
        NtStatus = SampPerformTempUpgradeWork( DomainHandle );
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampPerformTempUpgradeWork function failed with 0x%x\n",
                       NtStatus));
        }
    }
    else if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_INTERNAL_UPGRADE ) )
    {
        //
        // Only do this on the PDC
        //
        DOMAIN_SERVER_ROLE ServerRole;

        NtStatus = SamIQueryServerRole( DomainHandle, &ServerRole );
        if (  NT_SUCCESS( NtStatus )
          &&  (ServerRole == DomainServerRolePrimary) ) {

            NtStatus = SampAddWellKnownAccounts( DomainHandle,
                                                 BuiltinDomainHandle,
                                                 PromoteFlags );

            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SampAddWellKnownAccounts function failed with 0x%x\n",
                           NtStatus));
            }

            if (NT_SUCCESS(NtStatus) && SampUseDsData)
            {

                NtStatus = SampAddAnonymousToPreW2KCompAlias(DomainHandle, 
                                                             BuiltinDomainHandle
                                                             );
                if (!NT_SUCCESS(NtStatus)) {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SampAddAnonymousToPreW2KCompAlias function failed with 0x%x\n",
                               NtStatus));
                }

                //
                // if all well known accounts has been created, update 
                // DS server revision. We can afford to ignore the return error,
                // because if DS server revision update failed, we still have a 
                // chance to update accounts during PDC server role transfer.
                // 

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampDsSetServerRevision( SAMP_DS_REVISION );

                    if (!NT_SUCCESS(NtStatus)) {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampDsSetServerRevision function failed with 0x%x\n",
                                   NtStatus));
                    }
                }

            }

        }
    }
    else
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Invalid promote phase 2 data\n"));

        //
        // Oh, well, continue on
        //
        NtStatus = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_UPGRADE ) )
    {
        //
        // At this point, we have successfully booted from
        // the ds and created all our needed security principals.
        // Let's clean up.
        //

        //
        // Delete the saved upgrade hive
        //

        WCHAR*   SystemRoot = L"systemroot";
        WCHAR*   ConfigDirectoryPath = L"\\system32\\config";

        WCHAR *FilesToDelete[] =
        {
            SAMP_DOWNLEVEL_DB_FILENAME,
            SAMP_NEW_DB_FILENAME,
            SAMP_DOWNLEVEL_DB_FILENAME_BACKUP
        };

        WCHAR    SystemRootPath[ MAX_PATH + 1];
        ULONG    Size;

        WCHAR    FilePath[ MAX_PATH + 1];

        DWORD    WinError = ERROR_SUCCESS;

        BOOL     fStatus;

        ULONG i;



        //
        // Construct the file names
        //
        RtlZeroMemory( SystemRootPath, sizeof( SystemRootPath ) );
        Size = sizeof( SystemRootPath ) / sizeof(WCHAR);
        Size = GetEnvironmentVariable( SystemRoot,
                                       SystemRootPath,
                                       Size );

        for ( i = 0 ; i < ARRAY_COUNT( FilesToDelete ); i++ ) {

            wcscpy( FilePath, SystemRootPath );
            wcscat( FilePath, ConfigDirectoryPath );
            wcscat( FilePath, FilesToDelete[i] );

            fStatus = DeleteFile( FilePath );

            if ( !fStatus )
            {
                //
                // Tell the user to delete this file
                //
                PUNICODE_STRING EventString[1];
                UNICODE_STRING  UnicodeString;

                WinError = GetLastError();
                if ( WinError != ERROR_FILE_NOT_FOUND )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: Failed to delete directory %ls; error %d\n",
                               FilePath,
                               WinError));

                    RtlInitUnicodeString( &UnicodeString, FilePath );
                    EventString[0] = &UnicodeString;

                    SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                      0,     // no category
                                      SAMMSG_DATABASE_FILE_NOT_DELETED,
                                      NULL,  // no sid
                                      1,
                                      sizeof(DWORD),
                                      EventString,
                                      (PVOID)(&WinError));
                }
            }
        }

    }

    //
    // That's it - fall through to clean up
    //

Cleanup:

    if (ServerHandle) {
        SamrCloseHandle(&ServerHandle);
    }

    if (DomainHandle) {
        SamrCloseHandle(&DomainHandle);
    }

    if (BuiltinDomainHandle) {
        SamrCloseHandle(&BuiltinDomainHandle);
    }

    if (DomainInfo) {
        LsaIFree_LSAPR_POLICY_INFORMATION (PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)DomainInfo);
    }

    //
    // Everything was successful; get rid of the key
    //
    if (NT_SUCCESS(NtStatus)
     && !FLAG_ON( PromoteFlags, SAMP_PROMOTE_INTERNAL_UPGRADE )  ) {

        NtStatus =  SampDeleteKeyForPostBootPromote();
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampDeleteKeyForPostBootPromote failed with 0x%x\n",
                       NtStatus));
        }
        ASSERT(NT_SUCCESS(NtStatus));

        // An error here is not fatal
        NtStatus = STATUS_SUCCESS;
    }

    //
    // During the development phase, we want to trap all instances of this
    // path failing.  It should never fail.  If it does then, SamIInitialize
    // fails, indicating a failed boot sequence.
    //

    ASSERT(NT_SUCCESS(NtStatus));

    return NtStatus;
}


NTSTATUS
SampPerformFirstDcPromotePhase2(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN ULONG        Flags
    )
/*++

Routine Description

    This routine performs the steps necessary to complete the promotion
    of a member server to a domain controller.


Parameters

    None.

Return Values

    STATUS_SUCCESS or STATUS_NO_MEMORY

--*/
{
    NTSTATUS                    NtStatus, IgnoreStatus;
    HANDLE                      PolicyHandle = 0;
    POLICY_LSA_SERVER_ROLE_INFO ServerRoleInfo;
    ULONG                       RetryCount;
    PSID                        DomainSid = NULL;
    PSAMP_OBJECT                DomainContext = NULL;

    //
    // Extract the domain sid
    //
    DomainContext = (PSAMP_OBJECT)DomainHandle;
    ASSERT( DomainContext->ObjectNameInDs );
    DomainSid = (PSID) &DomainContext->ObjectNameInDs->Sid;
    ASSERT( DomainSid );

    if ( !SampUseDsData )
    {
        //
        // Guard ourselves against wierd configurations
        //
        return STATUS_SUCCESS;
    }

    //
    // Create the accounts
    //
    RetryCount = 0;
    do
    {
        NtStatus = SampCreateFirstMachineAccount(DomainHandle);

        if ( NtStatus == STATUS_DS_BUSY )
        {
            //
            // There is a problem arising where the ds is "busy"
            // during boot time hence failing this creation.
            //

            //
            // In checked builds, ASSERT so we can figure out why this busy
            // is being caused. Look at the other threads in lsass.exe that
            // would cause this busy state.
            //
            ASSERT( !"SAMSS: DS is busy during machine account creation" );

            if ( RetryCount > 10 )
            {
                //
                // N.B. Potentially spin off a thread to create the account
                //
                break;

            }

            Sleep( 1000 );
            RetryCount++;
        }

    }  while ( NtStatus == STATUS_DS_BUSY );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampCreateFirstMachineAccount failed with 0x%x\n",
                   NtStatus));

        return NtStatus;
    }

    RetryCount = 0;
    do
    {

        //
        // Double check there is no existing krbtgt account
        //
        NtStatus = SampRenameKrbtgtAccount();
        if ( !NT_SUCCESS(NtStatus) ) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampRenameKrbtgtAccount failed with 0x%x\n",
                       NtStatus));

            //
            // Well, let's try to make the account anyway
            //
            NtStatus = STATUS_SUCCESS;

        }

        NtStatus = SampAddWellKnownAccounts(DomainHandle,
                                            BuiltinDomainHandle,
                                            Flags);

        if ( NtStatus == STATUS_DS_BUSY )
        {
            //
            // There is a problem arising where the ds is "busy"
            // during boot time hence failing this creation.
            //

            //
            // In checked builds, ASSERT so we can figure out why this busy
            // is being caused.
            //
            ASSERT( !"SAMSS: DS is busy during machine account creation" );

            if ( RetryCount > 10 )
            {
                //
                // N.B. Potentially spin off a thread to create the account
                //

                break;

            }

            Sleep( 1000 );
            RetryCount++;

        }

    } while ( NtStatus == STATUS_DS_BUSY );

    RetryCount = 0;
    do
    {
        NtStatus = SampApplyWellKnownMemberships( DomainHandle,
                                                  BuiltinDomainHandle,
                                                  DomainSid,
                                                  Flags);

        if ( NtStatus == STATUS_DS_BUSY )
        {
            //
            // There is a problem arising where the ds is "busy"
            // during boot time hence failing this creation.
            //

            //
            // In checked builds, ASSERT so we can figure out why this busy
            // is being caused.
            //
            ASSERT( !"SAMSS: DS is busy during machine account creation" );

            if ( RetryCount > 10 )
            {
                //
                // N.B. Potentially spin off a thread to create the account
                //

                break;

            }

            Sleep( 1000 );
            RetryCount++;

        }
        else  if ( !NT_SUCCESS(NtStatus) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampApplyWellKnownMemberships failed with 0x%x\n",
                       NtStatus));
        }

    } while ( NtStatus == STATUS_DS_BUSY );

    if ( NT_SUCCESS( NtStatus ) )
    {
        //
        // For new domain, add the ea to the administrators
        //
        NtStatus = SampAddEnterpriseAdminsToAdministrators();
        // SampAddEnterpriseAdminsToAdministrators must handle
        // all cases
        ASSERT( NT_SUCCESS( NtStatus ) );
    }

    return NtStatus;

}

NTSTATUS
SampSetNtDsaLink(
  DSNAME * Object
  )
/*++

  Routine Description

    This routine sets the link between the machine account object
    and the server object.

  Parameters:

       Object Ds Name of the object

  Return Values

    STATUS_SUCCESS
    Other Error Codes from Failed Dir Calls
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    MODIFYARG   ModifyArg;
    MODIFYRES   *pModifyRes;
    ULONG        RetCode = 0;
    DSNAME      *DsaDN = NULL;
    DSNAME      *ServerDN;
    ATTRVAL     AttrVal;
    ULONG       NameSize=0;
    BOOL        fErr = FALSE;



    //
    // Get the DSA object
    //

    NtStatus = GetConfigurationName(
                    DSCONFIGNAME_DSA,
                    &NameSize,
                    NULL
                    );

    if ((NT_SUCCESS(NtStatus))|| (STATUS_BUFFER_TOO_SMALL == NtStatus))
    {
        SAMP_ALLOCA(DsaDN,NameSize);
        if (NULL!=DsaDN)
        {

            NtStatus = GetConfigurationName(
                          DSCONFIGNAME_DSA,
                          &NameSize,
                          DsaDN
                          );
        }
        else
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Begin a transaction
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Our gAnchor shouldd be initialize now
    //

    ASSERT(NULL!=DsaDN);

    // Get the server DN from DsaDN

    SAMP_ALLOCA(ServerDN,DsaDN->structLen);
    if (NULL==ServerDN)
    {
         NtStatus = STATUS_INSUFFICIENT_RESOURCES;
         goto Error;
    }

    fErr = TrimDSNameBy(DsaDN, 1, ServerDN);
    if (fErr) {
      // Error from TrimDSNameBy
      KdPrintEx((DPFLTR_SAMSS_ID,
                 DPFLTR_INFO_LEVEL,
                 "Cannot trim DsaDN %d\n",
                 fErr));
    }


    //
    // Build a ModifyArg and perform the Dir Add Entry
    //

    RtlZeroMemory(&ModifyArg,sizeof(ModifyArg));
    BuildStdCommArg(&ModifyArg.CommArg);
    ModifyArg.pObject = ServerDN;
    ModifyArg.count =1;
    ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
    ModifyArg.FirstMod.AttrInf.attrTyp = ATT_SERVER_REFERENCE;
    ModifyArg.FirstMod.AttrInf.AttrVal.valCount=1;
    ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &AttrVal;
    AttrVal.pVal = (UCHAR *) Object;
    AttrVal.valLen = Object->structLen;

    RetCode = DirModifyEntry(&ModifyArg,&pModifyRes);

    if (NULL==pModifyRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModifyRes->CommRes);
    }


Error:

    SampMaybeEndDsTransaction((NT_SUCCESS(NtStatus))?
            TransactionCommit:TransactionAbort);
    return NtStatus;
}



NTSTATUS
SampPerformReplicaDcPromotePhase2(
    SAMPR_HANDLE DomainHandle
    )
/*++

Routine Description

    This routine performs the steps necessary to complete the promotion
    of a member server to a domain controller.

    The following actions are performed:

    1) Set the link from the computer object to the server object

Parameters

    None.

Return Values

    STATUS_SUCCESS

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    WCHAR       MachineAccountName[MAX_COMPUTERNAME_LENGTH+2]; // +2 for NULL and $
    ULONG       ComputerNameLength = ARRAY_COUNT(MachineAccountName);
    RPC_UNICODE_STRING            AccountName;

    //
    // Resources to be cleaned up
    //
    SAMPR_HANDLE              UserHandle = 0;
    PUSER_CONTROL_INFORMATION UserControlInfo = NULL;
    SAMPR_ULONG_ARRAY         Rids;
    SAMPR_ULONG_ARRAY         UseRid;

    //
    // Init resources
    //
    RtlZeroMemory(&Rids, sizeof(Rids));
    RtlZeroMemory(&UseRid, sizeof(UseRid));

    if ( !SampUseDsData )
    {
        //
        // Protect against wierd configurations
        //
        return STATUS_SUCCESS;

    }


    //
    //
    //
    //
    // Get the Machine Account Name
    //

    if (!GetComputerNameW(MachineAccountName, &ComputerNameLength)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: GetComputerName failed with %d\n",
                   GetLastError()));

        NtStatus = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    wcscat(MachineAccountName, L"$");
    AccountName.Length = wcslen(MachineAccountName) * sizeof(WCHAR); // don't include the NULL
    AccountName.MaximumLength = AccountName.Length + sizeof(WCHAR);  // include the NULL
    AccountName.Buffer = MachineAccountName;


    //
    // See if the machine account exists
    //

    NtStatus =  SamrLookupNamesInDomain(DomainHandle,
                                        1,
                                        &AccountName,
                                        &Rids,
                                        &UseRid);

    if (NtStatus == STATUS_SUCCESS) {

        //
        // The account exists, open a handle to it, so we can set its
        // password
        //

        ASSERT(TRUE == UseRid.Element[0]);
        NtStatus = SamrOpenUser(DomainHandle,
                                GENERIC_ALL,
                                Rids.Element[0],
                                &UserHandle);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrOpenUser failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }
    } else {

        //
        // Log this event since it prevents start up
        //
        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,     // no category
                          SAMMSG_MACHINE_ACCOUNT_MISSING,
                          NULL,  // no sid
                          0,
                          sizeof(DWORD),
                          NULL,
                          (PVOID)(&NtStatus));


        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrLookupNamesInDomain failed with 0x%x\n",
                   NtStatus));

        //
        // Don't let this fail the boot
        //
        NtStatus = STATUS_SUCCESS;

        goto Cleanup;

    }

    //
    // Set the Link to the our MSFT DSA Object
    //

    NtStatus = SampSetNtDsaLink(
                    ((PSAMP_OBJECT)(UserHandle))->ObjectNameInDs
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetNtDsaLink failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

Cleanup:

    if (UserHandle) {
        SamrCloseHandle(&UserHandle);
    }

    if (Rids.Element) {
         MIDL_user_free(Rids.Element);
    }

    if (UseRid.Element) {
        MIDL_user_free(UseRid.Element);
    }

    return NtStatus;
}

NTSTATUS
SampCreateFirstMachineAccount(
    SAMPR_HANDLE DomainHandle
    )
/*++

Routine Description:

    This routine creates a machine object for the first DC in a domain.
    The password is initially set to the name of the account, which is
    <ComputerName>$

Parameters:

    DomainHandle:  this is a valid handle to the account domain object

Return Values:

    STATUS_SUCCESS if success; appropriate NTSTATUS otherwise

--*/
{
    NTSTATUS                      NtStatus = STATUS_SUCCESS;
    RPC_UNICODE_STRING            AccountName;
    ULONG                         AccessGranted;
    ULONG                         Rid = 0;
    USER_SET_PASSWORD_INFORMATION UserPasswordInfo;
    WCHAR                         MachineAccountName[MAX_COMPUTERNAME_LENGTH+2];
                                  // +2 for NULL and $
    ULONG                         ComputerNameLength = ARRAY_COUNT(MachineAccountName);
    WCHAR                         Password[SAMP_RANDOM_GENERATED_PASSWORD_LENGTH +1];
    BOOLEAN                       fStatus;
    ULONG                         Length, i;


    //
    // Resources to be cleaned up
    //
    SAMPR_HANDLE              UserHandle = 0;
    PUSER_CONTROL_INFORMATION UserControlInfo = NULL;
    SAMPR_ULONG_ARRAY         Rids;
    SAMPR_ULONG_ARRAY         UseRid;

    //
    // Parameter checking
    //
    ASSERT(DomainHandle);

    //
    // Stack clearing
    //
    RtlZeroMemory(&UserPasswordInfo, sizeof(UserPasswordInfo));
    RtlZeroMemory(MachineAccountName, sizeof(MachineAccountName));
    RtlZeroMemory(Password, sizeof(Password));
    RtlZeroMemory(&Rids, sizeof(Rids));
    RtlZeroMemory(&UseRid, sizeof(UseRid));


    //
    // Build the account name.
    //
    if (!GetComputerNameW(MachineAccountName, &ComputerNameLength)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: GetComputerName failed with %d\n",
                   GetLastError()));

        NtStatus = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
    wcscat(MachineAccountName, L"$");

    //
    // Build a random password
    //
    SampGenerateRandomPassword( Password,
                                ARRAY_COUNT( Password ) );


    //
    // RPC_UNICODE_STRING's are a bit different than UNICODE_STRING's;
    // RPC_UNICODE_STRING count the number of bytes
    //
    AccountName.Length = wcslen(MachineAccountName) * sizeof(WCHAR); // don't include the NULL
    AccountName.MaximumLength = AccountName.Length + sizeof(WCHAR);  // include the NULL
    AccountName.Buffer = MachineAccountName;

    //
    // Sanity check - if this assert is not true, then kerberos will
    // no longer work since it initially depends on the password
    // of the machine account to be the name of the computer
    //
    ASSERT(SAM_MAX_PASSWORD_LENGTH > MAX_COMPUTERNAME_LENGTH);

    //
    // See if the machine account already exists
    //
    NtStatus =  SamrLookupNamesInDomain(DomainHandle,
                                        1,
                                        &AccountName,
                                        &Rids,
                                        &UseRid);

    if (NtStatus == STATUS_NONE_MAPPED) {

        ULONG DomainIndex;
        ULONG GrantedAccess;

        //
        // The account does not exist, create it
        //


        //
        // 1. Allocate a RID for the account ( remember that the
        //    Rid manager is not yet initialized
        //
        DomainIndex = ((PSAMP_OBJECT)DomainHandle)->DomainIndex;
        Rid = SampDefinedDomains[DomainIndex].CurrentFixed.NextRid++;

        //
        // 2. Create the user with the right Rid.
        //
        NtStatus = SampCreateUserInDomain(DomainHandle,
                                  (RPC_UNICODE_STRING *)&AccountName,
                                  USER_SERVER_TRUST_ACCOUNT,
                                  GENERIC_ALL,
                                  FALSE,       //writelock held
                                  FALSE,       //not loopback client
                                  &UserHandle,
                                  &GrantedAccess,
                                  &Rid);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrCreateUser2InDomain failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }

    } else if (NtStatus == STATUS_SUCCESS) {
        //
        // The account exists, open a handle to it, so we can set its
        // password
        //
        ASSERT(TRUE == UseRid.Element[0]);
        NtStatus = SamrOpenUser(DomainHandle,
                                GENERIC_ALL,
                                Rids.Element[0],
                                &UserHandle);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrOpenUser failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }
        Rid = Rids.Element[0];
    } else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrLookupNamesInDomain failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;

    }
    ASSERT(UserHandle);
    ASSERT( 0 != Rid );

    //
    // Set the appropriate control control fields
    //
    NtStatus = SamrQueryInformationUser2(UserHandle,
                                         UserControlInformation,
                                         (PSAMPR_USER_INFO_BUFFER*)&UserControlInfo);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrQueryInformationUser2 failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    UserControlInfo->UserAccountControl &= ~USER_PASSWORD_NOT_REQUIRED;
    UserControlInfo->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
    UserControlInfo->UserAccountControl &= ~USER_ACCOUNT_TYPE_MASK;
    UserControlInfo->UserAccountControl |=  USER_SERVER_TRUST_ACCOUNT;
    UserControlInfo->UserAccountControl |=  USER_TRUSTED_FOR_DELEGATION;

    NtStatus = SamrSetInformationUser(UserHandle,
                                      UserControlInformation,
                                      (PSAMPR_USER_INFO_BUFFER)UserControlInfo);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrSetInformationUser failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Set the password
    //
    NtStatus = SampSetPassword(UserHandle,
                               (PUNICODE_STRING) &AccountName,
                               Rid,
                               Password);

    if(!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetPassword failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    NtStatus  = SampSetMachineAccountSecret( Password );
    if(!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetMachineAccountSecret failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Set the Link to the our server Object
    //

    NtStatus = SampSetNtDsaLink(
                    ((PSAMP_OBJECT)(UserHandle))->ObjectNameInDs
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetNtDsaLink failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }


    //
    // That's it; fall through to cleanup
    //

Cleanup:

    if (UserHandle) {
        SamrCloseHandle(&UserHandle);
    }

    if (UserControlInfo) {
        SamIFree_SAMPR_USER_INFO_BUFFER((PSAMPR_USER_INFO_BUFFER)UserControlInfo,
                                        UserControlInformation);
    }

    if (Rids.Element) {
         MIDL_user_free(Rids.Element);
    }

    if (UseRid.Element) {
        MIDL_user_free(UseRid.Element);
    }

    return NtStatus;
}



struct DS_WELL_KNOWN_ACCOUNT_TABLE
{
    ULONG   LocalizedName;
    ULONG   LocalizedComment;
    WCHAR * Password;
    ULONG   Rid;
    SAMP_OBJECT_TYPE ObjectType;
    SAM_ACCOUNT_TYPE AccountType;
    NTSTATUS NotFoundStatus;
    BOOLEAN  fBuiltinAccount;
    BOOLEAN  fEnterpriseOnly;
    BOOLEAN  fOnDC;
    BOOLEAN  fOnProfessional;
    BOOLEAN  fOnServer;
    BOOLEAN  fOnPersonal;
    BOOLEAN  fNewForNt5;    // The account did not exist on NT 3.x - 4.x
                            // versions of Windows NT
}  DsWellKnownAccounts[] =

{
    {
        SAMP_USER_NAME_ADMIN,
        SAMP_USER_COMMENT_ADMIN,
        NULL, // note -- this will cause a random password to be generated
        DOMAIN_USER_RID_ADMIN,
        SampUserObjectType,
        SamObjectUser,
        STATUS_NO_SUCH_USER,
        FALSE, // builitn account
        FALSE, // enterprise only
        TRUE,  // fOnDC
        TRUE,  // fOnProfessional
        TRUE,  // fOnServer
        FALSE, // fOnPersonal
        FALSE  // fNewForNT5
    },
    {
        SAMP_USER_NAME_GUEST,
        SAMP_USER_COMMENT_GUEST,
        L"", // blank password
        DOMAIN_USER_RID_GUEST,
        SampUserObjectType,
        SamObjectUser,
        STATUS_NO_SUCH_USER,
        FALSE, // builtin
        FALSE, // enterprise only
        FALSE, // fOnDC
        TRUE,  // fOnProfessional
        TRUE,  // fOnServer
        FALSE, // fOnPersonal
        FALSE  // fNewForNT5
    },
    {
        SAMP_USER_NAME_KRBTGT,
        SAMP_USER_COMMENT_KRBTGT,
        NULL, // note -- this will cause a random password to be generated
        DOMAIN_USER_RID_KRBTGT,
        SampUserObjectType,
        SamObjectUser,
        STATUS_NO_SUCH_USER,
        FALSE, // builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5

    },
    {
        SAMP_GROUP_NAME_COMPUTERS,
        SAMP_GROUP_COMMENT_COMPUTERS,
        NULL,
        DOMAIN_GROUP_RID_COMPUTERS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_CONTROLLERS,
        SAMP_GROUP_COMMENT_CONTROLLERS,
        NULL,
        DOMAIN_GROUP_RID_CONTROLLERS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_SCHEMA_ADMINS,
        SAMP_GROUP_COMMENT_SCHEMA_ADMINS,
        NULL,
        DOMAIN_GROUP_RID_SCHEMA_ADMINS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        TRUE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_ENTERPRISE_ADMINS,
        SAMP_GROUP_COMMENT_ENTERPRISE_ADMINS,
        NULL,
        DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        TRUE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_CERT_ADMINS,
        SAMP_GROUP_COMMENT_CERT_ADMINS,
        NULL,
        DOMAIN_GROUP_RID_CERT_ADMINS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_ADMINS,
        SAMP_GROUP_COMMENT_ADMINS,
        NULL,
        DOMAIN_GROUP_RID_ADMINS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE, // builtin 
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        FALSE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_USERS,
        SAMP_GROUP_COMMENT_USERS,
        NULL,
        DOMAIN_GROUP_RID_USERS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        FALSE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_GUESTS,
        SAMP_GROUP_COMMENT_GUESTS,
        NULL,
        DOMAIN_GROUP_RID_GUESTS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        FALSE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_POLICY_ADMINS,
        SAMP_GROUP_COMMENT_POLICY_ADMINS,
        NULL,
        DOMAIN_GROUP_RID_POLICY_ADMINS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_RAS_SERVERS,
        SAMP_ALIAS_COMMENT_RAS_SERVERS,
        NULL,
        DOMAIN_ALIAS_RID_RAS_SERVERS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_SERVER_OPS,
        SAMP_ALIAS_COMMENT_SERVER_OPS,
        NULL,
        DOMAIN_ALIAS_RID_SYSTEM_OPS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        FALSE,// fOnProfessional,
        FALSE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_ACCOUNT_OPS,
        SAMP_ALIAS_COMMENT_ACCOUNT_OPS,
        NULL,
        DOMAIN_ALIAS_RID_ACCOUNT_OPS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        FALSE,// fOnProfessional,
        FALSE,// fOnServer,
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_PRINT_OPS,
        SAMP_ALIAS_COMMENT_PRINT_OPS,
        NULL,
        DOMAIN_ALIAS_RID_PRINT_OPS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        FALSE,// fOnProfessional,
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_ADMINS,
        SAMP_ALIAS_COMMENT_ADMINS,
        NULL,
        DOMAIN_ALIAS_RID_ADMINS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_USERS,
        SAMP_ALIAS_COMMENT_USERS,
        NULL,
        DOMAIN_ALIAS_RID_USERS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_GUESTS,
        SAMP_ALIAS_COMMENT_GUESTS,
        NULL,
        DOMAIN_ALIAS_RID_GUESTS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_BACKUP_OPS,
        SAMP_ALIAS_COMMENT_BACKUP_OPS,
        NULL,
        DOMAIN_ALIAS_RID_BACKUP_OPS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_REPLICATOR,
        SAMP_ALIAS_COMMENT_REPLICATOR,
        NULL,
        DOMAIN_ALIAS_RID_REPLICATOR,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        FALSE,// fOnProfessional,
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_PREW2KCOMPACCESS,
        SAMP_ALIAS_COMMENT_PREW2KCOMPACCESS,
        NULL,
        DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        FALSE,// fOnProfessional,
        FALSE,// fOnServer,
        FALSE,// fOnPersonal,
        TRUE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_REMOTE_DESKTOP_USERS,
        SAMP_ALIAS_COMMENT_REMOTE_DESKTOP_USERS,
        NULL,
        DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        TRUE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_NETWORK_CONFIGURATION_OPS,
        SAMP_ALIAS_COMMENT_NETWORK_CONFIGURATION_OPS,
        NULL,
        DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        TRUE// fNewForNT5
    },
    {
     SAMP_ALIAS_NAME_POWER_USERS,
     SAMP_ALIAS_COMMENT_POWER_USERS,
     NULL,
     DOMAIN_ALIAS_RID_POWER_USERS,
     SampAliasObjectType,
     SamObjectAlias,
     STATUS_NO_SUCH_ALIAS,
     TRUE,  // builtin
     FALSE, // enterprise only,
     FALSE, // fOnDC
     TRUE,  // fOnProfessional
     TRUE, // fOnServer
     FALSE,  // fOnPersonal,
     FALSE  // fNewForNT5
 }

};

//
// Any Sid within builtin domain and account domain 
// are not considered as well known SID in this routine,
// because there is a real object in the backing store.
//
// For example  Builtin Domain itself, 
//              Administrators Alias, 
//              Domain Users Group are NOT well known here
// 
// Only those SIDs, which there is no real object to present 
// them, are considered Well Known in SAM.
//      
// For Example  Anonymous Logon SID
//              Dialup SID
//              Network Service SID are well known SIDs. 
// 

struct DS_WELL_KNOWN_MEMBERSHIP_TABLE
{
    ULONG            AccountName;
    ULONG            AccountRid;
    SAMP_OBJECT_TYPE AccountType;
    BOOLEAN          fBuiltinAccount;

    ULONG            GroupName;
    ULONG            GroupRid;       // This could be an "alias", too
    SAMP_OBJECT_TYPE GroupType;
    BOOLEAN          fBuiltinGroup;

    BOOLEAN          fEnterpriseOnly;

    BOOLEAN          fNewForNt5;    // The account did not exist on NT 3.x - 4.x
                                    // versions of Windows NT

    BOOLEAN          fWellKnownSid;
    PSID             *WellKnownAccountSid;

}  DsWellKnownMemberships[] =
{
    {
      SAMP_GROUP_NAME_ADMINS,
      DOMAIN_GROUP_RID_ADMINS,
      SampGroupObjectType,
      FALSE,
      SAMP_ALIAS_NAME_ADMINS,
      DOMAIN_ALIAS_RID_ADMINS,
      SampAliasObjectType,
      TRUE,
      FALSE,
      FALSE,
      FALSE,
      NULL
    },
    {
      SAMP_GROUP_NAME_USERS,
      DOMAIN_GROUP_RID_USERS,
      SampGroupObjectType,
      FALSE,
      SAMP_ALIAS_NAME_USERS,
      DOMAIN_ALIAS_RID_USERS,
      SampAliasObjectType,
      TRUE,
      FALSE,
      FALSE,
      FALSE,
      NULL
    },
    {
      SAMP_GROUP_NAME_GUESTS,
      DOMAIN_GROUP_RID_GUESTS,
      SampGroupObjectType,
      FALSE,
      SAMP_ALIAS_NAME_GUESTS,
      DOMAIN_ALIAS_RID_GUESTS,
      SampAliasObjectType,
      TRUE,
      FALSE,
      FALSE,
      FALSE,
      NULL
    },
    {
      SAMP_USER_NAME_ADMIN,
      DOMAIN_USER_RID_ADMIN,
      SampUserObjectType,
      FALSE,
      SAMP_GROUP_NAME_ADMINS,
      DOMAIN_GROUP_RID_ADMINS,
      SampGroupObjectType,
      FALSE,
      FALSE,
      FALSE,
      FALSE,
      NULL
    },
    {
      SAMP_USER_NAME_GUEST,
      DOMAIN_USER_RID_GUEST,
      SampUserObjectType,
      FALSE,
      SAMP_GROUP_NAME_GUESTS,
      DOMAIN_GROUP_RID_GUESTS,
      SampGroupObjectType,
      FALSE,
      FALSE,
      FALSE,
      FALSE,
      NULL
    },
    {
      SAMP_USER_NAME_ADMIN,
      DOMAIN_USER_RID_ADMIN,
      SampUserObjectType,
      FALSE,
      SAMP_GROUP_NAME_SCHEMA_ADMINS,
      DOMAIN_GROUP_RID_SCHEMA_ADMINS,
      SampGroupObjectType,
      FALSE,
      TRUE,
      TRUE,
      FALSE,
      NULL
    },
    {
      SAMP_USER_NAME_ADMIN,
      DOMAIN_USER_RID_ADMIN,
      SampUserObjectType,
      FALSE,
      SAMP_GROUP_NAME_ENTERPRISE_ADMINS,
      DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
      SampGroupObjectType,
      FALSE,
      TRUE,
      TRUE,
      FALSE,
      NULL
    },
    {
      SAMP_USER_NAME_ADMIN,
      DOMAIN_USER_RID_ADMIN,
      SampUserObjectType,
      FALSE,
      SAMP_GROUP_NAME_POLICY_ADMINS,
      DOMAIN_GROUP_RID_POLICY_ADMINS,
      SampGroupObjectType,
      FALSE,
      FALSE,
      TRUE,
      FALSE,
      NULL
    },
    {
      SAMP_WELL_KNOWN_ALIAS_EVERYONE,
      0,                      // ignored
      SampAliasObjectType,    // ignored
      FALSE,                  // ignored
      SAMP_ALIAS_NAME_PREW2KCOMPACCESS,
      DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,
      SampAliasObjectType,
      TRUE,  // builtin group
      FALSE, // not just enterprise install
      TRUE,  // it is new for nt5
      TRUE,  // Well Known Account
      &SampWorldSid
    },
    {
      SAMP_WELL_KNOWN_ALIAS_ANONYMOUS_LOGON,
      0,                      // ignored
      SampAliasObjectType,    // ignored
      FALSE,                  // ignored
      SAMP_ALIAS_NAME_PREW2KCOMPACCESS,
      DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,
      SampAliasObjectType,
      TRUE,  // builtin group
      FALSE, // not just enterprise install
      TRUE,  // it is new for nt5
      TRUE,  // Well Known Account
      &SampAnonymousSid
    }
};




NTSTATUS
SampSetWellKnownAccountProperties(
    SAMPR_HANDLE AccountHandle,
    UNICODE_STRING Comment,
    PUNICODE_STRING Name,
    WCHAR * Password,
    ULONG Index
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    USER_SET_PASSWORD_INFORMATION UserPasswordInfo;
    PUSER_CONTROL_INFORMATION     UserControlInfo = NULL;

    if (SampUserObjectType==DsWellKnownAccounts[Index].ObjectType)
    {
        //
        // Set the appropriate  control fields
        //

        NtStatus = SamrQueryInformationUser2(AccountHandle,
                                             UserControlInformation,
                                             (PSAMPR_USER_INFO_BUFFER*)&UserControlInfo);
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrQueryInformationUser2 failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }


        if ( (DsWellKnownAccounts[Index].Rid == DOMAIN_USER_RID_GUEST) 
          || (DsWellKnownAccounts[Index].Rid == DOMAIN_USER_RID_ADMIN)  )
        {
            //
            // Admin and Guest accounts passwords shouldn't expire
            //
            UserControlInfo->UserAccountControl |= USER_DONT_EXPIRE_PASSWORD;
        }

        if ( DsWellKnownAccounts[Index].Rid != DOMAIN_USER_RID_GUEST)
        {
            //
            // Guests don't need passwords
            //
            UserControlInfo->UserAccountControl &= ~USER_PASSWORD_NOT_REQUIRED;
        }


        if (DsWellKnownAccounts[Index].Rid == DOMAIN_USER_RID_ADMIN)
        {
            //
            // Admin account should not be disabled
            //
            UserControlInfo->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
        }

        //
        // Make sure the account is normal
        //
        UserControlInfo->UserAccountControl &= ~USER_ACCOUNT_TYPE_MASK;
        UserControlInfo->UserAccountControl |= USER_NORMAL_ACCOUNT;

        NtStatus = SamrSetInformationUser(AccountHandle,
                                          UserControlInformation,
                                          (PSAMPR_USER_INFO_BUFFER)UserControlInfo);
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL, "SAMSS: SamrSetInformationUser failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }

        //
        // Set the password
        //

        NtStatus = SampSetPassword(AccountHandle,
                                   Name,
                                   DsWellKnownAccounts[Index].Rid,
                                   Password);

        if(!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampSetPassword failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }

        //
        // Set the Comment String
        //

        NtStatus = SamrSetInformationUser(AccountHandle,
                                          UserAdminCommentInformation,
                                          (PSAMPR_USER_INFO_BUFFER)&Comment);

        if(!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrSetInformationUser (admin comment) failed with 0x%x\n",
                       NtStatus));

            // This is not fatal
            NtStatus = STATUS_SUCCESS;
        }
    }
    else if (SampGroupObjectType==DsWellKnownAccounts[Index].ObjectType)
    {
        NtStatus = SamrSetInformationGroup(AccountHandle,
                                          GroupAdminCommentInformation,
                                          (PSAMPR_GROUP_INFO_BUFFER)&Comment);

        if(!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrSetInformationUser (admin comment) failed with 0x%x\n",
                       NtStatus));

            // This is not fatal
            NtStatus = STATUS_SUCCESS;
        }
    }
    else if (SampAliasObjectType==DsWellKnownAccounts[Index].ObjectType)
    {
        NtStatus = SamrSetInformationAlias(AccountHandle,
                                          AliasAdminCommentInformation,
                                          (PSAMPR_ALIAS_INFO_BUFFER)&Comment);

        if(!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrSetInformationUser (admin comment) failed with 0x%x\n",
                       NtStatus));

            // This is not fatal
            NtStatus = STATUS_SUCCESS;
        }
    }


Cleanup:

    if (UserControlInfo) {
        SamIFree_SAMPR_USER_INFO_BUFFER((PSAMPR_USER_INFO_BUFFER)UserControlInfo,
                                        UserControlInformation);
    }

    return NtStatus;

}

NTSTATUS
SampAddWellKnownAccounts(
    IN SAMPR_HANDLE AccountDomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN ULONG        Flags
    )
/*++

Routine Description


    This routine creates the set of default NT security principals for a 
    domain.  Should an account exist with the same name as the default name 
    of a default account, the default account name will be changed to a unique
    value until creation succeeds.  For example, Administrator will become
    Administrator~0.  Again, note that the existing customer name wins.
    
    The only exception is the KRBTGT account.  This well known account must
    be named exactly KRBTGT for compatibility reasons.  This account should
    have already been renamed by this point in the process (ie in SamIPromote).

Parameters

    AccountDomainHandle, a valid SAM domain handle

    BuiltinDomainHandle, a valid SAM domain handle

Return Values

    STATUS_SUCCESS; a status from a SAM api call

--*/
{
    NTSTATUS                      NtStatus = STATUS_SUCCESS;
    UNICODE_STRING                Name;
    UNICODE_STRING                Comment;
    ULONG                         AccessGranted;
    ULONG                         ConflictingRid;

    WCHAR                         *Password;
    HMODULE                       AccountNamesResource;

    SAMPR_HANDLE                  DomainHandle = 0;

    //
    // Resources to be cleaned up
    //

    SAMPR_HANDLE                  AccountHandle = 0;

    SAMPR_ULONG_ARRAY             Rids;
    SAMPR_ULONG_ARRAY             UseRids;
    ULONG                         i;
    OSVERSIONINFOEXW osvi;
    BOOL fPersonalSKU = FALSE;

    SAMTRACE("CreateBuiltinDomain");


    


    //
    // Parameter checking
    //
    ASSERT(AccountDomainHandle);
    ASSERT(BuiltinDomainHandle);

    //
    // Determine if we are installing Personal SKU
    //

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionEx((OSVERSIONINFOW*)&osvi);

    fPersonalSKU = ( ( osvi.wProductType == VER_NT_WORKSTATION )
                                    && (osvi.wSuiteMask & VER_SUITE_PERSONAL));


    //
    // Get the message resource we need to get the account names from
    //

    AccountNamesResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );
    if (AccountNamesResource == NULL) {

        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    }


    for (i=0;i<ARRAY_COUNT(DsWellKnownAccounts);i++)
    {
        BOOLEAN fSetAttributes = TRUE;


        //
        // Stack clearing
        //
        RtlZeroMemory(&Rids, sizeof(Rids));
        RtlZeroMemory(&UseRids, sizeof(UseRids));


        if (  DsWellKnownAccounts[i].fEnterpriseOnly
           && !FLAG_ON( Flags, SAMP_PROMOTE_ENTERPRISE ) )
        {
            //
            // The account exists only in the root domain,
            // and this is not the root domain creation case, so continue
            //
            continue;
        }


        if  ((( DsWellKnownAccounts[i].fOnDC ) && (SampUseDsData)) ||
                // Create on a DC and the machine is a DC
            ( DsWellKnownAccounts[i].fOnServer && (SampProductType==NtProductLanManNt) &&
                    (!SampUseDsData) && (!SampIsDownlevelDcUpgrade())) ||
                // case of upgrading the safeboot hive when booting to regular DS mode
            ( DsWellKnownAccounts[i].fOnProfessional
                && ((SampProductType==NtProductWinNt) && !fPersonalSKU )) ||
                // Create on a workstation and the machine is a workstation
            ( DsWellKnownAccounts[i].fOnServer && (SampProductType==NtProductServer)) ||
                // Create on a server and the machine is a server
            ( DsWellKnownAccounts[i].fOnPersonal && fPersonalSKU ) )
                // Create on a personal and the machine is a personal flavor
        {
            //
            // Continue the loop and proceed on creating the account
            //
        }
        else
        {
            //
            // Go to the end of the loop and proceed with the next account
            //

            continue;
        }

        AccountHandle = NULL;
        RtlZeroMemory(&Name,sizeof(UNICODE_STRING));
        RtlZeroMemory(&Comment,sizeof(UNICODE_STRING));

        if ( DsWellKnownAccounts[i].fBuiltinAccount )
        {
            DomainHandle = BuiltinDomainHandle;
        }
        else
        {
            DomainHandle = AccountDomainHandle;
        }

        //
        // Build the account name and the comment.  This will also be the initial
        // password. The password requirement is for kerberos.
        //

        NtStatus = SampGetMessageStrings(
                     AccountNamesResource,
                     DsWellKnownAccounts[i].LocalizedName,
                     &Name,
                     DsWellKnownAccounts[i].LocalizedComment,
                     &Comment
                     );
        if (!NT_SUCCESS(NtStatus))
        {
            goto IterationCleanup;
        }


        Password = DsWellKnownAccounts[i].Password;

        //
        // See if an account with the rid already exists
        //

        NtStatus = SampOpenAccount(
                                DsWellKnownAccounts[i].ObjectType,
                                DomainHandle,
                                GENERIC_ALL,
                                DsWellKnownAccounts[i].Rid,
                                FALSE,
                                &AccountHandle
                                );

        if (DsWellKnownAccounts[i].NotFoundStatus == NtStatus)
        {
            ULONG RenameIndex = 0;
            UNICODE_STRING OriginalName;

            RtlCopyMemory( &OriginalName, &Name, sizeof(UNICODE_STRING));

            //
            // The account does not exist. Now check the name
            // is not in use
            //
            NtStatus =  SamrLookupNamesInDomain(AccountDomainHandle,
                                                1,
                                                (RPC_UNICODE_STRING *)&Name,
                                                &Rids,
                                                &UseRids);

            if (STATUS_NONE_MAPPED==NtStatus)
            {
                 
                 NtStatus =  SamrLookupNamesInDomain(BuiltinDomainHandle,
                                                1,
                                                (RPC_UNICODE_STRING *)&Name,
                                                &Rids,
                                                &UseRids);
            }


            while ( NT_SUCCESS( NtStatus ) 
                && (DsWellKnownAccounts[i].Rid != DOMAIN_USER_RID_KRBTGT) ) {
                // the krbtgt account cannot be renamed

                //
                // The default name exists -- find a unique one
                //

                WCHAR NewAccountName[UNLEN+1];
                ULONG SuffixIndex;
                WCHAR RenameIndexString[11];  // space to hold 32 bit number
                WCHAR Suffix[12];  // ~<32 bit number>
                ULONG Size;
                ULONG SuffixLength;

                if (Rids.Element) {
                    MIDL_user_free(Rids.Element);
                    Rids.Element = NULL;
                }
        
                if (UseRids.Element) {
                    MIDL_user_free(UseRids.Element);
                    UseRids.Element= NULL;
                }

                // Get the base ready
                RtlZeroMemory( NewAccountName, sizeof(NewAccountName));
                wcsncpy(NewAccountName, 
                        OriginalName.Buffer, 
                        min(SAMP_MAX_DOWN_LEVEL_NAME_LENGTH, OriginalName.Length/sizeof(WCHAR)));


                // Prepare the unique suffix
                RtlZeroMemory(Suffix, sizeof(Suffix));
                Suffix[0] = L'~';
                _itow(RenameIndex, RenameIndexString, 10);
                wcscat( Suffix, RenameIndexString );

                // Add the suffix to the base
                SuffixIndex = wcslen( NewAccountName );
                SuffixLength = wcslen( Suffix );
                if ( SuffixIndex + SuffixLength > SAMP_MAX_DOWN_LEVEL_NAME_LENGTH ) {
                    SuffixIndex = SAMP_MAX_DOWN_LEVEL_NAME_LENGTH - SuffixLength;
                }
                NewAccountName[SuffixIndex] = L'\0';
                wcscat( NewAccountName, Suffix );

                if ( Name.Buffer != OriginalName.Buffer ) {
                    LocalFree( Name.Buffer );
                }
                Size = (wcslen( NewAccountName ) + 1) * sizeof(WCHAR);
                Name.Buffer = LocalAlloc( 0, Size);
                if ( Name.Buffer ) {
                    wcscpy( Name.Buffer, NewAccountName );
                    RtlInitUnicodeString( &Name, Name.Buffer );

                    NtStatus =  SamrLookupNamesInDomain(AccountDomainHandle,
                                                1,
                                                (RPC_UNICODE_STRING *)&Name,
                                                &Rids,
                                                &UseRids);

                    if (STATUS_NONE_MAPPED==NtStatus)
                    {
                         

                         NtStatus =  SamrLookupNamesInDomain(BuiltinDomainHandle,
                                                        1,
                                                        (RPC_UNICODE_STRING *)&Name,
                                                        &Rids,
                                                        &UseRids);
                    }

                    
                } else {

                    NtStatus = STATUS_NO_MEMORY;
                }

                RenameIndex++;

            }

            if ( OriginalName.Buffer != Name.Buffer ) {
                LocalFree( OriginalName.Buffer );
                OriginalName.Buffer = NULL;
            }

            if (NtStatus == STATUS_NONE_MAPPED) {

                //
                // Good, no account with the rid or the account name
                // exists. Create the account
                //

                NtStatus = SamICreateAccountByRid(DomainHandle,
                                                  DsWellKnownAccounts[i].AccountType,
                                                  DsWellKnownAccounts[i].Rid,
                                                  (RPC_UNICODE_STRING *)&Name,
                                                  GENERIC_ALL,
                                                  &AccountHandle,
                                                  &ConflictingRid);
                if (!NT_SUCCESS(NtStatus)) {

                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SamICreateAccountByRid failed with 0x%x\n",
                               NtStatus));

                    goto IterationCleanup;

                }

                //
                // If this was an upgrade, the account didn't exist, and the 
                // account is not new for NT5, why that is strange.  
                // Log an event.
                //
                if (  FLAG_ON( Flags, SAMP_PROMOTE_UPGRADE )
                   && !DsWellKnownAccounts[i].fNewForNt5 ) {

                    PUNICODE_STRING EventString[1];
                    EventString[0] = (PUNICODE_STRING) &Name;

                    if ( SampUserObjectType==DsWellKnownAccounts[i].ObjectType ) {

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,     // no category
                                          SAMMSG_WELL_KNOWN_ACCOUNT_RECREATED,
                                          NULL,  // no sid
                                          1,
                                          sizeof(NTSTATUS),
                                          EventString,
                                          (PVOID)(&NtStatus));
                    } else {

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,     // no category
                                          SAMMSG_WELL_KNOWN_GROUP_RECREATED,
                                          NULL,  // no sid
                                          1,
                                          sizeof(NTSTATUS),
                                          EventString,
                                          (PVOID)(&NtStatus));
                    }
                }

            }
            else if ( NT_SUCCESS(NtStatus) )
            {

                //
                // Can be here only for the case of the krbtgt account
                //

                ASSERT(  DsWellKnownAccounts[i].Rid==DOMAIN_USER_RID_KRBTGT);

                NtStatus = STATUS_USER_EXISTS;

                goto IterationCleanup;

            }
            else
            {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SamrLookupNamesInDomain failed with 0x%x\n",
                           NtStatus));

                goto Cleanup;

            }


        }
        else if (NT_SUCCESS(NtStatus))
        {

            //
            // Account with the rid already exist.  Since this is a known rid,
            // only system services could have created it.  So, this must be
            // the given well known account
            // ( simply proceed )

            // Don't bother setting the attributes if the account aleady
            // existed, and this not a new account
            if ( !DsWellKnownAccounts[i].fNewForNt5
             ||  FLAG_ON( Flags, SAMP_PROMOTE_INTERNAL_UPGRADE )    )
            {
                fSetAttributes = FALSE;
            }


        } else
        {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrOpenUser failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }

        //
        // We should have an account Handle right Here
        //

        ASSERT(AccountHandle);

        if ( fSetAttributes )
        {
            //
            // 16 + 1 allows for 256 bits of randomness
            //
            WCHAR DummyPassword[SAMP_RANDOM_GENERATED_PASSWORD_LENGTH +1];

            if ( (NULL == Password)
              && (SampUserObjectType==DsWellKnownAccounts[i].ObjectType)   ) {

                //
                // Generate a random password for users if null
                //
                Password = DummyPassword;

                SampGenerateRandomPassword( DummyPassword,
                                            ARRAY_COUNT(DummyPassword) );

            }

            NtStatus = SampSetWellKnownAccountProperties(
                            AccountHandle,
                            Comment,
                            &Name,
                            Password,
                            i
                            );
        }

        if (!NT_SUCCESS(NtStatus))
        {
            goto IterationCleanup;
        }

IterationCleanup:

        if ( !NT_SUCCESS( NtStatus ) )
        {
            //
            // Log the error and then reset NtStatus to success
            //
            NTSTATUS IgnoreStatus = STATUS_SUCCESS;
            DWORD    WinError = ERROR_SUCCESS;
            DWORD    WinErrorToLog;
            UNICODE_STRING User, Error;
            PUNICODE_STRING EventStrings[2] = { &User, &Error };
            ULONG           Length;

            RtlZeroMemory( &User, sizeof( UNICODE_STRING ) );
            RtlZeroMemory( &Error, sizeof( UNICODE_STRING ) );

            IgnoreStatus = SampGetMessageStrings( AccountNamesResource,
                                                  DsWellKnownAccounts[i].LocalizedName,
                                                  &User,
                                                  0,
                                                  NULL );

            WinErrorToLog = RtlNtStatusToDosError( NtStatus );
            Length = FormatMessage( (FORMAT_MESSAGE_FROM_SYSTEM |
                                     FORMAT_MESSAGE_ALLOCATE_BUFFER),
                                     NULL, // no source
                                     WinErrorToLog,
                                     0, // let the system decide the language
                                     (LPWSTR)&Error.Buffer,
                                     0, // buffer is to be allocated
                                     NULL // no inserts
                                     );
            if ( Length > 0 ) {
                Error.MaximumLength = (USHORT) (Length + 1)* sizeof(WCHAR);
                Error.Length = (USHORT) Length * sizeof(WCHAR);
                Error.Buffer[Length-2] = L'\0';
            } else {
                WinError = GetLastError();
            }

            if (  (ERROR_SUCCESS == WinError)
                && NT_SUCCESS( IgnoreStatus ) )
            {
                ULONG Msg = SAMMSG_USER_SETUP_ERROR;

                SampWriteEventLog( EVENTLOG_INFORMATION_TYPE,
                                   0,    // no category
                                   Msg,
                                   NULL, // no sid
                                   sizeof(EventStrings)/sizeof(EventStrings[0]), // number of strings
                                   sizeof(DWORD), // size of data
                                   EventStrings,
                                   &WinErrorToLog
                                    );

            }

            if ( User.Buffer )
            {
                LocalFree( User.Buffer );
            }
            if ( Error.Buffer )
            {
                LocalFree( Error.Buffer );
            }

            // handled
            NtStatus = STATUS_SUCCESS;

        }

        if (AccountHandle) {
            SamrCloseHandle(&AccountHandle);
            AccountHandle = NULL;
        }

        if (Rids.Element) {
            MIDL_user_free(Rids.Element);
            Rids.Element = NULL;
        }

        if (UseRids.Element) {
            MIDL_user_free(UseRids.Element);
            UseRids.Element= NULL;
        }

        if ( Name.Buffer ) {
            LocalFree( Name.Buffer );
            Name.Buffer = NULL;
        }

        if ( Comment.Buffer ) {
            LocalFree( Comment.Buffer );
            Comment.Buffer = NULL;
        }

    }

    //
    // That's it; fall through to cleanup
    //

Cleanup:

    if (AccountHandle) {
        SamrCloseHandle(&AccountHandle);
    }

    if (Rids.Element) {
         MIDL_user_free(Rids.Element);
    }

    if (UseRids.Element) {
        MIDL_user_free(UseRids.Element);
    }

    if ( AccountNamesResource ) {
        FreeLibrary( AccountNamesResource );
    }

    ASSERT( NT_SUCCESS( NtStatus ) );

    return NtStatus;
}

NTSTATUS
SampCreateKeyForPostBootPromote(
    IN ULONG PromoteData
    )
/*++

Routine Description

    This routine creates a key used to record the fact that phase two
    of the promotion needs to happed on the next reboot.

Parameters

    PromoteData:  this value is stored in the key; it identifies whether this
                  is a promotion to first DC or a replica DC.

Return Values

    STATUS_SUCCESS; a system service error otherwise

--*/
{
    NTSTATUS          NtStatus, IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    PromoteKeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Create the value
        //
        RtlInitUnicodeString(&PromoteKeyName, L"PostPromoteBoot");
        NtStatus = NtSetValueKey(SamKeyHandle,
                                 &PromoteKeyName,
                                 0,               // Title name, optional
                                 REG_DWORD,
                                 &PromoteData,
                                 sizeof(DWORD));

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtSetValueKey failed with 0x%x\n",
                       NtStatus));
        }

        IgnoreStatus = NtFlushKey(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtFlushKey failed with 0x%x\n",
                       IgnoreStatus));
        }

        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));
        }

    }
    else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }


    return NtStatus;
}


NTSTATUS
SampRetrieveKeyForPostBootPromote(
    OUT PULONG PromoteData
    )
/*++

Routine Description:

    This routine


Parameters

    None.

Return Values


--*/
{

    NTSTATUS          NtStatus, IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    PromoteKeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    PKEY_VALUE_PARTIAL_INFORMATION   KeyPartialInfo;
    ULONG                            KeyPartialInfoSize = 0;

    ASSERT(PromoteData);

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Query the value
        //

        RtlInitUnicodeString(&PromoteKeyName, L"PostPromoteBoot");
        NtStatus = NtQueryValueKey(SamKeyHandle,
                                   &PromoteKeyName,
                                   KeyValuePartialInformation,
                                   NULL,
                                   0,
                                   &KeyPartialInfoSize);

        if (STATUS_BUFFER_TOO_SMALL == NtStatus) {
            //
            //  Allocate some space and then read the buffer
            //
            KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                             MIDL_user_allocate(KeyPartialInfoSize);

            if (KeyPartialInfo) {

                NtStatus = NtQueryValueKey(SamKeyHandle,
                                           &PromoteKeyName,
                                           KeyValuePartialInformation,
                                           KeyPartialInfo,
                                           KeyPartialInfoSize,
                                           &KeyPartialInfoSize);

                if (NT_SUCCESS(NtStatus)) {
                    //
                    // Analysis the value's data
                    //
                    if (KeyPartialInfo->DataLength == sizeof(DWORD)) {
                        *PromoteData = *(DWORD*)(KeyPartialInfo->Data);
                    } else {
                        SampDiagPrint( PROMOTE,
              ("SAMSS: Post boot promote key found with bogus value length\n"));

                        NtStatus = STATUS_UNSUCCESSFUL;
                    }

                } else {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: NtQueryValueKey failed with 0x%x\n",
                               NtStatus));
                }

                MIDL_user_free(KeyPartialInfo);

            } else {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Memory allocation failed\n"));

                NtStatus = STATUS_NO_MEMORY;

            }

        }  else if (STATUS_OBJECT_NAME_NOT_FOUND == NtStatus ||
                    STATUS_SUCCESS               == NtStatus ) {
            //
            // This is ok, too
            //
            ;

        } else {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtQueryValueKey failed with 0x%x\n",
                       NtStatus));
        }


        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));
        }

    }
    else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }

    return NtStatus;

}

NTSTATUS
SampDeleteKeyForPostBootPromote(
    VOID
    )
/*++

Routine Description


Parameters

    None.

Return Values


--*/
{
    NTSTATUS          NtStatus, NtStatus2, IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    KeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Delete the value
        //
        RtlInitUnicodeString(&KeyName, L"PostPromoteBoot");
        NtStatus = NtDeleteValueKey(SamKeyHandle,
                                    &KeyName);

        if (!NT_SUCCESS(NtStatus)) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtDeleteValueKey failed with 0x%x\n",
                       NtStatus));

        }

        RtlInitUnicodeString(&KeyName, SAMP_ADMIN_INFO_NAME);
        NtStatus2 = NtDeleteValueKey(SamKeyHandle,
                                    &KeyName);
        if (!NT_SUCCESS(NtStatus2)
         && NtStatus2 != STATUS_OBJECT_NAME_NOT_FOUND) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtDeleteValueKey failed with 0x%x\n",
                       NtStatus2));

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = NtStatus2;
            }
        }

        //
        // Make sure we don't run this code again
        //
        IgnoreStatus = NtFlushKey(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtFlushKey failed with 0x%x\n",
                       IgnoreStatus));
        }

        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));
        }

    }
    else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }

    return NtStatus;

}


NTSTATUS
SampSetPassword(
    IN SAMPR_HANDLE    UserHandle,
    IN PUNICODE_STRING AccountName,
    IN ULONG           AccountRid, OPTIONAL
    IN WCHAR          *Password
    )
/*++

Routine Description:

    This routines sets the clear text password, Password, on the user referred
    to by UserHandle.

Parameters:

    UserHandle : a valid handle to a user account

    AccountName : the account name of UserHandle; if specified, notification packages will be
                  called

    Rid:       : must be specified if AccountName is specified

    Password   : the password to set

Return Values:

    STATUS_SUCCESS; a system service error otherwise

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING              ClearNtPassword;

    ASSERT(UserHandle);
    ASSERT(Password);
    ASSERT(AccountName);


    RtlInitUnicodeString(&ClearNtPassword, Password);

    NtStatus = SamIChangePasswordForeignUser(
                    AccountName,
                    &ClearNtPassword,
                    NULL,// ClientToken,
                    0
                    );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamIChangePasswordForeignUser failed with 0x%x\n",
                   NtStatus));

        return NtStatus;
    }

    return NtStatus;
}

NTSTATUS
SampRegistryDelnode(
    IN WCHAR*  KeyPath
    )
/*++

Routine Description

    This routine recursively deletes the registry key starting at
    and including KeyPath.


Parameters

    KeyPath, null-terminating string

Return Values

    STATUS_SUCCESS or STATUS_NO_MEMORY; system service error otherwise

--*/
{

    NTSTATUS          NtStatus, IgnoreStatus;

    HANDLE            KeyHandle = 0;
    OBJECT_ATTRIBUTES KeyObject;
    UNICODE_STRING    KeyUnicodeName;

    #define EXPECTED_NAME_SIZE  32

    BYTE    Buffer1[sizeof(KEY_FULL_INFORMATION) + EXPECTED_NAME_SIZE];
    PKEY_FULL_INFORMATION FullKeyInfo = (PKEY_FULL_INFORMATION)&Buffer1[0];
    ULONG   FullKeyInfoSize = sizeof(Buffer1);
    BOOLEAN FullKeyInfoAllocated = FALSE;

    PKEY_BASIC_INFORMATION BasicKeyInfo = NULL;
    BOOLEAN                BasicKeyInfoAllocated = FALSE;

    WCHAR                  *SubKeyName = NULL;
    ULONG                  SubKeyNameSize = 0;

    WCHAR                  **SubKeyNameArray = NULL;
    ULONG                  SubKeyNameArrayLength = 0;

    ULONG                  Index;

    if (!KeyPath) {
        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory(&Buffer1, sizeof(Buffer1));

    //
    // Open the root key
    //
    RtlInitUnicodeString(&KeyUnicodeName, KeyPath);
    InitializeObjectAttributes(&KeyObject,
                               &KeyUnicodeName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&KeyHandle,
                         KEY_ALL_ACCESS,
                         &KeyObject);

    if (!NT_SUCCESS(NtStatus)) {

        return NtStatus;

    }

    //
    // Get the number of subkeys
    //
    NtStatus = NtQueryKey(KeyHandle,
                         KeyFullInformation,
                         FullKeyInfo,
                         FullKeyInfoSize,
                         &FullKeyInfoSize);

    if (STATUS_BUFFER_OVERFLOW == NtStatus ||
        STATUS_BUFFER_TOO_SMALL == NtStatus) {

       FullKeyInfo = MIDL_user_allocate( FullKeyInfoSize );
        if (!FullKeyInfo) {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        FullKeyInfoAllocated = TRUE;

        NtStatus = NtQueryKey(KeyHandle,
                              KeyFullInformation,
                              FullKeyInfo,
                              FullKeyInfoSize,
                              &FullKeyInfoSize);

    }

    if (!NT_SUCCESS(NtStatus)) {

        goto Cleanup;

    }

    //
    // Make an array for the sub key names - this has to be recorded before
    // any are deleted.
    //
    SubKeyNameArrayLength = FullKeyInfo->SubKeys;
    SubKeyNameArray = MIDL_user_allocate( SubKeyNameArrayLength * sizeof(WCHAR*));
    if (!SubKeyNameArray) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(SubKeyNameArray,  SubKeyNameArrayLength*sizeof(WCHAR*));

    //
    // Fill the names in
    //
    for (Index = 0;
            Index < SubKeyNameArrayLength && NT_SUCCESS(NtStatus);
                Index++) {


        BYTE    Buffer2[sizeof(KEY_BASIC_INFORMATION) + EXPECTED_NAME_SIZE];
        ULONG   BasicKeyInfoSize = sizeof(Buffer2);


        BasicKeyInfo = (PKEY_BASIC_INFORMATION) &Buffer2[0];
        BasicKeyInfoAllocated = FALSE;

        RtlZeroMemory(&Buffer2, sizeof(Buffer2));

        NtStatus = NtEnumerateKey(KeyHandle,
                                  Index,
                                  KeyBasicInformation,
                                  BasicKeyInfo,
                                  BasicKeyInfoSize,
                                  &BasicKeyInfoSize);

        if (STATUS_BUFFER_OVERFLOW == NtStatus ||
            STATUS_BUFFER_TOO_SMALL == NtStatus) {

            BasicKeyInfo = MIDL_user_allocate( BasicKeyInfoSize );
            if (!BasicKeyInfo) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            BasicKeyInfoAllocated = TRUE;


            NtStatus = NtEnumerateKey(KeyHandle,
                                      Index,
                                      KeyBasicInformation,
                                      BasicKeyInfo,
                                      BasicKeyInfoSize,
                                      &BasicKeyInfoSize);

        }

        if (NT_SUCCESS(NtStatus))  {

            //
            // Construct the key name
            //
            SubKeyNameSize  = BasicKeyInfo->NameLength
                            + (wcslen(KeyPath)*sizeof(WCHAR))
                            + sizeof(L"\\\0");

            SubKeyName = MIDL_user_allocate(SubKeyNameSize);
            if (!SubKeyName) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            RtlZeroMemory(SubKeyName, SubKeyNameSize);

            wcscpy(SubKeyName, KeyPath);
            wcscat(SubKeyName, L"\\");
            wcsncat(SubKeyName, BasicKeyInfo->Name, BasicKeyInfo->NameLength/sizeof(WCHAR));

            SubKeyNameArray[Index] = SubKeyName;

        }

        if (BasicKeyInfoAllocated && BasicKeyInfo) {
            MIDL_user_free(BasicKeyInfo);
        }
        BasicKeyInfo = NULL;

    }

    //
    // Now that we have a record of all the subkeys we can delete them!
    //
    if (NT_SUCCESS(NtStatus)) {

        for (Index = 0; Index < SubKeyNameArrayLength; Index++) {

            NtStatus = SampRegistryDelnode(SubKeyNameArray[Index]);

            if (!NT_SUCCESS(NtStatus)) {

                break;

            }
        }
    }


    //
    // Delete the key!
    //
    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtDeleteKey(KeyHandle);

    }


Cleanup:

    if (SubKeyNameArray) {
        for (Index = 0; Index < SubKeyNameArrayLength; Index++) {
            if (SubKeyNameArray[Index]) {
                MIDL_user_free(SubKeyNameArray[Index]);
            }
        }
        MIDL_user_free(SubKeyNameArray);
    }

    if (BasicKeyInfoAllocated && BasicKeyInfo) {
        MIDL_user_free(BasicKeyInfo);
    }

    if (FullKeyInfoAllocated && FullKeyInfo) {
        MIDL_user_free(FullKeyInfo);
    }

    IgnoreStatus = NtClose(KeyHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    return NtStatus;

}


NTSTATUS
SampRenameKrbtgtAccount(
    VOID
    )
/*++

Routine Description:

    This routine will check the local security database for any user, group,
    or alias named "krbtgt".  If one exists, the account will be renamed
    krbtgt~x, where x will start at 1 and be incremented until the rename
    succeeds.  Since this can only occur during gui mode setup, the user
    is notified via the setup api SetupLogError().

Parameters:

    None.

Return Values:

    STATUS_SUCCESS if no krbtgt was detected or if it was detected and was
    successfully renamed

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    DWORD    WinError;

    SAMPR_HANDLE ServerHandle = 0;
    SAMPR_HANDLE DomainHandle = 0;

    SAMPR_HANDLE KrbtgtAccountHandle = 0;
    SID_NAME_USE KrbtgtAccountType = SidTypeUser;

    PPOLICY_ACCOUNT_DOMAIN_INFO   DomainInfo = NULL;
    USER_ACCOUNT_NAME_INFORMATION UserInfo;
    GROUP_NAME_INFORMATION        GroupInfo;
    ALIAS_NAME_INFORMATION        AliasInfo;

    SAMPR_ULONG_ARRAY         Rids;
    SAMPR_ULONG_ARRAY         UseRid;
    BOOL                      AccountRenamed=FALSE;
    BOOL                      AccountShouldBeRenamed=FALSE;
    BOOL                      Status;

    #define        NEW_ACCOUNT_NAME_LENGTH  (7 + 1 + 10)
                                             // krbtgt plus a NULL
                                             // ~
                                             // a 32 bit number as a string

    WCHAR           NewAccountName[NEW_ACCOUNT_NAME_LENGTH];
    UNICODE_STRING  AccountName;

    ULONG          RenameIndex;
    WCHAR          RenameIndexString[10];

    WCHAR          *WarningString = NULL;

    RtlZeroMemory(&UserInfo, sizeof(UserInfo));
    RtlZeroMemory(&GroupInfo, sizeof(GroupInfo));
    RtlZeroMemory(&AliasInfo, sizeof(AliasInfo));
    RtlZeroMemory(&Rids, sizeof(Rids));
    RtlZeroMemory(&UseRid, sizeof(UseRid));

    //
    // Open the server
    //
    NtStatus = SamIConnect(NULL,           // server name, this is ignored
                           &ServerHandle,
                           GENERIC_ALL,    // all access
                           TRUE);          // trusted client

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamIConnect failed with 0x%x\n",
                   NtStatus));

        return NtStatus;
    }

    //
    // Get the current domain's sid
    //
    NtStatus = SampGetAccountDomainInfo(&DomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampGetAccountDomainInfo failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }
    ASSERT(DomainInfo);
    ASSERT(DomainInfo->DomainSid);

    //
    // Open the current domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              DomainInfo->DomainSid,
                              &DomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrOpenDomain failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }


    //
    // Try to open the existing krbtgt account
    //
    RtlInitUnicodeString(&AccountName, DOMAIN_KRBTGT_ACCOUNT_NAME_W);
    NtStatus =  SamrLookupNamesInDomain(DomainHandle,
                                        1,
                                        (RPC_UNICODE_STRING *)&AccountName,
                                        &Rids,
                                        &UseRid);

    if (NtStatus == STATUS_SUCCESS) {

        KrbtgtAccountType = UseRid.Element[0];


        if ((DOMAIN_USER_RID_KRBTGT == Rids.Element[0])
                && (SidTypeUser== KrbtgtAccountType))
        {

            //
            // If the account is a user account with the right rid, then
            // leave it as is
            //

            NtStatus = STATUS_SUCCESS;
            AccountShouldBeRenamed = FALSE;
        }
        else
        {
            //
            // Account exists and does not satisfy the above criterion.
            // Rename it.
            //

            AccountShouldBeRenamed = TRUE;


            switch (KrbtgtAccountType) {

                case SidTypeUser:

                    NtStatus = SamrOpenUser(DomainHandle,
                                            GENERIC_ALL,
                                            Rids.Element[0],
                                            &KrbtgtAccountHandle);

                    break;

                case SidTypeGroup:

                    NtStatus = SamrOpenGroup(DomainHandle,
                                             GENERIC_ALL,
                                             Rids.Element[0],
                                             &KrbtgtAccountHandle);
                    break;

                case SidTypeAlias:

                    NtStatus = SamrOpenAlias(DomainHandle,
                                             GENERIC_ALL,
                                             Rids.Element[0],
                                             &KrbtgtAccountHandle);

                    break;

                default:
                    ASSERT(FALSE);
                    NtStatus = STATUS_UNSUCCESSFUL;

            }
        }

    } else {

        //
        // Account does not exist
        //
        ASSERT(NtStatus == STATUS_NONE_MAPPED);
        if (NtStatus != STATUS_NONE_MAPPED) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Unexpected error from SamrLookupNamesInDomain\n"));
        }
        NtStatus = STATUS_SUCCESS;
        AccountShouldBeRenamed = FALSE;

    }

    RenameIndex = 0;
    AccountRenamed = FALSE;
    while (NT_SUCCESS(NtStatus) && AccountShouldBeRenamed && !AccountRenamed) {

        //
        // Try the next name candidate
        //
        RenameIndex++;
        _itow(RenameIndex, RenameIndexString, 10);

        RtlZeroMemory(NewAccountName, sizeof(NewAccountName));
        wcscpy(NewAccountName, DOMAIN_KRBTGT_ACCOUNT_NAME_W);
        wcscat(NewAccountName, L"~");
        wcscat(NewAccountName, RenameIndexString);

        switch (KrbtgtAccountType) {

            case SidTypeUser:

                RtlInitUnicodeString(&UserInfo.UserName, NewAccountName);

                NtStatus = SamrSetInformationUser(KrbtgtAccountHandle,
                                                  UserAccountNameInformation,
                                                  (PSAMPR_USER_INFO_BUFFER)&UserInfo);

                if (STATUS_USER_EXISTS == NtStatus  ||
                    STATUS_GROUP_EXISTS == NtStatus ||
                    STATUS_ALIAS_EXISTS == NtStatus) {
                    //
                    // Try again
                    //
                    NtStatus = STATUS_SUCCESS;
                } else if (NT_SUCCESS(NtStatus)) {
                    AccountRenamed = TRUE;
                }

                break;

            case SidTypeGroup:

                RtlInitUnicodeString(&GroupInfo.Name, NewAccountName);

                NtStatus = SamrSetInformationGroup(KrbtgtAccountHandle,
                                                  GroupNameInformation,
                                                  (PSAMPR_GROUP_INFO_BUFFER)&GroupInfo);


                if (STATUS_USER_EXISTS == NtStatus  ||
                    STATUS_GROUP_EXISTS == NtStatus ||
                    STATUS_ALIAS_EXISTS == NtStatus) {
                    //
                    // Try again
                    //
                    NtStatus = STATUS_SUCCESS;
                } else if (NT_SUCCESS(NtStatus)) {
                    AccountRenamed = TRUE;
                }

                break;

            case SidTypeAlias:

                RtlInitUnicodeString(&AliasInfo.Name, NewAccountName);
                NtStatus = SamrSetInformationAlias(KrbtgtAccountHandle,
                                                   AliasNameInformation,
                                                   (PSAMPR_ALIAS_INFO_BUFFER)&AliasInfo);


                if (STATUS_USER_EXISTS == NtStatus  ||
                    STATUS_GROUP_EXISTS == NtStatus ||
                    STATUS_ALIAS_EXISTS == NtStatus) {
                    //
                    // Try again
                    //
                    NtStatus = STATUS_SUCCESS;
                } else if (NT_SUCCESS(NtStatus)) {
                    AccountRenamed = TRUE;
                }

                break;

            default:
                ASSERT(FALSE);
                NtStatus = STATUS_UNSUCCESSFUL;

        }
    }


    if (AccountRenamed) {
        //
        // Write a message out to the setup log indicating that the
        // account was renamed
        //
        WarningString = SampGetKrbtgtRenameWarning(NewAccountName);
        if (WarningString) {
            if (SetupOpenLog(FALSE)) { // don't erase
                Status = SetupLogError(WarningString, LogSevWarning);
                ASSERT(Status);
                SetupCloseLog();
            }
            LocalFree(WarningString);
        }
    }

Cleanup:

    if (ServerHandle) {
        SamrCloseHandle(&ServerHandle);
    }

    if (DomainHandle) {
        SamrCloseHandle(&DomainHandle);
    }

    if (KrbtgtAccountHandle) {
        SamrCloseHandle(&KrbtgtAccountHandle);
    }

    if (DomainInfo) {
        LsaIFree_LSAPR_POLICY_INFORMATION (PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)DomainInfo);
    }

    if (Rids.Element) {
         MIDL_user_free(Rids.Element);
    }

    if (UseRid.Element) {
        MIDL_user_free(UseRid.Element);
    }

    return NtStatus;
}

WCHAR*
SampGetKrbtgtRenameWarning(
    WCHAR* NewName
    )
/*++

Routine Description:

    This routine queries the resource table in samsrv.dll to get the string
    to show the user if an existing krbtgt account existes.  If an error
    occurs trying to get the message, a default english string is used.

Parameters:

    NewName:  null terminated string used as an insert in the message

Return Values:

    The message string allocated from LocalAlloc; NULL if memory allocation
    failed.

--*/
{
    WCHAR   *InsertArray[2];
    HMODULE ResourceDll;
    WCHAR   *WarningString = NULL;
    ULONG   Length, Size;
    BOOL    Status;

    InsertArray[0] = NewName;
    InsertArray[1] = NULL; // this is the sentinel

    ResourceDll = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        SAMMSG_KRBTGT_RENAMED,
                                        0,       // Use caller's language
                                        (LPWSTR)&WarningString,
                                        0,       // routine should allocate
                                        (va_list*)&(InsertArray[0])
                                        );
        if (WarningString) {
            // Messages from a message file have a cr and lf appended
            // to the end
            WarningString[Length-2] = L'\0';
            Length -= 2;
        }

        Status = FreeLibrary(ResourceDll);
        ASSERT(Status);

    }

    if (!WarningString) {

        ASSERT(!"SAMSS: Resource allocation failed - this can be safely ignored");

        Size = (wcslen(SampDefaultKrbtgtWarningString)+
                wcslen(NewName)
                +1)*sizeof(WCHAR);
        WarningString = (WCHAR*)LocalAlloc(0, Size);
        if (WarningString) {

            RtlZeroMemory(WarningString, Size);
            swprintf(WarningString, SampDefaultKrbtgtWarningString, NewName);
        }

    }

    return WarningString;

}


WCHAR*
SampGetKrbtgtCommentString(
    VOID
    )
/*++

Routine Description:

    This routine queries the resource table in samsrv.dll to get the string
    for the krbtgt account admin comment.  If an error occurs trying to get the
    message, a default english string is used.

Parameters:

    None.

Return Values:

    The message string allocated from LocalAlloc; NULL if memory allocation
    failed.

--*/
{
    HMODULE ResourceDll;
    WCHAR   *CommentString=NULL;
    ULONG   Length, Size;
    BOOL    Status;

    ResourceDll = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        SAMP_USER_COMMENT_KRBTGT,
                                        0,       // Use caller's language
                                        (LPWSTR)&CommentString,
                                        0,       // routine should allocate
                                        NULL
                                        );
        if (CommentString) {
            // Messages from a message file have a cr and lf appended
            // to the end
            CommentString[Length-2] = L'\0';
            Length -= 2;
        }

        Status = FreeLibrary(ResourceDll);
        ASSERT(Status);

    }

    if (!CommentString) {

        ASSERT(!"SAMSS: Resource allocation failed - this can be safely ignored");

        Size = (wcslen(SampDefaultKrbtgtCommentString)+1)*sizeof(WCHAR);
        CommentString = (WCHAR*)LocalAlloc(0, Size);
        if (CommentString) {
            wcscpy(CommentString, SampDefaultKrbtgtCommentString);
        }
    }

    return CommentString;

}

NTSTATUS
SampSetAdminPassword(
    IN     SAMPR_HANDLE DomainHandle
    )
/*++

Routine Description:

    This routine is called on the reboot of a promoted dc.  It retrieves
    the admin password information from the registry and sets it in the
    ds.

Parameters:

    DomainHandle, a valid SAM domain handle

Return Values:

    A fatal SAM error - STATUS_SUCCESS is expected.

--*/
{

    NTSTATUS                    NtStatus, IgnoreStatus;
    USER_INTERNAL1_INFORMATION  Internal1Info;
    SAMPR_HANDLE                UserHandle = 0;

    ASSERT(DomainHandle);

    NtStatus = SamrOpenUser(DomainHandle,
                            GENERIC_ALL,
                            DOMAIN_USER_RID_ADMIN,
                            &UserHandle);

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampGetAdminPasswordFromRegistry(&Internal1Info);

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamrSetInformationUser(UserHandle,
                                              UserInternal1Information,
                                              (PSAMPR_USER_INFO_BUFFER)&Internal1Info);

            if (!NT_SUCCESS(NtStatus)) {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SamrSetInformationUser failed with 0x%x\n",
                           NtStatus));

            }
            else
            {

                //
                // This is a success, so we can remove it
                //
                NtStatus = SampRemoveAdminPasswordFromRegistry();
                if ( !NT_SUCCESS(NtStatus) ) {

                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SampRemoveAdminPasswordFromRegistry failed with 0x%x\n",
                               NtStatus));

                }

            }

        } else {

            if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {
                //
                // This is worth noting
                //
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SampGetAdminPasswordFromRegistry failed with 0x%x\n",
                           NtStatus));
            }

            //
            // Ok, nothing to set
            //
            NtStatus = STATUS_SUCCESS;
        }

        SamrCloseHandle(&UserHandle);

    } else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrOpenUser failed with 0x%x\n",
                   NtStatus));

    }

    RtlZeroMemory(&Internal1Info, sizeof(Internal1Info));

    return NtStatus;

}

NTSTATUS
SampGetCurrentAdminPassword(
    USER_INTERNAL1_INFORMATION *Internal1InfoOut
    )
/*++

Routine Description:

    This routine retrieves the account admin's password in the form
    of a USER_INNTERNAL1_INFORMATION structure.

Parameters:

    Internal1InfoOut, a caller allocated piece of memory for the password
                      information                                               

Return Values:

    STATUS_SUCCESS, or a resource error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PPOLICY_ACCOUNT_DOMAIN_INFO  DomainInfo = NULL;
    USER_INTERNAL1_INFORMATION *pInternal1Info = NULL;
    SAMPR_HANDLE                 ServerHandle = NULL;
    SAMPR_HANDLE                 DomainHandle = NULL;
    SAMPR_HANDLE                 UserHandle = NULL;


    //
    // Open the server
    //
    NtStatus = SamIConnect(NULL,
                           &ServerHandle,
                           GENERIC_ALL,
                           TRUE);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Get the account domain's sid
    //
    NtStatus = SampGetAccountDomainInfo(&DomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Open the account domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              DomainInfo->DomainSid,
                              &DomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Open the administrator account
    //
    NtStatus = SamrOpenUser(DomainHandle,
                            GENERIC_ALL,
                            DOMAIN_USER_RID_ADMIN,
                            &UserHandle);
    if (!NT_SUCCESS(NtStatus)) {
        //
        // N.B This error handling assumes that the Administrator account
        // exists.  This is a valid assumption for non-tampered products.
        //
        goto Cleanup;
    }

    //
    // Get the password
    //
    NtStatus = SamrQueryInformationUser2(UserHandle,
                                         UserInternal1Information,
                                         (PSAMPR_USER_INFO_BUFFER*)&pInternal1Info);

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Copy the information to the out parameter
    // 
    RtlCopyMemory(Internal1InfoOut, pInternal1Info, sizeof(*Internal1InfoOut));
    RtlZeroMemory(pInternal1Info, sizeof(*pInternal1Info));


Cleanup:

    if (pInternal1Info) {
       SamIFree_SAMPR_USER_INFO_BUFFER((PSAMPR_USER_INFO_BUFFER)pInternal1Info,
                                       UserInternal1Information);
    }
    if (UserHandle) {
        SamrCloseHandle(&UserHandle);
    }
    if (DomainHandle) {
        SamrCloseHandle(&DomainHandle);
    }
    if (DomainInfo) {
        LsaIFree_LSAPR_POLICY_INFORMATION (PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)DomainInfo);
    }
    if (ServerHandle) {
        SamrCloseHandle(&ServerHandle);
    }

    return NtStatus;
}

NTSTATUS
SampSetAdminPasswordInRegistry(
    IN BOOLEAN         fUseCurrentAdmin,
    IN PUNICODE_STRING ClearTextPassword
    )
/*++

Routine Description:

    This routine owf's the ClearTextPassword and then store the whole
    set pasword structure in the registry to picked up next reboot.

Parameters:

    fUseCurrentAdmin, use the current admin's password
                                           
    ClearTextPassword, the password to encrypt and store

Return Values:

    A fatal system service error - STATUS_SUCCESS expected.

--*/
{

    NTSTATUS NtStatus, IgnoreStatus;
    USER_INTERNAL1_INFORMATION  Internal1Info;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    KeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    ASSERT(ClearTextPassword);

    RtlZeroMemory(&Internal1Info, sizeof(USER_INTERNAL1_INFORMATION));

    if (fUseCurrentAdmin) {

        NtStatus = SampGetCurrentAdminPassword(&Internal1Info);

    } else {

        Internal1Info.PasswordExpired = FALSE;
        Internal1Info.NtPasswordPresent = TRUE;
    
        NtStatus = SampCalculateLmAndNtOwfPasswords(ClearTextPassword,
                                                    &Internal1Info.LmPasswordPresent,
                                                    &Internal1Info.LmOwfPassword,
                                                    &Internal1Info.NtOwfPassword);

    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Write it out to the registry
        //

        RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
        InitializeObjectAttributes(&SamKey,
                                   &SamKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        NtStatus = NtOpenKey(&SamKeyHandle,
                             DesiredAccess,
                             &SamKey);

        if (NT_SUCCESS(NtStatus)) {

            //
            // Create the value
            //

            RtlInitUnicodeString(&KeyName, SAMP_ADMIN_INFO_NAME);
            NtStatus = NtSetValueKey(SamKeyHandle,
                                     &KeyName,
                                     0,               // Title name, optional
                                     REG_BINARY,
                                     &Internal1Info,
                                     sizeof(USER_INTERNAL1_INFORMATION));

            if (NT_SUCCESS(NtStatus)) {

                IgnoreStatus = NtFlushKey(SamKeyHandle);
                if (!NT_SUCCESS(IgnoreStatus)) {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: NtFlushKey failed with 0x%x\n",
                               IgnoreStatus));
                }

            } else {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: NtSetValueKey failed with 0x%x\n",
                           NtStatus));
            }

            IgnoreStatus = NtClose(SamKeyHandle);
            if (!NT_SUCCESS(IgnoreStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: NtClose failed with 0x%x\n",
                           IgnoreStatus));
            }

        }
        else {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtOpenKey failed with 0x%x\n",
                       NtStatus));

        }

    } else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampCalculateLmAndNtOwfPasswords failed with 0x%x\n",
                   NtStatus));
    }

    RtlZeroMemory(&Internal1Info, sizeof(Internal1Info));

    return NtStatus;

}

NTSTATUS
SampGetAdminPasswordFromRegistry(
    OUT USER_INTERNAL1_INFORMATION *InternalInfo1 OPTIONAL
    )
/*++

Routine Description:

    This routine reads the set password structure stored in the registry
    from a promotion attempt.


Parameters:

    InternalInfo1, a pre-allocated structure into which the registry will be
                   copied in.

Return Values:

    A fatal system service error; STATUS_SUCCESS expected.
    STATUS_UNSUCCESSFUL, if the data is not the expected size.

--*/
{

    NTSTATUS          NtStatus, IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    KeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    PKEY_VALUE_PARTIAL_INFORMATION   KeyPartialInfo;
    ULONG                            KeyPartialInfoSize = 0;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Query the value
        //
        KeyPartialInfo = NULL;
        KeyPartialInfoSize = 0;
        RtlInitUnicodeString(&KeyName, SAMP_ADMIN_INFO_NAME);
        NtStatus = NtQueryValueKey(SamKeyHandle,
                                   &KeyName,
                                   KeyValuePartialInformation,
                                   KeyPartialInfo,
                                   KeyPartialInfoSize,
                                   &KeyPartialInfoSize);

        if (STATUS_BUFFER_TOO_SMALL == NtStatus) {
            //
            //  Allocate some space and then read the buffer
            //
            KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                             MIDL_user_allocate(KeyPartialInfoSize);

            if (KeyPartialInfo) {

                NtStatus = NtQueryValueKey(SamKeyHandle,
                                           &KeyName,
                                           KeyValuePartialInformation,
                                           KeyPartialInfo,
                                           KeyPartialInfoSize,
                                           &KeyPartialInfoSize);
            } else {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Memory allocation failed\n"));

                NtStatus = STATUS_NO_MEMORY;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // Analyse the value's data
            //
            if (KeyPartialInfo->DataLength == sizeof(USER_INTERNAL1_INFORMATION)) {

                //
                // This looks good
                //

                if ( ARGUMENT_PRESENT(InternalInfo1) ) {

                    RtlCopyMemory(InternalInfo1, KeyPartialInfo->Data, sizeof(USER_INTERNAL1_INFORMATION));

                }

            } else {

                SampDiagPrint( PROMOTE, ("SAMSS: AdminInfo key found with bogus value length\n"));
                NtStatus = STATUS_UNSUCCESSFUL;
            }

        } else if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtQueryValueKey failed with 0x%x\n",
                       NtStatus));

        }


        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));

        }

        if (KeyPartialInfo) {

            MIDL_user_free(KeyPartialInfo);

        }


    } else {


        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }

    return NtStatus;

}


NTSTATUS
SampRemoveAdminPasswordFromRegistry(
    VOID
    )
/*++

Routine Description:

    This routine removes the temporily stored admin password from the
    registry.

Parameters:

    None.

Return Values:

    NTSTATUS value

--*/
{

    NTSTATUS          NtStatus, IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    ValueName;

    ULONG             DesiredAccess = GENERIC_ALL;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if ( NT_SUCCESS(NtStatus) )
    {
        RtlInitUnicodeString( &ValueName, SAMP_ADMIN_INFO_NAME );

        NtStatus = NtDeleteValueKey( SamKeyHandle, &ValueName );

        if ( !NT_SUCCESS( NtStatus ) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtDeleteValueKey failed with 0x%x\n",
                       NtStatus));
        }

        NtClose( SamKeyHandle );

    }
    else
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));
    }

    return NtStatus;
}


WCHAR*
SampGetBlankAdminPasswordWarning(
    VOID
    )
/*++

Routine Description:

    This routine queries the resource table in samsrv.dll to get the string
    for the warning the admin password set failed.  If an error occurs trying
    to get the message, a default english string is used.

Parameters:

    None.

Return Values:

    The message string allocated from LocalAlloc; NULL if memory allocation
    failed.

--*/
{
    HMODULE ResourceDll;
    WCHAR   *WarningString=NULL;
    ULONG   Length, Size;
    BOOL    Status;

    ResourceDll = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        SAMMSG_BLANK_ADMIN_PASSWORD,
                                        0,       // Use caller's language
                                        (LPWSTR)&WarningString,
                                        0,       // routine should allocate
                                        NULL
                                        );
        if (WarningString) {
            // Messages from a message file have a cr and lf appended
            // to the end
            WarningString[Length-2] = L'\0';
            Length -= 2;
        }

        Status = FreeLibrary(ResourceDll);
        ASSERT(Status);

    }

    if (!WarningString) {

        ASSERT(!"SAMSS: Resource allocation failed - this can be safely ignored");

        Size = (wcslen(SampDefaultBlankAdminPasswordWarningString)+1)*sizeof(WCHAR);
        WarningString = (WCHAR*)LocalAlloc(0, Size);
        if (WarningString) {
            wcscpy(WarningString, SampDefaultBlankAdminPasswordWarningString);
        }
    }

    return WarningString;

}

NTSTATUS
SampPerformNewServerPhase2(
    SAMPR_HANDLE DomainHandle,
    BOOLEAN      fMemberServer
    )

/*++

Routine Description:

    This routine performs the actions necessary on a reboot to complete
    a demotion operation.

    Currently, all this means is to set the account domain's admin's password.

    As well, the ds files are cleaned up.

Parameters:

    DomainHandle: a valid handle to the account domain

    fMemberServer: TRUE if this is a member server

Return Values:

    an NT status; a failure is critical

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    WCHAR    *PathArray = NULL;
    DWORD    Size = 0;

    if ( SampUseDsData )
    {
        //
        // Protect against wierd configurations
        //

        // remove the key to
        NtStatus = SampDeleteDsDirsToDeleteKey();

        return STATUS_SUCCESS;
    }

    NtStatus = SampSetAdminPassword( DomainHandle );
    if ( !NT_SUCCESS(NtStatus) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetAdminPassword failed with %x0x\n"));
    }

    NtStatus = SampRetrieveDsDirsToDeleteKey( &PathArray, &Size );
    if ( NT_SUCCESS( NtStatus ) )
    {
        ASSERT( PathArray );
        NtStatus = SampProcessDsDirsToDelete( PathArray, Size );
        if ( !NT_SUCCESS(NtStatus) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampProcessDsDirsToDelete failed with %x0x\n",
                       NtStatus));
        }

        //
        // Delete the key
        //
        IgnoreStatus = SampDeleteDsDirsToDeleteKey();

        MIDL_user_free( PathArray );

    }


    return NtStatus;
}

NTSTATUS
SampPerformTempUpgradeWork(
    SAMPR_HANDLE DomainHandle
    )
/*++

Routine Description:

    This routine sets the admin password on the temporary accounts made
    for downlevel upgrades.

Parameters:

    DomainHandle: a valid handle to the account domain

Return Values:

    an NT status; a failure is critical

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = SampSetAdminPassword( DomainHandle );
    if ( !NT_SUCCESS(NtStatus) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetAdminPassword failed with 0x%x\n",
                   NtStatus));
    }

    return NtStatus;
}




NTSTATUS
SampApplyWellKnownMemberships(
    IN SAMPR_HANDLE AccountDomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN PSID         DomainSid,
    IN ULONG        Flags
    )
/*++

Routine Description:

    This routine applies the memberships indicated by
    DsWellKnownMemberships

Parameters:

    DomainHandle - a handle to the account domain

    BuiltinDomainHandle - a handle to the builtin domain

    DomainSid - the sid of the account domain


Return Values:

    an NT status; a failure is not critical

--*/
{

    NTSTATUS      NtStatus = STATUS_SUCCESS;
    ULONG         i;
    SAMPR_HANDLE  GroupDomainHandle = NULL;
    ULONG         DesiredAccess = MAXIMUM_ALLOWED;
    PSID          CurrentDomainSid = 0;

    //
    // These values were taken from bldsam3.c
    //
    ULONG         Attributes = SE_GROUP_MANDATORY |
                               SE_GROUP_ENABLED_BY_DEFAULT |
                               SE_GROUP_ENABLED;

    //
    // Parameter checking
    //
    ASSERT(AccountDomainHandle);
    ASSERT(BuiltinDomainHandle);
    ASSERT(DomainSid);

    for ( i=0; i < ARRAY_COUNT( DsWellKnownMemberships ); i++ )
    {
        SAMPR_HANDLE GroupHandle = NULL;
        PSID         AccountSid = NULL;
        BOOLEAN      fGroupOpened = FALSE;

        if (!SampUseDsData)
        {
            //
            // Currently no well known memberships in registry mode
            //

            continue;
        }

        if (  DsWellKnownMemberships[i].fEnterpriseOnly
          &&  !FLAG_ON( Flags, SAMP_PROMOTE_ENTERPRISE ) )
        {
            //
            // Thanks, but no thanks
            //
            continue;
        }

        if ( !DsWellKnownMemberships[i].fNewForNt5
          && !FLAG_ON( Flags, SAMP_PROMOTE_MIGRATE ) )
        {
            //
            // Thanks, but no thanks.
            //
            continue;
        }

        if ( (DOMAIN_ALIAS_RID_PREW2KCOMPACCESS == DsWellKnownMemberships[i].GroupRid)
           && !FLAG_ON( Flags, SAMP_PROMOTE_ALLOW_ANON ) ) {

            //
            // Don't apply
            //
            continue;

        }

        //
        // Get the right domain handle for the group
        //
        if ( DsWellKnownMemberships[i].fBuiltinGroup )
        {
            GroupDomainHandle = BuiltinDomainHandle;
        }
        else
        {
            GroupDomainHandle = AccountDomainHandle;
        }

        switch ( DsWellKnownMemberships[i].GroupType )
        {
            case SampGroupObjectType:

                //
                // Get the group handle
                //
                NtStatus = SamrOpenGroup( GroupDomainHandle,
                                          DesiredAccess,
                                          DsWellKnownMemberships[i].GroupRid,
                                          &GroupHandle );


                if ( !NT_SUCCESS( NtStatus ) )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SamrOpenGroup failed with 0x%x\n",
                               NtStatus));

                    goto IterationCleanup;
                }
                fGroupOpened = TRUE;

                //
                // Add the member
                //
                NtStatus = SamrAddMemberToGroup( GroupHandle,
                                                 DsWellKnownMemberships[i].AccountRid,
                                                 Attributes );


                if ( (NtStatus == STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS)
                 ||  (NtStatus == STATUS_MEMBER_IN_GROUP) )
                {
                    NtStatus = STATUS_SUCCESS;
                }

                if ( !NT_SUCCESS( NtStatus ) )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SamrAddMemberToGroup failed with 0x%x\n",
                               NtStatus));

                    goto IterationCleanup;
                }

                break;

            case SampAliasObjectType:

                //
                // Get the alias handle
                //


                NtStatus = SamrOpenAlias( GroupDomainHandle,
                                          DesiredAccess,
                                          DsWellKnownMemberships[i].GroupRid,
                                          &GroupHandle );


                if ( !NT_SUCCESS( NtStatus ) )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SamrOpenAlias failed with 0x%x\n",
                               NtStatus));

                    goto IterationCleanup;
                }
                fGroupOpened = TRUE;

                //
                // Prepare the Account SID 
                // 
                if (DsWellKnownMemberships[i].fWellKnownSid)
                {
                    ULONG   Size;

                    ASSERT( NULL != *DsWellKnownMemberships[i].WellKnownAccountSid );


                    Size = RtlLengthSid(*DsWellKnownMemberships[i].WellKnownAccountSid);

                    AccountSid = midl_user_allocate( Size );
                    if ( !AccountSid ) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto IterationCleanup;
                    }
                    RtlCopyMemory( AccountSid, 
                                   *DsWellKnownMemberships[i].WellKnownAccountSid, 
                                   Size );
                }
                else
                {
                    if ( DsWellKnownMemberships[i].fBuiltinAccount )
                    {
                        CurrentDomainSid = SampBuiltinDomainSid;
                    }
                    else
                    {
                        CurrentDomainSid = DomainSid;
                    }


                    NtStatus = SampCreateFullSid( CurrentDomainSid,
                                                  DsWellKnownMemberships[i].AccountRid,
                                                  &AccountSid );

                    if ( !NT_SUCCESS( NtStatus ) )
                    {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampCreateFullSid failed with 0x%x\n",
                                   NtStatus));

                        goto IterationCleanup;
                    }

                }

                //
                // Add the member
                //
                NtStatus = SamrAddMemberToAlias( GroupHandle,
                                                 AccountSid );

                if ( (NtStatus == STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS)
                 ||  (NtStatus == STATUS_MEMBER_IN_ALIAS) )

                {
                    NtStatus = STATUS_SUCCESS;
                }

                if ( !NT_SUCCESS( NtStatus ) )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SamrAddMemberToAlias failed with 0x%x\n",
                               NtStatus));

                    goto IterationCleanup;
                }


                break;

            default:
                ASSERT( "Invalid switch statement" );

        }

IterationCleanup:

        if ( !NT_SUCCESS( NtStatus ) )
        {

            //
            // Log the error and then reset NtStatus to success
            //
            NTSTATUS IgnoreStatus = STATUS_SUCCESS;
            DWORD    WinError = ERROR_SUCCESS;
            DWORD    WinErrorToLog;
            UNICODE_STRING User, Group, Error;
            PUNICODE_STRING EventStrings[3] = { &User, &Group, &Error };
            ULONG    Length;
            HMODULE  AccountNamesResource = NULL;

            RtlZeroMemory( &User, sizeof( UNICODE_STRING ) );
            RtlZeroMemory( &Group, sizeof( UNICODE_STRING ) );
            RtlZeroMemory( &Error, sizeof( UNICODE_STRING ) );

            AccountNamesResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );
            if (AccountNamesResource) {
                IgnoreStatus = SampGetMessageStrings( AccountNamesResource,
                                                      DsWellKnownMemberships[i].AccountName,
                                                      &User,
                                                      DsWellKnownMemberships[i].GroupName,
                                                      &Group );

                FreeLibrary( AccountNamesResource );
            } else {
                IgnoreStatus = STATUS_RESOURCE_DATA_NOT_FOUND;
            }

            WinErrorToLog = RtlNtStatusToDosError( NtStatus );
            Length = FormatMessage( (FORMAT_MESSAGE_FROM_SYSTEM |
                                     FORMAT_MESSAGE_ALLOCATE_BUFFER),
                                     NULL, // no source
                                     WinErrorToLog,
                                     0, // let the system decide the language
                                     (LPWSTR)&Error.Buffer,
                                     0, // buffer is to be allocated
                                     NULL // no inserts
                                    );
            if ( Length > 0 ) {
                Error.Length = (USHORT)Length;
                Error.MaximumLength = (USHORT)Length;
                Error.Buffer[Length-2] = L'\0';
            } else {
                WinError = GetLastError();
            }

            if (  (ERROR_SUCCESS == WinError)
                && NT_SUCCESS( IgnoreStatus ) )
            {
                ULONG Msg = SAMMSG_MEMBERSHIP_SETUP_ERROR_NO_GROUP;
                if ( fGroupOpened )
                {
                    Msg = SAMMSG_MEMBERSHIP_SETUP_ERROR;
                }

                SampWriteEventLog( EVENTLOG_INFORMATION_TYPE,
                                   0,    // no category
                                   Msg,
                                   NULL, // no sid
                                   sizeof(EventStrings)/sizeof(EventStrings[0]), // number of strings
                                   sizeof(DWORD), // size of data
                                   EventStrings,
                                   &WinErrorToLog
                                    );

            }

            if ( User.Buffer )
            {
                LocalFree( User.Buffer );
            }
            if ( Group.Buffer )
            {
                LocalFree( Group.Buffer );
            }
            if ( Error.Buffer )
            {
                LocalFree( Error.Buffer );
            }

            // This error condition is handled
            NtStatus = STATUS_SUCCESS;

        }


        if (GroupHandle)
        {
            SamrCloseHandle(&GroupHandle);
            GroupHandle = NULL;
        }

       if ( AccountSid )
       {
           MIDL_user_free(  AccountSid );
           AccountSid = NULL;
       }

    }

    ASSERT( NT_SUCCESS( NtStatus ) );
    return NtStatus;
}


NTSTATUS
SampAddAnonymousToPreW2KCompAlias(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle
    )
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    SAMPR_HANDLE        AliasHandle = NULL;
    SAMPR_PSID_ARRAY    MembersBuffer;
    BOOLEAN             IsMemberAlready = FALSE, AddToAlias = FALSE; 
    ULONG               i;

    // init local variables

    RtlZeroMemory(&MembersBuffer, sizeof(SAMPR_PSID_ARRAY));

    //
    // Get alias handle
    // 
    NtStatus = SamrOpenAlias(BuiltinDomainHandle,   // Domain Handle
                             MAXIMUM_ALLOWED,       // Desired Access
                             DOMAIN_ALIAS_RID_PREW2KCOMPACCESS, // Alias Rid
                             &AliasHandle
                             );

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // PRE_Windows 2000 Compatibility Group Should always be there
        // 
        goto Cleanup; 
    }

    //
    // Get Alias Members
    // 
    NtStatus = SamrGetMembersInAlias(AliasHandle,
                                     &MembersBuffer
                                     );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup; 
    }

    // 
    // Check membership, whether Everyone is a member of W2KCompGroup
    // 
    for (i = 0; i < MembersBuffer.Count; i++)
    {
        if (RtlEqualSid(SampWorldSid, MembersBuffer.Sids[i].SidPointer))
        {
            AddToAlias = TRUE;
        }
        if (RtlEqualSid(SampAnonymousSid, MembersBuffer.Sids[i].SidPointer))
        {
            IsMemberAlready = TRUE;
        }
    }

    //
    // Add the member 
    // 

    if (AddToAlias && !IsMemberAlready)
    {
        NtStatus = SamrAddMemberToAlias(AliasHandle,
                                        SampAnonymousSid
                                        );

        if ( (NtStatus == STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS)
         ||  (NtStatus == STATUS_MEMBER_IN_ALIAS) )
        {
            NtStatus = STATUS_SUCCESS;
        }
    }

Cleanup:

    if (AliasHandle)
    {
        SamrCloseHandle(&AliasHandle);
    }

    if (MembersBuffer.Sids)
    {
        MIDL_user_free(MembersBuffer.Sids);
    }

    return( NtStatus );
}





NTSTATUS
SampStoreDsDirsToDelete(
    VOID
    )
/*++

Routine Description:

    This routine queries the ds config to determine what directories
    to delete.  It then saves them in the process heap so when the ds is
    finally shutdown, the directories can be cleared.

Parameters:

    None.

Return Values:

    an NT status; a failure is not critical

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD    WinError = ERROR_SUCCESS;

    DWORD Size, Index, TotalSize, ArrayIndex;

    WCHAR **DsDirsArray = NULL;
    WCHAR *ContiguousArray = NULL;

    struct
    {
        WCHAR *RegKey;

    } SuffixArray[] =
    {
        TEXT(BACKUPPATH_KEY),
        TEXT(JETSYSTEMPATH_KEY),
        TEXT(LOGPATH_KEY)
    };

    ULONG NumberOfDirectories = ARRAY_COUNT(SuffixArray);

    //
    // Set up the directory array.  The +1 is the sentinal
    //
    Size = (NumberOfDirectories+1) * sizeof(WCHAR*);
    DsDirsArray = (WCHAR**) MIDL_user_allocate( Size );
    if ( NULL == DsDirsArray )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory( DsDirsArray, Size );

    //
    // Set up the individual directories
    //
    TotalSize = 0;
    Size = (MAX_PATH+1)*sizeof(WCHAR); // +1 for NULL
    for ( Index = 0; Index < NumberOfDirectories; Index++ )
    {
        DsDirsArray[Index] = (WCHAR*) MIDL_user_allocate( Size );
        if ( DsDirsArray[Index] )
        {
            RtlZeroMemory( DsDirsArray[Index], Size );

            WinError = GetConfigParamW( SuffixArray[Index].RegKey,
                                        DsDirsArray[Index],
                                        Size );
            if ( ERROR_SUCCESS != WinError )
            {
                MIDL_user_free( DsDirsArray[Index] );
                DsDirsArray[Index] = 0;
            }

            TotalSize += (wcslen( DsDirsArray[Index] ) + 1) * sizeof(WCHAR);
        }
        else
        {
            // No memory - break
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Marshall the strings up into a contiguous piece of memory
    //
    ContiguousArray = (WCHAR*) MIDL_user_allocate( TotalSize );
    if ( !ContiguousArray )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory( ContiguousArray, TotalSize );

    Index = 0;
    ArrayIndex = 0;
    while ( DsDirsArray[ArrayIndex] )
    {
        DWORD StringSize = (wcslen( DsDirsArray[ArrayIndex] ) + 1) * sizeof(WCHAR);
        RtlCopyMemory( &(ContiguousArray[Index]), DsDirsArray[ArrayIndex], StringSize );

        MIDL_user_free( DsDirsArray[ArrayIndex] );
        DsDirsArray[ArrayIndex] = 0;

        Index += (StringSize / sizeof(WCHAR));
        ArrayIndex++;
    }

    //
    // Set the value in the registry
    //
    NtStatus = SampCreateDsDirsToDeleteKey( ContiguousArray, TotalSize );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }


Cleanup:

    if ( ContiguousArray )
    {
        MIDL_user_free( ContiguousArray );
    }

    if ( DsDirsArray )
    {
        ULONG IndexTmp = 0;
        while ( DsDirsArray[IndexTmp] )
        {
            MIDL_user_free( DsDirsArray[IndexTmp] );
            IndexTmp++;
        }

        MIDL_user_free( DsDirsArray );
    }

    return NtStatus;
}


NTSTATUS
SampProcessDsDirsToDelete(
    IN OUT WCHAR *PathArray,
    IN DWORD Size
    )
/*++

Routine Description:

Parameters:


Return Values:

    A system service error

--*/
{
    NTSTATUS NtStatus  = STATUS_SUCCESS;
    DWORD    WinError  = ERROR_SUCCESS;
    WCHAR    Delim = L'\t';
    WCHAR    *DelimString = L"\t";
    WCHAR    *Path;
    ULONG    CharCount = Size / sizeof(WCHAR);
    ULONG    Index;

    //
    // Convert NULL's to tabs so wcstok will work
    //
    for ( Index = 0; Index < CharCount; Index++ )
    {
        if ( Index == (CharCount-1))
        {
            // final character - should be NULL
            ASSERT( L'\0' == PathArray[Index] );
        }
        else if ( L'\0' == PathArray[Index] )
        {
            PathArray[Index] = Delim;
        }
    }

    if ( PathArray )
    {
        Path = wcstok( PathArray, DelimString );
        while ( Path )
        {
            WinError = SampClearDirectory( Path );

            if (  ERROR_SUCCESS != WinError
              && !(   WinError == ERROR_PATH_NOT_FOUND
                   || WinError == ERROR_FILE_NOT_FOUND ) )
            {
                //
                // Tell the user to clear this directory
                //
                PUNICODE_STRING EventString[1];
                UNICODE_STRING  UnicodeString;

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Failed to delete directory %ls; error %d\n",
                           Path,
                           WinError));

                RtlInitUnicodeString( &UnicodeString, Path );
                EventString[0] = &UnicodeString;


                SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                  0,     // no category
                                  SAMMSG_DATABASE_DIR_NOT_DELETED,
                                  NULL,  // no sid
                                  1,
                                  sizeof(DWORD),
                                  EventString,
                                  (PVOID)(&WinError));
            }

            Path = wcstok( NULL, DelimString );
        }
    }

    return NtStatus;
}

NTSTATUS
SampCreateDsDirsToDeleteKey(
    IN WCHAR *PathArray,
    IN DWORD Size
    )
/*++

Routine Description:

Parameters:


Return Values:

    A system service error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NTSTATUS          IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    PromoteKeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Create the value
        //
        RtlInitUnicodeString(&PromoteKeyName, SAMP_DS_DIRS_INFO_NAME );
        NtStatus = NtSetValueKey(SamKeyHandle,
                                 &PromoteKeyName,
                                 0,               // Title name, optional
                                 REG_MULTI_SZ,
                                 PathArray,
                                 Size);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtSetValueKey failed with 0x%x\n",
                       NtStatus));
        }

        IgnoreStatus = NtFlushKey(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtFlushKey failed with 0x%x\n",
                       IgnoreStatus));
        }

        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));
        }

    }
    else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }

    return NtStatus;
}

NTSTATUS
SampRetrieveDsDirsToDeleteKey(
    OUT WCHAR **pPathArray,
    OUT DWORD *Size
    )
/*++

Routine Description:

Parameters:


Return Values:

    A system service error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    PromoteKeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    PKEY_VALUE_PARTIAL_INFORMATION   KeyPartialInfo;
    ULONG                            KeyPartialInfoSize = 0;

    WCHAR *Paths = NULL;

    ASSERT(pPathArray);
    ASSERT(Size);

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY);
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Query the value
        //

        RtlInitUnicodeString( &PromoteKeyName, SAMP_DS_DIRS_INFO_NAME );
        NtStatus = NtQueryValueKey(SamKeyHandle,
                                   &PromoteKeyName,
                                   KeyValuePartialInformation,
                                   NULL,
                                   0,
                                   &KeyPartialInfoSize);

        if (STATUS_BUFFER_TOO_SMALL == NtStatus) {
            //
            //  Allocate some space and then read the buffer
            //
            KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                             MIDL_user_allocate(KeyPartialInfoSize);

            if (KeyPartialInfo) {

                NtStatus = NtQueryValueKey(SamKeyHandle,
                                           &PromoteKeyName,
                                           KeyValuePartialInformation,
                                           KeyPartialInfo,
                                           KeyPartialInfoSize,
                                           &KeyPartialInfoSize);

                if (NT_SUCCESS(NtStatus)) {
                    //
                    // Analysis the value's data
                    //
                    *pPathArray = (WCHAR*) MIDL_user_allocate( KeyPartialInfo->DataLength );

                    if ( *pPathArray )
                    {
                        RtlCopyMemory( *pPathArray,
                                        KeyPartialInfo->Data,
                                        KeyPartialInfo->DataLength );
                        *Size = KeyPartialInfo->DataLength;
                    }
                    else
                    {
                        NtStatus = STATUS_NO_MEMORY;
                    }

                } else {

                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: NtQueryValueKey failed with 0x%x\n",
                               NtStatus));
                }

                MIDL_user_free( KeyPartialInfo );

            } else {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Memory allocation failed\n"));

                NtStatus = STATUS_NO_MEMORY;

            }

        }
        else
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtQueryValueKey failed with 0x%x\n",
                       NtStatus));
        }


        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));
        }

    }
    else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }

    if ( NT_SUCCESS( NtStatus ) )
    {
        ASSERT( *pPathArray );
    }

    return NtStatus;
}

NTSTATUS
SampDeleteDsDirsToDeleteKey(
    VOID
    )
/*++

Routine Description:

Parameters:


Return Values:

    A system service error

--*/
{

    NTSTATUS          NtStatus = STATUS_SUCCESS;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    ValueName;

    ULONG             DesiredAccess = GENERIC_ALL;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if ( NT_SUCCESS(NtStatus) )
    {
        RtlInitUnicodeString( &ValueName, SAMP_DS_DIRS_INFO_NAME );

        NtStatus = NtDeleteValueKey( SamKeyHandle, &ValueName );

        if ( !NT_SUCCESS( NtStatus )
          && STATUS_OBJECT_NAME_NOT_FOUND != NtStatus )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtDeleteValueKey failed with 0x%x\n",
                       NtStatus ));
        }

        NtClose( SamKeyHandle );

    }
    else
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));
    }

    return NtStatus;
}

DWORD
SampClearDirectory(
    IN WCHAR *DirectoryName
    )
/*++

Routine Description:

    This routine deletes all the files in Directory and, then
    if the directory is empty, removes the directory.

Parameters:

    DirectoryName: a null terminated string

Return Values:

    A value from winerror.h

    ERROR_SUCCESS - The check was done successfully.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD ExtendedWinError = ERROR_SUCCESS;
    HANDLE          FindHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR           Path[ MAX_PATH ];
    WCHAR           FilePath[ MAX_PATH ];
    BOOL            fStatus;

    if ( !DirectoryName )
    {
        return ERROR_SUCCESS;
    }

    if ( wcslen(DirectoryName) > MAX_PATH - 4 )
    {
        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory( Path, sizeof(Path) );
    wcscpy( Path, DirectoryName );
    wcscat( Path, L"\\*.*" );

    RtlZeroMemory( &FindData, sizeof( FindData ) );
    FindHandle = FindFirstFile( Path, &FindData );
    if ( INVALID_HANDLE_VALUE == FindHandle )
    {
        WinError = GetLastError();
        goto ClearDirectoryExit;
    }

    do
    {

        if (  !FLAG_ON( FindData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY ) )
        {
            RtlZeroMemory( FilePath, sizeof(FilePath) );
            wcscpy( FilePath, DirectoryName );
            wcscat( FilePath, L"\\" );
            wcscat( FilePath, FindData.cFileName );

            fStatus = DeleteFile( FilePath );
            if ( !fStatus )
            {
                ExtendedWinError = GetLastError();
            }

            //
            // Even if error, continue on
            //
        }

        RtlZeroMemory( &FindData, sizeof( FindData ) );

    } while ( FindNextFile( FindHandle, &FindData ) );

    WinError = GetLastError();

    //
    // Fall through to the exit
    //

ClearDirectoryExit:

    // This is not an error
    if ( ERROR_NO_MORE_FILES == WinError )
    {
        WinError = ERROR_SUCCESS;
    }

    if ( INVALID_HANDLE_VALUE != FindHandle )
    {
        FindClose( FindHandle );
    }

    if ( ERROR_SUCCESS == WinError )
    {
        //
        // Try to remove the directory
        //
        fStatus = RemoveDirectory( DirectoryName );

        //
        // Ignore the error and continue on
        //
        if ( !fStatus )
        {
            ExtendedWinError = GetLastError();
        }

    }

    // Propogate error if any delete file failed
    if ( ERROR_SUCCESS == WinError )
    {
        WinError = ExtendedWinError;
    }


    return WinError;
}

NTSTATUS
SampAddEnterpriseAdminsToAdministrators(
    VOID
    )
/*++

Routine Description:

    This routine, called during SamIPromote add the enterprise wide account
    of "Enterprise Admins" to the alias Administrators.

Parameters:

    None.

Return Values:

    STATUS_SUCCESS

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;

    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;

    ULONG   Size = 0;
    DSNAME *RootDomain = 0;

    DSNAME *AdministratorsDsName = NULL;

    // alloc'ed by MIDL_user_allocate
    PSID    EAdminsSid = NULL;
    DSNAME **EAdminsDsName = NULL;

    ULONG Count;

    //
    // Get the current domain sid
    //
    NtStatus = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                   (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // Get the root domain sid via its dsname
    //
    Size = 0;
    RootDomain = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_ROOT_DOMAIN,
                                     &Size,
                                     RootDomain );
    if ( STATUS_BUFFER_TOO_SMALL == NtStatus )
    {
        SAMP_ALLOCA(RootDomain,Size );

        if (NULL==RootDomain)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NtStatus = GetConfigurationName( DSCONFIGNAME_ROOT_DOMAIN,
                                         &Size,
                                         RootDomain );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }
    ASSERT( RtlValidSid( &RootDomain->Sid ) );

    //
    // Construct the enterprise admins' sid
    //
    NtStatus = SampCreateFullSid( &RootDomain->Sid,
                                  DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                                  &EAdminsSid
                                  );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // Create the local administrators dsname
    //
    Size = DSNameSizeFromLen( 0 );
    SAMP_ALLOCA(AdministratorsDsName ,Size );
    if (NULL==AdministratorsDsName)
    {
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
       goto Cleanup;
    }
    RtlZeroMemory( AdministratorsDsName, Size );
    AdministratorsDsName->structLen = Size;
    AdministratorsDsName->SidLen = RtlLengthSid( SampAdministratorsAliasSid );
    RtlCopySid( AdministratorsDsName->SidLen,
                &AdministratorsDsName->Sid,
                SampAdministratorsAliasSid );

    //
    // Create an FPO for the enterprise admins objects
    //
    Count = 0;
    do
    {
        //
        // Start a transaction
        //
        NTSTATUS st;

        NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            break;
        }

        NtStatus = SampDsResolveSidsForDsUpgrade(
                        DnsDomainInfo->Sid,
                        &EAdminsSid,
                        1,
                        ( RESOLVE_SIDS_FAIL_WELLKNOWN_SIDS
                        | RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL ),
                        &EAdminsDsName
                        );

        if ( NT_SUCCESS( NtStatus )
          && NULL != EAdminsDsName[0] )
        {
            //
            // Add the EA to administrators
            //
            NtStatus = SampDsAddMembershipAttribute( AdministratorsDsName,
                                                     SampAliasObjectType,
                                                     EAdminsDsName[0] );

            if ( STATUS_MEMBER_IN_ALIAS == NtStatus )
            {
                // This is acceptable
                NtStatus = STATUS_SUCCESS;
            }
        }

        st = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                           TransactionCommit :
                                           TransactionAbort );

        // Propogate the error if necessary
        if ( NT_SUCCESS(NtStatus) )
        {
            NtStatus = st;
        }

    } while ( (STATUS_DS_BUSY == NtStatus) && Count < 5 );

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // That's it -- fall through to cleanup
    //

Cleanup:


    // We should only fail on resource error, so let's assert

    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                          0,     // no category
                          SAMMSG_EA_TO_ADMIN_FAILED,
                          NULL,  // no sid
                          0,
                          sizeof(DWORD),
                          NULL,  // no message insert
                          (PVOID)(&NtStatus));

        // This is error has been handled
        NtStatus = STATUS_SUCCESS;
    }

    if ( EAdminsSid )
    {
        MIDL_user_free( EAdminsSid );
    }

    if ( EAdminsDsName )
    {
        if ( EAdminsDsName[0] )
        {
            MIDL_user_free( EAdminsDsName[0] );
        }
        MIDL_user_free( EAdminsDsName );
    }

    if ( DnsDomainInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );
    }

    return NtStatus;

}


DWORD
SampSetMachineAccountSecret(
    LPWSTR SecretValue
    )
/*++

Routine Description:

    This routine sets the local copy of the machine account's password.

    We go through the lsa client library because there is no easy way to
    set a secret via the in-proc api.

Parameters:

    None.

Return Values:

    ERROR_SUCCESS; winerror otherwise

--*/
{
    OBJECT_ATTRIBUTES PolicyObject;
    HANDLE   PolicyHandle;
    NTSTATUS NtStatus;
    UNICODE_STRING SecretName, SecretString;

    RtlInitUnicodeString(&SecretName, SSI_SECRET_NAME);

    RtlInitUnicodeString(&SecretString, SecretValue);

    RtlZeroMemory(&PolicyObject, sizeof(PolicyObject));

    NtStatus = LsaOpenPolicy(NULL,
                             &PolicyObject,
                             MAXIMUM_ALLOWED,
                             &PolicyHandle );

    if ( NT_SUCCESS(NtStatus) )
    {

        NtStatus = LsaStorePrivateData(PolicyHandle,
                                       &SecretName,
                                       &SecretString);

        LsaClose(PolicyHandle);
    }

    return NtStatus;

}



NTSTATUS
SampSetSafeModeAdminPassword(
    VOID
    )

/*++

Routine Description:

    This routine is called during the first boot of a domain controller to
    set the admin password of the safemode SAM registry hive.  The OWF
    password is stored in the registry; this routine must gaurentee to delete
    it whether or not the password set succeeded.

    This function is tricky because although we are running in DS mode
    we are setting a value in the registry SAM.

Parameters:

    None.

Return Values:

    A system service error

--*/
{
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    PSAMP_OBJECT AccountContext = NULL;
    USER_INTERNAL1_INFORMATION   Internal1Info;
    BOOLEAN fLockHeld = FALSE;
    BOOLEAN fCommit = FALSE;

    RtlZeroMemory( &Internal1Info, sizeof(Internal1Info) );

    NtStatus = SampGetAdminPasswordFromRegistry(&Internal1Info);
    if ( !NT_SUCCESS(NtStatus) ) {

        if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {
            //
            // This is worth noting
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampGetAdminPasswordFromRegistry failed with 0x%x\n",
                       NtStatus));
        }

        //
        // Ok, nothing to set
        //
        return STATUS_SUCCESS;
    }


    NtStatus = SampAcquireWriteLock();
    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                     ( "SAMSS: SampAcquireWriteLock returned 0x%x\n",
                      NtStatus ));

        goto Cleanup;
    }
    fLockHeld = TRUE;

    //
    // Set the transactional domain the account context will go to
    // the registry
    //
    SampSetTransactionDomain( SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX );

    //
    // Create a context
    //
    NtStatus = SampCreateAccountContext( SampUserObjectType,
                                         DOMAIN_USER_RID_ADMIN,
                                         TRUE,  // trusted client
                                         FALSE, // loopback
                                         TRUE,  // account exists
                                         &AccountContext );

    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                ( "SAMSS: SampCreateAccountContext for rid 0x%x returned 0x%x\n",
                      DOMAIN_USER_RID_ADMIN, NtStatus ));

        goto Cleanup;
    }

    SampReferenceContext( AccountContext );

    //
    // Store the passwords
    //
    NtStatus = SampStoreUserPasswords( AccountContext,
                                       &Internal1Info.LmOwfPassword,
                                       Internal1Info.LmPasswordPresent,
                                       &Internal1Info.NtOwfPassword,
                                       Internal1Info.NtPasswordPresent,
                                       FALSE,  // don't check history
                                       PasswordPushPdc,
                                       NULL,
                                       NULL
                                       );

    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                     ( "SAMSS: SampStoreUserPasswords returned 0x%x\n",
                      NtStatus ));

        goto Cleanup;
    }
    fCommit = TRUE;



Cleanup:

    if ( AccountContext )
    {
        //
        //  Dereference the context to make the changes
        //
        NtStatus = SampDeReferenceContext( AccountContext, fCommit );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint( DISPLAY_LOCKOUT,
                         ( "SAMSS: SampDeReferenceContext returned 0x%x\n",
                          NtStatus ));

            fCommit = FALSE;
        }


    }

    if ( fLockHeld ) {

        FlushImmediately = TRUE;

        NtStatus = SampReleaseWriteLock( fCommit );

        FlushImmediately = FALSE;

    }

    //
    // Keep the key open
    //
    if ( AccountContext ) {

        SampDeleteContext( AccountContext );
        AccountContext = 0;

    }

    if ( NT_SUCCESS( NtStatus ) && fCommit ) {

        SampRemoveAdminPasswordFromRegistry();

    }

    return NtStatus;


}


VOID
SampGenerateRandomPassword(
    IN LPWSTR Password,
    IN ULONG  Length
    )

/*++

Routine Description:

    This routine fills in Password with random bits.

Parameters:

    Password -- a preallocated buffer of WCHAR's
    
    Length -- the number of characters (not bytes) in Password

Return Values:

    None.            

--*/
{
    ULONG i;
    BOOLEAN fStatus;

    fStatus = CDGenerateRandomBits( (PUCHAR) Password,
                                    Length * sizeof(WCHAR) );
    ASSERT( fStatus );  // if false then we just get random stack or heap noise

    // Terminate the password
    Password[Length-1] = L'\0';
    // Make sure there aren't any NULL's in the password
    for (i = 0; i < (Length-1); i++)
    {
        if ( Password[i] == L'\0' )
        {
            // arbitrary letter
            Password[i] = L'c';
        }
    }
}

NTSTATUS
SampDsGetServerRevision(
    OUT ULONG   *DsRevision
    )
/*++

Routine Description:

    This routine retrieves DS Revision from SAM Server Object.

Parameter:

    DsRevision - used to return DS Revision

Return Value:

    NtStatus 

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    BOOLEAN         fTransOpen = FALSE;
    DWORD           DirError = 0;
    READARG         ReadArg;
    READRES         *ReadRes = NULL;
    COMMARG         *CommArg = NULL;
    ATTR            Attr;
    ATTRBLOCK       ReadAttrBlock;
    ENTINFSEL       EntInfSel;



    // Start a DS transaction

    NtStatus = SampMaybeBeginDsTransaction( TransactionRead );

    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }
    fTransOpen = TRUE;



    //
    // init read argument
    // 
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EntInfSel, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_REVISION;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EntInfSel.AttrTypBlock = ReadAttrBlock;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInfSel;
    ReadArg.pObject = SampServerObjectDsName;

    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);


    DirError = DirRead(&ReadArg, &ReadRes);

    if (NULL == ReadRes) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadRes->CommRes);
    }

    if (NT_SUCCESS(NtStatus))
    {
        ATTRBLOCK   AttrBlock;

        ASSERT(NULL != ReadRes);


        AttrBlock = ReadRes->entry.AttrBlock;

        if ( (1 == AttrBlock.attrCount) &&
             (NULL != AttrBlock.pAttr) &&
             (1 == AttrBlock.pAttr[0].AttrVal.valCount) &&
             (NULL != AttrBlock.pAttr[0].AttrVal.pAVal) )
        {
            ASSERT( sizeof(ULONG) == AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen );

            *DsRevision = * ((ULONG *)AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);

        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }


Cleanup:

    if ( fTransOpen )
    {
        NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

        IgnoreStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ? 
                                                  TransactionCommit : TransactionAbort
                                                );
    }

    return( NtStatus );
}


NTSTATUS
SampDsSetServerRevision(
    ULONG   DsRevision
    )
/*++

Routine Description:

    This routine sets DS Revision on SAM Server Object.

Parameter:

    DsRevision - DS Revision to set

Return Value:

    NtStatus 

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DirError = 0;
    MODIFYARG   ModArg;
    MODIFYRES   *ModRes = NULL;
    COMMARG     *CommArg = NULL;
    ATTR        Attr;
    ATTRVAL     AttrVal;
    ATTRVALBLOCK    AttrValBlock;
    BOOLEAN     fTransOpen = FALSE;


    // Start a DS transaction

    NtStatus = SampMaybeBeginDsTransaction( TransactionRead );

    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }
    fTransOpen = TRUE;


    RtlZeroMemory(&ModArg, sizeof(MODIFYARG));

    ModArg.pObject = SampServerObjectDsName;
    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = sizeof(ULONG);
    AttrVal.pVal = (PUCHAR) &DsRevision;

    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;

    Attr.attrTyp = ATT_REVISION;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    CommArg = &(ModArg.CommArg);
    BuildStdCommArg( CommArg );

    DirError = DirModifyEntry( &ModArg, &ModRes );

    if (NULL == ModRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError,&ModRes->CommRes);
    }

Cleanup:


    if ( fTransOpen )
    {
        NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

        IgnoreStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ? 
                                                  TransactionCommit : TransactionAbort
                                                );
    }

    return( NtStatus );
}




NTSTATUS
SampCheckAndAddWellKnownAccounts(
    IN PVOID Parameter
    )
/*++

Routine Description:

    This routine check DS Revision on SAM Server Object, 
    if the revision number is not equal to currnet DSRevision, 
    we are going to upgrade WellKnown Accounts, otherwise, do nothing. 
    
Parameter:

    Parameter - no use
    
Return Value:

    NtStatus Code

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    SAMPR_HANDLE    ServerHandle = 0;
    SAMPR_HANDLE    DomainHandle = 0;
    SAMPR_HANDLE    BuiltinDomainHandle = 0;
    PPOLICY_ACCOUNT_DOMAIN_INFO  DomainInfo = NULL;
    ULONG           DsRevision = 0;


    ASSERT( SampUseDsData );

    //
    // Get current revision number
    // 

    NtStatus = SampDsGetServerRevision(&DsRevision);

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // do nothing if it is up to date.
    // 

    if (SAMP_DS_REVISION == DsRevision)
    {
        NtStatus = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Open the server
    // 
    NtStatus = SampConnect(NULL,            // server name
                           &ServerHandle,
                           SAM_CLIENT_LATEST,
                           GENERIC_ALL,    // all access
                           TRUE,           // trusted client
                           FALSE,
                           FALSE,          // NotSharedByMultiThreads 
                           TRUE
                           );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Get the current domain's sid
    //
    NtStatus = SampGetAccountDomainInfo(&DomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }
    ASSERT(DomainInfo);
    ASSERT(DomainInfo->DomainSid);

    //
    // Open the current domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              DomainInfo->DomainSid,
                              &DomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Open the builtin domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              SampBuiltinDomainSid,
                              &BuiltinDomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Add Well Known Accounts
    //

    NtStatus = SampAddWellKnownAccounts(DomainHandle,
                                        BuiltinDomainHandle,
                                        SAMP_PROMOTE_INTERNAL_UPGRADE
                                        );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SampAddAnonymousToPreW2KCompAlias(
                                        DomainHandle,
                                        BuiltinDomainHandle
                                        );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // all success, update DS Revision to current
    //

    DsRevision = SAMP_DS_REVISION;

    NtStatus = SampDsSetServerRevision(DsRevision);

Cleanup:

    //
    // if failed, schedule another run
    // 

    if (!NT_SUCCESS(NtStatus))
    {
        LsaIRegisterNotification(
            SampCheckAndAddWellKnownAccounts,
            (PVOID) NULL,   // no parameter
            NOTIFIER_TYPE_INTERVAL,
            0,              // no class
            NOTIFIER_FLAG_ONE_SHOT,
            60,             // wait one minute
            NULL            // no handle
            );
    }

    if (ServerHandle) {
        SamrCloseHandle(&ServerHandle);
    }

    if (DomainHandle) {
        SamrCloseHandle(&DomainHandle);
    }

    if (BuiltinDomainHandle) {
        SamrCloseHandle(&BuiltinDomainHandle);
    }

    if (DomainInfo) {
        LsaIFree_LSAPR_POLICY_INFORMATION (PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)DomainInfo);
    }
    
    return( NtStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\pek.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        pek.cxx
//
// Contents:    Routines for Password encryption-decryption
//              and key management. Handles Password encryption and
//              decryption in registry mode. In DS mode does no
//              encryption/decryption --- encryption/decryption done by
//              DS.
//
//
// History:     5 December 1997        Created
//
//------------------------------------------------------------------------




#include <ntdspch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntsam.h>
#include <samrpc.h>
#include <ntsamp.h>
#include <samisrv.h>
#include <samsrvp.h>
#include <dslayer.h>
#include <cryptdll.h>
#include <wincrypt.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>
#include <attids.h>
#include <filtypes.h>
#include <lmaccess.h>

/////////////////////////////////////////////////////////////////////
//
//  Services Pertiaining to Encryption and Decryption of Secret
//  Data Attributes.
//
/////////////////////////////////////////////////////////////////////


USHORT
SampGetEncryptionKeyType()
/*++

    Obtains the Correct Key Id for use on Encryption, depending
    upon DS or Registry Mode

    Parameters:

        None

    Return Values

        Key Id for use on Encryption
--*/
{
    //
    // In registry mode encryption is performed by using the
    // 128 bit password encryption key stored in the domain 
    // object and salting the key with the RID of the account
    // and a constant that describes the attribute. In DS mode
    // No encryption is performed by SAM, the base DS handles the
    // encryption -- look at ds\ds\src\ntdsa\pek\pek.c 
    //

    if (SampSecretEncryptionEnabled)
    {
        if (SampUseDsData)
            //
            // In DS mode encryption is handled by DS.
            //
            return SAMP_NO_ENCRYPTION;
        else
            return SAMP_DEFAULT_SESSION_KEY_ID;
    }
    else
        return SAMP_NO_ENCRYPTION;
}

PUCHAR 
SampMagicConstantFromDataType(
       IN SAMP_ENCRYPTED_DATA_TYPE DataType,
       OUT PULONG ConstantLength
       )
{
    switch(DataType)
    {
       case LmPassword:
            *ConstantLength = sizeof("LMPASSWORD");
            return("LMPASSWORD");
       case NtPassword:
            *ConstantLength = sizeof("NTPASSWORD");
            return("NTPASSWORD");
       case NtPasswordHistory:
            *ConstantLength = sizeof("NTPASSWORDHISTORY");
            return("NTPASSWORDHISTORY");
       case LmPasswordHistory:
            *ConstantLength = sizeof("LMPASSWORDHISTORY");
            return("LMPASSWORDHISTORY");
       case MiscCredentialData:
            *ConstantLength = sizeof("MISCCREDDATA");
            return("MISCCREDDATA");
       default:
            break;
    }

    ASSERT(FALSE && "Should not happen");
    *ConstantLength = 0;
    return(NULL);
} 
  

NTSTATUS
SampEncryptSecretData(
    OUT PUNICODE_STRING EncryptedData,
    IN  USHORT          EncryptionType,
    IN  SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN  PUNICODE_STRING ClearData,
    IN  ULONG Rid
    )
/*++

Routine Description:

    This routine encrypts sensitive data. The encrypted data is allocated and
    should be free with SampFreeUnicodeString.


Arguments:

    EncryptedData - Receives the encrypted data and may be freed with
        SampFreeUnicodeString. The

    EncryptionType  - Specifies the Type of Encryption to Use.

    ClearData - Contains the clear data to encrypt. The length may be
        zero.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate the
        output.

--*/
{
    PSAMP_SECRET_DATA SecretData;
    struct RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    UCHAR * KeyToUse;
    ULONG   KeyLength;
    PUCHAR  ConstantToUse=NULL;
    ULONG   ConstantLength = 0;

    ASSERT(ENCRYPTED_LM_OWF_PASSWORD_LENGTH == ENCRYPTED_NT_OWF_PASSWORD_LENGTH);

    ASSERT(!SampIsDataEncrypted(ClearData));

    //
    // If encryption is not enabled, or caller does not want encryption,
    // do nothing special.
    //

    if ((!SampSecretEncryptionEnabled) || (SAMP_NO_ENCRYPTION==EncryptionType)) {
        return(SampDuplicateUnicodeString(
                EncryptedData,
                ClearData
                ));
    }

    //
    // Compute the size of the output buffer and allocate it.
    //

    EncryptedData->Length = SampSecretDataSize(ClearData->Length);
    EncryptedData->MaximumLength = EncryptedData->Length;

    EncryptedData->Buffer = (LPWSTR) MIDL_user_allocate(EncryptedData->Length);
    if (EncryptedData->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    SecretData = (PSAMP_SECRET_DATA) EncryptedData->Buffer;
    SecretData->Flags = SAMP_ENCRYPTION_FLAG_PER_TYPE_CONST;
    SecretData->KeyId = (USHORT) SampCurrentKeyId;
    ConstantToUse = SampMagicConstantFromDataType(DataType,&ConstantLength);

    switch(EncryptionType)
    {
    case SAMP_DEFAULT_SESSION_KEY_ID:
        ASSERT(FALSE==SampUseDsData);
        if (TRUE==SampUseDsData)
        {
            return STATUS_INTERNAL_ERROR;
        }

        KeyToUse = SampSecretSessionKey;
        KeyLength = SAMP_SESSION_KEY_LENGTH;
        break;

    default:
        ASSERT("Unknown Key Type Specified");
        return STATUS_INTERNAL_ERROR;
        break;

    }

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        KeyToUse,
        KeyLength
        );

    MD5Update(
        &Md5Context,
        (PUCHAR) &Rid,
        sizeof(ULONG)
        );

    MD5Update(
        &Md5Context,
        ConstantToUse,
        ConstantLength 
        );

    MD5Final(
        &Md5Context
        );

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

    //
    // Only encrypt if the length is greater than zero - RC4 can't handle
    // zero length buffers.
    //

    if (ClearData->Length > 0) {

        RtlCopyMemory(
            SecretData->Data,
            ClearData->Buffer,
            ClearData->Length
            );

        rc4(
            &Rc4Key,
            ClearData->Length,
            SecretData->Data
            );

    }


    return(STATUS_SUCCESS);

}


NTSTATUS
SampDecryptSecretData(
    OUT PUNICODE_STRING ClearData,
    IN SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN PUNICODE_STRING EncryptedData,
    IN ULONG Rid
    )
/*++

Routine Description:

    This routine decrypts sensitive data encrypted by SampEncryptSecretData().
    The clear data is allocated and should be free with SampFreeUnicodeString.
    The default session key with the default algorithm is used.


Arguments:

    ClearData - Contains the decrypted data. The length may be
        zero. The string should be freed with SampFreeUnicodeString.

    EncryptedData - Receives the encrypted data and may be freed with
        SampFreeUnicodeString.

    Rid - Rid to salt the data.


Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate the
        output.

--*/
{
    PSAMP_SECRET_DATA SecretData;
    struct RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    UCHAR * KeyToUse;
    ULONG   KeyLength;
    ULONG   Key;

    //
    // If encryption is not enabled, do nothing special.
    //

    if (!SampSecretEncryptionEnabled ||
        !SampIsDataEncrypted(EncryptedData)) {

        //
        // If secret encryption is enabled, than it is possible that early
        // releases of NT4 SP3 didn't decrypt a password before sticking
        // it in the history. If this is the case then return a null
        // string as the history.
        //


        if ((SampSecretEncryptionEnabled) &&
            ((EncryptedData->Length % ENCRYPTED_NT_OWF_PASSWORD_LENGTH) != 0)) {
            return(SampDuplicateUnicodeString(
                    ClearData,
                    &SampNullString
                    ));
        }


        return(SampDuplicateUnicodeString(
                ClearData,
                EncryptedData
                ));
    }

    //
    // Make sure the data has actually been encrypted.
    //

    ASSERT(ENCRYPTED_LM_OWF_PASSWORD_LENGTH == ENCRYPTED_NT_OWF_PASSWORD_LENGTH);
    ASSERT(SampIsDataEncrypted(EncryptedData));

    SecretData = (PSAMP_SECRET_DATA) EncryptedData->Buffer;
    
    //
    // Make sure we still have the correct key
    //

    if ((SecretData->KeyId !=SampCurrentKeyId) &&
       (SecretData->KeyId !=SampPreviousKeyId))
    {
        return(STATUS_INTERNAL_ERROR);
    }

    //
    // Compute the size of the output buffer and allocate it.
    //

    ClearData->Length = SampClearDataSize(EncryptedData->Length);
    ClearData->MaximumLength = ClearData->Length;

    //
    // If there was no data we can return now.
    //

    if (ClearData->Length == 0)
    {
        ClearData->Buffer = NULL;
        return(STATUS_SUCCESS);
    }

    ClearData->Buffer = (LPWSTR) MIDL_user_allocate(ClearData->Length);
    if (ClearData->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Find the Key to Use
    //

    if (SecretData->KeyId == SampCurrentKeyId)
    {
        KeyToUse = SampSecretSessionKey;
        KeyLength = SAMP_SESSION_KEY_LENGTH;
    } 
    else 
    {
        ASSERT(SecretData->KeyId==SampPreviousKeyId);

        KeyToUse = SampSecretSessionKeyPrevious;
        KeyLength = SAMP_SESSION_KEY_LENGTH;
    }

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        KeyToUse,
        KeyLength
        );

    MD5Update(
        &Md5Context,
        (PUCHAR) &Rid,
        sizeof(ULONG)
        );

    if ((SecretData->Flags & SAMP_ENCRYPTION_FLAG_PER_TYPE_CONST)!=0)
    {
        ULONG  ConstantLength = 0;
        PUCHAR ConstantToUse = SampMagicConstantFromDataType(DataType,&ConstantLength);


        MD5Update(
            &Md5Context,
            ConstantToUse,
            ConstantLength
            );
    } 
     
    MD5Final(
        &Md5Context
        );

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

    RtlCopyMemory(
        ClearData->Buffer,
        SecretData->Data,
        ClearData->Length
        );

    rc4(
        &Rc4Key,
        ClearData->Length,
        (PUCHAR) ClearData->Buffer
        );


    return(STATUS_SUCCESS);

}


        
        

        
NTSTATUS
SampEncryptDSRMPassword(
    OUT PUNICODE_STRING EncryptedData,
    IN  USHORT          EncryptionType,
    IN  SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN  PUNICODE_STRING ClearData,
    IN  ULONG Rid
    )
/*++

Routine Description:

    This routine encrypts password using SAM password encryption key.

    The encrypted password is allocated and should be free with 
    SampFreeUnicodeString.

    This routine will be used by SamrSetDSRMPassword ONLY.

Arguments:

    EncryptedData - Receives the encrypted data and may be freed with
        SampFreeUnicodeString. The

    KeyId         - Specifies the Type of Encryption to Use.

    ClearData - Contains the clear data to encrypt. The length may be
        zero.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate the
        output.

--*/
{
    PSAMP_SECRET_DATA SecretData;
    struct RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    UCHAR * KeyToUse;
    ULONG   KeyLength;
    PUCHAR  ConstantToUse=NULL;
    ULONG   ConstantLength = 0;

    ASSERT(ENCRYPTED_LM_OWF_PASSWORD_LENGTH == ENCRYPTED_NT_OWF_PASSWORD_LENGTH);

    ASSERT(!SampIsDataEncrypted(ClearData));

    //
    // If encryption is not enabled, or caller does not want encryption,
    // do nothing special.
    //

    if ((!SampSecretEncryptionEnabled) || (SAMP_NO_ENCRYPTION==EncryptionType)) {
        return(SampDuplicateUnicodeString(
                EncryptedData,
                ClearData
                ));
    }

    //
    // Compute the size of the output buffer and allocate it.
    //

    EncryptedData->Length = SampSecretDataSize(ClearData->Length);
    EncryptedData->MaximumLength = EncryptedData->Length;

    EncryptedData->Buffer = (LPWSTR) MIDL_user_allocate(EncryptedData->Length);
    if (EncryptedData->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    SecretData = (PSAMP_SECRET_DATA) EncryptedData->Buffer;
    SecretData->Flags = SAMP_ENCRYPTION_FLAG_PER_TYPE_CONST;
    SecretData->KeyId = (USHORT) SampCurrentKeyId;
    ConstantToUse = SampMagicConstantFromDataType(DataType,&ConstantLength);

    KeyToUse = SampSecretSessionKey;
    KeyLength = SAMP_SESSION_KEY_LENGTH;

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        KeyToUse,
        KeyLength
        );

    MD5Update(
        &Md5Context,
        (PUCHAR) &Rid,
        sizeof(ULONG)
        );

    MD5Update(
        &Md5Context,
        ConstantToUse,
        ConstantLength 
        );

    MD5Final(
        &Md5Context
        );

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

    //
    // Only encrypt if the length is greater than zero - RC4 can't handle
    // zero length buffers.
    //

    if (ClearData->Length > 0) {

        RtlCopyMemory(
            SecretData->Data,
            ClearData->Buffer,
            ClearData->Length
            );

        rc4(
            &Rc4Key,
            ClearData->Length,
            SecretData->Data
            );

    }


    return(STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\rng.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology 
* reference implementation, version 1.0
* 
* The Private Communication Technology reference implementation, version 1.0 
* ("PCTRef"), is being provided by Microsoft to encourage the development and 
* enhancement of an open standard for secure general-purpose business and 
* personal communications on open networks.  Microsoft is distributing PCTRef 
* at no charge irrespective of whether you use PCTRef for non-commercial or 
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without 
* warranty of any kind, either express or implied, including, without 
* limitation, the implied warranties or merchantability, fitness for a 
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out 
* of use or performance of PCTRef remains with you.
* 
* Please see the file LICENSE.txt, 
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
* 
* Please see http://pct.microsoft.com/pct/pct.htm for The Private 
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

VOID
STInitializeRNG(VOID);

VOID
STShutdownRNG(VOID);


VOID
STGenerateRandomBits(
    PUCHAR      pRandomData,
    ULONG       cRandomData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\samrpc_s_stub.c ===
#include "samrpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\samsrvp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    samsrvp.h

Abstract:

    This file contains definitions private to the SAM server program.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    JimK        04-Jul-1991
        Created initial file.
    ChrisMay    10-Jun-1996
        Added macros and flags/defines for IsDsObject tests.
    Murlis      27-Jun-1996
        Moved SAMP_OBJECT_TYPE and mapping table structure defines
        to mappings.h in dsamain\src\include
    ColinBr     08-Aug-1996
        Added new ASSERT definitions
    ChrisMay    05-Dec-1996
        Moved SampDiagPrint to dbgutilp.h with the rest of the debugging
        routines and definitions.

--*/

#ifndef _NTSAMP_
#define _NTSAMP_


#ifndef UNICODE
#define UNICODE
#endif // UNICODE

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                                                                    //
//      Diagnostics                                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////

#define SAMP_DIAGNOSTICS 1


// Macro to align buffer data on DWORD boundary.

#define SampDwordAlignUlong( v )  (((v)+3) & 0xfffffffc)

//
// Maximum number of digits that may be specified to
// SampRtlConvertRidToUnicodeString
//

#define SAMP_MAXIMUM_ACCOUNT_RID_DIGITS    ((ULONG) 8)

//
// Account never expires timestamp (in ULONG form )
//

#define SAMP_ACCOUNT_NEVER_EXPIRES         ((ULONG) 0)



//
// SAM's shutdown order level (index).
// Shutdown notifications are made in the order of highest level
// to lowest level value.
//

#define SAMP_SHUTDOWN_LEVEL                 ((DWORD) 481)



// Define a Macro to set and unset the state of the DS object in the Context
// blob.

#define SAMP_REG_OBJECT                     ((ULONG) 0x00000001)
#define SAMP_DS_OBJECT                      ((ULONG) 0x00000002)


// Define a Macro to set and Unset the state of the DS object
// in the Context blob

#define SetDsObject(c)    ((c->ObjectFlags) |= SAMP_DS_OBJECT);\
                          ((c->ObjectFlags) &= ~(SAMP_REG_OBJECT));


#define SetRegistryObject(c)  ((c->ObjectFlags) |= SAMP_REG_OBJECT);\
                              ((c->ObjectFlags) &= ~(SAMP_DS_OBJECT));


//Define a Macro to check if the object is in the DS
#define IsDsObject(c)       (((c->ObjectFlags)& SAMP_DS_OBJECT)==SAMP_DS_OBJECT)


// Define a Macro to obtain the domain object given an account Object
#define DomainObjectFromAccountContext(C)\
            SampDefinedDomains[C->DomainIndex].Context->ObjectNameInDs

// Define a Macro to obtain the domain Sid given the account object
#define DomainSidFromAccountContext(C)\
            SampDefinedDomains[C->DomainIndex].Sid


// Define a Macro to access the Root Domain Object

#define ROOT_OBJECT     ((DSNAME *) RootObjectName)

// Macro to test wether DownLevelDomainControllers are present in the system
#define DownLevelDomainControllersPresent(DomainIndex)  (SampDefinedDomains[DomainIndex].IsMixedDomain)

// Macro to compute a DsName given and OrName
#define DSNAME_FROM_ORNAME(ORName)  ((DSNAME *)((UCHAR *) ORName + (ULONG) ORName->DN.pDN))


// Define a Macro for ARRAY Counts
#define ARRAY_COUNT(x)  (sizeof(x)/sizeof(x[0]))

// Define a Macro for Absolute Value
#define ABSOLUTE_VALUE(x) ((x<0)?(-x):x)

//
// Macro to help with RTL_BITMAP.
//
// b is the number of bits desired in the bitmap
//
#define SAMP_BITMAP_ULONGS_FROM_BITS(b) ((b + 31) / 32)

#define DOMAIN_START_DS 2
#define DOMAIN_START_REGISTRY 0

// Defines the maximum number of Sids that we will return in a reverse membership
// call.
#define MAX_SECURITY_IDS    1000

// Define a macro to find out wether the domain is a builtin domain
#define IsBuiltinDomain(x) (SampDefinedDomains[x].IsBuiltinDomain)

#define FLAG_ON(x, y)  ((y)==((x)&(y)))


#define SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX 1

#define DECLARE_CLIENT_REVISION(handle)\
    ULONG ClientRevision  = SampClientRevisionFromHandle(handle);




#define SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus)\
    SampMapNtStatusToClientRevision(ClientRevision,&NtStatus);\


// Defines the maximum number of members that can be added or removed from group/alias.
#if DBG

#define INIT_MEMBERSHIP_OPERATION_NUMBER   4
#define MAX_MEMBERSHIP_OPERATION_NUMBER    8

#else

#define INIT_MEMBERSHIP_OPERATION_NUMBER   16
#define MAX_MEMBERSHIP_OPERATION_NUMBER    5000

#endif


//
// Defines the value for incrementally read Group/Alias Membership
//

#if DBG

#define SAMP_READ_GROUP_MEMBERS_INCREMENT   10
#define SAMP_READ_ALIAS_MEMBERS_INCREMENT   10

#else

#define SAMP_READ_GROUP_MEMBERS_INCREMENT   500
#define SAMP_READ_ALIAS_MEMBERS_INCREMENT   500

#endif

//
// defines values for CONTROL used in SampMaybeAcquireReadLock
// 

#define DEFAULT_LOCKING_RULES                               0x0
#define DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED       0x1

//
// define a macro for alloca that traps any exceptions
//

#define SAMP_ALLOCA(y,x) \
   __try {\
     y = alloca(x);\
   } __except ( GetExceptionCode() == STATUS_STACK_OVERFLOW) {\
     /*_resetstkoflw();*/\
     y=NULL;\
   }


#define SAMP_CONTEXT_SIGNATURE          0xEE77FF88
 

#define SAMP_CLOSE_OPERATION_ACCESS_MASK    0xFFFFFFFF


#define SAMP_DEFAULT_LASTLOGON_TIMESTAMP_SYNC_INTERVAL          14 
#define SAMP_LASTLOGON_TIMESTAMP_SYNC_SWING_WINDOW               5

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h
#include <rpc.h>        // DataTypes and runtime APIs
#include <string.h>     // strlen
#include <stdio.h>      // sprintf

#define UnicodeTerminate(p) ((PUNICODE_STRING)(p))->Buffer[(((PUNICODE_STRING)(p))->Length + 1)/sizeof(WCHAR)] = UNICODE_NULL

#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <samrpc.h>     // midl generated SAM RPC definitions
#include <ntlsa.h>
#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <samisrv.h>    // SamIConnect()
#include <lsarpc.h>
#include <lsaisrv.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <samsrv.h>     // prototypes available to security process
#include "sampmsgs.h"
#include "lsathunk.h"
#include "dbgutilp.h"   // supplimental debugging routines
#include <mappings.h>


VOID
UnexpectedProblem( VOID );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ASSERT is a macro defined in ntrtl.h that calls RtlAssert which is a      //
// in ntdll.dll that is only defined when DBG == 1, hece requiring a checked //
// ntdll.dll, hence a checked system.                                        //
//                                                                           //
// To allow ASSERT to break into a debugger when SAM is built with DBG == 1  //
// and still test it on a free system, ASSERT is redefined here to call a    //
// a private version of RtlAssert, namely SampAssert, when                    //
// SAMP_PRIVATE_ASSERT == 1.                                                 //
//                                                                           //
// Checked in versions of the file should have SAMP_PRIVATE_ASSERT == 0      //
// so for people outside the SAM world, ASSERT will have the action defined  //
// in ntrtl.h                                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifdef USER_MODE_SAM
    #define SAMP_PRIVATE_ASSERT 1
#else
    #define SAMP_PRIVATE_ASSERT 1
#endif

#if DBG

#define SUCCESS_ASSERT(Status, Msg)                                     \
{                                                                       \
    if ( !NT_SUCCESS(Status) ) {                                        \
        UnexpectedProblem();                                            \
        BldPrint(Msg);                                                  \
        BldPrint("Status is: 0x%lx \n", Status);                        \
        return(Status);                                                 \
                                                                        \
    }                                                                   \
}

#else

#define SUCCESS_ASSERT(Status, Msg)                                     \
{                                                                       \
    if ( !NT_SUCCESS(Status) ) {                                        \
        return(Status);                                                 \
    }                                                                   \
}

#endif // DBG


#if (DBG == 1) && (SAMP_PRIVATE_ASSERT == 1)

VOID
SampAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        SampAssert( #exp, __FILE__, __LINE__, NULL )

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        SampAssert( #exp, __FILE__, __LINE__, msg )

#else

// Follow the convention of the ASSERT definition in ntrtl.h

#endif // DBG

ULONG
SampTransactionDomainIndexFn();

#define SampTransactionDomainIndex SampTransactionDomainIndexFn()


BOOLEAN
SampTransactionWithinDomainFn();

#define SampTransactionWithinDomain SampTransactionWithinDomainFn()


VOID
SampSetTransactionWithinDomain(
    IN BOOLEAN  WithinDomain
    );

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Caller Types when calling  SampStoreUserPasswords                   //
//      PasswordChange  -- the caller trying to change password        //
//      PasswordSet     -- the caller trying to set password           //
//      PasswordPushPdc -- the caller trying to Push Password changes  //
//                         on PDC                                      //
//                                                                     //
// These caller types are used by WMI event trace                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef enum _SAMP_STORE_PASSWORD_CALLER_TYPE {
    PasswordChange = 1,
    PasswordSet,
    PasswordPushPdc
} SAMP_STORE_PASSWORD_CALLER_TYPE;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Structure for optimized(speed up) group/alias membership add/remove //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY {
    ULONG   OpType;         // ADD_VALUE or REMOVE_VALUE
    PDSNAME MemberDsName;       // Pointer to DSNAME
} SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY, *PSAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Structure for User Parameter Migration                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_SUPPLEMENTAL_CRED {
    struct _SAMP_SUPPLEMENTAL_CRED * Next;
    SECPKG_SUPPLEMENTAL_CRED SupplementalCred;
    BOOLEAN     Remove;
} SAMP_SUPPLEMENTAL_CRED, *PSAMP_SUPPLEMENTAL_CRED;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Structure for User Site Affinity                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_SITE_AFFINITY {

    GUID SiteGuid;
    LARGE_INTEGER TimeStamp;

} SAMP_SITE_AFFINITY, *PSAMP_SITE_AFFINITY;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macro to define SAM Attribute access bitmap                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(x)                           \
    ULONG x##Buffer[SAMP_BITMAP_ULONGS_FROM_BITS(MAX_SAM_ATTRS)];      \
    RTL_BITMAP x;

#define SAMP_INIT_SAM_ATTRIBUTE_BITMASK(x)                             \
    RtlInitializeBitMap(&x,                                            \
                        (x##Buffer),                                   \
                        MAX_SAM_ATTRS );                               \
    RtlClearAllBits(&x);

#define SAMP_COPY_SAM_ATTRIBUTE_BITMASK(x,y)                             \
    RtlCopyMemory(x##Buffer,y##Buffer,sizeof(x##Buffer));
    

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TEMPORARY GenTab2 definitions                                             //
// These structures should be considered opaque.                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Each element in the tree is pointed to from a leaf structure.
// The leafs are linked together to arrange the elements in
// ascending sorted order.
//

typedef struct _GTB_TWO_THREE_LEAF {

    //
    // Sort order list links
    //

    LIST_ENTRY SortOrderEntry;

    //
    // Pointer to element
    //

    PVOID   Element;

} GTB_TWO_THREE_LEAF, *PGTB_TWO_THREE_LEAF;



typedef struct _GTB_TWO_THREE_NODE {

    //
    // Pointer to parent node.  If this is the root node,
    // then this pointer is null.
    //

    struct _GTB_TWO_THREE_NODE *ParentNode;


    //
    //  Pointers to child nodes.
    //
    //    1) If a pointer is null, then this node does not have
    //       that child.  In this case, the control value MUST
    //       indicate that the children are leaves.
    //
    //    2) If the children are leaves, then each child pointer
    //       is either NULL (indicating this node doesn't have
    //       that child) or points to a GTB_TWO_THREE_LEAF.
    //       If ThirdChild is Non-Null, then so is SecondChild.
    //       If SecondChild is Non-Null, then so is FirstChild.
    //       (that is, you can't have a third child without a
    //       second child, or a second child without a first
    //       child).
    //

    struct _GTB_TWO_THREE_NODE *FirstChild;
    struct _GTB_TWO_THREE_NODE *SecondChild;
    struct _GTB_TWO_THREE_NODE *ThirdChild;

    //
    // Flags provding control information about this node
    //

    ULONG   Control;


    //
    // These fields point to the element that has the lowest
    // value of all elements in the second and third subtrees
    // (respectively).  These fields are only valid if the
    // corresponding child subtree pointer is non-null.
    //

    PGTB_TWO_THREE_LEAF LowOfSecond;
    PGTB_TWO_THREE_LEAF LowOfThird;

} GTB_TWO_THREE_NODE, *PGTB_TWO_THREE_NODE;


//
//  The comparison function takes as input pointers to elements containing
//  user defined structures and returns the results of comparing the two
//  elements.  The result must indicate whether the FirstElement
//  is GreaterThan, LessThan, or EqualTo the SecondElement.
//

typedef
RTL_GENERIC_COMPARE_RESULTS
(NTAPI *PRTL_GENERIC_2_COMPARE_ROUTINE) (
    PVOID FirstElement,
    PVOID SecondElement
    );

//
//  The allocation function is called by the generic table package whenever
//  it needs to allocate memory for the table.
//

typedef
PVOID
(NTAPI *PRTL_GENERIC_2_ALLOCATE_ROUTINE) (
    CLONG ByteSize
    );

//
//  The deallocation function is called by the generic table package whenever
//  it needs to deallocate memory from the table that was allocated by calling
//  the user supplied allocation function.
//

typedef
VOID
(NTAPI *PRTL_GENERIC_2_FREE_ROUTINE) (
    PVOID Buffer
    );


typedef struct _RTL_GENERIC_TABLE2 {

    //
    // Pointer to root node.
    //

    PGTB_TWO_THREE_NODE Root;

    //
    // Number of elements in table
    //

    ULONG ElementCount;

    //
    // Link list of leafs (and thus elements) in sort order
    //

    LIST_ENTRY SortOrderHead;


    //
    // Caller supplied routines
    //

    PRTL_GENERIC_2_COMPARE_ROUTINE  Compare;
    PRTL_GENERIC_2_ALLOCATE_ROUTINE Allocate;
    PRTL_GENERIC_2_FREE_ROUTINE     Free;


} RTL_GENERIC_TABLE2, *PRTL_GENERIC_TABLE2;



//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Generic Table2 Routine Definitions...                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


typedef struct 
{
    UNICODE_STRING  AccountName;
    SAMP_OBJECT_TYPE    ObjectType;

} SAMP_ACCOUNT_NAME_TABLE_ELEMENT, *PSAMP_ACCOUNT_NAME_TABLE_ELEMENT;


typedef struct
{
    PSID    ClientSid;
    ULONG   ActiveContextCount;
} SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT, *PSAMP_ACTIVE_CONTEXT_TABLE_ELEMENT;



//NTSYSAPI
VOID
//NTAPI
RtlInitializeGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PRTL_GENERIC_2_COMPARE_ROUTINE  CompareRoutine,
    PRTL_GENERIC_2_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_GENERIC_2_FREE_ROUTINE     FreeRoutine
    );


//NTSYSAPI
PVOID
//NTAPI
RtlInsertElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PBOOLEAN NewElement
    );


//NTSYSAPI
BOOLEAN
//NTAPI
RtlDeleteElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    );


//NTSYSAPI
PVOID
//NTAPI
RtlLookupElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    );


//NTSYSAPI
PVOID
//NTAPI
RtlEnumerateGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID *RestartKey
    );


//NTSYSAPI
PVOID
//NTAPI
RtlRestartKeyByIndexGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    ULONG I,
    PVOID *RestartKey
    );

//NTSYSAPI
PVOID
//NTAPI
RtlRestartKeyByValueGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PVOID *RestartKey
    );

//NTSYSAPI
ULONG
//NTAPI
RtlNumberElementsGenericTable2(
    PRTL_GENERIC_TABLE2 Table
    );

//
//  The function IsGenericTableEmpty will return to the caller TRUE if
//  the generic table is empty (i.e., does not contain any elements)
//  and FALSE otherwise.
//

//NTSYSAPI
BOOLEAN
//NTAPI
RtlIsGenericTable2Empty (
    PRTL_GENERIC_TABLE2 Table
    );





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// This macro generates TRUE if account auditing is enabled and this
// server is a PDC.  Otherwise, this macro generates FALSE.
//
// SampDoAccountAuditing(
//      IN ULONG i
//      )
//
// Where:
//
//      i - is the index of the domain whose state is to be checked.
//

#define SampDoAccountAuditing( i )                       \
    (SampSuccessAccountAuditingEnabled == TRUE)

#define SampDoSuccessOrFailureAccountAuditing( i, Status )        \
    (((SampFailureAccountAuditingEnabled == TRUE) && (!NT_SUCCESS(Status)))\
      ||((SampSuccessAccountAuditingEnabled==TRUE) && (NT_SUCCESS(Status))))

//
// VOID
// SampSetAuditingInformation(
// IN PPOLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo
// )
//
// Routine Description:
//
// This macro function sets the Audit Event Information relevant to SAM
// given LSA Audit Events Information.
//
// Arguments:
//
//     PolicyAuditEventsInfo - Pointer to Audit Events Information
//         structure.
//
// Return Values:
//
//     None.
//

#define SampSetAuditingInformation( PolicyAuditEventsInfo ) {       \
                                                                    \
    if (PolicyAuditEventsInfo->AuditingMode &&                      \
           (PolicyAuditEventsInfo->EventAuditingOptions[ AuditCategoryAccountManagement ] & \
                POLICY_AUDIT_EVENT_SUCCESS)                         \
       ) {                                                          \
                                                                    \
        SampSuccessAccountAuditingEnabled = TRUE;                   \
                                                                    \
    } else {                                                        \
                                                                    \
        SampSuccessAccountAuditingEnabled = FALSE;                  \
    }                                                               \
  if (PolicyAuditEventsInfo->AuditingMode &&                      \
           (PolicyAuditEventsInfo->EventAuditingOptions[ AuditCategoryAccountManagement ] & \
                POLICY_AUDIT_EVENT_FAILURE)                         \
       ) {                                                          \
                                                                    \
        SampFailureAccountAuditingEnabled = TRUE;                   \
                                                                    \
    } else {                                                        \
                                                                    \
        SampFailureAccountAuditingEnabled = FALSE;                  \
    }                                                               \
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Defines                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// Major and minor revision are stored as a single 32-bit
// value with the major revision in the upper 16-bits and
// the minor revision in the lower 16-bits.
//
//      Major Revision:         1  - NT Version 1.0
//          Minor Revisions:        1 - NT Revision 1.0
//                                  2 - NT Revision 1.0A
//

#define SAMP_MAJOR_REVISION            (0x00010000)
#define SAMP_MINOR_REVISION_V1_0       (0x00000001)
#define SAMP_MINOR_REVISION_V1_0A      (0x00000002)
#define SAMP_MINOR_REVISION            (0x00000002)

//
// SAMP_REVISION is the revision at which the database is created. This is several
// revisions below than the current revision as the database creation code has been
// kept unchanged from years of yore
//

#define SAMP_REVISION                  (SAMP_MAJOR_REVISION + SAMP_MINOR_REVISION)
#define SAMP_NT4_SERVER_REVISION       (SAMP_REVISION + 1)
#define SAMP_NT4SYSKEY_SERVER_REVISION (SAMP_REVISION + 2)
#define SAMP_NT4SP7_SERVER_REVISION    (SAMP_REVISION + 3)
#define SAMP_WIN2K_REVISION            (SAMP_REVISION + 4)

// 
// The below is the current revision; it corresponds to the fix for sysprep for
// re-encrypting keys.
//

#define SAMP_WHISTLER_OR_W2K_SYSPREP_FIX_REVISION  (SAMP_REVISION + 5)

//
// SAMP_SERVER_REVISION is the current revision for registry mode SAM.
//

#define SAMP_SERVER_REVISION           (SAMP_WHISTLER_OR_W2K_SYSPREP_FIX_REVISION)

//
// SAMP_DS_REVISION is the revision level maintained on the sam server object in the DS 
//

#define SAMP_DS_REVISION               1

#define SAMP_UNKNOWN_REVISION( Revision )                  \
    ( ((Revision & 0xFFFF0000) > SAMP_MAJOR_REVISION)  ||  \
        (Revision > SAMP_SERVER_REVISION) )                \


//
// Maximum supported name length (in bytes) for this revision...
//

#define SAMP_MAXIMUM_NAME_LENGTH       (1024)

//
// Maximum length of a downlevel user name
//

#define SAMP_MAX_DOWN_LEVEL_NAME_LENGTH (20)


//
// Maximum amount of memory anyone can ask us to spend on a single
// request
//

#define SAMP_MAXIMUM_MEMORY_TO_USE     (4096*4096)


//
// Maximum allowable number of object opens.
// After this, opens will be rejected with INSUFFICIENT_RESOURCES
//

#define SAMP_PER_CLIENT_MAXIMUM_ACTIVE_CONTEXTS (2048)

//
// Maximum number of clients can open objects at the same time
// After this, opens will be rejected with INSUFFICIENT_RESOURCES
//  
#define SAMP_MAXIMUM_CLIENTS_COUNT      (1024)


//
// The number of SAM Local Domains
//

#define SAMP_DEFINED_DOMAINS_COUNT  ((ULONG)  2)


//
// Defines the maximum number of well-known (restricted) accounts
// in the SAM database. Restricted accounts have rids less than this
// value. User-defined accounts have rids >= this value.
//

#define SAMP_RESTRICTED_ACCOUNT_COUNT  1000


//
// Maximum password history length.  We store OWFs (16 bytes) in
// a string (up to 64k), so we could have up to 4k.  However, that's
// much larger than necessary, and we'd like to leave room in case
// OWFs grow or somesuch.  So we'll limit it to 1k.
//

#define SAMP_MAXIMUM_PASSWORD_HISTORY_LENGTH    1024

//
// The default group attributes to return when anybody asks for them.
// This saves the expense of looking at the user object every time.
//


#define SAMP_DEFAULT_GROUP_ATTRIBUTES ( SE_GROUP_MANDATORY | \
                                        SE_GROUP_ENABLED | \
                                        SE_GROUP_ENABLED_BY_DEFAULT )

//
// This is the length in bytes of the session key used to encrypt secret
// (sensitive) information.
//

#define SAMP_SESSION_KEY_LENGTH 16

//
// Constants for encryption type. These constants control the behaviour
// SampEncryptSecretData and SampDecryptSecretData.
//
//   SAMP_NO_ENCRYPTION does no encryption. This is used in DS mode as
//   core DS is responsible for the encryption.
//
//   SAMP_DEFAULT_SESSION_KEY_ID indicates to SampEncryptSecretData 
//   that the encryption needs to be performed with using the Password
//   encryption key of registry mode SAM
//

#define SAMP_NO_ENCRYPTION              ((USHORT)0x0)
#define SAMP_DEFAULT_SESSION_KEY_ID     ((USHORT)0x01)

//
// This is the number of retries for entering the session key decryption key
//

#define SAMP_BOOT_KEY_RETRY_COUNT       3


//
// Flags for data stored in the encrypted form. The flags in the secret data
// structure are used to denote the various types of encryption algorithms/
// variations that have been implemented. A flags value of 0 corresponds to an
// RC4 encryption using an MD5 of the key and the RID. This type of encryption
// was introduced in NT 4.0 SP3.
//

//
// This flag specifies that the data encrypted did use different magic constants
// that correspond to the various encryption types below. This type of encryption
// does an MD5 with the key and the magic constant before doing an RC4 using the key
// and the data. This encryption was introduced in win2k and then backported to 
// NT 4.0 SP6a.
//
#define SAMP_ENCRYPTION_FLAG_PER_TYPE_CONST ((USHORT)0x1)

//
// This specifies the encrypted data type for various types of data that we
// expect to retrieve 
//

typedef enum _SAMP_ENCRYPTED_DATA_TYPE {
      LmPassword=1,
      NtPassword,
      LmPasswordHistory,
      NtPasswordHistory,
      MiscCredentialData
} SAMP_ENCRYPTED_DATA_TYPE;

//
// This is the mimumim number of history entries to store for the krbtgt
// account.
//


#define SAMP_KRBTGT_PASSWORD_HISTORY_LENGTH 3
#define SAMP_RANDOM_GENERATED_PASSWORD_LENGTH         16


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Each object has an associated set of attributes on disk.            //
// These attributes are divided into fixed-length and variable-length. //
// Each object type defines whether its fixed and variable length      //
// attributes are stored together or separately.                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define SAMP_SERVER_STORED_SEPARATELY  (FALSE)

#define SAMP_DOMAIN_STORED_SEPARATELY  (TRUE)

#define SAMP_USER_STORED_SEPARATELY    (TRUE)

#define SAMP_GROUP_STORED_SEPARATELY   (FALSE)

#define SAMP_ALIAS_STORED_SEPARATELY   (FALSE)




///////////////////////////////////////////////////////////////////////////////
//
// Data structures used for tracking allocated memory
//
///////////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_MEMORY {
    struct _SAMP_MEMORY *Next;
    PVOID               Memory;
} SAMP_MEMORY, *PSAMP_MEMORY;



///////////////////////////////////////////////////////////////////////////////
//
// Data structures used for enumeration
//
///////////////////////////////////////////////////////////////////////////////


typedef struct _SAMP_ENUMERATION_ELEMENT {
    struct _SAMP_ENUMERATION_ELEMENT *Next;
    SAMPR_RID_ENUMERATION Entry;
} SAMP_ENUMERATION_ELEMENT, *PSAMP_ENUMERATION_ELEMENT;


///////////////////////////////////////////////////////////////////////////////
//
// Data structures related to service administration
//
///////////////////////////////////////////////////////////////////////////////

//
// SAM Service operation states.
// Valid state transition diagram is:
//
//    Initializing ----> Enabled <====> Disabled ---> Shutdown -->Terminating
//                               <====> Demoted  ---> Shutdown -->Terminating
//

typedef enum _SAMP_SERVICE_STATE {
    SampServiceInitializing = 1,
    SampServiceEnabled,
    SampServiceDisabled,
    SampServiceDemoted,
    SampServiceShutdown,
    SampServiceTerminating
} SAMP_SERVICE_STATE, *PSAMP_SERVICE_STATE;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//     Enumeration context associated with Enumerating Accounts in the       //
//     DS. This maintains the State Information regarding Paged Results      //
//     type of search in the DS, on a per domain context basis.              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


typedef struct _SAMP_DS_ENUMERATION_CONTEXT {

    // Used to Link to other Objects of this Type
    LIST_ENTRY              ContextListEntry;
    // Pointer to a DS Restart Structure
    PRESTART                Restart;
    // The Enumeration Handle associated with this structure.
    SAM_ENUMERATE_HANDLE    EnumerateHandle;
} SAMP_DS_ENUMERATION_CONTEXT, *PSAMP_DS_ENUMERATION_CONTEXT;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Display State Information used to speed up query of display information //
//   when clients want to download the entire display information            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_DS_DISPLAY_STATE {
    PRESTART        Restart;
    DOMAIN_DISPLAY_INFORMATION DisplayInformation;
    ULONG           TotalAvailable;
    ULONG           TotalEntriesReturned;
    ULONG           NextStartingOffset;
} SAMP_DS_DISPLAY_STATE;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Data structures associated with object types                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



//
// Object type-dependent information
//

typedef struct _SAMP_OBJECT_INFORMATION {

    //
    // Generic mapping for this object type
    //

    GENERIC_MAPPING GenericMapping;


    //
    // Mask of access types that are not valid for
    // this object type when the access mask has been
    // mapped from generic to specific access types.
    //

    ACCESS_MASK InvalidMappedAccess;


    //
    // Mask of accesses representing write operations.  These are
    // used on a BDC to determine if an operation should be allowed
    // or not.
    //

    ACCESS_MASK WriteOperations;

    //
    // Name of the object type - used for auditing.
    //

    UNICODE_STRING  ObjectTypeName;


    //
    // The following fields provide information about the attributes
    // of this object and how they are stored on disk.  These values
    // are set at SAM initialization time and are not changed
    // thereafter.  NOTE: changing these values in the build will
    // result in an on-disk format change - so don't change them 
    //
    //
    //      FixedStoredSeparately - When TRUE indicates the fixed and
    //          variable-length attributes of the object are stored
    //          separately (in two registry-key-attributes).  When FALSE,
    //          indicates they are stored together (in a single
    //          registry-key-attribute).
    //
    //
    //      FixedAttributesOffset - Offset from the beginning of the
    //          on-disk buffer to the beginning of the fixed-length
    //          attributes structure.
    //
    //      VariableBufferOffset - Offset from the beginning of the
    //          on-disk buffer to the beginning of the Variable-length
    //          data buffer.  If fixed and variable-length data are
    //          stored together, this will be zero.
    //
    //      VariableArrayOffset - Offset from the beginning of the
    //          on-disk buffer to the beginning of the array of
    //          variable-length attributes descriptors.
    //
    //      VariableDataOffset - Offset from the beginning of the
    //          on-disk buffer to the beginning of the variable-length
    //          attribute data.
    //

    BOOLEAN FixedStoredSeparately;
    ULONG FixedAttributesOffset,
          VariableBufferOffset,
          VariableArrayOffset,
          VariableDataOffset;

    //
    // Indicates the length of the fixed length information
    // for this object type.
    //

    ULONG FixedLengthSize;

    //
    // The following fields provide information about the attributes of this
    // object. Modifying SAM to utilize the DS as the backing store for domain
    // account information, while still using the registry backing store for
    // workstation account information, means that there are two similar, but
    // slightly different data representations for SAM account information.
    //
    // All account information is represented in memory in terms of the fixed
    // and variable-length data buffers (as defined in earlier versions of the
    // SAM library). The source of the information, however, has changed in
    // that domain-account information (i.e. Domain Controller accounts) comes
    // from the DS backing store.
    //
    // Consequently, there is no need to store KEY_VALUE_PARTIAL_INFORMATION
    // within the SAM buffer (because that is registry specific).
    //
    // Additionally, because some of the DS data types are different from the
    // types used in previous SAM implementations, buffer offsets and lengths
    // have changed from those stored in the registry, and mapped into memory
    // by SAM code.
    //
    // The upshot of this is that whenever SAM buffers, constructed from the
    // registry information are referenced, the above offsets (e.g. Fixed-
    // AttributesOffset) are used. Alternatively, whenever SAM buffers, con-
    // structed from DS information are referenced, the below offsets (e.g
    // FixedDsAttributesOffset) are used.
    //

    ULONG FixedDsAttributesOffset,
          FixedDsLengthSize,
          VariableDsBufferOffset,
          VariableDsArrayOffset,
          VariableDsDataOffset;

    //
    // Indicates the number of variable length attributes
    // for this object type.
    //

    ULONG VariableAttributeCount;


} SAMP_OBJECT_INFORMATION, *PSAMP_OBJECT_INFORMATION;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// The  following structures represent the in-memory body of each      //
// object type.  This is typically used to link instances of object    //
// types together, and track dynamic state information related to      //
// the object type.                                                    //
//                                                                     //
// This information does not include the on-disk representation of     //
// the object data.  That information is kept in a separate structure  //
// both on-disk and when in-memory.                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// SERVER object in-memory body                                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_SERVER_OBJECT {
    ULONG Reserved1;
} SAMP_SERVER_OBJECT, *PSAMP_SERVER_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// DOMAIN object in-memory body                                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_DOMAIN_OBJECT {
    ULONG Reserved1;

    //
    // State information regarding the last display information reqest is
    // maintained in here. This is to allow fast restarts for clients that
    // want to download all the display information in one stroke
    //
    SAMP_DS_DISPLAY_STATE DsDisplayState;

} SAMP_DOMAIN_OBJECT, *PSAMP_DOMAIN_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// USER object in-memory body                                          //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_USER_OBJECT {
    ULONG   Rid;

    //
    // LockoutTime is set to the current time when an account becomes
    // locked out due to too many invalid password attempts. Lockout-
    // Time is set to zero when the account is unlocked.
    //

    LARGE_INTEGER   LockoutTime;

    //
    // LastLogonTimeStamp is set to the value of LastLogon if the
    // difference is greater than 7 days (or by any registry setting)
    // 

    LARGE_INTEGER   LastLogonTimeStamp;

    //
    // Supplemental credentials of a user object can be
    // cached in the context. The following 3 fields are
    // used to hold it
    //

    PVOID   CachedSupplementalCredentials;
    ULONG   CachedSupplementalCredentialLength;
    BOOLEAN CachedSupplementalCredentialsValid;

    //
    // Writes of supplemental credentials are held as a linked list
    // in this field and then combined with other writes when the
    // context is flushed to disk.
    //

    PSAMP_SUPPLEMENTAL_CRED SupplementalCredentialsToWrite;

    //
    // Old UserParameters Attribute, when doing UserParms Migration,
    // we are required to provide the old UserParms Value, so we cache
    // the old UserParms value and length at here.
    //

    PVOID   CachedOrigUserParms;
    ULONG   CachedOrigUserParmsLength;
    BOOLEAN CachedOrigUserParmsIsValid;

    //
    // Bit to keep an access check result, wether the
    // user has access to domain password information
    //
    BOOLEAN DomainPasswordInformationAccessible;

    //
    // Indicates that the context was returned as part of a machine,
    // account creation as a privilege. Such a context is only allowed
    // access to set only the password of the user described by the
    // context, as that is the only other operation in a machine join.
    //

    BOOLEAN PrivilegedMachineAccountCreate;

    //
    // Used to hold if user parms information is accessible ( bit to
    // to keep an access check result
    //

    BOOLEAN UparmsInformationAccessible;

    //
    // Pointer to the Domain SId, used by NT4 Security Descriptor to
    // NT5 SD Conversion Routine. In normal running, it should always be NULL.
    // Only set to point to the Domain SID during dcpromo time.
    //

    PSID    DomainSidForNt4SdConversion;

    //
    // Holds the UPN of the user
    //

    UNICODE_STRING  UPN;

    BOOLEAN UpnDefaulted;

    //
    // Information pertaining to the site affinity of a user.  Only used
    // in branch office scenarios
    //
    SAMP_SITE_AFFINITY SiteAffinity;

    //
    // Used to indicate whether a user handle should be checked for
    // site affinity.
    //
    BOOLEAN fCheckForSiteAffinityUpdate;

    //
    // This flag indicates that non-universal groups were not obtained
    // due to lack of a GC
    //
    BOOLEAN fNoGcAvailable;

    //
    // Information about the client location
    //
    SAM_CLIENT_INFO ClientInfo;

    //
    // A2D2 attribute ( A2D2 stands for authenticated to delegation to )
    // and this attribute is really an array  of SPN's.
    //

    PUSER_ALLOWED_TO_DELEGATE_TO_LIST A2D2List;

} SAMP_USER_OBJECT, *PSAMP_USER_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// GROUP object in-memory body                                         //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_GROUP_OBJECT {
    ULONG Rid;
    NT4_GROUP_TYPE NT4GroupType;
    NT5_GROUP_TYPE NT5GroupType;
    BOOLEAN        SecurityEnabled;
    ULONG          CachedMembershipOperationsListMaxLength;
    ULONG          CachedMembershipOperationsListLength;
    SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY   * CachedMembershipOperationsList;
} SAMP_GROUP_OBJECT, *PSAMP_GROUP_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// ALIAS object in-memory body                                         //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ALIAS_OBJECT {
    ULONG Rid;
    NT4_GROUP_TYPE NT4GroupType;
    NT5_GROUP_TYPE NT5GroupType;
    BOOLEAN        SecurityEnabled;
    ULONG          CachedMembershipOperationsListMaxLength;
    ULONG          CachedMembershipOperationsListLength;
    SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY   * CachedMembershipOperationsList;
} SAMP_ALIAS_OBJECT, *PSAMP_ALIAS_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                                                                     //
// The following data structure is the in-memory context associated    //
// with an open object.                                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_OBJECT {


    //
    // Structure used to link this structure into lists
    //

    LIST_ENTRY ContextListEntry;

    //
    // Indicates the type of object stored.
    // This is used to access an array of object type descriptors.
    //

    SAMP_OBJECT_TYPE ObjectType;


    //
    // The FixedValid and VariableValid indicate whether the data in
    // the fixed and variable-length on-disk image buffers are valid
    // (i.e., were read from disk) or invalid (uninitialized).
    // TRUE indicates the attribute is valid, FALSE indicates it is not.
    //

    BOOLEAN FixedValid:1;
    BOOLEAN VariableValid:1;


    //
    // The following flags indicate whether the fixed and/or variable
    // length attributes portion of this object are dirty (i.e., have
    // been changed since read from disk).  If TRUE, then the data is
    // dirty and will have to be flushed upon commit.  These flags are
    // only meaningful if the corresponding FixedValid or VariableValid
    // flag is TRUE.
    //
    // When attributes are read from disk, the data is said to be
    // "clean".  If any changes are made to that data, then it is
    // said to be "dirty".  Dirty object attributes will be flushed
    // to disk when the object is de-referenced at the end of a
    // client call.
    //

    BOOLEAN FixedDirty:1;
    BOOLEAN VariableDirty:1;


    //
    // This field indicates a context block is to be deleted.
    // Actual deallocation of the memory for the context block
    // will not occur until the reference count drops to zero.
    //

    BOOLEAN MarkedForDelete:1;

    //
    // This field is used to indicate that the client associated with
    // this context block is to be fully trusted.  When TRUE, no access
    // checks are performed against the client.  This allows a single
    // interface to be used by both RPC clients and internal procedures.
    //

    BOOLEAN TrustedClient:1;

    //
    // This field indicates that the context handle was created to service
    // a SAM loopback request from the DS. This is similar to the trusted
    // bit in that no access checks are performed. However trusted by passes
    // many other consistency checks while loopback will not bypass them
    //

    BOOLEAN LoopbackClient:1;


    //
    // This flag is TRUE when this context is valid.  It may be necessary
    // to invalidate before we can eliminate all references to it due to
    // the way RPC works.  RPC will only allow you to invalidate a context
    // handle when called by the client using an API that has the context
    // handle as an OUT parameter.
    //
    // Since someone may delete a user or group object (which invalidates
    // all handles to that object), we must have a way of tracking handle
    // validity independent of RPC's method.
    //

    BOOLEAN Valid:1;

    ULONG   Signature;

    //
    // This flag, tells the SAM routines wether it is safe to avoid locking
    // the database before queries. This allows to multi-thread calls.
    // When a context is declared as thread safe it is not added to the list
    // of context's kept in memory ( the reason for the exclusion ).
    //

    BOOLEAN NotSharedByMultiThreads:1;

    //
    // This flag is used during new SAM Account Creation and 
    // existing Account Rename. It indicates whether the caller should 
    // remove the accoount name from the in memory SAM Account Name Table 
    // or not. 
    //

    BOOLEAN RemoveAccountNameFromTable:1;


    //
    // This Flag Tells the Commit code that a lazy flush is O.K
    //

    BOOLEAN LazyCommit:1;

    //
    // This flag indicates that it is ok to persist OnDiskData across
    // multiple SAM calls. Helps logon as logon providers like to open
    // a user handle and then query the handle multiple times.
    //

    BOOLEAN PersistAcrossCalls:1;


    //
    // This flag indicates that it is ok to buffer writes to the on disk
    // structure in the context. The actual write is then performed at close
    // handle time
    //

    BOOLEAN BufferWrites:1;

    //
    // This flag indicates to urgent replicate any change made in the context
    // when flushing its contents to the ds
    //
    BOOLEAN ReplicateUrgently:1;

    //
    // This flag indicates that the context is being opened by server side 
    // code internally in the LSA.
    //
    BOOLEAN OpenedBySystem:1;


    //
    // Indicates this context was opened as part of migrating a user from
    // registry SAM to DS as part of Dcpromo.
    //

    BOOLEAN OpenedByDCPromo:1;

    //
    // This flag indicates that only some of the attributes in the PVOID structure
    // in the context are valid.
    //

    BOOLEAN AttributesPartiallyValid:1;


    //
    // This is the set of per attribute valid bits. This is a 64 Bit integer
    // and can handle upto 64 attributes
    //

    RTL_BITMAP  PerAttributeInvalidBits;

    //
    // The Buffer where the per attribute dirty bits are stored
    //

    ULONG       PerAttributeInvalidBitsBuffer[MAX_SAM_ATTRS/sizeof(ULONG)];


    //
    // This is the set of per attribute dirty bits. This is a 64 Bit integer
    // and can handle upto 64 attributes
    //

    RTL_BITMAP  PerAttributeDirtyBits;

    //
    // The Buffer where the per attribute dirty bits are stored
    //

    ULONG       PerAttributeDirtyBitsBuffer[MAX_SAM_ATTRS/sizeof(ULONG)];

    //
    // This field points to the on-disk attributes of the object.  This
    // is one of:
    //               SAMP_ON_DISK_SERVER_OBJECT
    //               SAMP_ON_DISK_DOMAIN_OBJECT
    //               SAMP_ON_DISK_USER_OBJECT
    //               SAMP_ON_DISK_GROUP_OBJECT
    //               SAMP_ON_DISK_ALIAS_OBJECT
    //
    // The memory pointed to by this field is one allocation unit, even
    // if fixed and variable length attributes are stored as seperate
    // registry key attributes.  This means that any time additions to
    // the variable length attributes causes a new buffer to be allocated,
    // both the fixed and variable length portions of the structure must
    // be copied to the newly allocated memory.
    //

    PVOID OnDisk;


    //
    // The OnDiskAllocated, OnDiskUsed, and OnDiskFree fields describe the
    // memory pointed to by the OnDisk field.  The OnDiskAllocated field
    // indicates how many bytes long the block of memory is.  The OnDiskUsed
    // field indicates how much of the allocated memory is already in use.
    // The variable length attributes are all packed upon any modification
    // so that all free space is at the end of the block.  The OnDiskFree
    // field indicates how many bytes of the allocated block are available
    // for use (note that this should be Allocated minus Used ).
    //
    // NOTE: The allocated and used values will ALWAYS be rounded up to ensure
    //       they are integral multiples of 4 bytes in length.  This ensures
    //       any use of these fields directly will be dword aligned.
    //
    //       Also note that when the VariableValid flag is FALSE,
    //       then the then OnDiskUsed OnDiskFree do NOT contain valid
    //       values.
    //

    ULONG  OnDiskAllocated;
    ULONG  OnDiskUsed;
    ULONG  OnDiskFree;

    //
    // In DS mode it is possible to prefetch information such that the on disk is
    // only partially populated. If that happens and if a later an attribute is requested
    // that has not been populated in the OnDisk structure, we fetch the on disk structure
    // again from disk. However we do not want the free the existing OnDisk till the context
    // has been dereferenced as there is a lot of code that simply references data from the
    // on disk structure. We save the current value of on disk in this variable so that we
    // can free it later.
    //
    PVOID  PreviousOnDisk;



    //
    // Before a context handle may be used, it must be referenced.
    // This prevents the data from being deallocated from underneath it.
    //
    // Note, this count reflects one reference for the open itself, and
    // then another reference for each time the object is looked up or
    // subsequently referenced.  Therefore, a handle close should
    // dereference the object twice - once to counter the Lookup operation
    // and once to represent elimination of the handle itself.
    //

    ULONG ReferenceCount;



    //
    // This field indicates the accesses that the client has been granted
    // via this context.
    //

    ACCESS_MASK GrantedAccess;



    //
    // This handle is to the root registry key of the corresponding
    // object.  If this value is NULL, then the corresponding
    // object was created in a previous call, but has not yet been
    // opened.  This will only occur for USERS, GROUPS, and ALIASES
    // (and DOMAINS when we support DOMAIN creation).
    //

    HANDLE RootKey;

    //
    // This is the registry name of the corresponding object.  It is
    // set when the object is created, when RootKey is null.  It is
    // used to add the attributes changes out to the RXACT in the absence
    // of the RootKey.  After being used once, it is deleted - because
    // the next time the object is used, the LookupContext() will fill
    // in the RootKey.
    //

    UNICODE_STRING RootName;



    // The Following field indicates the name of the Object in the DS,
    // if the Object resides in the DS.

    DSNAME *ObjectNameInDs;

    //
    // The following field points to the ActiveContextCount element 
    // in SAM in-memory table. ActiveContextCount element contains
    // Client Sid and number of Contexts opened so far. 
    // By caching the pointer to the element
    // 
    // 1. we'll not need to lookup SID during de-reference. Instead, 
    //    we can decrement ref count directly.
    // 
    // 2. Don't need to impersonate client to get user SID even in 
    //    the case of client dies suddently.
    // 

    PVOID   ElementInActiveContextTable;


    // Defined Flags area as follows
    // SAMP_OBJ_FLAG_DS -- Determines whether the object is present in the DS
    // or in the Registry. If present in the Registry then the RootKey and Root
    // Name fields indicate the registry fields the object is associated
    // with. Else the ObjectNameInDs field indicates the object in the DS

    ULONG ObjectFlags;


    //
    // if the object is a DS object then this field contains the actual
    // object class of the object in the DS.
    //
    ULONG DsClassId;

    //
    // If the object is other than a Server object, then this field
    // contains the index of the domain the object is in.  This provides
    // access to things like the domain's name.
    //

    ULONG DomainIndex;

    //
    // NT5 and above SAM tracks the client's version in the context. This
    // allows newer error codes to be returned ( otherwise not possible )
    // due to downlevel client limitations
    //

    ULONG ClientRevision;

    //
    // This field indicates whether an audit generation routine must be
    // called when this context block is deleted (which represents a
    // handle being deleted). This cannot be a bit field as this has to
    // be passed on to NtAccessCheckAndAuditAlarm
    //

    BOOLEAN AuditOnClose;

    //
    // Attribute level access
    //
    SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(WriteGrantedAccessAttributes)

    //
    //  The body of each object.
    //

    union {

        SAMP_SERVER_OBJECT Server;      // local-account object types
        SAMP_DOMAIN_OBJECT Domain;
        SAMP_GROUP_OBJECT Group;
        SAMP_ALIAS_OBJECT Alias;
        SAMP_USER_OBJECT User;

    } TypeBody;


} SAMP_OBJECT, *PSAMP_OBJECT;




///////////////////////////////////////////////////////////////////////////////
//
// Data structures used to store information in the registry
//
///////////////////////////////////////////////////////////////////////////////

//
// Fixed length portion of a revision 1 Server object
//

typedef struct _SAMP_V1_FIXED_LENGTH_SERVER {

    ULONG RevisionLevel;

} SAMP_V1_FIXED_LENGTH_SERVER, *PSAMP_V1_FIXED_LENGTH_SERVER;

//
// Fixed length portion of a Domain
// (previous release formats of this structure follow)
//
// Note: in version 1.0 of NT, the fixed length portion of
//       a domain was stored separate from the variable length
//       portion.  This allows us to compare the size of the
//       data read from disk against the size of a V1_0A form
//       of the fixed length data to determine whether it is
//       a Version 1 format or later format.
//
// Note: In NT4 SP3 the new domain format was introduced to
//      stored password encryption keys in the builtin & account domain
//      objects.
//
//

#define SAMP_DOMAIN_KEY_INFO_LENGTH 64

//
// This flag determines whether or not we are using a session key to
// encrypt secret data
//

#define SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED 0x1
//
// This is an Auth Flag that indicates that the machine has had
// a transition during NT4 upgrade
//

#define SAMP_DOMAIN_KEY_AUTH_FLAG_UPGRADE    0x2

typedef struct _SAMP_V1_0A_FIXED_LENGTH_DOMAIN {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   CreationTime;
    LARGE_INTEGER   ModifiedCount;
    LARGE_INTEGER   MaxPasswordAge;
    LARGE_INTEGER   MinPasswordAge;
    LARGE_INTEGER   ForceLogoff;
    LARGE_INTEGER   LockoutDuration;
    LARGE_INTEGER   LockoutObservationWindow;
    LARGE_INTEGER   ModifiedCountAtLastPromotion;


    ULONG           NextRid;
    ULONG           PasswordProperties;

    USHORT          MinPasswordLength;
    USHORT          PasswordHistoryLength;

    USHORT          LockoutThreshold;

    DOMAIN_SERVER_ENABLE_STATE ServerState;
    DOMAIN_SERVER_ROLE ServerRole;

    BOOLEAN         UasCompatibilityRequired;
    UCHAR           Unused2[3];                 // padding
    USHORT          DomainKeyAuthType;
    USHORT          DomainKeyFlags;
    UCHAR           DomainKeyInformation[SAMP_DOMAIN_KEY_INFO_LENGTH];  // new for NT4 SP3
    UCHAR           DomainKeyInformationPrevious[SAMP_DOMAIN_KEY_INFO_LENGTH];//new for whistler
    ULONG           CurrentKeyId;
    ULONG           PreviousKeyId;

} SAMP_V1_0A_FIXED_LENGTH_DOMAIN, *PSAMP_V1_0A_FIXED_LENGTH_DOMAIN;

typedef struct _SAMP_V1_0A_W2K_FIXED_LENGTH_DOMAIN {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   CreationTime;
    LARGE_INTEGER   ModifiedCount;
    LARGE_INTEGER   MaxPasswordAge;
    LARGE_INTEGER   MinPasswordAge;
    LARGE_INTEGER   ForceLogoff;
    LARGE_INTEGER   LockoutDuration;
    LARGE_INTEGER   LockoutObservationWindow;
    LARGE_INTEGER   ModifiedCountAtLastPromotion;


    ULONG           NextRid;
    ULONG           PasswordProperties;

    USHORT          MinPasswordLength;
    USHORT          PasswordHistoryLength;

    USHORT          LockoutThreshold;

    DOMAIN_SERVER_ENABLE_STATE ServerState;
    DOMAIN_SERVER_ROLE ServerRole;

    BOOLEAN         UasCompatibilityRequired;
    UCHAR           Unused2[3];                 // padding
    USHORT          DomainKeyAuthType;
    USHORT          DomainKeyFlags;
    UCHAR           DomainKeyInformation[SAMP_DOMAIN_KEY_INFO_LENGTH];  // new for NT4 SP3

} SAMP_V1_0A_WIN2K_FIXED_LENGTH_DOMAIN, *PSAMP_V1_0A_WIN2K_FIXED_LENGTH_DOMAIN;

typedef struct _SAMP_V1_0A_ORG_FIXED_LENGTH_DOMAIN {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   CreationTime;
    LARGE_INTEGER   ModifiedCount;
    LARGE_INTEGER   MaxPasswordAge;
    LARGE_INTEGER   MinPasswordAge;
    LARGE_INTEGER   ForceLogoff;
    LARGE_INTEGER   LockoutDuration;
    LARGE_INTEGER   LockoutObservationWindow;
    LARGE_INTEGER   ModifiedCountAtLastPromotion;


    ULONG           NextRid;
    ULONG           PasswordProperties;

    USHORT          MinPasswordLength;
    USHORT          PasswordHistoryLength;

    USHORT          LockoutThreshold;

    DOMAIN_SERVER_ENABLE_STATE ServerState;
    DOMAIN_SERVER_ROLE ServerRole;

    BOOLEAN         UasCompatibilityRequired;

} SAMP_V1_0A_ORG_FIXED_LENGTH_DOMAIN, *PSAMP_V1_0A_ORG_FIXED_LENGTH_DOMAIN;


typedef struct _SAMP_V1_0_FIXED_LENGTH_DOMAIN {

    LARGE_INTEGER CreationTime;
    LARGE_INTEGER ModifiedCount;
    LARGE_INTEGER MaxPasswordAge;
    LARGE_INTEGER MinPasswordAge;
    LARGE_INTEGER ForceLogoff;

    ULONG NextRid;

    DOMAIN_SERVER_ENABLE_STATE ServerState;
    DOMAIN_SERVER_ROLE ServerRole;

    USHORT MinPasswordLength;
    USHORT PasswordHistoryLength;
    ULONG PasswordProperties;

    BOOLEAN UasCompatibilityRequired;

} SAMP_V1_0_FIXED_LENGTH_DOMAIN, *PSAMP_V1_0_FIXED_LENGTH_DOMAIN;






//
// Fixed length portion of a revision 1 group account
//
// Note:  MemberCount could be treated as part of the fixed length
//        data, but it is more convenient to keep it with the Member RID
//        list in the MEMBERS key.
//

typedef struct _SAMP_V1_FIXED_LENGTH_GROUP {

    ULONG RelativeId;
    ULONG Attributes;
    UCHAR AdminGroup;

} SAMP_V1_FIXED_LENGTH_GROUP, *PSAMP_V1_FIXED_LENGTH_GROUP;

typedef struct _SAMP_V1_0A_FIXED_LENGTH_GROUP {

    ULONG Revision;
    ULONG RelativeId;
    ULONG Attributes;
    ULONG Unused1;
    UCHAR AdminCount;
    UCHAR OperatorCount;

} SAMP_V1_0A_FIXED_LENGTH_GROUP, *PSAMP_V1_0A_FIXED_LENGTH_GROUP;


//
// Fixed length portion of a revision 1 alias account
//
// Note:  MemberCount could be treated as part of the fixed length
//        data, but it is more convenient to keep it with the Member RID
//        list in the MEMBERS key.
//

typedef struct _SAMP_V1_FIXED_LENGTH_ALIAS {

    ULONG RelativeId;

} SAMP_V1_FIXED_LENGTH_ALIAS, *PSAMP_V1_FIXED_LENGTH_ALIAS;



//
// Fixed length portion of a user account
// (previous release formats of this structure follow)
//
// Note:  GroupCount could be treated as part of the fixed length
//        data, but it is more convenient to keep it with the Group RID
//        list in the GROUPS key.
//
// Note: in version 1.0 of NT, the fixed length portion of
//       a user was stored separate from the variable length
//       portion.  This allows us to compare the size of the
//       data read from disk against the size of a V1_0A form
//       of the fixed length data to determine whether it is
//       a Version 1 format or later format.


//
// This is the fixed length user from NT3.51 QFE and SUR
//


typedef struct _SAMP_V1_0A_FIXED_LENGTH_USER {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   LastLogon;
    LARGE_INTEGER   LastLogoff;
    LARGE_INTEGER   PasswordLastSet;
    LARGE_INTEGER   AccountExpires;
    LARGE_INTEGER   LastBadPasswordTime;

    ULONG           UserId;
    ULONG           PrimaryGroupId;
    ULONG           UserAccountControl;

    USHORT          CountryCode;
    USHORT          CodePage;
    USHORT          BadPasswordCount;
    USHORT          LogonCount;
    USHORT          AdminCount;
    USHORT          Unused2;
    USHORT          OperatorCount;

} SAMP_V1_0A_FIXED_LENGTH_USER, *PSAMP_V1_0A_FIXED_LENGTH_USER;

//
// This is the fixed length user from NT3.5 and NT3.51
//


typedef struct _SAMP_V1_0_FIXED_LENGTH_USER {

    ULONG           Revision;
    ULONG           Unused1;

    LARGE_INTEGER   LastLogon;
    LARGE_INTEGER   LastLogoff;
    LARGE_INTEGER   PasswordLastSet;
    LARGE_INTEGER   AccountExpires;
    LARGE_INTEGER   LastBadPasswordTime;

    ULONG           UserId;
    ULONG           PrimaryGroupId;
    ULONG           UserAccountControl;

    USHORT          CountryCode;
    USHORT          CodePage;
    USHORT          BadPasswordCount;
    USHORT          LogonCount;
    USHORT          AdminCount;

} SAMP_V1_0_FIXED_LENGTH_USER, *PSAMP_V1_0_FIXED_LENGTH_USER;


//
// This is the fixed length user from NT3.1
//

typedef struct _SAMP_V1_FIXED_LENGTH_USER {

    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;

    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;

    USHORT CountryCode;
    USHORT CodePage;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT AdminCount;


} SAMP_V1_FIXED_LENGTH_USER, *PSAMP_V1_FIXED_LENGTH_USER;


//
// Domain account information is cached in memory in a sorted list.
// This allows fast return of information to user-interactive clients.
// One of these structures is part of the in-memory information for each domain.
//

typedef struct _PSAMP_DOMAIN_DISPLAY_INFORMATION {

    RTL_GENERIC_TABLE2 RidTable;
    ULONG TotalBytesInRidTable;

    RTL_GENERIC_TABLE2 UserTable;
    ULONG TotalBytesInUserTable;

    RTL_GENERIC_TABLE2 MachineTable;
    ULONG TotalBytesInMachineTable;

    RTL_GENERIC_TABLE2 InterdomainTable;
    ULONG TotalBytesInInterdomainTable;

    RTL_GENERIC_TABLE2 GroupTable;
    ULONG TotalBytesInGroupTable;


    //
    // These fields specify whether the cached information is valid.
    // If TRUE, the cache contains valid information
    // If FALSE,  trees are empty.
    //

    BOOLEAN UserAndMachineTablesValid;
    BOOLEAN GroupTableValid;

} SAMP_DOMAIN_DISPLAY_INFORMATION, *PSAMP_DOMAIN_DISPLAY_INFORMATION;


//
// Domain account information data structure used to pass data to the
// cache manipulation routines. This structure is the union of the cached
// data for all the account types that we keep in the cache. Other SAM routines
// can call fill this structure in without knowing which type of account
// requires which elements.
//

typedef struct _SAMP_ACCOUNT_DISPLAY_INFO {
    ULONG           Rid;
    ULONG           AccountControl;   // Also used as Attributes for groups
    UNICODE_STRING  Name;
    UNICODE_STRING  Comment;
    UNICODE_STRING  FullName;

} SAMP_ACCOUNT_DISPLAY_INFO, *PSAMP_ACCOUNT_DISPLAY_INFO;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Alias Membership Lists.                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_AL_REFERENCED_DOMAIN {

    ULONG DomainReference;
    PSID DomainSid;

} SAMP_AL_REFERENCED_DOMAIN, *PSAMP_AL_REFERENCED_DOMAIN;

typedef struct _SAMP_AL_REFERENCED_DOMAIN_LIST {

    ULONG SRMaximumLength;
    ULONG SRUsedLength;
    ULONG MaximumCount;
    ULONG UsedCount;
    PSAMP_AL_REFERENCED_DOMAIN Domains;

} SAMP_AL_REFERENCED_DOMAIN_LIST, *PSAMP_AL_REFERENCED_DOMAIN_LIST;

typedef struct _SAMP_AL_SR_REFERENCED_DOMAIN {

    ULONG Length;
    ULONG DomainReference;
    SID DomainSid;

} SAMP_AL_SR_REFERENCED_DOMAIN, *PSAMP_AL_SR_REFERENCED_DOMAIN;

typedef struct _SAMP_AL_SR_REFERENCED_DOMAIN_LIST {

    ULONG SRMaximumLength;
    ULONG SRUsedLength;
    ULONG MaximumCount;
    ULONG UsedCount;
    SAMP_AL_SR_REFERENCED_DOMAIN Domains[ANYSIZE_ARRAY];

} SAMP_AL_SR_REFERENCED_DOMAIN_LIST, *PSAMP_AL_SR_REFERENCED_DOMAIN_LIST;


//
// The Alias Membership Lists are global data structures maintained by SAM
// to provide rapid retrieval of Alias membership information.  There are
// two types of Lists, the Alias Member List which is used to retrieve members
// of Aliases and the Member Alias List which is used to retrieve the aliases
// that members belong to.  A pair of these lists exists for each local
// SAM Domain (currently, the BUILTIN and Accounts domain are the only two)
//
// Currently, these lists are used as memory caches.  They are generated at
// system boot from the information stored in the SAM Database in the Registry
// and SAM keeps them up to date when Alias memberships change.  Thus SAM
// API which perform lookup/read operations can use these lists instead of
// accessing the Registry keys directly.  At a future date, it may be possible
// to back up the lists directly to the Registry and make obsolete the current
// information for Alias membership stored there.  Because these lists are
// used as caches, they can be invalidated when the going gets tough, in which
// case, API will read their information directly from the Registry.
//
// Alias Member List
//
// This is the 'Alias-to-Member' List.  Given one or more Aliases, it is used to
// find their members.  One of these lists exists for each local SAM Domain.
// The Alias Member List specifies all/ of the information describing aliases
// in the local SAM Domain.  It is designed for fast retrieval of alias
// membership information for an account given the account's Sid.
//
// An Alias Member List is structured.  For each Alias in the list, the accounts that
// are mebers of the Alias are classified by their Referenced Domain.  If an
// account is a member of n aliases in the SAM Local Domain to which an Alias
// List relates, there will be n entries for the account in the Alias Member List -
//
// are classified by domain.  If an AccountSid is a member of n aliases in a given SAM
// Local Domain, there are n entries for it in the Alias Member List.
//
// The structure of an Alias Member List consists of three levels.  These are, from
// the top down:
//
// * The Alias Member List structure (SAMP_AL_ALIAS_LIST)
//
// The Alias Member List structure specifies all aliases in the local SAM Domain.
// One of these exists per local SAM domain.  It contains a list of Alias
// structures.
//
// * The Alias structure
//
// One Alias structure exists for each alias in the local SAM Domain.  An
// Alias structure contains an array of Domain structures.
//
// * The Domain structure
//
// The Domain structure describes a Domain which has one or more accounts
// belonging to one or more aliases in the local SAM domain.  The structure
// contains a list of these member accounts.
//
// The entire Alias Member List is self relative, facilitating easy storage and
// retrieval from backing storage.
//

typedef struct _SAMP_AL_DOMAIN {

    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG DomainReference;
    ULONG RidCount;
    ULONG Rids[ANYSIZE_ARRAY];

} SAMP_AL_DOMAIN, *PSAMP_AL_DOMAIN;

typedef struct _SAMP_AL_ALIAS {

    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG AliasRid;
    ULONG DomainCount;
    SAMP_AL_DOMAIN Domains[ANYSIZE_ARRAY];

} SAMP_AL_ALIAS, *PSAMP_AL_ALIAS;

typedef struct _SAMP_AL_ALIAS_MEMBER_LIST {

    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG AliasCount;
    ULONG DomainIndex;
    ULONG Enabled;
    SAMP_AL_ALIAS Aliases[ANYSIZE_ARRAY];

} SAMP_AL_ALIAS_MEMBER_LIST, *PSAMP_AL_ALIAS_MEMBER_LIST;

//
// Member Alias List.
//
// This is the 'Member to Alias' List.  Given one or more member account Sids,
// this list is used to find all the Aliases to which one or more of the
// members belongs.  One Member Alias List exists for each local SAM Domain.
// The list contains all of the membership relationships for aliases in the
// Domain.  The member accounts are grouped by sorted Rid within Domain
// Sid, and for each Rid the list contains an array of the Rids of the Aliases
// to which it belongs.
//
// This list is implemented in a Self-Relative format for easy backup and
// restore.  For now, the list is being used simply as a cache, which is
// constructed at system load, and updated whenever membership relationships
// change.  When the going gets tough, we just ditch the cache.  Later, it
// may be desirable to save this list to a backing store (e.g. to a Registry
// Key)
//
// The list is implemented as a 3-tier hierarchy.  These are described
// from the top down.
//
// Member Alias List (SAMP_AL_MEMBER_ALIAS_LIST)
//
// This top-level structure contains the list header.  The list header
// contains a count of the Member Domains and also the DomainIndex of the
// SAM Local Domain to which the list relates.
//
// Member Domain
//
// One of these exists for each Domain that contains one or more accounts
// that are members of one or more Aliases in the SAM local Domain.
//
// Member Account
//
// One of these exists for each account that is a member of one or more
// Aliases in the SAM Local Domain.  A Member Account structure specifies
// the Rid of the member and the Rid of the Aliases to which it belongs
// (only Aliases in the associated local SAM Domain are listed).
//

typedef struct _SAMP_AL_MEMBER_ACCOUNT {

    ULONG Signature;
    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG Rid;
    ULONG AliasCount;
    ULONG AliasRids[ ANYSIZE_ARRAY];

} SAMP_AL_MEMBER_ACCOUNT, *PSAMP_AL_MEMBER_ACCOUNT;

typedef struct _SAMP_AL_MEMBER_DOMAIN {

    ULONG Signature;
    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG RidCount;
    SID DomainSid;

} SAMP_AL_MEMBER_DOMAIN, *PSAMP_AL_MEMBER_DOMAIN;

typedef struct _SAMP_AL_MEMBER_ALIAS_LIST {

    ULONG Signature;
    ULONG MaximumLength;
    ULONG UsedLength;
    ULONG DomainIndex;
    ULONG DomainCount;
    SAMP_AL_MEMBER_DOMAIN MemberDomains[ANYSIZE_ARRAY];

} SAMP_AL_MEMBER_ALIAS_LIST, *PSAMP_AL_MEMBER_ALIAS_LIST;

//
// Alias Information
//
// This is the top level structure which connects the Lists. One of these
// appears in the SAMP_DEFINED_DOMAINS structure.
//
//  The connection between the lists is as follows
//
//  SAMP_DEFINED_DOMAINS Contains SAMP_AL_ALIAS_INFORMATION
//
//  SAMP_AL_ALIAS_INFORMATION contains pointers to
//  SAMP_AL_ALIAS_MEMBER_LIST and SAMP_AL_MEMBER_ALIAS_LIST
//
//  SAMP_AL_ALIAS_MEMBER_LIST and SAMP_AL_MEMBER_ALIAS_LIST contain
//  the DomainIndex of the SAMP_DEFINED_DOMAINS structure.
//
//  Thus it is possible to navigate from any list to any other.
//

typedef struct _SAMP_AL_ALIAS_INFORMATION {

    BOOLEAN Valid;
    UNICODE_STRING AliasMemberListKeyName;
    UNICODE_STRING MemberAliasListKeyName;

    HANDLE AliasMemberListKeyHandle;
    HANDLE MemberAliasListKeyHandle;

    PSAMP_AL_ALIAS_MEMBER_LIST AliasMemberList;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList;

    SAMP_AL_REFERENCED_DOMAIN_LIST ReferencedDomainList;

} SAMP_AL_ALIAS_INFORMATION, *PSAMP_AL_ALIAS_INFORMATION;

typedef struct _SAMP_AL_SPLIT_MEMBER_SID {

    ULONG Rid;
    PSID DomainSid;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain;

} SAMP_AL_SPLIT_MEMBER_SID, *PSAMP_AL_SPLIT_MEMBER_SID;

typedef struct _SAMP_AL_SPLIT_MEMBER_SID_LIST {

    ULONG Count;
    PSAMP_AL_SPLIT_MEMBER_SID Sids;

} SAMP_AL_SPLIT_MEMBER_SID_LIST, *PSAMP_AL_SPLIT_MEMBER_SID_LIST;



//
// Information about the names and RID's of accounts for a domain
// (meant only for the BUILTIN domain which contains only a few aliases)
//
typedef struct _SAMP_ACCOUNT_NAME_CACHE {

    ULONG Count;
    struct {
        ULONG Rid;
        UNICODE_STRING Name;
    }*Entries;

}SAMP_ACCOUNT_NAME_CACHE, *PSAMP_ACCOUNT_NAME_CACHE;



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Information about each domain that is kept readily available in memory  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

typedef struct _PSAMP_DEFINED_DOMAINS {

    //
    // This field contains a handle to a context open to the domain object.
    // This handle can be used to reference in-memory copies of all
    // attributes and is used when writing out changes to the object.
    //

    PSAMP_OBJECT Context;

    //
    // (Should keep the domain's security descriptor here)
    //




    //
    // This field contains the SID of the domain.
    //

    PSID Sid;

    //
    // This field contains the external name of this domain.  This is the
    // name by which the domain is known outside SAM and is the name
    // recorded by the LSA in the PolicyAccountDomainInformation
    // information class for the Policy Object.
    //

    UNICODE_STRING ExternalName;

    //
    // This field contains the internal name of this domain.  This is the
    // name by which the domain is known inside SAM.  It is set at
    // installation and never changes.
    //

    UNICODE_STRING InternalName;

    //
    // These fields contain standard security descriptors for new user,
    // group, and alias accounts within the corresponding domain.
    //
    // The following security descriptors are prepared:
    //
    //         AdminUserSD - Contains a SD appropriate for applying to
    //             a user object that is a member of the ADMINISTRATORS
    //             alias.
    //
    //         AdminGroupSD - Contains a SD appropriate for applying to
    //             a group object that is a member of the ADMINISTRATORS
    //             alias.
    //
    //         NormalUserSD - Contains a SD appropriate for applying to
    //             a user object that is NOT a member of the ADMINISTRATORS
    //             alias.
    //
    //         NormalGroupSD - Contains a SD appropriate for applying to
    //             a Group object that is NOT a member of the ADMINISTRATORS
    //             alias.
    //
    //         NormalAliasSD - Contains a SD appropriate for applying to
    //             newly created alias objects.
    //
    //
    //
    // Additionally, the following related information is provided:
    //
    //         AdminUserRidPointer
    //         NormalUserRidPointer
    //
    //             Points to the last RID of the ACE in the corresponding
    //             SD's DACL which grants access to the user.  This rid
    //             must be replaced with the user's rid being the SD is
    //             applied to the user object.
    //
    //
    //
    //         AdminUserSDLength
    //         AdminGroupSDLength
    //         NormalUserSDLength
    //         NormalGroupSDLength
    //         NormalAliasSDLength
    //
    //             The length, in bytes, of the corresponding security
    //             descriptor.
    //

    PSECURITY_DESCRIPTOR
               AdminUserSD,
               AdminGroupSD,
               NormalUserSD,
               NormalGroupSD,
               NormalAliasSD;

    PULONG     AdminUserRidPointer,
               NormalUserRidPointer;

    ULONG      AdminUserSDLength,
               AdminGroupSDLength,
               NormalUserSDLength,
               NormalGroupSDLength,
               NormalAliasSDLength;


    //
    // There are two copies of the fixed length domain information.
    // When a transaction is started, the "UnmodifiedFixed" field is copied
    // to the "CurrentFixed" field.  The CurrentFixed field is the field
    // all operations should be performed on (like allocating new RIDs).
    // When a write-lock is released, the CurrentFixed information will
    // either be automatically written out (if the transaction is to be
    // committed) or discarded (if the transaction is to be rolled back).
    // If the transaction is committed, then the CurrentField will also be
    // copied to the UnmodifiedFixed field, making it available for the next
    // transaction.
    //
    // This allows an operation to proceed, operating on fields
    // (specifically, the NextRid and ModifiedCount fields) without
    // regard to whether the operation will ultimately be committed or
    // rolled back.
    //

    SAMP_V1_0A_FIXED_LENGTH_DOMAIN
                                CurrentFixed,
                                UnmodifiedFixed;


    //
    // Flag Indicating wether CurrentFixed and Unmodified Fixed are valid
    //

    BOOLEAN     FixedValid;

    //
    // Serial Number for Netlogon ChangeLog
    //

    LARGE_INTEGER  NetLogonChangeLogSerialNumber;


    //
    // Cached display information
    //

    SAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation;

    //
    // Cached Alias Information
    //

    SAMP_AL_ALIAS_INFORMATION AliasInformation;


    //
    // Indicates that the domain is a builtin domain
    //

    BOOLEAN    IsBuiltinDomain;

    //
    // Indicates that this is a mixed domain. This bit is set at startup
    // time.
    //

    BOOLEAN     IsMixedDomain;

    //
    // Maintains the behaviour version of the domain
    //

    ULONG     BehaviorVersion;

    //
    // Keeps the LastLogonTimeStampSyncInterval in memory
    // 

    ULONG       LastLogonTimeStampSyncInterval;

    //
    // Maintains the server role. The server role is also maintained
    // in the current fixed and unmodified fixed structures, for the
    // sake of old code that references the role in these structures
    //


    DOMAIN_SERVER_ROLE  ServerRole;


    //
    // The Domain handle for DirFindEntry
    //

    ULONG               DsDomainHandle;


    //
    // The DNS Domain Information
    //

    UNICODE_STRING      DnsDomainName;

    UNICODE_STRING      DnsForestName;

    //
    // Indicates that the domain allocates large sids
    //
    BOOLEAN IsExtendedSidDomain;

    //
    // Cached information about account names for
    // lookup purposes.  Does not require the SAM lock to
    // be referenced
    //
    PSAMP_ACCOUNT_NAME_CACHE AccountNameCache;


} SAMP_DEFINED_DOMAINS, *PSAMP_DEFINED_DOMAINS;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// This structure is used to describe where the data for               //
// an object's variable length attribute is.  This is a                //
// self-relative structure, allowing it to be stored on disk           //
// and later retrieved and used without fixing pointers.               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef struct _SAMP_VARIABLE_LENGTH_ATTRIBUTE {
    //
    // Indicates the offset of data from the address of this data
    // structure.
    //

    LONG Offset;


    //
    // Indicates the length of the data.
    //

    ULONG Length;


    //
    // A 32-bit value that may be associated with each variable
    // length attribute.  This may be used, for example, to indicate
    // how many elements are in the variable-length attribute.
    //

    ULONG Qualifier;

}  SAMP_VARIABLE_LENGTH_ATTRIBUTE, *PSAMP_VARIABLE_LENGTH_ATTRIBUTE;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// The  following structures represent the On-Disk Structure of each   //
// object type.  Each object has a fixed length data portion and a     //
// variable length data portion.  Information in the object type       //
// descriptor indicates how many variable length attributes the object //
// has and whether the fixed and variable length data are stored       //
// together in one registry key attribute, or, alternatively, each is  //
// stored in its own registry key attribute.                           //
//                                                                     //
//                                                                     //
//                                                                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// SERVER object on-disk structure                                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ON_DISK_SERVER_OBJECT {


    //
    // This field is needed for registry i/o operations.
    // This marks the beginning of the i/o buffer address.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header1;


    //
    // This field contains the fixed length attributes of the object
    //

    SAMP_V1_FIXED_LENGTH_SERVER V1Fixed;


#if SAMP_SERVER_STORED_SEPARATELY

    //
    // This header is needed for registry operations if fixed and
    // variable length attributes are stored separately.  This
    // field marks the beginning of the i/o buffer address for
    // variable-length attribute i/o.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header2;
#endif //SAMP_SERVER_STORED_SEPARATELY

    //
    // Elements of this array point to variable-length attribute
    // values.
    //

    SAMP_VARIABLE_LENGTH_ATTRIBUTE Attribute[SAMP_SERVER_VARIABLE_ATTRIBUTES];


} SAMP_ON_DISK_SERVER_OBJECT, *PSAMP_ON_DISK_SERVER_OBJECT;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// DOMAIN object on-disk structure                                     //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ON_DISK_DOMAIN_OBJECT {


    //
    // This field is needed for registry i/o operations.
    // This marks the beginning of the i/o buffer address.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header1;


    //
    // This field contains the fixed length attributes of the object
    //

    SAMP_V1_0A_FIXED_LENGTH_DOMAIN V1Fixed;


#if SAMP_DOMAIN_STORED_SEPARATELY

    //
    // This header is needed for registry operations if fixed and
    // variable length attributes are stored separately.  This
    // field marks the beginning of the i/o buffer address for
    // variable-length attribute i/o.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header2;
#endif //SAMP_DOMAIN_STORED_SEPARATELY

    //
    // Elements of this array point to variable-length attribute
    // values.
    //

    SAMP_VARIABLE_LENGTH_ATTRIBUTE Attribute[SAMP_DOMAIN_VARIABLE_ATTRIBUTES];


} SAMP_ON_DISK_DOMAIN_OBJECT, *PSAMP_ON_DISK_DOMAIN_OBJECT;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// USER object on-disk structure                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ON_DISK_USER_OBJECT {


    //
    // This field is needed for registry i/o operations.
    // This marks the beginning of the i/o buffer address.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header1;


    //
    // This field contains the fixed length attributes of the object
    //

    SAMP_V1_0A_FIXED_LENGTH_USER V1Fixed;


#if SAMP_USER_STORED_SEPARATELY

    //
    // This header is needed for registry operations if fixed and
    // variable length attributes are stored separately.  This
    // field marks the beginning of the i/o buffer address for
    // variable-length attribute i/o.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header2;
#endif //SAMP_USER_STORED_SEPARATELY

    //
    // Elements of this array point to variable-length attribute
    // values.
    //

    SAMP_VARIABLE_LENGTH_ATTRIBUTE Attribute[SAMP_USER_VARIABLE_ATTRIBUTES];


} SAMP_ON_DISK_USER_OBJECT, *PSAMP_ON_DISK_USER_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// GROUP object on-disk structure                                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ON_DISK_GROUP_OBJECT {


    //
    // This field is needed for registry i/o operations.
    // This marks the beginning of the i/o buffer address.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header1;


    //
    // This field contains the fixed length attributes of the object
    //

    SAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed;


#if SAMP_GROUP_STORED_SEPARATELY

    //
    // This header is needed for registry operations if fixed and
    // variable length attributes are stored separately.  This
    // field marks the beginning of the i/o buffer address for
    // variable-length attribute i/o.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header2;
#endif //SAMP_GROUP_STORED_SEPARATELY

    //
    // Elements of this array point to variable-length attribute
    // values.
    //

    SAMP_VARIABLE_LENGTH_ATTRIBUTE Attribute[SAMP_GROUP_VARIABLE_ATTRIBUTES];


} SAMP_ON_DISK_GROUP_OBJECT, *PSAMP_ON_DISK_GROUP_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// ALIAS object on-disk structure                                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ON_DISK_ALIAS_OBJECT {


    //
    // This field is needed for registry i/o operations.
    // This marks the beginning of the i/o buffer address.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header1;


    //
    // This field contains the fixed length attributes of the object
    //

    SAMP_V1_FIXED_LENGTH_ALIAS V1Fixed;


#if SAMP_ALIAS_STORED_SEPARATELY

    //
    // This header is needed for registry operations if fixed and
    // variable length attributes are stored separately.  This
    // field marks the beginning of the i/o buffer address for
    // variable-length attribute i/o.
    //

    KEY_VALUE_PARTIAL_INFORMATION Header2;
#endif //SAMP_ALIAS_STORED_SEPARATELY

    //
    // Elements of this array point to variable-length attribute
    // values.
    //

    SAMP_VARIABLE_LENGTH_ATTRIBUTE Attribute[SAMP_ALIAS_VARIABLE_ATTRIBUTES];


} SAMP_ON_DISK_ALIAS_OBJECT, *PSAMP_ON_DISK_ALIAS_OBJECT;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Data structures associated with secret data                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// This type is encapsulated within a UNICODE_STRING structure when storing
// secret data such as passwords or password histories. The length of the
// UNICODE_STRING should include the overhead of this structure. The pad
// field ensures that
//

#include <pshpack1.h>
typedef struct _SAMP_SECRET_DATA {
    USHORT KeyId;
    USHORT Flags;
    UCHAR Data[ANYSIZE_ARRAY];
} SAMP_SECRET_DATA, *PSAMP_SECRET_DATA;
#include <poppack.h>

//
// This macro calculates the space required for encrypting  a clear buffer of
// length _x_
//

#define SampSecretDataSize(_x_) (sizeof(SAMP_SECRET_DATA) - ANYSIZE_ARRAY * sizeof(UCHAR) + (_x_))

//
// This macro calculates the space required for decrypting a clear buffer of
// length _x_
//

#define SampClearDataSize(_x_) ((_x_) - (SampSecretDataSize(0)))

//
// This macro indentifies whether or not a unicode string structure contains
// encrypted data
//

#define SampIsDataEncrypted(_x_) ((((_x_)->Length % ENCRYPTED_LM_OWF_PASSWORD_LENGTH)==SampSecretDataSize(0)) && \
        (*(PUSHORT)((_x_)->Buffer) >= 1))


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Enumerated types for manipulating group memberships                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef enum _SAMP_MEMBERSHIP_DELTA {
    AddToAdmin,
    NoChange,
    RemoveFromAdmin
} SAMP_MEMBERSHIP_DELTA, *PSAMP_MEMBERSHIP_DELTA;




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Notification information structure, used to generate delayed notification //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_DELAYED_NOTIFICATION_INFORMATION {
     SECURITY_DB_OBJECT_TYPE    DbObjectType;
     SECURITY_DB_DELTA_TYPE     DeltaType;
     NT4SID                     DomainSid;
     ULONG                      Rid;
     UNICODE_STRING             AccountName;
     LARGE_INTEGER              SerialNumber;
} SAMP_DELAYED_NOTIFICATION_INFORMATION, *PSAMP_DELAYED_NOTIFICATION_INFORMATION;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                                                                           //
// The following typedefs were moved in from bldsam3.c so that sdconvert can //
// reference them                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



//
// domain selector
//

typedef enum _SAMP_DOMAIN_SELECTOR {

    DomainBuiltin = 0,
    DomainAccount

} SAMP_DOMAIN_SELECTOR, *PSAMP_DOMAIN_SELECTOR;

//
// Types of protection that may be assigned to accounts
//

typedef ULONG SAMP_ACCOUNT_PROTECTION;

#define SAMP_PROT_SAM_SERVER                (0L)
#define SAMP_PROT_BUILTIN_DOMAIN            (1L)
#define SAMP_PROT_ACCOUNT_DOMAIN            (2L)
#define SAMP_PROT_ADMIN_ALIAS               (3L)
#define SAMP_PROT_PWRUSER_ACCESSIBLE_ALIAS  (4L)
#define SAMP_PROT_NORMAL_ALIAS              (5L)
#define SAMP_PROT_ADMIN_GROUP               (6L)
#define SAMP_PROT_NORMAL_GROUP              (7L)
#define SAMP_PROT_ADMIN_USER                (8L)
#define SAMP_PROT_NORMAL_USER               (9L)
#define SAMP_PROT_GUEST_ACCOUNT             (10L)
#define SAMP_PROT_TYPES                     (11L)

//
// Protection information for SAM objects
//

typedef struct _SAMP_PROTECTION {

    ULONG Length;
    PSECURITY_DESCRIPTOR Descriptor;
    PULONG RidToReplace;
    BOOLEAN RidReplacementRequired;

} SAMP_PROTECTION, *PSAMP_PROTECTION;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// These typedefs are for the prefetch mechanism in SAM to intelligently    //
// control the # of attributes being read when a context is created         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


typedef struct _SAMP_PREFETCH_TABLE {
    ATTRTYP Attribute;
    ULONG   ExtendedField;
} SAMP_PREFETCH_TABLE;

#define USER_EXTENDED_FIELD_INTERNAL_SITEAFFINITY (0x00000001L)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Special Functions exported by SAM to NTDSA.dll that allows NTDSA to      //
//  inform about object changes                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
SampNetLogonNotificationRequired(
    PSID ObjectSid,
    SAMP_OBJECT_TYPE SampObjectType
    );

VOID
SampNotifyReplicatedInChange(
    PSID    ObjectSid,
    BOOL    WriteLockHeldByDs,
    SECURITY_DB_DELTA_TYPE  DeltaType,
    SAMP_OBJECT_TYPE    SampObjectType,
    PUNICODE_STRING     AccountName,
    ULONG   AccountControl,
    ULONG   GroupType,
    ULONG   CallerType,
    BOOL    MixedModeChange
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Special Function exported by SAM to NTDSA.dll that allows NTDSA to      //
//  request SAM to invalidate the current rid range used by the DC           //
//  for new account creation                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampInvalidateRidRange(BOOLEAN fAuthoritative);

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Special functions exported by SAM to ntdsa.dll that allows to set        //
// NT4 replication state                                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID
SampGetSerialNumberDomain2(
    IN PSID DomainSid,
    OUT LARGE_INTEGER * SamSerialNumber,
    OUT LARGE_INTEGER * SamCreationTime,
    OUT LARGE_INTEGER * BuiltinSerialNumber,
    OUT LARGE_INTEGER * BuiltinCreationTime
    );

NTSTATUS
SampSetSerialNumberDomain2(
    IN PSID DomainSid,
    OUT LARGE_INTEGER * SamSerialNumber,
    OUT LARGE_INTEGER * SamCreationTime,
    OUT LARGE_INTEGER * BuiltinSerialNumber,
    OUT LARGE_INTEGER * BuiltinCreationTime
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Special Functions exported to NTDSA.dll for loopback operations           //                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SamISetMixedDomainFlag(
    IN SAMPR_HANDLE DomainHandle
    );


NTSTATUS
SamIDsSetObjectInformation(
    IN SAMPR_HANDLE ObjectHandle,
    IN DSNAME       *pObject,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    );


NTSTATUS
SamIDsCreateObjectInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PRPC_UNICODE_STRING  AccountName,
    IN ULONG UserAccountType, 
    IN ULONG GroupType,
    IN ACCESS_MASK  DesiredAccess,
    OUT SAMPR_HANDLE *AccountHandle,
    OUT PULONG  GrantedAccess,
    IN OUT PULONG RelativeId
    );


NTSTATUS
SamILoopbackConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
SamIAddDSNameToGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN DSNAME   *   DSName
    );

NTSTATUS
SamIRemoveDSNameFromGroup(
    IN  SAMPR_HANDLE GroupHandle,
    IN DSNAME * DSName
    );

NTSTATUS
SamIAddDSNameToAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN DSNAME * DSName
    );

NTSTATUS
SamIRemoveDSNameFromAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN DSNAME * DSName
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// The following prototypes are usable throughout the process that SAM       //
// resides in.  THESE ROUTINES MUST NOT BE CALLED BY NON-SAM CODE !          //
//                                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Site support API's
//
NTSTATUS
SampFindUserSiteAffinity(
    IN PSAMP_OBJECT AccountContext,
    IN ATTRBLOCK* Attrs,
    OUT SAMP_SITE_AFFINITY *pSiteAffinity
    );

NTSTATUS
SampRefreshSiteAffinity(
    IN PSAMP_OBJECT AccountContext
    );

BOOLEAN
SampCheckForSiteAffinityUpdate(
    IN  PSAMP_OBJECT AccountContext,
    IN  ULONG        Flags,
    IN  PSAMP_SITE_AFFINITY pOldSA,
    OUT PSAMP_SITE_AFFINITY pNewSA,
    OUT BOOLEAN*            fDeleteOld
    );

NTSTATUS
SampInitSiteInformation(
    VOID
    );

NTSTATUS
SampUpdateSiteInfoCallback(
    PVOID
    );

BOOLEAN
SampIsGroupCachingEnabled(
    IN  PSAMP_OBJECT AccountContext
    );


NTSTATUS
SampExtractClientIpAddr(
    IN handle_t     BindingHandle OPTIONAL,
    IN SAMPR_HANDLE UserHandle OPTIONAL,    
    IN PSAMP_OBJECT Context
    );

//
// SAM's shutdown notification routine
//


BOOL SampShutdownNotification( DWORD   dwCtrlType );


//
// Sub-Component initialization routines
//

BOOLEAN SampInitializeDomainObject(VOID);

NTSTATUS
SampInitializeRegistry (
    WCHAR                      *SamParentKeyName,
    PNT_PRODUCT_TYPE            ProductType       OPTIONAL,
    PPOLICY_LSA_SERVER_ROLE     ServerRole        OPTIONAL,
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL,
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL,
    BOOLEAN                     EnableSecretEncryption OPTIONAL
    );

NTSTATUS
SampReInitializeSingleDomain(
    ULONG Index
    );

//
// database and lock related services
//

VOID
SampAcquireReadLock(VOID);


VOID
SampReleaseReadLock(VOID);


VOID
SampMaybeAcquireReadLock(
    IN PSAMP_OBJECT Context,
    IN ULONG  Control,
    OUT BOOLEAN * fLockAcquired
    );

VOID
SampMaybeReleaseReadLock(
    IN BOOLEAN fLockAcquired
    );

NTSTATUS
SampAcquireWriteLock( VOID );


NTSTATUS
SampReleaseWriteLock(
    IN BOOLEAN Commit
    );

NTSTATUS
SampMaybeAcquireWriteLock(
    IN PSAMP_OBJECT Context,
    OUT BOOLEAN * fLockAcquired
    );

NTSTATUS
SampMaybeReleaseWriteLock(
    IN BOOLEAN fLockAcquired,
    IN BOOLEAN Commit
    );

VOID
SampAcquireSamLockExclusive(VOID);


VOID
SampReleaseSamLockExclusive(VOID);


BOOLEAN
SampCurrentThreadOwnsLock();



NTSTATUS
SampCommitChanges();

NTSTATUS
SampCommitAndRetainWriteLock(
    VOID
    );

NTSTATUS
SampCommitChangesToRegistry(
    BOOLEAN  * AbortDone
    );


VOID
SampSetTransactionDomain(
    IN ULONG DomainIndex
    );



//
// Context block manipulation services
//

PSAMP_OBJECT
SampCreateContext(
    IN SAMP_OBJECT_TYPE Type,
    IN ULONG   DomainIndex,
    IN BOOLEAN TrustedClient
    );

PSAMP_OBJECT
SampCreateContextEx(
    IN SAMP_OBJECT_TYPE Type,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN DsMode,
    IN BOOLEAN NotSharedByMultiThreads,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN LazyCommit,
    IN BOOLEAN PersistAcrossCalls,
    IN BOOLEAN BufferWrites,
    IN BOOLEAN OpenedByDCPromo,
    IN ULONG   DomainIndex
    );

VOID
SampDeleteContext(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampLookupContext(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN SAMP_OBJECT_TYPE ExpectedType,
    OUT PSAMP_OBJECT_TYPE FoundType
    );

NTSTATUS
SampLookupContextEx(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN PRTL_BITMAP RequestedAttributeAccess,
    IN SAMP_OBJECT_TYPE ExpectedType,
    OUT PSAMP_OBJECT_TYPE FoundType
    );

VOID
SampReferenceContext(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampDeReferenceContext(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN Commit
    );

NTSTATUS
SampDeReferenceContext2(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN Commit
    );

//
// Context validation services.
//

VOID
SampAddNewValidContextAddress(
    IN PSAMP_OBJECT NewContext
    );


NTSTATUS
SampValidateContextAddress(
    IN PSAMP_OBJECT Context
    );

VOID
SampInvalidateContextAddress(
    IN PSAMP_OBJECT Context
    );

VOID
SampInsertContextList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    );

VOID
SampRemoveEntryContextList(
    PLIST_ENTRY Entry
    ); 

VOID
SampInvalidateObjectContexts(
    IN PSAMP_OBJECT ObjectContext,
    IN ULONG Rid
    );

VOID
SampInvalidateContextListKeysByObjectType(
    IN SAMP_OBJECT_TYPE  ObjectType,
    IN BOOLEAN  Close
    );


//
// Unicode String related services - These use MIDL_user_allocate and
// MIDL_user_free so that the resultant strings can be given to the
// RPC runtime.
//

NTSTATUS
SampInitUnicodeString(
    OUT PUNICODE_STRING String,
    IN USHORT MaximumLength
    );

NTSTATUS
SampAppendUnicodeString(
    IN OUT PUNICODE_STRING Target,
    IN PUNICODE_STRING StringToAdd
    );

VOID
SampFreeUnicodeString(
    IN PUNICODE_STRING String
    );

VOID
SampFreeOemString(
    IN POEM_STRING String
    );

NTSTATUS
SampDuplicateUnicodeString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

NTSTATUS
SampUnicodeToOemString(
    IN POEM_STRING OutString,
    IN PUNICODE_STRING InString
    );

NTSTATUS
SampBuildDomainSubKeyName(
    OUT PUNICODE_STRING KeyName,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    );


NTSTATUS
SampRetrieveStringFromRegistry(
    IN HANDLE ParentKey,
    IN PUNICODE_STRING SubKeyName,
    OUT PUNICODE_STRING Body
    );


NTSTATUS
SampPutStringToRegistry(
    IN BOOLEAN RelativeToDomain,
    IN PUNICODE_STRING SubKeyName,
    IN PUNICODE_STRING Body
    );

NTSTATUS
SampOpenDomainKey(
    IN PSAMP_OBJECT DomainContext,
    IN PRPC_SID DomainId,
    IN BOOLEAN SetTransactionDomain
    );

//
//  user, group and alias Account services
//


NTSTATUS
SampBuildAccountKeyName(
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT PUNICODE_STRING AccountKeyName,
    IN PUNICODE_STRING AccountName
    );

NTSTATUS
SampBuildAccountSubKeyName(
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT PUNICODE_STRING AccountKeyName,
    IN ULONG AccountRid,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    );

NTSTATUS
SampBuildAliasMembersKeyName(
    IN PSID AccountSid,
    OUT PUNICODE_STRING DomainKeyName,
    OUT PUNICODE_STRING AccountKeyName
    );

NTSTATUS
SampValidateNewAccountName(
    PSAMP_OBJECT    Context,
    PUNICODE_STRING NewAccountName,
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampValidateAccountNameChange(
    IN PSAMP_OBJECT    AccountContext,
    IN PUNICODE_STRING NewAccountName,
    IN PUNICODE_STRING OldAccountName,
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampIsAccountBuiltIn(
    ULONG Rid
    );



NTSTATUS
SampAdjustAccountCount(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Increment
    );

NTSTATUS
SampRetrieveAccountCounts(
    OUT PULONG UserCount,
    OUT PULONG GroupCount,
    OUT PULONG AliasCount
    );

NTSTATUS
SampRetrieveAccountCountsDs(
    IN PSAMP_OBJECT DomainContext,
    IN BOOLEAN  GetApproximateCount, 
    OUT PULONG UserCount,
    OUT PULONG GroupCount,
    OUT PULONG AliasCount
    );



NTSTATUS
SampEnumerateAccountNamesCommon(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationHandle,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned
    );


NTSTATUS
SampEnumerateAccountNames(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
SampEnumerateAccountNames2(
    IN PSAMP_OBJECT     DomainContext,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
SampLookupAccountRid(
    IN PSAMP_OBJECT     DomainContext,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING  Name,
    IN NTSTATUS         NotFoundStatus,
    OUT PULONG          Rid,
    OUT PSID_NAME_USE   Use
    );

NTSTATUS
SampLookupAccountRidRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING  Name,
    IN NTSTATUS         NotFoundStatus,
    OUT PULONG          Rid,
    OUT PSID_NAME_USE   Use
    );

NTSTATUS
SampLookupAccountName(
    IN ULONG                DomainIndex,
    IN ULONG                Rid,
    OUT PUNICODE_STRING     Name OPTIONAL,
    OUT PSAMP_OBJECT_TYPE   ObjectType
    );

NTSTATUS
SampLookupAccountNameDs(
    IN PSID                 DomainSid,
    IN ULONG                Rid,
    OUT PUNICODE_STRING     Name OPTIONAL,
    OUT PSAMP_OBJECT_TYPE   ObjectType,
    OUT PULONG              AccountType
    );

NTSTATUS
SampOpenAccount(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AccountId,
    IN BOOLEAN WriteLockHeld,
    OUT SAMPR_HANDLE *AccountHandle
    );

NTSTATUS
SampCreateAccountContext(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AccountId,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN AccountExists,
    OUT PSAMP_OBJECT *AccountContext
    );

NTSTATUS
SampCreateAccountContext2(
    IN PSAMP_OBJECT PassedInContext OPTIONAL,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AccountId,
    IN PULONG UserAccountControl OPTIONAL,
    IN PUNICODE_STRING AccountName OPTIONAL,
    IN ULONG   ClientRevision,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN CreateByPrivilege,
    IN BOOLEAN AccountExists,
    IN BOOLEAN OverrideLocalGroupCheck,
    IN PULONG  GroupType OPTIONAL,
    OUT PSAMP_OBJECT *AccountContext
    );

NTSTATUS
SampCreateAccountSid(
    PSAMP_OBJECT AccountContext,
    PSID *AccountSid
    );

NTSTATUS
SampRetrieveGroupV1Fixed(
    IN PSAMP_OBJECT GroupContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed
    );

NTSTATUS
SampReplaceGroupV1Fixed(
    IN PSAMP_OBJECT Context,
    IN PSAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed
    );

NTSTATUS
SampEnforceSameDomainGroupMembershipChecks(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG MemberRid
    );

NTSTATUS
SampEnforceCrossDomainGroupMembershipChecks(
    IN PSAMP_OBJECT AccountContext,
    IN PSID MemberSid,
    IN DSNAME * MemberName
    );

NTSTATUS
SampRetrieveUserV1aFixed(
    IN PSAMP_OBJECT UserContext,
    OUT PSAMP_V1_0A_FIXED_LENGTH_USER V1aFixed
    );

NTSTATUS
SampReplaceUserV1aFixed(
    IN PSAMP_OBJECT Context,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER V1aFixed
    );

NTSTATUS
SampUpdateAccountDisabledFlag(
    PSAMP_OBJECT Context,
    PULONG  pUserAccountControl
    );

NTSTATUS
SampRetrieveGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN PULONG MemberCount,
    IN PULONG  *Members OPTIONAL
    );

NTSTATUS
SampChangeAccountOperatorAccessToMember(
    IN PRPC_SID MemberSid,
    IN SAMP_MEMBERSHIP_DELTA ChangingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA ChangingToOperator
    );

NTSTATUS
SampChangeOperatorAccessToUser(
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA ChangingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA ChangingToOperator
    );

NTSTATUS
SampChangeOperatorAccessToUser2(
    IN PSAMP_OBJECT                    UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed,
    IN SAMP_MEMBERSHIP_DELTA           AddingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA           AddingToOperator
    );

NTSTATUS
SampQueryInformationUserInternal(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN BOOLEAN  LockHeld,
    IN ULONG    FieldsForUserallInformation,
    IN ULONG    ExtendedFieldsForUserInternal6Information,
    OUT PSAMPR_USER_INFO_BUFFER *Buffer
    );

NTSTATUS
SampCreateUserInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    OUT SAMPR_HANDLE *UserHandle,
    OUT PULONG GrantedAccess,
    IN OUT PULONG RelativeId
    );

NTSTATUS
SampCreateAliasInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    IN ULONG   GroupType,
    OUT SAMPR_HANDLE *AliasHandle,
    IN OUT PULONG RelativeId
    );

NTSTATUS
SampCreateGroupInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    IN ULONG   GroupType,
    OUT SAMPR_HANDLE *GroupHandle,
    IN OUT PULONG RelativeId
    );

NTSTATUS
SampWriteGroupType(
    IN SAMPR_HANDLE GroupHandle,
    IN ULONG        GroupType,
    IN BOOLEAN      SkipChecks
    );

NTSTATUS
SampWriteLockoutTime(
    IN PSAMP_OBJECT UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER    V1aFixed,
    IN LARGE_INTEGER LockoutTime
    );


NTSTATUS
SampDsUpdateLockoutTime(
    IN PSAMP_OBJECT AccountContext
    );

NTSTATUS
SampDsUpdateLockoutTimeEx(
    IN PSAMP_OBJECT AccountContext,
    IN BOOLEAN      ReplicateUrgently
    );


//
// Access validation and auditing related services
//

NTSTATUS
SampValidateDomainControllerCreation(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampValidateObjectAccess(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN ObjectCreation
    );

NTSTATUS
SampValidateObjectAccess2(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN HANDLE      ClientToken,
    IN BOOLEAN ObjectCreation,
    IN BOOLEAN ChangePassword,
    IN BOOLEAN SetPassword
    );

BOOLEAN
SampIsAttributeAccessGranted(
    IN PRTL_BITMAP AccessGranted,
    IN PRTL_BITMAP AccessRequested
    );

VOID
SampSetAttributeAccess(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG SamAttribute,
    IN OUT PRTL_BITMAP AttributeAccessTable
    );

VOID
SampSetAttributeAccessWithWhichFields(
    IN ULONG WhichFields,
    IN OUT PRTL_BITMAP AttributeAccessTable
    );


VOID
SampNt4AccessToWritableAttributes(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ACCESS_MASK DesiredAccess,
    OUT PRTL_BITMAP Attributes
    );

VOID
SampAuditOnClose(
    IN PSAMP_OBJECT Context
    );


NTSTATUS
SampCreateNullToken(
    );


NTSTATUS
SampAuditAnyEvent(
    IN PSAMP_OBJECT         AccountContext,
    IN NTSTATUS             Status,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL
    );

VOID
SampAuditDomainChange(
    ULONG   DomainIndex
    );


VOID
SampAuditUserChange(
    ULONG   DomainIndex, 
    PUNICODE_STRING AccountName,
    PULONG  AccountRid, 
    ULONG   AccountControl
    );


VOID
SampAuditGroupChange(
    ULONG   DomainIndex, 
    PUNICODE_STRING AccountName,
    PULONG  AccountRid, 
    ULONG   GroupType
    );

VOID
SampAuditGroupTypeChange(
    PSAMP_OBJECT GroupContext,
    BOOLEAN OldSecurityEnabled,
    BOOLEAN NewSecurityEnabled,
    NT5_GROUP_TYPE OldNT5GroupType,
    NT5_GROUP_TYPE NewNT5GroupType
    );


VOID
SampAuditGroupMemberChange(
    PSAMP_OBJECT    GroupContext,
    BOOLEAN AddMember,
    PWCHAR  MemberStringName,
    PULONG  MemberRid  OPTIONAL,
    PSID    MemberSid  OPTIONAL
    );

VOID
SampAuditUserAccountControlChange(
    PSAMP_OBJECT AccountContext, 
    ULONG NewUserAccountControl, 
    ULONG OldUserAccountControl,
    PUNICODE_STRING AccountName
    );

VOID
SampAuditDomainPolicyChange(
    IN NTSTATUS StatusCode,
    IN PSID DomainSid,
    IN PUNICODE_STRING DomainName,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass
    );

VOID
SampAuditDomainChangeDs(
    IN PSAMP_OBJECT DomainContext,
    IN ULONG        cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    );


VOID
SampAuditAccountNameChange(
    IN PSAMP_OBJECT     AccountContext,
    IN PUNICODE_STRING  NewAccountName,
    IN PUNICODE_STRING  OldAccountName
    );

VOID
SampAuditUserDelete(
    ULONG           DomainIndex, 
    PUNICODE_STRING AccountName,
    PULONG          AccountRid, 
    ULONG           AccountControl
    );

VOID
SampAuditGroupDelete(
    ULONG           DomainIndex, 
    PUNICODE_STRING AccountName,
    PULONG          AccountRid, 
    ULONG           GroupType
    );

NTSTATUS
SampConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ULONG       ClientRevision,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN NotSharedByMultiThreads,
    IN BOOLEAN InternalCaller
    );

NTSTATUS
SampDsProtectServerObject(
    IN PVOID Parameter                                   
    );


NTSTATUS
SampRetrieveUserPasswords(
    IN PSAMP_OBJECT Context,
    OUT PLM_OWF_PASSWORD LmOwfPassword,
    OUT PBOOLEAN LmPasswordNonNull,
    OUT PNT_OWF_PASSWORD NtOwfPassword,
    OUT PBOOLEAN NtPasswordPresent,
    OUT PBOOLEAN NtPasswordNonNull
    );


//
// Authenticated RPC and SPX support services
//


ULONG
SampSecureRpcInit(
    PVOID Ignored
    );

BOOLEAN
SampStartNonNamedPipeTransports(
    );

//
// Directory Service Backup/Restore support
//
ULONG
SampDSBackupRestoreInit(
    PVOID Ignored
    );


//
// Logging support routines
//


//
// This variable controls what is printed to the log.  Changeable 
// via the registry key CCS\Control\Lsa\SamLogLevel
//
extern ULONG SampLogLevel;

//
// Turns on logging for account lockout
//
#define  SAMP_LOG_ACCOUNT_LOCKOUT  0x00000001

NTSTATUS
SampInitLogging(
    VOID
    );

VOID
SampLogLevelChange(
    HANDLE hLsaKey
    );

VOID
SampLogPrint(
    IN ULONG LogLevel,
    IN LPSTR Format,
    ...
    );

#define SAMP_PRINT_LOG(x, _args_)        \
    if (((x) & SampLogLevel) == (x)) {   \
        SampLogPrint _args_ ;            \
    }

//
// Notification package routines.
//

//
// Indicates that the password has been manually expired
//
#define SAMP_PWD_NOTIFY_MANUAL_EXPIRE    0x00000001
//
// Indicates that the account has been unlocked
//
#define SAMP_PWD_NOTIFY_UNLOCKED         0x00000002
//
// Indicates that the user's password has been set or changedsd
//
#define SAMP_PWD_NOTIFY_PWD_CHANGE       0x00000004
//
// Indicats the account is a machine account
//
#define SAMP_PWD_NOTIFY_MACHINE_ACCOUNT  0x00000008

NTSTATUS
SampPasswordChangeNotify(
    IN ULONG        Flags,
    PUNICODE_STRING UserName,
    ULONG           RelativeId,
    PUNICODE_STRING NewPassword,
    IN BOOLEAN      Loopback
    );

NTSTATUS
SampPasswordChangeFilter(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING FullName,
    IN PUNICODE_STRING NewPassword,
    IN OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL,
    IN BOOLEAN SetOperation
    );

NTSTATUS
SampLoadNotificationPackages(
    );

NTSTATUS
SampDeltaChangeNotify(
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );

NTSTATUS
SampSyncLsaInterdomainTrustPassword(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING Password
    );


NTSTATUS
SampStoreUserPasswords(
    IN PSAMP_OBJECT Context,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN BOOLEAN LmPasswordPresent,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN BOOLEAN NtPasswordPresent,
    IN BOOLEAN CheckHistory,
    IN SAMP_STORE_PASSWORD_CALLER_TYPE CallerType,
    IN PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo OPTIONAL,
    IN PUNICODE_STRING ClearPassword OPTIONAL
    );

NTSTATUS
SampDsSetPasswordUser(
    IN PSAMP_OBJECT UserHandle,
    IN PUNICODE_STRING NewClearPassword
    );

NTSTATUS
SampDsChangePasswordUser(
    IN PSAMP_OBJECT UserHandle,
    IN PUNICODE_STRING OldClearPassword,
    IN PUNICODE_STRING NewClearPassword
    );





//
// Security Descriptor production services
//


NTSTATUS
SampInitializeDomainDescriptors(
    ULONG Index
    );

NTSTATUS
SampGetNewAccountSecurity(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN RestrictCreatorAccess,
    IN ULONG NewAccountRid,
    IN PSAMP_OBJECT Context OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    );

NTSTATUS
SampGetNewAccountSecurityNt4(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN RestrictCreatorAccess,
    IN ULONG NewAccountRid,
    IN ULONG DomainIndex,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    );

NTSTATUS
SampGetObjectSD(
    IN PSAMP_OBJECT Context,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

NTSTATUS
SampGetDomainObjectSDFromDsName(
    IN DSNAME   *DomainObjectDsName,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );


NTSTATUS
SampModifyAccountSecurity(
    IN PSAMP_OBJECT     Context,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN PSECURITY_DESCRIPTOR OldDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    );

NTSTATUS
SampBuildSamProtection(
    IN PSID WorldSid,
    IN PSID AdminsAliasSid,
    IN ULONG AceCount,
    IN PSID AceSid[],
    IN ACCESS_MASK AceMask[],
    IN PGENERIC_MAPPING GenericMap,
    IN BOOLEAN UserObject,
    OUT PULONG DescriptorLength,
    OUT PSECURITY_DESCRIPTOR *Descriptor,
    OUT PULONG *RidToReplace OPTIONAL
    );


NTSTATUS
SampValidatePassedSD(
    IN ULONG                          Length,
    IN PISECURITY_DESCRIPTOR_RELATIVE PassedSD
    );

//
// Group related services
//

NTSTATUS
SampChangeGroupAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    OUT PUNICODE_STRING OldAccountName
    );

NTSTATUS
SampChangeAliasAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    OUT PUNICODE_STRING OldAccountName
    );

NTSTATUS
SampChangeUserAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    IN ULONG UserAccountControl,
    OUT PUNICODE_STRING OldAccountName
    );

NTSTATUS
SampReplaceUserLogonHours(
    IN PSAMP_OBJECT Context,
    IN PLOGON_HOURS LogonHours
    );

NTSTATUS
SampComputePasswordExpired(
    IN BOOLEAN PasswordExpired,
    OUT PLARGE_INTEGER PasswordLastSet
    );

NTSTATUS
SampSetUserAccountControl(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        UserAccountControl,
    IN IN SAMP_V1_0A_FIXED_LENGTH_USER * V1aFixed,
    IN BOOLEAN      ChangePrimaryGroupId,
    OUT BOOLEAN     *AccountUnlocked,
    OUT BOOLEAN     *AccountGettingMorphed,
    OUT BOOLEAN     *KeepOldPrimaryGroupMembership
    );

NTSTATUS
SampAssignPrimaryGroup(
    IN PSAMP_OBJECT Context,
    IN ULONG GroupRid
    );

NTSTATUS
SampAddUserToGroup(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG GroupRid,
    IN ULONG UserRid
    );

NTSTATUS
SampRemoveUserFromGroup(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG GroupRid,
    IN ULONG UserRid
    );

NTSTATUS
SampValidateDSName(
    IN PSAMP_OBJECT AccountContext,
    IN DSNAME * DSName,
    OUT PSID    * Sid,
    OUT DSNAME  **ImprovedDSName
    );

NTSTATUS
SampDsCheckSidType(
    IN  PSID    Sid,
    IN  ULONG   cDomainSids,
    IN  PSID    *rgDomainSids,
    IN  ULONG   cEnterpriseSids,
    IN  PSID    *rgEnterpriseSids,
    OUT BOOLEAN * WellKnownSid,
    OUT BOOLEAN * BuiltinDomainSid,
    OUT BOOLEAN * LocalSid,
    OUT BOOLEAN * ForeignSid,
    OUT BOOLEAN * EnterpriseSid
    );

NTSTATUS
SampGetDomainSidListForSam(
    PULONG pcDomainSids,
    PSID   **rgDomainSids,
    PULONG pcEnterpriseSids,
    PSID   **rgEnterpriseSids
   );

NTSTATUS
SampDsCreateForeignSecurityPrincipal(
    IN PSID pSid,
    IN DSNAME * DomainObjectName,
    OUT DSNAME ** ppDsName
    );

NTSTATUS
SampCheckGroupTypeBits(
    IN BOOLEAN MixedDomain,
    IN ULONG   GroupType
    );


//
// Alias related services
//

NTSTATUS
SampAlBuildAliasInformation(
    );

NTSTATUS
SampAlDelayedBuildAliasInformation(
    IN PVOID Parameter
    );

NTSTATUS
SampAlInvalidateAliasInformation(
    IN ULONG DomainIndex
    );

NTSTATUS
SampAlQueryAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    );

NTSTATUS
SampAlQueryMembersOfAlias(
    IN SAMPR_HANDLE AliasHandle,
    OUT PSAMPR_PSID_ARRAY MemberSids
    );

NTSTATUS
SampAlAddMembersToAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG Options,
    IN PSAMPR_PSID_ARRAY MemberSids
    );

NTSTATUS
SampAlRemoveMembersFromAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG Options,
    IN PSAMPR_PSID_ARRAY MemberSids
    );

NTSTATUS
SampAlLookupMembersInAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG AliasRid,
    IN PSAMPR_PSID_ARRAY MemberSids,
    OUT PULONG MembershipCount
    );

NTSTATUS
SampAlDeleteAlias(
    IN SAMPR_HANDLE *AliasHandle
    );

NTSTATUS
SampAlRemoveAccountFromAllAliases(
    IN PSID AccountSid,
    IN BOOLEAN CheckAccess,
    IN SAMPR_HANDLE DomainHandle OPTIONAL,
    IN PULONG MembershipCount OPTIONAL,
    IN PULONG *Membership OPTIONAL
    );

NTSTATUS
SampRetrieveAliasMembers(
    IN PSAMP_OBJECT AliasContext,
    IN PULONG MemberCount,
    IN PSID **Members OPTIONAL
    );


NTSTATUS
SampRemoveAccountFromAllAliases(
    IN PSID AccountSid,
    IN PDSNAME AccountNameInDs OPTIONAL,
    IN BOOLEAN CheckAccess,
    IN SAMPR_HANDLE DomainHandle OPTIONAL,
    IN PULONG MembershipCount OPTIONAL,
    IN PULONG *Membership OPTIONAL
    );

NTSTATUS
SampAlSlowQueryAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    IN DSNAME ** DsNameArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    );

NTSTATUS
SampRetrieveAliasMembership(
    IN PSID Account,
    IN DSNAME * AccountDn OPTIONAL,
    OUT PULONG MemberCount OPTIONAL,
    IN OUT PULONG BufferSize OPTIONAL,
    OUT PULONG Buffer OPTIONAL
    );

NTSTATUS
SampInitAliasNameCache(
    VOID
    );


//
// User related services
//


NTSTATUS
SampGetPrivateUserData(
    PSAMP_OBJECT UserContext,
    OUT PULONG DataLength,
    OUT PVOID *Data
    );

NTSTATUS
SampSetPrivateUserData(
    PSAMP_OBJECT UserContext,
    IN ULONG DataLength,
    IN PVOID Data
    );
NTSTATUS
SampRetrieveUserGroupAttribute(
    IN ULONG UserRid,
    IN ULONG GroupRid,
    OUT PULONG Attribute
    );

NTSTATUS
SampAddGroupToUserMembership(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG GroupRid,
    IN ULONG Attributes,
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA AdminGroup,
    IN SAMP_MEMBERSHIP_DELTA OperatorGroup,
    OUT PBOOLEAN UserActive,
    OUT PBOOLEAN PrimaryGroup
    );

NTSTATUS
SampSetGroupAttributesOfUser(
    IN ULONG GroupRid,
    IN ULONG Attributes,
    IN ULONG UserRid
    );

NTSTATUS
SampRemoveMembershipUser(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG GroupRid,
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA AdminGroup,
    IN SAMP_MEMBERSHIP_DELTA OperatorGroup,
    OUT PBOOLEAN UserActive
    );

BOOLEAN
SampStillInLockoutObservationWindow(
    PSAMP_OBJECT UserContext,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed
    );


//
// Cached display information services
//

NTSTATUS
SampInitializeDisplayInformation (
    ULONG DomainIndex
    );

NTSTATUS
SampMarkDisplayInformationInvalid (
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampUpdateDisplayInformation (
    PSAMP_ACCOUNT_DISPLAY_INFO OldAccountInfo OPTIONAL,
    PSAMP_ACCOUNT_DISPLAY_INFO NewAccountInfo OPTIONAL,
    SAMP_OBJECT_TYPE            ObjectType
    );


//
// Miscellaneous services
//

BOOLEAN
SampValidateComputerName(
    IN  PWSTR Name,
    IN  ULONG Length
    );

LARGE_INTEGER
SampAddDeltaTime(
    IN LARGE_INTEGER Time,
    IN LARGE_INTEGER DeltaTime
    );

NTSTATUS
SampCreateFullSid(
    PSID    DomainSid,
    ULONG   Rid,
    PSID    *AccountSid
    );

NTSTATUS
SampSplitSid(
    IN PSID AccountSid,
    OUT PSID *DomainSid,
    OUT ULONG *Rid
    );

BOOLEAN SampIsWellKnownSid(
    IN PSID Sid
    );

BOOLEAN SampIsSameDomain(
    IN PSID AccountSid,
    IN PSID DomainSid
    );

VOID
SampNotifyNetlogonOfDelta(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );

VOID
SampWriteEventLog (
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING *Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL
    );

NTSTATUS
SampGetAccountDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    );

NTSTATUS
SampSetAccountDomainPolicy(
    IN PUNICODE_STRING AccountDomainName,
    IN PSID            AccountDomainSid
    );

NTSTATUS
SampUpgradeSamDatabase(
    ULONG Revision
    );

NTSTATUS
SampAbortSingleLoopbackTask(
    IN OUT PVOID  *VoidNotifyItem
    );

NTSTATUS
SampProcessSingleLoopbackTask(
    IN PVOID  *VoidNotifyItem
    );

VOID
SampAddLoopbackTaskForBadPasswordCount(
    IN PUNICODE_STRING AccountName
    );

NTSTATUS
SampAddLoopbackTaskDeleteTableElement(
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampAddLoopbackTaskForAuditing(
    IN NTSTATUS             PassedStatus,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL
    );

NTSTATUS
SampOpenUserInServer(
    PUNICODE_STRING UserName,
    BOOLEAN Unicode,
    IN BOOLEAN TrustedClient,
    SAMPR_HANDLE * UserHandle
    );

BOOLEAN
SampIncrementBadPasswordCount(
    IN PSAMP_OBJECT UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    IN PUNICODE_STRING  MachineName OPTIONAL
    );

NTSTATUS
SampConvertUiListToApiList(
    IN  PUNICODE_STRING UiList OPTIONAL,
    OUT PUNICODE_STRING ApiList,
    IN BOOLEAN BlankIsDelimiter
    );

NTSTATUS
SampFindComputerObject(
    IN  PDSNAME DsaObject,
    OUT PDSNAME *ComputerObject
    );
//
// found in dsupgrad.lib
//

NTSTATUS
SampRegistryToDsUpgrade (
    WCHAR* wcszRegPath
    );

NTSTATUS
SampValidateDomainCache(
    VOID
    );

NTSTATUS
SampDsResolveSids(
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    );

NTSTATUS
SampDsLookupObjectByAlternateId(
    IN PDSNAME DomainRoot,
    IN ULONG AttributeId,
    IN PUNICODE_STRING AlternateId,
    OUT PDSNAME *Object
    );

BOOLEAN
SampIsSetupInProgress(
    OUT BOOLEAN *Upgrade OPTIONAL
    );

ULONG
SampDefaultPrimaryGroup(
    PSAMP_OBJECT    UserContext,
    ULONG           AccountType
    );

NTSTATUS
SampGetMessageStrings(
    LPVOID              Resource,
    DWORD               Index1,
    PUNICODE_STRING     String1,
    DWORD               Index2,
    PUNICODE_STRING     String2 OPTIONAL
    );


//
// Role change support services
//
BOOL
SampIsRebootAfterPromotion(
    OUT PULONG PromoteData
    );

NTSTATUS
SampPerformPromotePhase2(
     IN ULONG PromoteData
     );

NTSTATUS
SampGetAdminPasswordFromRegistry(
    OUT USER_INTERNAL1_INFORMATION *InternalInfo1 OPTIONAL
    );

BOOLEAN
SampUsingDsData();


//
// Old RPC stub routine definitions used in SamIFree()
//

void _fgs__RPC_UNICODE_STRING (RPC_UNICODE_STRING  * _source);
void _fgs__SAMPR_RID_ENUMERATION (SAMPR_RID_ENUMERATION  * _source);
void _fgs__SAMPR_ENUMERATION_BUFFER (SAMPR_ENUMERATION_BUFFER  * _source);
void _fgs__SAMPR_SR_SECURITY_DESCRIPTOR (SAMPR_SR_SECURITY_DESCRIPTOR  * _source);
void _fgs__SAMPR_GET_GROUPS_BUFFER (SAMPR_GET_GROUPS_BUFFER  * _source);
void _fgs__SAMPR_GET_MEMBERS_BUFFER (SAMPR_GET_MEMBERS_BUFFER  * _source);
void _fgs__SAMPR_LOGON_HOURS (SAMPR_LOGON_HOURS  * _source);
void _fgs__SAMPR_ULONG_ARRAY (SAMPR_ULONG_ARRAY  * _source);
void _fgs__SAMPR_SID_INFORMATION (SAMPR_SID_INFORMATION  * _source);
void _fgs__SAMPR_PSID_ARRAY (SAMPR_PSID_ARRAY  * _source);
void _fgs__SAMPR_RETURNED_USTRING_ARRAY (SAMPR_RETURNED_USTRING_ARRAY  * _source);
void _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION (SAMPR_DOMAIN_GENERAL_INFORMATION  * _source);
void _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION2 (SAMPR_DOMAIN_GENERAL_INFORMATION2  * _source);
void _fgs__SAMPR_DOMAIN_OEM_INFORMATION (SAMPR_DOMAIN_OEM_INFORMATION  * _source);
void _fgs__SAMPR_DOMAIN_NAME_INFORMATION (SAMPR_DOMAIN_NAME_INFORMATION  * _source);
void _fgs_SAMPR_DOMAIN_REPLICATION_INFORMATION (SAMPR_DOMAIN_REPLICATION_INFORMATION  * _source);
void _fgu__SAMPR_DOMAIN_INFO_BUFFER (SAMPR_DOMAIN_INFO_BUFFER  * _source, DOMAIN_INFORMATION_CLASS _branch);
void _fgu__SAMPR_GROUP_INFO_BUFFER (SAMPR_GROUP_INFO_BUFFER  * _source, GROUP_INFORMATION_CLASS _branch);
void _fgu__SAMPR_ALIAS_INFO_BUFFER (SAMPR_ALIAS_INFO_BUFFER  * _source, ALIAS_INFORMATION_CLASS _branch);
void _fgu__SAMPR_USER_INFO_BUFFER (SAMPR_USER_INFO_BUFFER  * _source, USER_INFORMATION_CLASS _branch);
void _fgu__SAMPR_DISPLAY_INFO_BUFFER (SAMPR_DISPLAY_INFO_BUFFER  * _source, DOMAIN_DISPLAY_INFORMATION _branch);



//
// SAM object attribute manipulation services
//



VOID
SampInitObjectInfoAttributes();

NTSTATUS
SampStoreObjectAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN UseKeyHandle
    );

NTSTATUS
SampDeleteAttributeKeys(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampGetFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN MakeCopy,
    OUT PVOID *FixedData
    );

NTSTATUS
SamIGetFixedAttributes(                 // Export used in samwrite.c
    IN PSAMP_OBJECT Context,
    IN BOOLEAN MakeCopy,
    OUT PVOID *FixedData
    );

NTSTATUS
SampSetFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN PVOID FixedData
    );

NTSTATUS
SampGetUnicodeStringAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PUNICODE_STRING UnicodeAttribute
    );

NTSTATUS
SampSetUnicodeStringAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PUNICODE_STRING Attribute
    );

NTSTATUS
SampGetSidAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PSID *Sid
    );

NTSTATUS
SampSetSidAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSID Attribute
    );

NTSTATUS
SampGetAccessAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PULONG Revision,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

NTSTATUS
SampSetAccessAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSECURITY_DESCRIPTOR Attribute,
    IN ULONG Length
    );

NTSTATUS
SampGetUlongArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PULONG *UlongArray,
    OUT PULONG UsedCount,
    OUT PULONG LengthCount
    );

NTSTATUS
SampSetUlongArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PULONG Attribute,
    IN ULONG UsedCount,
    IN ULONG LengthCount
    );

NTSTATUS
SampGetLargeIntArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PLARGE_INTEGER *LargeIntArray,
    OUT PULONG Count
    );

NTSTATUS
SampSetLargeIntArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PLARGE_INTEGER Attribute,
    IN ULONG Count
    );

NTSTATUS
SampGetSidArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PSID *SidArray,
    OUT PULONG Length,
    OUT PULONG Count
    );

NTSTATUS
SampSetSidArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSID Attribute,
    IN ULONG Length,
    IN ULONG Count
    );

NTSTATUS
SampGetLogonHoursAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PLOGON_HOURS LogonHours
    );

NTSTATUS
SampSetLogonHoursAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PLOGON_HOURS Attribute
    );

VOID
SampFreeAttributeBuffer(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampRtlConvertUlongToUnicodeString(
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN ULONG DigitCount,
    IN BOOLEAN AllocateDestinationString,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
SampRtlWellKnownPrivilegeCheck(
    BOOLEAN ImpersonateClient,
    IN ULONG PrivilegeId,
    IN OPTIONAL PCLIENT_ID ClientId
    );

NTSTATUS
SampImpersonateClient(
    OUT BOOLEAN *fImpersonatingAnonymous 
    );

VOID
SampRevertToSelf(
    IN  BOOLEAN fImpersonatingAnonymous 
    );


//
// Routines to support Extended Sid's
//
VOID
SampInitEmulationSettings(
    IN HKEY LsaKey 
    );

BOOLEAN
SampIsExtendedSidModeEmulated(
    IN ULONG *Mode
    );

// BOOLEAN
//  SampIsContextFromExtendedSidDomain(
//    SAMP_OBJECT Context
//    );
#define SampIsContextFromExtendedSidDomain(x) \
      SampDefinedDomains[(x)->DomainIndex].IsExtendedSidDomain



//
// Encryption and Decryption services
//

USHORT
SampGetEncryptionKeyType();

NTSTATUS
SampDecryptSecretData(
    OUT PUNICODE_STRING ClearData,
    IN SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN PUNICODE_STRING EncryptedData,
    IN ULONG Rid
    );

NTSTATUS
SampEncryptSecretData(
    OUT PUNICODE_STRING EncryptedData,
    IN USHORT KeyId,
    IN SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN PUNICODE_STRING ClearData,
    IN ULONG Rid
    );

NTSTATUS
SampInitializeSessionKey(
    VOID
    );

VOID
SampCheckNullSessionAccess(
    IN HKEY LsaKey 
    );

NTSTATUS
SampExtendedEnumerationAccessCheck(
    IN OUT BOOLEAN * pCanEnumEntireDomain 
    );

//
// The Following 2 functions convert between account Control and Flags
//

NTSTATUS
SampFlagsToAccountControl(
    IN ULONG Flags,
    OUT PULONG UserAccountControl
    );



ULONG
SampAccountControlToFlags(
    IN ULONG Flags
    );


//
// The following function calculates LM and NT OWF Passwords
//

NTSTATUS
SampCalculateLmAndNtOwfPasswords(
    IN PUNICODE_STRING ClearNtPassword,
    OUT PBOOLEAN LmPasswordPresent,
    OUT PLM_OWF_PASSWORD LmOwfPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

//
// Initialize Sam Global well known Sids
//

NTSTATUS
SampInitializeWellKnownSids( VOID );


//
// SampDsGetPrimaryDomainStart is used to correctly set the starting index in the
// SampDefinedDomains array whenever it is accessed in the SAM code. In the
// case of an NT workstation or member server, the first two entries of the
// array correspond to registry data, hence the index is started at zero. In
// the case of a domain controller, the DS-based data is not stored in the
// first two elements (those may be used for crash-recovery data, still ob-
// tained from the registry), but rather in subsequent array elements, hence
// is start at index DOMAIN_START_DS.
//

ULONG
SampDsGetPrimaryDomainStart(VOID);


//
// SampIsMixedDomain returns wether the domain has downlevel domain controllers
// present. SampIsMixedDomain checks the value of an attribute on the domain
// object
//

NTSTATUS
SampGetDsDomainSettings(
    BOOLEAN *MixedDomain, 
    ULONG * BehaviorVersion, 
    ULONG * LastLogonTimeStampSyncInterval
    );


//
// This routine determines if Sid is either the builtin domain, or a
// member of the builtin domain
//
BOOLEAN
SampIsMemberOfBuiltinDomain(
    IN PSID Sid
    );

//
// This routine performs a special security check before group membership changes
// for "sensitive" groups
//

NTSTATUS
SampCheckForSensitiveGroups(SAMPR_HANDLE AccountHandle);

//
// The Following Functions Ensure that all threads not executing with the
// SAM lock held are finished with their current activity before the
// DS shutdown sequence is initiated.
//

NTSTATUS
SampInitializeShutdownEvent();

NTSTATUS
SampIncrementActiveThreads(VOID);

VOID
SampDecrementActiveThreads(VOID);

VOID
SampWaitForAllActiveThreads(
    IN PSAMP_SERVICE_STATE PreviousServiceState OPTIONAL
    );

//
// Functions to upgrade the SAM database and fix SAM bugs
//

NTSTATUS
SampUpgradeSamDatabase(
    ULONG Revision
    );

BOOLEAN
SampGetBootOptions(
    VOID
    );


BOOLEAN
SampIsDownlevelDcUpgrade(
    VOID
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 2-3 tree generic table routines                                     //
// These should be moved to RTL directory if a general need arises.    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


VOID
RtlInitializeGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PRTL_GENERIC_2_COMPARE_ROUTINE  CompareRoutine,
    PRTL_GENERIC_2_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_GENERIC_2_FREE_ROUTINE     FreeRoutine
    );

PVOID
RtlInsertElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PBOOLEAN NewElement
    );

BOOLEAN
RtlDeleteElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    );

PVOID
RtlLookupElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    );

PVOID
RtlEnumerateGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID *RestartKey
    );

PVOID
RtlRestartKeyByIndexGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    ULONG I,
    PVOID *RestartKey
    );

PVOID
RtlRestartKeyByValueGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PVOID *RestartKey
    );

ULONG
RtlNumberElementsGenericTable2(
    PRTL_GENERIC_TABLE2 Table
    );

BOOLEAN
RtlIsGenericTable2Empty (
    PRTL_GENERIC_TABLE2 Table
    );

//////////////////////////////////////////////////
NTSTATUS
SampCheckAccountNameTable(
    IN PSAMP_OBJECT    Context,
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampDeleteElementFromAccountNameTable(
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    );


NTSTATUS
SampInitializeAccountNameTable(
    );

PVOID
SampAccountNameTableAllocate(
    ULONG   BufferSize
    );

VOID
SampAccountNameTableFree(
    PVOID   Buffer
    );

RTL_GENERIC_COMPARE_RESULTS
SampAccountNameTableCompare(
    PVOID   Node1,
    PVOID   Node2
    );

LONG
SampCompareDisplayStrings(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN IgnoreCase
    );


/////////////////////////////////////////////////////////

NTSTATUS
SampGetCurrentOwnerAndPrimaryGroup(
    OUT PTOKEN_OWNER * Owner,
    OUT PTOKEN_PRIMARY_GROUP * PrimaryGroup
    );

NTSTATUS
SampGetCurrentUser(
    IN HANDLE ClientToken OPTIONAL,
    OUT PTOKEN_USER * User,
    OUT BOOL        * Administrator
    );

NTSTATUS
SampGetCurrentClientSid(
    IN  HANDLE   ClientToken OPTIONAL,
    OUT PSID    *ppSid,
    OUT BOOL    *Administrator
    );


VOID
SampInitializeActiveContextTable(
    );

PVOID
SampActiveContextTableAllocate(
    ULONG   BufferSize
    );

VOID
SampActiveContextTableFree(
    PVOID   Buffer
    );

RTL_GENERIC_COMPARE_RESULTS
SampActiveContextTableCompare(
    PVOID   Node1,
    PVOID   Node2
    );

NTSTATUS
SampIncrementActiveContextCount(
    PSAMP_OBJECT    Context
    );

VOID
SampDecrementActiveContextCount(
    PVOID   ElementInActiveContextTable
    );



/////////////////////////////////////////////////////////


VOID
SampMapNtStatusToClientRevision(
   IN ULONG ClientRevision,
   IN OUT NTSTATUS *pNtStatus
   );

ULONG
SampClientRevisionFromHandle(
   PVOID handle
   );

//
// Performance counter functions
//

VOID
SampUpdatePerformanceCounters(
    DWORD               dwStat,
    DWORD               dwOperation,
    DWORD               dwChange
    );


//
// Functions for manipulating supplemental credentials
//
VOID
SampFreeSupplementalCredentialList(
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentialList
    );

NTSTATUS
SampAddSupplementalCredentialsToList(
    IN OUT PSAMP_SUPPLEMENTAL_CRED *SupplementalCredentialList,
    IN PUNICODE_STRING PackageName,
    IN PVOID           CredentialData,
    IN ULONG           CredentialLength,
    IN BOOLEAN         ScanForConflict,
    IN BOOLEAN         Remove
    );

NTSTATUS
SampConvertCredentialsToAttr(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG   Flags,
    IN ULONG   ObjectRid,
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentials,
    OUT ATTR * CredentialAttr
    );


NTSTATUS
SampRetrieveCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    IN BOOLEAN Primary,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Shared global variables                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


extern NT_PRODUCT_TYPE SampProductType;
extern BOOLEAN SampUseDsData;

extern BOOLEAN SampRidManagerInitialized;

extern RTL_RESOURCE SampLock;
extern BOOLEAN SampTransactionWithinDomainGlobal;
extern ULONG SampTransactionDomainIndexGlobal;

extern RTL_CRITICAL_SECTION SampContextListCritSect; 

extern RTL_GENERIC_TABLE2   SampAccountNameTable;
extern RTL_CRITICAL_SECTION SampAccountNameTableCriticalSection; 
extern PRTL_CRITICAL_SECTION SampAccountNameTableCritSect; 


extern RTL_GENERIC_TABLE2   SampActiveContextTable;


extern SAMP_SERVICE_STATE SampServiceState;

extern BOOLEAN SampSuccessAccountAuditingEnabled;
extern BOOLEAN SampFailureAccountAuditingEnabled;


extern HANDLE SampKey;
extern PRTL_RXACT_CONTEXT SampRXactContext;

extern SAMP_OBJECT_INFORMATION SampObjectInformation[ SampUnknownObjectType ];

extern LIST_ENTRY SampContextListHead;

extern ULONG SampDefinedDomainsCount;
extern PSAMP_DEFINED_DOMAINS SampDefinedDomains;
extern UNICODE_STRING SampFixedAttributeName;
extern UNICODE_STRING SampVariableAttributeName;
extern UNICODE_STRING SampCombinedAttributeName;

extern UNICODE_STRING SampNameDomains;
extern UNICODE_STRING SampNameDomainGroups;
extern UNICODE_STRING SampNameDomainAliases;
extern UNICODE_STRING SampNameDomainAliasesMembers;
extern UNICODE_STRING SampNameDomainUsers;
extern UNICODE_STRING SampNameDomainAliasesNames;
extern UNICODE_STRING SampNameDomainGroupsNames;
extern UNICODE_STRING SampNameDomainUsersNames;

extern UNICODE_STRING SampBackSlash;
extern UNICODE_STRING SampNullString;
extern UNICODE_STRING SampSamSubsystem;
extern UNICODE_STRING SampServerObjectName;


extern LARGE_INTEGER SampImmediatelyDeltaTime;
extern LARGE_INTEGER SampNeverDeltaTime;
extern LARGE_INTEGER SampHasNeverTime;
extern LARGE_INTEGER SampWillNeverTime;

//
// checked build only. If CurrentControlSet\Control\Lsa\UpdateLastLogonTSByMinute
// is set, the value of LastLogonTimeStampSyncInterval will be a "unit" by minute
// instead of "days", which helps to test this feature.   So checked build only.
// 

#if DBG
extern BOOLEAN SampLastLogonTimeStampSyncByMinute;
#endif 


extern LM_OWF_PASSWORD SampNullLmOwfPassword;
extern NT_OWF_PASSWORD SampNullNtOwfPassword;

extern TIME LastUnflushedChange;
extern BOOLEAN FlushThreadCreated;
extern BOOLEAN FlushImmediately;

extern LONG SampFlushThreadMinWaitSeconds;
extern LONG SampFlushThreadMaxWaitSeconds;
extern LONG SampFlushThreadExitDelaySeconds;

//
// Warning: these SIDs are only defined during the first boot of setup,
// when the code in bldsam3.c for building the SAM database, has been
// run. On a normal build they are both NULL.
//

extern PSID SampBuiltinDomainSid;
extern PSID SampAccountDomainSid;

extern PSID SampWorldSid;
extern PSID SampAnonymousSid;
extern PSID SampLocalSystemSid;
extern PSID SampAdministratorUserSid;
extern PSID SampAdministratorsAliasSid;
extern PSID SampAccountOperatorsAliasSid;
extern PSID SampAuthenticatedUsersSid;
extern PSID SampPrincipalSelfSid;
extern PSID SampBuiltinDomainSid;
extern PSID SampNetworkSid;



extern HANDLE  SampNullSessionToken;
extern BOOLEAN SampNetwareServerInstalled;
extern BOOLEAN SampIpServerInstalled;
extern BOOLEAN SampAppletalkServerInstalled;
extern BOOLEAN SampVinesServerInstalled;

extern UCHAR SampSecretSessionKey[SAMP_SESSION_KEY_LENGTH];
extern UCHAR SampSecretSessionKeyPrevious[SAMP_SESSION_KEY_LENGTH];
extern BOOLEAN SampSecretEncryptionEnabled;
extern ULONG   SampCurrentKeyId;
extern ULONG   SampPreviousKeyId;
extern BOOLEAN SampUpgradeInProcess;

extern SAMP_DS_TRANSACTION_CONTROL SampDsTransactionType;
extern DSNAME* RootObjectName;
extern BOOLEAN SampLockHeld;

//
// This Flag is TRUE when DS failed to start.
//
extern BOOLEAN SampDsInitializationFailed;
//
// This flag is TRUE when the DS has been successfully initialized
//
extern BOOLEAN SampDsInitialized;

//
// For Tagged tracing support
//

extern ULONG SampTraceTag;
extern ULONG SampTraceFileTag;

//
// SAM server object name holder
//
extern DSNAME * SampServerObjectDsName;




//
// Event to tell waiting threads that the
// system is about to shut down
//

extern HANDLE SampAboutToShutdownEventHandle;

//
// Flags to determine if certain containers exist; these flags are valid
// after SampInitialize returns
//
extern BOOLEAN SampDomainControllersOUExists;
extern BOOLEAN SampUsersContainerExists;
extern BOOLEAN SampComputersContainerExists;

//
//
// Global pointer (to heap memory) to store well known container's
// distinguished name
//
extern DSNAME * SampDomainControllersOUDsName;
extern DSNAME * SampUsersContainerDsName;
extern DSNAME * SampComputersContainerDsName;
extern DSNAME * SampComputerObjectDsName;




//
// Global tests the value of a key in the registry for a hard/soft logon
// policy in the event of GC failures.
//
extern BOOLEAN SampIgnoreGCFailures;

//
// Flag to indicate whether the Promote is coming from NT4 PDC or a
// stand along Windows 2000 Server
//
extern BOOLEAN SampNT4UpgradeInProgress;

//
// This flag indicates whether null sessions (world) should be allowed to
// list users in the domain and members of groups.
//
extern BOOLEAN SampRestrictNullSessions;

//
// This flag indicates that we do not store the LM hash. This can be
// enabled by setting a Registry Key
//

extern BOOLEAN SampNoLmHash;

//
// This flag indicates that we should check extended SAM Query/Enumerate 
// Access control right. This is based upon a registry key setting
// 

extern BOOLEAN SampDoExtendedEnumerationAccessCheck;

//
// This flag when set disables netlogon notifications in the upgrade path
//

extern BOOLEAN SampDisableNetlogonNotification;


//
// This flag indicates whether or not to enforce giving site affinity to
// clients outside our site by looking at the client's IP address.
//
extern BOOLEAN SampNoGcLogonEnforceKerberosIpCheck;

//
// This flag indicates whether or not to enforce that only interactive
// logons via NTLM are to be given site affinity
//
extern BOOLEAN SampNoGcLogonEnforceNTLMCheck;

//
// This flags indicates whether or not to replicate password set/change
// operations urgently.
//
extern BOOLEAN SampReplicatePasswordsUrgently;

//
// This flag is enabled on personal and professional to force guest 
// access for all network operations
//
extern BOOLEAN SampForceGuest;

//
// This flag indicates whether or not the local machine is joined to a domain
// 
extern BOOLEAN SampIsMachineJoinedToDomain;

//
// This flag tells if we are running Personal SKU
// 
extern BOOLEAN SampPersonalSKU;


//
// This flag is typically enabled on personal machines to limit security
// concerns when using blank passwords
//
extern BOOLEAN SampLimitBlankPasswordUse;

//
//  Handy macro for LockoutTime
//
// BOOLEAN
// SAMP_LOCKOUT_SET(
//     IN PSAMP_OBJECT x
//    );
//
#define SAMP_LOCKOUT_TIME_SET(x) \
     (BOOLEAN)( ((x)->TypeBody.User.LockoutTime.QuadPart)!=0)


ULONG
SampPositionOfHighestBit(
    ULONG Flag
    );




NTSTATUS
SampInitWellKnownSDTable(
    VOID
);


NTSTATUS
SampGetCachedObjectSD(
    IN PSAMP_OBJECT Context,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );


NTSTATUS
SampCheckAndAddWellKnownAccounts(
    IN PVOID Parameter
    );


VOID
SampGenerateRandomPassword(
    IN LPWSTR Password,
    IN ULONG  Length
    );

#endif // _NTSAMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\rundown.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rundown.c

Abstract:

    This file contains context handle rundown services
    related to the SAM server RPC interface package..


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////






void
SAMPR_HANDLE_rundown(
    IN SAMPR_HANDLE SamHandle
    )

/*++

Routine Description:

    This service is called if a binding breaks when a context_handle is
    still active.

    Note that the RPC runtime will eliminate any race condition caused
    by an outstanding call to the server with this context handle that
    might cause the handle to become invalid before the rundown routine
    is called.

Arguments:

    SamHandle - The context handle value whose context must be rundown.
        Note that as far as RPC is concerned, this handle is no longer
        valid at the time the rundown call is made.

Return Value:


    None.


--*/
{

    NTSTATUS NtStatus;
    PSAMP_OBJECT Context;
    SAMP_OBJECT_TYPE FoundType;

    Context = (PSAMP_OBJECT)(SamHandle);



    SampAcquireReadLock();

    //
    // Lookup the context block
    //

    NtStatus = SampLookupContext(
                   Context,                 // Context
                   0L,                      // DesiredAccess
                   SampUnknownObjectType,   // ExpectedType
                   &FoundType               // FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

            // TEMPORARY
            //DbgPrint("Rundown of  ");
            //if (FoundType == SampServerObjectType) DbgPrint("Server ");
            //if (FoundType == SampDomainObjectType) DbgPrint("Domain ");
            //if (FoundType == SampGroupObjectType) DbgPrint("Group ");
            //if (FoundType == SampUserObjectType) DbgPrint("User ");
            //DbgPrint("context.\n");
            //DbgPrint("    Handle Value is:    0x%lx\n", Context );
            //if (Context->ReferenceCount != 2) {
            //DbgPrint("    REFERENCE COUNT is: 0x%lx\n", Context->ReferenceCount);
            //}
            // TEMPORARY

        //
        // Delete this context...
        //

        SampDeleteContext( Context );


        //
        // And drop our reference from the lookup operation
        //

        SampDeReferenceContext( Context, FALSE);


    }


    SampReleaseReadLock();


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\samss.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    samss.c

Abstract:

    This is the main routine for the Security Account Manager Server process.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    JimK        04-Jul-91
        Created initial file.
    ChrisMay    13-Aug-96
        Added branch at the end of SampInitialize to initialize domain con-
        trollers from the DS backing store instead of the registry.
    ChrisMay    07-Oct-96
        Added routine to support crash-recovery by booting from the registry
        as a fall back to booting from the DS.
    ChrisMay    02-Jan-97
        Moved call to SampDsBuildRootObjectName inside the test to determine
        whether or not the machine is a DC.
    ColinBr     23-Jan-97
        Added thread creation for delayed directory service initialization
    ColinBr     12-Jun-97
        Changed the crash-recovery hives to be stand alone server hives which
        exist under HKLM\SAM\SAFEMODE. Also layed foundation for supporting
        LsaISafeMode(), and eliminating the possibility of running a DC using
        registry hives.


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dslayer.h>
#include <dsdomain.h>
#include <sdconvrt.h>
#include <nlrepl.h>
#include <dsconfig.h>
#include <ridmgr.h>
#include <samtrace.h>
#include <dnsapi.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Module Private defines                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#define SAM_AUTO_BUILD

//
// Enable this define to compile in code to SAM that allows for the
// simulation of SAM initialization/installation failures.  See
// SampInitializeForceError() below for details.
//

// #define SAMP_SETUP_FAILURE_TEST 1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampRegistryDelnode(
    IN WCHAR* KeyPath
    );

NTSTATUS
SampInitialize(
    OUT PULONG Revision
    );

VOID
SampLoadPasswordFilterDll( VOID );

NTSTATUS
SampEnableAuditPrivilege( VOID );

NTSTATUS
SampFixGroupCount( VOID );

VOID
SampPerformInitializeFailurePopup( NTSTATUS ErrorStatus );


#ifdef SAMP_SETUP_FAILURE_TEST

NTSTATUS
SampInitializeForceError(
    OUT PNTSTATUS ForcedStatus
    );

#endif //SAMP_SETUP_FAILURE_TEST



#if SAMP_DIAGNOSTICS
VOID
SampActivateDebugProcess( VOID );

NTSTATUS
SampActivateDebugProcessWrkr(
    IN PVOID ThreadParameter
    );
#endif //SAMP_DIAGNOSTICS

NTSTATUS
SampCacheComputerObject();

NTSTATUS
SampQueryNetLogonChangeNumbers( VOID );

NTSTATUS
SampSetSafeModeAdminPassword(
    VOID
    );

NTSTATUS
SampApplyDefaultSyskey();

NTSTATUS
SampReadRegistryParameters(
    IN PVOID p
    );


VOID
SampMachineNameChangeCallBack(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
BOOLEAN
SampIsDownlevelDcUpgrade(
    VOID
    )
/*++

Routine Description:

    This is a downlevel dc upgrade if

    1) the product type is LanmanNT
    2) we are running during an upgrade
    3) there are no ntds parameter keys in the registry

Arguments:

Return Value:

    TRUE if the above conditions are satisfied; FALSE otherwise

--*/
{
    NTSTATUS          NtStatus;

    OBJECT_ATTRIBUTES KeyObject;
    HANDLE            KeyHandle;
    UNICODE_STRING    KeyName;


    if (SampProductType == NtProductLanManNt
     && SampIsSetupInProgress(NULL)) {

        //
        // Does the key exist ?
        //

        RtlInitUnicodeString(&KeyName, TEXT("\\Registry\\Machine\\") TEXT(DSA_CONFIG_ROOT));
        RtlZeroMemory(&KeyObject, sizeof(KeyObject));
        InitializeObjectAttributes(&KeyObject,
                                   &KeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        NtStatus = NtOpenKey(&KeyHandle,
                             KEY_READ,
                             &KeyObject);


        if (!NT_SUCCESS(NtStatus)) {
            //
            // The key not does or is not accessible so the ds has not
            // been installed, making this a downlevel upgrade
            //
            return TRUE;
        }

        CloseHandle(KeyHandle);

    }

    return FALSE;

}

NTSTATUS
SampChangeConfigurationKeyToValue(
    IN PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine checks for the existence of a key with the name "Name" under
    \\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa.  If it
    exists, then a value of "Name" is placed under 
    \\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa.

Arguments:

    Name -- the name of the key

Return Value:

    resource error only

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS StatusCheck;

    OBJECT_ATTRIBUTES KeyObject;
    HANDLE            KeyHandle;
    UNICODE_STRING    KeyName;

    WCHAR Path[256];
    WCHAR *RootPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa";
    HANDLE OldKey;

    //
    // Set up the path to the old key
    //
    RtlZeroMemory(Path, sizeof(Path));
    wcscpy(Path, RootPath);
    wcscat(Path, L"\\");
    wcsncat(Path, Name->Buffer, Name->Length);
    ASSERT(wcslen(Path) < sizeof(Path)/sizeof(Path[0]));

    RtlInitUnicodeString(&KeyName, Path);
    RtlZeroMemory(&KeyObject, sizeof(KeyObject));
    InitializeObjectAttributes(&KeyObject,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&OldKey,
                         DELETE,
                         &KeyObject);

    if (NT_SUCCESS(NtStatus)) {

        //
        // The key exists; add the value and then remove the key
        //
        RtlInitUnicodeString(&KeyName, RootPath);
        RtlZeroMemory(&KeyObject, sizeof(KeyObject));
        InitializeObjectAttributes(&KeyObject,
                                   &KeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
    
        NtStatus = NtOpenKey(&KeyHandle,
                             KEY_READ | KEY_WRITE,
                             &KeyObject);

        if (NT_SUCCESS(NtStatus)) {

            //
            // Add the value
            //
            ULONG             Value = 1;
            NtStatus =  NtSetValueKey(KeyHandle,
                                      Name,
                                      0,
                                      REG_DWORD,
                                      &Value,
                                      sizeof(Value));

            if (NT_SUCCESS(NtStatus)) {

                //
                // Remove the key
                //
                StatusCheck = NtDeleteKey(OldKey);
                ASSERT(NT_SUCCESS(StatusCheck));

            }

            StatusCheck = NtClose(KeyHandle);
            ASSERT(NT_SUCCESS(StatusCheck));

        }

        StatusCheck = NtClose(OldKey);
        ASSERT(NT_SUCCESS(StatusCheck));

    } else {

        //
        // Key doesn't exist -- that's fine, nothing to do
        //
        NtStatus = STATUS_SUCCESS;

    }

    return NtStatus;
}

VOID
SampChangeConfigurationKeys(
    VOID
    )
/*++

Routine Description:

    This routine changes configuration keys to values
    
    N.B. This code currently supports settings made in the Windows 2000
    release.  Once upgrade from this release is not supported, this
    code can be removed.

Arguments:

    None.

Return Value:

    None.         

--*/
{
    ULONG i;
    LPWSTR Values[] = 
    {
        L"IgnoreGCFailures",
        L"NoLmHash"
    };
    #define NELEMENTS(x) (sizeof(x)/sizeof((x)[0]))

    for (i = 0; i < NELEMENTS(Values) ; i++) {

        UNICODE_STRING NameU;
        NTSTATUS CheckStatus;

        RtlInitUnicodeString(&NameU, Values[i]);

        CheckStatus = SampChangeConfigurationKeyToValue(&NameU);
        ASSERT(NT_SUCCESS(CheckStatus));
    }

    return;

}

static CHAR BootMsg[100];




VOID
SampMachineNameChangeCallBack(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
/*++
Routine Description:

    Call back whenever machine name is change, so that SAM can update cached
    Account Domain Name

Parameter:

    ChangedInfoClass

Reture Value: 

    None

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PLSAPR_POLICY_INFORMATION   PolicyInfo = NULL;
    PSAMP_DEFINED_DOMAINS       Domain = NULL;
    ULONG       Index = 0; 

    ULONG       DnsNameLen = DNS_MAX_NAME_BUFFER_LENGTH+1;
    WCHAR       DnsNameBuffer[DNS_MAX_NAME_BUFFER_LENGTH+1];
    BOOLEAN     fCompareDnsDomainName = FALSE;



    //
    // only Account Domain info change is interested
    // 

    if ( SampUseDsData ||
         (PolicyNotifyAccountDomainInformation != ChangedInfoClass)
         )
    {
        return;
    }

    //
    // Query LSA Policy to get account domain name
    // 

    NtStatus = LsaIQueryInformationPolicyTrusted(
                    PolicyAccountDomainInformation,
                    &PolicyInfo
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        return;
    }

    //
    // get machine DNS name
    // 
    RtlZeroMemory(DnsNameBuffer, sizeof(WCHAR) * DnsNameLen);
    if ( GetComputerNameExW(ComputerNameDnsFullyQualified,
                            DnsNameBuffer,
                            &DnsNameLen) )
    {
        fCompareDnsDomainName = TRUE;
    }

    //
    // Acquire SAM Lock
    // 

    SampAcquireSamLockExclusive();


    //
    // scan SAM defined domain array (Account Domain Only)
    // and update cached Account Domain Name (machine name)
    // 
    for ( Index = 0; Index < SampDefinedDomainsCount; Index++ )
    {
        PWCHAR      pTmp = NULL;
        ULONG       BufLength = 0;

        Domain = &(SampDefinedDomains[Index]); 

        // not builtin domain
        if (!Domain->IsBuiltinDomain)
        {
            // Account Domain Name should be changed
            if (!RtlEqualUnicodeString(&(Domain->ExternalName),
                                       (UNICODE_STRING *)&(PolicyInfo->PolicyAccountDomainInfo.DomainName), 
                                       TRUE)  // case insensitive
                )
            {

                // allocate memory
                BufLength = PolicyInfo->PolicyAccountDomainInfo.DomainName.MaximumLength;  
                pTmp = RtlAllocateHeap( RtlProcessHeap(), 0, BufLength);
                if (NULL != pTmp)
                {
                    RtlZeroMemory(pTmp, BufLength);
                    RtlCopyMemory(pTmp, PolicyInfo->PolicyAccountDomainInfo.DomainName.Buffer, BufLength);
                    Domain->ExternalName.Length = PolicyInfo->PolicyAccountDomainInfo.DomainName.Length;
                    Domain->ExternalName.MaximumLength = PolicyInfo->PolicyAccountDomainInfo.DomainName.MaximumLength;

                    //
                    // release the old name
                    // 
                    RtlFreeHeap(RtlProcessHeap(), 0, Domain->ExternalName.Buffer);
                    Domain->ExternalName.Buffer = pTmp;
                    pTmp = NULL;
                }
            }

            // update DnsDomainName if necessary
            if (fCompareDnsDomainName)
            {
                // previous DnsDomainName is NULL or changed
                if ((NULL == Domain->DnsDomainName.Buffer) ||
                    (!DnsNameCompare_W(Domain->DnsDomainName.Buffer, DnsNameBuffer))
                    )
                {
                    BufLength = DnsNameLen * sizeof(WCHAR);

                    pTmp = RtlAllocateHeap( RtlProcessHeap(), 0, BufLength );
                    if (NULL != pTmp)
                    {
                        RtlZeroMemory(pTmp, BufLength);
                        RtlCopyMemory(pTmp, DnsNameBuffer, BufLength);
                        Domain->DnsDomainName.Length = (USHORT)BufLength;
                        Domain->DnsDomainName.MaximumLength = (USHORT)BufLength;

                        //
                        // release old value
                        // 
                        if (Domain->DnsDomainName.Buffer)
                        {
                            RtlFreeHeap(RtlProcessHeap(), 0, Domain->DnsDomainName.Buffer);
                        }
                        Domain->DnsDomainName.Buffer = pTmp;
                        pTmp = NULL;
                    }
                }
            }
        }
    }


    //
    // Release SAM Lock
    // 

    SampReleaseSamLockExclusive();

    if ( NULL != PolicyInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(PolicyAccountDomainInformation,
                                          PolicyInfo);
    }
}




NTSTATUS
SamIInitialize (
    VOID
    )

/*++

Routine Description:

    This is the initialization control routine for the Security Account
    Manager Server.  A mechanism is provided for simulating initialization
    errors.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully

        Simulated errors

        Errors from called routines.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    HANDLE EventHandle = NULL;
    ULONG Revision = 0;
    ULONG PromoteData;
    BOOLEAN fUpgrade = FALSE;


    SAMTRACE("SamIInitialize");

//
// The following conditional code is used to generate artifical errors
// during SAM installation for the purpose of testing setup.exe error
// handling.  This code should remain permanently, since it provides a
// way of testing against regressions in the setup error handling code.
//

#ifdef SAMP_SETUP_FAILURE_TEST
    NTSTATUS ForcedStatus;

    //
    // Read an error code from the Registry.
    //

    NtStatus = SampInitializeForceError( &ForcedStatus);

    if (!NT_SUCCESS(NtStatus)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Attempt to force error failed 0x%lx\n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM will try to initialize normally\n"));

        NtStatus = STATUS_SUCCESS;

    } else {

        //
        // Use the status returned
        //

        NtStatus = ForcedStatus;
    }

#endif // SAMP_SETUP_FAILURE_TEST

    //
    // Initialize SAM if no error was forced.
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampInitialize( &Revision );
    }

    //
    // Register our shutdown routine
    //

    if (!SetConsoleCtrlHandler(SampShutdownNotification, TRUE)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM Server: SetConsoleCtrlHandler call failed %d\n",
                   GetLastError()));
    }

    if (!SetProcessShutdownParameters(SAMP_SHUTDOWN_LEVEL,SHUTDOWN_NORETRY)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM Server: SetProcessShutdownParameters call failed %d\n",
                   GetLastError()));
    }


    //
    // Register Domain Name Change Notification Call Back (Registry Mode Only)
    // 
    if (!SampUseDsData && NT_SUCCESS(NtStatus))
    {
        NtStatus = LsaIRegisterPolicyChangeNotificationCallback(
                        SampMachineNameChangeCallBack,
                        PolicyNotifyAccountDomainInformation
                        );
    }

    //
    // Try to load the cached Alias Membership information and turn on caching.
    // In Registry Case, if unsuccessful, caching remains disabled forever.
    //

    //
    // For DS Case, enable Builtin Domain's Alias Membership information.
    // in Registry Case, enable both Builtin Domain and Account Domain Alias Caching.
    //

    if (NT_SUCCESS(NtStatus))
    {
        if (TRUE==SampUseDsData)
        {
            LsaIRegisterNotification(
                        SampAlDelayedBuildAliasInformation,
                        NULL,
                        NOTIFIER_TYPE_INTERVAL,
                        0,
                        NOTIFIER_FLAG_ONE_SHOT,
                        150,        // wait for 5 minutes: 300 secound
                        0
                        );

            //
            // Create the builtin account name cache
            //
            NtStatus = SampInitAliasNameCache();
            if (!NT_SUCCESS(NtStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "[SAMSS]: SampInitAliasNameCache failed (0x%x)", NtStatus));
            }

        }
        else
        {
            IgnoreStatus = SampAlBuildAliasInformation();

            if ( !NT_SUCCESS(IgnoreStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAM Server: Build Alias Cache access violation handled"));

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAM Server: Alias Caching turned off\n"));
            }
        }
    }

    //
    // Perform any necessary upgrades.
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampUpgradeSamDatabase(
                        Revision
                        );
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM Server: Failed to upgrade SAM database: 0x%x\n",
                       NtStatus));
        }
    }


    //
    // (Almost) Everyone is initialized, start processing calls.
    //

    SampServiceState = SampServiceEnabled;
    
    //
    // Do phase 2 of promotion, if necessary.  This must be
    // called after the ServiceState is set to enabled.
    //

    if (NT_SUCCESS(NtStatus) && !LsaISafeMode() )
    {
        if (SampIsRebootAfterPromotion(&PromoteData)) {

            SampDiagPrint( PROMOTE, ("SAMSS: Performing phase 2 of SAM promotion\n"));

            NtStatus = SampPerformPromotePhase2(PromoteData);

            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SampCreateNewDsDomainAccounts returned: 0x%x\n",
                           NtStatus));
            }

        }
    }

    if ( (NT_SUCCESS(NtStatus))
     &&  SampIsSetupInProgress( &fUpgrade )
     &&  fUpgrade 
     &&  SampUseDsData ) {

        //
        // This is GUI mode setup then upgrade all the group information
        // This is now being run for the benefit of DS data
        //
        NtStatus = SampPerformPromotePhase2(SAMP_PROMOTE_INTERNAL_UPGRADE);

        if (!NT_SUCCESS(NtStatus)) {

            ASSERT( NT_SUCCESS(NtStatus) );
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: New account creation failed with: 0x%x\n",
                       NtStatus));

            //
            // Don't fail the install because of this
            //
            NtStatus = STATUS_SUCCESS;
        }
    }

    
    //
    // In DS Mode cache the DS name of the computer object
    //

    if ((SampUseDsData) && (NT_SUCCESS(NtStatus)))
    {
       SampCacheComputerObject();
    }


    if (NT_SUCCESS(NtStatus) && SampUseDsData)
    {
        // Tell the Core DS that SAM is running, it can now start tasks that
        // would have conflicted with SAM startup.
        SampSignalStart();
    }

    //
    // Startup the thread that initializes the backup restore interface
    //

    if (SampUseDsData || LsaISafeMode())
    {
        HANDLE ThreadHandle;
        ULONG  ThreadId;

        // This is either a DC in normal or repair mode
        // Create a thread to host Directory Service Backup/Restore

        ThreadHandle = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) SampDSBackupRestoreInit,
                            NULL,
                            0,
                            &ThreadId
                            );


        if (ThreadHandle == NULL)
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS:  Unable to create SampDSBackupRestoreInit thread: %d\n",
                       GetLastError()));

            // If unable to create the DS Backup Restore thread, we should still be
            // able to boot. Should not return error at this point.
        }
        else
        {
            CloseHandle(ThreadHandle);
        }
    }

    //
    // In Ds Mode perform RID manager initialization synchronously
    // NT5 Relative ID (RID) management is distributed because accounts
    // can be created on any DC in the domain, and not just the primary
    // domain controller. Initialization of the RID Manager sets initial
    // RID values and reads the DS to restore previous RID pools.
    //


    if ((SampUseDsData) && (NT_SUCCESS(NtStatus)))
    {

        //
        // Try initializing the RID manager
        //

        NtStatus = SampDomainRidInitialization(TRUE);
        if (!NT_SUCCESS(NtStatus))
        {
            // RID initialization failure will prohibit the DC from creating
            // new accounts, groups, or aliases.

            //
            // SampDomainRidInitialization reschedules itself so this 
            // error has been handled
            //
            NtStatus = STATUS_SUCCESS;
        }
        else
        {
            //
            // Rids are initialized. Turn on the Writable Bit
            //
            I_NetLogonSetServiceBits(DS_WRITABLE_FLAG,DS_WRITABLE_FLAG);
        }


    }

    //
    // In DS Mode, protect SAM Server Object from being renamed or deleted
    // 

    if ((SampUseDsData) && NT_SUCCESS(NtStatus))
    {
        LsaIRegisterNotification(
                    SampDsProtectServerObject,
                    NULL,
                    NOTIFIER_TYPE_INTERVAL,
                    0,
                    NOTIFIER_FLAG_ONE_SHOT,
                    300,        // wait for 5 minutes: 300 secound
                    0
                    );
    }


    //
    // In DS mode, Register WMI trace
    //

    if (SampUseDsData && NT_SUCCESS(NtStatus))
    {
        HANDLE   ThreadHandle;
        ULONG    ThreadId = 0;

        ThreadHandle = CreateThread(NULL,
                                    0,
                                    SampInitializeTrace,
                                    NULL,
                                    0,
                                    &ThreadId
                                    );

        if (NULL == ThreadHandle)
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Failed to Create SampInitailizeTrace thread. Error ==> %d \n",
                       GetLastError()));
        }
        else
        {
            CloseHandle(ThreadHandle);
        }
    }


    //
    // If requested, activate a diagnostic process.
    // This is a debug aid expected to be used for SETUP testing.
    //

#if SAMP_DIAGNOSTICS
    IF_SAMP_GLOBAL( ACTIVATE_DEBUG_PROC ) {

        SampActivateDebugProcess();
    }
#endif //SAMP_DIAGNOSTICS

    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SAM server failed to initialize (%08lx)\n",
                   NtStatus));

        //
        // If SAM server failed initialization due to DS failure.
        // give the user shutdown option, and instruct him to boot
        // to safe boot.

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM Server: SamIInitialize failed with status code:0x%x, about to call into SampPerformInitializeFailurePopup.\n",
                   NtStatus));

        SampPerformInitializeFailurePopup(NtStatus);

    }

    return(NtStatus);
}


BOOLEAN
SampUsingDsData()

/*++

    Itty bitty export so in-process clients know which mode we're in.

--*/

{
    return(SampUseDsData);
}

BOOLEAN
SamIAmIGC()
{
    if (SampUseDsData) {
        return((BOOLEAN)SampAmIGC());
    } else {
        return FALSE;
    }
}









NTSTATUS
SampInitContextList(
    VOID
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

    __try
    {
        NtStatus = RtlInitializeCriticalSectionAndSpinCount(
                        &SampContextListCritSect,
                        4000
                        );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    IgnoreStatus = RtlEnterCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    InitializeListHead(&SampContextListHead);

    IgnoreStatus = RtlLeaveCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return( NtStatus );
}
    


NTSTATUS
SampInitialize(
    OUT PULONG Revision
    )

/*++

Routine Description:

    This routine does the actual initialization of the SAM server.  This includes:

        - Initializing well known global variable values

        - Creating the registry exclusive access lock,

        - Opening the registry and making sure it includes a SAM database
          with a known revision level,

        - Starting the RPC server,

        - Add the SAM services to the list of exported RPC interfaces



Arguments:

    Revision - receives the revision of the database.

Return Value:

    STATUS_SUCCESS - Initialization has successfully completed.

    STATUS_UNKNOWN_REVISION - The SAM database has an unknown revision.



--*/
{
    NTSTATUS            NtStatus;
    NTSTATUS            IgnoreStatus;
    LPWSTR              ServiceName;

    PSAMP_OBJECT ServerContext;
    OBJECT_ATTRIBUTES SamAttributes;
    UNICODE_STRING SamNameU;
    UNICODE_STRING SamParentNameU;
    PULONG RevisionLevel;
    BOOLEAN ProductExplicitlySpecified;
    PPOLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    CHAR    NullLmPassword = 0;
    RPC_STATUS  RpcStatus;
    HANDLE      ThreadHandle, ThreadHandleTmp;
    ULONG       ThreadId;
    BOOLEAN     CrashRecoveryMode = FALSE;
    BOOLEAN     RegistryMode = FALSE;
    BOOLEAN     DownlevelDcUpgrade = FALSE;
    BOOLEAN     RecreateHives = FALSE;
    PNT_PRODUCT_TYPE  DatabaseProductType = NULL;
    NT_PRODUCT_TYPE   TempDatabaseProductType;
    DWORD             PromoteData;
    BOOLEAN     fUpgrade;
    BOOLEAN     fSetup;

    SAMTRACE("SampInitialize");

    //
    // Set the state of our service to "initializing" until everything
    // is initialized.
    //

    SampServiceState = SampServiceInitializing;


    //
    // Initialize the Shutdown Handler, we get shut down notifications
    // regardless
    //

    NtStatus = SampInitializeShutdownEvent();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Check the environment
    //
    fSetup = SampIsSetupInProgress(&fUpgrade);

    //
    // Initialize the logging resources
    //
    NtStatus = SampInitLogging();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Change any configuration keys
    //
    if (fUpgrade) {

        SampChangeConfigurationKeys();
    }

    //
    // Read configuration data and register for updates
    //
    LsaIRegisterNotification( SampReadRegistryParameters,
                              0,
                              NOTIFIER_TYPE_NOTIFY_EVENT,
                              NOTIFY_CLASS_REGISTRY_CHANGE,
                              0,
                              0,
                              0 );
    (VOID) SampReadRegistryParameters(NULL);

    //
    // Set up some useful well-known sids
    //

    NtStatus = SampInitializeWellKnownSids();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Get the product type
    //

    ProductExplicitlySpecified = RtlGetNtProductType(&SampProductType);

    //
    // Are we in safe mode?
    //
    CrashRecoveryMode = LsaISafeMode();

    //
    // Is this a downlevel dc upgrade ?
    //
    DownlevelDcUpgrade = SampIsDownlevelDcUpgrade();


    //
    // initialize Active Context Table
    // 

    SampInitializeActiveContextTable();

    //
    // Initialize the server/domain context list
    //

    NtStatus = SampInitContextList();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Initialize the attribute field information of the object
    // information structures.
    //

    SampInitObjectInfoAttributes();

    //
    // Set up the generic mappings for the SAM object types
    //

    SampObjectInformation[ SampServerObjectType ].GenericMapping.GenericRead
        = SAM_SERVER_READ;
    SampObjectInformation[ SampServerObjectType ].GenericMapping.GenericWrite
        = SAM_SERVER_WRITE;
    SampObjectInformation[ SampServerObjectType ].GenericMapping.GenericExecute
        = SAM_SERVER_EXECUTE;
    SampObjectInformation[ SampServerObjectType ].GenericMapping.GenericAll
        = SAM_SERVER_ALL_ACCESS;

    SampObjectInformation[ SampDomainObjectType ].GenericMapping.GenericRead
        = DOMAIN_READ;
    SampObjectInformation[ SampDomainObjectType ].GenericMapping.GenericWrite
        = DOMAIN_WRITE;
    SampObjectInformation[ SampDomainObjectType ].GenericMapping.GenericExecute
        = DOMAIN_EXECUTE;
    SampObjectInformation[ SampDomainObjectType ].GenericMapping.GenericAll
        = DOMAIN_ALL_ACCESS;

    SampObjectInformation[ SampGroupObjectType ].GenericMapping.GenericRead
        = GROUP_READ;
    SampObjectInformation[ SampGroupObjectType ].GenericMapping.GenericWrite
        = GROUP_WRITE;
    SampObjectInformation[ SampGroupObjectType ].GenericMapping.GenericExecute
        = GROUP_EXECUTE;
    SampObjectInformation[ SampGroupObjectType ].GenericMapping.GenericAll
        = GROUP_ALL_ACCESS;

    SampObjectInformation[ SampAliasObjectType ].GenericMapping.GenericRead
        = ALIAS_READ;
    SampObjectInformation[ SampAliasObjectType ].GenericMapping.GenericWrite
        = ALIAS_WRITE;
    SampObjectInformation[ SampAliasObjectType ].GenericMapping.GenericExecute
        = ALIAS_EXECUTE;
    SampObjectInformation[ SampAliasObjectType ].GenericMapping.GenericAll
        = ALIAS_ALL_ACCESS;

    SampObjectInformation[ SampUserObjectType ].GenericMapping.GenericRead
        = USER_READ;
    SampObjectInformation[ SampUserObjectType ].GenericMapping.GenericWrite
        = USER_WRITE;
    SampObjectInformation[ SampUserObjectType ].GenericMapping.GenericExecute
        = USER_EXECUTE;
    SampObjectInformation[ SampUserObjectType ].GenericMapping.GenericAll
        = USER_ALL_ACCESS;

    //
    // Set mask of INVALID accesses for an access mask that is already mapped.
    //

    SampObjectInformation[ SampServerObjectType ].InvalidMappedAccess
        = (ULONG)(~(SAM_SERVER_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED));
    SampObjectInformation[ SampDomainObjectType ].InvalidMappedAccess
        = (ULONG)(~(DOMAIN_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED));
    SampObjectInformation[ SampGroupObjectType ].InvalidMappedAccess
        = (ULONG)(~(GROUP_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED));
    SampObjectInformation[ SampAliasObjectType ].InvalidMappedAccess
        = (ULONG)(~(ALIAS_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED));
    SampObjectInformation[ SampUserObjectType ].InvalidMappedAccess
        = (ULONG)(~(USER_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED));

    //
    // Set a mask of write operations for the object types.  Strip
    // out READ_CONTROL, which doesn't allow writing but is defined
    // in all of the standard write accesses.
    // This is used to enforce correct role semantics (e.g., only
    // trusted clients can perform write operations when a domain
    // role isn't Primary).
    //
    // Note that USER_WRITE isn't good enough for user objects.  That's
    // because USER_WRITE allows users to modify portions of their
    // account information, but other portions can only be modified by
    // an administrator.
    //

    SampObjectInformation[ SampServerObjectType ].WriteOperations
        = (SAM_SERVER_WRITE & ~READ_CONTROL) | DELETE;
    SampObjectInformation[ SampDomainObjectType ].WriteOperations
        = (DOMAIN_WRITE & ~READ_CONTROL) | DELETE;
    SampObjectInformation[ SampGroupObjectType ].WriteOperations
        = (GROUP_WRITE & ~READ_CONTROL) | DELETE;
    SampObjectInformation[ SampAliasObjectType ].WriteOperations
        = (ALIAS_WRITE & ~READ_CONTROL) | DELETE;
    SampObjectInformation[ SampUserObjectType ].WriteOperations
        = ( USER_WRITE & ~READ_CONTROL ) | USER_WRITE_ACCOUNT |
          USER_FORCE_PASSWORD_CHANGE | USER_WRITE_GROUP_INFORMATION | DELETE;

    // Set up the names of the SAM defined object types.
    // These names are used for auditing purposes.

    RtlInitUnicodeString( &SamNameU, L"SAM_SERVER" );
    SampObjectInformation[ SampServerObjectType ].ObjectTypeName = SamNameU;
    RtlInitUnicodeString( &SamNameU, L"SAM_DOMAIN" );
    SampObjectInformation[ SampDomainObjectType ].ObjectTypeName = SamNameU;
    RtlInitUnicodeString( &SamNameU, L"SAM_GROUP" );
    SampObjectInformation[ SampGroupObjectType ].ObjectTypeName  = SamNameU;
    RtlInitUnicodeString( &SamNameU, L"SAM_ALIAS" );
    SampObjectInformation[ SampAliasObjectType ].ObjectTypeName  = SamNameU;
    RtlInitUnicodeString( &SamNameU, L"SAM_USER" );
    SampObjectInformation[ SampUserObjectType ].ObjectTypeName   = SamNameU;

    //
    // Set up the name of the SAM server object itself (rather than its type)
    //

    RtlInitUnicodeString( &SampServerObjectName, L"SAM" );

    //
    // Set up the name of the SAM server for auditing purposes
    //

    RtlInitUnicodeString( &SampSamSubsystem, L"Security Account Manager" );

    //
    // Set up the names of well known registry keys
    //

    RtlInitUnicodeString( &SampFixedAttributeName,    L"F" );
    RtlInitUnicodeString( &SampVariableAttributeName, L"V" );
    RtlInitUnicodeString( &SampCombinedAttributeName, L"C" );

    RtlInitUnicodeString(&SampNameDomains, L"DOMAINS" );
    RtlInitUnicodeString(&SampNameDomainGroups, L"Groups" );
    RtlInitUnicodeString(&SampNameDomainAliases, L"Aliases" );
    RtlInitUnicodeString(&SampNameDomainAliasesMembers, L"Members" );
    RtlInitUnicodeString(&SampNameDomainUsers, L"Users" );
    RtlInitUnicodeString(&SampNameDomainAliasesNames, L"Names" );
    RtlInitUnicodeString(&SampNameDomainGroupsNames, L"Names" );
    RtlInitUnicodeString(&SampNameDomainUsersNames, L"Names" );



    //
    // Initialize other useful characters and strings
    //

    RtlInitUnicodeString(&SampBackSlash, L"\\");
    RtlInitUnicodeString(&SampNullString, L"");


    //
    // Initialize some useful time values
    //

    SampImmediatelyDeltaTime.LowPart = 0;
    SampImmediatelyDeltaTime.HighPart = 0;

    SampNeverDeltaTime.LowPart = 0;
    SampNeverDeltaTime.HighPart = MINLONG;

    SampHasNeverTime.LowPart = 0;
    SampHasNeverTime.HighPart = 0;

    SampWillNeverTime.LowPart = MAXULONG;
    SampWillNeverTime.HighPart = MAXLONG;


    //
    // Initialize useful encryption constants
    //

    NtStatus = RtlCalculateLmOwfPassword(&NullLmPassword, &SampNullLmOwfPassword);
    ASSERT( NT_SUCCESS(NtStatus) );

    RtlInitUnicodeString(&SamNameU, NULL);
    NtStatus = RtlCalculateNtOwfPassword(&SamNameU, &SampNullNtOwfPassword);
    ASSERT( NT_SUCCESS(NtStatus) );


    //
    // Initialize variables for the hive flushing thread
    //

    LastUnflushedChange.LowPart = 0;
    LastUnflushedChange.HighPart = 0;

    FlushThreadCreated  = FALSE;
    FlushImmediately    = FALSE;

    SampFlushThreadMinWaitSeconds   = 30;
    SampFlushThreadMaxWaitSeconds   = 600;
    SampFlushThreadExitDelaySeconds = 120;


    //
    // Enable the audit privilege (needed to use NtAccessCheckAndAuditAlarm)
    //

    NtStatus = SampEnableAuditPrivilege();

    if (!NT_SUCCESS(NtStatus)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  The SAM Server could not enable the audit Privilege.\n"
                   "              Failing to initialize SAM.\n"));

        return( NtStatus );
    }

    //
    // Get Auditing Information from the LSA and save information
    // relevant to SAM.
    //

    NtStatus = LsaIQueryInformationPolicyTrusted(
                   PolicyAuditEventsInformation,
                   (PLSAPR_POLICY_INFORMATION *) &PolicyAuditEventsInfo
                   );

    if (NT_SUCCESS(NtStatus)) {

        SampSetAuditingInformation( PolicyAuditEventsInfo );

    } else {

        //
        // Failed to query Audit Information from LSA.  Allow SAM to
        // continue initializing wuth SAM Account auditing turned off.
        //

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  Query Audit Info from LSA returned 0x%lX\n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  Sam Account Auditing is not enabled"));

        SampSuccessAccountAuditingEnabled = FALSE;
        SampFailureAccountAuditingEnabled = FALSE;
        NtStatus = STATUS_SUCCESS;
    }

    //
    // We no longer need the Lsa Audit Events Info data.
    //

    if (PolicyAuditEventsInfo != NULL) {

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAuditEventsInformation,
            (PLSAPR_POLICY_INFORMATION) PolicyAuditEventsInfo
            );
    }

    //
    // Create the internal data structure and backstore lock ...
    //

    __try
    {
        RtlInitializeResource(&SampLock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
          KdPrintEx((DPFLTR_SAMSS_ID,
                     DPFLTR_INFO_LEVEL,
                     "SAM failed to initialize SamLock under low memory condition. Exceptin thrown: 0x%x (%d)\n",
                     GetExceptionCode(),
                     GetExceptionCode()));

          NtStatus = STATUS_INSUFFICIENT_RESOURCES;
          return (NtStatus);
    }

    //
    // Open the registry and make sure it includes a SAM database.
    // Also make sure this SAM database has been initialized and is
    // at a revision level we understand.
    //



    RtlInitUnicodeString( &SamParentNameU, L"\\Registry\\Machine\\Security" );
    RtlInitUnicodeString( &SamNameU, L"\\Registry\\Machine\\Security\\SAM" );



    //
    // Check if this is the Reboot after a DC promotion/demotion.
    // In this case we will have delete old sam hives and recreate new
    // hives depending upon the type of promotion operation. We create
    // new hives on all cases of role changes. The only exception to
    // the rule is the reboot after the GUI setup phase of the NT4/NT5.1 backup,
    // in which case we create the hives before the reboot in order to
    // preserve the syskey settings. The flag SAMP_TEMP_UPGRADE in promote
    // data indicates that it is the case of a reboot after a GUI mode setup
    // phase of an NT4 / NT3.51 backup domain controller.
    //

    //
    // Note the check for the admin password.  The logic here is that 
    // anytime a SAM database is recreated due to a role change there
    // should be an administrative password to set.  Also, this handles
    // the case where after a promotion, the server is immediately
    // started in ds repair mode: in this case we want to recreate
    // the database and set the password; however when starting in the
    // DS mode afterwards, we don't want to recreate the repair 
    // database again.  The act of setting the password removes
    // the registry that makes SampGetAdminPasswordFromRegistry return
    // STATUS_SUCCESS.
    //
    if (  (SampIsRebootAfterPromotion(&PromoteData)) 
       &&  NT_SUCCESS(SampGetAdminPasswordFromRegistry(NULL))
       && (!FLAG_ON( (PromoteData), SAMP_TEMP_UPGRADE ) ) )
    {
        //
        // Get rid of the old database
        //
        NtStatus = SampRegistryDelnode( SamNameU.Buffer );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            //
            // This is itself is no reason to bail on initialization
            //
            NtStatus = STATUS_SUCCESS;
        }

        RecreateHives = TRUE;
    }

    if ( SampProductType == NtProductLanManNt )
    {
        //
        // The registry domain is really an account type domain
        //
        TempDatabaseProductType = NtProductServer;
        DatabaseProductType = &TempDatabaseProductType;
    }

    ASSERT( NT_SUCCESS(NtStatus) );

    InitializeObjectAttributes(
        &SamAttributes,
        &SamNameU,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &SamAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &SampKey,
                   (KEY_READ | KEY_WRITE),
                   &SamAttributes,
                   0
                   );

    if ( NtStatus == STATUS_OBJECT_NAME_NOT_FOUND ) {


        if (!SampIsSetupInProgress(NULL) && !RecreateHives)
        {
            //
            // This is not a boot after dcpromo, and
            // this is not a GUI setup either, fail
            // OS startup. This prevents easy offline
            // attacks against other components in the system
            // by recreating the SAM hives
            //

            return(STATUS_UNSUCCESSFUL);
        }


#ifndef SAM_AUTO_BUILD

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL, " NEWSAM\\SERVER: Sam database not found in registry.\n"
                   "                Failing to initialize\n"));

        return(NtStatus);

#endif //SAM_AUTO_BUILD

#if DBG
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " NEWSAM\\SERVER: Initializing SAM registry database for\n"));

        if (DatabaseProductType) {
            if (*DatabaseProductType == NtProductWinNt) {
                DbgPrint("                WinNt product.\n");
            } else if ( *DatabaseProductType == NtProductLanManNt ) {
                DbgPrint("                LanManNt product.\n");
            } else {
                DbgPrint("                Dedicated Server product.\n");
            }
        } else{
            if (SampProductType == NtProductWinNt) {
                DbgPrint("                WinNt product.\n");
            } else if ( SampProductType == NtProductLanManNt ) {
                DbgPrint("                LanManNt product.\n");
            } else {
                DbgPrint("                Dedicated Server product.\n");
            }
        }
#endif //DBG

        //
        // Change the flush thread timeouts.  This is necessary because
        // the reboot following an installation does not call
        // ExitWindowsEx() and so our shutdown notification routine does
        // not get called.  Consequently, it does not have a chance to
        // flush any changes that were obtained by syncing with a PDC.
        // If there are a large number of accounts, it could be
        // extremely expensive to do another full re-sync.  So, close
        // the flush thread wait times so that it is pretty sure to
        // have time to flush.
        //

        SampFlushThreadMinWaitSeconds   = 5;

        NtStatus = SampInitializeRegistry(SamParentNameU.Buffer,
                                          DatabaseProductType,
                                          NULL,     // Server Role - NULL implies
                                                    // call into LSA
                                          NULL,     // AccountDomainInfo - NULL implies call into
                                                    // LSA
                                          NULL,      // PrimaryDomainInfo - NULL implies call into
                                                    // LSA
                                          FALSE
                                          );


        if (!NT_SUCCESS(NtStatus)) {

            return(NtStatus);
        }

        SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &SamAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &SampKey,
                       (KEY_READ | KEY_WRITE),
                       &SamAttributes,
                       0
                       );
    }

    if (!NT_SUCCESS(NtStatus)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL, "SAM Server: Could not access the SAM database.\n"
                   "            Status is 0x%lx \n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            Failing to initialize SAM.\n"));

        return(NtStatus);
    }

    //
    // The following subroutine may be removed from the code
    // following the Daytona release.  By then it will have fixed
    // the group count.
    //

    NtStatus = SampFixGroupCount();


    //
    // We need to read the fixed attributes of the server objects.
    // Create a context to do that.
    //
    // Server Object doesn't care about DomainIndex, use 0 is fine. (10/12/2000 ShaoYin)
    // Note: we are creating a registry mode object here (DS does not start yet)
    // 

    ServerContext = SampCreateContextEx(SampServerObjectType,   // Object Type
                                        TRUE,   // trusted client
                                        FALSE,  // Registry Object, not DS object
                                        TRUE,   // Not Shared By multi Threads
                                        FALSE,  // loopback client
                                        FALSE,  // lazy commit
                                        FALSE,  // persis across calls
                                        FALSE,  // Buffer Writes
                                        FALSE,  // Opened By DCPromo
                                        0       // Domain Index
                                        );


    if ( ServerContext == NULL ) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL, "SAM Server: Could not create server context.\n"
                   "            Failing to initialize SAM.\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // The RootKey for a SERVER object is the root of the SAM database.
    // This key should not be closed when the context is deleted.
    //

    ServerContext->RootKey = SampKey;

    //
    // Get the FIXED attributes, which just consists of the revision level.
    //


    NtStatus = SampGetFixedAttributes(
                   ServerContext,
                   FALSE,
                   (PVOID *)&RevisionLevel
                   );

    if (NtStatus != STATUS_SUCCESS) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM Server: Could not access the SAM database revision level.\n"));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            Status is 0x%lx \n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            Failing to initialize SAM.\n"));

        return(NtStatus);
    }

    *Revision = *RevisionLevel;

    if ( SAMP_UNKNOWN_REVISION( *Revision ) ) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM Server: The SAM database revision level is not one supported\n"));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            by this version of the SAM server code.  The highest revision\n"));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            level supported is 0x%lx.  The SAM Database revision is 0x%lx \n",
                   (ULONG)SAMP_SERVER_REVISION,
                   *Revision));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            Failing to initialize SAM.\n"));

        return(STATUS_UNKNOWN_REVISION);
    }

    SampDeleteContext( ServerContext );

    //
    // If necessary, commit a partially commited transaction.
    //

    NtStatus = RtlInitializeRXact( SampKey, TRUE, &SampRXactContext );

    if ( NtStatus == STATUS_RXACT_STATE_CREATED ) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  RXACT state of the SAM database didn't yet exist.\n"
                   "              Failing to initialize SAM.\n"));

        return(NtStatus);
    } else if (!NT_SUCCESS(NtStatus)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  RXACT state of the SAM database didn't initialize properly.\n"));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "              Status is 0x%lx \n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "              Failing to initialize SAM.\n"));

        return(NtStatus);
    }

    if ( NtStatus == STATUS_RXACT_COMMITTED ) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  Previously aborted backstore commit was completed\n"
                   "              during SAM initialization.  This is not a cause\n"
                   "              for alarm.\n"
                   "              Continuing with SAM initialization.\n"));
    }


    //
    // Allow each sub-component of SAM a chance to initialize
    //

    // Initialize the domain objects of this DC. Each hosted domain
    // is composed of two domains: Builtin and Account. The first hosted
    // domain fills the first two elements of the SampDefinedDomains array,
    // the next hosted domain fills the next two elements, and so on.
    //
    // The first hosted domain is always setup. On a workstation or server,
    // the hosted domain contains the account information for normal opera-
    // tion. On a domain controller, this same domain contains the crash-
    // recovery accounts, used in the event that the DS is unable to start
    // or run correctly. Subsequent hosted domains (on a DC) contain the
    // account information for a normally running DC, and this account data
    // is persistently stored in the DS.

    SampDiagPrint(INFORM,
                  ("SAMSS: Initializing domain-controller domain objects\n"));

    if (!SampInitializeDomainObject())
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Domain Object Intialization Failed.\n"
                   "        Failing to initialize SAM Server.\n"));

        return(STATUS_INVALID_DOMAIN_STATE);
    }

    //
    // Intialize the session key for password encryption. Note this step
    // is done before the repair boot password is set below, so that
    // syskey based encryption is achieved for the repair boot password.
    //

    NtStatus = SampInitializeSessionKey();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Set the ds registry password if necessary
    //
    if (  SampIsRebootAfterPromotion(&PromoteData)
        && (  FLAG_ON( PromoteData, SAMP_PROMOTE_REPLICA )
           || FLAG_ON( PromoteData, SAMP_PROMOTE_DOMAIN ) ) 
        && (   ((NtProductLanManNt == SampProductType)
              && !DownlevelDcUpgrade) 
           || ((NtProductServer == SampProductType)
              && LsaISafeMode() ) )
        ) {

        (VOID) SampSetSafeModeAdminPassword();

    }

    //
    // Determine that the product is a domain controller and that it is
    // not in gui mode setup, hence, should reference the
    // DS for account data.
    //

    if (NtProductLanManNt == SampProductType
        && !DownlevelDcUpgrade)
    {
        // If the product type is a domain controller and it is not recover-
        // ing from a previous crash, reference the DS for account data.

        SampUseDsData = TRUE;
        SampDiagPrint(INFORM,
                      ("SAMSS: Domain controller is using DS data.\n"));
    }
    else
    {
        SampUseDsData = FALSE;
        SampDiagPrint(INFORM,
                      ("SAMSS: Domain controller is using registry data.\n"));
    }

    if (TRUE == SampUseDsData)
    {
        UNICODE_STRING ServerObjectRDN;
        UNICODE_STRING SystemContainerRDN;
        DSNAME         *SampSystemContainerDsName;


        //
        // Now, initialize the domain objects from the DS
        //

        NtStatus = SampDsInitializeDomainObjects();

        SampDiagPrint(INFORM,
                      ("SAMSS: SampDsInitializeDomainObjects status = 0x%lx\n",
                       NtStatus));

        if (!NT_SUCCESS(NtStatus))
        {
            // If SampDsInitializeDomainObjects failed, it is likely that the
            // DS failed to start. It is likely that the DS was unable to
            // start, be accessed, or there may be a data corruption.

            return(NtStatus);

        }

        NtStatus = SampInitializeAccountNameTable();

        if (!NT_SUCCESS(NtStatus))
        {
            //
            // If we failed to init SampAccountNameTable. We can not
            // function well
            // 

            return(NtStatus);
        }

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampInitializeAccountNameTable SUCCEED ==> %d\n",
                   NtStatus));


        //
        // Create the DS Name of the Sam server Object. The current logic assumes a hard
        // coded path for the system container / Server object. This will be changed, once
        // the new method of querying for the system container, in a rename safe way, comes
        // online
        //

        RtlInitUnicodeString(&SystemContainerRDN,L"System");

        NtStatus = SampDsCreateDsName(
                        SampDefinedDomains[DOMAIN_START_DS+1].Context->ObjectNameInDs,
                        &SystemContainerRDN,
                        &SampSystemContainerDsName
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Create the SAM server Object's Name, boot to safe mode\n"));

            return(STATUS_INVALID_DOMAIN_STATE);
        }

        RtlInitUnicodeString(&ServerObjectRDN,L"Server");

        NtStatus = SampDsCreateDsName(
                        SampSystemContainerDsName,
                        &ServerObjectRDN,
                        &SampServerObjectDsName
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Create the SAM server Object's Name, boot to safe mode \n"));

            return(STATUS_INVALID_DOMAIN_STATE);
        }

        MIDL_user_free(SampSystemContainerDsName);


        //
        // Initialize the well known (server / domain objects) Security 
        // Descriptor Table.
        // 

        NtStatus = SampInitWellKnownSDTable();

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID, 
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Cache SAM server/domain Object's Security Descriptor\n"));

            return( NtStatus );
        }


        //
        // Initialize the access Rights for NT5 Security descriptors
        //

        NtStatus = SampInitializeAccessRightsTable();

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Initialize the access rights table, set \"samusereg\" switch in system starttup\n"));

            return(STATUS_INVALID_DOMAIN_STATE);
        }

        //
        // Initialize the site information
        //

        NtStatus = SampInitSiteInformation();

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Initialize site information\n"));

            NtStatus = STATUS_SUCCESS;
        }


        SampIsMachineJoinedToDomain = TRUE;
    }
    else
    {
        // 
        // This machine is not a DC
        // check whether it is running Personal SKU
        // if not, if it joins to a domain
        // 
        OSVERSIONINFOEXW osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
        if(GetVersionExW((OSVERSIONINFOW*)&osvi))
        {
            if ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL))
            {
                SampPersonalSKU = TRUE;
            }
        } 

        if (!SampPersonalSKU)
        {
            NTSTATUS                    NtStatus = STATUS_SUCCESS;
            PLSAPR_POLICY_INFORMATION   pPolicyInfo = NULL;

            // 
            // Determine if this machine joins to a domain. 
            // 
            NtStatus = LsaIQueryInformationPolicyTrusted(
                                    PolicyPrimaryDomainInformation,
                                    &pPolicyInfo
                                    );

            if (NT_SUCCESS(NtStatus))
            {
                PSID    AccountDomainSid = NULL;

                AccountDomainSid = SampDefinedDomains[ DOMAIN_START_REGISTRY + 1 ].Sid;

                // primary domain sid is not NULL and is not equal to local 
                // account domain sid. This machine must be joined to a domain
                if (pPolicyInfo->PolicyPrimaryDomainInfo.Sid &&
                    (!RtlEqualSid(AccountDomainSid, 
                                  pPolicyInfo->PolicyPrimaryDomainInfo.Sid)) )
                {
                    SampIsMachineJoinedToDomain = TRUE;
                }

                LsaIFree_LSAPR_POLICY_INFORMATION(PolicyPrimaryDomainInformation, 
                                                  pPolicyInfo);
            }
        }
    }
    

    //
    // Check if the machine is syskey'd and if not then syskey the machine
    //

    NtStatus = SampApplyDefaultSyskey();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Notify netlogon of our role if this is gui mode setup for
    // a DC upgrade
    //
    if (  DownlevelDcUpgrade
      && (SampProductType == NtProductLanManNt)  )
    {
        POLICY_LSA_SERVER_ROLE LsaServerRole;

        // The DS should not be running
        ASSERT( !SampUseDsData );

        switch ( SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].ServerRole )
        {
            case DomainServerRolePrimary:
                LsaServerRole= PolicyServerRolePrimary;
                break;

            case DomainServerRoleBackup:
                LsaServerRole = PolicyServerRoleBackup;
                break;

            default:
                ASSERT(FALSE && "InvalidServerRole");
                LsaServerRole = PolicyServerRoleBackup;
        }

        (VOID) I_NetNotifyRole( LsaServerRole );
    }

    //
    //  Initialize and Check Net Logon Change Numbers
    //  to support any Down Level Replication
    //

    NtStatus = SampQueryNetLogonChangeNumbers();
    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Failed to query netlogon change Numbers 0x%x\n",
                   NtStatus));

        //
        // Reset the status code to success. Do not let boot fail
        //

        NtStatus = STATUS_SUCCESS;
    }

    //
    // Build null session token handle. Also initializes token source info
    //

    NtStatus = SampCreateNullToken();
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Unable to create NULL token: 0x%x\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    // Tell the LSA that we have started. Ignore the
    // error code.
    //

    if (SampUseDsData)
    {
        NtStatus = LsaISamIndicatedDsStarted( TRUE );

        if ( !NT_SUCCESS( NtStatus )) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS:  Failed to notify LSA of DS startup: 0x%x.\n"
                       "        Failing to initialize SAM Server.\n",
                       NtStatus));

            return(NtStatus);
        }
    }

    //
    // Load the password-change notification packages.
    //

    NtStatus = SampLoadNotificationPackages( );

    if (!NT_SUCCESS(NtStatus)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Failed to load notification packagees: 0x%x.\n"
                   "        Failing to initialize SAM Server.\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    //
    // Load the password filter DLL if there is one
    //

    SampLoadPasswordFilterDll();



    //
    // Start the RPC server...
    //

    //
    // Publish the sam server interface package...
    //
    // NOTE:  Now all RPC servers in lsass.exe (now winlogon) share the same
    // pipe name.  However, in order to support communication with
    // version 1.0 of WinNt,  it is necessary for the Client Pipe name
    // to remain the same as it was in version 1.0.  Mapping to the new
    // name is performed in the Named Pipe File System code.
    //



     ServiceName = L"lsass";
     NtStatus = RpcpAddInterface( ServiceName, samr_ServerIfHandle);




    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Could Not Start RPC Server.\n"
                   "        Failing to initialize SAM Server.\n"
                   "        Status is: 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    // If we are running as a netware server, for Small World or FPNW,
    // register an SPX endpoint and some authentication info.
    //

    SampStartNonNamedPipeTransports();


    //
    // Create a thread to start authenticated RPC.
    //

    ThreadHandle = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) SampSecureRpcInit,
                        NULL,
                        0,
                        &ThreadId
                        );


    if (ThreadHandle == NULL) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Unable to create thread: %d\n",
                   GetLastError()));

        return(STATUS_INVALID_HANDLE);

    }
    else {
        CloseHandle(ThreadHandle);
    }

    return(NtStatus);
}


NTSTATUS
SampInitializeWellKnownSids( VOID )

/*++

Routine Description:

    This routine initializes some global well-known sids.



Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Initialization has successfully completed.

    STATUS_NO_MEMORY - Couldn't allocate memory for the sids.

--*/
{
    NTSTATUS
        NtStatus;

    PPOLICY_ACCOUNT_DOMAIN_INFO
        DomainInfo;

    //
    //      WORLD is s-1-1-0
    //  ANONYMOUS is s-1-5-7
    //

    SID_IDENTIFIER_AUTHORITY
            WorldSidAuthority       =   SECURITY_WORLD_SID_AUTHORITY,
            NtAuthority             =   SECURITY_NT_AUTHORITY;

    SAMTRACE("SampInitializeWellKnownSids");


    NtStatus = RtlAllocateAndInitializeSid(
                   &NtAuthority,
                   1,
                   SECURITY_ANONYMOUS_LOGON_RID,
                   0, 0, 0, 0, 0, 0, 0,
                   &SampAnonymousSid
                   );
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlAllocateAndInitializeSid(
                       &WorldSidAuthority,
                       1,                      //Sub authority count
                       SECURITY_WORLD_RID,     //Sub authorities (up to 8)
                       0, 0, 0, 0, 0, 0, 0,
                       &SampWorldSid
                       );
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = RtlAllocateAndInitializeSid(
                            &NtAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0, 0, 0, 0, 0, 0,
                            &SampAdministratorsAliasSid
                            );
            if (NT_SUCCESS(NtStatus)) {
                NtStatus = RtlAllocateAndInitializeSid(
                                &NtAuthority,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                                0, 0, 0, 0, 0, 0,
                                &SampAccountOperatorsAliasSid
                                );
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = RtlAllocateAndInitializeSid(
                                    &NtAuthority,
                                    1,
                                    SECURITY_AUTHENTICATED_USER_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &SampAuthenticatedUsersSid
                                    );
                    if (NT_SUCCESS(NtStatus)) {
                        NtStatus = RtlAllocateAndInitializeSid(
                                        &NtAuthority,
                                        1,
                                        SECURITY_PRINCIPAL_SELF_RID,
                                        0,0, 0, 0, 0, 0, 0,
                                        &SampPrincipalSelfSid
                                        );
                        if (NT_SUCCESS(NtStatus)) {
                            NtStatus = RtlAllocateAndInitializeSid(
                                            &NtAuthority,
                                            1,
                                            SECURITY_BUILTIN_DOMAIN_RID,
                                            0,0, 0, 0, 0, 0, 0,
                                            &SampBuiltinDomainSid
                                            );
                            if (NT_SUCCESS(NtStatus)) {
                                NtStatus = SampGetAccountDomainInfo( &DomainInfo );
                                if (NT_SUCCESS(NtStatus)) {
                                    NtStatus = SampCreateFullSid( DomainInfo->DomainSid,
                                                                  DOMAIN_USER_RID_ADMIN,
                                                                  &SampAdministratorUserSid
                                                                  );
                                    MIDL_user_free( DomainInfo );

                                    if (NT_SUCCESS(NtStatus)) {
                                        NtStatus = RtlAllocateAndInitializeSid(
                                                       &NtAuthority, 
                                                       1, 
                                                       SECURITY_LOCAL_SYSTEM_RID, 
                                                       0, 0, 0, 0, 0, 0, 0, 
                                                       &SampLocalSystemSid
                                                       );
                                    if (NT_SUCCESS(NtStatus)) {
                                         NtStatus = RtlAllocateAndInitializeSid(
                                                       &NtAuthority,
                                                       1,
                                                       SECURITY_NETWORK_RID,
                                                       0, 0, 0, 0, 0, 0, 0,
                                                       &SampNetworkSid
                                                       );
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

        }
    }

    return(NtStatus);
}



VOID
SampLoadPasswordFilterDll(
    VOID
    )

/*++

Routine Description:

    This function loads a DLL to do password filtering.  This DLL is
    optional and is expected to be used by ISVs or customers to do
    things like dictionary lookups and other simple algorithms to
    reject any password deemed too risky to allow a user to use.

    For example, user initials or easily guessed password might be
    rejected.

Arguments:

    None.

Return Value:

    None.


--*/

{


#if NOT_YET_SUPPORTED
    NTSTATUS Status, IgnoreStatus, MsProcStatus;
    PVOID ModuleHandle;
    STRING ProcedureName;

    UNICODE_STRING FileName;

    PSAM_PF_INITIALIZE  InitializeRoutine;



    //
    // Indicate the dll has not yet been loaded.
    //

    SampPasswordFilterDllRoutine = NULL;



    RtlInitUnicodeString( &FileName, L"PwdFiltr" );
    Status = LdrLoadDll( NULL, NULL, &FileName, &ModuleHandle );


    if (!NT_SUCCESS(Status)) {
        return;
    }

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "Samss: Loading Password Filter DLL - %Z\n",
               &FileName));

    //
    // Now get the address of the password filter DLL routines
    //

    RtlInitString( &ProcedureName, SAM_PF_NAME_INITIALIZE );
    Status = LdrGetProcedureAddress(
                 ModuleHandle,
                 &ProcedureName,
                 0,
                 (PVOID *)&InitializeRoutine
                 );

    if (!NT_SUCCESS(Status)) {

        //
        // We found the DLL, but couldn't get its initialization routine
        // address
        //

        // FIX, FIX - Log an error

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "Samss: Couldn't get password filter DLL init routine address.\n"
                   "       Status is:  0x%lx\n",
                   Status));

        IgnoreStatus = LdrUnloadDll( ModuleHandle );
        return;
    }


    RtlInitString( &ProcedureName, SAM_PF_NAME_PASSWORD_FILTER );
    Status = LdrGetProcedureAddress(
                 ModuleHandle,
                 &ProcedureName,
                 0,
                 (PVOID *)&SampPasswordFilterDllRoutine
                 );

    if (!NT_SUCCESS(Status)) {

        //
        // We found the DLL, but couldn't get its password filter routine
        // address
        //

        // FIX, FIX - Log an error

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "Samss: Couldn't get password filter routine address from loaded DLL.\n"
                   "       Status is:  0x%lx\n",
                   Status));

        IgnoreStatus = LdrUnloadDll( ModuleHandle );
        return;
    }




    //
    // Now initialize the DLL
    //

    Status = (InitializeRoutine)();

    if (!NT_SUCCESS(Status)) {

        //
        // We found the DLL and loaded its routine addresses, but it returned
        // and error from its initialize routine.
        //

        // FIX, FIX - Log an error

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "Samss: Password filter DLL returned error from initialization routine.\n");
                   "       Status is:  0x%lx\n",
                   Status));

        SampPasswordFilterDllRoutine = NULL;
        IgnoreStatus = LdrUnloadDll( ModuleHandle );
        return;
    }

#endif // NOT_YET_SUPPORTED
    return;


}


NTSTATUS
SampEnableAuditPrivilege( VOID )

/*++

Routine Description:

    This routine enables the SAM process's AUDIT privilege.
    This privilege is necessary to use the NtAccessCheckAndAuditAlarm()
    service.



Arguments:

    None.

Return Value:




--*/

{
    NTSTATUS NtStatus, IgnoreStatus;
    HANDLE Token;
    LUID AuditPrivilege;
    PTOKEN_PRIVILEGES NewState;
    ULONG ReturnLength;

    SAMTRACE("SampEnableAuditPrivilege");

    //
    // Open our own token
    //

    NtStatus = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_ADJUST_PRIVILEGES,
                 &Token
                 );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Initialize the adjustment structure
    //

    AuditPrivilege =
        RtlConvertLongToLuid(SE_AUDIT_PRIVILEGE);

    ASSERT( (sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)) < 100);
    NewState = RtlAllocateHeap(RtlProcessHeap(), 0, 100 );
    if (NULL==NewState)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    NewState->PrivilegeCount = 1;
    NewState->Privileges[0].Luid = AuditPrivilege;
    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Set the state of the privilege to ENABLED.
    //

    NtStatus = NtAdjustPrivilegesToken(
                 Token,                            // TokenHandle
                 FALSE,                            // DisableAllPrivileges
                 NewState,                         // NewState
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &ReturnLength                     // ReturnLength
                 );

    //
    // Clean up some stuff before returning
    //

    RtlFreeHeap( RtlProcessHeap(), 0, NewState );
    IgnoreStatus = NtClose( Token );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    return NtStatus;
}


VOID
SampPerformInitializeFailurePopup( NTSTATUS ErrorStatus )
/*++

Routine Description:

    This routine will give the user the shutdown option and
    instruct him to boot to safe mode if we are running in Registry Case.
    If this is a Domain Controller, then direct user to boot into DS
    Repair Mode.

Arguments:

    Error Status Code which causes the failure.

Return Value:

    None

--*/
{
    UINT     PreviousMode;
    ULONG    Response;
    ULONG    Win32Error = 0;
    HMODULE  ResourceDll;
    BOOLEAN  WasEnabled;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    UINT_PTR ErrorParameters[2];
    WCHAR    * ErrorMessage = NULL;
    WCHAR    * ArgArray[4];
    UNICODE_STRING  ErrorString;

    //
    // First, construct the Message String for the Error which caused SAM failure.
    //

    //
    // FormatMessage() Can NOT construct correct message string with additional
    // arguments for NTSTATUS code. FormatMessage() can ONLY format message with
    // additional parameters for Win32/DOS error code.
    // So we need to map NTSTATUS code to Win32 error code.
    //
    // If fail to map the NTSTATUS code to Win32 Code,
    // then try to get message string from without insert.
    //
    //
    ArgArray[0] = NULL;
    ArgArray[1] = NULL;
    ArgArray[2] = NULL;
    ArgArray[3] = NULL;

    Win32Error = RtlNtStatusToDosError(ErrorStatus);

    if (ERROR_MR_MID_NOT_FOUND == Win32Error)
    {
        //
        // Get Message String from NTSTATUS code
        //
        ResourceDll = (HMODULE) GetModuleHandle( L"ntdll.dll" );

        if (NULL != ResourceDll)
        {
            FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |    // find message from ntdll.dll
                           FORMAT_MESSAGE_IGNORE_INSERTS |  // do not insert
                           FORMAT_MESSAGE_ALLOCATE_BUFFER,  // please allocate buffer for me
                           ResourceDll,                     // source dll
                           ErrorStatus,                     // message ID
                           0,                               // language ID 
                           (LPWSTR)&ErrorMessage,           // address of return Message String
                           0,                               // maximum buffer size if not 0
                           NULL                             // can not insert arguments, so set to NULL
                           );

            FreeLibrary(ResourceDll);
        }
    }
    else
    {
        //
        // Get Message String from Win32 Code (mapped from ntstatus)
        //
        FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |     // find message from system resource table
                       FORMAT_MESSAGE_ARGUMENT_ARRAY |  // insert arguments which are all NULL
                       FORMAT_MESSAGE_ALLOCATE_BUFFER,  // please allocate buffer for me
                       NULL,                            // from system, so NULL here
                       Win32Error,                      // use the Win32Error
                       0,                               // language ID
                       (LPWSTR)&ErrorMessage,           // address of return message string
                       0,                               // maximum buffer size if not 0
                       (va_list *) &(ArgArray)          // arguments for inserting, all NULL
                       );

    }

    if (ErrorMessage) {
        RtlInitUnicodeString(&ErrorString,
                             ErrorMessage
                             );
    }
    else {
        RtlInitUnicodeString(&ErrorString,
                             L"Unmapped Error"
                             );
    }

    ErrorParameters[0] = (UINT_PTR)&ErrorString;
    ErrorParameters[1] = (UINT_PTR)ErrorStatus;

    //
    // Adjust Error Mode, so that we can get the popup Message Box
    //
    PreviousMode = SetErrorMode(0);

    //
    // Display different error message in different situation.
    //
    if (SampDsInitializationFailed && (STATUS_DS_CANT_START != ErrorStatus))
    {
        //
        // SampDsInitializationFailed will be set to TRUE
        // when DS fails to start
        //
        // Error code will be set to STATUS_DS_CANT_START if DS failed to
        // start and returned meaningless STATUS_UNSUCCESSFUL.
        //
        if (SampIsSetupInProgress(NULL))
        {
            Status = STATUS_DS_INIT_FAILURE_CONSOLE; 
        }
        else
        {
            Status = STATUS_DS_INIT_FAILURE;
        }
    }
    else
    {
        if (TRUE == SampUseDsData)
        {

            if (SampIsSetupInProgress(NULL))
            {
                // We are in DS mode and during GUI mode setup, 
                // should instruct user to boot into Recovery Console.
                Status = STATUS_DS_SAM_INIT_FAILURE_CONSOLE; 
            }
            else
            {
                //
                // We are in DS mode, should tell user to boot into DS Repair Mode
                //
                Status = STATUS_DS_SAM_INIT_FAILURE;
            }
        }
        else
        {
            //
            // We are in Registry mode, should boot into Safe Mode
            //
            Status = STATUS_SAM_INIT_FAILURE;
        }
    }

    NtStatus = NtRaiseHardError(
                            Status, // Status Code
                            2,  // number of parameters
                            1,  // Unicode String Mask
                            ErrorParameters,
                            OptionOk,
                            &Response
                            );

    SetErrorMode(PreviousMode);

    if (NT_SUCCESS(NtStatus) && Response==ResponseOk) {

        //
        // If the user is ok with shutdown, adjust privilege level,
        // issue shutdown request.
        //
        RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                            TRUE,       // enable shutdown privilege.
                            FALSE,
                            &WasEnabled
                           );

        //
        // Shutdown and Reboot now.
        // Note: use NtRaiseHardError to shutdown the machine will result Bug Check
        //

        NtShutdownSystem(ShutdownReboot);

        //
        // if Shutdown request failed, (returned from above API)
        // reset shutdown privilege to previous value.
        //
        RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                            WasEnabled,   // reset to previous state.
                            FALSE,
                            &WasEnabled
                           );

    }

    if (ErrorMessage != NULL) {
        LocalFree(ErrorMessage);
    }

    return;

}




NTSTATUS
SampFixGroupCount( VOID )

/*++

Routine Description:

    This routine fixes the group count of the account domain.
    A bug in early Daytona beta systems left the group count
    too low (by one).  This routine fixes that problem by
    setting the value according to however many groups are found
    in the registry.


Arguments:

    None - uses the gobal variable "SampKey".


Return Value:

    The status value of the registry services needed to query
    and set the group count.


--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    UNICODE_STRING
        KeyName,
        NullName;

    HANDLE
        AccountHandle;

    ULONG
        ResultLength,
        GroupCount = 0;

    PKEY_FULL_INFORMATION
        KeyInfo;

    SAMTRACE("SampFixGroupCount");


    RtlInitUnicodeString( &KeyName,
                          L"DOMAINS\\Account\\Groups"
                          );


    //
    // Open this key.
    // Query the number of sub-keys in the key.
    // The number of groups is one less than the number
    // of values (because there is one key called "Names").
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                SampKey,
                                NULL
                                );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &AccountHandle,
                   (KEY_READ | KEY_WRITE),
                   &ObjectAttributes,
                   0
                   );

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtQueryKey(
                     AccountHandle,
                     KeyFullInformation,
                     NULL,                  // Buffer
                     0,                     // Length
                     &ResultLength
                     );

        SampDumpNtQueryKey(KeyFullInformation,
                           NULL,
                           0,
                           &ResultLength);

        if (NtStatus == STATUS_BUFFER_OVERFLOW  ||
            NtStatus == STATUS_BUFFER_TOO_SMALL) {

            KeyInfo = RtlAllocateHeap( RtlProcessHeap(), 0, ResultLength);
            if (KeyInfo == NULL) {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                NtStatus = NtQueryKey(
                             AccountHandle,
                             KeyFullInformation,
                             KeyInfo,               // Buffer
                             ResultLength,          // Length
                             &ResultLength
                             );

                SampDumpNtQueryKey(KeyFullInformation,
                                   KeyInfo,
                                   ResultLength,
                                   &ResultLength);

                if (NT_SUCCESS(NtStatus)) {
                    GroupCount = (KeyInfo->SubKeys - 1);
                }

                RtlFreeHeap( RtlProcessHeap(), 0, KeyInfo );
            }
        }


        if (NT_SUCCESS(NtStatus)) {

            RtlInitUnicodeString( &NullName, NULL );
            NtStatus = NtSetValueKey(
                         AccountHandle,
                         &NullName,                 // Null value name
                         0,                         // Title Index
                         GroupCount,                // Count goes in Type field
                         NULL,                      // No data
                         0
                         );
        }


        IgnoreStatus = NtClose( AccountHandle );
        ASSERT( NT_SUCCESS(IgnoreStatus) );
    }

    return(NtStatus);


}


#ifdef SAMP_SETUP_FAILURE_TEST

NTSTATUS
SampInitializeForceError(
    OUT PNTSTATUS ForcedStatus
    )

/*++

Routine Description:

    This function forces an error to occur in the SAM initialization/installation.
    The error to be simulated is specified by storing the desired Nt Status
    value to be simulated in the REG_DWORD registry key valie PhonyLsaError
    in HKEY_LOCAL_MACHINE\System\Setup.

Arguments:

    ForcedStatus - Receives the Nt status code to be simulated.  If set to a
        non-success status, SAM initialization is bypassed and the specified
        status code is set instead.  If STATUS_SUCCESS is returned, no
        simulation takes place and SAM initializes as it would normally.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS OutputForcedStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle = NULL;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation = NULL;
    ULONG KeyValueInfoLength;
    ULONG ResultLength;
    UNICODE_STRING KeyPath;
    UNICODE_STRING ValueName;

    SAMTRACE("SampInitializeForceError");


    RtlInitUnicodeString( &KeyPath, L"\\Registry\\Machine\\System\\Setup" );
    RtlInitUnicodeString( &ValueName, L"PhonyLsaError" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    SampDumpNtOpenKey((MAXIMUM_ALLOWED), &ObjectAttributes, 0);

    NtStatus = NtOpenKey( &KeyHandle, MAXIMUM_ALLOWED, &ObjectAttributes);

    if (!NT_SUCCESS( NtStatus )) {

        //
        // If the error is simply that the registry key does not exist,
        // do not simulate an error and allow SAM initialization to
        // proceed.
        //

        if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtOpenKey for Phony Lsa Error failed 0x%lx\n",
                       NtStatus));

            goto InitializeForceErrorError;
        }

        NtStatus = STATUS_SUCCESS;

        goto InitializeForceErrorFinish;
    }

    KeyValueInfoLength = 256;

    NtStatus = STATUS_NO_MEMORY;

    KeyValueInformation = RtlAllocateHeap(
                              RtlProcessHeap(),
                              0,
                              KeyValueInfoLength
                              );

    if (KeyValueInformation == NULL) {

        goto InitializeForceErrorError;
    }

    NtStatus = NtQueryValueKey(
                   KeyHandle,
                   &ValueName,
                   KeyValueFullInformation,
                   KeyValueInformation,
                   KeyValueInfoLength,
                   &ResultLength
                   );

    SampDumpNtQueryValueKey(&ValueName,
                            KeyValueFullInformation,
                            KeyValueInformation,
                            KeyValueInfoLength,
                            &ResultLength);

    if (!NT_SUCCESS(NtStatus)) {

        //
        // If the error is simply that that the PhonyLsaError value has not
        // been set, do not simulate an error and instead allow SAM initialization
        // to proceed.
        //

        if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtQueryValueKey for Phony Lsa Error failed 0x%lx\n",
                       NtStatus));

            goto InitializeForceErrorError;
        }

        NtStatus = STATUS_SUCCESS;
        goto InitializeForceErrorFinish;
    }

    NtStatus = STATUS_INVALID_PARAMETER;

    if (KeyValueInformation->Type != REG_DWORD) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Key for Phony Lsa Error is not REG_DWORD type"));

        goto InitializeForceErrorError;
    }

    NtStatus = STATUS_SUCCESS;

    //
    // Obtain the error code stored as the registry key value
    //

    OutputForcedStatus = *((NTSTATUS *)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset));

InitializeForceErrorFinish:

    //
    // Clean up our resources.
    //

    if (KeyValueInformation != NULL) {

        RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInformation );
    }

    if (KeyHandle != NULL) {

        NtClose( KeyHandle );
    }

    *ForcedStatus = OutputForcedStatus;
    return(NtStatus);

InitializeForceErrorError:

    goto InitializeForceErrorFinish;
}

#endif // SAMP_SETUP_FAILURE_TEST



#if SAMP_DIAGNOSTICS

VOID
SampActivateDebugProcess( VOID )

/*++

Routine Description:

    This function activates a process with a time delay.
    The point of this action is to provide some diagnostic capabilities
    during SETUP.  This originated out of the need to run dh.exe (to get
    a heap dump of LSASS.exe) during setup.



Arguments:

    Arguments are provided via global variables.  The debug user is
    given an opportunity to change these string values before the
    process is activated.

Return Values:

    None.

--*/

{
    NTSTATUS
        NtStatus;

    HANDLE
        Thread;

    DWORD
        ThreadId;

    IF_NOT_SAMP_GLOBAL( ACTIVATE_DEBUG_PROC ) {
        return;
    }

    //
    // Do all the work in another thread so that it can wait before
    // activating the debug process.
    //

    Thread = CreateThread(
                 NULL,
                 0L,
                 (LPTHREAD_START_ROUTINE)SampActivateDebugProcessWrkr,
                 0L,
                 0L,
                 &ThreadId
                 );
    if (Thread != NULL) {
        (VOID) CloseHandle( Thread );
    }


    return;
}


NTSTATUS
SampActivateDebugProcessWrkr(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    This function activates a process with a time delay.
    The point of this action is to provide some diagnostic capabilities
    during SETUP.  This originated out of the need to run dh.exe (to get
    a heap dump of LSASS.exe) during setup.

    The user is given the opportunity to change any or all of the
    following values before the process is activated (and before
    we wait):

                Seconds until activation
                Image to activate
                Command line to image


Arguments:

    ThreadParameter - Not used.

Return Values:

    STATUS_SUCCESS

--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        CommandLine;

    ULONG
        Delay = 30;          // Number of seconds

    SECURITY_ATTRIBUTES
        ProcessSecurityAttributes;

    STARTUPINFO
        StartupInfo;

    PROCESS_INFORMATION
        ProcessInformation;

    SECURITY_DESCRIPTOR
        SD;

    BOOL
        Result;


    RtlInitUnicodeString( &CommandLine,
                          TEXT("dh.exe -p 33") );


    //
    // Give the user an opportunity to change parameter strings...
    //

    SampDiagPrint( ACTIVATE_DEBUG_PROC,
                   ("SAM: Diagnostic flags are set to activate a debug process...\n"
                    " The following parameters are being used:\n\n"
                    "   Command Line [0x%lx]:   *%wZ*\n"
                    "   Seconds to activation [address: 0x%lx]:   %d\n\n"
                    " Change parameters if necessary and then proceed.\n"
                    " Use |# command at the ntsd prompt to see the process ID\n"
                    " of lsass.exe\n",
                    &CommandLine, &CommandLine,
                    &Delay, Delay) );

    DbgBreakPoint();

    //
    // Wait for Delay seconds ...
    //

    Sleep( Delay*1000 );

    SampDiagPrint( ACTIVATE_DEBUG_PROC,
                   ("SAM: Activating debug process %wZ\n",
                    &CommandLine) );
    //
    // Initialize process security info
    //

    InitializeSecurityDescriptor( &SD ,SECURITY_DESCRIPTOR_REVISION1 );
    ProcessSecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    ProcessSecurityAttributes.lpSecurityDescriptor = &SD;
    ProcessSecurityAttributes.bInheritHandle = FALSE;

    //
    // Initialize process startup info
    //

    RtlZeroMemory( &StartupInfo, sizeof(StartupInfo) );
    StartupInfo.cb = sizeof(STARTUPINFO);
    StartupInfo.lpReserved = CommandLine.Buffer;
    StartupInfo.lpTitle = CommandLine.Buffer;
    StartupInfo.dwX =
        StartupInfo.dwY =
        StartupInfo.dwXSize =
        StartupInfo.dwYSize = 0L;
    StartupInfo.dwFlags = STARTF_FORCEOFFFEEDBACK;
    StartupInfo.wShowWindow = SW_SHOW;   // let it be seen if possible
    StartupInfo.lpReserved2 = NULL;
    StartupInfo.cbReserved2 = 0;


    //
    // Now create the diagnostic process...
    //

    Result = CreateProcess(
                      NULL,             // Image name
                      CommandLine.Buffer,
                      &ProcessSecurityAttributes,
                      NULL,         // ThreadSecurityAttributes
                      FALSE,        // InheritHandles
                      CREATE_UNICODE_ENVIRONMENT,   //Flags
                      NULL,  //Environment,
                      NULL,  //CurrentDirectory,
                      &StartupInfo,
                      &ProcessInformation);

    if (!Result) {
        SampDiagPrint( ACTIVATE_DEBUG_PROC,
                       ("SAM: Couldn't activate diagnostic process.\n"
                        "     Error: 0x%lx (%d)\n\n",
                        GetLastError(), GetLastError()) );
    }

    return(STATUS_SUCCESS);         // Exit this thread
}
#endif // SAMP_DIAGNOSTICS


NTSTATUS
SampQueryNetLogonChangeNumbers()
/*++

    Routine Description

        Queries Netlogon for the change Log Serial Number

    Parameters

          None:

    Return Values

       STATUS_SUCCESS;
       Other Values from Netlogon API
--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    ULONG           i;
    LARGE_INTEGER   NetLogonChangeLogSerialNumber;

    //
    // On a Per domain basis query netlogon for the change log serial Number
    //

    for (i=0;i<SampDefinedDomainsCount;i++)
    {

        if ((IsDsObject(SampDefinedDomains[i].Context))
            && (DomainServerRolePrimary==SampDefinedDomains[i].ServerRole))
        {
            BOOLEAN         FlushRequired = FALSE;

            NtStatus =   I_NetLogonGetSerialNumber(
                                SecurityDbSam,
                                SampDefinedDomains[i].Sid,
                                &(NetLogonChangeLogSerialNumber)
                                );

            if (STATUS_INVALID_DOMAIN_ROLE == NtStatus)
            {

                //
                // Not PDC then just set to 1, netlogon will ignore notifications anyway
                //

               SampDiagPrint(INFORM,("I_NetLogonGetSerialNumber Returned %x for Domain %d\n",
                                            NtStatus,i));

               SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart = 1;
               NtStatus = STATUS_SUCCESS;
            }
            else if (!NT_SUCCESS(NtStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS:  Could not Query Serial Number From Netlogon, Error = %x\n",
                           NtStatus));

                return(NtStatus);
            }


            //
            // Acquire Write Lock
            //

            NtStatus = SampAcquireWriteLock();
            if (!NT_SUCCESS(NtStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Unable to Acquire Write Lock to flush Serial Number, Error = %x\n",
                           NtStatus));

                return (NtStatus);
            }

            //
            // Validate the Domain Cache if necessary, as release write lock without
            // flushing invalidates it
            //

            NtStatus = SampValidateDomainCache();
            if (!NT_SUCCESS(NtStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Unable to Validate Domain Cache while initializing %x\n",
                           NtStatus));

                SampReleaseWriteLock(FALSE);
                return (NtStatus);
            }

            //
            // Make the present domain the transaction domain. This will make the commit code, run part of
            // release write lock commit the correct domain.
            //

            SampSetTransactionDomain(i);

            //
            // There are now 3 Cases.
            //
            // Case 1 -- The Netlogon Change Log Serial Number is Equal to the domain
            //           Modified Count. This is the clean flush case. In this case
            //           the domain modified Count is the serial number
            // Case 2 -- The Netlogon Change Log Serial Number is > the domain modified count
            //           This corresponds to an unclean shut down, or failed Ds Commit. The Change
            //           Serial number is then the one queried from the log.
            // Case 3 -- The Netlogon Change Serial Number is less than the change serial number in
            //           the modified count property of the domain object and the domain is not a builtin
            //           domain. This corresponds to some sort of error with the log.
            //           The only recourse in this case is a full sync.
            // Case 4 -- Same as Case 3, but builtin domain. In this case the number on the modified count
            //           property on the domain object prevails. We make the assumption that the modified count
            //           propety on the builtin domain object is always an accurate value. This is true as
            //           long as there are no failed commits. However in case of failed commits we expect to
            //           hit 2. To hit 4 means that the commit on the builtin domain failed plus a huge
            //           number of commits succeeded after that on the account domain, such as to wrap the log,
            //           plus the machine crashed such that we could not flush the latest modified count. The
            //           end result of this is that backup domain controllers will skip a change for which a
            //           commit never took place.
            //

            if (NetLogonChangeLogSerialNumber.QuadPart ==
                    SampDefinedDomains[i].CurrentFixed.ModifiedCount.QuadPart)
            {
                SampDiagPrint(INFORM,("Number Queried From Log Same as Modified Count on Domain %d\n",i));
                SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart = NetLogonChangeLogSerialNumber.QuadPart;
            }
            else if (NetLogonChangeLogSerialNumber.QuadPart >
                    SampDefinedDomains[i].CurrentFixed.ModifiedCount.QuadPart)
            {
                SampDiagPrint(INFORM,("Number Queried From Log Greater Than Modified Count on Domain %d\n",i));

                //
                // Set the serial number to the one queried from the change log.
                //

                SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart =
                                            NetLogonChangeLogSerialNumber.QuadPart;
                SampDefinedDomains[i].CurrentFixed.ModifiedCount.QuadPart = NetLogonChangeLogSerialNumber.QuadPart;

                ASSERT(( RtlCompareMemory(
                                &SampDefinedDomains[i].CurrentFixed,
                                &SampDefinedDomains[i].UnmodifiedFixed,
                                sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN) ) !=
                                sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN) ));

                FlushRequired = TRUE;
            }
            else
            {
                SampDiagPrint(INFORM,("Number Queried From Log Less Than Modified Count on Domain %d\n",i));
                if (SampDefinedDomains[i].IsBuiltinDomain)
                {
                    SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart =
                            SampDefinedDomains[i].CurrentFixed.ModifiedCount.QuadPart;
                }
                else
                {
                    //
                    // Force a Full Sync. Set Serial Number to 1 and restamp the creation time.
                    //

                    SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart = 1;
                    SampDefinedDomains[i].CurrentFixed.ModifiedCount.QuadPart = 1;
                    NtQuerySystemTime(
                        &(SampDefinedDomains[i].CurrentFixed.CreationTime));

                    FlushRequired = TRUE;
                }

            }

            NtStatus = SampReleaseWriteLock(FlushRequired);

            if (!NT_SUCCESS(NtStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Commit Failed While Setting Serial Number, Error = %x\n",
                           NtStatus));

                return (NtStatus);
            }


        }
        else
        {

            //
            // Registry or BDC Case
            //

            SampDefinedDomains[i].NetLogonChangeLogSerialNumber =
                SampDefinedDomains[i].CurrentFixed.ModifiedCount;
            NtStatus = STATUS_SUCCESS;
        }

    }

    return (NtStatus);
}

NTSTATUS
SampCacheComputerObject()
{
   NTSTATUS NtStatus = STATUS_SUCCESS;
   DSNAME   *TempDN=NULL;

   NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
   if (NT_SUCCESS(NtStatus))
   {
        NtStatus = SampFindComputerObject(NULL,&TempDN);
        if (NT_SUCCESS(NtStatus))
        {
             SampComputerObjectDsName = MIDL_user_allocate(TempDN->structLen);
             if (NULL!=SampComputerObjectDsName)
             {
                 RtlCopyMemory(SampComputerObjectDsName,TempDN,TempDN->structLen);
             }
        }
   }

   SampMaybeEndDsTransaction(TransactionCommit);

   return(NtStatus);
}

//
// SAM Configuration Keys that are either disabled or enabled
//
struct {
    
    LPSTR   ValueName;
    BOOLEAN *pfEnabled;

} SampConfigurationKeys[] = 
{
    {"IgnoreGCFailures",                    &SampIgnoreGCFailures},
    {"NoLmHash",                            &SampNoLmHash},
    {"SamDoExtendedEnumerationAccessCheck", &SampDoExtendedEnumerationAccessCheck},
    {"SamNoGcLogonEnforceKerberosIpCheck",  &SampNoGcLogonEnforceKerberosIpCheck},
    {"SamNoGcLogonEnforceNTLMCheck",        &SampNoGcLogonEnforceNTLMCheck},
    {"SamReplicatePasswordsUrgently",       &SampReplicatePasswordsUrgently},
    {"ForceGuest",                          &SampForceGuest},
    {"LimitBlankPasswordUse",               &SampLimitBlankPasswordUse },
};

NTSTATUS
SampReadRegistryParameters(
    PVOID p
    )
/*++

Routine Description:

   This routine reads in the configuration parameters for SAM.  This routine
   is called once during startup and then whenever the CONTROL\LSA
   registry key changes.

Arguments:

    p - Not used.

Return Values:

    STATUS_SUCCESS

--*/
{
    DWORD WinError;
    HKEY LsaKey;
    DWORD dwSize, dwValue, dwType;
    ULONG i;

    WinError = RegOpenKey(HKEY_LOCAL_MACHINE,
                          L"System\\CurrentControlSet\\Control\\Lsa",
                          &LsaKey );
    if (ERROR_SUCCESS != WinError) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Read the simple ones in first
    //
    for (i = 0; i < ARRAY_COUNT(SampConfigurationKeys); i++) {

        dwSize = sizeof(dwValue);
        WinError = RegQueryValueExA(LsaKey,
                                    SampConfigurationKeys[i].ValueName,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwValue,
                                    &dwSize);
    
        if ((ERROR_SUCCESS == WinError) && 
            (REG_DWORD == dwType) &&
            (1 == dwValue)) {
            *SampConfigurationKeys[i].pfEnabled = TRUE;
        } else {
            *SampConfigurationKeys[i].pfEnabled = FALSE;
        }
    }

    //
    // Hack!
    // 
    // To be removed once setup guys fix GUI mode to set, not change,
    // the admin password.
    //
    {
        BOOLEAN fUpgrade;
        if (SampIsSetupInProgress( &fUpgrade )) {

            SampLimitBlankPasswordUse = FALSE;
        }
    }

    //
    // End of Hack!
    //

    //
    // Call out to the more complicated routines
    //

    //
    // NULL session access
    //
    SampCheckNullSessionAccess(LsaKey);

    //
    // Large SID Emulation modes
    //
    SampInitEmulationSettings(LsaKey);

    //
    // Logging levels
    //
    SampLogLevelChange(LsaKey);


    RegCloseKey(LsaKey);

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\samifree.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    samifree.c

Abstract:

    This file contains routines to free structure allocated by the Samr
    routines.  These routines are used by SAM clients which live in the
    same process as the SAM server and call the Samr routines directly.


Author:

    Cliff Van Dyke (CliffV) 26-Feb-1992

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>





VOID
SamIFree_SAMPR_SR_SECURITY_DESCRIPTOR (
    PSAMPR_SR_SECURITY_DESCRIPTOR Source
    )

/*++

Routine Description:

    This routine free a SAMPR_SR_SECURITY_DESCRIPTOR and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_SR_SECURITY_DESCRIPTOR ( Source );
        MIDL_user_free (Source);
    }
}



VOID
SamIFree_SAMPR_DOMAIN_INFO_BUFFER (
    PSAMPR_DOMAIN_INFO_BUFFER Source,
    DOMAIN_INFORMATION_CLASS Branch
    )

/*++

Routine Description:

    This routine free a SAMPR_DOMAIN_INFO_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

    Branch - Specifies which branch of the union to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgu__SAMPR_DOMAIN_INFO_BUFFER ( Source, Branch );
        MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_ENUMERATION_BUFFER (
    PSAMPR_ENUMERATION_BUFFER Source
    )

/*++

Routine Description:

    This routine free a SAMPR_ENUMERATION_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_ENUMERATION_BUFFER ( Source );
        MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_PSID_ARRAY (
    PSAMPR_PSID_ARRAY Source
    )

/*++

Routine Description:

    This routine free a the graph of allocated nodes pointed to
    by a PSAMPR_PSID_ARRAY

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_PSID_ARRAY ( Source );
    }
}


VOID
SamIFree_SAMPR_ULONG_ARRAY (
    PSAMPR_ULONG_ARRAY Source
    )

/*++

Routine Description:

    This routine free a SAMPR_ULONG_ARRAY and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_ULONG_ARRAY ( Source );
        // SAM never allocates this.
        // MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_RETURNED_USTRING_ARRAY (
    PSAMPR_RETURNED_USTRING_ARRAY Source
    )

/*++

Routine Description:

    This routine free a SAMPR_RETURNED_USTRING_ARRAY and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_RETURNED_USTRING_ARRAY ( Source );
        // SAM never allocates this.
        // MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_GROUP_INFO_BUFFER (
    PSAMPR_GROUP_INFO_BUFFER Source,
    GROUP_INFORMATION_CLASS Branch
    )

/*++

Routine Description:

    This routine free a SAMPR_GROUP_INFO_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

    Branch - Specifies which branch of the union to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgu__SAMPR_GROUP_INFO_BUFFER ( Source, Branch );
        MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_ALIAS_INFO_BUFFER (
    PSAMPR_ALIAS_INFO_BUFFER Source,
    ALIAS_INFORMATION_CLASS Branch
    )

/*++

Routine Description:

    This routine free a SAMPR_ALIAS_INFO_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

    Branch - Specifies which branch of the union to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgu__SAMPR_ALIAS_INFO_BUFFER ( Source, Branch );
        MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_GET_MEMBERS_BUFFER (
    PSAMPR_GET_MEMBERS_BUFFER Source
    )

/*++

Routine Description:

    This routine free a SAMPR_GET_MEMBERS_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_GET_MEMBERS_BUFFER ( Source );
        MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_USER_INFO_BUFFER (
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    )

/*++

Routine Description:

    This routine free a SAMPR_USER_INFO_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

    Branch - Specifies which branch of the union to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {

        _fgu__SAMPR_USER_INFO_BUFFER ( Source, Branch );
        MIDL_user_free (Source);
    }
}

VOID
SamIFree_UserInternal6Information (
   PUSER_INTERNAL6_INFORMATION  Source
   )
{  

    if (NULL!=Source)
    {
        _fgu__SAMPR_USER_INFO_BUFFER( (PSAMPR_USER_INFO_BUFFER) &Source->I1,UserAllInformation);
        MIDL_user_free(Source->A2D2List);
        MIDL_user_free(Source->UPN.Buffer);
        MIDL_user_free(Source);
    }
}


VOID
SamIFree_SAMPR_GET_GROUPS_BUFFER (
    PSAMPR_GET_GROUPS_BUFFER Source
    )

/*++

Routine Description:

    This routine free a SAMPR_GET_GROUPS_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_GET_GROUPS_BUFFER ( Source );
        MIDL_user_free (Source);
    }
}



VOID
SamIFree_SAMPR_DISPLAY_INFO_BUFFER (
    PSAMPR_DISPLAY_INFO_BUFFER Source,
    DOMAIN_DISPLAY_INFORMATION Branch
    )

/*++

Routine Description:

    This routine free a SAMPR_DISPLAY_INFO_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

    Branch - Specifies which branch of the union to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgu__SAMPR_DISPLAY_INFO_BUFFER ( Source, Branch );
        // SAM never allocates this.
        // MIDL_user_free (Source);
    }
}

VOID
SamIFreeSidAndAttributesList(
    IN  PSID_AND_ATTRIBUTES_LIST List
    )
/*

  Routine Description:

        Frees the Sid And Attributes Array returned by a get Reverse membership list


  Arguments:

        cSids  - Count of Sid/Attribute Pairs
        rpSids - Array of Sids

  Return Values
       None

  */
{
    ULONG   Index;

    if (NULL!=List->SidAndAttributes)
    {
        for (Index=0;Index<List->Count;Index++)
        {
            if (List->SidAndAttributes[Index].Sid)
                MIDL_user_free(List->SidAndAttributes[Index].Sid);
        }

        MIDL_user_free(List->SidAndAttributes);
    }
}

VOID
SamIFreeSidArray(
    IN  PSAMPR_PSID_ARRAY List
    )
/*

  Routine Description:

  Frees the Sid Array returned by a get Reverse membership list


  Arguments:

  Return Values
       None

  */
{
    ULONG   Index;

    if (NULL != List)
    {
        if (List->Sids != NULL)
        {
            for (Index = 0; Index < List->Count ; Index++ )
            {
                if (List->Sids[Index].SidPointer != NULL)
                {
                    MIDL_user_free(List->Sids[Index].SidPointer);
                }
            }
            MIDL_user_free(List->Sids);
        }
        MIDL_user_free(List);
    }
}

VOID
SamIFreeVoid(
    IN  PVOID ptr
    )
/*

  Routine Description:

  Frees memory pointed to by ptr. Useful for cases where non-Sam functions
  need to free memory allocated off the process heap of Sam. For ex., 
  dbGetReverseMemberships in dbconstr.c in ntdsa.dll calls this to free
  Sid array returned by Sam in SampDsGetReverseMembership call


  Arguments:

  Return Values
       None

  */
{
    MIDL_user_free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\samaudit.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    SAMAUDIT.C
    
Abstract:

    Improving SAM Account Management Auditing. 
    
Author:

    18-June-1999     ShaoYin
    
Revision History:


--*/

//
//
//  Include header files
//
// 

#include <samsrvp.h>
#include <msaudite.h>




typedef struct _SAMP_AUDIT_MESSAGE_TABLE {

    ULONG   MessageId;
    PWCHAR  MessageString;

}   SAMP_AUDIT_MESSAGE_TABLE;


//
// the following table is used to hold Message String for
// each every additional audit message text SAM wants to 
// put into the audit event.
//
// this table will be filled whenever needed. Once loaded
// SAM won't free them, instead, SAM will keep using the 
// Message String from the table. So that we can save 
// time of calling FormatMessage()
// 

SAMP_AUDIT_MESSAGE_TABLE    SampAuditMessageTable[] =
{
    {SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_DISABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_DISABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_ENABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_ENABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_ENABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_ENABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_DISABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_DISABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_MEMBER_ACCOUNT_NAME_NOT_AVAILABLE, 
     NULL },

    {SAMMSG_AUDIT_ACCOUNT_ENABLED, 
     NULL },

    {SAMMSG_AUDIT_ACCOUNT_DISABLED, 
     NULL },

    {SAMMSG_AUDIT_ACCOUNT_CONTROL_CHANGE, 
     NULL },

    {SAMMSG_AUDIT_ACCOUNT_NAME_CHANGE, 
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_PWD,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOGOFF,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_OEM,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_REPLICATION,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_SERVERROLE,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_STATE,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOCKOUT,
     NULL }, 

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_MODIFIED,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_DOMAINMODE,
     NULL }

};


ULONG   cSampAuditMessageTable = sizeof(SampAuditMessageTable) /
                                    sizeof(SAMP_AUDIT_MESSAGE_TABLE);



PWCHAR
SampGetAuditMessageString(
    ULONG   MessageId
    )
/*++
Routine Description:

    This routine will get the message text for the passed in 
    message ID.
    
    It will only search in the SampAuditMessageTable. If the 
    message string for the message ID has been loaded, then 
    return the message string immediately. Otherwise, load the
    message string the SAMSRV.DLL, and save the message string
    in the table. 

    if can't find the message ID from the table, return NULL.
    
Parameters:

    MessageId -- MessageID for the message string interested.

Return Value:
    
    Pointer to the message string. 
    
    Caller SHOULD NOT free the message string. Because the 
    string is in the table. We want to keep it.    
        
--*/
{
    HMODULE ResourceDll;
    PWCHAR  MsgString = NULL;
    ULONG   Index;
    ULONG   Length = 0;
    BOOL    Status;


    for (Index = 0; Index < cSampAuditMessageTable; Index++)
    {
        if (MessageId == SampAuditMessageTable[Index].MessageId)
        {
            if (NULL != SampAuditMessageTable[Index].MessageString)
            {
                MsgString = SampAuditMessageTable[Index].MessageString;
            }
            else
            {
                //
                // not finding the message string from the table.
                // try to load it
                // 
                ResourceDll = (HMODULE) LoadLibrary(L"SAMSRV.DLL");

                if (NULL == ResourceDll)
                {
                    return NULL;
                }

                Length = (USHORT) FormatMessage(
                                        FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        MessageId,
                                        0,          // Use caller's language
                                        (LPWSTR)&MsgString,
                                        0,          // routine should allocate
                                        NULL        // Insertion string 
                                        );

                if (MsgString)
                {
                    // message text has "cr" and "lf" in the end
                    MsgString[Length - 2] = L'\0';
                    SampAuditMessageTable[Index].MessageString = MsgString;
                }

                Status = FreeLibrary(ResourceDll);
                ASSERT(Status);
            }
            return (MsgString);
        }
    }

    return (NULL);
}




NTSTATUS
SampAuditAnyEvent(
    IN PSAMP_OBJECT         AccountContext,
    IN NTSTATUS             Status,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL
    )
/*++

Routine Description:

    This routine is a wrapper of auditing routines, it calls different
    worker routines based on the client type. For loopback client and 
    the status is success so far, insert this auditing task into 
    Loopback Task Queue in thread state, which will be either
    performed or aborted when the transaction done.  That is because 
    
    For SAM Client, since the transaction has been committed already, 
    go ahead let LSA generate the audit event. 

    If the status is not success, and caller still wants to audit this 
    event, perform the auditing immediately.  
    
Paramenters:

    Same as the worker routine
    
Return Values:

    NtStatus         

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    if (NT_SUCCESS(Status) && AccountContext->LoopbackClient)
    {
        NtStatus = SampAddLoopbackTaskForAuditing(
                        Status,         // Status
                        AuditId,        // Audit Id
                        DomainSid,      // Domain SID
                        AdditionalInfo, // Additional Info
                        MemberRid,      // Member Rid
                        MemberSid,      // Member Sid
                        AccountName,    // Account Name
                        DomainName,     // Domain Name
                        AccountRid,     // Account Rid
                        Privileges      // Privileges used
                        );
    }
    else
    {
        NtStatus = LsaIAuditSamEvent(
                        Status,         // Status
                        AuditId,        // Audit Id
                        DomainSid,      // Domain SID
                        AdditionalInfo, // Additional Info
                        MemberRid,      // Member Rid
                        MemberSid,      // Member Sid
                        AccountName,    // Account Name
                        DomainName,     // Domain Name
                        AccountRid,     // Account Rid
                        Privileges      // Privileges used
                        );
    }

    return(NtStatus);
}







VOID
SampAuditGroupTypeChange(
    PSAMP_OBJECT GroupContext, 
    BOOLEAN OldSecurityEnabled, 
    BOOLEAN NewSecurityEnabled, 
    NT5_GROUP_TYPE OldNT5GroupType, 
    NT5_GROUP_TYPE NewNT5GroupType
    )
/*++
Routine Description:

    This routine audits SAM group type change.

Parameters:

    GroupContext -- Group (univeral, globa or local) Context
    
    OldSecurityEnabled -- Indicate the group is security enabled or 
                          not prior to the change 
    
    NewSecurityEnabled -- Indicate the group is security enabled or 
                          not after the change

    OldNT5GroupType -- Group Type before the change
                              
    NewNT5GroupType -- Group Type after the change                          

Return Value:

    None.    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS Domain = NULL;
    SAMP_OBJECT_TYPE    ObjectType;
    UNICODE_STRING      GroupTypeChange, GroupName;
    PWCHAR      GroupTypeChangeString = NULL;
    ULONG       MsgId = SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
    ULONG       GroupRid;

    //
    // Determine the nature of the group type change
    // 
    if (OldSecurityEnabled)
    {
        switch (OldNT5GroupType) {
        case NT5ResourceGroup: 
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                case NT5AccountGroup:
                    ASSERT(FALSE && "Local ==> Global\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_DISABLED_LOCAL_GROUP;
                    break;
                case NT5AccountGroup:
                    ASSERT(FALSE && "Local ==> Global\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            break;
        case NT5AccountGroup:
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "Global ==> Local\n");
                    return;
                case NT5AccountGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "Global ==> Local\n");
                    return;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_DISABLED_GLOBAL_GROUP;
                    break;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            break;
        case NT5UniversalGroup:
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_ENABLED_LOCAL_GROUP; 
                    break;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_ENABLED_GLOBAL_GROUP; 
                    break;
                case NT5UniversalGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_LOCAL_GROUP;
                    break;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_GLOBAL_GROUP;
                    break;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            break;
        default:
            ASSERT(FALSE && "Invalide Group Type\n");
            return;
        }
    }
    else
    {
        switch (OldNT5GroupType) {
        case NT5ResourceGroup: 
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_ENABLED_LOCAL_GROUP;
                    break;
                case NT5AccountGroup:
                    ASSERT(FALSE && "Local ==> Global\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                case NT5AccountGroup:
                    ASSERT(FALSE && "Local ==> Global\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            break;
        case NT5AccountGroup:
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "Global ==> Local\n");
                    return;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_ENABLED_GLOBAL_GROUP;
                    break;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "Global ==> Local\n");
                    return;
                case NT5AccountGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            break;
        case NT5UniversalGroup:
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_LOCAL_GROUP; 
                    break;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_GLOBAL_GROUP; 
                    break;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_DISABLED_LOCAL_GROUP;
                    break;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_DISABLED_GLOBAL_GROUP;
                    break;
                case NT5UniversalGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                default:
                    ASSERT(FALSE && "Invalide Group Type\n");
                    return;
                }
            }
            break;
        default:
            ASSERT(FALSE && "Invalide Group Type\n");
            return;
        }
    }

    //
    // Get the group type change message from resource table 
    // 

    GroupTypeChangeString = SampGetAuditMessageString(MsgId);

    if (GroupTypeChangeString)
    {
        RtlInitUnicodeString(&GroupTypeChange, GroupTypeChangeString);
    }
    else
    {
        RtlInitUnicodeString(&GroupTypeChange, L"-");
    }

    //
    // Get Group Account Rid
    // 
    if (SampGroupObjectType == GroupContext->ObjectType)
    {
        GroupRid = GroupContext->TypeBody.Group.Rid;
    }
    else
    {
        GroupRid = GroupContext->TypeBody.Alias.Rid;
    }
    
    //
    // Get Group Account Name
    // 
    Domain = &SampDefinedDomains[ GroupContext->DomainIndex ];

    NtStatus = SampLookupAccountName(
                        GroupContext->DomainIndex,
                        GroupRid,
                        &GroupName, 
                        &ObjectType
                        );

    if (!NT_SUCCESS(NtStatus)) {
        RtlInitUnicodeString(&GroupName, L"-");
    }

    SampAuditAnyEvent(
        GroupContext,
        STATUS_SUCCESS,
        SE_AUDITID_GROUP_TYPE_CHANGE,   // Audit Id
        Domain->Sid,                    // Domain SID
        &GroupTypeChange,
        NULL,                           // Member Rid (not used)
        NULL,                           // Member Sid (not used)
        &GroupName,                     // Account Name
        &Domain->ExternalName,          // Domain
        &GroupRid,                      // Account Rid
        NULL                            // Privileges used
        );

    if (NT_SUCCESS(NtStatus)) {
        MIDL_user_free( GroupName.Buffer );
    }
                        
    return;
}





VOID
SampAuditGroupMemberChange(
    PSAMP_OBJECT    GroupContext, 
    BOOLEAN AddMember, 
    PWCHAR  MemberStringName OPTIONAL,
    PULONG  MemberRid  OPTIONAL,
    PSID    MemberSid  OPTIONAL
    )
/*++
Routine Description:

    This routine takes care of all kinds of Group Member update.

Arguments:

    GroupContext -- Pointer to Group Object Context

    AddMember -- TRUE: Add a Member 
                 FALSE: Remove a Member

    MemberStringName -- If present, it's the member account's 
                        string name                 

    MemberRid -- Pointer to the member account's RID if present.                        

    MemberSid -- Pointer to the member accoutn's SID if present  

Return Value:

    None.
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;     
    SAMP_OBJECT_TYPE        ObjectType; 
    UNICODE_STRING          GroupName;
    UNICODE_STRING          MemberName;
    NT5_GROUP_TYPE          NT5GroupType; 
    BOOLEAN     SecurityEnabled;
    ULONG       GroupRid;
    ULONG       AuditId;
    

    Domain = &SampDefinedDomains[GroupContext->DomainIndex];


    if (SampGroupObjectType == GroupContext->ObjectType)
    {
        ASSERT(ARGUMENT_PRESENT(MemberRid));

        GroupRid = GroupContext->TypeBody.Group.Rid;
        SecurityEnabled = GroupContext->TypeBody.Group.SecurityEnabled;
        NT5GroupType = GroupContext->TypeBody.Group.NT5GroupType;

    }
    else
    {
        ASSERT(SampAliasObjectType == GroupContext->ObjectType);
        ASSERT(ARGUMENT_PRESENT(MemberSid));

        GroupRid = GroupContext->TypeBody.Alias.Rid;
        SecurityEnabled = GroupContext->TypeBody.Alias.SecurityEnabled;
        NT5GroupType = GroupContext->TypeBody.Alias.NT5GroupType;
    }


    if (AddMember)
    {
        if (SecurityEnabled)
        {
            switch (NT5GroupType) {
            case NT5ResourceGroup:
                AuditId = SE_AUDITID_LOCAL_GROUP_ADD;
                break;
            case NT5AccountGroup:
                AuditId = SE_AUDITID_GLOBAL_GROUP_ADD;
                break;
            case NT5UniversalGroup:
                AuditId = SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_ADD;
                break;
            default:
                ASSERT(FALSE && "Invalid Group Type\n");
                return;
            }
        }
        else
        {
            switch (NT5GroupType) {
            case NT5ResourceGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_ADD;
                break;
            case NT5AccountGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_ADD;
                break;
            case NT5UniversalGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_ADD;
                break;
            default:
                ASSERT(FALSE && "Invalid Group Type\n");
                return;
            }
        }
    }
    else
    {
        if (SecurityEnabled)
        {
            switch (NT5GroupType) {
            case NT5ResourceGroup:
                AuditId = SE_AUDITID_LOCAL_GROUP_REM;
                break;
            case NT5AccountGroup:
                AuditId = SE_AUDITID_GLOBAL_GROUP_REM;
                break;
            case NT5UniversalGroup:
                AuditId = SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_REM;
                break;
            default:
                ASSERT(FALSE && "Invalid Group Type\n");
                return;
            }
        }
        else
        {
            switch (NT5GroupType) {
            case NT5ResourceGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_REM;
                break;
            case NT5AccountGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_REM;
                break;
            case NT5UniversalGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_REM;
                break;
            default:
                ASSERT(FALSE && "Invalid Group Type\n");
                return;
            }
        }
    }

    //
    // member name 
    // 
    if (ARGUMENT_PRESENT(MemberStringName))
    {
        RtlInitUnicodeString(&MemberName, MemberStringName);
    }
    else
    {
        RtlInitUnicodeString(&MemberName, L"-");
    }


    //
    // Group name
    // 
    NtStatus = SampLookupAccountName(
                            GroupContext->DomainIndex,
                            GroupRid, 
                            &GroupName, 
                            &ObjectType
                            );

    if (!NT_SUCCESS(NtStatus)) {
        RtlInitUnicodeString(&GroupName, L"-");
    }

    SampAuditAnyEvent(
        GroupContext,
        STATUS_SUCCESS,
        AuditId,              // Audit Event Id
        Domain->Sid,          // Domain SID
        &MemberName,          // Additional Info -- Member Name
        MemberRid,            // Member Rid is present 
        MemberSid,            // Member Sid is present
        &GroupName,           // Group Account Name
        &Domain->ExternalName,// Domain Name 
        &GroupRid,            // Group Rid
        NULL                  // Privileges
        );

    if ( NT_SUCCESS(NtStatus) ) {
        MIDL_user_free( GroupName.Buffer );
    }

    return;
}
    



VOID
SampAuditUserAccountControlChange(
    PSAMP_OBJECT AccountContext, 
    ULONG NewUserAccountControl, 
    ULONG OldUserAccountControl,
    PUNICODE_STRING AccountName
    )
/*++
Routine Description:

    This routine audits User/Computer Account changes. 
    And log Account Disable or Enabled event. 

Arguments:

    AccountContext -- Pointer to User/Computer Account Context
    
    OldUserAccountControl -- UserAccountControl before the change
    
    NewUserAccountControl -- UserAccountControl after the change
    
    AccountName -- Pass in account name

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus;
    PSAMP_DEFINED_DOMAINS Domain = NULL;
    ULONG   AuditId = 0;
    

    //
    // If and ONLY if this account get auto Lockedout or Unlocked, 
    // return immediately, because we have already event log 
    // account lockout and unlock operation. 
    // 
    if ((OldUserAccountControl & (ULONG) USER_ACCOUNT_DISABLED) == 
        (NewUserAccountControl & (ULONG) USER_ACCOUNT_DISABLED) )
    {
        return;
    }


    Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

    // 
    // audit account state change: Disabled or Enabled
    // 

    if ( (OldUserAccountControl & USER_ACCOUNT_DISABLED) &&
        !(NewUserAccountControl & USER_ACCOUNT_DISABLED) )
    {
        AuditId = SE_AUDITID_USER_ENABLED; 
    }
    else if ( !(OldUserAccountControl & USER_ACCOUNT_DISABLED) &&
               (NewUserAccountControl & USER_ACCOUNT_DISABLED) )
    {
        AuditId = SE_AUDITID_USER_DISABLED; 
    }

    SampAuditAnyEvent(AccountContext,
                      STATUS_SUCCESS,
                      AuditId,
                      Domain->Sid,
                      NULL,
                      NULL,
                      NULL,
                      AccountName,
                      &Domain->ExternalName,
                      &AccountContext->TypeBody.User.Rid,
                      NULL
                      );

    return;
}



VOID
SampAuditDomainPolicyChange(
    IN NTSTATUS StatusCode,
    IN PSID DomainSid, 
    IN PUNICODE_STRING DomainName,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass
    )
/*++
Routine Description:

    This routine audits Domain Policy changes. 
    And write what policy property has been modified.

Arguments:

    StatusCode - Status Code to log     

    DomainSid - Domain Object SID
    
    DomainName - Domain Name
    
    DomainInformationClass - indicate what policy property

Return Value:

    None.

--*/
{
    ULONG       MsgId;
    PWCHAR      DomainPolicyChangeString = NULL;
    UNICODE_STRING  DomainPolicyChange;

    switch (DomainInformationClass) {
    case DomainPasswordInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_PWD;
        break;
    case DomainLogoffInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOGOFF;
        break;
    case DomainOemInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_OEM;
        break;
    case DomainReplicationInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_REPLICATION;
        break;
    case DomainServerRoleInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_SERVERROLE;
        break;
    case DomainStateInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_STATE;
        break;
    case DomainLockoutInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOCKOUT;
        break;
    case DomainModifiedInformation2:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_MODIFIED;
        break;
    case DomainGeneralInformation:
    case DomainGeneralInformation2:
    case DomainNameInformation:
    case DomainModifiedInformation:
    case DomainUasInformation:
    default:
        return;
    }

    DomainPolicyChangeString = SampGetAuditMessageString(MsgId);

    if (DomainPolicyChangeString)
    {
        RtlInitUnicodeString(&DomainPolicyChange, DomainPolicyChangeString);
    }
    else
    {
        RtlInitUnicodeString(&DomainPolicyChange, L"-");
    }

    //
    // Loopback Client will not call into this routine
    // 

    LsaIAuditSamEvent(
        StatusCode,
        SE_AUDITID_DOMAIN_POLICY_CHANGE,// Audit ID
        DomainSid,                      // Domain Sid
        &DomainPolicyChange,            // Indicate what policy property was changed
        NULL,                           // Member Rid (not used)
        NULL,                           // Member Sid (not used)
        NULL,                           // Account Name (not used)
        DomainName,                     // Domain
        NULL,                           // Account Rid (not used)
        NULL                            // Privileges used
        );

    return;
}



VOID
SampAuditDomainChangeDs(
    IN PSAMP_OBJECT DomainContext,
    IN ULONG        cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++
Routine Description:

    This routine audits Domain attribute changes originated from 
    loopback client

Parameters:

    DomainContext - pointer to the domain object

    cCallMap - number of attributes
    
    rCallMap - array of attributes
    
    rSamAttributeMap - SAM attribute mapping table

Return Values:
--*/
{
    BOOLEAN AuditOemInfo = FALSE,
            AuditPwdInfo = FALSE,
            AuditLogoffInfo = FALSE,
            AuditLockoutInfo = FALSE,
            AuditDomainMode = FALSE,
            fAdditionalInfoSet = FALSE;
    PWCHAR  OemInfo = NULL, 
            PwdInfo = NULL, 
            LogoffInfo = NULL, 
            LockoutInfo = NULL, 
            DomainModeInfo = NULL;
    UNICODE_STRING  AdditionalInfo;
    PWSTR   AdditionalInfoString = NULL;
    ULONG   i, BufLength = 0;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;


    //
    // Get a pointer to the domain this object is in
    // 

    Domain = &SampDefinedDomains[DomainContext->DomainIndex];

    //
    // go through all attributes need to be audited
    // 

    for ( i = 0; i < cCallMap; i++ )
    {
        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
        {
            continue;
        }

        switch(rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_DOMAIN_OEM_INFORMATION:

            if (!AuditOemInfo)
            {
                AuditOemInfo = TRUE;
                OemInfo = SampGetAuditMessageString(
                                SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_OEM); 
                BufLength += (wcslen(OemInfo) + 1);
            }

            break;

        case SAMP_FIXED_DOMAIN_MAX_PASSWORD_AGE:
        case SAMP_FIXED_DOMAIN_MIN_PASSWORD_AGE:
        case SAMP_FIXED_DOMAIN_PWD_PROPERTIES:
        case SAMP_FIXED_DOMAIN_MIN_PASSWORD_LENGTH:
        case SAMP_FIXED_DOMAIN_PASSWORD_HISTORY_LENGTH:

            if (!AuditPwdInfo)
            {
                AuditPwdInfo = TRUE;
                PwdInfo = SampGetAuditMessageString(
                                SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_PWD); 
                BufLength += (wcslen(PwdInfo) + 1);
            }

            break;

        case SAMP_FIXED_DOMAIN_FORCE_LOGOFF:

            if (!AuditLogoffInfo)
            {
                AuditLogoffInfo = TRUE;
                LogoffInfo = SampGetAuditMessageString(
                                SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOGOFF); 
                BufLength += (wcslen(LogoffInfo) + 1);
            }

            break;

        case SAMP_FIXED_DOMAIN_LOCKOUT_DURATION:
        case SAMP_FIXED_DOMAIN_LOCKOUT_OBSERVATION_WINDOW:
        case SAMP_FIXED_DOMAIN_LOCKOUT_THRESHOLD:

            if (!AuditLockoutInfo)
            {
                AuditLockoutInfo = TRUE;
                LockoutInfo = SampGetAuditMessageString(
                                SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOCKOUT); 
                BufLength += (wcslen(LockoutInfo) + 1);
            }

            break;

        case SAMP_DOMAIN_MIXED_MODE:

            if (!AuditDomainMode)
            {
                AuditDomainMode = TRUE;
                DomainModeInfo = SampGetAuditMessageString(
                                SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_DOMAINMODE); 
                BufLength += (wcslen(DomainModeInfo) + 1);
            }

            break;

        default:

            break;
        }
    }

    if (BufLength)
    {
        AdditionalInfoString = MIDL_user_allocate( BufLength * sizeof(WCHAR) );
        if (NULL == AdditionalInfoString)
        {
            return;
        }
        RtlZeroMemory(AdditionalInfoString, BufLength * sizeof(WCHAR));


        if (OemInfo)
        {
            wcscat(AdditionalInfoString, OemInfo);
            fAdditionalInfoSet = TRUE;
        }
        if (PwdInfo)
        {
            if (fAdditionalInfoSet)
            {
                wcscat(AdditionalInfoString, L",");
            }
            wcscat(AdditionalInfoString, PwdInfo);
            fAdditionalInfoSet = TRUE;
        }
        if (LogoffInfo)
        {
            if (fAdditionalInfoSet)
            {
                wcscat(AdditionalInfoString, L",");
            }
            wcscat(AdditionalInfoString, LogoffInfo);
            fAdditionalInfoSet = TRUE;
        }
        if (LockoutInfo)
        {
            if (fAdditionalInfoSet)
            {
                wcscat(AdditionalInfoString, L",");
            }
            wcscat(AdditionalInfoString, LockoutInfo);
            fAdditionalInfoSet = TRUE;
        }
        if (DomainModeInfo)
        {
            if (fAdditionalInfoSet)
            {
                wcscat(AdditionalInfoString, L",");
            }
            wcscat(AdditionalInfoString, DomainModeInfo);
            fAdditionalInfoSet = TRUE;
        }

        RtlInitUnicodeString(&AdditionalInfo, AdditionalInfoString);
    }
    else
    {
        RtlInitUnicodeString(&AdditionalInfo, L"-");
    }

    ASSERT(DomainContext->LoopbackClient);

    SampAddLoopbackTaskForAuditing(
                STATUS_SUCCESS, 
                SE_AUDITID_DOMAIN_POLICY_CHANGE,    // Audit ID
                Domain->Sid,                        // Domain Sid
                &AdditionalInfo,                    // Indicate policy
                NULL,                               // Member Rid (not used)
                NULL,                               // Member Sid (not used)
                NULL,                               // Account Name (not used)
                &Domain->ExternalName,              // Domain Name
                NULL,                               // Account Rid (not used)
                NULL
                );

    if (AdditionalInfoString)
    {
        MIDL_user_free( AdditionalInfoString );
    }

    return;
}



VOID
SampAuditAccountNameChange(
    IN PSAMP_OBJECT     AccountContext,
    IN PUNICODE_STRING  NewAccountName,
    IN PUNICODE_STRING  OldAccountName
    )
/*++
Routine Description:

    This routine generates an Account Name Change audit. 
    it calls SampAuditAnyEvent().

Parameters:

    AccountContext - object context
    
    NewAccountName - pointer to new account name
    
    OldAccountName - pointer to old account name

Return Value:

    None
    
--*/
{
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    ULONG                   AccountRid;

    //
    // Get a pointer to the domain this object is in.
    // 

    Domain = &SampDefinedDomains[AccountContext->DomainIndex];

    //
    // Get AccountRid
    // 

    switch (AccountContext->ObjectType)
    {
    case SampUserObjectType:
        AccountRid = AccountContext->TypeBody.User.Rid;
        break;

    case SampGroupObjectType:
        AccountRid = AccountContext->TypeBody.Group.Rid;
        break;
        
    case SampAliasObjectType:
        AccountRid = AccountContext->TypeBody.Alias.Rid;
        break;

    default:
        ASSERT(FALSE && "Invalid object type\n");
        return;
    }


    SampAuditAnyEvent(AccountContext,   // AccountContext,
                      STATUS_SUCCESS,   // NtStatus
                      SE_AUDITID_ACCOUNT_NAME_CHANGE,  // AuditId,
                      Domain->Sid,      // DomainSid
                      OldAccountName,   // Additional Info
                      NULL,             // Member Rid
                      NULL,             // Member Sid
                      NewAccountName,   // AccountName
                      &Domain->ExternalName,    // Domain Name
                      &AccountRid,      // AccountRid
                      NULL              // Privileges used
                      );

}



VOID
SampAuditDomainChange(
    ULONG   DomainIndex
    )
/*++
Routine Description:

    this routine generates a domain change audit event. It is called by 
    SampNotifyReplicatedinChange() for LDAP client modifying domain object.  

Parameters:

    DomainIndex - indicates which domain been changed    

Return Value:

    None.

--*/
{
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    UNICODE_STRING          AdditionalInfo;


    //
    // Get a pointer to the domain this object is in.
    // 

    Domain = &SampDefinedDomains[DomainIndex];

    RtlInitUnicodeString(&AdditionalInfo, L"-");

    LsaIAuditSamEvent(
        STATUS_SUCCESS,
        SE_AUDITID_DOMAIN_POLICY_CHANGE,// Audit ID
        Domain->Sid,                    // Domain Sid
        &AdditionalInfo,                // Indicate what policy property was changed
        NULL,                           // Member Rid (not used)
        NULL,                           // Member Sid (not used)
        NULL,                           // Account Name (not used)
        &Domain->ExternalName,          // Domain
        NULL,                           // Account Rid (not used)
        NULL                            // Privileges used
        );

    return; 
}

VOID
SampAuditGroupChange(
    ULONG   DomainIndex, 
    PUNICODE_STRING AccountName,
    PULONG  AccountRid, 
    ULONG   GroupType
    )
/*++
Routine Description:

    This routine generates a group change audit. 
    It is called by both RPC clents and LDAP clents.

    RPC client - calls it from SamrSetInformationGroup / SamrSetInformationAlias

    LDAP client - calls it from SampNotifyReplicatedinChange. 

Parameter:

    DomainIndex -- indicates which domain the object belongs to

    AccountName -- pointer to account name.
    
    AcountRid -- pointer to account rid 

    GroupType -- indicates the group type, used to pick up audit ID

Return Value:

    None

--*/
{
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    ULONG                   AuditId;

    //
    // Get a pointer to the domain this object is in.
    // 

    Domain = &SampDefinedDomains[DomainIndex];

    //
    // chose an Auditing ID to audit
    // 

    if (GROUP_TYPE_SECURITY_ENABLED & GroupType)
    {
        if (GROUP_TYPE_RESOURCE_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_LOCAL_GROUP_CHANGE;
        }
        else if (GROUP_TYPE_ACCOUNT_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_GLOBAL_GROUP_CHANGE;
        }
        else if (GROUP_TYPE_UNIVERSAL_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_CHANGE;
        }
        else
        {
            ASSERT(FALSE && "Invalid GroupType\n");
            return;
        }
    }
    else
    {
        if (GROUP_TYPE_RESOURCE_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_CHANGE; 
        }
        else if (GROUP_TYPE_ACCOUNT_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_CHANGE;
        }
        else if (GROUP_TYPE_UNIVERSAL_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_CHANGE;
        }
        else
        {
            ASSERT(FALSE && "Invalid GroupType\n");
            return;
        }
    }

    LsaIAuditSamEvent(STATUS_SUCCESS,
                      AuditId,
                      Domain->Sid,
                      NULL,
                      NULL,
                      NULL,
                      AccountName,
                      &(Domain->ExternalName),
                      AccountRid,
                      NULL
                      );

    return;
}


VOID
SampAuditUserChange(
    ULONG   DomainIndex, 
    PUNICODE_STRING AccountName,
    PULONG  AccountRid, 
    ULONG   AccountControl
    )
{
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    UNICODE_STRING          AdditionalInfo;
    ULONG                   AuditId;


    RtlInitUnicodeString(&AdditionalInfo, L"-");
    
    //
    // Get a pointer to the domain this object is in.
    // 

    Domain = &SampDefinedDomains[DomainIndex];

    //
    // chose an Auditing ID to audit
    // 

    if (AccountControl & USER_MACHINE_ACCOUNT_MASK)
    {
        AuditId = SE_AUDITID_COMPUTER_CHANGE;
    }
    else
    {
        AuditId = SE_AUDITID_USER_CHANGE;
    }

    LsaIAuditSamEvent(STATUS_SUCCESS,
                      AuditId,
                      Domain->Sid,
                      &AdditionalInfo,
                      NULL,
                      NULL,
                      AccountName,
                      &(Domain->ExternalName),
                      AccountRid,
                      NULL
                      );

    return;
}


VOID
SampAuditUserDelete(
    ULONG           DomainIndex, 
    PUNICODE_STRING AccountName,
    PULONG          AccountRid, 
    ULONG           AccountControl
    )
/*++

Routine Description:

    This routine generates a group change audit. 
    
    It is called in both registry and DS cases

    Registry - calls it from SamrDeleteUser

    DS - calls it from SampNotifyReplicatedinChange. 

Parameter:

    DomainIndex -- indicates which domain the object belongs to

    AccountName -- pointer to account name.
    
    AcountRid -- pointer to account rid 

    AccountControl -- the type of user account 

Return Value:

    None

--*/
{
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    ULONG                   AuditId;

    //
    // Get a pointer to the domain this object is in.
    //

    Domain = &SampDefinedDomains[DomainIndex];

    if (AccountControl & USER_MACHINE_ACCOUNT_MASK )
    {
        AuditId = SE_AUDITID_COMPUTER_DELETED;
    }
    else
    {
        AuditId = SE_AUDITID_USER_DELETED;
    }

    LsaIAuditSamEvent(STATUS_SUCCESS,
                      AuditId,
                      Domain->Sid,
                      NULL,
                      NULL,
                      NULL,
                      AccountName,
                      &(Domain->ExternalName),
                      AccountRid,
                      NULL
                      );


    return;
}

VOID
SampAuditGroupDelete(
    ULONG           DomainIndex, 
    PUNICODE_STRING GroupName,
    PULONG          AccountRid, 
    ULONG           GroupType
    )
/*++

Routine Description:

    This routine generates a group change audit. 
    
    It is called in both registry and DS cases

    Registry  - calls it from SamrDeleteGroup / SamrDeleteAlias

    DS  - calls it from SampNotifyReplicatedinChange. 

Parameter:

    DomainIndex -- indicates which domain the object belongs to

    GroupName -- pointer to group name.
    
    AcountRid -- pointer to account rid 

    GroupType -- indicates the group type, used to pick up audit ID

Return Value:

    None

--*/
{
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    ULONG                   AuditId;

    //
    // Get a pointer to the domain this object is in.
    //

    Domain = &SampDefinedDomains[DomainIndex];

    //
    // chose an Auditing ID to audit
    //
    if (GROUP_TYPE_SECURITY_ENABLED & GroupType)
    {
        if (GROUP_TYPE_ACCOUNT_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_GLOBAL_GROUP_DELETED;
        }
        else if (GROUP_TYPE_UNIVERSAL_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_DELETED;
        }
        else 
        {
            ASSERT(GROUP_TYPE_RESOURCE_GROUP & GroupType);
            AuditId = SE_AUDITID_LOCAL_GROUP_DELETED;
        }
    }
    else
    {
        if (GROUP_TYPE_ACCOUNT_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_DELETED;
        }
        else if (GROUP_TYPE_UNIVERSAL_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_DELETED;
        }
        else
        {
            ASSERT(GROUP_TYPE_RESOURCE_GROUP & GroupType);
            AuditId = SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_DELETED;
        }
    }

    LsaIAuditSamEvent(STATUS_SUCCESS,
                      AuditId,
                      Domain->Sid,
                      NULL,
                      NULL,
                      NULL,
                      GroupName,
                      &(Domain->ExternalName),
                      AccountRid,
                      NULL
                      );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\samtrace.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    SAMTRACE.C
    
Abstract:

    Implement SAM Server event tracing by using WMI trace infrastructure. 
    
Author:

    01-Dec-1998     ShaoYin
    
Revision History:


--*/

//
//
//  Include header files
//
// 

#include <samsrvp.h>
#include <wmistr.h>                 // WMI
#define INITGUID
#include <sdconvrt.h>
#include <sddl.h>
#include <samtrace.h>




#define RESOURCE_NAME __TEXT("MofResource")
#define IMAGE_PATH    __TEXT("samsrv.dll")
#define LSA_KEY_STRING  __TEXT("System\\CurrentControlSet\\Control\\Lsa")
#define TRACE_SAM_EVENT_IN_DETAIL_VALUE_STRING    __TEXT("TraceSamEventInDetail")

#define SAM_EVENT_TRACE_VERSION     0x00000001 
#define SAM_EVENT_TRACE_SIGNATURE   __TEXT("SAM")

unsigned long   SampEventTraceFlag = FALSE;
TRACEHANDLE     SampTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE     SampTraceLoggerHandle = (TRACEHANDLE) 0;
BOOLEAN         SampTraceLogEventInDetail = FALSE;



//
// Forward declaration
// 

ULONG
SampTraceControlCallBack(
    IN WMIDPREQUESTCODE RequestCode, 
    IN PVOID RequestContext, 
    IN OUT ULONG *InOutBufferSize, 
    IN OUT PVOID Buffer
    );
    
//
// The following table contains the address of event trace GUID.
// We should always update SAMPTRACE_GUID (enum type defined in samtrace.h)
// whenever we add new event trace GUID for SAM
// 
    
TRACE_GUID_REGISTRATION SampTraceGuids[] =
{
    {&SampConnectGuid,                          NULL},
    {&SampCloseHandleGuid,                      NULL},
    {&SampSetSecurityObjectGuid,                NULL},
    {&SampQuerySecurityObjectGuid,              NULL},
    {&SampShutdownSamServerGuid,                NULL},
    {&SampLookupDomainInSamServerGuid,          NULL},
    {&SampEnumerateDomainsInSamServerGuid,      NULL},
    {&SampOpenDomainGuid,                       NULL},
    {&SampQueryInformationDomainGuid,           NULL},
    {&SampSetInformationDomainGuid,             NULL},
    {&SampCreateGroupInDomainGuid,              NULL},
    {&SampEnumerateGroupsInDomainGuid,          NULL},
    {&SampCreateUserInDomainGuid,               NULL},
    {&SampCreateComputerInDomainGuid,           NULL},
    {&SampEnumerateUsersInDomainGuid,           NULL},
    {&SampCreateAliasInDomainGuid,              NULL},
    {&SampEnumerateAliasesInDomainGuid,         NULL},
    {&SampGetAliasMembershipGuid,               NULL},
    {&SampLookupNamesInDomainGuid,              NULL},
    {&SampLookupIdsInDomainGuid,                NULL},
    {&SampOpenGroupGuid,                        NULL},
    {&SampQueryInformationGroupGuid,            NULL},
    {&SampSetInformationGroupGuid,              NULL},
    {&SampAddMemberToGroupGuid,                 NULL},
    {&SampDeleteGroupGuid,                      NULL},
    {&SampRemoveMemberFromGroupGuid,            NULL},
    {&SampGetMembersInGroupGuid,                NULL},
    {&SampSetMemberAttributesOfGroupGuid,       NULL},
    {&SampOpenAliasGuid,                        NULL},
    {&SampQueryInformationAliasGuid,            NULL},
    {&SampSetInformationAliasGuid,              NULL},
    {&SampDeleteAliasGuid,                      NULL},
    {&SampAddMemberToAliasGuid,                 NULL},
    {&SampRemoveMemberFromAliasGuid,            NULL},
    {&SampGetMembersInAliasGuid,                NULL},
    {&SampOpenUserGuid,                         NULL},
    {&SampDeleteUserGuid,                       NULL},
    {&SampQueryInformationUserGuid,             NULL},
    {&SampSetInformationUserGuid,               NULL},
    {&SampChangePasswordUserGuid,               NULL},
    {&SampChangePasswordComputerGuid,           NULL},
    {&SampSetPasswordUserGuid,                  NULL},
    {&SampSetPasswordComputerGuid,              NULL},
    {&SampPasswordPushPdcGuid,                  NULL},
    {&SampGetGroupsForUserGuid,                 NULL},
    {&SampQueryDisplayInformationGuid,          NULL},
    {&SampGetDisplayEnumerationIndexGuid,       NULL},
    {&SampGetUserDomainPasswordInformationGuid, NULL},
    {&SampRemoveMemberFromForeignDomainGuid,    NULL},
    {&SampGetDomainPasswordInformationGuid,     NULL},
    {&SampSetBootKeyInformationGuid,            NULL},
    {&SampGetBootKeyInformationGuid,            NULL},

};


#define SampGuidCount (sizeof(SampTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

    

ULONG
_stdcall
SampInitializeTrace(
    PVOID Param
    )
/*++    
Routine Description:

    Register WMI Trace Guids. The caller should only call this 
    api in DS mode.
    
Parameters:

    None.
    
Reture Values:
    
    None. 
    
--*/
{
    ULONG   Status = ERROR_SUCCESS;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }
    
    //
    // Register Trace GUIDs
    // 
    
    Status = RegisterTraceGuids(
                    SampTraceControlCallBack, 
                    NULL, 
                    &SampControlGuid, 
                    SampGuidCount, 
                    SampTraceGuids, 
                    FileName, 
                    RESOURCE_NAME, 
                    &SampTraceRegistrationHandle);
                    
#if DBG
    if (Status != ERROR_SUCCESS)
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampInitializeTrace Failed ==> %d\n",
                   Status));

    }
    else
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampInitializeTrace SUCCEED ==> %d\n",
                   Status));
    }
#endif // DBG
    
    return Status;
}


BOOLEAN
SampCheckLogEventInDetailFlag(
    TRACEHANDLE TraceLoggerHandle
    )
/*++

Routine Description:

    This routine checks whether data logging is enabled or not. 
    if detail event trace is enabled, then log event in detail.
    Otherwise, just log the event without detail info.

Parameters:

    None

Return Value:

    TRUE - data logging is enabled
    
    FALSE - data logging is disabled

--*/
{
    ULONG           WinError = ERROR_SUCCESS;
    HKEY            LsaKey;
    DWORD           dwType = REG_DWORD, dwSize = sizeof(DWORD), dwValue = 0;
    BOOLEAN         ReturnResult = FALSE;
    ULONG           EnableLevel = 1;


    WinError = RegOpenKey(HKEY_LOCAL_MACHINE,
                          LSA_KEY_STRING,
                          &LsaKey
                          );

    if (ERROR_SUCCESS == WinError)
    {
        WinError = RegQueryValueEx(LsaKey,
                                   TRACE_SAM_EVENT_IN_DETAIL_VALUE_STRING,
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&dwValue,
                                   &dwSize
                                   );

        if ((ERROR_SUCCESS == WinError) && 
            (REG_DWORD == dwType) &&
            (1 == dwValue))
        {
            ReturnResult = TRUE;
        }

        RegCloseKey(LsaKey);
    }


    if (!ReturnResult)
    {
        //
        // Reg key is not set ... just get the level
        // from the trace logger handle
        //

        EnableLevel = GetTraceEnableLevel(TraceLoggerHandle);
        if ( EnableLevel > 1)
        {
            ReturnResult = TRUE;
        }
    }



    return(ReturnResult);
}


ULONG
SampTraceControlCallBack(
    IN WMIDPREQUESTCODE RequestCode, 
    IN PVOID RequestContext, 
    IN OUT ULONG *InOutBufferSize, 
    IN OUT PVOID Buffer
    )
/*++

Routine Description:

Parameters:

Return Values:

--*/
{

    PWNODE_HEADER   Wnode = (PWNODE_HEADER) Buffer;
    TRACEHANDLE     LocalTraceHandle;
    ULONG   Status = ERROR_SUCCESS;
    ULONG   RetSize;
    ULONG   EnableLevel;
    
    switch (RequestCode) 
    {
        case WMI_ENABLE_EVENTS:
        {
            SampTraceLoggerHandle = LocalTraceHandle = GetTraceLoggerHandle(Buffer);
            SampEventTraceFlag = 1;     // enable flag
            SampTraceLogEventInDetail = SampCheckLogEventInDetailFlag(LocalTraceHandle);
            RetSize = 0;  
            break; 
        }
    
        case WMI_DISABLE_EVENTS:
        {
            SampTraceLoggerHandle = (TRACEHANDLE) 0;
            SampEventTraceFlag = 0;     // disable flag
            SampTraceLogEventInDetail= FALSE;   // disable detail data logging
            RetSize = 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }
    } 
    
    *InOutBufferSize = RetSize;
    return Status;
} 


    
VOID
SampTraceEvent(
    IN ULONG WmiEventType, 
    IN ULONG TraceGuid 
    )
/*++

Routine Description:

    This routine will do a WMI event trace. 
    
    In Registry Mode, it is NO-OP.
    
    Only has effect in DS mode.

Parameters:

    WmiEventType - Event Type, valid values are:
                   EVENT_TRACE_TYPE_START
                   EVENT_TRACE_TYPE_END
                   
    TraceGuid - Index in SampTraceGuids[]                   

Return Values:

    None.

--*/

{
    ULONG       WinError = ERROR_SUCCESS;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    RPC_STATUS  RpcStatus = RPC_S_OK;
    RPC_BINDING_HANDLE  ServerBinding;
    PTOKEN_OWNER    Owner = NULL;
    PTOKEN_PRIMARY_GROUP    PrimaryGroup = NULL;
    PWSTR       StringSid = NULL;       
    PWSTR       StringBinding = NULL;
    PWSTR       NetworkAddr = NULL;
    WCHAR       NullChar = 0;
    ULONG       Version = SAM_EVENT_TRACE_VERSION;
    SAMP_EVENT_TRACE_INFO   Event;

    
    
    //
    // Theoretically, only test SampEventTraceFlag would be enough, since
    // SampEventTraceFlag will remain FALSE in Registry Mode, because 
    // SampInitializeTrace() will never been called in Registry Mode.
    // Thus nobody will change the value of SampEventTraceFlag 
    // 
    if (!SampEventTraceFlag)
    {
        return;
    }

    //
    // Assert we do a WMI trace only in DS mode.
    // 
    ASSERT(SampUseDsData);


    // 
    // Fill the event information. 
    // 
    memset(&Event, 0, sizeof(SAMP_EVENT_TRACE_INFO));
      
    //
    // TraceGuid should be a valid one
    //
    ASSERT(TraceGuid <= SampGuidCount);
    Event.EventTrace.GuidPtr = (ULONGLONG) SampTraceGuids[TraceGuid].Guid; 
      
    Event.EventTrace.Class.Type = (UCHAR) WmiEventType;
    Event.EventTrace.Class.Version =  SAM_EVENT_TRACE_VERSION;   
    Event.EventTrace.Flags |= (WNODE_FLAG_USE_GUID_PTR |  // GUID is actually a pointer 
                               WNODE_FLAG_USE_MOF_PTR  |  // Data is not contiguous to header
                               WNODE_FLAG_TRACED_GUID);   // denotes a trace 
                             
    Event.EventTrace.Size = sizeof(EVENT_TRACE_HEADER);   // no other parameters/information

    //
    // log detailed info if required
    // 

    if (SampTraceLogEventInDetail && 
        (EVENT_TRACE_TYPE_START == WmiEventType)
        )
    {

        //
        // Get Client SID
        // 
        NtStatus = SampGetCurrentOwnerAndPrimaryGroup(
                            &Owner,
                            &PrimaryGroup
                            );

        if (!NT_SUCCESS(NtStatus))
        {
            StringSid = &NullChar;
        }
        else 
        {
            if (0 == ConvertSidToStringSidW(Owner->Owner, &StringSid))
            {
                StringSid = &NullChar;
            }
        }

        //
        // Get Clinet Network Address 
        // 

        RpcStatus = RpcBindingServerFromClient(NULL, &ServerBinding); 

        if (RPC_S_OK == RpcStatus)
        {
            RpcStatus = RpcBindingToStringBindingW(ServerBinding, &StringBinding);
            
            if (RPC_S_OK == RpcStatus)
            {
                RpcStatus = RpcStringBindingParseW(StringBinding, 
                                               NULL,
                                               NULL,
                                               &NetworkAddr,
                                               NULL,
                                               NULL
                                               );
            }

        }

        if (RPC_S_OK != RpcStatus)
        {
            NetworkAddr = &NullChar;
        }

        //
        // O.K. Now we have both Client SID and NetworkAddr, 
        // prepare the event info
        // 

        Event.EventInfo[0].Length = (wcslen(SAM_EVENT_TRACE_SIGNATURE) + 1) * sizeof(WCHAR);
        Event.EventInfo[0].DataPtr = (ULONGLONG) SAM_EVENT_TRACE_SIGNATURE;

        Event.EventInfo[1].Length = sizeof(ULONG);
        Event.EventInfo[1].DataPtr = (ULONGLONG) &Version;

        Event.EventInfo[2].Length = (wcslen(StringSid) + 1) * sizeof(WCHAR);
        Event.EventInfo[2].DataPtr = (ULONGLONG) StringSid;

        Event.EventInfo[3].Length = (wcslen(NetworkAddr) + 1) * sizeof(WCHAR);
        Event.EventInfo[3].DataPtr = (ULONGLONG) NetworkAddr;

        Event.EventTrace.Size += sizeof(Event.EventInfo);
       
    }

    //
    // Log the Event
    // 
    WinError = TraceEvent(SampTraceLoggerHandle, 
                          (PEVENT_TRACE_HEADER)&Event
                          ); 

    if (WinError != ERROR_SUCCESS)
    {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampTraceEvent Error: 0x%x\n",
                       WinError));
    }


    //
    // Cleanup
    //

    if (Owner)
        MIDL_user_free(Owner);

    if (PrimaryGroup)
        MIDL_user_free(PrimaryGroup);

    if (StringSid && (&NullChar != StringSid))
        LocalFree(StringSid);

    if (NetworkAddr && (&NullChar != NetworkAddr))
        RpcStringFreeW(&NetworkAddr);

    if (StringBinding)
        RpcStringFreeW(&StringBinding);


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\samtrace.h ===
#ifndef _SAMTRACE_H
#define _SAMTRACE_H

/*++

copyright (c) 1998 Microsoft Corporation

Module Name:

    SAMTRACE.H
    
Abstract:

    Inplement SAM server event trace by using WMI trace infrastructure.
    
Author:
    
    01-Dec-1998  ShaoYin
    
Revision History:

    
--*/    


//
//
// included headers
//
// 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>


#include <wmistr.h>
#include <evntrace.h>



extern unsigned long    SampEventTraceFlag;
extern TRACEHANDLE      SampTraceRegistrationHandle;
extern TRACEHANDLE      SampTraceLoggerHandle;
extern BOOLEAN          SampTraceLogEventInDetail;


ULONG
_stdcall
SampInitializeTrace(PVOID Param);


VOID
SampTraceEvent(
    IN ULONG WmiEventType, 
    IN ULONG TraceGuid 
    );


//
// This is the control Guid for the group of Guids traced below
// 
DEFINE_GUID ( /* 8e598056-8993-11d2-819e-0000f875a064 */
    SampControlGuid, 
    0x8e598056, 
    0x8993, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* 8c89045c-3f5d-4289-939a-fb854000cb6b */
    SampConnectGuid,
    0x8c89045c,
    0x3f5d,
    0x4289,
    0x93, 0x9a, 0xfb, 0x85, 0x40, 0x00, 0xcb, 0x6b
    );


DEFINE_GUID ( /* dbc0ceab-cff3-4c0f-85f2-0c2107142f36 */
    SampCloseHandleGuid,
    0xdbc0ceab,
    0xcff3,
    0x4c0f,
    0x85, 0xf2, 0x0c, 0x21, 0x07, 0x14, 0x2f, 0x36
    );


DEFINE_GUID ( /* 74e10cbb-202e-4a97-871d-8547972b5141 */
    SampSetSecurityObjectGuid,
    0x74e10cbb,
    0x202e,
    0x4a97,
    0x87, 0x1d, 0x85, 0x47, 0x97, 0x2b, 0x51, 0x41
    );


DEFINE_GUID ( /* 676347f3-fd20-4e7d-90b1-77e35f84af9a */
    SampQuerySecurityObjectGuid,
    0x676347f3,
    0xfd20,
    0x4e7d,
    0x90, 0xb1, 0x77, 0xe3, 0x5f, 0x84, 0xaf, 0x9a
    );



DEFINE_GUID ( /* f8012701-7e99-49c5-b832-1db8bc4a610d */
    SampShutdownSamServerGuid,
    0xf8012701,
    0x7e99,
    0x49c5,
    0xb8, 0x32, 0x1d, 0xb8, 0xbc, 0x4a, 0x61, 0x0d
    );



DEFINE_GUID ( /* a11e5d6b-353d-4bf6-97a8-ede4cba45524 */
    SampLookupDomainInSamServerGuid,
    0xa11e5d6b,
    0x353d,
    0x4bf6,
    0x97, 0xa8, 0xed, 0xe4, 0xcb, 0xa4, 0x55, 0x24
    );



DEFINE_GUID ( /* 7c65ceb0-75ba-46b9-884e-67e038c5b003 */
    SampEnumerateDomainsInSamServerGuid,
    0x7c65ceb0,
    0x75ba,
    0x46b9,
    0x88, 0x4e, 0x67, 0xe0, 0x38, 0xc5, 0xb0, 0x03
    );



DEFINE_GUID ( /* 6e1f2449-f1f3-4634-b51f-46e2c6625892 */
    SampOpenDomainGuid,
    0x6e1f2449,
    0xf1f3,
    0x4634,
    0xb5, 0x1f, 0x46, 0xe2, 0xc6, 0x62, 0x58, 0x92
    );



DEFINE_GUID ( /* 89399c21-4aaf-408e-ba39-ab831a1298d5 */
    SampQueryInformationDomainGuid,
    0x89399c21,
    0x4aaf,
    0x408e,
    0xba, 0x39, 0xab, 0x83, 0x1a, 0x12, 0x98, 0xd5
    );



DEFINE_GUID ( /* 45309ef4-c59e-425e-b95b-19f1c5a3c55a */
    SampSetInformationDomainGuid,
    0x45309ef4,
    0xc59e,
    0x425e,
    0xb9, 0x5b, 0x19, 0xf1, 0xc5, 0xa3, 0xc5, 0x5a
    );


DEFINE_GUID ( /* c8eb5e5c-899c-11d2-819e-0000f875a064 */ 
    SampCreateGroupInDomainGuid,
    0xc8eb5e5c, 
    0x899c, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* 5d11e02f-0c36-4180-ad07-89062c9df9ec */
    SampEnumerateGroupsInDomainGuid,
    0x5d11e02f,
    0x0c36,
    0x4180,
    0xad, 0x07, 0x89, 0x06, 0x2c, 0x9d, 0xf9, 0xec
    );


DEFINE_GUID ( /* 39511dbe-899b-11d2-819e-0000f875a064 */
    SampCreateUserInDomainGuid,
    0x39511dbe, 
    0x899b, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* abb14b68-899b-11d2-819e-0000f875a064 */
    SampCreateComputerInDomainGuid,
    0xabb14b68, 
    0x899b, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* 07ffaa1d-34f6-49cd-b541-2f0d7dff15c4 */
    SampEnumerateUsersInDomainGuid,
    0x07ffaa1d,
    0x34f6,
    0x49cd,
    0xb5, 0x41, 0x2f, 0x0d, 0x7d, 0xff, 0x15, 0xc4
    );



DEFINE_GUID ( /* 5e612efd-c05e-4f76-bced-f5607aa3d46e */
    SampCreateAliasInDomainGuid,
    0x5e612efd,
    0xc05e,
    0x4f76,
    0xbc, 0xed, 0xf5, 0x60, 0x7a, 0xa3, 0xd4, 0x6e
    );


DEFINE_GUID ( /* f1fea491-bfa6-436c-a178-a70d03b4fb1a */
    SampEnumerateAliasesInDomainGuid,
    0xf1fea491,
    0xbfa6,
    0x436c,
    0xa1, 0x78, 0xa7, 0x0d, 0x03, 0xb4, 0xfb, 0x1a
    );


DEFINE_GUID ( /* 1cf5fd19-1ac1-4324-84f7-970a634a91ee */
    SampGetAliasMembershipGuid,
    0x1cf5fd19,
    0x1ac1,
    0x4324,
    0x84, 0xf7, 0x97, 0x0a, 0x63, 0x4a, 0x91, 0xee
    );


DEFINE_GUID ( /* a41d90bc-899d-11d2-819e-0000f875a064 */     
    SampLookupNamesInDomainGuid,
    0xa41d90bc, 
    0x899d, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );

    
DEFINE_GUID ( /* 25059476-899f-11d2-819e-0000f875a064 */
    SampLookupIdsInDomainGuid, 
    0x25059476,
    0x899f, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );



DEFINE_GUID ( /* b41d7bdf-4249-4651-ac0f-1879be0d5c0c */
    SampOpenGroupGuid,
    0xb41d7bdf,
    0x4249,
    0x4651,
    0xac, 0x0f, 0x18, 0x79, 0xbe, 0x0d, 0x5c, 0x0c
    );



DEFINE_GUID ( /* 632fcc78-6057-48f9-8d5f-4bb0f73d3cd1 */
    SampQueryInformationGroupGuid,
    0x632fcc78,
    0x6057,
    0x48f9,
    0x8d, 0x5f, 0x4b, 0xb0, 0xf7, 0x3d, 0x3c, 0xd1
    );



DEFINE_GUID ( /* 26106246-4473-4295-841b-4a51c6afc3db */
    SampSetInformationGroupGuid,
    0x26106246,
    0x4473,
    0x4295,
    0x84, 0x1b, 0x4a, 0x51, 0xc6, 0xaf, 0xc3, 0xdb
    );



DEFINE_GUID ( /* f9d2ba6a-899c-11d2-819e-0000f875a064 */
    SampAddMemberToGroupGuid, 
    0xf9d2ba6a, 
    0x899c, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* 5f7c4ba5-d6a4-4625-900e-48fa7811e06a */
    SampDeleteGroupGuid,
    0x5f7c4ba5,
    0xd6a4,
    0x4625,
    0x90, 0x0e, 0x48, 0xfa, 0x78, 0x11, 0xe0, 0x6a
    );

    
DEFINE_GUID ( /* 250959aa-899d-11d2-819e-0000f875a064 */
    SampRemoveMemberFromGroupGuid, 
    0x25095aa, 
    0x899d, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );
    


DEFINE_GUID ( /* 5954bc51-c5ec-4aaa-831c-6f2c1b2515b6 */
    SampGetMembersInGroupGuid,
    0x5954bc51,
    0xc5ec,
    0x4aaa,
    0x83, 0x1c, 0x6f, 0x2c, 0x1b, 0x25, 0x15, 0xb6
    );



DEFINE_GUID ( /* 0254ba6d-7ff0-4bfe-a3f9-8fd8da667641 */
    SampSetMemberAttributesOfGroupGuid,
    0x0254ba6d,
    0x7ff0,
    0x4bfe,
    0xa3, 0xf9, 0x8f, 0xd8, 0xda, 0x66, 0x76, 0x41
    );



DEFINE_GUID ( /* ba41c883-592f-4ab9-b2a9-c6263b011fe7 */
    SampOpenAliasGuid,
    0xba41c883,
    0x592f,
    0x4ab9,
    0xb2, 0xa9, 0xc6, 0x26, 0x3b, 0x01, 0x1f, 0xe7
    );



DEFINE_GUID ( /* 419f025a-bf06-4673-af66-d230bec2af02 */
    SampQueryInformationAliasGuid,
    0x419f025a,
    0xbf06,
    0x4673,
    0xaf, 0x66, 0xd2, 0x30, 0xbe, 0xc2, 0xaf, 0x02
    );



DEFINE_GUID ( /* e712d39d-a3a6-4224-a1bd-4717b24e4e8c */
    SampSetInformationAliasGuid,
    0xe712d39d,
    0xa3a6,
    0x4224,
    0xa1, 0xbd, 0x47, 0x17, 0xb2, 0x4e, 0x4e, 0x8c
    );


DEFINE_GUID ( /* fbfe2540-452b-41bb-9219-dfb6fd1a129b */
    SampDeleteAliasGuid,
    0xfbfe2540,
    0x452b,
    0x41bb,
    0x92, 0x19, 0xdf, 0xb6, 0xfd, 0x1a, 0x12, 0x9b
    );



DEFINE_GUID ( /* 3a2e63d1-5dc4-4168-85ea-3e331f88ce83 */
    SampAddMemberToAliasGuid,
    0x3a2e63d1,
    0x5dc4,
    0x4168,
    0x85, 0xea, 0x3e, 0x33, 0x1f, 0x88, 0xce, 0x83
    );



DEFINE_GUID ( /* 6ba1639c-afc4-454e-b3e0-5e8f7fc39af9 */
    SampRemoveMemberFromAliasGuid,
    0x6ba1639c,
    0xafc4,
    0x454e,
    0xb3, 0xe0, 0x5e, 0x8f, 0x7f, 0xc3, 0x9a, 0xf9
    );



DEFINE_GUID ( /* 5cec3d52-6eeb-474d-b468-58362888f1b0 */
    SampGetMembersInAliasGuid,
    0x5cec3d52,
    0x6eeb,
    0x474d,
    0xb4, 0x68, 0x58, 0x36, 0x28, 0x88, 0xf1, 0xb0
    );



DEFINE_GUID ( /* b8d2bc4a-1525-4386-bb1c-6bb2e24eb001 */
    SampOpenUserGuid,
    0xb8d2bc4a,
    0x1525,
    0x4386,
    0xbb, 0x1c, 0x6b, 0xb2, 0xe2, 0x4e, 0xb0, 0x01
    );



DEFINE_GUID ( /* c2a0e094-a178-4372-b4fe-a33e48c3585c */
    SampDeleteUserGuid,
    0xc2a0e094,
    0xa178,
    0x4372,
    0xb4, 0xfe, 0xa3, 0x3e, 0x48, 0xc3, 0x58, 0x5c
    );



DEFINE_GUID ( /* e1cb227a-6d55-4282-a5f7-6fa4a5922c0b */
    SampQueryInformationUserGuid,
    0xe1cb227a,
    0x6d55,
    0x4282,
    0xa5, 0xf7, 0x6f, 0xa4, 0xa5, 0x92, 0x2c, 0x0b
    );



DEFINE_GUID ( /* bc80e27f-6b74-4da9-abfc-2e4e82b81000 */
    SampSetInformationUserGuid,
    0xbc80e27f,
    0x6b74,
    0x4da9,
    0xab, 0xfc, 0x2e, 0x4e, 0x82, 0xb8, 0x10, 0x00
    );


DEFINE_GUID ( /* 45fc997e-899d-11d2-819e-0000f875a064 */    
    SampChangePasswordUserGuid,
    0x45fc997e,
    0x899d, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );


DEFINE_GUID ( /* 19b30cde-3e41-4cff-83c8-3df2779f840c */
    SampChangePasswordComputerGuid,
    0x19b30cde,
    0x3e41,
    0x4cff,
    0x83, 0xc8, 0x3d, 0xf2, 0x77, 0x9f, 0x84, 0x0c
    );


    
DEFINE_GUID ( /* 62bef71e-899d-11d2-819e-0000f875a064 */    
    SampSetPasswordUserGuid, 
    0x62bef71e, 
    0x899d, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );
    
DEFINE_GUID ( /* 880217b8-899d-11d2-819e-0000f875a064 */    
    SampSetPasswordComputerGuid, 
    0x880217b8,
    0x899d, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );
    
DEFINE_GUID ( /* 1f228de8-8a6c-11d2-819e-0000f875a064 */
    SampPasswordPushPdcGuid, 
    0x1f228de8, 
    0x8a6c, 
    0x11d2, 
    0x81, 0x9e, 0x00, 0x00, 0xf8, 0x75, 0xa0, 0x64 
    );

    
DEFINE_GUID ( /* 0e3913c5-9760-4ced-b133-004a64e8d53c */
    SampGetGroupsForUserGuid,
    0x0e3913c5,
    0x9760,
    0x4ced,
    0xb1, 0x33, 0x00, 0x4a, 0x64, 0xe8, 0xd5, 0x3c
    );


DEFINE_GUID ( /* eb225178-f5f0-42b7-895b-db89276f647a */
    SampQueryDisplayInformationGuid,
    0xeb225178,
    0xf5f0,
    0x42b7,
    0x89, 0x5b, 0xdb, 0x89, 0x27, 0x6f, 0x64, 0x7a
    );



DEFINE_GUID ( /* aceb7864-9a14-4c73-8ed0-94ec53f6651c */
    SampGetDisplayEnumerationIndexGuid,
    0xaceb7864,
    0x9a14,
    0x4c73,
    0x8e, 0xd0, 0x94, 0xec, 0x53, 0xf6, 0x65, 0x1c
    );



DEFINE_GUID ( /* 4ff7a7db-43ca-470a-8b64-3003e2d22042 */
    SampGetUserDomainPasswordInformationGuid,
    0x4ff7a7db,
    0x43ca,
    0x470a,
    0x8b, 0x64, 0x30, 0x03, 0xe2, 0xd2, 0x20, 0x42
    );



DEFINE_GUID ( /* 8919f267-a053-4669-aa69-2da0d4a20d92 */
    SampRemoveMemberFromForeignDomainGuid,
    0x8919f267,
    0xa053,
    0x4669,
    0xaa, 0x69, 0x2d, 0xa0, 0xd4, 0xa2, 0x0d, 0x92
    );



DEFINE_GUID ( /* ff0c6ce2-9528-4a91-b9c7-bcf834b6f79a */
    SampGetDomainPasswordInformationGuid,
    0xff0c6ce2,
    0x9528,
    0x4a91,
    0xb9, 0xc7, 0xbc, 0xf8, 0x34, 0xb6, 0xf7, 0x9a
    );



DEFINE_GUID ( /* 2e991575-c2ed-42a7-97ff-a0d6571f1862 */
    SampSetBootKeyInformationGuid,
    0x2e991575,
    0xc2ed,
    0x42a7,
    0x97, 0xff, 0xa0, 0xd6, 0x57, 0x1f, 0x18, 0x62
    );



DEFINE_GUID ( /* 33be4128-d02e-4b6f-949e-ab77cc8164b1 */
    SampGetBootKeyInformationGuid,
    0x33be4128,
    0xd02e,
    0x4b6f,
    0x94, 0x9e, 0xab, 0x77, 0xcc, 0x81, 0x64, 0xb1
    );


//
// The following "typedef enum" actually is the index of LPGUID in 
// the table of SampTraceGuids[] (defined in samtrace.c). We should 
// always change SampTraceGuids[] if we add any other entry 
// in the following enum type.  
// 
    
    
typedef enum _SAMPTRACE_GUIDS {

    SampGuidConnect,
    SampGuidCloseHandle,
    SampGuidSetSecurityObject,
    SampGuidQuerySecurityObject,
    SampGuidShutdownSamServer,
    SampGuidLookupDomainInSamServer,
    SampGuidEnumerateDomainsInSamServer,
    SampGuidOpenDomain,
    SampGuidQueryInformationDomain,
    SampGuidSetInformationDomain,
    SampGuidCreateGroupInDomain,
    SampGuidEnumerateGroupsInDomain,
    SampGuidCreateUserInDomain,
    SampGuidCreateComputerInDomain,
    SampGuidEnumerateUsersInDomain,
    SampGuidCreateAliasInDomain,
    SampGuidEnumerateAliasesInDomain,
    SampGuidGetAliasMembership,
    SampGuidLookupNamesInDomain,
    SampGuidLookupIdsInDomain,
    SampGuidOpenGroup,
    SampGuidQueryInformationGroup,
    SampGuidSetInformationGroup,
    SampGuidAddMemberToGroup,
    SampGuidDeleteGroup,
    SampGuidRemoveMemberFromGroup,
    SampGuidGetMembersInGroup,
    SampGuidSetMemberAttributesOfGroup,
    SampGuidOpenAlias,
    SampGuidQueryInformationAlias,
    SampGuidSetInformationAlias,
    SampGuidDeleteAlias,
    SampGuidAddMemberToAlias,
    SampGuidRemoveMemberFromAlias,
    SampGuidGetMembersInAlias,
    SampGuidOpenUser,
    SampGuidDeleteUser,
    SampGuidQueryInformationUser,
    SampGuidSetInformationUser,
    SampGuidChangePasswordUser,
    SampGuidChangePasswordComputer,
    SampGuidSetPasswordUser,
    SampGuidSetPasswordComputer,
    SampGuidPasswordPushPdc,
    SampGuidGetGroupsForUser,
    SampGuidQueryDisplayInformation,
    SampGuidGetDisplayEnumerationIndex,
    SampGuidGetUserDomainPasswordInformation,
    SampGuidRemoveMemberFromForeignDomain,
    SampGuidGetDomainPasswordInformation,
    SampGuidSetBootKeyInformation,
    SampGuidGetBootKeyInformation

} SAMPTRACE_GUID;    


typedef struct _SAMP_EVENT_TRACE_INFO
{
    EVENT_TRACE_HEADER  EventTrace;
    MOF_FIELD           EventInfo[4];

}   SAMP_EVENT_TRACE_INFO, *PSAMP_EVENT_TRACE_INFO;
    
#endif /* _SAMTRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\sdconvrt.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Sdconvert.h

Abstract:

    This file contains services and type definitions pertaining to the 
    conversin of NT5 and NT4 SAM security descriptors

    


Author:

    Murli Satagopan (MURLIS)

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SDCONVRT_

#define _SDCONVRT_

//
// Access Right mapping Table -- The access right mapping table is
// specify the relationship between the NT4 SAM access rights and
// the DS rights. For every SAM access right there is an entry in
// the table which represents the access right as a DS access mask
// and property GUID
//


typedef struct _ACCESSRIGHT_MAPPING_TABLE {
    ACCESS_MASK SamAccessRight;
    ACCESS_MASK DsAccessMask;    
    USHORT ObjectTypeListIndex;
    USHORT Level;
    ULONG cGuids;
    const GUID  * DsGuid;
    
} ACCESSRIGHT_MAPPING_TABLE;


//
//
// The reverse Mapping table contains a SAM access mask entry for each DS access mask
// on a per property basis. The 16 specific rights of the DS is divided into 8 bit
// halves and for each combination of these, the corresponding SAM access mask is 
// stored. Given a Ds access mask and Type GUID this table can be use to 
// very quickly compute the corresponding SAM access mask.
//
//
typedef struct _REVERSE_MAPPING_TABLE_ENTRY {
    USHORT SamSpecificRightsHi[256]; 
    USHORT SamSpecificRightsLo[256]; 
} REVERSE_MAPPING_TABLE;


//
// The Sid Access mask table is used by NT5 to NT4 down non match algorithm
// down conversion code. This table is used to group the access masks in by
// type guid and Sid from a set of ACLS
//

typedef struct _SID_ACCESS_MASK_TABLE_ENTRY {
    PSID Sid;
    ACCESS_MASK * AccessAllowedMasks;
    ACCESS_MASK * AccessDeniedMasks;
    ACCESS_MASK   StandardAllowedMask;
    ACCESS_MASK   StandardDeniedMask;
} SID_ACCESS_MASK_TABLE;


//
// The ACE table is used to hold information regarding the default Dacls to be
// put on NT5 SAM security descriptors. An ace table lists the aces in the Dacl
//
//

typedef struct _ACE_TABLE_ENTRY {
    ULONG             AceType;
    PSID              *Sid;
    ACCESS_MASK       AccessMask;
    BOOLEAN           IsObjectGuid;
    const GUID        *TypeGuid;
    const GUID        *InheritGuid;
} ACE_TABLE;


//
// The NT4_ACE_TABLE structure is used by routines that try to recognize standard
// NT4 SAM Sids. These tables hold the SID and Access Masks of Ace's present in NT4
// DACL's
//

typedef struct _NT4_ACE_TABLE_ENTRY {
    PSID    *Sid;
    ACCESS_MASK AccessMask;
} NT4_ACE_TABLE;

typedef void ACE;

#define ACL_CONVERSION_CACHE_SIZE 10 // just a 10 element cache 

typedef struct _ACL_CONVERSION_CACHE_ELEMENT {
    NT4SID SidOfPrincipal;
    BOOLEAN fValid;
    BOOLEAN fAdmin;
} ACL_CONVERSION_CACHE_ELEMENT;

typedef struct _ACL_CONVERSION_CACHE {
    CRITICAL_SECTION Lock;
    ACL_CONVERSION_CACHE_ELEMENT Elements[ACL_CONVERSION_CACHE_SIZE];
} ACL_CONVERSION_CACHE;




//
// ACL Conversion cache routines
//

NTSTATUS
SampInitializeAclConversionCache();


VOID
SampInvalidateAclConversionCache();

BOOLEAN
SampLookupAclConversionCache(
    IN PSID SidToLookup,
    OUT BOOLEAN *fAdmin
    );

VOID
SampAddToAclConversionCache(
    IN PSID SidToAdd, 
    IN BOOLEAN fAdmin
    );
 
//
//
// Some Defines
//
//

#define MAX_SCHEMA_GUIDS 256
#define OBJECT_CLASS_GUID_INDEX 0
#define MAX_ACL_SIZE     2048
#define GEMERIC_MASK     0xF0000000


//
//    SAM well known Sids
//
//

#define ADMINISTRATOR_SID        (&(SampAdministratorsAliasSid))
#define ACCOUNT_OPERATOR_SID     (&(SampAccountOperatorsAliasSid))   
#define WORLD_SID                (&(SampWorldSid))
#define PRINCIPAL_SELF_SID        (&(SampPrincipalSelfSid))
#define AUTHENTICATED_USERS_SID  (&(SampAuthenticatedUsersSid))
#define BUILTIN_DOMAIN_SID       (&(SampBuiltinDomainSid))


#define DS_SPECIFIC_RIGHTS  (RIGHT_DS_CREATE_CHILD |\
                                RIGHT_DS_DELETE_CHILD |\
                                RIGHT_DS_LIST_CONTENTS |\
                                RIGHT_DS_SELF_WRITE |\
                                RIGHT_DS_READ_PROPERTY |\
                                RIGHT_DS_WRITE_PROPERTY)


//
//
// Function Prototypes
//
//

//
// Init Function for external clients like DS upgrade
//
//

NTSTATUS
SampInitializeSdConversion();


//
// Computes the reverse access rights plus does some misc initialization
//
//

NTSTATUS
SampInitializeAccessRightsTable();


//
// Access Check based on NT5 SD and NT4 SAM access Mask
//
//

NTSTATUS
SampDoNt5SdBasedAccessCheck(
    IN  PSAMP_OBJECT Context,
    IN  PVOID   Nt5Sd,
    IN  PSID    PrincipalSelfSid,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  ULONG   Nt4SamAccessMask,
    IN  BOOLEAN ObjectCreation,
    IN  GENERIC_MAPPING * Nt4SamGenericMapping,
    IN  HANDLE  ClientToken,
    OUT ACCESS_MASK * GrantedAccess,
    OUT PRTL_BITMAP   GrantedAccessAttributes,
    OUT NTSTATUS * AccessCheckStatus
    );


//
//  NT4 to NT5 upgradation of security descriptor
//
//

NTSTATUS
SampConvertNt4SdToNt5Sd(
    IN PVOID Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PSAMP_OBJECT CONTEXT OPTIONAL,
    OUT PVOID * Nt5Sd
    );

NTSTATUS
SampPropagateSelectedSdChanges(
    IN PVOID Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PSAMP_OBJECT CONTEXT OPTIONAL,
    OUT PVOID * Nt5Sd
    );


//
// NT5 to NT4 down conversion
//
//

NTSTATUS
SampConvertNt5SdToNt4SD(
    IN PVOID Nt5Sd,
    IN PSAMP_OBJECT Context,
    IN PSID SelfSid,
    OUT PVOID * Nt4Sd
    );


//
// Building NT5 security descriptors
//
//


NTSTATUS
SampBuildEquivalentNt5Protection(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN BOOLEAN ChangePassword,
    IN PSID Owner,
    IN PSID Group,
    IN PACL Sacl,
    IN PSAMP_OBJECT Context OPTIONAL,
    PSECURITY_DESCRIPTOR * Nt5Sd,
    PULONG Nt5SdLength
    );

NTSTATUS
SampGetDefaultSecurityDescriptorForClass(
    ULONG   DsClassId,
    PULONG  SecurityDescriptorLength,
    BOOLEAN TrustedClient,
    PSECURITY_DESCRIPTOR    *SecurityDescriptor
    );

NTSTATUS
SampMakeNewSelfRelativeSecurityDescriptor(
    PSID    Owner,
    PSID    Group,
    PACL    Dacl,
    PACL    Sacl,
    PULONG  SecurityDescriptorLength,
    PSECURITY_DESCRIPTOR * SecurityDescriptor
    );


//
//
// Some easy to use routines for SD, ACL and ACE manipulation
//
//
//

PACL 
GetDacl(
    IN PSECURITY_DESCRIPTOR Sd
    );


PACL 
GetSacl(
    IN PSECURITY_DESCRIPTOR Sd
    );

PSID 
GetOwner(
     IN PSECURITY_DESCRIPTOR Sd
     );
                
PSID 
GetGroup(
     IN PSECURITY_DESCRIPTOR Sd
     );


ULONG 
GetAceCount(
    IN PACL Acl
    );

ACE * 
GetAcePrivate(
    IN PACL Acl,
    ULONG AceIndex
    );


ACCESS_MASK 
AccessMaskFromAce(
                IN ACE * Ace
                );


PSID SidFromAce(
        IN ACE * Ace
        );

BOOLEAN
IsAccessAllowedAce(
    ACE * Ace
    );


BOOLEAN
IsAccessAllowedObjectAce(
    ACE * Ace
    );


BOOLEAN
AdjustAclSize(PACL Acl);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\sdconvrt.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    sdconvrt.c

Abstract:

      This File contains Routines to convert between NT5 security descriptors as
      defined in Dsrights.doc and NT4 Sam Security Descriptors.


Author:

    Murli Satagopan ( MURLIS ) 27-September -1996

Environment:

    User Mode - Win32

Revision History:



--*/


//
// SYNOPSIS
//
//
//
//  ACCESS RIGHTS MAPPING TABLES:
//
//    The access right mapping table contains the equivalent, per property DS access right and
//    type guid for each access right. At startup a reverse mapping table is constructed. The
//    reverse mapping table list the set of SAM access rights for each DS access mask on a per
//    property set guid basis. Since 32 bits of the access mask will result in 4 billion entries
//    in the table we cannot build this straight away. The following logic is used to reduce the
//    size of the table . The standard rights portion is always associated with the Object Type
//    that we are accessing. ie in a access check we shall use the standard rights from the granted
//    access corresponding to the Object Type of the object itself. The remaining 16 bits are split
//    into two halves, one half for the lower 8 bits and one half for the higher 8 bits. A set of
//    SAM access mask is computed for each combination of 256 for each of the halves. When a real
//    16 bit access mask is given, the low combination is looked up, then the high cobination is
//    looked up and then ored together to form the combined access mask. This can be done, since
//    each SAM right is exactly one DS right on a property GUID.
//
//
//
// ACCESS  CHECKING
//
//    The way the access checking works is as follows:
//
//       We impersonate client, grab the token and do a AccessCheckByType Result List asking for maximum
//       allowed access. We pass in a objecttype list which contains an entry for each object type
//       encountered in the access rights mapping table for that object. The function returns the granted access
//       for each objectType GUID. We walk these granted access, lookup the reverse mapping table and
//       and compute the SAM access granted by virtue of the granted access on the object type GUID.
//       Once we get the computed SAM access mask, we compare it with the desired access mask, and then
//       pass or fail the access check.
//
//
//  NT4 SD to NT5 SD conversion
//
//      Here we try to distinguish standard patterns. For Domain, Server, the pattern is declared standard.
//      For Groups, ALiases we distinguish between Admin and Non Admin. For Users, Admin , Non Admin Change
//      Password and Non Admin Non Change Password. If we cannot distinguish, then we use a different algorithm
//      that proceeds as follows.
//
//          1. The Group , Owner and Sacl are copied as such. Conversion only affects the DACL
//          2. We walk the NT4 Dacl, Acl by Acl. As we walk we build a SID access mask table. The
//             The Sid access mask table contains one entry for each Sid in the NT4 Dacl and list
//             of DS Accesses that are allowed or denied for this Sid. This access list is maintained
//             as an array of access masks per ObjectType GUID for the appropriate SAM object.
//
//          3. Once the Sid access mask table is constructed then we walk this table and add Object
//             Aces to represent each of the permissions that were explicity denied or granted to
//             each Sid in the NT4 Dacl.
//
//  NT5 to NT4 SD Conversion
//
//      We get the reverse membership and check wether he is a member of Administrators Alias ( CliffV - what if
//      he is administrator by privilege ) . For users then check the the NT5 Security descriptor for password change
//      also. For Domain, Server, we straightaway build the default security descriptor.
//
//
//
//

#include <samsrvp.h>
#include <seopaque.h>
#include <ntrtl.h>
#include <ntseapi.h>
#include <ntsam.h>
#include <ntdsguid.h>
#include <mappings.h>
#include <dsevent.h>
#include <permit.h>
#include <dslayer.h>
#include <sdconvrt.h>
#include <dbgutilp.h>
#include <dsmember.h>
#include <malloc.h>
#include <attids.h>

//
// GUID on which unused SAM property rights map to. This guid is never present anywhere
// else, so such rights will never be granted/ denied.
//

const GUID GUID_FOR_UNUSED_SAM_RIGHTS={0x7ed84960,0xad10,0x11d0,0x8a,0x92,0x00,0xaa,0x00,0x6e,0x05,0x29};

//
// TABLES  -----------------------------------------------------------------------
//


//
//
// ACE tables list the Aces in Dacls to be used for Default Sds for NT5 SAM objects
//
//

ACE_TABLE ServerAceTable[] =
{
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },

    {
        ACCESS_ALLOWED_ACE_TYPE,
        WORLD_SID,
        GENERIC_READ|GENERIC_EXECUTE,
        FALSE,
        NULL,
        NULL
    }
};

ACE_TABLE DomainAceTable[] =

{
    {
        ACCESS_ALLOWED_ACE_TYPE,
        WORLD_SID,
        RIGHT_DS_READ_PROPERTY|RIGHT_DS_LIST_CONTENTS,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        GENERIC_READ,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ACCOUNT_OPERATOR_SID,
        GENERIC_READ|GENERIC_EXECUTE|RIGHT_DS_CREATE_CHILD|RIGHT_DS_DELETE_CHILD,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    }
};


ACE_TABLE GroupAceTable[] =
{
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY | RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_SendTo,
        NULL
    },

    {
        ACCESS_ALLOWED_ACE_TYPE,
        ACCOUNT_OPERATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },

    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },

    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        GENERIC_READ|RIGHT_DS_WRITE_PROPERTY_EXTENDED,
        FALSE,
        &GUID_A_MEMBER,
        NULL
    }
};

ACE_TABLE GroupAdminAceTable[] =
{
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY | RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_SendTo,
        NULL
    },

    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },

    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        GENERIC_READ|RIGHT_DS_WRITE_PROPERTY_EXTENDED,
        FALSE,
        &GUID_A_MEMBER,
        NULL
    }
};




ACE_TABLE UserAceTable[] =
{

    //
    // Change password right needs to be given
    // to world, because when the user logs on
    // for the first time, and must change password
    // is set to true, at that point there is no
    // token, and the user is not yet authenticated.
    //
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        WORLD_SID,
        RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY | RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ACCOUNT_OPERATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    }
};

ACE_TABLE UserAdminAceTable[] =
{


    //
    // Change password right needs to be given
    // to world, because when the user logs on
    // for the first time, and must change password
    // is set to true, at that point there is no
    // token, and the user is not yet authenticated.
    //
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        WORLD_SID,
        RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY | RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        GENERIC_WRITE,
        FALSE,
        &GUID_PS_MEMBERSHIP,
        NULL
    },

    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_READ_PROPERTY | RIGHT_DS_WRITE_PROPERTY | RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    }
};


ACE_TABLE UserNoPwdAceTable[] =
{
    {
        ACCESS_DENIED_OBJECT_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_DENIED_OBJECT_ACE_TYPE,
        WORLD_SID,
        RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_OBJECT_ACE_TYPE,
        WORLD_SID,
        RIGHT_DS_CONTROL_ACCESS,
        FALSE,
        &GUID_CONTROL_UserChangePassword,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        AUTHENTICATED_USERS_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ACCOUNT_OPERATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        ADMINISTRATOR_SID,
        GENERIC_ALL,
        FALSE,
        NULL,
        NULL
    },
    {
        ACCESS_ALLOWED_ACE_TYPE,
        PRINCIPAL_SELF_SID,
        RIGHT_DS_READ_PROPERTY,
        FALSE,
        NULL,
        NULL
    }
};


//------------------------------------------------------
//
//
//    Access Right Mapping Tables and object type lists
//
//            These Table maps the DownLevel SAM
//            access rights to those of DS. The object type list
//            arrays consist of the object type guids that are
//            referenced in the Access Rights Mapping Tables and
//            are also ordered so that they can be directly passed
//            into the AccessCheckByTypeResultList function. Further
//            the object type list index field in the Access RightMapping
//            table is set to the corresponding index in the
//            ObjectType list array. This is is used by security descriptor
//            conversion routines to easily find the corresponding object type
//            in the Object Type List
//
//            In the tables the Object Class GUID is the object class of the
//            base class. Routines are supposed to fixup the Object Class by
//            querying the actual object's class GUID from the DS schema cache
//
//


//
//  Server Object , Access Rights Mapping Table
//

OBJECT_TYPE_LIST  ServerObjectTypeList[]=
{
    {ACCESS_OBJECT_GUID,0, (GUID *) &GUID_C_SAM_SERVER}
};

ACCESSRIGHT_MAPPING_TABLE  ServerAccessRightMappingTable[] =
{
    {
        SAM_SERVER_CONNECT,
        RIGHT_DS_READ_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    },

    {
        SAM_SERVER_SHUTDOWN,
        RIGHT_DS_WRITE_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    },

    {
        SAM_SERVER_INITIALIZE,
        RIGHT_DS_WRITE_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    },

    {
        SAM_SERVER_CREATE_DOMAIN,
        RIGHT_DS_WRITE_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    },

    {
        SAM_SERVER_ENUMERATE_DOMAINS,
        RIGHT_DS_READ_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    },

    {
        SAM_SERVER_LOOKUP_DOMAIN,
        RIGHT_DS_READ_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_SAM_SERVER
    }
};


OBJECT_TYPE_LIST  DomainObjectTypeList[]=
{
    {ACCESS_OBJECT_GUID,0, (GUID *)&GUID_C_DOMAIN},
        {ACCESS_PROPERTY_SET_GUID,0, (GUID *)&GUID_PS_DOMAIN_PASSWORD},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_LOCK_OUT_OBSERVATION_WINDOW},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_LOCKOUT_DURATION},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_LOCKOUT_THRESHOLD},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_MAX_PWD_AGE},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_MIN_PWD_AGE},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_MIN_PWD_LENGTH},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_PWD_HISTORY_LENGTH},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_PWD_PROPERTIES},
        {ACCESS_PROPERTY_SET_GUID,0, (GUID *)&GUID_PS_DOMAIN_OTHER_PARAMETERS},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_SERVER_STATE},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_SERVER_ROLE},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_MODIFIED_COUNT},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_UAS_COMPAT},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_FORCE_LOGOFF},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_DOMAIN_REPLICA},
            {ACCESS_PROPERTY_GUID,0, (GUID *)&GUID_A_OEM_INFORMATION},
        {ACCESS_PROPERTY_SET_GUID,0, (GUID *)&GUID_CONTROL_DomainAdministerServer}
};

ACCESSRIGHT_MAPPING_TABLE  DomainAccessRightMappingTable[] =
{
    {
        DOMAIN_READ_PASSWORD_PARAMETERS,
        RIGHT_DS_READ_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_DOMAIN_PASSWORD },

    {
        DOMAIN_WRITE_PASSWORD_PARAMS,
        RIGHT_DS_WRITE_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_DOMAIN_PASSWORD },

    {
        DOMAIN_READ_OTHER_PARAMETERS,
        RIGHT_DS_READ_PROPERTY,
        0,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_DOMAIN_OTHER_PARAMETERS },

    {
        DOMAIN_WRITE_OTHER_PARAMETERS,
        RIGHT_DS_WRITE_PROPERTY,
        0,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_DOMAIN_OTHER_PARAMETERS },

    {
        DOMAIN_CREATE_USER,
        RIGHT_DS_CREATE_CHILD,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN  },

    {
        DOMAIN_CREATE_GROUP,
        RIGHT_DS_CREATE_CHILD,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN  },

    {
        DOMAIN_CREATE_ALIAS,
        RIGHT_DS_CREATE_CHILD,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN   },

    {
        DOMAIN_GET_ALIAS_MEMBERSHIP,
        RIGHT_DS_READ_PROPERTY,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN   },

    {
        DOMAIN_LIST_ACCOUNTS,
        RIGHT_DS_LIST_CONTENTS,
        0,
        ACCESS_OBJECT_GUID,
        1,
        &GUID_C_DOMAIN   },

    {
        DOMAIN_LOOKUP,
        RIGHT_DS_LIST_CONTENTS,
        0,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_C_DOMAIN   },

    {
        DOMAIN_ADMINISTER_SERVER,
        RIGHT_DS_CONTROL_ACCESS,
        4,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_CONTROL_DomainAdministerServer }
};


OBJECT_TYPE_LIST  GroupObjectTypeList[]=
{
    {ACCESS_OBJECT_GUID,0 , (GUID *)&GUID_C_GROUP},
    {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_GENERAL_INFO},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_ADMIN_DESCRIPTION},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_CODE_PAGE},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_COUNTRY_CODE},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_OBJECT_SID},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_PRIMARY_GROUP_ID},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_SAM_ACCOUNT_NAME},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_USER_COMMENT},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_DISPLAY_NAME},
    {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_MEMBERSHIP},
        {ACCESS_PROPERTY_GUID,0,(GUID *)&GUID_A_MEMBER}
};


ACCESSRIGHT_MAPPING_TABLE GroupAccessRightMappingTable[] =
{
    {
        GROUP_READ_INFORMATION,
        RIGHT_DS_READ_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO  },

    {
        GROUP_WRITE_ACCOUNT,
        RIGHT_DS_WRITE_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },

    {
        GROUP_ADD_MEMBER,
        RIGHT_DS_WRITE_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER   },

    {
        GROUP_REMOVE_MEMBER,
        RIGHT_DS_WRITE_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER   },

    {
        GROUP_LIST_MEMBERS,
        RIGHT_DS_READ_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER  },
};


OBJECT_TYPE_LIST  AliasObjectTypeList[]=
{
    {ACCESS_OBJECT_GUID,0 , (GUID *)&GUID_C_GROUP},
        {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_GENERAL_INFO},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_ADMIN_DESCRIPTION},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_CODE_PAGE},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_COUNTRY_CODE},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_OBJECT_SID},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_PRIMARY_GROUP_ID},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_SAM_ACCOUNT_NAME},
            {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_USER_COMMENT},
        {ACCESS_PROPERTY_SET_GUID,0,(GUID *) &GUID_PS_MEMBERSHIP},
            {ACCESS_PROPERTY_GUID,0,(GUID *)&GUID_A_MEMBER}
};


ACCESSRIGHT_MAPPING_TABLE AliasAccessRightMappingTable[] =
{
    {
        ALIAS_READ_INFORMATION,
        RIGHT_DS_READ_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO  },

    {
        ALIAS_WRITE_ACCOUNT,
        RIGHT_DS_WRITE_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },
    {
        ALIAS_ADD_MEMBER,
        RIGHT_DS_WRITE_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER   },

    {
        ALIAS_REMOVE_MEMBER,
        RIGHT_DS_WRITE_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER   },

    {
        ALIAS_LIST_MEMBERS,
        RIGHT_DS_READ_PROPERTY,
        3,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_MEMBER  },
};

//
// User access right mapping table
//
//
//

OBJECT_TYPE_LIST  UserObjectTypeList[]=
{
    {ACCESS_OBJECT_GUID,0, (GUID *) &GUID_C_USER},

    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_PS_GENERAL_INFO},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_ADMIN_DESCRIPTION},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_CODE_PAGE},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_COUNTRY_CODE},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_OBJECT_SID},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_PRIMARY_GROUP_ID},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_SAM_ACCOUNT_NAME},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_USER_COMMENT},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_DISPLAY_NAME},

    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_PS_USER_ACCOUNT_RESTRICTIONS},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_ACCOUNT_EXPIRES},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_PWD_LAST_SET},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_USER_ACCOUNT_CONTROL},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_USER_PARAMETERS},

    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_PS_USER_LOGON},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_BAD_PWD_COUNT},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_HOME_DIRECTORY},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_HOME_DRIVE},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_LAST_LOGOFF},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_LAST_LOGON},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_LOGON_COUNT},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_LOGON_HOURS},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_LOGON_WORKSTATION},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_PROFILE_PATH},
        {ACCESS_PROPERTY_GUID,0,(GUID *) &GUID_A_SCRIPT_PATH},

    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_PS_MEMBERSHIP},
        {ACCESS_PROPERTY_GUID,      0,      (GUID *) &GUID_A_IS_MEMBER_OF_DL},
    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_CONTROL_UserChangePassword},
    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_CONTROL_UserForceChangePassword},
    {ACCESS_PROPERTY_SET_GUID,  0,      (GUID *) &GUID_FOR_UNUSED_SAM_RIGHTS}
};

//
// N.B. This table must be in the same order as the UserObjectTypeList
// table above
//
ULONG UserAttributeMappingTable[] = 
{
    0,  // object guid

    0,  // general info property set
    SAMP_USER_ADMIN_COMMENT,
    SAMP_FIXED_USER_CODEPAGE,
    SAMP_FIXED_USER_COUNTRY_CODE,
    SAMP_FIXED_USER_SID,
    SAMP_FIXED_USER_PRIMARY_GROUP_ID,
    SAMP_USER_ACCOUNT_NAME,
    SAMP_USER_USER_COMMENT,
    SAMP_USER_FULL_NAME,

    0, // Account restrictions property set
    SAMP_FIXED_USER_ACCOUNT_EXPIRES,
    SAMP_FIXED_USER_PWD_LAST_SET,
    SAMP_FIXED_USER_ACCOUNT_CONTROL,
    SAMP_USER_PARAMETERS,

    0, // User Logon property set
    SAMP_FIXED_USER_BAD_PWD_COUNT,
    SAMP_USER_HOME_DIRECTORY,
    SAMP_USER_HOME_DIRECTORY_DRIVE,
    SAMP_FIXED_USER_LAST_LOGOFF,
    SAMP_FIXED_USER_LAST_LOGON,
    SAMP_FIXED_USER_LOGON_COUNT,
    SAMP_USER_LOGON_HOURS,
    SAMP_USER_WORKSTATIONS,
    SAMP_USER_PROFILE_PATH,
    SAMP_USER_SCRIPT_PATH,

    // The rest are not related to attributes settable via
    // SamrSetInformationUser
    0,
    0,
    0,
    0,
    0
};

ACCESSRIGHT_MAPPING_TABLE UserAccessRightMappingTable[] =
{
    {
        USER_READ_GENERAL,
        RIGHT_DS_READ_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },

    {
        USER_READ_PREFERENCES,
        RIGHT_DS_READ_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },

    {
        USER_WRITE_PREFERENCES,
        RIGHT_DS_WRITE_PROPERTY,
        1,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },

    {
        USER_READ_LOGON,
        RIGHT_DS_READ_PROPERTY,
        3,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_USER_LOGON },

    {
        USER_READ_ACCOUNT,
        RIGHT_DS_READ_PROPERTY,
        2,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_USER_ACCOUNT_RESTRICTIONS },

    {
        USER_WRITE_ACCOUNT,
        RIGHT_DS_WRITE_PROPERTY,
        2,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_USER_LOGON },
    {
        USER_WRITE_ACCOUNT,
        RIGHT_DS_WRITE_PROPERTY,
        2,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_GENERAL_INFO },
    {
        USER_WRITE_ACCOUNT,
        RIGHT_DS_WRITE_PROPERTY,
        2,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_PS_USER_ACCOUNT_RESTRICTIONS },
    {
        USER_CHANGE_PASSWORD,
        RIGHT_DS_CONTROL_ACCESS,
        6,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_CONTROL_UserChangePassword },

    {
        USER_FORCE_PASSWORD_CHANGE,
        RIGHT_DS_CONTROL_ACCESS,
        7,
        ACCESS_PROPERTY_SET_GUID,
        1,
        &GUID_CONTROL_UserForceChangePassword },

    {
        USER_LIST_GROUPS,
        RIGHT_DS_READ_PROPERTY,
        5,
        ACCESS_PROPERTY_GUID,
        1,
        &GUID_A_IS_MEMBER_OF_DL },

    {
        USER_READ_GROUP_INFORMATION,
        RIGHT_DS_READ_PROPERTY,
        5,
        0,
        ACCESS_PROPERTY_SET_GUID,
        &GUID_FOR_UNUSED_SAM_RIGHTS },

    {
        USER_WRITE_GROUP_INFORMATION,
        RIGHT_DS_WRITE_PROPERTY,
        5,
        0,
        ACCESS_PROPERTY_SET_GUID,
        &GUID_FOR_UNUSED_SAM_RIGHTS },
};



ULONG   cServerObjectTypes = ARRAY_COUNT(ServerObjectTypeList);
ULONG   cDomainObjectTypes = ARRAY_COUNT(DomainObjectTypeList);
ULONG   cGroupObjectTypes  = ARRAY_COUNT(GroupObjectTypeList);
ULONG   cAliasObjectTypes  = ARRAY_COUNT(AliasObjectTypeList);
ULONG   cUserObjectTypes   = ARRAY_COUNT(UserObjectTypeList);

//
//  Reverse Mapping Table for each type
//
//

REVERSE_MAPPING_TABLE * ServerReverseMappingTable;
REVERSE_MAPPING_TABLE * DomainReverseMappingTable;
REVERSE_MAPPING_TABLE * GroupReverseMappingTable;
REVERSE_MAPPING_TABLE * AliasReverseMappingTable;
REVERSE_MAPPING_TABLE * UserReverseMappingTable;



GENERIC_MAPPING  DsGenericMap = DS_GENERIC_MAPPING;

//
// NT4 ACE tables describing the NT4 Dacls. All Aces
// in NT4 Dacls are access Allowed Aces.
//
//
NT4_ACE_TABLE NT4GroupNormalTable[] =
{
    { WORLD_SID, GROUP_READ|GROUP_EXECUTE },
    { ADMINISTRATOR_SID, GROUP_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, GROUP_ALL_ACCESS }
};

NT4_ACE_TABLE NT4GroupAdminTable[] =
{
    { WORLD_SID, GROUP_READ|GROUP_EXECUTE },
    { ADMINISTRATOR_SID, GROUP_ALL_ACCESS }
};

NT4_ACE_TABLE NT4AliasNormalTable[] =
{
    { WORLD_SID, ALIAS_READ|ALIAS_EXECUTE },
    { ADMINISTRATOR_SID, ALIAS_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, ALIAS_ALL_ACCESS }
};

NT4_ACE_TABLE NT4AliasAdminTable[] =
{
    { WORLD_SID, ALIAS_READ|ALIAS_EXECUTE },
    { ADMINISTRATOR_SID, ALIAS_ALL_ACCESS }
};

//
// Note the Principal Self Sid is used in here to
// denote that the User's Sid itself. NT4 systems do
// not employ the principal self Sid. The match routines
// are however designed to match the principal Self Sid to
// any Sid in the account domain.
//

NT4_ACE_TABLE NT4UserNormalTable[] =
{
    { WORLD_SID, USER_READ|USER_EXECUTE},
    { ADMINISTRATOR_SID, USER_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, USER_ALL_ACCESS },
    { PRINCIPAL_SELF_SID,USER_WRITE}
};


NT4_ACE_TABLE NT4UserNoChangePwdTable[] =
{
    { WORLD_SID, (USER_READ|USER_EXECUTE) &(~(USER_CHANGE_PASSWORD)) },
    { ADMINISTRATOR_SID, USER_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, USER_ALL_ACCESS },
    { PRINCIPAL_SELF_SID, (USER_WRITE)&(~(USER_CHANGE_PASSWORD)) }
};

NT4_ACE_TABLE NT4UserNoChangePwdTable2[] =
{
    { WORLD_SID, (USER_READ|USER_EXECUTE) &(~(USER_CHANGE_PASSWORD)) },
    { ADMINISTRATOR_SID, USER_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, USER_ALL_ACCESS }
};

NT4_ACE_TABLE NT4UserAdminTable[] =
{
    { WORLD_SID, USER_READ|USER_EXECUTE },
    { ADMINISTRATOR_SID, USER_ALL_ACCESS },
    { PRINCIPAL_SELF_SID, USER_WRITE}
};

NT4_ACE_TABLE NT4UserRestrictedAccessTable[] =
{
    { WORLD_SID, USER_READ|USER_EXECUTE},
    { PRINCIPAL_SELF_SID,USER_WRITE|DELETE|USER_FORCE_PASSWORD_CHANGE},
    { ADMINISTRATOR_SID, USER_ALL_ACCESS },
    { ACCOUNT_OPERATOR_SID, USER_ALL_ACCESS }

};



//----------------------------------------------------------------------------------

//
//
// Function prototype declarations
//
//
//
//
//

NTSTATUS
SampComputeReverseAccessRights(
  ACCESSRIGHT_MAPPING_TABLE  * MappingTable,
  ULONG cEntriesInMappingTable,
  POBJECT_TYPE_LIST  ObjectTypeList,
  ULONG cObjectTypes,
  REVERSE_MAPPING_TABLE ** ReverseMappingTable
  );


NTSTATUS
SampRecognizeStandardNt4Sd(
    IN PVOID   Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG DsClassId,
    IN PSAMP_OBJECT Context OPTIONAL,
    OUT BOOLEAN *ChangePassword,
    OUT BOOLEAN *Admin,
    OUT PVOID * Nt5Sd
    );

NTSTATUS
SampCheckIfAdmin(
    PSID SidOfPrincipal,
    BOOLEAN * Admin
    );

NTSTATUS
SampCheckIfChangePasswordAllowed(
    PSECURITY_DESCRIPTOR Nt5Sd,
    PSID  UserSid,
    BOOLEAN * ChangePasswordAllowed
    );

NTSTATUS
SampCreateNT5Dacl(
    ACE_TABLE * AceTable,
    ULONG       cEntries,
    IN  PSAMP_OBJECT    Context OPTIONAL,
    PACL        Dacl
    );

NTSTATUS
SampBuildNt4DomainProtection(
    PSECURITY_DESCRIPTOR * Nt4DomainDescriptor,
    PULONG  DescriptorLength
    );

NTSTATUS
SampBuildNt4ServerProtection(
    PSECURITY_DESCRIPTOR * Nt4ServerDescriptor,
    PULONG  DescriptorLength
    );

NTSTATUS
SampInitializeWellKnownSidsForDsUpgrade( VOID );

VOID
SampRecognizeNT4GroupDacl(
    PACL    NT4Dacl,
    BOOLEAN *Standard,
    BOOLEAN *Admin
    );

VOID
SampRecognizeNT4AliasDacl(
    PACL    NT4Dacl,
    BOOLEAN *Standard,
    BOOLEAN *Admin
    );

VOID
SampRecognizeNT4UserDacl(
    PACL    NT4Dacl,
    PSAMP_OBJECT Context,
    BOOLEAN *Standard,
    BOOLEAN *Admin,
    BOOLEAN *ChangePassword,
    OUT PSID * Owner
    );

BOOLEAN
SampMatchNT4Aces(
    NT4_ACE_TABLE *AceTable,
    ULONG         cEntriesInAceTable,
    PACL          NT4Dacl
    );

NTSTATUS
SampAddNT5ObjectAces(
    SID_ACCESS_MASK_TABLE *SidAccessMaskTable,
    ULONG   AceCount,
    POBJECT_TYPE_LIST   ObjectTypeList,
    ULONG   cObjectTypes,
    PSAMP_OBJECT    Context,
    PACL    NT5Dacl
    );



//----------------------------------------------------------------------------------
//
//  Initialization Routines
//
//
//


NTSTATUS
SampInitializeSdConversion()
/*
    This routine is intended to be called by Dsupgrad. It builds the well known Sid
    array as SamInitialize is not called in this process

    Parameters None

    Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY

*/
{
    NTSTATUS NtStatus;

    NtStatus = SampInitializeWellKnownSidsForDsUpgrade();
    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampInitializeAccessRightsTable();
    }

    return NtStatus;
}


NTSTATUS
SampInitializeAccessRightsTable()
/*++
    Routine Description

          This does the following

            1. Initializes the Reverse Mapping Table, which is used to
               perform fast access checks.
            2. Initializes the DS generic Map

    Parameters

          None

    Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    // Initialize the ACL conversion cache
    //

    NtStatus = SampInitializeAclConversionCache();

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    //
    // Compute the Reverse access rights for each object type.
    //

    NtStatus = SampComputeReverseAccessRights(
                    ServerAccessRightMappingTable,
                    ARRAY_COUNT(ServerAccessRightMappingTable),
                    ServerObjectTypeList,
                    cServerObjectTypes,
                    &ServerReverseMappingTable
                    );
    if (!NT_SUCCESS(NtStatus))
        goto Error;


    NtStatus = SampComputeReverseAccessRights(
                    DomainAccessRightMappingTable,
                    ARRAY_COUNT(DomainAccessRightMappingTable),
                    DomainObjectTypeList,
                    cDomainObjectTypes,
                    &DomainReverseMappingTable
                    );
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    NtStatus = SampComputeReverseAccessRights(
                    GroupAccessRightMappingTable,
                    ARRAY_COUNT(GroupAccessRightMappingTable),
                    GroupObjectTypeList,
                    cGroupObjectTypes,
                    &GroupReverseMappingTable
                    );
    if (!NT_SUCCESS(NtStatus))
        goto Error;

     NtStatus = SampComputeReverseAccessRights(
                    AliasAccessRightMappingTable,
                    ARRAY_COUNT(AliasAccessRightMappingTable),
                    AliasObjectTypeList,
                    cAliasObjectTypes,
                    &AliasReverseMappingTable
                    );
    if (!NT_SUCCESS(NtStatus))
        goto Error;


    NtStatus = SampComputeReverseAccessRights(
                    UserAccessRightMappingTable,
                    ARRAY_COUNT(UserAccessRightMappingTable),
                    UserObjectTypeList,
                    cUserObjectTypes,
                    &UserReverseMappingTable
                    );

Error:

    return NtStatus;

}


NTSTATUS
SampComputeReverseAccessRights(
  ACCESSRIGHT_MAPPING_TABLE  * MappingTable,
  ULONG cEntriesInMappingTable,
  POBJECT_TYPE_LIST  ObjectTypeList,
  ULONG cObjectTypes,
  REVERSE_MAPPING_TABLE ** ReverseMappingTable
  )
  /*++

  Routine  Description:

        This routine computes the reverse mapping table and an
        object type list given acces rights table. The entries in the reverse
        mapping table are in the same order as in the object type list.

        The reverse Mapping Table consists of one Entry for Each Object Type
        GUID in the Object Type List. Each Entry consists of the Sam Access Rights
        granted for 256 Low 8 bit combinations of DS access Mask and 256 hi 8 bit
        combinations of Ds Access Masks.

  Parameters:

        MappingTable -- Pointer to the access right mapping table
        cEntriesInMappingTable -- No of entries in the mapping table
        ObjectTypeList         -- The Object type list ( list of GUIDS representing the
                                  SAM classes or properties that we are intereseted in ).
        cObjectTypes           -- No of entries in the object type list
        ReverseMappingTable    -- Reverse Mapping table that is computed

  Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG i,j;
    ULONG DsAccessMask;


    *ReverseMappingTable = RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            cObjectTypes * sizeof(REVERSE_MAPPING_TABLE)
                            );

    if (NULL==*ReverseMappingTable)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlZeroMemory(*ReverseMappingTable,
                   cObjectTypes * sizeof(REVERSE_MAPPING_TABLE)
                   );

    //
    // For Each Guid in the object type list
    //

    for (i=0;i<cObjectTypes;i++)
    {

        //
        // For each access Ds Access Mask that we may supply for that GUID
        //

        for (DsAccessMask=0;DsAccessMask<256;DsAccessMask++)
        {

            //
            // Go through the mapping table and match by Guid
            // Note we consider only an 8 bit mask at a time as we divide the 16 specific
            // rights into 2 groups of 8. For each of the 256 combinations in each,
            // we will compute the SAM access rights corresponding to them. This way
            // we will have 2 sets of SAM access rights, one corresponding to the
            // lo 8 bit combinations, and one to the hi 8 bit combinations. The
            // assumption being made in here is that each SAM access right is a
            // combination of ds access rights in only one 8 bit half, on some
            // object type . This assumption is very much valid today,
            // as each SAM right is infact a single Ds right, on some object type. Since we
            // should not be defining new NT4 SAM access rights, we should be covered
            // for the future.
            //


            for (j=0;j<cEntriesInMappingTable;j++)
            {
                if (memcmp(ObjectTypeList[i].ObjectType,
                          MappingTable[j].DsGuid,
                          sizeof(GUID))==0)
                {
                    //
                    // if GUID Matched, then check wether the Ds access mask supplied
                    // in the mapping table satisfies the access Mask
                    //

                    if ((MappingTable[j].DsAccessMask)==(DsAccessMask &
                            MappingTable[j].DsAccessMask))
                    {
                        //
                        // This Mask grants the Required Access. So add the Sam
                        // access right defined in the mapping table to this combination
                        // of guid and access mask. Remember i indexes over the Guids,
                        // in the object type list and DsAccessMask indexes over the
                        // DS access mask.

                        (*ReverseMappingTable)[i].SamSpecificRightsLo[DsAccessMask]
                            |=MappingTable[j].SamAccessRight;
                    }

                    //
                    // Do the Same for the next 8 bits
                    //
                    //

                    if ((MappingTable[j].DsAccessMask)==((DsAccessMask*256) &
                            MappingTable[j].DsAccessMask))
                    {
                        //
                        // This Mask grants the Required Access. So add the Sam
                        // access right defined in the mapping table to this combination
                        // of guid and access mask. Remember i indexes over the Guids,
                        // in the object type list and DsAccessMask indexes over the
                        // DS access mask.

                        (*ReverseMappingTable)[i].SamSpecificRightsHi[DsAccessMask]
                            |=MappingTable[j].SamAccessRight;
                    }


                }
            }
        }
    }

Error:

    if (!NT_SUCCESS(NtStatus))
    {

        if (*ReverseMappingTable)
        {
            RtlFreeHeap(RtlProcessHeap(),0,*ReverseMappingTable);
            *ReverseMappingTable = NULL;
        }
    }


    return NtStatus;
}


//------------------------------------------------------------------------------------
//
//
//  A Set of private wrappers for some of the comonly called RTl functions
//  which make coding a little easier as well as more readable. The functions
//  are self explanatory. At some point in time if performance is a concern
//  then these should be replaced by macros.
//
//
//


PACL GetDacl(
    IN PSECURITY_DESCRIPTOR Sd
    )
{
    BOOL     Status;
    PACL     Dacl = NULL;
    PACL     DaclToReturn = NULL;
    BOOL     DaclPresent;
    BOOL     DaclDefaulted;

    Status = GetSecurityDescriptorDacl(
                    Sd,
                    &DaclPresent,
                    &Dacl,
                    &DaclDefaulted
                    );
    if ((Status)
        && DaclPresent
        && !DaclDefaulted)
    {
        DaclToReturn = Dacl;
    }

    return DaclToReturn;

}

PACL GetSacl(
    IN PSECURITY_DESCRIPTOR Sd
    )
{
    BOOL     Status;
    PACL     Sacl = NULL;
    PACL     SaclToReturn = NULL;
    BOOL     SaclPresent;
    BOOL     SaclDefaulted;

    Status = GetSecurityDescriptorSacl(
                    Sd,
                    &SaclPresent,
                    &Sacl,
                    &SaclDefaulted
                    );
    if ((Status)
        && SaclPresent
        && !SaclDefaulted)
    {
        SaclToReturn = Sacl;
    }

    return SaclToReturn;

}

PSID GetOwner(
     IN PSECURITY_DESCRIPTOR Sd
     )
{
    BOOL     Status;
    PSID     OwnerToReturn = NULL;
    PSID     Owner;
    BOOL     OwnerDefaulted;

    Status = GetSecurityDescriptorOwner(
                    Sd,
                    &Owner,
                    &OwnerDefaulted
                    );
    if (Status)
    {
        OwnerToReturn = Owner;
    }

    return OwnerToReturn;
}

PSID GetGroup(
     IN PSECURITY_DESCRIPTOR Sd
     )
{
    BOOL     Status;
    PSID     GroupToReturn = NULL;
    PSID     Group;
    BOOL     GroupDefaulted;

    Status = GetSecurityDescriptorGroup(
                    Sd,
                    &Group,
                    &GroupDefaulted
                    );
    if (Status)
    {
        GroupToReturn = Group;
    }

    return GroupToReturn;
}


ULONG GetAceCount(
    IN PACL Acl
    )
{
    ULONG   AceCount = 0;


    AceCount = Acl->AceCount;

    return AceCount;
}


ACE * GetAcePrivate(
    IN PACL Acl,
    ULONG AceIndex
    )
{
    BOOL Status;
    ACE * Ace = NULL;

    Status = GetAce(
                 Acl,
                 AceIndex,
                 &Ace
                 );
    if (!Status)
        Ace = NULL;

    return Ace;
}

ACCESS_MASK AccessMaskFromAce(
                IN ACE * Ace
                )
{
    ACE_HEADER * AceHeader = (ACE_HEADER *) Ace;
    ULONG      Mask = 0;

    switch(AceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        Mask =
           ((ACCESS_ALLOWED_ACE *) Ace)->Mask;
        break;

    case ACCESS_DENIED_ACE_TYPE:
        Mask =
           ((ACCESS_DENIED_ACE *) Ace)->Mask;
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        Mask =
           ((SYSTEM_AUDIT_ACE *) Ace)->Mask;
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        Mask =
           ((SYSTEM_ALARM_ACE *) Ace)->Mask;
        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        Mask =
           ((COMPOUND_ACCESS_ALLOWED_ACE *) Ace)->Mask;
        break;


    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        Mask =
           ((ACCESS_ALLOWED_OBJECT_ACE *) Ace)->Mask;
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        Mask =
           ((ACCESS_DENIED_OBJECT_ACE *) Ace)->Mask;
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        Mask =
           ((SYSTEM_AUDIT_OBJECT_ACE *) Ace)->Mask;
        break;

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        Mask =
           ((SYSTEM_ALARM_OBJECT_ACE *) Ace)->Mask;
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    return Mask;

}

PSID SidFromAce(
        IN ACE * Ace
        )
{
    ACE_HEADER * AceHeader = (ACE_HEADER *) Ace;
    PSID      SidStart = NULL;

    switch(AceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        SidStart =
           &(((ACCESS_ALLOWED_ACE *) Ace)->SidStart);
        break;

    case ACCESS_DENIED_ACE_TYPE:
        SidStart =
           &(((ACCESS_DENIED_ACE *) Ace)->SidStart);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        SidStart =
           &(((SYSTEM_AUDIT_ACE *) Ace)->SidStart);
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        SidStart =
           &(((SYSTEM_ALARM_ACE *) Ace)->SidStart);
        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        SidStart =
           &(((COMPOUND_ACCESS_ALLOWED_ACE *) Ace)->SidStart);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        SidStart =
           RtlObjectAceSid(Ace);
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:
        SidStart =
           RtlObjectAceSid(Ace);
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        SidStart =
           RtlObjectAceSid(Ace);
        break;

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        SidStart =
           RtlObjectAceSid(Ace);
        break;

    default:
        ASSERT(FALSE);
        break;
    }

    return SidStart;

}

BOOLEAN
IsAccessAllowedAce(
    ACE * Ace
    )
{
    return ( (ACCESS_ALLOWED_ACE_TYPE)==(((ACE_HEADER *) Ace)->AceType));
}

BOOLEAN
IsAccessDeniedAce(
    ACE * Ace
    )
{
    return ( (ACCESS_DENIED_ACE_TYPE)==(((ACE_HEADER *) Ace)->AceType));
}

BOOLEAN
IsAccessAllowedObjectAce(
    ACE * Ace
    )
{
    return ( (ACCESS_ALLOWED_OBJECT_ACE_TYPE)==(((ACE_HEADER *) Ace)->AceType));
}

BOOLEAN
IsAccessDeniedObjectAce(
    ACE * Ace
    )
{
    return ( (ACCESS_DENIED_OBJECT_ACE_TYPE)==(((ACE_HEADER *) Ace)->AceType));
}




BOOLEAN
AdjustAclSize(PACL Acl)
{
    ULONG_PTR AclStart;
    ULONG_PTR AclEnd;
    BOOLEAN ReturnStatus = FALSE;
    ACE * Ace;

    if ((FindFirstFreeAce(Acl,&Ace))
            && (NULL!=Ace))
    {
        AclStart = (ULONG_PTR)Acl;
        AclEnd   = (ULONG_PTR)Ace;

        Acl->AclSize = (USHORT)(AclEnd-AclStart);
        ReturnStatus = TRUE;
    }

    return ReturnStatus;
}



VOID DumpAce(ACE * Ace)
{
    ACE_HEADER * AceHeader = (ACE_HEADER *) Ace;
    PSID         Sid       = SidFromAce(Ace);
    GUID         *ObjectType;

    if (NULL == Ace)
    {
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Invalid Ace (NULL)\n"));
        return;
    }

    switch(AceHeader->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Allowed Ace\n"));
        break;

    case ACCESS_DENIED_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Denied Ace\n"));
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t System Audit Ace\n"));
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t System Alarm Ace\n"));
        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Allowed Compound Ace\n"));
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Allowed Object Ace\n"));
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Object Type ="));
        ObjectType = &(((ACCESS_ALLOWED_OBJECT_ACE *) Ace)->ObjectType);
        SampDumpBinaryData((UCHAR *)ObjectType,sizeof(GUID));
        break;

    case ACCESS_DENIED_OBJECT_ACE_TYPE:

        SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Denied Object Ace\n"));
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Object Type ="));
        ObjectType = &(((ACCESS_DENIED_OBJECT_ACE *) Ace)->ObjectType);
        SampDumpBinaryData((UCHAR *)ObjectType,sizeof(GUID));
        break;

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

        SampDiagPrint(SD_DUMP,("[SAMSS] \t System Audit Object Ace\n"));
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Object Type ="));
        ObjectType = &(((SYSTEM_AUDIT_OBJECT_ACE *) Ace)->ObjectType);
        SampDumpBinaryData((UCHAR *)ObjectType,sizeof(GUID));
        break;

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:

        SampDiagPrint(SD_DUMP,("[SAMSS] \t System Alarm Object Ace\n"));
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Object Type ="));
        ObjectType = &(((SYSTEM_ALARM_OBJECT_ACE *) Ace)->ObjectType);
        SampDumpBinaryData((UCHAR *)ObjectType,sizeof(GUID));
        break;

    default:
        ASSERT(FALSE);
        SampDiagPrint(SD_DUMP,("[SAMSS] \t Unknown Ace Type\n"));
        return;
    }

    SampDiagPrint(SD_DUMP,("[SAMSS] \t Access Mask = %x\n",AccessMaskFromAce(Ace)));
    SampDiagPrint(SD_DUMP,("[SAMSS] \t Sid ="));
    SampDumpBinaryData(Sid,RtlLengthSid(Sid));
    SampDiagPrint(SD_DUMP,("[SAMSS]\n"));

}

VOID DumpSecurityDescriptor(
    PSECURITY_DESCRIPTOR Sd
    )
{
    ULONG Length;
    ULONG i;

    if (NULL!=Sd)
    {
        PSID  Owner = GetOwner(Sd);
        PSID  Group = GetGroup(Sd);
        PACL  Dacl  = GetDacl(Sd);
        PACL  Sacl  = GetSacl(Sd);


        if (NULL!=Owner)
        {
            Length = RtlLengthSid(Owner);
            SampDiagPrint(SD_DUMP,("[SAMSS] Owner = "));
            SampDumpBinaryData((BYTE *)Owner,Length);
        }
        else
        {
            SampDiagPrint(SD_DUMP,("[SAMSS] Owner = NULL\n"));
        }

        if (NULL!=Group)
        {
            Length = RtlLengthSid(Group);
            SampDiagPrint(SD_DUMP,("[SAMSS] Group = "));
            SampDumpBinaryData((BYTE *)Group,Length);
        }
        else
        {
            SampDiagPrint(SD_DUMP,("[SAMSS] Group = NULL\n"));
        }


         if (NULL!=Dacl)
        {
            ULONG   AceCount;

            SampDiagPrint(SD_DUMP,("[SAMSS] Dacl=\n"));

            AceCount = GetAceCount(Dacl);
            for (i=0;i<AceCount;i++)
            {
                ACE * Ace;

                SampDiagPrint(SD_DUMP,("[SAMSS] ACE %d\n",i));
                Ace = GetAcePrivate(Dacl,i);
                if (Ace)
                    DumpAce(Ace);
            }
        }
        else
        {
            SampDiagPrint(SD_DUMP,("[SAMSS] Dacl = NULL\n"));
        }


        if (NULL!=Sacl)
        {

            ULONG   AceCount;

            SampDiagPrint(SD_DUMP,("[SAMSS] Sacl=\n\n"));

            AceCount = GetAceCount(Sacl);
            for (i=0;i<AceCount;i++)
            {
                ACE * Ace;

                SampDiagPrint(SD_DUMP,("[SAMSS] ACE %d\n",i));
                Ace = GetAcePrivate(Sacl,i);
                if (Ace)
                    DumpAce(Ace);
            }

        }
        else
        {
            SampDiagPrint(SD_DUMP,("[SAMSS] Sacl = NULL\n"));
        }

    }
    else
     SampDiagPrint(SD_DUMP,("[SAMSS] Security Descriptor = NULL\n"));


}


//-------------------------------------------------------------------------------------------------------
//
//
//  ACCESS Check Functions
//
//

ULONG
DsToSamAccessMask(
    SAMP_OBJECT_TYPE ObjectType,
    ULONG DsAccessMask
    )
/*

  Routine Description:

        Given a Ds Access Mask on an Access Allowed ACE, treat it as
        access allowed on all object types and return the appropriate
        SAM access mask . This function is not currently used today
        but can be used tp validate the reverse mapping table

  Parameters
        DsAccessMask

  Return Value

      SAM access mask

*/
{

    ACCESSRIGHT_MAPPING_TABLE  * MappingTable;
    ULONG               cEntriesInMappingTable;
    ULONG               Index;
    ULONG               SamAccessRight = 0;


    //
    // Choose the Appropriate Mapping Table and Object Type List
    //

    switch(ObjectType)
    {
    case SampDomainObjectType:
        MappingTable =  DomainAccessRightMappingTable;
        cEntriesInMappingTable = ARRAY_COUNT(DomainAccessRightMappingTable);
        break;
    case SampGroupObjectType:
        MappingTable = GroupAccessRightMappingTable;
        cEntriesInMappingTable = ARRAY_COUNT(GroupAccessRightMappingTable);
        break;
    case SampAliasObjectType:
        MappingTable = AliasAccessRightMappingTable;
        cEntriesInMappingTable = ARRAY_COUNT(AliasAccessRightMappingTable);
        break;
    case SampUserObjectType:
        MappingTable = UserAccessRightMappingTable;
        cEntriesInMappingTable = ARRAY_COUNT(UserAccessRightMappingTable);
        break;
    default:
        goto Error;
    }

    //
    // Walk through the mapping table and for each entry that satisfies the
    // given mask, add the correspond Sam access right
    //

    for (Index=0;Index<cEntriesInMappingTable;Index++)
    {
        if ((MappingTable[Index].DsAccessMask & DsAccessMask)
            == (MappingTable[Index].DsAccessMask))
        {
            //
            // Mask is satisfied, add the right
            //

            SamAccessRight |= MappingTable[Index].SamAccessRight;
        }
    }

Error:

    return SamAccessRight;
}





NTSTATUS
SampDoNt5SdBasedAccessCheck(
    IN  PSAMP_OBJECT        Context,
    IN  PVOID               Nt5Sd,
    IN  PSID                PrincipalSelfSid,
    IN  SAMP_OBJECT_TYPE    ObjectType,
    IN  ULONG               Nt4SamAccessMask,
    IN  BOOLEAN             ObjectCreation,
    IN  GENERIC_MAPPING     *Nt4SamGenericMapping,
    IN  HANDLE              ClientToken,
    OUT ACCESS_MASK         *GrantedAccess,
    OUT PRTL_BITMAP         WriteGrantedAccessAttributes,
    OUT NTSTATUS            *AccessCheckStatus
    )
/*++
    Routine Description

        Given an NT5 Security Descriptor and an NT4 SAM access Mask,
        this does an access check using the Nt5 Access check functions,
        after mapping the NT4 SAM access Mask

    Parameters:

        Context           -- Open Handle to the object that is being access checked.
                            The access Check routine may derive any additional information
                            about the object through the context.
        Nt5Sd             -- NT 5 Security Descriptor
        PrincipalSelfSid  -- For security principals, the Sid of the object
                            that is being access checked
        ObjectType        -- SAM Object Type
        Nt4SamAccessMask  -- This is the NT 4 SAM access Mask

        ObjectCreation    -- Indicates that the object is being created

        Nt4SamGenericMapping -- This is the NT4 SAM generic mapping structure

        ClientToken       -- Optional parameter for client token

        GrantedAccess     -- The granted access in terms of the NT4 SAM access mask is
                            given in here
        
                                    
        WriteGrantedAccessAttributes -- a bitmap of attributes that can be
                                        written
                                                                    
        AccessCheckStatus -- Returns the result of the Access Check

    Return Values

        STATUS_SUCCESS upon successful check
        STATUS_ACCESS_DENIED otherwise

--*/
{
    NTSTATUS    NtStatus;

    REVERSE_MAPPING_TABLE *ReverseMappingTable = NULL;
    POBJECT_TYPE_LIST      ObjectTypeList = NULL,
                           LocalObjectTypeList;


    ULONG                 cObjectTypes;
    ULONG                 Nt5DesiredAccess;
    ACCESS_MASK           GrantedAccesses[MAX_SCHEMA_GUIDS];
    NTSTATUS              AccessStatuses[MAX_SCHEMA_GUIDS];

    ACCESS_MASK           SamAccessMaskComputed=0;
    ACCESS_MASK           Nt4AccessMaskAsPassedIn = Nt4SamAccessMask;
    BOOLEAN               MaximumAllowedAskedFor = (BOOLEAN)((Nt4SamAccessMask & MAXIMUM_ALLOWED)!=0);
    ACCESS_MASK           MaximumAccessMask;
    NTSTATUS              ChkStatus = STATUS_SUCCESS;

    ULONG                 i;

    GUID                  ClassGuid;
    ULONG                 ClassGuidLength=sizeof(GUID);
    UNICODE_STRING        ObjectName;
    BOOLEAN               FreeObjectName = FALSE;

    BOOLEAN               fAtLeastOneAccessGranted = FALSE;
    BOOLEAN               ImpersonatingNullSession = FALSE;

    ULONG                 *AttributeMappingTable = NULL;

    SampDiagPrint(NT5_ACCESS_CHECKS,("[SAMSS] NT5 ACCESS CHECK ENTERED \n"));

    //
    // Initliaze the granted access
    //
    *GrantedAccess = 0;
    RtlClearAllBits(WriteGrantedAccessAttributes);


    //
    // Get a name for auditing
    //

    RtlZeroMemory(&ObjectName,sizeof(UNICODE_STRING));

    if (Context->ObjectNameInDs->NameLen>0)
    {
        ObjectName.Length = ObjectName.MaximumLength =
                      (USHORT) Context->ObjectNameInDs->NameLen;
        ObjectName.Buffer = Context->ObjectNameInDs->StringName;
    }
    else
    {
        //
        // If the name is not there at least the SID must be there
        //

        ASSERT(Context->ObjectNameInDs->SidLen >0);

        NtStatus = RtlConvertSidToUnicodeString(&ObjectName, (PSID)&(Context->ObjectNameInDs->Sid), TRUE);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        FreeObjectName = TRUE;
    }

    //
    // Get the self sid
    //

    if ((!ARGUMENT_PRESENT(PrincipalSelfSid)) &&
            (SampServerObjectType != ObjectType))
        {
            PrincipalSelfSid = SampDsGetObjectSid(Context->ObjectNameInDs);

            if (NULL == PrincipalSelfSid)
            {
                // Can't get SID for Security Principal. Set Error
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
        }

    //
    // Get the Appropriate MappingTable
    //

    switch(ObjectType)
    {
    case SampDomainObjectType:
        ObjectTypeList = DomainObjectTypeList;
        cObjectTypes = cDomainObjectTypes;
        ReverseMappingTable = DomainReverseMappingTable;
        break;
    case SampGroupObjectType:
        ObjectTypeList = GroupObjectTypeList;
        cObjectTypes = cGroupObjectTypes;
        ReverseMappingTable = GroupReverseMappingTable;
        break;
    case SampAliasObjectType:
        ObjectTypeList = AliasObjectTypeList;
        cObjectTypes = cAliasObjectTypes;
        ReverseMappingTable = AliasReverseMappingTable;
        break;
    case SampUserObjectType:
        ObjectTypeList = UserObjectTypeList;
        cObjectTypes = cUserObjectTypes;
        ReverseMappingTable = UserReverseMappingTable;
        AttributeMappingTable = UserAttributeMappingTable;
        break;
    case SampServerObjectType:
        ObjectTypeList = ServerObjectTypeList;
        cObjectTypes = cServerObjectTypes;
        ReverseMappingTable = ServerReverseMappingTable;
        break;
    default:
        ASSERT(FALSE && "Invalid Object Type Specified");
        NtStatus = STATUS_INTERNAL_ERROR;
        return NtStatus;
    }

   //
   //  Print out diagnostics if asked for regarding the Object Types and the
   //  security descriptor
   //

   SampDiagPrint(NT5_ACCESS_CHECKS,("[SAMSS]\tcObjectTypes=%x\n",cObjectTypes));

   IF_SAMP_GLOBAL(SD_DUMP)
       DumpSecurityDescriptor(Nt5Sd);


   //
   //  Make a local copy of the object type list
   //

   SAMP_ALLOCA(LocalObjectTypeList, cObjectTypes * sizeof(ObjectTypeList));
   if (NULL==LocalObjectTypeList)
   {
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
       goto Error;
   }

   RtlCopyMemory(
       LocalObjectTypeList,
       ObjectTypeList,
       cObjectTypes * sizeof(ObjectTypeList)
       );


   //
   // Fix up the Class of the object. It is important to note that the object class
   // guid for the ACCESS_OBJECT_GUID level is a constant GUID that represents the base
   // SAM class. We really have to fixup with the actual class guid of the object that
   // we are processing from the DS's schema cache.
   //

   NtStatus = SampGetClassAttribute(
                Context->DsClassId,
                ATT_SCHEMA_ID_GUID,
                &ClassGuidLength,
                &ClassGuid
                );
   if (!NT_SUCCESS(NtStatus))
   {
       goto Error;
   }

   ASSERT(ClassGuidLength == sizeof(GUID));

   LocalObjectTypeList[OBJECT_CLASS_GUID_INDEX].ObjectType = &ClassGuid;

   //
   // Ask for maximum available access
   //

   MaximumAccessMask = MAXIMUM_ALLOWED|(Nt4SamAccessMask & ACCESS_SYSTEM_SECURITY);

   RtlZeroMemory(AccessStatuses,cObjectTypes * sizeof(ULONG));
   RtlZeroMemory(GrantedAccesses,cObjectTypes * sizeof(ULONG));

   //
   // Impersonate the client
   //

   if (!ARGUMENT_PRESENT(ClientToken))
   {
       NtStatus = SampImpersonateClient(&ImpersonatingNullSession);
       if (!NT_SUCCESS(NtStatus))
           goto Error;
   }

   //
   // Allow a chance to break before the access check.
   //

   IF_SAMP_GLOBAL(BREAK_ON_CHECK)
       DebugBreak();

   //
   // Call the access check routine
   //

   if (ARGUMENT_PRESENT(ClientToken))
   {
       CHAR                  PrivilegeSetBuffer[256];
       PRIVILEGE_SET         *PrivilegeSet = (PRIVILEGE_SET *)PrivilegeSetBuffer;
       ULONG                 PrivilegeSetLength = sizeof(PrivilegeSetBuffer);


       RtlZeroMemory(PrivilegeSet,PrivilegeSetLength);

       ChkStatus =   NtAccessCheckByTypeResultList(
                        Nt5Sd,
                        PrincipalSelfSid,
                        ClientToken,
                        MaximumAccessMask,
                        ObjectTypeList,
                        cObjectTypes,
                        &DsGenericMap,
                        PrivilegeSet,
                        &PrivilegeSetLength,
                        GrantedAccesses,
                        AccessStatuses
                        );
   }
   else
   {
        ChkStatus =  NtAccessCheckByTypeResultListAndAuditAlarm(
                        &SampSamSubsystem,
                        (PVOID)Context,
                        &SampObjectInformation[ ObjectType ].ObjectTypeName,
                        &ObjectName,
                        Nt5Sd,
                        PrincipalSelfSid,
                        MaximumAccessMask,
                        AuditEventDirectoryServiceAccess,
                        0,
                        ObjectTypeList,
                        cObjectTypes,
                        &DsGenericMap,
                        ObjectCreation,
                        GrantedAccesses,
                        AccessStatuses,
                        &Context->AuditOnClose
                        );
   }


   //
   // Stop impersonating the client
   //

   if (!ARGUMENT_PRESENT(ClientToken))
   {
        SampRevertToSelf(ImpersonatingNullSession);
   }

   //
   // Use the Reverse MappingTable to compute the SAM access Mask
   //

   if (NT_SUCCESS(ChkStatus))
   {
       for(i=0;i<cObjectTypes;i++)
       {

           if ((AccessStatuses[i])==STATUS_SUCCESS)
           {

               ULONG RightsAdded=0;


               fAtLeastOneAccessGranted = TRUE;

               //
               // Lookup the Reverse Mapping Table to determine the SAM rights added from
               // the set of DS specific rights granted
               //

               //
               // Or in the SAM rights corresponding to Lower 8 bit half DS rights
               //

               RightsAdded |= (ULONG) ReverseMappingTable[i].SamSpecificRightsLo
                    [GrantedAccesses[i] & ((ULONG ) 0xFF)];


               //
               // Or in the SAM access rights corresponding Upper 8 bit half DS
               // rights
               //



               RightsAdded |= (ULONG) ReverseMappingTable[i].SamSpecificRightsHi
                    [(GrantedAccesses[i] & ((ULONG) 0xFF00))>>8];



               //
               // Always Grant DOMAIN_CREATE Access. The Creation code will let the DS
               // do the access check, so that appropriate container etc can be included
               // in the access check evaluation
               //

               if (SampDomainObjectType==ObjectType)
               {
                   RightsAdded |= DOMAIN_CREATE_USER
                                    |DOMAIN_CREATE_GROUP|DOMAIN_CREATE_ALIAS;
               }

               //
               // Add these rights to the SAM rights we are adding
               //
               //

               SamAccessMaskComputed |=RightsAdded;



               SampDiagPrint(NT5_ACCESS_CHECKS,
                   ("[SAMSS]\t\t GUID=%x-%x-%x-%x, GrantedAccess = %x,RightsAdded = %x\n",
                            ((ULONG *) ObjectTypeList[i].ObjectType)[0],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[1],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[2],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[3],
                            GrantedAccesses[i],
                            RightsAdded
                            ));
               //
               // OR in the Standard rights only for the case that represents the particular
               // object's Type. Since we build the type list we know guarentee the offset
               // of the appropriate Object type GUID for the class to be equal to the constant
               // be 0. OBJECT_CLASS_GUID_INDEX is defined to be 0

               if (i==OBJECT_CLASS_GUID_INDEX)
               {
                   ULONG StandardRightsAdded;

                   StandardRightsAdded =  (GrantedAccesses[i]) & (STANDARD_RIGHTS_ALL|
                                                ACCESS_SYSTEM_SECURITY);

                   SamAccessMaskComputed |= StandardRightsAdded;

                   SampDiagPrint(NT5_ACCESS_CHECKS,
                       ("[SAMSS] Object Class GUID, Standard Rights added are %x \n",
                            StandardRightsAdded));
               }

               //
               // On user objects check if we have access to user parameters. Save this
               // around to use it when querying user parms alone if did not have read
               // account but had this.
               //

               if ((SampUserObjectType==ObjectType)
                 && (ObjectTypeList[i].ObjectType == &GUID_A_USER_PARAMETERS))
               {
                    Context->TypeBody.User.UparmsInformationAccessible = TRUE;
               }


               //
               // Determine what attributes are writable if applicable
               //
               if (AttributeMappingTable) {
                   ASSERT(ObjectType == SampUserObjectType);
                   if (GrantedAccesses[i] & RIGHT_DS_WRITE_PROPERTY) {
                       SampSetAttributeAccess(ObjectType,
                                              AttributeMappingTable[i],
                                              WriteGrantedAccessAttributes);
                   }
               }
           }
           else
           {
               //
               // Ignore the access check if did'nt pass for that GUID
               // Print the failure message in case we want to debug
               //
               //

               SampDiagPrint(NT5_ACCESS_CHECKS,
                   ("[SAMSS]\t\t GUID=%x-%x-%x-%x FAILED Status = %x\n",
                            ((ULONG *) ObjectTypeList[i].ObjectType)[0],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[1],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[2],
                            ((ULONG *) ObjectTypeList[i].ObjectType)[3],
                            AccessStatuses[i]
                            ));
           }



       }


       //
       //  At this point we have the Passed in SAM access Mask and
       //  the available SAM rights as computed by the Access Check
       //  by type result list. 3 cases
       //      1. Client did not ask for maximum allowed bit
       //      2. Client asked for maximum allowed but also other access
       //      3. Client asked only for maximum allowed
       //


       //
       // Reset the Maximum allowed bit
       //

       Nt4SamAccessMask &= ~((ULONG) MAXIMUM_ALLOWED);

       //
       //  Use the SAM generic access Mask to compute the accesses required for each generic
       //  access bit.
       //


       RtlMapGenericMask(&Nt4SamAccessMask,Nt4SamGenericMapping);

       if (((SamAccessMaskComputed & Nt4SamAccessMask) != Nt4SamAccessMask)
        || !fAtLeastOneAccessGranted )
       {

           // Case 1 and Fail
           // Case 2 and Fail
           // Case 3 Never

           // Or if no accesses were granted at all

           //
           // The access is that is present is less than the access that is requested
           // FAIL the access Check

           *AccessCheckStatus = STATUS_ACCESS_DENIED;
           RtlClearAllBits(WriteGrantedAccessAttributes);

       }
       else
       {

           // Case 1 and Pass
           // Case 2 and Pass
           // Case 3 Always

           //
           // Pass the access check.
           //

           *AccessCheckStatus = STATUS_SUCCESS;
           if (MaximumAllowedAskedFor)
               *GrantedAccess = SamAccessMaskComputed;
           else
               *GrantedAccess = Nt4SamAccessMask;

       }
   }
   else
   {
       ULONG Status = GetLastError();
       SampDiagPrint(NT5_ACCESS_CHECKS,
         ("[SAMSS]\t\t AccessCheckAPI failed, Status = %x, cObjects = %x\n",
                Status,cObjectTypes));

       NtStatus = STATUS_ACCESS_DENIED;
       RtlClearAllBits(WriteGrantedAccessAttributes);
   }


   //
   // Print Message reagarding access check for Diagnostics of problems in
   // checked builds
   //

   SampDiagPrint(NT5_ACCESS_CHECKS,
     ("[SAMSS]: NT5 ACCESS CK FINISH: Status=%x,Granted=%x,Desired=%x,Computed=%x\n",
            *AccessCheckStatus,*GrantedAccess,Nt4SamAccessMask,
            SamAccessMaskComputed));

Error:

   if (FreeObjectName)
   {
       RtlFreeHeap(RtlProcessHeap(),0,ObjectName.Buffer);
   }

   return NtStatus;
}




//--------------------------------------------------------------------------------------------------------------
//
//        SECURITY Descriptor Convertion Functions
//
//
//




NTSTATUS
SampAddNT5ObjectAces(
    SID_ACCESS_MASK_TABLE *SidAccessMaskTable,
    ULONG   AceCount,
    POBJECT_TYPE_LIST   ObjectTypeList,
    ULONG   cObjectTypes,
    PSAMP_OBJECT    Context,
    PACL    NT5Dacl
    )
/*++

    Routine Description:

        This routines adds the appropriate ACE's to the Dacl specified in NT5Dacl,
        by using the information in the Sid Access Mask table

    Parameters:

        SidAccessMaskTable -- The Sid Access Mask Table
        AceCount           -- Count of Aces in the original NT4 Dacl that was used
                              to construct the Sid access Mask Table. This is used
                              as the maximum possible length for the Sid access mask
                              table.
        ObjectTypeList     -- The Object type list for the specified class
        Context            -- Optional parameter, gives an open context to the object.
                              Used to obtain the actual Class Id of the object.

        NT5Dacl            -- The Dacl to which the ACE's need to be added

    Return Values;

        STATUS_SUCCESS

--*/
{
    ULONG       i,j,k;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    GUID        ClassGuid;
    ULONG       ClassGuidLength=sizeof(GUID);
    ACCESS_MASK MappedAccessMask = GENERIC_ALL;

    //
    // Obtain the actual Class GUID of the object whose security descriptor is being
    // converted
    //

    if (ARGUMENT_PRESENT(Context))
    {
        NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        NtStatus = SampGetClassAttribute(
                Context->DsClassId,
                ATT_SCHEMA_ID_GUID,
                &ClassGuidLength,
                &ClassGuid
                );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        ASSERT(ClassGuidLength==sizeof(GUID));
    }


    //
    // Add Aces walking through the Sid Access Mask Table
    //

    for (i=0;i<AceCount;i++)
    {
        if (NULL!=SidAccessMaskTable[i].Sid)
        {
            //
            // Add Denied Aces for specific rights for this Sid
            //

            for (j=0;j<cObjectTypes;j++)
            {
                if (0!=SidAccessMaskTable[i].AccessDeniedMasks[j])
                {
                    GUID * ObjectTypeToUse;

                    //
                    // if a Context argument was specified then use the Class
                    // guid obtained from the schema cache for the ACCESS_OBJECT_GUID
                    // level. The GUID in the object type list actually represents the
                    // base class.
                    //

                    if ((ARGUMENT_PRESENT(Context))
                            && (ACCESS_OBJECT_GUID==ObjectTypeList[j].Level))
                    {
                        ObjectTypeToUse = &ClassGuid;
                    }
                    else
                    {
                        ObjectTypeToUse = ObjectTypeList[j].ObjectType;
                    }

                    //
                    //  Add an access denied ACE to the NT5 Dacl
                    //

                    if (!AddAccessDeniedObjectAce(
                            NT5Dacl,
                            ACL_REVISION_DS,
                            0,
                            SidAccessMaskTable[i].AccessDeniedMasks[j],
                            ObjectTypeToUse,
                            NULL,
                            SidAccessMaskTable[i].Sid
                            ))
                    {
                        NtStatus = STATUS_UNSUCCESSFUL;
                        goto Error;
                    }
                }
            }

            //
            // Add Denied Rights for standard rights for this Sid
            //

            if (0!=SidAccessMaskTable[i].StandardDeniedMask)
            {
                if (!AddAccessDeniedAce(
                        NT5Dacl,
                        ACL_REVISION_DS,
                        SidAccessMaskTable[i].StandardDeniedMask,
                        SidAccessMaskTable[i].Sid
                    ))
                {
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }
            }

            //
            // Add Allowed Aces for specific rights for this Sid
            //

            for (j=0;j<cObjectTypes;j++)
            {
                if (0!=SidAccessMaskTable[i].AccessAllowedMasks[j])
                {
                    GUID * ObjectTypeToUse;

                    //
                    // if a Context argument was specified then use the Class
                    // guid for the ACCESS_OBJECT_GUID level
                    //
                    if ((ARGUMENT_PRESENT(Context))
                            && (ACCESS_OBJECT_GUID==ObjectTypeList[j].Level))
                    {
                        ObjectTypeToUse = &ClassGuid;
                    }
                    else
                    {
                        ObjectTypeToUse = ObjectTypeList[j].ObjectType;
                    }

                    if (!AddAccessAllowedObjectAce(
                                    NT5Dacl,
                                    ACL_REVISION_DS,
                                    0,
                                    SidAccessMaskTable[i].AccessAllowedMasks[j],
                                    ObjectTypeToUse,
                                    NULL,
                                    SidAccessMaskTable[i].Sid
                                    ))
                    {
                        NtStatus = STATUS_UNSUCCESSFUL;
                        goto Error;
                    }
                }
            }

            //
            // Add Allowed Rights for standard rights for this Sid
            //

            if (0!=SidAccessMaskTable[i].StandardAllowedMask)
            {
                if (!AddAccessAllowedAce(
                        NT5Dacl,
                        ACL_REVISION_DS,
                        SidAccessMaskTable[i].StandardAllowedMask,
                        SidAccessMaskTable[i].Sid
                    ))
                {
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Error;
                }
            }

        }
    }



    //
    // No matter what Add an Ace that gives Administrators All Access
    // This is needed as the set of DS rights is a superset of the SAM
    // rights and Administrators need to have access to all "DS
    // aspects" of the object regardless of how the SAM rights are set.
    //

    RtlMapGenericMask(
        &(MappedAccessMask),
        &DsGenericMap
        );

    if (!AddAccessAllowedAce(
            NT5Dacl,
            ACL_REVISION_DS,
            MappedAccessMask,
            *ADMINISTRATOR_SID
            ))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Adjust the size of the ACL so that we consume less disk
    //

    if (!AdjustAclSize(NT5Dacl))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }



Error:

    return NtStatus;

}




NTSTATUS
SampConvertNt5SdToNt4SD(
    IN PVOID Nt5Sd,
    IN PSAMP_OBJECT Context,
    IN PSID SelfSid,
    OUT PVOID * Nt4Sd
    )
/*++

    Routine Description

        This routine converts an NT5 DS security descriptor into an NT4
        SAM security Descriptor.

    Parameters:

        Nt5Sd -- NT5 Security Descriptor
        ObjectType -- The Sam Object Type
        SelfSid    -- Sid to use for the constant PRINCIPAL_SELF_SID
        Nt4Sd      -- Out parameter for the NT4 Descriptor

    Return Codes:
        STATUS_SUCCESS
        Other Error codes indicating type of failure
--*/
{

    BOOLEAN  StandardSd = TRUE;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN Admin, ChangePasswordAllowed;
    ULONG Nt4SdLength;
    ULONG AccountRid;
    PACL Dacl = NULL;
    ULONG AceCount = 0;
    SAMP_OBJECT_TYPE ObjectType = Context->ObjectType;


    Dacl = GetDacl(Nt5Sd);

    if ((NULL==Dacl)
        || (GetAceCount(Dacl)==0))
    {
        //
        // If the Dacl was NULL or Ace is zero in the Dacl
        // there is no need to convert as in the conversion
        // we basically convert the Aces in the Dacl
        //

        ULONG   Len;

        Len = GetSecurityDescriptorLength(Nt5Sd);
        *Nt4Sd = MIDL_user_allocate(Len);

        if (NULL==*Nt4Sd)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlCopyMemory(*Nt4Sd,Nt5Sd,Len);
    }

    else
    {

        switch(ObjectType)
        {

            //
            // For Domain and Server objects, NT4 SAM does not allow any customization
            // of the security descriptor ( except through SetSecurityObject ),
            // so directly return the standard NT4 descriptor built by bldsam3
            //

        case SampDomainObjectType:

            NtStatus = SampBuildNt4DomainProtection(
                            Nt4Sd,
                            &Nt4SdLength
                            );
            break;

        case SampServerObjectType:


            NtStatus = SampBuildNt4ServerProtection(
                            Nt4Sd,
                            &Nt4SdLength
                            );
            break;

            //
            // For group / alias objects we are intersted in finding wether the security
            // descriptor of interest is Admin or not. So call the reverse membership
            // routine and see if it is a member of any administrators Alias
            //

        case SampGroupObjectType:
        case SampAliasObjectType:


            NtStatus = SampSplitSid(SelfSid,NULL, &AccountRid);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            NtStatus = SampCheckIfAdmin(SelfSid, & Admin);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            //
            // Call the NT4 Samp routine to build the security descriptor
            //
            //

            NtStatus = SampGetNewAccountSecurityNt4(
                            ObjectType,
                            Admin,
                            TRUE,
                            FALSE,
                            AccountRid,
                            Context->DomainIndex,
                            Nt4Sd,
                            &Nt4SdLength
                            );
            break;


            //
            // For User objects we need to know wether change password is allowed or
            // not apart from Admin / Non Admin
            //

        case SampUserObjectType:


            NtStatus = SampSplitSid(SelfSid,NULL, &AccountRid);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            NtStatus = SampCheckIfAdmin(SelfSid, & Admin);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            NtStatus = SampCheckIfChangePasswordAllowed(
                            Nt5Sd,
                            SelfSid,
                            &ChangePasswordAllowed
                            );
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            //
            // Call the NT4 Samp routine to build the security descriptor
            //
            //

            NtStatus = SampGetNewAccountSecurityNt4(
                            ObjectType,
                            Admin,
                            TRUE,
                            FALSE,
                            AccountRid,
                            Context->DomainIndex,
                            Nt4Sd,
                            &Nt4SdLength
                            );

            if (!NT_SUCCESS(NtStatus))
                goto Error;

            if (!ChangePasswordAllowed && !Admin)
            {
                ACE * UsersAce;
                PACL Nt4Dacl;

                Nt4Dacl = GetDacl(*Nt4Sd);
                if (NULL!=Nt4Dacl)
                {
                    //
                    // Get the 4th ACE, which corresponds to Users Sid
                    //

                    UsersAce = GetAcePrivate(Nt4Dacl,3);
                    if (NULL!=UsersAce)
                    {
                        ACCESS_MASK * SamAccessMask;

                        SamAccessMask =
                                &(((ACCESS_ALLOWED_ACE *) UsersAce)
                                    ->Mask);

                        (*SamAccessMask)&=~((ACCESS_MASK) USER_CHANGE_PASSWORD);
                    }

                    //
                    // Get the first Ace which corresponds to World Sid
                    //
                    UsersAce = GetAcePrivate(Nt4Dacl,0);
                    if ((NULL!=UsersAce) && (RtlEqualSid(*WORLD_SID,SidFromAce(UsersAce))))
                    {
                        ACCESS_MASK * SamAccessMask;

                        SamAccessMask =
                                &(((ACCESS_ALLOWED_ACE *) UsersAce)
                                    ->Mask);

                        (*SamAccessMask)&=~((ACCESS_MASK) USER_CHANGE_PASSWORD);
                    }



                }
            }
            break;

        default:

            ASSERT(FALSE);
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;

        }
    }


Error:

     SampDiagPrint(SD_CONVERSION,("[SAMSS]  Leaving NT5 To NT4 Conversion, Status= %0x\n",NtStatus));

     IF_SAMP_GLOBAL(SD_CONVERSION)
     {
         IF_SAMP_GLOBAL(SD_DUMP)
         {
             SampDiagPrint(SD_CONVERSION,("[SAMSS] NT5 Security Descriptor = \n"));
             DumpSecurityDescriptor(Nt5Sd);
             SampDiagPrint(SD_CONVERSION,("[SAMSS] NT4 Security Descriptor = \n"));
             DumpSecurityDescriptor(*Nt4Sd);
         }
     }

 return NtStatus;

}

NTSTATUS
SampConvertNt4SdToNt5Sd(
    IN PVOID Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN  PSAMP_OBJECT Context OPTIONAL,
    OUT PVOID * Nt5Sd
    )

/*++

    Routine Description

        This is the entry point routine for a generic NT4 SAM
        to NT5 SD

    Parameters

        Nt4Sd      -- The NT4 Security descriptor
        ObjectType -- The SAM object Type
        Nt5Sd      -- The Nt5 Security Descriptor

    Return Values

  --*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG   NtSdLength;
    SECURITY_DESCRIPTOR_CONTROL Control;
    ULONG    Revision;
    ULONG    DsClassId;
    BOOLEAN  StandardSd;
    BOOLEAN  ChangePassword, Admin;



    SampDiagPrint(SD_CONVERSION,("[SAMSS] Performing NT4 To NT5 Coversion\n"));


    //
    // Do Some Parameter Validations
    //

    if (!RtlValidSecurityDescriptor(Nt4Sd))
    {
        return STATUS_INVALID_PARAMETER;
    }

    NtStatus = RtlGetControlSecurityDescriptor(
                    Nt4Sd,
                    &Control,
                    &Revision
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    if (Revision > SECURITY_DESCRIPTOR_REVISION)
        return STATUS_INVALID_PARAMETER;

    //
    // Get the Class Id
    //

    if (ARGUMENT_PRESENT(Context))
    {
        DsClassId = Context->DsClassId;
    }
    else
    {
        DsClassId = SampDsClassFromSamObjectType(ObjectType);
    }

    //
    // Identify if the security descriptor is a standard one,
    // in which case retrieve the corresponding standard one
    //

    NtStatus = SampRecognizeStandardNt4Sd(
                    Nt4Sd,
                    ObjectType,
                    DsClassId,
                    Context,
                    &ChangePassword,
                    &Admin,
                    Nt5Sd
                    );


Error:

     SampDiagPrint(SD_CONVERSION,("[SAMSS]  Leaving NT4 To NT5 Conversion, Status= %0x\n",NtStatus));

     IF_SAMP_GLOBAL(SD_CONVERSION)
     {
         IF_SAMP_GLOBAL(SD_DUMP)
         {
             SampDiagPrint(SD_CONVERSION,("[SAMSS] ObjectType = %d\n",ObjectType));
             SampDiagPrint(SD_CONVERSION,("[SAMSS] NT4 Security Descriptor = \n"));
             DumpSecurityDescriptor(Nt4Sd);
             SampDiagPrint(SD_CONVERSION,("[SAMSS] NT5 Security Descriptor = \n"));
             DumpSecurityDescriptor(*Nt5Sd);
         }
     }


    return NtStatus;
}

NTSTATUS
SampRecognizeStandardNt4Sd(
    IN PVOID   Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG DsClassId,
    IN PSAMP_OBJECT Context OPTIONAL,
    OUT BOOLEAN *ChangePassword,
    OUT BOOLEAN *Admin,
    OUT PVOID * Nt5Sd
    )
/*++

  Routine Description:

    Tries to recognize a standard NT4 Sd and returns the NT5 Sd if the
    recognition. Recognition focuses on determining the Admin and change password
    nature of the object

  Parameters

        Nt4Sd       -- NT4 SAM SD
        ObjectType  -- SAM object Type
        DsClassId   -- The DS Class Id
        Context     -- Optional In parameter to the context
        ChangePassword -- For user objects indicates that self can change password
        Admin       -- user/group is /was a member of administrators.
        Nt5Sd       -- if Nt4Sd was a standard security descriptor, then in
                       that case return the corresponding NT5 Security
                       descriptor

  Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY
--*/
{

    ULONG   AceCount;
    PACL    Nt4Dacl;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG   Nt5SdLength;
    ULONG   DefaultSecurityDescriptorLength;
    PSECURITY_DESCRIPTOR DefaultSecurityDescriptor=NULL;
    PSID    OwnerSid = NULL;
    BOOLEAN StandardSd = TRUE;

    //
    // Initialize return values
    //

    *Nt5Sd = NULL;
    *ChangePassword = TRUE;
    *Admin = FALSE;


    //
    // Using the Sam global flag we can always
    // enable the full conversion. This is useful to test
    // the full conversion routine.
    //

    IF_SAMP_GLOBAL(FORCE_FULL_SD_CONVERSION)
    {
        return STATUS_SUCCESS;
    }


    //
    // Get the Default Security Descriptor For Class
    //

    NtStatus = SampGetDefaultSecurityDescriptorForClass(
                    DsClassId,
                    &DefaultSecurityDescriptorLength,
                    TRUE, // Trusted Client
                    &DefaultSecurityDescriptor
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Get the Dacl and walk ACL by ACL
    // to select the correct NT5 security
    // Descriptor
    //

    Nt4Dacl = GetDacl(Nt4Sd);


    if ((NULL==Nt4Dacl)
        ||(GetAceCount(Nt4Dacl)==0))
    {

        //
        // If the Dacl was NULL then No ACL conversion
        // is required
        //

        NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                        GetOwner(Nt4Sd), // Pass through Ownner
                        GetGroup(Nt4Sd), // Pass through Group
                        NULL,            // Set Dacl to NULL
                        GetSacl(DefaultSecurityDescriptor), // Set Sacl To Schema Default
                        &Nt5SdLength,
                        Nt5Sd            // Get the new security descriptor
                        );
    }
    else
    {

        //
        // We have a Non Null Dacl. Will need to walk the DACL and
        // find out whether it matches the standard security descriptor
        //

        switch(ObjectType)
        {

        case SampDomainObjectType:
        case SampServerObjectType:

            //
            // For Domain and Server object's we completely ignore the
            // the Dacl on the NT4 object, and proceed to create a
            // a standard Dacl of our own
            //

            break;

        case SampGroupObjectType:

            //
            // We need to distinguish between Admin and Non Admin case
            //

            SampRecognizeNT4GroupDacl(Nt4Dacl, &StandardSd, Admin);
            break;

        case SampAliasObjectType:

            //
            // We need to distinguish between Admin and Non Admin case
            //

            SampRecognizeNT4AliasDacl(Nt4Dacl, &StandardSd, Admin);
            break;

        case SampUserObjectType:

            //
            // We need to distinguish between Admin, Non Admin, Change Password and Non Change
            // Password in non admin case. Also for machine accounts we try to grab the owner
            //
            SampRecognizeNT4UserDacl(Nt4Dacl, Context, &StandardSd, Admin, ChangePassword, &OwnerSid);
            break;

        default:

            ASSERT(FALSE && "Invalid Object Type");
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }

        //
        // Get the dacl from the schema, but remember, we need to
        // preserve the Admin and Change Password nature across
        // an NT4 upgrade. The standard schema default is for the non
        // admin and change password allowed case
        //

        if (!(*Admin) && (*ChangePassword))
        {
            //
            // Reset to schema default
            //

            NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                            (NULL!=OwnerSid)?OwnerSid:GetOwner(Nt4Sd), // Pass through Ownner
                            GetGroup(Nt4Sd), // Pass through Group
                            GetDacl(DefaultSecurityDescriptor), // Set Dacl to NULL
                            GetSacl(DefaultSecurityDescriptor), // Set Sacl To Schema Default
                            &Nt5SdLength,
                            Nt5Sd            // Get the new security descriptor
                            );
        }
        else
        {
            //
            // Build the equivalent NT5 Protections
            //

            NtStatus = SampBuildEquivalentNt5Protection(
                            ObjectType,
                            *Admin,
                            *ChangePassword,
                            GetOwner(Nt4Sd), // Pass Through Owner
                            GetGroup(Nt4Sd), // Pass Through Group
                            GetSacl(DefaultSecurityDescriptor), // Reset Sacl To Schema Default Sacl
                            Context,
                            Nt5Sd,
                            &Nt5SdLength
                            );
        }

    }

Error:

    if (NULL!=DefaultSecurityDescriptor)
    {
        MIDL_user_free(DefaultSecurityDescriptor);
        DefaultSecurityDescriptor = NULL;
    }

    return NtStatus;

}

VOID
SampRecognizeNT4GroupDacl(
    PACL    NT4Dacl,
    BOOLEAN *Standard,
    BOOLEAN *Admin
    )
/*++

      Routine Description:

        This routine tries to recognize wether the given DACL is a standard NT4 Group Dacl

      Parameters:

            NT4Dacl  -- Pointer to the NT4 Dacl
            Standard -- TRUE is returned in here if the Dacl were a standard DACL.
            Admin    -- TRUE is returned in here if the Dacl is an Admin DACL

      Return Values:

            None
--*/
{
    if (SampMatchNT4Aces(NT4GroupAdminTable,ARRAY_COUNT(NT4GroupAdminTable),NT4Dacl))
    {
        *Admin = TRUE;
        *Standard = TRUE;
    }
    else if (SampMatchNT4Aces(NT4GroupNormalTable,ARRAY_COUNT(NT4GroupNormalTable),NT4Dacl))
    {
        *Admin = FALSE;
        *Standard = TRUE;
    }
    else
    {
        *Standard = FALSE;
    }
}

VOID
SampRecognizeNT4AliasDacl(
    PACL    NT4Dacl,
    BOOLEAN *Standard,
    BOOLEAN *Admin
    )
/*++

      Routine Description:

        This routine tries to recognize wether the given DACL is a standard NT4 Alias Dacl

      Parameters:

            NT4Dacl  -- Pointer to the NT4 Dacl
            Standard -- TRUE is returned in here if the Dacl were a standard DACL.
            Admin    -- TRUE is returned in here if the Dacl is an Admin DACL

      Return Values:

            None
--*/
{

    if (SampMatchNT4Aces(NT4AliasAdminTable,ARRAY_COUNT(NT4AliasAdminTable),NT4Dacl))
    {
        *Admin = TRUE;
        *Standard = TRUE;
    }
    else if (SampMatchNT4Aces(NT4AliasNormalTable,ARRAY_COUNT(NT4AliasNormalTable),NT4Dacl))
    {
        *Admin = FALSE;
        *Standard = TRUE;
    }
    else
    {
        *Standard = FALSE;
    }
}


VOID
SampRecognizeNT4UserDacl(
    PACL    NT4Dacl,
    PSAMP_OBJECT Context,
    BOOLEAN *Standard,
    BOOLEAN *Admin,
    BOOLEAN *ChangePassword,
    OUT PSID * OwnerSid
    )
/*++

      Routine Description:

        This routine tries to recognize wether the given DACL is a standard NT4 User Dacl

      Parameters:

            NT4Dacl  -- Pointer to the NT4 Dacl
            Context -- Pointer to SAMP_OBJECT, used to get the RID of itself.
            Standard -- TRUE is returned in here if the Dacl were a standard DACL.
            Admin    -- TRUE is returned in here if the Dacl is an Admin DACL
            ChangePassword TRUE is returned here if user had change password rights
            OwnerOfMachine If the account was created through SeMachineAccount privilege then
                           get the owner of the machine.

      Return Values:

            None
--*/
{

    //
    // Initialize the return value
    //
    *OwnerSid = NULL;

    if (SampMatchNT4Aces(NT4UserAdminTable,ARRAY_COUNT(NT4UserAdminTable),NT4Dacl))
    {
        *Admin = TRUE;
        *Standard = TRUE;
        *ChangePassword = TRUE;
    }
    else if (SampMatchNT4Aces(NT4UserNormalTable,ARRAY_COUNT(NT4UserNormalTable),NT4Dacl))
    {
        *Admin = FALSE;
        *Standard = TRUE;
        *ChangePassword = TRUE;
    }
    else if ((SampMatchNT4Aces(NT4UserNoChangePwdTable, ARRAY_COUNT(NT4UserNoChangePwdTable),NT4Dacl)) ||
                (SampMatchNT4Aces(NT4UserNoChangePwdTable2, ARRAY_COUNT(NT4UserNoChangePwdTable2),NT4Dacl)))
    {
        *Standard = TRUE;
        *Admin = FALSE;
        *ChangePassword = FALSE;
    }
    else if (SampMatchNT4Aces(NT4UserRestrictedAccessTable, ARRAY_COUNT(NT4UserRestrictedAccessTable),NT4Dacl))
    {
        ACE * Ace = NULL;
        ULONG i;

        *Standard = TRUE;
        *Admin = FALSE;
        *ChangePassword = TRUE;

        for (i=0;i<ARRAY_COUNT(NT4UserRestrictedAccessTable);i++)
        {
            Ace = GetAcePrivate(NT4Dacl,i);
            if ((NULL!=Ace) && ((AccessMaskFromAce(Ace)) == (USER_WRITE|DELETE|USER_FORCE_PASSWORD_CHANGE)))
            {
                NTSTATUS NtStatus = STATUS_SUCCESS;
                PSID     AccountSid = NULL;
                PSID     TempSid = NULL;

                // Get the SID of the owner
                TempSid = SidFromAce(Ace);

                //
                // Only do the check when Context is presented.
                //
                if (ARGUMENT_PRESENT(Context))
                {
                    //
                    // If this is a machine account and DomainSidForNt4SdConversion
                    // is not NULL, then compare the Sid of the owner and the
                    // Sid of the machine account itself, they should not be
                    // the same. (DsClassId should have been set correctly already,
                    // DomainSidForNt4SdConversion is only been set during dcpromo
                    // time.)
                    //
                    //
                    if (CLASS_COMPUTER == Context->DsClassId &&
                        (NULL != Context->TypeBody.User.DomainSidForNt4SdConversion)
                       )
                    {
                        // Create the SID of this machine account itself
                        NtStatus = SampCreateFullSid(
                                        Context->TypeBody.User.DomainSidForNt4SdConversion, // Domain Sid
                                        Context->TypeBody.User.Rid,     // Rid
                                        &AccountSid
                                        );

                        if (NT_SUCCESS(NtStatus))
                        {
                            //
                            // If the Sid of the owner and the Sid of this
                            // machine account are not the same, then set the
                            // OwnerSid to the SID in the DACL.
                            //
                            if ( !RtlEqualSid(TempSid, AccountSid) )
                            {
                                KdPrintEx((DPFLTR_SAMSS_ID,
                                           DPFLTR_INFO_LEVEL,
                                           "Machine Account's Owner has been set to according to the NT4 DACL.\n"));

                                Context->TypeBody.User.PrivilegedMachineAccountCreate = TRUE;
                                *OwnerSid = TempSid;
                            }

                            MIDL_user_free(AccountSid);
                        }
                    }
                }
                break;
            } // end of if statement
        } // end of for statement
    }
    else
    {
        *Standard = FALSE;
    }
}


BOOLEAN
SampMatchNT4Aces(
    NT4_ACE_TABLE *AceTable,
    ULONG         cEntriesInAceTable,
    PACL          NT4Dacl
    )
/*++

    Given a table structure describing the Aces in a standard NT4 Dacl,
    and the NT4 Ace, this routine tries to find wether the given standard
    table structure matches the Nt4Dacl supplied. The Aces are walked in both
    forward and reverse order, as NT4 replication reverses the order of Aces.

    The principal self Sid in the Ace table is treated like a wildcarded Sid.

    Parameters:

        AceTable - A table describing the NT4 Aces in the table
        cEntriesinAceTable - Provides the number of entries in the Ace Table
        NT4Dacl -- The NT4 Dacl,

    Return Values

        TRUE or FALSE depending upon the Dacl matched or not
--*/
{
    ULONG   AceCount;
    ACE     *Ace[4];
    BOOLEAN Match = FALSE;
    ULONG   i;


    AceCount = GetAceCount(NT4Dacl);

    if (AceCount>ARRAY_COUNT(Ace))
    {
        return FALSE;
    }

    if (cEntriesInAceTable==AceCount)
    {

        //
        // Candidate for a match
        //

        BOOL forwardMatch = TRUE;
        BOOL reverseMatch = FALSE;

        //
        // Get hold of interesting ACES
        //

        for (i=0;i<cEntriesInAceTable;i++)
        {
            Ace[i] = GetAcePrivate(NT4Dacl,i);
        }

        //
        // Check wether it is a standard ACE, by comapring ACE by ACE, going forward
        //

        for (i=0;i<cEntriesInAceTable;i++)
        {
            if (
                !( 
                   (NULL != Ace[i]) 
                &&
                   (IsAccessAllowedAce(Ace[i]))
                && (
                     (RtlEqualSid(*(AceTable[i].Sid),SidFromAce(Ace[i])))
                     // Prinicpal self Sid in table matches any Sid
                     || (RtlEqualSid(*(AceTable[i].Sid), *PRINCIPAL_SELF_SID))
                   )
                && (AceTable[i].AccessMask == AccessMaskFromAce(Ace[i]))
                )
               )
            {
                forwardMatch = FALSE;
                break;
            }
        }

        //
        // NT4 Replication Reverses order of Aces. Check wether by reversing
        // we are able to match
        //

        if (!forwardMatch)
        {
            reverseMatch = TRUE;

            for (i=0;i<cEntriesInAceTable;i++)
            {
                ULONG   TablIndx = cEntriesInAceTable-i-1;

                if (
                    !(
                       (NULL != Ace[i])
                    && 
                       (IsAccessAllowedAce(Ace[i]))
                    && (
                        (RtlEqualSid(*(AceTable[TablIndx].Sid),SidFromAce(Ace[i])))
                        // Prinicpal self Sid in table matches any Sid
                        || (RtlEqualSid(*(AceTable[TablIndx].Sid), *PRINCIPAL_SELF_SID))
                       )
                    && (AceTable[TablIndx].AccessMask == AccessMaskFromAce(Ace[i]))
                    )
                   )
                {
                    reverseMatch = FALSE;
                    break;
                }
            }
        }

        if (forwardMatch || reverseMatch)
        {
            Match = TRUE;
        }
    }

    return Match;
}




NTSTATUS
SampCheckIfAdmin(
    PSID SidOfPrincipal,
    BOOLEAN * Admin
    )
/*++

  Routine Description:

        Checks to see if SidOfPrincipal is member of administrators alias


  Parameters

    SidOfPrincipal  - Sid of principal
    Admin           - bool returning Admin or non Admin

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    DSNAME *DsNameOfPrincipal = NULL;
    PSID   *DsSids = NULL;

    *Admin = FALSE;

    if (RtlEqualSid(SidOfPrincipal,*ADMINISTRATOR_SID))
    {

        //
        // Admin Alias itself is passed in. Getting reverse
        // membership for it will get nothing back
        //

        *Admin = TRUE;
    }
    else if (SampLookupAclConversionCache(SidOfPrincipal,Admin))
    {
        //
        // ACL Conversion Cache Lookup Succeed, the Admin bit
        // would now be set depending upon saves state in cache
        //

    }
    else
    {


        //
        // Check wether the passed in SID itself an administrator Sid
        //



        NtStatus = SampDsObjectFromSid(
                        SidOfPrincipal,
                        &DsNameOfPrincipal
                        );
        if (NT_SUCCESS(NtStatus))
        {
            ULONG Count;
            ULONG Index;

            NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            //
            // NT5 To NT4 Descriptor Conversion requests No G.C This is because
            // the only real NT4 Client who wants to query the Security Descriptor
            // is NT4 Replication, and in a mixed domain we should not have
            // NT5 style cross domain memberships.
            //

            NtStatus = SampDsGetReverseMemberships(
                            DsNameOfPrincipal,
                            SAM_GET_MEMBERSHIPS_TWO_PHASE|SAM_GET_MEMBERSHIPS_NO_GC,
                            &Count,
                            &DsSids);

            if (NT_SUCCESS(NtStatus))
            {
                for (Index=0;Index<Count;Index++)
                {
                    ULONG Rid;

                    NtStatus = SampSplitSid(
                                    DsSids[Index],
                                    NULL,
                                    &Rid
                                    );
                    if ((NT_SUCCESS(NtStatus))
                        && (DOMAIN_ALIAS_RID_ADMINS == Rid))
                    {
                        *Admin=TRUE;
                         break;
                    }


                }

                //
                // O.K Now add this result to the cache
                //

                SampAddToAclConversionCache(SidOfPrincipal,(*Admin));

            }

            MIDL_user_free(DsNameOfPrincipal);
        }
        else if (STATUS_NOT_FOUND==NtStatus)
        {
            //
            // We could not find this SID in the DS. So apparently
            // it is not a member of anything, so it is not an
            // administrator
            //

            *Admin = FALSE;
            NtStatus = STATUS_SUCCESS;
        }
    }

Error:

    if (NULL!=DsSids)
        THFree(DsSids);

    return NtStatus;
}





NTSTATUS
SampCheckIfChangePasswordAllowed(
    IN  PSECURITY_DESCRIPTOR Nt5Sd,
    IN  PSID     UserSid,
    OUT  BOOLEAN *ChangePasswordAllowed
    )
/*++

    Checks wether Password Change is allowed for an NT5 Sd
    No User Sid need be passed , as PRINCIPAL_SELF_SID denotes user

    Parameters

        Nt5Sd  -- Nt5 Security descriptor
        UserSid -- The Sid of the user.
        ChangePasswod -- Boolean returning password change

    Return Values

        STATUS_SUCCESS

 --*/

{
    PACL Dacl= NULL;

    //
    // Initialize Change Password Allowed to FALSE
    //
    *ChangePasswordAllowed=FALSE;
    Dacl = GetDacl(Nt5Sd);
    if (NULL!=Dacl)
    {
        ULONG AceCount;
        ULONG Index;

        //
        // Walk each ACE and try to find a deny/allowed ACE that denies/grants the right
        // to change password for either world, user's sid, or principal self SID.
        // This is the same algorithm used by win2k UI to figure out if a given
        // win2k ACL on a user object allows change password right on that user object.
        //

        AceCount = GetAceCount(Dacl);
        for (Index=0;Index<AceCount;Index++)
        {
            ACE * Ace;

            Ace = GetAcePrivate(Dacl,Index);

            //
            // Object ACE that has the control access right for
            // User Change Password
            //

            if (
                  (NULL!=Ace)
               && (IsAccessAllowedObjectAce(Ace))
               && (
                    (RtlEqualSid(*PRINCIPAL_SELF_SID,SidFromAce(Ace)))
                   || (RtlEqualSid(UserSid,SidFromAce(Ace)))
                   || (RtlEqualSid(*WORLD_SID,SidFromAce(Ace)))
                  )
               && (NULL!=RtlObjectAceObjectType(Ace))
               && (memcmp(RtlObjectAceObjectType(Ace),
                            &(GUID_CONTROL_UserChangePassword),
                            sizeof(GUID))==0)
               )
            {
                 *ChangePasswordAllowed = TRUE;
                 break;
            }

            //
            // Access Allowed Ace for DS control access
            //

            else if ((NULL!=Ace)
                && (IsAccessAllowedAce(Ace))
                && (
                      (RtlEqualSid(*PRINCIPAL_SELF_SID,SidFromAce(Ace)))
                   || (RtlEqualSid(UserSid,SidFromAce(Ace)))
                   || (RtlEqualSid(*WORLD_SID,SidFromAce(Ace)))
                   )
                && ((AccessMaskFromAce(Ace))& RIGHT_DS_CONTROL_ACCESS))
            {
                *ChangePasswordAllowed = TRUE;
                break;
            }

            //
            // Access denied Object ACE for DS control access
            //
              if (
                  (NULL!=Ace)
               && (IsAccessDeniedObjectAce(Ace))
               && (
                    (RtlEqualSid(*PRINCIPAL_SELF_SID,SidFromAce(Ace)))
                   || (RtlEqualSid(UserSid,SidFromAce(Ace)))
                   || (RtlEqualSid(*WORLD_SID,SidFromAce(Ace)))
                  )
               && (NULL!=RtlObjectAceObjectType(Ace))
               && (memcmp(RtlObjectAceObjectType(Ace),
                            &(GUID_CONTROL_UserChangePassword),
                            sizeof(GUID))==0)
               )
            {
                 *ChangePasswordAllowed = FALSE;
                 break;
            }

            //
            // Access Allowed Ace for DS control access
            //

            else if ((NULL!=Ace)
                && (IsAccessDeniedAce(Ace))
                && (
                      (RtlEqualSid(*PRINCIPAL_SELF_SID,SidFromAce(Ace)))
                   || (RtlEqualSid(UserSid,SidFromAce(Ace)))
                   || (RtlEqualSid(*WORLD_SID,SidFromAce(Ace)))
                   )
                && ((AccessMaskFromAce(Ace))& RIGHT_DS_CONTROL_ACCESS))
            {
                *ChangePasswordAllowed = FALSE;
                break;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SampBuildEquivalentNt5Protection(
    SAMP_OBJECT_TYPE ObjectType,
    BOOLEAN Admin,
    BOOLEAN ChangePassword,
    PSID OwnerSid,
    PSID GroupSid,
    PACL Sacl,
    IN PSAMP_OBJECT Context OPTIONAL,
    PSECURITY_DESCRIPTOR * Nt5Sd,
    PULONG  Nt5SdLength
    )
/*++

  Routine Description:

    Given the Admin and Change Password Nature of a security principal, SampBuildNT5Protection
        builds a standard NT5 Security descriptor, that most closely matches the corresponding standard
        NT4 Security Descriptor, with the same Admin and Change Password Nature.

  Parameters:

    ObjectType          -- SAM object type
    Admin                       -- Indicates Admin. This bit is ignored at present.
    ChangePassword  -- For user objects wether user has right to change password
    OwnerSId        -- Owner
    GroupSid        -- Group
    Sacl            -- SystemAcl
    Nt5SD           -- Nt5SD , just built
    Nt5SdLength     -- Length of the Nt5 Sd

  Return Values

     STATUS_SUCCESS -- Upon Successful Completion
     Other Error codes to return proper Failure indication upon Failure

--*/
{
    NTSTATUS NtStatus;
    ULONG   Index =0;
    SECURITY_DESCRIPTOR SdAbsolute;
    CHAR    SaclBuffer[MAX_ACL_SIZE];
    CHAR    DaclBuffer[MAX_ACL_SIZE];
    PACL    SaclToSet = (ACL *) SaclBuffer;
    PACL    Dacl = (ACL *) DaclBuffer;
    ACE_TABLE *AceTableToUse = NULL;
    ULONG     cEntriesInAceTable = 0;
    ULONG     SdLength;

    //
    // Create the security descriptor
    //
    *Nt5Sd = NULL;
    *Nt5SdLength = 0;
    if (!InitializeSecurityDescriptor(&SdAbsolute,SECURITY_DESCRIPTOR_REVISION))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Create Dacl
    //

    if (!InitializeAcl(Dacl,sizeof(DaclBuffer),ACL_REVISION_DS))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }



    //
    // Set the owner, default the owner to administrators alias
    //

    if (NULL==OwnerSid)
    {
        OwnerSid = *ADMINISTRATOR_SID;  // Administrator is the default owner
    }

    if (!SetSecurityDescriptorOwner(&SdAbsolute,OwnerSid,FALSE))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    //
    // Set the group, default the group to administrators alias
    //

    if (NULL==GroupSid)
    {
        GroupSid = *ADMINISTRATOR_SID;
    }

    if (!SetSecurityDescriptorGroup(&SdAbsolute,GroupSid,FALSE))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    //
    // Get the System ACL to Set
    //

    if (NULL!=Sacl)
    {
        SaclToSet = Sacl;
    }
    else
    {
        //
        // Build a default system ACL
        //
        //

        //
        // Create the SACL in it. Set the SAcl revision to ACL_REVISION_DS.
        //

        if (!InitializeAcl(SaclToSet,sizeof(SaclBuffer),ACL_REVISION_DS))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }

        NtStatus = AddAuditAccessAce(
                    SaclToSet,
                    ACL_REVISION_DS,
                    STANDARD_RIGHTS_WRITE|
                    DELETE |
                    WRITE_DAC|
                    ACCESS_SYSTEM_SECURITY,
                    *WORLD_SID,
                    TRUE,
                    TRUE
                    );

         if (!NT_SUCCESS(NtStatus))
            goto Error;

         if (!AdjustAclSize(SaclToSet))
         {
             NtStatus = STATUS_UNSUCCESSFUL;
             goto Error;
         }
    }

    //
    // Set the Sacl
    //

    if (!SetSecurityDescriptorSacl(&SdAbsolute,TRUE,SaclToSet,FALSE))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    //
    // Get the Dacl to Set
    //

    switch(ObjectType)
    {
    case SampDomainObjectType:
         AceTableToUse = DomainAceTable;
         cEntriesInAceTable = ARRAY_COUNT(DomainAceTable);
         break;

    case SampServerObjectType:
         AceTableToUse = ServerAceTable;
         cEntriesInAceTable = ARRAY_COUNT(ServerAceTable);
         break;

    case SampGroupObjectType:
    case SampAliasObjectType:

         if (!Admin)
         {
            AceTableToUse = GroupAceTable;
            cEntriesInAceTable = ARRAY_COUNT(GroupAceTable);
         }
         else
         {
            AceTableToUse = GroupAdminAceTable;
            cEntriesInAceTable = ARRAY_COUNT(GroupAdminAceTable);
         }

         break;


    case SampUserObjectType:
         if ((!ChangePassword) && (!Admin))
         {
             AceTableToUse = UserNoPwdAceTable;
             cEntriesInAceTable = ARRAY_COUNT(UserNoPwdAceTable);
         }
         else if (!Admin)
         {
            AceTableToUse = UserAceTable;
            cEntriesInAceTable = ARRAY_COUNT(UserAceTable);
         }
         else
         {
            AceTableToUse = UserAdminAceTable;
            cEntriesInAceTable = ARRAY_COUNT(UserAdminAceTable);
         }


         break;

    default:

        ASSERT(FALSE);
        break;
    }

    NtStatus = SampCreateNT5Dacl(
                  AceTableToUse,
                  cEntriesInAceTable,
                  Context,
                  Dacl
                  );

    if (!NT_SUCCESS(NtStatus))
        goto Error;



    //
    // Set the Dacl
    //

    if (!SetSecurityDescriptorDacl(&SdAbsolute,TRUE,Dacl,FALSE))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Now convert this security descriptor to self relative form
    //

    SdLength =  GetSecurityDescriptorLength(&SdAbsolute);
    *Nt5Sd = MIDL_user_allocate(SdLength);
    if (NULL==*Nt5Sd)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    if (!MakeSelfRelativeSD(&SdAbsolute,*Nt5Sd,&SdLength))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        if (*Nt5Sd)
        {
            MIDL_user_free(*Nt5Sd);
            *Nt5Sd = NULL;
        }
    }

    *Nt5SdLength = SdLength;

Error:

    return NtStatus;
}


NTSTATUS
SampCreateNT5Dacl(
    ACE_TABLE * AceTable,
    ULONG       cEntries,
    PSAMP_OBJECT Context OPTIONAL,
    PACL        Dacl
    )
/*

  Routine Description:

    THis routine walks through the ACE table and creates a Dacl,
    as specified in the ACE Table

  Parameters:

    AceTable -- The Ace Table to use for knowledge about Aces in the Dacl
    cEntires -- The number of entries in the Ace table
    Context  -- If an Open context is provided then this context is used to
                subsutitue the Class Guid of the actual object by fetching it
                from the DS. Else the one in the ACE table is used, which corresponds
                to the class GUID of the Base object Type. Each Ace table entry has
                a boolean field which tells this function wether the GUID in the
                corresponding entry refers to the class GUID.
    Dacl     -- The constructed Dacl is returned in here

  Return Values

    STATUS_SUCCESS
    Other Error codes upon failure

  */
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    Index = 0;
    ULONG     ClassGuidLength=sizeof(GUID);
    GUID      ClassGuid;
    GUID      *ClassGuidInAceTable;

    //
    // Obtain the actual Class GUID of the object whose security descriptor is being
    // converted. Also obtain the default class GUID in the Ace Table. Before adding
    // the Aces we will substitute the class guid of the actual class.
    //

    if (ARGUMENT_PRESENT(Context))
    {
        NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        NtStatus = SampGetClassAttribute(
                        Context->DsClassId,
                        ATT_SCHEMA_ID_GUID,
                        &ClassGuidLength,
                        &ClassGuid
                        );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }



    for (Index=0;Index<cEntries;Index++)
    {
        ULONG MappedAccessMask;

        MappedAccessMask =  AceTable[Index].AccessMask;

        RtlMapGenericMask(
            &(MappedAccessMask),
            &DsGenericMap
            );

        switch(AceTable[Index].AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            if (!AddAccessAllowedAce(
                            Dacl,
                            ACL_REVISION_DS,
                            MappedAccessMask,
                            *(AceTable[Index].Sid)
                            ))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
            }
            break;

        case ACCESS_DENIED_ACE_TYPE:
            if (!AddAccessDeniedAce(
                            Dacl,
                            ACL_REVISION_DS,
                            MappedAccessMask,
                            *(AceTable[Index].Sid)
                            ))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
            }
            break;
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:


            if (!AddAccessAllowedObjectAce(
                            Dacl,
                            ACL_REVISION_DS,
                            0,
                            MappedAccessMask,
                            ((ARGUMENT_PRESENT(Context))&& AceTable[Index].IsObjectGuid)?
                               (&ClassGuid):(GUID *) AceTable[Index].TypeGuid,
                            (GUID *) AceTable[Index].InheritGuid,
                            *(AceTable[Index].Sid)
                            ))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            break;
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
            if (!AddAccessDeniedObjectAce(
                            Dacl,
                            ACL_REVISION_DS,
                            0,
                            MappedAccessMask,
                            ((ARGUMENT_PRESENT(Context))&& AceTable[Index].IsObjectGuid)?
                                (&ClassGuid):((GUID *) AceTable[Index].TypeGuid),
                            (GUID *) AceTable[Index].InheritGuid,
                            *(AceTable[Index].Sid)
                            ))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            break;

        default:
            break;
        }
    }

 //
 // Adjust the size of the ACL so that we consume less disk
 //

 if (!AdjustAclSize(Dacl))
 {
     NtStatus = STATUS_UNSUCCESSFUL;
 }

Error:

    return NtStatus;
}

NTSTATUS
SampGetDefaultSecurityDescriptorForClass(
    ULONG   DsClassId,
    PULONG  SecurityDescriptorLength,
    BOOLEAN TrustedClient,
    PSECURITY_DESCRIPTOR    *SecurityDescriptor
    )
/*++

    SampGetDefaultSecurityDescriptorForClass queries the Schema to obtain the default security
    descriptor for the class. It tries to obtain the owner and group fields by impersonating
    and grabbing the user's Sid. If the owner and group fields is not present or if it is a
    trusted client then the Administrator's SID is used instead.

    Parameters:

        DsClassId                The DS Class Id of the class whose security descriptor
                                 we desire
        SecurityDescriptorLength The length of the security descriptor is returned in here
        TrustedClient            Indicates Trusted Clients. No impersonation is done for
                                 trusted clients.
        SecurityDescriptor       The Security Descriptor that we want.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    PTOKEN_OWNER Owner=NULL;
    PTOKEN_PRIMARY_GROUP PrimaryGroup=NULL;
    PSECURITY_DESCRIPTOR TmpSecurityDescriptor = NULL;
    ULONG                TmpSecurityDescriptorLength = 0;


    ASSERT(NULL!=SecurityDescriptor);
    ASSERT(NULL!=SecurityDescriptorLength);

    //
    // Query the schema asking for default security descriptor. Determine how much
    // memory to alloc
    //

    *SecurityDescriptorLength = 0;
    *SecurityDescriptor = NULL;

    NtStatus = SampGetClassAttribute(
                                    DsClassId,
                                    ATT_DEFAULT_SECURITY_DESCRIPTOR,
                                    SecurityDescriptorLength,
                                    NULL
                                    );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {

        //
        // Allocate a buffer for the security descriptor
        //

        *SecurityDescriptor = MIDL_user_allocate(*SecurityDescriptorLength);
        if (NULL==*SecurityDescriptor)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        NtStatus = SampGetClassAttribute(
                                        DsClassId,
                                        ATT_DEFAULT_SECURITY_DESCRIPTOR,
                                        SecurityDescriptorLength,
                                        *SecurityDescriptor
                                        );
    }
    else
    {
        //
        // Case where there is no security descriptor in the schema
        //

        NtStatus = STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(NtStatus))
    {


        //
        // For a Non Trusted Client obtain the User and Primary
        // group Sid by Querying the Token
        //

        if (!TrustedClient)
        {
            NtStatus = SampGetCurrentOwnerAndPrimaryGroup(
                            &Owner,
                            &PrimaryGroup
                            );
            if (!NT_SUCCESS(NtStatus))
                goto Error;
        }

        //
        // Make a new security descriptor , setting the owner and the group
        // to that of
        //

        NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                        (Owner)?Owner->Owner:(*ADMINISTRATOR_SID),
                        (PrimaryGroup)?PrimaryGroup->PrimaryGroup:(*ADMINISTRATOR_SID),
                        GetDacl(*SecurityDescriptor),
                        GetSacl(*SecurityDescriptor),
                        &TmpSecurityDescriptorLength,
                        &TmpSecurityDescriptor
                        );

        if (NT_SUCCESS(NtStatus))
        {
            MIDL_user_free(*SecurityDescriptor);
            *SecurityDescriptor = TmpSecurityDescriptor;
            *SecurityDescriptorLength = TmpSecurityDescriptorLength;
        }

    }

Error:

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL!=*SecurityDescriptor)
        {
            MIDL_user_free(*SecurityDescriptor);
            *SecurityDescriptor = NULL;
        }
        *SecurityDescriptorLength = 0;
    }

    if (Owner)
        MIDL_user_free(Owner);

    if (PrimaryGroup)
        MIDL_user_free(PrimaryGroup);


    return NtStatus;
}


NTSTATUS
SampMakeNewSelfRelativeSecurityDescriptor(
    PSID    Owner,
    PSID    Group,
    PACL    Dacl,
    PACL    Sacl,
    PULONG  SecurityDescriptorLength,
    PSECURITY_DESCRIPTOR * SecurityDescriptor
    )
/*++

      Routine Description:

      Given the 4 components of a security descriptor this routine makes a new
      self relative Security descriptor.

      Parameters:

        Owner -- The Sid of the owner
        Group -- The Sid of the group
        Dacl  -- The Dacl to Use
        Sacl  -- The Sacl to Use

      Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_UNSUCCESSFUL
--*/
{

    SECURITY_DESCRIPTOR SdAbsolute;
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    *SecurityDescriptorLength = 0;
    *SecurityDescriptor = NULL;

    if (!InitializeSecurityDescriptor(&SdAbsolute,SECURITY_DESCRIPTOR_REVISION))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    //
    // Set the owner, default the owner to administrators alias
    //


    if (NULL!=Owner)
    {
        if (!SetSecurityDescriptorOwner(&SdAbsolute,Owner,FALSE))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }
    }




    if (NULL!=Group)
    {
        if (!SetSecurityDescriptorGroup(&SdAbsolute,Group,FALSE))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }
    }


    //
    // Set the Dacl if there is one
    //

    if (NULL!=Dacl)
    {
        if (!SetSecurityDescriptorDacl(&SdAbsolute,TRUE,Dacl,FALSE))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }
    }

    //
    // Set the Sacl if there is one
    //

    if (NULL!=Sacl)
    {
        if (!SetSecurityDescriptorSacl(&SdAbsolute,TRUE,Sacl,FALSE))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
        }
    }

    //
    // Make a new security Descriptor
    //

    *SecurityDescriptorLength =  GetSecurityDescriptorLength(&SdAbsolute);
    *SecurityDescriptor = MIDL_user_allocate(*SecurityDescriptorLength);
    if (NULL==*SecurityDescriptor)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }


    if (!MakeSelfRelativeSD(&SdAbsolute,*SecurityDescriptor,SecurityDescriptorLength))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        if (*SecurityDescriptor)
        {
            MIDL_user_free(*SecurityDescriptor);
            *SecurityDescriptor = NULL;
        }
    }

Error:


    return NtStatus;
}



NTSTATUS
SampInitializeWellKnownSidsForDsUpgrade( VOID )
/*++

Routine Description:

    This routine initializes some global well-known sids.  This
    is needed for the upgrade case, as we do not call SamInitialize

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Initialization has successfully completed.

    STATUS_NO_MEMORY - Couldn't allocate memory for the sids.

--*/
{
    NTSTATUS
        NtStatus;

    PPOLICY_ACCOUNT_DOMAIN_INFO
        DomainInfo;

    //
    //      WORLD is s-1-1-0
    //  ANONYMOUS is s-1-5-7
    //

    SID_IDENTIFIER_AUTHORITY
            WorldSidAuthority       =   SECURITY_WORLD_SID_AUTHORITY,
            NtAuthority             =   SECURITY_NT_AUTHORITY;

    SAMTRACE("SampInitializeWellKnownSids");


    NtStatus = RtlAllocateAndInitializeSid(
                   &NtAuthority,
                   1,
                   SECURITY_ANONYMOUS_LOGON_RID,
                   0, 0, 0, 0, 0, 0, 0,
                   &SampAnonymousSid
                   );
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlAllocateAndInitializeSid(
                       &WorldSidAuthority,
                       1,                      //Sub authority count
                       SECURITY_WORLD_RID,     //Sub authorities (up to 8)
                       0, 0, 0, 0, 0, 0, 0,
                       &SampWorldSid
                       );
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = RtlAllocateAndInitializeSid(
                            &NtAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0, 0, 0, 0, 0, 0,
                            &SampAdministratorsAliasSid
                            );
            if (NT_SUCCESS(NtStatus)) {
                NtStatus = RtlAllocateAndInitializeSid(
                                &NtAuthority,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                                0, 0, 0, 0, 0, 0,
                                &SampAccountOperatorsAliasSid
                                );
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = RtlAllocateAndInitializeSid(
                                    &NtAuthority,
                                    1,
                                    SECURITY_AUTHENTICATED_USER_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &SampAuthenticatedUsersSid
                                    );
                    if (NT_SUCCESS(NtStatus)) {
                        NtStatus = RtlAllocateAndInitializeSid(
                                        &NtAuthority,
                                        1,
                                        SECURITY_PRINCIPAL_SELF_RID,
                                        0,0, 0, 0, 0, 0, 0,
                                        &SampPrincipalSelfSid
                                        );

                    }
                }
            }

        }
    }

    return(NtStatus);
}




NTSTATUS
SampBuildNt4DomainProtection(
    PSECURITY_DESCRIPTOR * Nt4DomainDescriptor,
    PULONG  DescriptorLength
    )
/*++
    Builds a Default NT4 Descriptor for SAM domain objects
    Calls the Build Sam Routines

    Parameters:

        Nt4DomainDescriptor -- The NT4 Domain security Descriptor that
        is to be built

        DescriptorLength    -- The length of the Descriptor

    Return Values

        STATUS_SUCCESS
        Other Error codes upon failure

--*/
{
    NTSTATUS    NtStatus;
    PSID        AceSid[3];
    ACCESS_MASK AceMask[3];
    PSECURITY_DESCRIPTOR    LocalDescriptor = NULL;
    GENERIC_MAPPING  DomainMap    =  {DOMAIN_READ,
                                      DOMAIN_WRITE,
                                      DOMAIN_EXECUTE,
                                      DOMAIN_ALL_ACCESS
                                      };


    *Nt4DomainDescriptor = NULL;
    *DescriptorLength = 0;

    AceSid[0]  = *(WORLD_SID);
    AceMask[0] = (DOMAIN_EXECUTE | DOMAIN_READ);

    AceSid[1]  = *(ADMINISTRATOR_SID);
    AceMask[1] = (DOMAIN_ALL_ACCESS);


    AceSid[2]  = *(ACCOUNT_OPERATOR_SID);
    AceMask[2] = (DOMAIN_EXECUTE | DOMAIN_READ | DOMAIN_CREATE_USER  |
                                                 DOMAIN_CREATE_GROUP |
                                                 DOMAIN_CREATE_ALIAS);

    NtStatus = SampBuildSamProtection(
                    *WORLD_SID,
                    *ADMINISTRATOR_SID,
                    3,//AceCount,
                    AceSid,
                    AceMask,
                    &DomainMap,
                    FALSE,
                    DescriptorLength,
                    &LocalDescriptor,
                    NULL
                    );

    if (NT_SUCCESS(NtStatus))
    {
        *Nt4DomainDescriptor = MIDL_user_allocate(*DescriptorLength);
        if (NULL!=*Nt4DomainDescriptor)
        {
            RtlCopyMemory(
                *Nt4DomainDescriptor,
                LocalDescriptor,
                *DescriptorLength
                );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }

        RtlFreeHeap(RtlProcessHeap(),0,LocalDescriptor);
        LocalDescriptor = NULL;
    }

    return NtStatus;
}

NTSTATUS
SampBuildNt4ServerProtection(
    PSECURITY_DESCRIPTOR * Nt4ServerDescriptor,
    PULONG  DescriptorLength
    )
/*++

    Builds a Default NT4 Descriptor for SAM Server objects

    Calls the Build Sam Routines

    Parameters:

        Nt4DomainDescriptor -- The NT4 Domain security Descriptor that
        is to be built

        DescriptorLength    -- The length of the Descriptor

    Return Values

        STATUS_SUCCESS
        Other Error codes upon failure


--*/
{
    NTSTATUS    NtStatus;
    PSID        AceSid[2];
    ACCESS_MASK AceMask[2];
    PSECURITY_DESCRIPTOR    LocalDescriptor = NULL;
    GENERIC_MAPPING  ServerMap    =  {SAM_SERVER_READ,
                                      SAM_SERVER_WRITE,
                                      SAM_SERVER_EXECUTE,
                                      SAM_SERVER_ALL_ACCESS
                                      };


    AceSid[0]  = *(WORLD_SID);
    AceMask[0] = (SAM_SERVER_EXECUTE | SAM_SERVER_READ);

    AceSid[1]  = *(ADMINISTRATOR_SID);
    AceMask[1] = (SAM_SERVER_ALL_ACCESS);


    *Nt4ServerDescriptor = NULL;
    *DescriptorLength = 0;

    NtStatus = SampBuildSamProtection(
                    *WORLD_SID,
                    *ADMINISTRATOR_SID,
                    2,//AceCount,
                    AceSid,
                    AceMask,
                    &ServerMap,
                    FALSE,
                    DescriptorLength,
                    &LocalDescriptor,
                    NULL
                    );

    if (NT_SUCCESS(NtStatus))
    {
        *Nt4ServerDescriptor = MIDL_user_allocate(*DescriptorLength);
        if (NULL!=*Nt4ServerDescriptor)
        {
            RtlCopyMemory(
                *Nt4ServerDescriptor,
                LocalDescriptor,
                *DescriptorLength
                );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }

        RtlFreeHeap(RtlProcessHeap(),0,LocalDescriptor);
        LocalDescriptor = NULL;
    }

    return NtStatus;
}


NTSTATUS
SampPropagateSelectedSdChanges(
    IN PVOID Nt4Sd,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PSAMP_OBJECT Context,
    OUT PVOID * Nt5Sd
    )
/*++

    Routine Description:

        SampPropagateSelectedSdChanges propagates only selected aspects of the Dacl in the
        NT4 security descriptor. This allows downlevel clients to perform essential functions
        like change password without losing information in the actual NT5 security descriptor
        on the object.

    Parameters:

        Nt4Sd      -- The NT4 security descriptor
        ObjectType -- The object type of the object whose security descriptor we want to modify
        Context    -- An open context to the object whose security descriptor is being modified
        Nt5Sd      -- The security descriptor in which essential elements of the NT4 Sd have been
                      propagated is returned in here.

    Return Values:

        STATUS_SUCCESS

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PVOID       TmpNt5Sd = NULL;
    PVOID       SDToFree = NULL;
    BOOLEAN     Admin , ChangePassword;
    BOOLEAN     ChangePasswordAllowedOnCurrent;
    PVOID       CurrentSD = NULL;
    ULONG       CurrentSDLength = 0;

    *Nt5Sd = NULL;

    ASSERT(IsDsObject(Context));
    ASSERT(!Context->TrustedClient);


    //
    // Retrieve the current security descriptor
    //

    NtStatus = SampGetObjectSD(
                        Context,
                        &CurrentSDLength,
                        &CurrentSD
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    if (SampUserObjectType==ObjectType)
    {

        SDToFree = CurrentSD;

        //
        // First Parse the passed in NT4 DACL and see if it is a change password allowed /denied type
        //

        NtStatus = SampRecognizeStandardNt4Sd(
                        Nt4Sd,
                        ObjectType,
                        Context->DsClassId,
                        Context,
                        &ChangePassword,
                        &Admin,
                        &TmpNt5Sd
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Check the current Status of Password change / Admin ness
        //

        ASSERT(Context->ObjectNameInDs->SidLen >0);

        NtStatus = SampCheckIfChangePasswordAllowed(
                        CurrentSD,
                        &Context->ObjectNameInDs->Sid,
                        &ChangePasswordAllowedOnCurrent
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            MIDL_user_free(TmpNt5Sd);
            goto Error;
        }

        if (ChangePassword != ChangePasswordAllowedOnCurrent)
        {
            *Nt5Sd = TmpNt5Sd;
            SDToFree = CurrentSD;
        }
        else
        {
            *Nt5Sd = CurrentSD;
            SDToFree = TmpNt5Sd;
        }
    }
    else
    {
        //
        // Don't allow untrusted callers to change the SD through the downlevel
        // interface, fail the call silently
        //

        *Nt5Sd = CurrentSD;
    }

Error:

    if (NULL!=SDToFree)
    {
        MIDL_user_free(SDToFree);
        SDToFree = NULL;
    }

    return(NtStatus);


}

//--------------------------------------------------------------------------
//
// ACL conversion routines implement a small cache to quickly lookup if a given
// SID is of Admin nature or not. This allows us to not take the hit of looking
// up a reverse membership list when looking up domain controllers
//

ACL_CONVERSION_CACHE SampAclConversionCache;

NTSTATUS
SampInitializeAclConversionCache()
/*++

  Routine Description

  This routine initializes the ACL conversion cache.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Set a high spin count so that contentions do not result in
    // high context switch overhead.
    //

    NtStatus = RtlInitializeCriticalSectionAndSpinCount(
                    &SampAclConversionCache.Lock,
                    100
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Mark the Cache as Invalid
    //

    SampInvalidateAclConversionCache();

Error:

    return (NtStatus);
}


VOID
SampInvalidateAclConversionCache()
/*++

    Routine Description

    This routine invalidates the ACL conversion cache.


--*/
{
    ULONG i;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    NtStatus = RtlEnterCriticalSection(&SampAclConversionCache.Lock);
    if (!NT_SUCCESS(NtStatus))
    {
        //
        // Well Enter critical section failed. There is nothing we can do
        // about it. We cannot invalidate the cache without entering the critical
        // section.
        //


        return;
    }

    for (i=0;i<ACL_CONVERSION_CACHE_SIZE;i++)
    {
        SampAclConversionCache.Elements[i].fValid = FALSE;
    }

    RtlLeaveCriticalSection(&SampAclConversionCache.Lock);

}

BOOLEAN
SampLookupAclConversionCache(
    IN PSID SidToLookup,
    OUT BOOLEAN *fAdmin
    )
/*++

  This routine looks up in the acl conversion cache. The cache is hashed using the
  RID of the account. Hash conflicts are handled by simply throwing out the pre-
  existing entry

  Paramters

        SidToLookup -- The SID which we want to lookup
        fAdmin      -- On a successful lookup indicates and admin/non admin

   Return Values

        TRUE -- Successful lookup
        FALSE -- Failed lookup.


--*/
{

    BOOLEAN fMatch = FALSE;
    ULONG   Rid=0;
    ULONG   Hash=0;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Get the RID
    //

    Rid = *(RtlSubAuthoritySid(SidToLookup,*(RtlSubAuthorityCountSid(SidToLookup))-1));

    Hash = Rid % ACL_CONVERSION_CACHE_SIZE;

    //
    // Enter the Lock protecting the Cache
    //

    NtStatus = RtlEnterCriticalSection(&SampAclConversionCache.Lock);

    //
    // If we cannot grab a critical section exit without declaring a match.
    //

    if (!NT_SUCCESS(NtStatus))
    {
        return(FALSE);
    }

    if ((SampAclConversionCache.Elements[Hash].fValid) &&
        (RtlEqualSid(&SampAclConversionCache.Elements[Hash].SidOfPrincipal,SidToLookup)))
    {
        //
        // Test Succeeded . Call it a match
        //

         *fAdmin = SampAclConversionCache.Elements[Hash].fAdmin;
         fMatch = TRUE;
    }

    RtlLeaveCriticalSection(&SampAclConversionCache.Lock);

    return(fMatch);
}


VOID
SampAddToAclConversionCache(
    IN PSID SidToAdd,
    IN BOOLEAN fAdmin
    )
/*++

  Routine Description

    This routine adds a SID to the ACL conversion cache. The Cache is hashed by RID and
    hash conflicts are handled by throwing out the existing entry.

  Parameters

    Sid -- Sid to Add
    fAdmin -- Indicates that the concerned SID is a member of
              the administrators group.

  Return Values

    None ( Void Function )

--*/
{
    ULONG   Rid=0;
    ULONG   Hash=0;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Get the RID
    //

    Rid = *(RtlSubAuthoritySid(SidToAdd,*(RtlSubAuthorityCountSid(SidToAdd))-1));

    Hash = Rid % (ACL_CONVERSION_CACHE_SIZE);

    //
    // Enter the Lock protecting the Cache
    //

    NtStatus = RtlEnterCriticalSection(&SampAclConversionCache.Lock);

    //
    // If we cannot grab a critical section exit doing anything
    //

    if (!NT_SUCCESS(NtStatus))
    {
        return;
    }

    //
    // Test if the entry already exists
    //

    if (!((SampAclConversionCache.Elements[Hash].fValid) &&
        (RtlEqualSid(&SampAclConversionCache.Elements[Hash].SidOfPrincipal,SidToAdd))))
    {
        //
        // Entry Does not already exist, add the entry
        //

        NtStatus = RtlCopySid(
                        sizeof(NT4SID),
                        &SampAclConversionCache.Elements[Hash].SidOfPrincipal,
                        SidToAdd
                        );

        if (NT_SUCCESS(NtStatus))
        {
            //
            // Successfully copied
            //

            SampAclConversionCache.Elements[Hash].fAdmin = fAdmin;
            SampAclConversionCache.Elements[Hash].fValid = TRUE;
        }

    }

    RtlLeaveCriticalSection(&SampAclConversionCache.Lock);
}

BOOLEAN
SampIsAttributeAccessGranted(
    IN PRTL_BITMAP AccessGranted,
    IN PRTL_BITMAP AccessRequested
    )
/*++

Routine  Description:

    This routine checks that all bits that are set in AccessRequested are
    also set in AccessGranted.  If so, then TRUE is returned; FALSE otherwise.

Parameters:

    See description.

Return Values

    See description.

--*/
{
    ULONG i;

    //
    // Check for both read and write
    //
    for (i = 0; i < MAX_SAM_ATTRS; i++) {
        if (RtlCheckBit(AccessRequested, i)
        && !RtlCheckBit(AccessGranted, i)) {
            return FALSE;
        }
    }
    return TRUE;
}

//
// This table is used to translate WhichFields in SamrSetInformationUser
// to SAM attributes, as well as provide an offset into the Context's
// attribute array.
//

struct
{
    ULONG WhichField;
    ULONG SamAttribute;

} SampWhichFieldToSamAttr [] =
{
    {USER_ALL_ADMINCOMMENT,          SAMP_USER_ADMIN_COMMENT},         
    {USER_ALL_CODEPAGE,              SAMP_FIXED_USER_CODEPAGE},        
    {USER_ALL_COUNTRYCODE,           SAMP_FIXED_USER_COUNTRY_CODE},    
    {USER_ALL_USERID,                SAMP_FIXED_USER_SID},             
    {USER_ALL_PRIMARYGROUPID,        SAMP_FIXED_USER_PRIMARY_GROUP_ID},
    {USER_ALL_USERNAME,              SAMP_USER_ACCOUNT_NAME},          
    {USER_ALL_USERCOMMENT,           SAMP_USER_USER_COMMENT},          
    {USER_ALL_FULLNAME,              SAMP_USER_FULL_NAME},             

    {USER_ALL_ACCOUNTEXPIRES,        SAMP_FIXED_USER_ACCOUNT_EXPIRES},
    {USER_ALL_PASSWORDLASTSET,       SAMP_FIXED_USER_PWD_LAST_SET},   
    {USER_ALL_USERACCOUNTCONTROL,    SAMP_FIXED_USER_ACCOUNT_CONTROL},
    {USER_ALL_PARAMETERS,            SAMP_USER_PARAMETERS},           

    {USER_ALL_BADPASSWORDCOUNT,      SAMP_FIXED_USER_BAD_PWD_COUNT}, 
    {USER_ALL_HOMEDIRECTORY,         SAMP_USER_HOME_DIRECTORY},      
    {USER_ALL_HOMEDIRECTORYDRIVE,    SAMP_USER_HOME_DIRECTORY_DRIVE},
    {USER_ALL_LASTLOGOFF,            SAMP_FIXED_USER_LAST_LOGOFF},   
    {USER_ALL_LASTLOGON,             SAMP_FIXED_USER_LAST_LOGON},    
    {USER_ALL_LOGONCOUNT,            SAMP_FIXED_USER_LOGON_COUNT},   
    {USER_ALL_LOGONHOURS,            SAMP_USER_LOGON_HOURS},         
    {USER_ALL_WORKSTATIONS,          SAMP_USER_WORKSTATIONS},        
    {USER_ALL_PROFILEPATH,           SAMP_USER_PROFILE_PATH},        
    {USER_ALL_SCRIPTPATH,            SAMP_USER_SCRIPT_PATH}         
};

VOID
SampSetAttributeAccess(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG SamAttribute,
    IN OUT PRTL_BITMAP AttributeAccessTable
    )
/*++

Routine  Description:

    This routine sets the appropriate bit in AttributesAccessTable that
    indicates that SamAttribute (as defined in mappings.h) is accessible.

Parameters:

    ObjectType -- the object type corresponding to the GrantedAccess
    
    SamAttribute -- #define of a SAM attribute in mappings.h
    
    AttributeAccessTable -- a bitmap of attributes

Return Values

    None.

--*/
{
    ULONG i;

    //
    // Only user object is supported now
    //
    ASSERT(ObjectType == SampUserObjectType);
    if (ObjectType == SampUserObjectType) {
        //
        // Find the element in the table
        //
        for (i = 0; i < ARRAY_COUNT(SampWhichFieldToSamAttr); i++) {
            if (SamAttribute == SampWhichFieldToSamAttr[i].SamAttribute) {
                RtlSetBits(AttributeAccessTable, i, 1);
                break;
            }
        }
    }

    return;
}

VOID
SampSetAttributeAccessWithWhichFields(
    IN ULONG WhichFields,
    IN OUT PRTL_BITMAP AttributeAccessTable
    )
/*++

Routine  Description:

    This routine sets the appropriate bits in AttributesAccessTable that
    indicates that the SamAttributes represented by the WhichFields are
    accessible.

Parameters:

    WhichFields -- from ntsam.h
    
    AttributeAccessTable -- a bitmap of attributes

Return Values

    None.

--*/
{
    ULONG i;
    for (i = 0; i < ARRAY_COUNT(SampWhichFieldToSamAttr); i++) {
        if (WhichFields & SampWhichFieldToSamAttr[i].WhichField) {
            RtlSetBits(AttributeAccessTable, i, 1);
        }
    }
}


VOID
SampNt4AccessToWritableAttributes(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ACCESS_MASK GrantedAccess,
    OUT PRTL_BITMAP Attributes
    )
/*++

Routine  Description:

    This routine sets what attributes are writeable based on the Nt4
    access mask.

Parameters:

    ObjectType -- the object type corresponding to the GrantedAccess
    
    GrantedAccess -- Nt4 access mask
    
    Attributes -- bitmap of attributes                

Return Values

    None.

--*/
{
    ULONG WhichFields = 0;

    ASSERT(ObjectType == SampUserObjectType);
    if (ObjectType == SampUserObjectType) {

        ULONG WhichFields = 0;
        if (GrantedAccess & USER_WRITE_PREFERENCES) {
            WhichFields |= USER_ALL_WRITE_PREFERENCES_MASK;
        }
    
        if (GrantedAccess & USER_WRITE_ACCOUNT) {
            WhichFields |= USER_ALL_WRITE_ACCOUNT_MASK;
        }
    
        SampSetAttributeAccessWithWhichFields(WhichFields,
                                              Attributes);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\secdescr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SecDescr.c

Abstract:

    This file contains services related to the establishment of and modification
    of security descriptors for SAM objects.

    Note that there are a couple of special security descriptors that this routine
    does not build.  These are the security descriptors for the DOMAIN_ADMIN group,
    the ADMIN user account, and the SAM object.  For the first release, in which
    creation of domains is not supported, the DOMAIN object's security descriptor
    is also not created here.

    These security descriptors are built by the program that initializes a SAM
    database.


Author:

    Jim Kelly    (JimK)  14-Oct-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <sdconvrt.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()
#include <dslayer.h>
#include <sdconvrt.h>
#include <samtrace.h>





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SampCheckForDescriptorRestrictions(
    IN PSAMP_OBJECT             Context,
    IN SAMP_OBJECT_TYPE         ObjectType,
    IN ULONG                    ObjectRid,
    IN PISECURITY_DESCRIPTOR_RELATIVE PassedSD
    );





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services available for use throughout SAM                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampInitializeDomainDescriptors(
    ULONG Index
    )
/*++


Routine Description:

    This routine initializes security descriptors needed to protect
    user, group, and alias objects.

    These security descriptors are placed in the SampDefinedDomains[] array.

    This routine expects all SIDs to be previously initialized.

    The following security descriptors are prepared:

            AdminUserSD - Contains a SD appropriate for applying to
                a user object that is a member of the ADMINISTRATORS
                alias.

            AdminGroupSD - Contains a SD appropriate for applying to
                a group object that is a member of the ADMINISTRATORS
                alias.

            NormalUserSD - Contains a SD appropriate for applying to
                a user object that is NOT a member of the ADMINISTRATORS
                alias.

            NormalGroupSD - Contains a SD appropriate for applying to
                a Group object that is NOT a member of the ADMINISTRATORS
                alias.

            NormalAliasSD - Contains a SD appropriate for applying to
                newly created alias objects.



    Additionally, the following related information is provided:

            AdminUserRidPointer
            NormalUserRidPointer

                Points to the last RID of the ACE in the corresponding
                SD's DACL which grants access to the user.  This rid
                must be replaced with the user's rid being the SD is
                applied to the user object.



            AdminUserSDLength
            AdminGroupSDLength
            NormalUserSDLength
            NormalGroupSDLength
            NormalAliasSDLength

                The length, in bytes, of the corresponding security
                descriptor.




Arguments:

    Index - The index of the domain whose security descriptors are being
        created.  The Sid field of this domain's data structure is already
        expected to be set.

Return Value:

    STATUS_SUCCESS - The security descriptors have been successfully initialized.

    STATUS_INSUFFICIENT_RESOURCES - Heap could not be allocated to produce the needed
        security descriptors.

--*/
{

    NTSTATUS Status;
    ULONG Size;

    PSID AceSid[10];          // Don't expect more than 10 ACEs in any of these.
    ACCESS_MASK AceMask[10];  // Access masks corresponding to Sids

    GENERIC_MAPPING  AliasMap     =  {ALIAS_READ,
                                      ALIAS_WRITE,
                                      ALIAS_EXECUTE,
                                      ALIAS_ALL_ACCESS
                                      };

    GENERIC_MAPPING  GroupMap     =  {GROUP_READ,
                                      GROUP_WRITE,
                                      GROUP_EXECUTE,
                                      GROUP_ALL_ACCESS
                                      };

    GENERIC_MAPPING  UserMap      =  {USER_READ,
                                      USER_WRITE,
                                      USER_EXECUTE,
                                      USER_ALL_ACCESS
                                      };


    SID_IDENTIFIER_AUTHORITY
            BuiltinAuthority      =   SECURITY_NT_AUTHORITY;


    ULONG   AdminsSidBuffer[8],
            AccountSidBuffer[8];

    PSID    AdminsAliasSid        =   &AdminsSidBuffer[0],
            AccountAliasSid       =   &AccountSidBuffer[0],
            AnySidInAccountDomain =   NULL;

    SAMTRACE("SampInitializeDomainDescriptors");


    //
    // Make sure the buffer we've alloted for the simple sids above
    // are large enough.
    //
    //
    //      ADMINISTRATORS and ACCOUNT_OPERATORS aliases
    //      are  is S-1-5-20-x (2 sub-authorities)
    //
    ASSERT( RtlLengthRequiredSid(2) <= ( 8 * sizeof(ULONG) ) );


    ////////////////////////////////////////////////////////////////////////////////////
    //                                                                                //
    // Initialize the SIDs we'll need.
    //                                                                                //
    ////////////////////////////////////////////////////////////////////////////////////


    RtlInitializeSid( AdminsAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AdminsAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AdminsAliasSid,  1 )) = DOMAIN_ALIAS_RID_ADMINS;

    RtlInitializeSid( AccountAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AccountAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AccountAliasSid,  1 )) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;

    //
    // Initialize a SID that can be used to represent accounts
    // in this domain.
    //
    // This is the same as the domain sid found in the DefinedDomains[]
    // array except it has one more sub-authority.
    // It doesn't matter what the value of the last RID is because it
    // is always replaced before use.
    //

    Size = RtlLengthSid( SampDefinedDomains[Index].Sid ) + sizeof(ULONG);
    AnySidInAccountDomain = RtlAllocateHeap( RtlProcessHeap(), 0, Size);
    if (NULL==AnySidInAccountDomain)
    {
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( AnySidInAccountDomain != NULL );
    Status = RtlCopySid(
                Size,
                AnySidInAccountDomain,
                SampDefinedDomains[Index].Sid );
    ASSERT(NT_SUCCESS(Status));
    (*RtlSubAuthorityCountSid( AnySidInAccountDomain )) += 1;








    ///////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    //
    //
    //
    //
    //   The following security is assigned to groups that are made
    //   members of the ADMINISTRATORS alias.
    //
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant               Grant
    //              WORLD               Administrators
    //              (Execute | Read)    GenericAll
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //   All other aliases and groups must be assigned the following
    //   security:
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant               Grant           Grant
    //              WORLD               Administrators  AccountOperators Alias
    //              (Execute | Read)    GenericAll      GenericAll
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //
    //
    //   The following security is assigned to users  that are made a
    //   member of the ADMINISTRATORS alias.  This includes direct
    //   inclusion or indirect inclusion through group membership.
    //
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant            Grant          Grant
    //              WORLD            Administrators User's SID
    //              (Execute | Read) GenericAll     GenericWrite
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //
    //   All other users must be assigned the following
    //   security:
    //
    //      Owner: AccountOperators Alias
    //      Group: AccountOperators Alias
    //
    //      Dacl:   Grant            Grant          Grant                   Grant
    //              WORLD            Administrators Account Operators Alias User's SID
    //              (Execute | Read) GenericAll     GenericAll              GenericWrite
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //
    // Note  that because we are going to cram these ACLs directly
    // into the backing store, we must map the generic accesses
    // beforehand.
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //
    ///////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////





    //
    // We're not particularly good about freeing memory on error
    // conditions below.  Generally speaking, if this doens't
    // initialize correctly, the system is hosed.
    //


    //
    // Normal Alias SD
    //

    AceSid[0]  = SampWorldSid;
    AceMask[0] = (ALIAS_EXECUTE | ALIAS_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (ALIAS_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (ALIAS_ALL_ACCESS);


    Status = SampBuildSamProtection(
                 SampWorldSid,                          // WorldSid
                 AdminsAliasSid,                        // AdminsAliasSid
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &AliasMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampDefinedDomains[Index].NormalAliasSDLength, // Descriptor
                 &SampDefinedDomains[Index].NormalAliasSD,       // Descriptor
                 NULL                                            // RidToReplace
                 );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }





    //
    // Admin Group SD
    //

    AceSid[0]  = SampWorldSid;
    AceMask[0] = (GROUP_EXECUTE | GROUP_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (GROUP_ALL_ACCESS);


    Status = SampBuildSamProtection(
                 SampWorldSid,                          // WorldSid
                 AdminsAliasSid,                        // AdminsAliasSid
                 2,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &GroupMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampDefinedDomains[Index].AdminGroupSDLength,  // Descriptor
                 &SampDefinedDomains[Index].AdminGroupSD,        // Descriptor
                 NULL                                           // RidToReplace
                 );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }



    //
    // Normal GROUP SD
    //

    AceSid[0]  = SampWorldSid;
    AceMask[0] = (GROUP_EXECUTE | GROUP_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (GROUP_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (GROUP_ALL_ACCESS);


    Status = SampBuildSamProtection(
                 SampWorldSid,                          // WorldSid
                 AdminsAliasSid,                        // AdminsAliasSid
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &GroupMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampDefinedDomains[Index].NormalGroupSDLength,  // Descriptor
                 &SampDefinedDomains[Index].NormalGroupSD,        // Descriptor
                 NULL                                             // RidToReplace
                 );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }




    //
    // Admin User SD
    //

    AceSid[0]  = SampWorldSid;
    AceMask[0] = (USER_EXECUTE | USER_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (USER_ALL_ACCESS);

    AceSid[2]  = AnySidInAccountDomain;
    AceMask[2] = (USER_WRITE);


    Status = SampBuildSamProtection(
                 SampWorldSid,                          // WorldSid
                 AdminsAliasSid,                        // AdminsAliasSid
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &UserMap,                              // GenericMap
                 TRUE,                                  // Not user object
                 &SampDefinedDomains[Index].AdminUserSDLength,  // Descriptor
                 &SampDefinedDomains[Index].AdminUserSD,        // Descriptor
                 &SampDefinedDomains[Index].AdminUserRidPointer // RidToReplace
                 );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }



    //
    // Normal User SD
    //

    AceSid[0]  = SampWorldSid;
    AceMask[0] = (USER_EXECUTE | USER_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (USER_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (USER_ALL_ACCESS);

    AceSid[3]  = AnySidInAccountDomain;
    AceMask[3] = (USER_WRITE);


    Status = SampBuildSamProtection(
                 SampWorldSid,                          // WorldSid
                 AdminsAliasSid,                        // AdminsAliasSid
                 4,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &UserMap,                              // GenericMap
                 TRUE,                                  // Not user object
                 &SampDefinedDomains[Index].NormalUserSDLength,  // Descriptor
                 &SampDefinedDomains[Index].NormalUserSD,        // Descriptor
                 &SampDefinedDomains[Index].NormalUserRidPointer // RidToReplace
                 );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }

done:


    RtlFreeHeap( RtlProcessHeap(), 0, AnySidInAccountDomain );


    return(Status);

}


NTSTATUS
SampBuildSamProtection(
    IN PSID WorldSid,
    IN PSID AdminsAliasSid,
    IN ULONG AceCount,
    IN PSID AceSid[],
    IN ACCESS_MASK AceMask[],
    IN PGENERIC_MAPPING GenericMap,
    IN BOOLEAN UserObject,
    OUT PULONG DescriptorLength,
    OUT PSECURITY_DESCRIPTOR *Descriptor,
    OUT PULONG *RidToReplace OPTIONAL
    )

/*++


Routine Description:

    This routine builds a self-relative security descriptor ready
    to be applied to one of the SAM objects.

    If so indicated, a pointer to the last RID of the SID in the last
    ACE of the DACL is returned and a flag set indicating that the RID
    must be replaced before the security descriptor is applied to an object.
    This is to support USER object protection, which must grant some
    access to the user represented by the object.

    The owner and group of each security descriptor will be set
    to:

                    Owner:  Administrators Alias
                    Group:  Administrators Alias


    The SACL of each of these objects will be set to:


                    Audit
                    Success | Fail
                    WORLD
                    (Write | Delete | WriteDacl | AccessSystemSecurity)



Arguments:

    AceCount - The number of ACEs to be included in the DACL.

    AceSid - Points to an array of SIDs to be granted access by the DACL.
        If the target SAM object is a User object, then the last entry
        in this array is expected to be the SID of an account within the
        domain with the last RID not yet set.  The RID will be set during
        actual account creation.

    AceMask - Points to an array of accesses to be granted by the DACL.
        The n'th entry of this array corresponds to the n'th entry of
        the AceSid array.  These masks should not include any generic
        access types.

    GenericMap - Points to a generic mapping for the target object type.


    UserObject - Indicates whether the target SAM object is a User object
        or not.  If TRUE (it is a User object), then the resultant
        protection will be set up indicating Rid replacement is necessary.


    DescriptorLength - Receives the length of the resultant SD.

    Descriptor - Receives a pointer to the resultant SD.

    RidToReplace - Is required aif userObject is TRUE and will be set
        to point to the user's RID.


Return Value:

    TBS.

--*/
{

    NTSTATUS                Status;

    SECURITY_DESCRIPTOR     Absolute;
    PSECURITY_DESCRIPTOR    Relative;
    PACL                    TmpAcl;
    PACCESS_ALLOWED_ACE     TmpAce;
    PSID                    TmpSid;
    ULONG                   Length, i;
    PULONG                  RidLocation = NULL;
    BOOLEAN                 IgnoreBoolean;
    ACCESS_MASK             MappedMask;

    SAMTRACE("SampBuildSamProtection");

    //
    // The approach is to set up an absolute security descriptor that
    // looks like what we want and then copy it to make a self-relative
    // security descriptor.
    //


    Status = RtlCreateSecurityDescriptor(
                 &Absolute,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    ASSERT( NT_SUCCESS(Status) );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }



    //
    // Owner
    //

    Status = RtlSetOwnerSecurityDescriptor (&Absolute, AdminsAliasSid, FALSE );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }



    //
    // Group
    //

    Status = RtlSetGroupSecurityDescriptor (&Absolute, AdminsAliasSid, FALSE );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }




    //
    // Discretionary ACL
    //
    //      Calculate its length,
    //      Allocate it,
    //      Initialize it,
    //      Add each ACE
    //      Add it to the security descriptor
    //

    Length = (ULONG)sizeof(ACL);
    for (i=0; i<AceCount; i++) {

        Length += RtlLengthSid( AceSid[i] ) +
                  (ULONG)sizeof(ACCESS_ALLOWED_ACE) -
                  (ULONG)sizeof(ULONG);  //Subtract out SidStart field length
    }

    TmpAcl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(TmpAcl != NULL);
    if (NULL==TmpAcl)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = RtlCreateAcl( TmpAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    for (i=0; i<AceCount; i++) {
        MappedMask = AceMask[i];
        RtlMapGenericMask( &MappedMask, GenericMap );
        Status = RtlAddAccessAllowedAce (
                     TmpAcl,
                     ACL_REVISION2,
                     MappedMask,
                     AceSid[i]
                     );
        ASSERT( NT_SUCCESS(Status) );
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }
    }

    Status = RtlSetDaclSecurityDescriptor (&Absolute, TRUE, TmpAcl, FALSE );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }




    //
    // Sacl
    //


    Length = (ULONG)sizeof(ACL) +
             RtlLengthSid( WorldSid ) +
             RtlLengthSid( SampAnonymousSid ) +
             2*((ULONG)sizeof(SYSTEM_AUDIT_ACE) - (ULONG)sizeof(ULONG));  //Subtract out SidStart field length
    TmpAcl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(TmpAcl != NULL);
    if (NULL==TmpAcl)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = RtlCreateAcl( TmpAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = RtlAddAuditAccessAce (
                 TmpAcl,
                 ACL_REVISION2,
                 (GenericMap->GenericWrite | DELETE | WRITE_DAC | ACCESS_SYSTEM_SECURITY)& ~READ_CONTROL,
                 WorldSid,
                 TRUE,          //AuditSuccess,
                 TRUE           //AuditFailure
                 );
    ASSERT( NT_SUCCESS(Status) );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = RtlAddAuditAccessAce (
                 TmpAcl,
                 ACL_REVISION2,
                 GenericMap->GenericWrite | STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                 SampAnonymousSid,
                 TRUE,          //AuditSuccess,
                 TRUE           //AuditFailure
                 );
    ASSERT( NT_SUCCESS(Status) );
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = RtlSetSaclSecurityDescriptor (&Absolute, TRUE, TmpAcl, FALSE );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }






    //
    // Convert the Security Descriptor to Self-Relative
    //
    //      Get the length needed
    //      Allocate that much memory
    //      Copy it
    //      Free the generated absolute ACLs
    //

    Length = 0;
    Status = RtlAbsoluteToSelfRelativeSD( &Absolute, NULL, &Length );
    ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

    Relative = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(Relative != NULL);
    if (NULL==Relative)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Status = RtlAbsoluteToSelfRelativeSD(&Absolute, Relative, &Length );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }


    RtlFreeHeap( RtlProcessHeap(), 0, Absolute.Dacl );
    RtlFreeHeap( RtlProcessHeap(), 0, Absolute.Sacl );




    //
    // If the object is a user object, then get the address of the
    // last RID of the SID in the last ACE in the DACL.
    //

    if (UserObject == TRUE) {

        Status = RtlGetDaclSecurityDescriptor(
                    Relative,
                    &IgnoreBoolean,
                    &TmpAcl,
                    &IgnoreBoolean
                    );
        ASSERT(NT_SUCCESS(Status));
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }
        Status = RtlGetAce ( TmpAcl, AceCount-1, (PVOID *)&TmpAce );
        ASSERT(NT_SUCCESS(Status));
        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }
        TmpSid = (PSID)(&TmpAce->SidStart),

        RidLocation = RtlSubAuthoritySid(
                          TmpSid,
                          (ULONG)(*RtlSubAuthorityCountSid( TmpSid ) - 1)
                          );
    }


    //
    // Set the result information
    //

    (*DescriptorLength) = Length;
    (*Descriptor)       = Relative;
    if (ARGUMENT_PRESENT(RidToReplace)) {
        ASSERT(UserObject && "Must be User Object\n");
        (*RidToReplace) = RidLocation;
    }



    return(Status);

}

NTSTATUS
SampGetNewAccountSecurity(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN RestrictCreatorAccess,
    IN ULONG NewAccountRid,
    IN PSAMP_OBJECT Context OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    )


/*++

Routine Description:

    This service creates a standard self-relative security descriptor
    for a new USER, GROUP or ALIAS account.


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


Arguments:

    ObjectType - Indicates the type of account for which a new security
        descriptor is required.  This must be either SampGroupObjectType
        or SampUserObjectType.

    Admin - if TRUE, indicates the security descriptor will be protecting
        an object that is an admin object (e.g., is a member, directly
        or indirectly, of the ADMINISTRATORS alias).

    TrustedClient - Indicates whether the client is a trusted client
        or not.  TRUE indicates the client is trusted, FALSE indicates
        the client is not trusted.

    RestrictCreatorAccess - Indicates whether or not the creator's
        access to the object is to be restricted according to
        specific rules.  Also indicates whether or not the account
        is to be given any access to itself.  An account will only
        be given access to itself if there are no creator access
        restrictions.

        The following ObjectTypes have restriction rules that may
        be requested:

            User:
                    - Admin is assigned as owner of the object.
                    - Creator is given (DELETE | USER_WRITE) access.


    NewAccountRid - The relative ID of the new account.

        Context - In the DS case this context gives an open context to the object
                in question. This open context is used to consider the class of the
                DS object while constucting the security descriptor.

    NewDescriptor - Receives a pointer to the new account's self-relative
        security descriptor.  Be sure to free this descriptor with
        MIDL_user_free() when done.

    DescriptorLength - Receives the length (in bytes) of the returned
        security descriptor


Return Value:

    STATUS_SUCCESS - A new security descriptor has been produced.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to
        produce the security descriptor.



--*/

{

    NTSTATUS    NtStatus;

    //
    // Check wether we are running from the DS. If yes then we should
    // call the new SampBuildNt5Protection call
    //

    if (IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context))
    {
        //
        //  If we are using the Ds, then we should never be constructing a default
        //  security descriptor, but rather getting the security descriptor from
        //  the schema.
        //

        ASSERT(FALSE);
        NtStatus = STATUS_INTERNAL_ERROR;


    }
    else
    {
        NtStatus = SampGetNewAccountSecurityNt4(
                        ObjectType,
                        Admin,
                        TrustedClient,
                        RestrictCreatorAccess,
                        NewAccountRid,
                        SampTransactionDomainIndex,
                        NewDescriptor,
                        DescriptorLength
                        );
    }

    return NtStatus;
}




NTSTATUS
SampGetNewAccountSecurityNt4(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN RestrictCreatorAccess,
    IN ULONG NewAccountRid,
    IN ULONG   DomainIndex,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    )


/*++

Routine Description:

    This service creates a standard self-relative security descriptor
    for a new USER, GROUP or ALIAS account.


   
Arguments:

    ObjectType - Indicates the type of account for which a new security
        descriptor is required.  This must be either SampGroupObjectType
        or SampUserObjectType.

    Admin - if TRUE, indicates the security descriptor will be protecting
        an object that is an admin object (e.g., is a member, directly
        or indirectly, of the ADMINISTRATORS alias).

    TrustedClient - Indicates whether the client is a trusted client
        or not.  TRUE indicates the client is trusted, FALSE indicates
        the client is not trusted.

    RestrictCreatorAccess - Indicates whether or not the creator's
        access to the object is to be restricted according to
        specific rules.  Also indicates whether or not the account
        is to be given any access to itself.  An account will only
        be given access to itself if there are no creator access
        restrictions.

        The following ObjectTypes have restriction rules that may
        be requested:

            User:
                    - Admin is assigned as owner of the object.
                    - Creator is given (DELETE | USER_WRITE) access.


    NewAccountRid - The relative ID of the new account.

    NewDescriptor - Receives a pointer to the new account's self-relative
        security descriptor.  Be sure to free this descriptor with
        MIDL_user_free() when done.

    DescriptorLength - Receives the length (in bytes) of the returned
        security descriptor


Return Value:

    STATUS_SUCCESS - A new security descriptor has been produced.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to
        produce the security descriptor.



--*/

{
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    ULONG                AccountSidBuffer[8];
    PSID                 AccountAliasSid = &AccountSidBuffer[0];

    SECURITY_DESCRIPTOR  DaclDescriptor;
    NTSTATUS             NtStatus = STATUS_SUCCESS;
    NTSTATUS             IgnoreStatus;
    HANDLE               ClientToken = INVALID_HANDLE_VALUE;
    ULONG                DataLength = 0;
    ACCESS_ALLOWED_ACE   *NewAce = NULL;
    PACL                 NewDacl = NULL;
    PACL                 OldDacl = NULL;
    PSECURITY_DESCRIPTOR StaticDescriptor = NULL;
    PSECURITY_DESCRIPTOR LocalDescriptor = NULL;
    PTOKEN_GROUPS        ClientGroups = NULL;
    PTOKEN_OWNER         SubjectOwner = NULL;
    PSID                 SubjectSid = NULL;
    ULONG                AceLength = 0;
    ULONG                i;
    BOOLEAN              AdminAliasFound = FALSE;
    BOOLEAN              AccountAliasFound = FALSE;
    BOOLEAN              DaclPresent, DaclDefaulted;

    GENERIC_MAPPING GenericMapping;
    GENERIC_MAPPING AliasMap     =  {ALIAS_READ,
                                     ALIAS_WRITE,
                                     ALIAS_EXECUTE,
                                     ALIAS_ALL_ACCESS
                                     };

    GENERIC_MAPPING GroupMap     =  {GROUP_READ,
                                     GROUP_WRITE,
                                     GROUP_EXECUTE,
                                     GROUP_ALL_ACCESS
                                     };

    GENERIC_MAPPING UserMap      =  {USER_READ,
                                     USER_WRITE,
                                     USER_EXECUTE,
                                     USER_ALL_ACCESS
                                     };

    BOOLEAN              ImpersonatingNullSession = FALSE;

    SAMTRACE("SampGetNewAccountSecurity");

    //
    // Security account objects don't pick up security in the normal
    // fashion in the release 1 timeframe.  They are assigned a well-known
    // security descriptor based upon their object type.
    //
    // Notice that all the accounts with tricky security are created when
    // the domain is created (e.g., admin groups and admin user account).
    //

    switch (ObjectType) {

    case SampGroupObjectType:

        ASSERT(RestrictCreatorAccess == FALSE);

        //
        // NewAccountRid parameter is ignored for groups.
        //

        if (Admin == TRUE) {

            StaticDescriptor =
                SampDefinedDomains[DomainIndex].AdminGroupSD;
            (*DescriptorLength) =
                SampDefinedDomains[DomainIndex].AdminGroupSDLength;
        } else {

            StaticDescriptor =
                SampDefinedDomains[DomainIndex].NormalGroupSD;
            (*DescriptorLength) =
                SampDefinedDomains[DomainIndex].NormalGroupSDLength;
        }

        GenericMapping = GroupMap;

        break;


    case SampAliasObjectType:

        ASSERT(RestrictCreatorAccess == FALSE);

        //
        // Admin and NewAccountRid parameters are ignored for aliases.
        //

        StaticDescriptor =
            SampDefinedDomains[DomainIndex].NormalAliasSD;
        (*DescriptorLength) =
            SampDefinedDomains[DomainIndex].NormalAliasSDLength;

        GenericMapping = AliasMap;

        break;


    case SampUserObjectType:

        if (Admin == TRUE) {

            StaticDescriptor =
                SampDefinedDomains[DomainIndex].AdminUserSD;
            (*DescriptorLength) =
                SampDefinedDomains[DomainIndex].AdminUserSDLength;
            (*SampDefinedDomains[DomainIndex].AdminUserRidPointer)
                = NewAccountRid;

        } else {

            StaticDescriptor =
                SampDefinedDomains[DomainIndex].NormalUserSD;
            (*DescriptorLength) =
                SampDefinedDomains[DomainIndex].NormalUserSDLength;
            (*SampDefinedDomains[DomainIndex].NormalUserRidPointer)
                = NewAccountRid;
        }

        GenericMapping = UserMap;

        break;

    }

    //
    // We have a pointer to SAM's static security descriptor.  Copy it
    // into a heap buffer that RtlSetSecurityObject() will like.
    //

    LocalDescriptor = RtlAllocateHeap( RtlProcessHeap(), 0, (*DescriptorLength) );

    if ( LocalDescriptor == NULL ) {

        (*NewDescriptor) = NULL;
        (*DescriptorLength) = 0;

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory(
        LocalDescriptor,
        StaticDescriptor,
        (*DescriptorLength)
        );

    //
    // If the caller is to have restricted access to this account,
    // then remove the last ACE from the ACL (the one intended for
    // the account itself).
    //

    if (RestrictCreatorAccess) {
        NtStatus = RtlGetDaclSecurityDescriptor(
                       LocalDescriptor,
                       &DaclPresent,
                       &OldDacl,
                       &DaclDefaulted
                       );
        ASSERT(NT_SUCCESS(NtStatus));
        ASSERT(DaclPresent);
        ASSERT(OldDacl->AceCount >= 1);

        OldDacl->AceCount -= 1;  // Remove the last ACE from the ACL.
    }


    //
    // If the caller is not a trusted client, see if the caller is an
    // administrator or an account operator.  If not, add an ACCESS_ALLOWED
    // ACE to the DACL that gives full access to the creator (or restricted
    // access, if so specified).
    //

    if ( !TrustedClient ) {

        NtStatus = SampImpersonateClient(&ImpersonatingNullSession);

        if (NT_SUCCESS(NtStatus)) {   // if (ImpersonatingClient)

            NtStatus = NtOpenThreadToken(
                           NtCurrentThread(),
                           TOKEN_QUERY,
                           TRUE,            //OpenAsSelf
                           &ClientToken
                           );

            //
            // Stop impersonating the client
            //

            SampRevertToSelf(ImpersonatingNullSession);

            if (NT_SUCCESS(NtStatus)) {     // if (TokenOpened)




                //
                // See if the caller is an administrator or an account
                // operator.  First, see how big
                // a buffer we need to hold the caller's groups.
                //

                NtStatus = NtQueryInformationToken(
                               ClientToken,
                               TokenGroups,
                               NULL,
                               0,
                               &DataLength
                               );

                if ( ( NtStatus == STATUS_BUFFER_TOO_SMALL ) &&
                    ( DataLength > 0 ) ) {

                    ClientGroups = MIDL_user_allocate( DataLength );

                    if ( ClientGroups == NULL ) {

                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

                        //
                        // Now get a list of the caller's groups.
                        //

                        NtStatus = NtQueryInformationToken(
                                       ClientToken,
                                       TokenGroups,
                                       ClientGroups,
                                       DataLength,
                                       &DataLength
                                       );

                        if ( NT_SUCCESS( NtStatus ) ) {


                            //
                            // Build the SID of the ACCOUNT_OPS alias, so we
                            // can see if the user is included in it.
                            //

                            RtlInitializeSid(
                                AccountAliasSid,
                                &BuiltinAuthority,
                                2 );

                            *(RtlSubAuthoritySid( AccountAliasSid,  0 )) =
                                SECURITY_BUILTIN_DOMAIN_RID;

                            *(RtlSubAuthoritySid( AccountAliasSid,  1 )) =
                                DOMAIN_ALIAS_RID_ACCOUNT_OPS;

                            //
                            // See if the ADMIN or ACCOUNT_OPS alias is in
                            // the caller's groups.
                            //

                            for ( i = 0; i < ClientGroups->GroupCount; i++ ) {

                                SubjectSid = ClientGroups->Groups[i].Sid;
                                ASSERT( SubjectSid != NULL );

                                if ( RtlEqualSid( SubjectSid, SampAdministratorsAliasSid  ) ) {

                                    AdminAliasFound = TRUE;
                                    break;
                                }
                                if ( RtlEqualSid( SubjectSid, AccountAliasSid ) ) {

                                    AccountAliasFound = TRUE;
                                    break;
                                }
                            }

                            //
                            // If the callers groups did not include the admins
                            // alias, add an ACCESS_ALLOWED ACE for the owner.
                            //

                            if ( !AdminAliasFound && !AccountAliasFound ) {

                                //
                                // First, find out what size buffer we need
                                // to get the owner.
                                //

                                NtStatus = NtQueryInformationToken(
                                               ClientToken,
                                               TokenOwner,
                                               NULL,
                                               0,
                                               &DataLength
                                               );

                                if ( ( NtStatus == STATUS_BUFFER_TOO_SMALL ) &&
                                    ( DataLength > 0 ) ) {

                                    SubjectOwner = MIDL_user_allocate( DataLength );

                                    if ( SubjectOwner == NULL ) {

                                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                                    } else {

                                        //
                                        // Now, query the owner that will be
                                        // given access to the object
                                        // created.
                                        //

                                        NtStatus = NtQueryInformationToken(
                                                       ClientToken,
                                                       TokenOwner,
                                                       SubjectOwner,
                                                       DataLength,
                                                       &DataLength
                                                       );

                                        if ( NT_SUCCESS( NtStatus ) ) {

                                            //
                                            // Create an ACE that gives the
                                            // owner full access.
                                            //

                                            AceLength = sizeof( ACE_HEADER ) +
                                                        sizeof( ACCESS_MASK ) +
                                                        RtlLengthSid(
                                                            SubjectOwner->Owner );

                                            NewAce = (ACCESS_ALLOWED_ACE *)
                                                    MIDL_user_allocate( AceLength );

                                            if ( NewAce == NULL ) {

                                                NtStatus =
                                                    STATUS_INSUFFICIENT_RESOURCES;

                                            } else {

                                                NewAce->Header.AceType =
                                                    ACCESS_ALLOWED_ACE_TYPE;

                                                NewAce->Header.AceSize = (USHORT) AceLength;
                                                NewAce->Header.AceFlags = 0;
                                                NewAce->Mask = USER_ALL_ACCESS;

                                                //
                                                // If the creator's access is
                                                // to be restricted, change the
                                                // AccessMask.
                                                //

                                                if (RestrictCreatorAccess) {
                                                    NewAce->Mask = DELETE     |
                                                                   USER_WRITE |
                                                                   USER_FORCE_PASSWORD_CHANGE;
                                                }

                                                RtlCopySid(
                                                    RtlLengthSid(
                                                        SubjectOwner->Owner ),
                                                    (PSID)( &NewAce->SidStart ),
                                                    SubjectOwner->Owner );

                                                //
                                                // Allocate a new, larger ACL and
                                                // copy the old one into it.
                                                //

                                                NtStatus =
                                                    RtlGetDaclSecurityDescriptor(
                                                        LocalDescriptor,
                                                        &DaclPresent,
                                                        &OldDacl,
                                                        &DaclDefaulted
                                                        );

                                                if ( NT_SUCCESS( NtStatus ) ) {

                                                    NewDacl = MIDL_user_allocate(
                                                                  OldDacl->AclSize +
                                                                  AceLength );

                                                    if ( NewDacl == NULL ) {

                                                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                                                    } else {

                                                        RtlCopyMemory(
                                                            NewDacl,
                                                            OldDacl,
                                                            OldDacl->AclSize
                                                            );

                                                        NewDacl->AclSize =
                                                            OldDacl->AclSize +
                                                            (USHORT) AceLength;

                                                        //
                                                        // Add the new ACE
                                                        // to the new ACL.
                                                        //

                                                        NtStatus = RtlAddAce(
                                                            NewDacl,
                                                            ACL_REVISION2,
                                                            1,                      // add after first ACE (world)
                                                            (PVOID)NewAce,
                                                            AceLength
                                                            );
                                                    }  // end_if (allocated NewDacl)
                                                } // end_if (get DACL from SD)
                                            } // end_if (allocated NewAce)
                                        } // end_if (Query TokenOwner Succeeded)
                                    } // end_if (Allocated TokenOwner buffer)
                                } // end_if (Query TokenOwner size Succeeded)
                            } // end_if (not admin)
                        } // end_if (Query TokenGroups Succeeded)
                    } // end_if (Allocated TokenGroups buffer)
                } // end_if (Query TokenGroups size Succeeded)

                IgnoreStatus = NtClose( ClientToken );
                ASSERT(NT_SUCCESS(IgnoreStatus));

            }  // end_if (TokenOpened)
        } // end_if (ImpersonatingClient)
    } // end_if (TrustedClient)

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        // If we created a new DACL above, stick it on the security
        // descriptor.
        //

        if ( NewDacl != NULL ) {

            NtStatus = RtlCreateSecurityDescriptor(
                           &DaclDescriptor,
                           SECURITY_DESCRIPTOR_REVISION1
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Set the DACL on the LocalDescriptor.  Note that this
                // call will RtlFreeHeap() the old descriptor, and allocate
                // a new one.
                //

                DaclDescriptor.Control = SE_DACL_PRESENT;
                DaclDescriptor.Dacl = NewDacl;

                NtStatus = RtlSetSecurityObject(
                               DACL_SECURITY_INFORMATION,
                               &DaclDescriptor,
                               &LocalDescriptor,
                               &GenericMapping,
                               NULL
                               );
            }
        }
    }

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        // Copy the security descriptor and length into buffers for the
        // caller.  AceLength is 0 if we didn't add an ACE to the DACL
        // above.
        //

        (*DescriptorLength) = (*DescriptorLength) + AceLength;

        (*NewDescriptor) = MIDL_user_allocate( (*DescriptorLength) );

        if ( (*NewDescriptor) == NULL ) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlCopyMemory(
                (*NewDescriptor),
                LocalDescriptor,
                (*DescriptorLength)
                );
        }
    }

    //
    // Free up local items that may have been allocated.
    //

    if ( LocalDescriptor != NULL ) {
        RtlFreeHeap( RtlProcessHeap(), 0, LocalDescriptor );
    }

    if ( ClientGroups != NULL ) {
        MIDL_user_free( ClientGroups );
    }

    if ( SubjectOwner != NULL ) {
        MIDL_user_free( SubjectOwner );
    }

    if ( NewAce != NULL ) {
        MIDL_user_free( NewAce );
    }

    if ( NewDacl != NULL ) {
        MIDL_user_free( NewDacl );
    }


    if ( !NT_SUCCESS( NtStatus ) ) {

        (*NewDescriptor) = NULL;
        (*DescriptorLength) = 0;
    }

    return( NtStatus );
}


NTSTATUS
SampModifyAccountSecurity(
    IN PSAMP_OBJECT Context,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Admin,
    IN PSECURITY_DESCRIPTOR OldDescriptor,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor,
    OUT PULONG DescriptorLength
    )
/*++

Routine Description:

    This service modifies a self-relative security descriptor
    for a USER or GROUP to add or remove account operator access.


Arguments:

    Context    -- Takes the Context of the object whose security Descriptor
       needs to be modified. The object's context is required in the DS
       case where information regarding the actual class of the object is
       used in constructing the security descriptor.

    ObjectType - Indicates the type of account for which a new security
        descriptor is required.  This must be either SampGroupObjectType
        or SampUserObjectType.

    Admin - if TRUE, indicates the security descriptor will be protecting
        an object that is an admin object (e.g., is a member, directly
        or indirectly, of the ADMINISTRATORS or an operator alias).

    NewDescriptor - Receives a pointer to the new account's self-relative
        security descriptor.  Be sure to free this descriptor with
        MIDL_user_free() when done.

    DescriptorLength - Receives the length (in bytes) of the returned
        security descriptor


Return Value:

    STATUS_SUCCESS - A new security descriptor has been produced.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to
        produce the security descriptor.



--*/

{
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    ULONG                AccountSidBuffer[8];
    PSID                 AccountAliasSid = &AccountSidBuffer[0];
    NTSTATUS             NtStatus = STATUS_SUCCESS;
    NTSTATUS             IgnoreStatus;
    ULONG                Length;
    ULONG                i,j;
    ULONG                AccountOpAceIndex;
    ULONG                AceCount;
    PACL                 OldDacl;
    PACL                 NewDacl = NULL;
    BOOLEAN              DaclDefaulted;
    BOOLEAN              DaclPresent;
    ACL_SIZE_INFORMATION AclSizeInfo;
    PACCESS_ALLOWED_ACE  Ace;
    PGENERIC_MAPPING     GenericMapping;
    ACCESS_MASK          AccountOpAccess;
    SECURITY_DESCRIPTOR  AbsoluteDescriptor;
    PSECURITY_DESCRIPTOR  LocalDescriptor = NULL;

    GENERIC_MAPPING GroupMap     =  {GROUP_READ,
                                     GROUP_WRITE,
                                     GROUP_EXECUTE,
                                     GROUP_ALL_ACCESS
                                     };

    GENERIC_MAPPING UserMap      =  {USER_READ,
                                     USER_WRITE,
                                     USER_EXECUTE,
                                     USER_ALL_ACCESS
                                     };

    SAMTRACE("SampModifyAccountSecurity");



    if (IsDsObject(Context))
    {
       //
           // We should never ever need to modify account security the way
           // NT4.0 used to do
           //

                ASSERT(FALSE);

    }
    else
    {



        NtStatus = RtlCopySecurityDescriptor(
                        OldDescriptor,
                        &LocalDescriptor
                        );

        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }

        //
        // Build the SID of the ACCOUNT_OPS alias, so we
        // can see if is in the DACL or we can add it to the DACL.
        //

        RtlInitializeSid(
            AccountAliasSid,
            &BuiltinAuthority,
            2
            );

        *(RtlSubAuthoritySid( AccountAliasSid,  0 )) =
            SECURITY_BUILTIN_DOMAIN_RID;

        *(RtlSubAuthoritySid( AccountAliasSid,  1 )) =
            DOMAIN_ALIAS_RID_ACCOUNT_OPS;

        //
        // The approach is to set up an absolute security descriptor that
        // contains the new DACL, and then merge that into the existing
        // security descriptor.
        //


        IgnoreStatus = RtlCreateSecurityDescriptor(
                            &AbsoluteDescriptor,
                            SECURITY_DESCRIPTOR_REVISION1
                            );
        ASSERT( NT_SUCCESS(IgnoreStatus) );

        //
        // Figure out the access granted to account operators and the
        // generic mask to use.
        //

        if (ObjectType == SampUserObjectType) {
            AccountOpAccess = USER_ALL_ACCESS;
            GenericMapping = &UserMap;
        } else if (ObjectType == SampGroupObjectType) {
            AccountOpAccess = GROUP_ALL_ACCESS;
            GenericMapping = &GroupMap;
        } else {
            //
            // This doesn't apply to aliases, domains, or servers.
            //
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Get the old DACL off the passed in security descriptor.
        //

        IgnoreStatus = RtlGetDaclSecurityDescriptor(
                            OldDescriptor,
                            &DaclPresent,
                            &OldDacl,
                            &DaclDefaulted
                            );

        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // We will only modify the DACL if it is present
        //

        if (!DaclPresent) {
            *NewDescriptor = LocalDescriptor;
            *DescriptorLength = RtlLengthSecurityDescriptor(LocalDescriptor);
            return(STATUS_SUCCESS);
        }

        //
        // Get the count of ACEs
        //

        IgnoreStatus = RtlQueryInformationAcl(
                            OldDacl,
                            &AclSizeInfo,
                            sizeof(AclSizeInfo),
                            AclSizeInformation
                            );


        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Calculate the lenght of the new ACL.
        //

        Length = (ULONG)sizeof(ACL);
        AccountOpAceIndex = 0xffffffff;


        for (i = 0; i < AclSizeInfo.AceCount; i++) {
            IgnoreStatus = RtlGetAce(
                                OldDacl,
                                i,
                                (PVOID *) &Ace
                                );
            ASSERT(NT_SUCCESS(IgnoreStatus));

            //
            // Check if this is an access allowed ACE, and the ACE is for
            // the Account Operators alias.
            //

            if ( (Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) &&
                 RtlEqualSid( AccountAliasSid,
                              &Ace->SidStart ) ) {

                AccountOpAceIndex = i;
                continue;
            }
            Length += Ace->Header.AceSize;
        }


        if (!Admin) {

            //
            // If we are making this account not be an admin account and it already
            // has an account operator ace, we are done.
            //

            if ( AccountOpAceIndex != 0xffffffff ) {

                *NewDescriptor = LocalDescriptor;
                *DescriptorLength = RtlLengthSecurityDescriptor(LocalDescriptor);
                return(STATUS_SUCCESS);
            } else {

                //
                // Add the size of an account operator ace to the required length
                //

                Length += sizeof(ACCESS_ALLOWED_ACE) +
                            RtlLengthSid(AccountAliasSid) -
                            sizeof(ULONG);
            }

        }

        NewDacl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

        if (NewDacl == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        IgnoreStatus = RtlCreateAcl( NewDacl, Length, ACL_REVISION2);
        ASSERT( NT_SUCCESS(IgnoreStatus) );

        //
        // Add the old ACEs back into this ACL.
        //

        for (i = 0, j = 0; i < AclSizeInfo.AceCount; i++) {
            if (i == AccountOpAceIndex) {
                ASSERT(Admin);
                continue;
            }
            //
            // Add back in the old ACEs
            //

            IgnoreStatus = RtlGetAce(
                                OldDacl,
                                i,
                                (PVOID *) &Ace
                                );
            ASSERT(NT_SUCCESS(IgnoreStatus));

            IgnoreStatus = RtlAddAce (
                                NewDacl,
                                ACL_REVISION2,
                                j,
                                Ace,
                                Ace->Header.AceSize
                                );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
        }

        //
        // If we are making this account not be an administrator, add the
        // access allowed ACE for the account operator. This ACE is always
        // the second to last one.
        //

        if (!Admin) {
            IgnoreStatus = RtlAddAccessAllowedAce(
                                NewDacl,
                                ACL_REVISION2,
                                AccountOpAccess,
                                AccountAliasSid
                                );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        //
        // Insert this DACL into the security descriptor.
        //

        IgnoreStatus = RtlSetDaclSecurityDescriptor (
                            &AbsoluteDescriptor,
                            TRUE,                   // DACL present
                            NewDacl,
                            FALSE                   // DACL not defaulted
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Now call RtlSetSecurityObject to merge the existing security descriptor
        // with the new DACL we just created.
        //


        NtStatus = RtlSetSecurityObject(
                        DACL_SECURITY_INFORMATION,
                        &AbsoluteDescriptor,
                        &LocalDescriptor,
                        GenericMapping,
                        NULL
                        );
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        *NewDescriptor = LocalDescriptor;
        *DescriptorLength = RtlLengthSecurityDescriptor(LocalDescriptor);
        LocalDescriptor = NULL;
    }
Cleanup:

    if ( NewDacl != NULL ) {
        RtlFreeHeap(RtlProcessHeap(),0, NewDacl );
    }
    if (LocalDescriptor != NULL) {
        RtlDeleteSecurityObject(&LocalDescriptor);
    }

    return( NtStatus );
}




NTSTATUS
SampGetObjectSD(
    IN PSAMP_OBJECT Context,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    This retrieves a security descriptor from a SAM object's backing store.




Arguments:

    Context - The object to which access is being requested.

    SecurityDescriptorLength - Receives the length of the security descriptor.

    SecurityDescriptor - Receives a pointer to the security descriptor.



Return Value:

    STATUS_SUCCESS - The security descriptor has been retrieved.

    STATUS_INTERNAL_DB_CORRUPTION - The object does not have a security descriptor.
        This is bad.


    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to retrieve the
        security descriptor.

    STATUS_UNKNOWN_REVISION - The security descriptor retrieved is no one known by
        this revision of SAM.



--*/
{

    NTSTATUS NtStatus;
    ULONG Revision;

    SAMTRACE("SampGetObjectSD");

    (*SecurityDescriptorLength) = 0;

    //
    // for server and domain object, get security descriptor from in memory 
    // cache. Any failure here is treated as a cache miss. 
    // In fact, there are only two errors returned
    // 
    //      Cached SD is not available - SAM has a separate thread to update it later.
    //                                   proceed with SampGetAccessAttribute() here 
    // 
    //      Resource failure - will return immediately
    // 

    if (IsDsObject(Context) &&
        (SampServerObjectType == Context->ObjectType ||SampDomainObjectType == Context->ObjectType)
        )
    {
        NtStatus = SampGetCachedObjectSD(
                        Context, 
                        SecurityDescriptorLength,
                        SecurityDescriptor
                        );

        //
        // STATUS_UNSUCCESSFUL from the above routine means a cache miss,
        // should proceed with SampGetAccessAttribute().
        // 
        // return for all the other cases.
        // 
        if (STATUS_UNSUCCESSFUL != NtStatus)
        {
            return( NtStatus );
        }
    }


    NtStatus = SampGetAccessAttribute(
                    Context,
                    SAMP_OBJECT_SECURITY_DESCRIPTOR,
                    TRUE, // Make copy
                    &Revision,
                    SecurityDescriptor
                    );

    if (NT_SUCCESS(NtStatus)) {

        if ( SAMP_UNKNOWN_REVISION( Revision ) )
        {
            NtStatus = STATUS_UNKNOWN_REVISION;
        }


        if (!NT_SUCCESS(NtStatus)) {
            MIDL_user_free( (*SecurityDescriptor) );
            *SecurityDescriptor = NULL;
        }
    }


    if (NT_SUCCESS(NtStatus)) {
        *SecurityDescriptorLength = GetSecurityDescriptorLength(
                                        (*SecurityDescriptor) );
    }

    return(NtStatus);
}


NTSTATUS
SampGetDomainObjectSDFromDsName(
    IN DSNAME   *DomainObjectDsName,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    This retrieves a security descriptor from a SAM object's backing store
    based upon the object's DS name. 
    
    MUST be running in DS mode


Arguments:

    DomainObjectDsName - The object to which access is being requested.

    SecurityDescriptorLength - Receives the length of the security descriptor.

    SecurityDescriptor - Receives a pointer to the security descriptor.



Return Value:

    STATUS_SUCCESS - The security descriptor has been retrieved.

    STATUS_INTERNAL_DB_CORRUPTION - The object does not have a security descriptor.
        This is bad.


    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to retrieve the
        security descriptor.

    STATUS_UNKNOWN_REVISION - The security descriptor retrieved is no one known by
        this revision of SAM.



--*/
{

    NTSTATUS NtStatus;
    ULONG Revision;
    
    ATTRTYP  SDType[] = {SAMP_DOMAIN_SECURITY_DESCRIPTOR};
    ATTRVAL  SDVal[] = {0,NULL};
    DEFINE_ATTRBLOCK1(SDAttrBlock,SDType,SDVal);
    ATTRBLOCK   ReadSDAttrBlock;
    ULONG       ValLength = 0;


    SAMTRACE("SampGetDomainObjectSDFromDsName");


    ASSERT(DomainObjectDsName);

    (*SecurityDescriptorLength) = 0;

    //
    // Get the domain object security descriptor
    // 
    NtStatus = SampDsRead(DomainObjectDsName,
                          0,
                          SampDomainObjectType,
                          &SDAttrBlock,
                          &ReadSDAttrBlock
                          );

    if (NT_SUCCESS(NtStatus)) 
    {
        ASSERT(ReadSDAttrBlock.attrCount == 1);
        ASSERT(ReadSDAttrBlock.pAttr[0].attrTyp == SAMP_DOMAIN_SECURITY_DESCRIPTOR);
        ASSERT(ReadSDAttrBlock.pAttr[0].AttrVal.valCount == 1);

        ValLength = ReadSDAttrBlock.pAttr[0].AttrVal.pAVal[0].valLen;

        *SecurityDescriptor = MIDL_user_allocate(ValLength);
        
        if (NULL == (*SecurityDescriptor))
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            RtlZeroMemory(*SecurityDescriptor, ValLength);
            RtlCopyMemory(*SecurityDescriptor,
                          ReadSDAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal,
                          ValLength
                          );
            *SecurityDescriptorLength = ValLength;

        }
    }

    return(NtStatus);
}




NTSTATUS
SamrSetSecurityObject(
    IN SAMPR_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This function (SamrSetSecurityObject) takes a well formed Security
    Descriptor provided by the caller and assigns specified portions of
    it to an object.  Based on the flags set in the SecurityInformation
    parameter and the caller's access rights, this procedure will
    replace any or all of the security information associated with an
    object.

    This is the only function available to users and applications for
    changing security information, including the owner ID, group ID, and
    the discretionary and system ACLs of an object.  The caller must
    have WRITE_OWNER access to the object to change the owner or primary
    group of the object.  The caller must have WRITE_DAC access to the
    object to change the discretionary ACL.  The caller must have
    ACCESS_SYSTEM_SECURITY access to an object to assign a system ACL
    to the object.

    This API is modelled after the NtSetSecurityObject() system service.


Parameters:

    ObjectHandle - A handle to an existing object.

    SecurityInformation - Indicates which security information is to
        be applied to the object.  The value(s) to be assigned are
        passed in the SecurityDescriptor parameter.


    SecurityDescriptor - A pointer to a well formed self-relative Security
        Descriptor and corresponding length.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        either WRITE_OWNER, WRITE_DAC, or ACCESS_SYSTEM_SECURITY
        access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened SAM object.

    STATUS_BAD_DESCRIPTOR_FORMAT - Indicates something about security descriptor
        is not valid.  This may indicate that the structure of the descriptor is
        not valid or that a component of the descriptor specified via the
        SecurityInformation parameter is not present in the security descriptor.

    STATUS_INVALID_PARAMETER - Indicates no security information was specified.

    STATUS_LAST_ADMIN - Indicates the new SD could potentially lead
        to the administrator account being unusable and therefore
        the new protection is being rejected.

--*/
{

    NTSTATUS                        NtStatus, IgnoreStatus, TmpStatus;
    PSAMP_OBJECT                    Context;
    SAMP_OBJECT_TYPE                FoundType;
    SECURITY_DB_OBJECT_TYPE         SecurityDbObjectType;
    ACCESS_MASK                     DesiredAccess;
    PSECURITY_DESCRIPTOR            RetrieveSD, SetSD;
    PISECURITY_DESCRIPTOR_RELATIVE  PassedSD;
    ULONG                           RetrieveSDLength;
    ULONG                           ObjectRid;
    ULONG                           SecurityDescriptorIndex;
    HANDLE                          ClientToken;
    BOOLEAN                         NotificationType = TRUE;
    BOOLEAN                         ImpersonatingNullSession = FALSE;


    SAMTRACE_EX("SamrSetSecurityObject");

    //
    // WMI Event Trace
    // 
    
    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetSecurityObject
                   );


    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    if (SecurityDescriptor == NULL) {
        NtStatus = STATUS_BAD_DESCRIPTOR_FORMAT;
        goto Error;
    }
    if (SecurityDescriptor->SecurityDescriptor == NULL) {
        NtStatus = STATUS_BAD_DESCRIPTOR_FORMAT;
        goto Error;
    }

    PassedSD = (PISECURITY_DESCRIPTOR_RELATIVE)(SecurityDescriptor->SecurityDescriptor);


    //
    // Validate the passed security descriptor
    //

    NtStatus = SampValidatePassedSD( SecurityDescriptor->Length, PassedSD );
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    //
    // Set the desired access based upon the specified SecurityInformation
    //

    DesiredAccess = 0;
    if ( SecurityInformation & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }
    if ( SecurityInformation & (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION)) {
        DesiredAccess |= WRITE_OWNER;
    }
    if ( SecurityInformation & DACL_SECURITY_INFORMATION ) {
        DesiredAccess |= WRITE_DAC;
    }

    //
    // If no information was specified, then return invalid parameter.
    //

    if (DesiredAccess == 0) {

        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Make sure the specified fields are present in the provided security descriptor.
    // You can't mess up an SACL or DACL, but you can mess up an owner or group.
    // Security descriptors must have owner and group fields.
    //

    if ( (SecurityInformation & OWNER_SECURITY_INFORMATION) ) {
        if (PassedSD->Owner == 0) {
            NtStatus = STATUS_BAD_DESCRIPTOR_FORMAT;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
        }
    }


    if ( (SecurityInformation & GROUP_SECURITY_INFORMATION) ) {
        if (PassedSD->Group == 0) {
            NtStatus = STATUS_BAD_DESCRIPTOR_FORMAT;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
        }
    }

    //
    // See if the handle is valid and opened for the requested access
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    Context = (PSAMP_OBJECT)ObjectHandle;
    NtStatus = SampLookupContext(
                   Context,
                   DesiredAccess,
                   SampUnknownObjectType,           // ExpectedType
                   &FoundType
                   );

    switch ( FoundType ) {

        case SampServerObjectType: {

            SecurityDescriptorIndex = SAMP_SERVER_SECURITY_DESCRIPTOR;
            ObjectRid = 0L;
            NotificationType = FALSE;
            break;
        }

        case SampDomainObjectType: {


            SecurityDbObjectType = SecurityDbObjectSamDomain;
            SecurityDescriptorIndex = SAMP_DOMAIN_SECURITY_DESCRIPTOR;
            ObjectRid = 0L;
            break;
        }

        case SampUserObjectType: {

            SecurityDbObjectType = SecurityDbObjectSamUser;
            SecurityDescriptorIndex = SAMP_USER_SECURITY_DESCRIPTOR;
            ObjectRid = Context->TypeBody.User.Rid;
            break;
        }

        case SampGroupObjectType: {

            SecurityDbObjectType = SecurityDbObjectSamGroup;
            SecurityDescriptorIndex = SAMP_GROUP_SECURITY_DESCRIPTOR;
            ObjectRid = Context->TypeBody.Group.Rid;
            break;
        }

        case SampAliasObjectType: {

            SecurityDbObjectType = SecurityDbObjectSamAlias;
            SecurityDescriptorIndex = SAMP_ALIAS_SECURITY_DESCRIPTOR;
            ObjectRid = Context->TypeBody.Alias.Rid;
            break;
        }

        default: {

            NotificationType = FALSE;
            if (NT_SUCCESS(NtStatus))
            {
                ASSERT(FALSE && "Invalid SAM Object Type\n");
                NtStatus = STATUS_INTERNAL_ERROR; 
            }
        }
    }

    //
    // Do not let non trusted clients set Sacls in the SetSecurityInterface. ACL conversion
    // always resets sacls to schema default.
    //

    if ((NT_SUCCESS(NtStatus))
        && (IsDsObject(Context))
        && (!Context->TrustedClient)
        && (SecurityInformation & SACL_SECURITY_INFORMATION))
    {
        IgnoreStatus = SampDeReferenceContext( Context, FALSE );
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(NtStatus)) {


        //
        // Get the security descriptor
        //


        RetrieveSD = NULL;
        RetrieveSDLength = 0;
        NtStatus = SampGetObjectSD( Context, &RetrieveSDLength, &RetrieveSD);

        if (NT_SUCCESS(NtStatus)) {

            //
            // Make sure the descriptor does not break any Administrator
            // restrictions.
            //

            NtStatus = SampCheckForDescriptorRestrictions( Context,
                                                           FoundType,
                                                           ObjectRid,
                                                           PassedSD );

            if (NT_SUCCESS(NtStatus)) {

                //
                // copy the retrieved descriptor into process heap so we can use RTL routines.
                //

                SetSD = NULL;
                if (NT_SUCCESS(NtStatus)) {

                    SetSD = RtlAllocateHeap( RtlProcessHeap(), 0, RetrieveSDLength );
                    if ( SetSD == NULL) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    } else {
                        RtlCopyMemory( SetSD, RetrieveSD, RetrieveSDLength );
                    }
                }

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // if the caller is replacing the owner and he is not
                    // trusted, then a handle to the impersonation token is
                    // necessary. If the caller is trusted then take process
                    // token.
                    //

                    ClientToken = 0;
                    if ( (SecurityInformation & OWNER_SECURITY_INFORMATION) ) {

                        if(!Context->TrustedClient) {

                            NtStatus = SampImpersonateClient(&ImpersonatingNullSession);

                            if (NT_SUCCESS(NtStatus)) {

                                NtStatus = NtOpenThreadToken(
                                               NtCurrentThread(),
                                               TOKEN_QUERY,
                                               TRUE,            //OpenAsSelf
                                               &ClientToken
                                               );
                                ASSERT( (ClientToken == 0) || NT_SUCCESS(NtStatus) );



                                //
                                // Stop impersonating the client
                                //

                                SampRevertToSelf(ImpersonatingNullSession);
                            }
                        }
                        else {

                            //
                            // trusted client
                            //

                            NtStatus = NtOpenProcessToken(
                                            NtCurrentProcess(),
                                            TOKEN_QUERY,
                                            &ClientToken );

                            ASSERT( (ClientToken == 0) || NT_SUCCESS(NtStatus) );

                        }

                    }

                    if (NT_SUCCESS(NtStatus)) {

                            PSECURITY_DESCRIPTOR SDToSet = NULL;
                            PSECURITY_DESCRIPTOR NT5SD = NULL;

                            //
                            // For the NT5 Domain Controller Case, upgrade to NT5 security
                            // Descriptor
                            //

                            if (IsDsObject(Context))
                            {
                                PSECURITY_DESCRIPTOR Nt4Sd = PassedSD;



                                // Upgrade the security descriptor to NT5 and set it
                                // on the object for trusted clients. For non trusted
                                // clients, Propagate only some things ( like change
                                // password from the NT4 Security Descriptor.

                                if (Context->TrustedClient)
                                {
                                    NtStatus = SampConvertNt4SdToNt5Sd(
                                                    Nt4Sd,
                                                    Context->ObjectType,
                                                    Context,
                                                    &NT5SD
                                                    );
                                }
                                else
                                {
                                    NtStatus = SampPropagateSelectedSdChanges(
                                                    Nt4Sd,
                                                    Context->ObjectType,
                                                    Context,
                                                    &NT5SD
                                                    );
                                }

                                SDToSet = NT5SD;
                            }
                            else
                            {
                                //
                                // Registry Case
                                //

                                SDToSet = PassedSD;
                            }


                        //
                        // Build the replacement security descriptor.
                        // This must be done in process heap to satisfy the needs of the RTL
                        // routine.
                        //

                        NtStatus = RtlSetSecurityObject(
                                       SecurityInformation,
                                       SDToSet,
                                       &SetSD,
                                       &SampObjectInformation[FoundType].GenericMapping,
                                       ClientToken
                                       );

                        if (ClientToken != 0) {
                            IgnoreStatus = NtClose( ClientToken );
                            ASSERT(NT_SUCCESS(IgnoreStatus));
                        }

                        if (NULL!=NT5SD)
                            MIDL_user_free(NT5SD);

                        if (NT_SUCCESS(NtStatus)) {



                            if (NT_SUCCESS(NtStatus))
                            {

                                //
                                // Apply the security descriptor back onto the object.
                                //

                                NtStatus = SampSetAccessAttribute(
                                               Context,
                                               SecurityDescriptorIndex,
                                               SetSD,
                                               RtlLengthSecurityDescriptor(SetSD)
                                               );
                            }
                        }

                    }
                }
            }

            //
            // Free up allocated memory
            //

            if (RetrieveSD != NULL) {
                MIDL_user_free( RetrieveSD );
            }
            if (SetSD != NULL) {
                RtlFreeHeap( RtlProcessHeap(), 0, SetSD );
            }

            //
            // De-reference the object
            //

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = SampDeReferenceContext( Context, TRUE );

            } else {

                IgnoreStatus = SampDeReferenceContext( Context, FALSE );
            }
        }

    } //end_if



    //
    // Commit the changes to disk.
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        if ( NotificationType && NT_SUCCESS( NtStatus ) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChange,
                SecurityDbObjectType,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,  // Replicate immediately
                NULL            // Delta data
                );
        }
    }



    //
    // Release lock and propagate errors
    //

    TmpStatus = SampReleaseWriteLock( FALSE );

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = TmpStatus;
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // WMI Event Trace
    //
    
    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetSecurityObject
                   );

    return(NtStatus);


}

NTSTATUS
SampValidatePassedSD(
    IN ULONG                          Length,
    IN PISECURITY_DESCRIPTOR_RELATIVE PassedSD
    )

/*++

Routine Description:

    This routine validates that a passed security descriptor is valid and does
    not extend beyond its expressed length.


Parameters:

    Length - The length of the security descriptor.  This should be what RPC
        used to allocate memory to receive the security descriptor.

    PassedSD - Points to the security descriptor to inspect.


Return Values:

    STATUS_SUCCESS - The security descriptor is valid.

    STATUS_BAD_DESCRIPTOR_FORMAT - Something was wrong with the security
        descriptor.  It might have extended beyond its limits or had an
        invalid component.



--*/
{
    NTSTATUS    NtStatus;

    PACL        Acl;
    PSID        Sid;
    PUCHAR      SDEnd;
    BOOLEAN     Present, IgnoreBoolean;

    SAMTRACE("SampValidatePassedSD");


    if (Length < SECURITY_DESCRIPTOR_MIN_LENGTH) {
        return(STATUS_BAD_DESCRIPTOR_FORMAT);
    }

    SDEnd = (PUCHAR)PassedSD + Length;


    try {



        //
        // Verify that the security descriptor is in
        // self relative form
        //

        if (!((((PISECURITY_DESCRIPTOR_RELATIVE)PassedSD)->Control)
                & SE_SELF_RELATIVE)){

            return (STATUS_BAD_DESCRIPTOR_FORMAT);
        }

        //
        // Make sure the DACL is within the SD
        //

        NtStatus = RtlGetDaclSecurityDescriptor(
                        (PSECURITY_DESCRIPTOR)PassedSD,
                        &Present,
                        &Acl,
                        &IgnoreBoolean
                        );
        if (!NT_SUCCESS(NtStatus)) {
            return( STATUS_BAD_DESCRIPTOR_FORMAT );
        }

        if (Present) {
            if (Acl != NULL) {

                //
                // Make sure the ACl header is in the buffer.
                //

                if ( (((PUCHAR)Acl)>SDEnd) ||
                     (((PUCHAR)Acl)+sizeof(ACL) > SDEnd) ||
                     (((PUCHAR)Acl) < (PUCHAR)PassedSD) ) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }

                //
                // Make sure the rest of the ACL is within the buffer
                //
                // 1. Self AclSize should be less than the length of
                //    the passed SD as the SD should be in self relative
                //    format
                // 2. The end of the ACL should be within the security
                //    descriptor
                //

                if ( (Acl->AclSize > Length) ||
                     (((PUCHAR)Acl)+Acl->AclSize > SDEnd)) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }

                //
                // Make sure the rest of the ACL is valid
                //

                if (!RtlValidAcl( Acl )) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }
            }
        }



        //
        // Make sure the SACL is within the SD
        //

        NtStatus = RtlGetSaclSecurityDescriptor(
                        (PSECURITY_DESCRIPTOR)PassedSD,
                        &Present,
                        &Acl,
                        &IgnoreBoolean
                        );
        if (!NT_SUCCESS(NtStatus)) {
            return( STATUS_BAD_DESCRIPTOR_FORMAT );
        }

        if (Present) {
            if (Acl != NULL) {

                //
                // Make sure the ACl header is in the buffer.
                //
                //
                // 1. Self AclSize should be less than the length of
                //    the passed SD as the SD should be in self relative
                //    format
                // 2. The end of the ACL should be within the security
                //    descriptor
                //

                if ( (((PUCHAR)Acl)>SDEnd) ||
                     (((PUCHAR)Acl)+sizeof(ACL) > SDEnd) ||
                     (((PUCHAR)Acl) < (PUCHAR)PassedSD) ) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }

                //
                // Make sure the rest of the ACL is within the buffer
                //

                if ( (Acl->AclSize > Length) ||
                    (((PUCHAR)Acl)+Acl->AclSize > SDEnd)) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }

                //
                // Make sure the rest of the ACL is valid
                //

                if (!RtlValidAcl( Acl )) {
                    return( STATUS_BAD_DESCRIPTOR_FORMAT );
                }
            }
        }


        //
        // Make sure the Owner SID is within the SD
        //

        NtStatus = RtlGetOwnerSecurityDescriptor(
                        (PSECURITY_DESCRIPTOR)PassedSD,
                        &Sid,
                        &IgnoreBoolean
                        );
        if (!NT_SUCCESS(NtStatus)) {
            return( STATUS_BAD_DESCRIPTOR_FORMAT );
        }

        if (Sid != NULL) {

            //
            // Make sure the SID header is in the SD
            //

            if ( (((PUCHAR)Sid)>SDEnd) ||
                 (((PUCHAR)Sid)+sizeof(SID)-(ANYSIZE_ARRAY*sizeof(ULONG)) > SDEnd) ||
                 (((PUCHAR)Sid) < (PUCHAR)PassedSD) ) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }


            //
            // Make sure there aren't too many sub-authorities
            //

            if (((PISID)Sid)->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }


            //
            // Make sure the rest of the SID is within the SD
            //

            if ( ((PUCHAR)Sid)+RtlLengthSid(Sid) > SDEnd) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }

        }



        //
        // Make sure the Group SID is within the SD
        //

        NtStatus = RtlGetGroupSecurityDescriptor(
                        (PSECURITY_DESCRIPTOR)PassedSD,
                        &Sid,
                        &IgnoreBoolean
                        );
        if (!NT_SUCCESS(NtStatus)) {
            return( STATUS_BAD_DESCRIPTOR_FORMAT );
        }

        if (Sid != NULL) {

            //
            // Make sure the SID header is in the SD
            //

            if ( (((PUCHAR)Sid)>SDEnd) ||
                 (((PUCHAR)Sid)+sizeof(SID)-(ANYSIZE_ARRAY*sizeof(ULONG)) > SDEnd) ||
                 (((PUCHAR)Sid) < (PUCHAR)PassedSD) ) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }


            //
            // Make sure there aren't too many sub-authorities
            //

            if (((PISID)Sid)->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }


            //
            // Make sure the rest of the SID is within the SD
            //

            if ( ((PUCHAR)Sid)+RtlLengthSid(Sid) > SDEnd) {
                return( STATUS_BAD_DESCRIPTOR_FORMAT );
            }

        }




    } except(EXCEPTION_EXECUTE_HANDLER) {
        return( STATUS_BAD_DESCRIPTOR_FORMAT );
    }  // end_try




    return(STATUS_SUCCESS);
}

NTSTATUS
SampCheckForDescriptorRestrictions(
    IN PSAMP_OBJECT             Context,
    IN SAMP_OBJECT_TYPE         ObjectType,
    IN ULONG                    ObjectRid,
    IN PISECURITY_DESCRIPTOR_RELATIVE  PassedSD
    )

/*++

Routine Description:

    This function ensures that the passed security descriptor,
    which is being applied to an object of type 'FoundType' with
    a Rid of value 'ObjectRid', does not violate any policies.
    For example, you can not set protection on the Administrator
    user account such that the administrator is unable to change
    her password.



Parameters:

    Context - The caller's context.  This is used to determine
        whether the caller is trusted or not.  If the caller is
        trusted, then there are no restrictions.

    ObjectType - The type of object the new security descriptor
        is being applied to.

    ObjectRid - The RID of the object the new security descriptor
        is being applied to.

    PassedSD - The security descriptor passed by the client.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_LAST_ADMIN - Indicates the new SD could potentially lead
        to the administrator account being unusable and therefore
        the new protection is being rejected.



--*/
{

    NTSTATUS
        NtStatus;

    BOOLEAN
        DaclPresent = FALSE,
        AdminSid,
        Done,
        IgnoreBoolean;

    PACL
        Dacl = NULL;

    ACL_SIZE_INFORMATION
        DaclInfo;

    PACCESS_ALLOWED_ACE
        Ace;

    ACCESS_MASK
        Accesses,
        Remaining;

    ULONG
        AceIndex;

    GENERIC_MAPPING
        UserMap      =  {USER_READ,
                         USER_WRITE,
                         USER_EXECUTE,
                         USER_ALL_ACCESS};

    SAMTRACE("SampCheckForDescriptorRestrictions");

    //
    // No checking for trusted client operations
    //

    if (Context->TrustedClient) {
        return(STATUS_SUCCESS);
    }



    NtStatus = RtlGetDaclSecurityDescriptor ( (PSECURITY_DESCRIPTOR)PassedSD,
                                               &DaclPresent,
                                               &Dacl,
                                               &IgnoreBoolean    //DaclDefaulted
                                               );
    ASSERT(NT_SUCCESS(NtStatus));

    if (!NT_SUCCESS(NtStatus))
    {
        return(STATUS_BAD_DESCRIPTOR_FORMAT);
    }


    if (!DaclPresent) {

        //
        // Not replacing the DACL
        //

        return(STATUS_SUCCESS);
    }

    if (Dacl == NULL) {

        //
        // Assigning "World all access"
        //

        return(STATUS_SUCCESS);
    }

    if (!RtlValidAcl(Dacl)) {
        return(STATUS_INVALID_ACL);
    }

    NtStatus = RtlQueryInformationAcl ( Dacl,
                                        &DaclInfo,
                                        sizeof(ACL_SIZE_INFORMATION),
                                        AclSizeInformation
                                        );
    ASSERT(NT_SUCCESS(NtStatus));




    //
    // Enforce Administrator user policies
    //

    NtStatus = STATUS_SUCCESS;
    if (ObjectRid == DOMAIN_USER_RID_ADMIN) {

        ASSERT(ObjectType == SampUserObjectType);

        //
        // For the administrator account, the ACL must grant
        // these accesses:
        //

        Remaining = USER_READ_GENERAL            |
                    USER_READ_PREFERENCES        |
                    USER_WRITE_PREFERENCES       |
                    USER_READ_LOGON              |
                    USER_READ_ACCOUNT            |
                    USER_WRITE_ACCOUNT           |
                    USER_CHANGE_PASSWORD         |
                    USER_FORCE_PASSWORD_CHANGE   |
                    USER_LIST_GROUPS             |
                    USER_READ_GROUP_INFORMATION  |
                    USER_WRITE_GROUP_INFORMATION;

        //
        // to these SIDs:
        //
        //      <domain>\Administrator
        //      <builtin>\Administrators
        //
        // It doesn't matter which accesses are granted to which SIDs,
        // as long as collectively all the accesses are granted.
        //

        //
        // Walk the ACEs collecting accesses that are granted to these
        // SIDs.  Make sure there are no DENYs that prevent them from
        // being granted.
        //

        Done = FALSE;
        for ( AceIndex=0;
              (AceIndex < DaclInfo.AceCount) && !Done;
              AceIndex++) {

            NtStatus = RtlGetAce ( Dacl, AceIndex, &((PVOID)Ace) );

            //
            // Don't do anything with inherit-only ACEs
            //

            if ((Ace->Header.AceFlags & INHERIT_ONLY_ACE) == 0) {

                //
                // Note that we expect ACCESS_ALLOWED_ACE and ACCESS_DENIED_ACE
                // to be identical structures in the following switch statement.
                //

                switch (Ace->Header.AceType) {
                case ACCESS_ALLOWED_ACE_TYPE:
                case ACCESS_DENIED_ACE_TYPE:
                    {
                        //
                        // Is this an interesting SID
                        //

                        AdminSid =
                            RtlEqualSid( ((PSID)(&Ace->SidStart)),
                                         SampAdministratorUserSid)
                            ||
                            RtlEqualSid( ((PSID)(&Ace->SidStart)),
                                         SampAdministratorsAliasSid);
                        if (AdminSid) {

                            //
                            // Map the accesses granted or denied
                            //

                            Accesses = Ace->Mask;
                            RtlMapGenericMask( &Accesses, &UserMap );

                            if (Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) {

                                Remaining &= ~Accesses;
                                if (Remaining == 0) {

                                    //
                                    // All necessary accesses granted
                                    //

                                    Done = TRUE;
                                }

                            } else {
                                ASSERT(Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE);

                                if (Remaining & Accesses) {

                                    //
                                    // We've just been denied some necessary
                                    // accesses that haven't yet been granted.
                                    //

                                    Done = TRUE;
                                }
                            }

                        }

                        break;
                    }

                default:
                    break;
                } // end_switch

                if (Done) {
                    break;
                }
            }

        } // end_for

        if (Remaining != 0) {
            NtStatus = STATUS_LAST_ADMIN;
        }


    } // end_if (Administrator Account)



    return(NtStatus);
}



NTSTATUS
SamrQuerySecurityObject(
    IN SAMPR_HANDLE ObjectHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSAMPR_SR_SECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    This function (SamrQuerySecurityObject) returns to the caller requested
    security information currently assigned to an object.

    Based on the caller's access rights this procedure
    will return a security descriptor containing any or all of the
    object's owner ID, group ID, discretionary ACL or system ACL.  To
    read the owner ID, group ID, or the discretionary ACL the caller
    must be granted READ_CONTROL access to the object.  To read the
    system ACL the caller must be granted ACCESS_SYSTEM_SECURITY
    access.

    This API is modelled after the NtQuerySecurityObject() system
    service.


Parameters:

    ObjectHandle - A handle to an existing object.

    SecurityInformation - Supplies a value describing which pieces of
        security information are being queried.

    SecurityDescriptor - Provides a pointer to a structure to be filled
        in with a security descriptor containing the requested security
        information.  This information is returned in the form of a
        self-relative security descriptor.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        either READ_CONTROL or ACCESS_SYSTEM_SECURITY
        access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened SAM object.


--*/
{
    NTSTATUS                        NtStatus, IgnoreStatus;
    PSAMP_OBJECT                    Context;
    SAMP_OBJECT_TYPE                FoundType;
    ACCESS_MASK                     DesiredAccess;
    PSAMPR_SR_SECURITY_DESCRIPTOR   RpcSD;
    PSECURITY_DESCRIPTOR            RetrieveSD, ReturnSD;
    ULONG                           RetrieveSDLength, ReturnSDLength;


    SAMTRACE_EX("SamrQuerySecurityObject");


    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQuerySecurityObject
                   );

    ReturnSD = NULL;



    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (*SecurityDescriptor == NULL);







    //
    // Set the desired access based upon the requested SecurityInformation
    //

    DesiredAccess = 0;
    if ( SecurityInformation & SACL_SECURITY_INFORMATION) {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }
    if ( SecurityInformation &  (DACL_SECURITY_INFORMATION  |
                                 OWNER_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION)
       ) {
        DesiredAccess |= READ_CONTROL;
    }





    //
    // Allocate the first block of returned memory
    //

    RpcSD = MIDL_user_allocate( sizeof(SAMPR_SR_SECURITY_DESCRIPTOR) );
    if (RpcSD == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    RpcSD->Length = 0;
    RpcSD->SecurityDescriptor = NULL;



    //
    // See if the handle is valid and opened for the requested access
    //


    SampAcquireReadLock();
    Context = (PSAMP_OBJECT)ObjectHandle;
    NtStatus = SampLookupContext(
                   Context,
                   DesiredAccess,
                   SampUnknownObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {


        //
        // Get the security descriptor
        //


        RetrieveSDLength = 0;
        NtStatus = SampGetObjectSD( Context, &RetrieveSDLength, &RetrieveSD);

        if (NT_SUCCESS(NtStatus)) {



            //
            // For NT5 Domain Controllers convert the security descriptor
            // back to a NT4 Format
            //

            if (IsDsObject(Context))
            {
                PSID    SelfSid = NULL;
                PSECURITY_DESCRIPTOR    Nt5SD = RetrieveSD;

                RetrieveSD = NULL;

                if (SampServerObjectType != Context->ObjectType)
                {
                    SelfSid = SampDsGetObjectSid(Context->ObjectNameInDs);

                    if (NULL == SelfSid)
                    {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                //
                // The Self Sid will be NULL for the server object case
                //

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampConvertNt5SdToNt4SD(
                                   Nt5SD,
                                   Context,
                                   SelfSid,
                                   &RetrieveSD
                                  );
                }

                MIDL_user_free(Nt5SD);
            }

            if (NT_SUCCESS(NtStatus))
            {


                //
                // Recompute the retireve SD length as the length might
                // have changed during conversion
                //

                RetrieveSDLength = GetSecurityDescriptorLength(RetrieveSD);

                //
                // blank out the parts that aren't to be returned
                //

                if ( !(SecurityInformation & SACL_SECURITY_INFORMATION) ) {
                    ((PISECURITY_DESCRIPTOR_RELATIVE)RetrieveSD)->Control  &= ~SE_SACL_PRESENT;
                }


                if ( !(SecurityInformation & DACL_SECURITY_INFORMATION) ) {
                    ((PISECURITY_DESCRIPTOR_RELATIVE)RetrieveSD)->Control  &= ~SE_DACL_PRESENT;
                }


                if ( !(SecurityInformation & OWNER_SECURITY_INFORMATION) ) {
                    ((PISECURITY_DESCRIPTOR_RELATIVE)RetrieveSD)->Owner = 0;
                }


                if ( !(SecurityInformation & GROUP_SECURITY_INFORMATION) ) {
                    ((PISECURITY_DESCRIPTOR_RELATIVE)RetrieveSD)->Group = 0;
                }


                //
                // Determine how much memory is needed for a self-relative
                // security descriptor containing just this information.
                //


                ReturnSDLength = 0;
                NtStatus = RtlMakeSelfRelativeSD(
                               RetrieveSD,
                               NULL,
                               &ReturnSDLength
                               );
                ASSERT(!NT_SUCCESS(NtStatus));

                if (NtStatus == STATUS_BUFFER_TOO_SMALL) {


                    ReturnSD = MIDL_user_allocate( ReturnSDLength );
                    if (ReturnSD == NULL) {

                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                    } else {


                        //
                        // make an appropriate self-relative security descriptor
                        //

                        NtStatus = RtlMakeSelfRelativeSD(
                                       RetrieveSD,
                                       ReturnSD,
                                       &ReturnSDLength
                                       );
                    }

                }

            }
            //
            // Free up the retrieved SD
            //

            if (RetrieveSD != NULL) {
                MIDL_user_free( RetrieveSD );
            }

        }



        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext( Context, FALSE );
    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();



    //
    // If we succeeded, set up the return buffer.
    // Otherwise, free any allocated memory.
    //

    if (NT_SUCCESS(NtStatus)) {

        RpcSD->Length = ReturnSDLength;
        RpcSD->SecurityDescriptor = (PUCHAR)ReturnSD;
        (*SecurityDescriptor) = RpcSD;

    } else {

        MIDL_user_free( RpcSD );
        if (ReturnSD != NULL) {
            MIDL_user_free(ReturnSD);
        }
        (*SecurityDescriptor) = NULL;
    }


    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQuerySecurityObject
                   );


    return(NtStatus);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\sdcache.c ===
/*++

Copyright (c) 1990 - 2000  Microsoft Corporation

Module Name:

    sdcache.c

Abstract:

    This file contains routines to implement cached Server Object / Domain Object 
    Security Descriptor

Author:

    Shaohua Yin ( SHAOYIN ) Oct. 10, 2000

Environment:

    User Mode - Win32

Revision History:



--*/



#include <samsrvp.h>
#include <seopaque.h>
#include <ntrtl.h>
#include <ntseapi.h>
#include <ntsam.h>
#include <ntdsguid.h>
#include <mappings.h>
#include <dsevent.h>
#include <permit.h>
#include <dslayer.h>
#include <sdconvrt.h>
#include <dbgutilp.h>
#include <dsmember.h>
#include <malloc.h>
#include <attids.h>
#include <filtypes.h>





#define SampServerClientHandle              0
#define SampAccountDomainClientHandle       1
#define SampBuiltinDomainClientHandle       2

#define SampServerObjectSDIndex     0
#define SampAccountDomainSDIndex    1
#define SampBuiltinDomainSDIndex    2


//
// declare private routines
//

BOOL
SampNotifyPrepareToImpersonate(
    ULONG Client,
    ULONG Server,
    VOID **ImpersonateData
    );

VOID
SampNotifyStopImpersonation(
    ULONG Client,
    ULONG Server,
    VOID *ImpersonateData
    );

VOID
SampProcessWellKnownSDChange(
    ULONG   hClient,
    ULONG   hServer,
    ENTINF  *EntInf
    );

NTSTATUS
SampUpdateWellKnownSD(
    PVOID pv
    );

NTSTATUS
SampDelayedFreeSD(
    PVOID pv
    );


//
// Variables to point to the cached well known object Security Descriptor
// 

PSECURITY_DESCRIPTOR SampServerObjectSD = NULL;  
PSECURITY_DESCRIPTOR SampAccountDomainObjectSD = NULL;  
PSECURITY_DESCRIPTOR SampBuiltinDomainObjectSD = NULL;  

//
// Variables to point Domain Object DS Name, note: they are not hold the domain dsname, 
// but just a pointer to SampDefinedDomains[i].Context->ObjectNameInDs
// 

DSNAME * SampAccountDomainDsName = NULL;
DSNAME * SampBuiltinDomainDsName = NULL;


//
// 
//

typedef struct _SD_CACHE_TABLE_ENTRY    {
    PDSNAME *ppObjectDsName;
    PSECURITY_DESCRIPTOR *ppSD;
    PF_PFI pfPrepareForImpersonate;
    PF_TD  pfTransmitData;             
    PF_SI  pfStopImpersonating;
    DWORD  hClient;
} SD_CACHE_TABLE; 


SD_CACHE_TABLE  SampWellKnownSDTable[] =
{
    {
        &SampServerObjectDsName, 
        &SampServerObjectSD,
        SampNotifyPrepareToImpersonate, 
        SampProcessWellKnownSDChange,
        SampNotifyStopImpersonation,
        SampServerClientHandle
    },

    {
        &SampAccountDomainDsName, 
        &SampAccountDomainObjectSD,
        SampNotifyPrepareToImpersonate,
        SampProcessWellKnownSDChange,
        SampNotifyStopImpersonation,
        SampAccountDomainClientHandle
    },

    {
        &SampBuiltinDomainDsName, 
        &SampBuiltinDomainObjectSD,
        SampNotifyPrepareToImpersonate,
        SampProcessWellKnownSDChange,
        SampNotifyStopImpersonation,
        SampBuiltinDomainClientHandle
    }
};


ULONG cSampWellKnownSDTable = 
        sizeof(SampWellKnownSDTable) / 
        sizeof(SD_CACHE_TABLE);



NTSTATUS
SampWellKnownSDNotifyRegister(
    PDSNAME pObjectDsName,
    PF_PFI pfPrepareForImpersonate,
    PF_TD  pfTransmitData,
    PF_SI  pfStopImpersonating,
    DWORD  hClient
    )
/*++

Routine Description:

    This routine registers DS object change notification routines.

    NOTE: the caller should have a open DS transaction.

Parameters:

    pObjectDsName - pointer to the object dsname

    pfPrepareForImpersonate - pointer to prepare routine 

    pfTransmitData - pointer to notification routine 

    pfStopImpersonating - pointer to cleanup routine

    hClient - client identifier

Return Values:

    NtStatus code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    SEARCHARG   SearchArg;
    NOTIFYARG   NotifyArg;
    NOTIFYRES*  NotifyRes = NULL; 
    ENTINFSEL   EntInfSel;
    ATTR        Attr;
    FILTER      Filter;
    ULONG       DirError;

    ASSERT( SampExistsDsTransaction() );


    //
    // init notify arg
    //
    NotifyArg.pfPrepareForImpersonate = pfPrepareForImpersonate;
    NotifyArg.pfTransmitData = pfTransmitData;
    NotifyArg.pfStopImpersonating = pfStopImpersonating;
    NotifyArg.hClient = hClient;

    //
    // init search arg
    // 
    RtlZeroMemory(&SearchArg, sizeof(SEARCHARG));
    RtlZeroMemory(&EntInfSel, sizeof(ENTINFSEL));
    RtlZeroMemory(&Filter, sizeof(ATTR));
    RtlZeroMemory(&Attr, sizeof(ATTR));

    SearchArg.pObject = pObjectDsName;

    InitCommarg(&SearchArg.CommArg);
    SearchArg.choice = SE_CHOICE_BASE_ONLY;
    SearchArg.bOneNC = TRUE;

    SearchArg.pSelection = &EntInfSel;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr = &Attr;
    Attr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;

    SearchArg.pFilter = &Filter;
    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_TRUE;

    //
    // Call Dir* API
    // 
    DirError = DirNotifyRegister(&SearchArg, &NotifyArg, &NotifyRes); 
                                                            
    if ( DirError != 0 ) {

        NtStatus = SampMapDsErrorToNTStatus(DirError, &NotifyRes->CommRes);

    }

    return( NtStatus );
}


NTSTATUS
SampGetObjectSDByDsName(
    PDSNAME pObjectDsName,
    PSECURITY_DESCRIPTOR *ppSD
    )
/*++

Routine Description:

    This routine reads DS, get security descriptor of this object

    NOTE: the caller should have a DS transaction opened before 
          calling this routine

Parameter:

    pObjectDsName - object ds name

    ppSD -- pointer to hold security descriptor

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DWORD       DirError;
    READARG     ReadArg;
    READRES    *ReadRes = NULL;
    COMMARG    *CommArg = NULL;
    ATTR        Attr;
    ATTRBLOCK   ReadAttrBlock;
    ENTINFSEL   EntInfSel;


    ASSERT( SampExistsDsTransaction() );

    //
    // Init Read Argument
    // 
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EntInfSel, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EntInfSel.AttrTypBlock = ReadAttrBlock;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInfSel;
    ReadArg.pObject = pObjectDsName;

    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);


    DirError = DirRead(&ReadArg, &ReadRes);

    if (NULL == ReadRes) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadRes->CommRes);
    }

    if (NT_SUCCESS(NtStatus))
    {
        ATTRBLOCK   AttrBlock;

        ASSERT(NULL != ReadRes);


        AttrBlock = ReadRes->entry.AttrBlock;

        if ( (1 == AttrBlock.attrCount) &&
             (NULL != AttrBlock.pAttr) &&
             (1 == AttrBlock.pAttr[0].AttrVal.valCount) &&
             (NULL != AttrBlock.pAttr[0].AttrVal.pAVal) )
        {
            ULONG   SDLength = 0;

            SDLength = AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen;

            *ppSD = RtlAllocateHeap(RtlProcessHeap(), 0, SDLength);

            if (NULL == (*ppSD))
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {

                RtlZeroMemory((*ppSD), SDLength);

                RtlCopyMemory(*ppSD,
                              AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal,
                              SDLength
                              );
            }
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }

    return( NtStatus );    
}


NTSTATUS
SampInitWellKnownSDTable(
    VOID
)
/*++

Routine Description:

    This routine initializes the SampWellKnownSDTable[], basically we cache
    server object and domain objects (account and builtin domain) security 
    descriptor, because they are not changed very frequently. 
    
    Also SAM registers the DS change notification routines, thus that object
    change can trigger the cached security descriptor been updated. 
    
Parameter: 

    None.
    
Return Value:
    
    NtStatus Code     

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DsNameLen = 0;
    ULONG       DomainIndex = 0;
    ULONG       i;

    //
    // copy Builtin domain object DSName
    //    

    DomainIndex = SampDsGetPrimaryDomainStart();
    DsNameLen = SampDefinedDomains[DomainIndex].Context->ObjectNameInDs->structLen;

    SampBuiltinDomainDsName = RtlAllocateHeap(RtlProcessHeap(), 0, DsNameLen);
    if (NULL == SampBuiltinDomainDsName) 
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    RtlZeroMemory(SampBuiltinDomainDsName, DsNameLen);
    RtlCopyMemory(SampBuiltinDomainDsName, 
                  SampDefinedDomains[DomainIndex].Context->ObjectNameInDs,
                  DsNameLen
                  );

    //
    // Copy Account Domain object DSName 
    // 

    DomainIndex ++;
    DsNameLen = SampDefinedDomains[DomainIndex].Context->ObjectNameInDs->structLen;

    SampAccountDomainDsName = RtlAllocateHeap(RtlProcessHeap(), 0, DsNameLen);
    if (NULL == SampAccountDomainDsName) 
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    RtlZeroMemory(SampAccountDomainDsName, DsNameLen);
    RtlCopyMemory(SampAccountDomainDsName, 
                  SampDefinedDomains[DomainIndex].Context->ObjectNameInDs,
                  DsNameLen
                  );

    //
    // Begin a DS transaction if required
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Register DS object change notification routine.
    // if succeed, go ahead cache object security descriptor.
    // otherwise leave the SD to NULL
    // 

    for (i = 0; i < cSampWellKnownSDTable; i++ )
    {
        //
        // init the SD pointer to NULL
        // 

        *(SampWellKnownSDTable[i].ppSD) = NULL;

        // 
        // register notification routine
        // 

        NtStatus = SampWellKnownSDNotifyRegister(
                        *SampWellKnownSDTable[i].ppObjectDsName, 
                        SampWellKnownSDTable[i].pfPrepareForImpersonate,
                        SampWellKnownSDTable[i].pfTransmitData,
                        SampWellKnownSDTable[i].pfStopImpersonating,
                        SampWellKnownSDTable[i].hClient
                        );

        if ( NT_SUCCESS(NtStatus) )
        {
            PSECURITY_DESCRIPTOR pSD = NULL;

            //
            // get well known object security descriptor
            // 

            NtStatus = SampGetObjectSDByDsName(
                            *SampWellKnownSDTable[i].ppObjectDsName,
                            &pSD
                            );

            if ( NT_SUCCESS(NtStatus) )
            {
                *(SampWellKnownSDTable[i].ppSD) = pSD;
            }
        }

        if ( !NT_SUCCESS(NtStatus) )
        {
            goto Error;
        }
    }

Error:

    if ( !NT_SUCCESS(NtStatus) )
    {
        if (SampBuiltinDomainDsName)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, SampBuiltinDomainDsName);
            SampBuiltinDomainDsName = NULL;
        }

        if (SampAccountDomainDsName)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, SampAccountDomainDsName); 
            SampAccountDomainDsName = NULL;
        }
    }

    //
    // End the DS transaction
    // 

    SampMaybeEndDsTransaction(TransactionCommit);

    return( NtStatus );
}




BOOL
SampServerNotifyPrepareToImpersonate(
    ULONG Client,
    ULONG Server,
    VOID **ImpersonateData
    )
//
// This function is called by the core DS as preparation for a call to
// SampProcessWellKnownSDChange.  Since SAM does not have a
// client context, we set the thread state fDSA to TRUE.
//
{
    SampSetDsa( TRUE );

    return TRUE;
}

VOID
SampServerNotifyStopImpersonation(
    ULONG Client,
    ULONG Server,
    VOID *ImpersonateData
    )
//
// Called after SampProcessWellKnownSDChange, this function
// undoes the effect of SampNotifyPrepareToImpersonate
//
{

    SampSetDsa( FALSE );

    return;
}






VOID
SampProcessWellKnownSDChange(
    ULONG   hClient,
    ULONG   hServer,
    ENTINF  *EntInf
    )
/*++

Routine Description:

    This routine is called if Server / Domain Object have been modified.  

    Though we don't know which attribute has been changed, we'd better
    update the cached object security descriptor.

    for better performance, we can read DS object Meta data to tell whether
    security descriptor been changed or not. 

Parameter:
    
    hClient - client identifier
    
    hServer - server identifier
    
    EntInf  - pointer to entry info

Return Value:

    None.

--*/
{
    ULONG   i, Index;
    PVOID   pv = NULL;
    PVOID   PtrToFree = NULL;

    //
    // determine which object needs to be updated
    // 

    for (i = 0; i < cSampWellKnownSDTable; i++ )
    {
        if (hClient == SampWellKnownSDTable[i].hClient)
        {
            Index = i;
            break;
        }
    }

    if (i >= cSampWellKnownSDTable)
    {
        ASSERT( FALSE && "Invalid client identifier\n");
        return;
    }

    //
    // invalidate cached object SD
    // 
    
    pv = NULL;
    PtrToFree = InterlockedExchangePointer(
                    SampWellKnownSDTable[Index].ppSD,
                    pv
                    );

    if ( PtrToFree )
    {
        LsaIRegisterNotification(
                        SampDelayedFreeSD,
                        PtrToFree,
                        NOTIFIER_TYPE_INTERVAL,
                        0,        // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        3600,     // wait for 60 min
                        NULL      // no handle
                        );
    }
    

    //
    // Update cached object SD
    // 

    pv = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(ULONG));

    if (NULL == pv) {
        return;
    }

    RtlZeroMemory(pv, sizeof(ULONG));

    *(ULONG *)pv = Index;
    
    SampUpdateWellKnownSD(pv);

    return;
}



NTSTATUS
SampUpdateWellKnownSD(
    PVOID pv
    )
/*++

Routine Description:

    This routine updates SampWellKnownSDTable[], value of pv
    indicates which element needs to be updated.  

    NOTE: cached SD should have already been invalidated

Parameter:

    pv - value tells the index of entry in the table

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR     pSD = NULL;
    BOOLEAN     fTransOpen = TRUE;
    PVOID       PtrToFree = NULL;
    ULONG       Index = 0;

    ASSERT( NULL != pv );

    if (NULL == pv)
    {
        return( STATUS_INVALID_PARAMETER );
    }

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }
    fTransOpen = TRUE;

    //
    // get the new security descriptor
    // 

    Index = * (ULONG *)pv;
    NtStatus = SampGetObjectSDByDsName(
                        *SampWellKnownSDTable[Index].ppObjectDsName,
                        &pSD
                        );

    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }


    //
    // update cached security descriptor if everything is fine
    // 

    PtrToFree = InterlockedExchangePointer(
                        SampWellKnownSDTable[Index].ppSD,
                        pSD
                        );

    // the update should only happen when the cached SD is invalid
    ASSERT( NULL == PtrToFree );
    
Cleanup:

    if ( fTransOpen )
    {
        NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

        IgnoreStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ? 
                                                  TransactionCommit : TransactionAbort
                                                );
    }

    // if not succeed, try again
    if ( !NT_SUCCESS(NtStatus) )
    {
        LsaIRegisterNotification(
                        SampUpdateWellKnownSD,
                        pv,
                        NOTIFIER_TYPE_INTERVAL,
                        0,            // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        60,           // wait for 1 min
                        NULL          // no handle
                        );
    }
    else
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pv);
    }

    return( NtStatus );
}





NTSTATUS
SampGetCachedObjectSD(
    IN PSAMP_OBJECT Context,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )
/*++

Routine Description:

    This routine get object security descriptor from well known SD table

Parameter:
    
    Context - object context
    
    SecurityDescriptorLength - object SD length

    SecurityDescriptor - place to hold SD 

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       i, Index = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;


    //
    // init return values
    // 

    *SecurityDescriptorLength = 0;
    *SecurityDescriptor = NULL;

    
    //
    // scan well known object SD table first
    // 
    
    switch (Context->ObjectType)
    {
    case SampServerObjectType:

        Index = SampServerObjectSDIndex;
        break;

    case SampDomainObjectType:

        if (IsBuiltinDomain(Context->DomainIndex))
        {
            Index = SampBuiltinDomainSDIndex;
        }
        else
        {
            Index = SampAccountDomainSDIndex;
        }

        break;

    default:

        ASSERT(FALSE && "Incorrect SAM object type\n");
        break;
    }

    pSD = *(SampWellKnownSDTable[Index].ppSD);

    //
    // if the well known object (server / domain) SD is available, 
    // get it from the table, other return error. So that caller can 
    // read DS backing store.
    // 

    if (NULL == pSD)
    {
        return( STATUS_UNSUCCESSFUL ); 
    }
    else
    {
        ULONG   SDLength = RtlLengthSecurityDescriptor( pSD );

        *SecurityDescriptor = RtlAllocateHeap(RtlProcessHeap(), 0, SDLength);

        if (NULL == *SecurityDescriptor)
        {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
        else
        {
            RtlZeroMemory(*SecurityDescriptor, SDLength);

            RtlCopyMemory(*SecurityDescriptor, pSD, SDLength);

            *SecurityDescriptorLength = SDLength;
        }
    }

    return( NtStatus );
}


NTSTATUS
SampDelayedFreeSD(
    PVOID pv
    )
{
    if ( pv ) {

        RtlFreeHeap( RtlProcessHeap(), 0, pv );
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\security.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This file contains services which perform access validation on
    attempts to access SAM objects.  It also performs auditing on
    both open and close operations.


Author:

    Jim Kelly    (JimK)  6-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <ntseapi.h>
#include <seopaque.h>
#include <sdconvrt.h>
#include <dslayer.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()

#include <attids.h>             // ATT_SCHEMA_ID_GUID
#include <ntdsguid.h>           // GUID_CONTROL_DsInstallReplica
#include "permit.h"             // for DS_GENERIC_MAPPING


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


VOID
SampRemoveAnonymousChangePasswordAccess(
    IN OUT PSECURITY_DESCRIPTOR     Sd
    );

NTSTATUS
SampRemoveAnonymousAccess(
    IN OUT PSECURITY_DESCRIPTOR *    Sd,
    IN OUT PULONG                    SdLength,
    IN ULONG    AccessToRemove,
    IN SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampCreateUserToken(
    IN PSAMP_OBJECT UserContext,
    IN HANDLE       PassedInToken,
    IN HANDLE       *UserToken
    );

BOOLEAN
SampIsForceGuestEnabled();

BOOLEAN
SampIsClientLocal();



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamIImpersonateNullSession(
    )
/*++

Routine Description:

    Impersonates the null session token

Arguments:

    None

Return Value:

    STATUS_CANNOT_IMPERSONATE - there is no null session token to imperonate

--*/
{
    SAMTRACE("SampImpersonateNullSession");

    if (SampNullSessionToken == NULL) {
        return(STATUS_CANNOT_IMPERSONATE);
    }
    return( NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &SampNullSessionToken,
                sizeof(HANDLE)
                ) );

}

NTSTATUS
SamIRevertNullSession(
    )
/*++

Routine Description:

    Reverts a thread from impersonating the null session token.

Arguments:

    None

Return Value:

    STATUS_CANNOT_IMPERSONATE - there was no null session token to be
        imperonating.

--*/
{

    HANDLE NullHandle = NULL;

    SAMTRACE("SampRevertNullSession");

    if (SampNullSessionToken == NULL) {
        return(STATUS_CANNOT_IMPERSONATE);
    }

    return( NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID) &NullHandle,
                sizeof(HANDLE)
                ) );

}





NTSTATUS
SampValidateDomainControllerCreation(
    IN PSAMP_OBJECT Context
    )
/*++
Routine Description:

    This routine will check whether the client has enough right
    to convert a machine (workstation or standalone server) account
    to a Server Trust Account (replica domain controller).

    1. Retrieve Domain NC head, which is Account Domain

        1.1 Get Domain NC head Security Descriptor

    2. Fill the Object List

    3. Impersonate Client

    4. Access Check

    5. Unimpersonate Client

    Note: Should only be called in DS case.

Parameters:

    Context - The handle value that will be assigned if the access validation
        is successful.

Return Values:

    STATUS_SUCCESS  -- the client has enough right to create a Server
                       Trust Account

    STATUS_ACCESS_DENIED -- not enough right

    other Error code.

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    PSAMP_OBJECT            DomainContext = NULL;
    OBJECT_TYPE_LIST        ObjList[2];
    DWORD                   Results[2];
    DWORD                   GrantedAccess[2];
    PSECURITY_DESCRIPTOR    pSD = NULL;
    GENERIC_MAPPING         GenericMapping = DS_GENERIC_MAPPING;
    ACCESS_MASK             DesiredAccess;
    ULONG           cbSD = 0;
    GUID            ClassGuid;
    ULONG           ClassGuidLength = sizeof(GUID);
    BOOLEAN         bTemp = FALSE;
    PSID            PrincipleSelfSid = NULL;
    UNICODE_STRING  ObjectName;
    BOOLEAN         FreeObjectName = FALSE;
    BOOLEAN         ImpersonatingNullSession = FALSE;

    SAMTRACE("SampValidateDomainControllerCreation");

    //
    // Get this object itself SID
    // (except for the Server Object, because server object does not have SID)
    //
    if (SampServerObjectType != Context->ObjectType)
    {
        PrincipleSelfSid = SampDsGetObjectSid(Context->ObjectNameInDs);

        if (NULL == PrincipleSelfSid)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Get this object's Object Name
    //
    RtlZeroMemory(&ObjectName, sizeof(UNICODE_STRING));

    if (Context->ObjectNameInDs->NameLen > 0)
    {
        ObjectName.Length = ObjectName.MaximumLength =
                        (USHORT) Context->ObjectNameInDs->NameLen * sizeof(WCHAR);
        ObjectName.Buffer = Context->ObjectNameInDs->StringName;
    }
    else if (SampServerObjectType != Context->ObjectType)
    {
        //
        // If the name is not there at least the SID must be there
        //
        ASSERT(Context->ObjectNameInDs->SidLen > 0);

        NtStatus = RtlConvertSidToUnicodeString(&ObjectName, (PSID)&(Context->ObjectNameInDs->Sid), TRUE);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
        FreeObjectName = TRUE;
    }


    //
    // Get the domain
    //

    Domain = &SampDefinedDomains[ Context->DomainIndex ];

    DomainContext = Domain->Context;

    //
    // It should not be the Builtin Domain
    //

    ASSERT(!Domain->IsBuiltinDomain && "Shouldn't Be Builtin Domain");

    //
    // It should not be in registry mode
    //
    ASSERT(IsDsObject(DomainContext));

    //
    // Get the Domain's Security Descriptor
    //
    NtStatus = SampGetDomainObjectSDFromDsName(
                            DomainContext->ObjectNameInDs,
                            &cbSD,
                            &pSD
                            );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Get the Class GUID
    //

    NtStatus = SampGetClassAttribute(
                                DomainContext->DsClassId,
                                ATT_SCHEMA_ID_GUID,
                                &ClassGuidLength,
                                &ClassGuid
                                );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    ASSERT(ClassGuidLength == sizeof(GUID));

    //
    // Setup Object List
    //

    ObjList[0].Level = ACCESS_OBJECT_GUID;
    ObjList[0].Sbz = 0;
    ObjList[0].ObjectType = &ClassGuid;
    //
    // Every control access guid is considered to be in it's own property
    // set. To achieve this, we treat control access guids as property set
    // guids.
    //
    ObjList[1].Level = ACCESS_PROPERTY_SET_GUID;
    ObjList[1].Sbz = 0;
    ObjList[1].ObjectType = (GUID *)&GUID_CONTROL_DsInstallReplica;


    //
    // Assume full access
    //

    Results[0] = 0;
    Results[1] = 0;

    //
    // Impersonate the client
    //

    NtStatus = SampImpersonateClient(&ImpersonatingNullSession);

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Allow a chance to break before the access check
    //

    IF_SAMP_GLOBAL(BREAK_ON_CHECK)
        DebugBreak();


    //
    // Set the desired access
    //

    DesiredAccess = RIGHT_DS_CONTROL_ACCESS;

    //
    // Map the desired access to contain no
    // generic accesses.
    //

    MapGenericMask(&DesiredAccess, &GenericMapping);


    NtStatus = NtAccessCheckByTypeResultListAndAuditAlarm(
                                &SampSamSubsystem,          // SubSystemName
                                (PVOID) Context,            // HandleId or NULL
                                &SampObjectInformation[ Context->ObjectType ].ObjectTypeName, // ObjectTypyName
                                &ObjectName,                // ObjectName
                                pSD,                        // Domain NC head's SD
                                PrincipleSelfSid,           // This machine account's SID
                                DesiredAccess,              // Desired Access
                                AuditEventDirectoryServiceAccess,   // Audit Type
                                0,                          // Flags
                                ObjList,                    // Object Type List
                                2,                          // Object Typy List Length
                                &GenericMapping,            // Generic Mapping
                                FALSE,                      // Object Creation
                                GrantedAccess,              // Granted Status
                                Results,                    // Access Status
                                &bTemp);                    // Generate On Close

    //
    // Stop impersonating the client
    //

    SampRevertToSelf(ImpersonatingNullSession);

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Ok, we checked access, Now, access is granted if either
        // we were granted access on the entire object (i.e. Results[0]
        // is NULL ) or we were granted explicit rights on the access
        // guid (i.e. Results[1] is NULL).
        //

        if ( Results[0] && Results[1] )
        {
            NtStatus = STATUS_ACCESS_DENIED;
        }
    }


Error:

    if (NULL != pSD)
    {
        MIDL_user_free(pSD);
    }

    if (FreeObjectName)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, ObjectName.Buffer);
    }

    return NtStatus;

}


NTSTATUS
SampValidateObjectAccess(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK  DesiredAccess,
    IN BOOLEAN      ObjectCreation
    )
{
    return(SampValidateObjectAccess2(
                Context,
                DesiredAccess,
                NULL,
                ObjectCreation,
                FALSE,
                FALSE
                ));
}

NTSTATUS
SampValidateObjectAccess2(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN HANDLE      ClientToken,
    IN BOOLEAN     ObjectCreation,
    IN BOOLEAN     ChangePassword,
    IN BOOLEAN     SetPassword
    )

/*++

Routine Description:

    This service performs access validation on the specified object.
    The security descriptor of the object is expected to be in a sub-key
    of the ObjectRootKey named "SecurityDescriptor".


    This service:

        1) Retrieves the target object's SecurityDescriptor from the
           the ObjectRootKey or from the DS in DS mode.

        2) Impersonates the client.  If this fails, and we have a
            null session token to use, imperonate that.

        3) Uses NtAccessCheckAndAuditAlarm() to validate access to the
           object, In DS mode it uses   SampDoNt5SdBasedAccessCheck which does the
           mapping from downlevel to NT5 rights before the access check.

        4) Stops impersonating the client.

    Upon successful completion, the passed context's GrantedAccess mask
    and AuditOnClose fields will be properly set to represent the results
    of the access validation.  If the AuditOnClose field is set to TRUE,
    then the caller is responsible for calling SampAuditOnClose() when
    the object is closed.


     This function also has a different behaviour for loopback clients. For loopback
     clients the access mask that is specifies is the one on which we do the access check.
     After we successfully access check for those rights we grant all the remaining rights.
     This is because the access mask specifies those rights which the DS did not know how
     to access ck for  ( like control access right on change password ) and the DS has already
     access checked for all the remainder rights that are really required.



Arguments:

    Context - The handle value that will be assigned if the access validation
        is successful.

    DesiredAccess - Specifies the accesses being requested to the target
        object. In the loopback case ( context is marked as a loopback client ) specifies
        the access that we need to check above what the DS has checked . Typically used to
        check accesses such as change password that the DS does not know how to check for.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.


    ChangePasswordOperation


    SetPasswordOperation



Return Value:

    STATUS_SUCCESS - Indicates access has been granted.

    Other values that may be returned are those returned by:

            NtAccessCheckAndAuditAlarm()




--*/
{

    NTSTATUS NtStatus=STATUS_SUCCESS,
             IgnoreStatus=STATUS_SUCCESS,
             AccessStatus=STATUS_SUCCESS;
    ULONG SecurityDescriptorLength;
    PSECURITY_DESCRIPTOR SecurityDescriptor =NULL;
    ACCESS_MASK MappedDesiredAccess;
    BOOLEAN TrustedClient;
    BOOLEAN LoopbackClient;
    SAMP_OBJECT_TYPE ObjectType;
    PUNICODE_STRING ObjectName = NULL;
    ULONG DomainIndex;
    ULONG AllAccess = 0;
    BOOLEAN fNoAccessRequested = FALSE;
    ULONG   AccessToRestrictAnonymous = 0;
    HANDLE UserToken = INVALID_HANDLE_VALUE;
    PSID    SelfSid = NULL;
    ULONG   LocalGrantedAccess = 0;

    SAMTRACE("SampValidateObjectAccess");

    //
    // Extract various fields from the account context
    //

    TrustedClient = Context->TrustedClient;
    LoopbackClient= Context->LoopbackClient;
    ObjectType    = Context->ObjectType;
    DomainIndex   = Context->DomainIndex;

    //
    // Map the desired access
    //

    MappedDesiredAccess = DesiredAccess;
    RtlMapGenericMask(
        &MappedDesiredAccess,
        &SampObjectInformation[ ObjectType ].GenericMapping
        );

    //
    // Calculate the string to use as an object name for auditing
    //

    NtStatus = STATUS_SUCCESS;

    switch (ObjectType) {

    case SampServerObjectType:
        ObjectName = &SampServerObjectName;
        AllAccess  = SAM_SERVER_ALL_ACCESS;
        AccessToRestrictAnonymous = 0;
        break;

    case SampDomainObjectType:
        ObjectName = &SampDefinedDomains[DomainIndex].ExternalName;
        AllAccess  = DOMAIN_ALL_ACCESS;
        AccessToRestrictAnonymous = DOMAIN_LIST_ACCOUNTS | DOMAIN_READ_PASSWORD_PARAMETERS;
        break;

    case SampUserObjectType:
        ObjectName = &Context->RootName;
        AllAccess = USER_ALL_ACCESS;
        AccessToRestrictAnonymous = USER_LIST_GROUPS;
        break;

    case SampGroupObjectType:
        ObjectName = &Context->RootName;
        AllAccess = GROUP_ALL_ACCESS;
        AccessToRestrictAnonymous = GROUP_LIST_MEMBERS;
        break;

    case SampAliasObjectType:
        ObjectName = &Context->RootName;
        AllAccess = ALIAS_ALL_ACCESS;
        AccessToRestrictAnonymous = ALIAS_LIST_MEMBERS;
        break;

    default:
        ASSERT(FALSE && "Invalid Object Type");
        break;
    }


    ASSERT(AllAccess && "AllAccess not initialized\n");

    if (TrustedClient) {
        Context->GrantedAccess = LoopbackClient?AllAccess:MappedDesiredAccess;
        Context->AuditOnClose  = FALSE;
        return(STATUS_SUCCESS);
    }

    if (LoopbackClient) {

        //
        // A loopback client means Ntdsa calling back into SAM.
        // The only case an access ck needs to be perfomed by
        // SAM is if it is a change password or a set password
        // operation. In all other cases, ntdsa has already peformed
        // an access ck -- the values are being looped through SAM only
        // other types of validation -- like account name uniqueness
        //

        if ((!ChangePassword) && (!SetPassword))
        {
            Context->GrantedAccess = AllAccess;
            Context->AuditOnClose = FALSE;
            return(STATUS_SUCCESS);
        }
    }

    //
    // Fetch the security descriptor
    //

    NtStatus = SampGetObjectSD(
                    Context,
                    &SecurityDescriptorLength, 
                    &SecurityDescriptor
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }
    //
    // Password change case is special. If it is a change password operation,
    // then we need to validate Access to change password on the user object.
    // We special case change password to appear as an authentication protocol
    // -- this is done in general by performing the access ck using a Token
    // that only contains the SELF and EVERYONE SIDs.There are special caveats
    // involving use of ForceGuest and LimitBlankPasswordAccess settings which
    // alter the composition of the token.
    //

    if (ChangePassword)
    {
        
         ASSERT(DesiredAccess == USER_CHANGE_PASSWORD);
         ASSERT(SampUserObjectType == ObjectType);

         NtStatus  = SampCreateUserToken(Context,ClientToken,&UserToken);
         if (!NT_SUCCESS(NtStatus))
         {
             goto Error;
         }
    }
    else if (SampUserObjectType == ObjectType)
    {
        //
        // Do not access check for change password
        // on user objects, unless the change password
        // boolean is set. This is because various scenarios
        // need the access ck to be delayed till the time
        // of the actual change password and not perform
        // this opeation at handle open time.
        // We'll know to access ck if requested.
        //

        DesiredAccess &= ~(USER_CHANGE_PASSWORD);
        MappedDesiredAccess &= ~(USER_CHANGE_PASSWORD);
    }

    //
    // If the desired access field is 0 and the handle is being opened by SAM
    // itself, then allow the handle open. It could be that the real caller did not
    // have any access and therefore the access ck below could fail. The 0 desired 
    // access trick is used in internal handle opens, to delay the access ck to 
    // the time when the operations is being performed to when the handle is being
    // opened.
    //

    if ((Context->OpenedBySystem) && (0==DesiredAccess))
    {
        Context->GrantedAccess = 0;
        Context->AuditOnClose  = FALSE;
        NtStatus = STATUS_SUCCESS;
        AccessStatus = STATUS_SUCCESS;
        goto Error;
    }

    //
    // Perform the access check. Note we do different things for DS mode and
    // Registry mode
    //

    if (IsDsObject(Context))
    {
        
        //
        // Call the DS mode access check routine.
        // The DS mode access check routine is different from a simple access
        // check. The reason for this is that in SAM the access rights are 
        // defined based on attribute groups as defined in ntsam.h. The security
        // descriptor however is retrieved from the DS, and the acls have
        // their access masks set in terms of DS access mask constants. Therefore
        // a corresponding mapping needs to be performed during the time of the
        // access check.
        //
     
        NtStatus =  SampDoNt5SdBasedAccessCheck(
                        Context,
                        SecurityDescriptor,
                        NULL,
                        ObjectType,
                        DesiredAccess,
                        ObjectCreation,
                        &SampObjectInformation[ ObjectType ].GenericMapping,
                        (UserToken!=INVALID_HANDLE_VALUE)?
                                UserToken:ClientToken,
                        &Context->GrantedAccess,
                        &Context->WriteGrantedAccessAttributes,
                        &AccessStatus    
                        );
         
    }
    else
    {    
        
        //
        // If  we are restricting null
        // session access, remove the anonymous domain list account
        // access.
        //

        if (SampRestrictNullSessions ) {

            NtStatus = SampRemoveAnonymousAccess(
                                    &SecurityDescriptor,
                                    &SecurityDescriptorLength,
                                    AccessToRestrictAnonymous,
                                    ObjectType
                                    );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }

     
        if (UserToken!=INVALID_HANDLE_VALUE)
        {
            CHAR    PrivilegeSetBuffer[256];
            PRIVILEGE_SET  *PrivilegeSet = (PRIVILEGE_SET *)PrivilegeSetBuffer;
            ULONG          PrivilegeSetLength = sizeof(PrivilegeSetBuffer);

            //
            // Access validate the client
            //
             
            NtStatus = NtAccessCheck (
                            SecurityDescriptor,
                            UserToken,
                            MappedDesiredAccess,
                            &SampObjectInformation[ObjectType].GenericMapping,
                            PrivilegeSet,
                            &PrivilegeSetLength,
                            &Context->GrantedAccess,
                            &AccessStatus
                            );
        }
        else
        {
            
               

            BOOLEAN ImpersonatingNullSession = FALSE;

            //
            // Impersonate the client.  If RPC impersonation fails because
            // it is not supported (came in unauthenticated), then impersonate
            // the null session.
            //

            NtStatus = SampImpersonateClient(&ImpersonatingNullSession);
            
      
            if (NT_SUCCESS(NtStatus)) {

                //
                // Because of bug 411289, the NtAccessCheck* API's don't return
                // ACCESS_DENIED when presented with 0 access.  Because clients
                // may already expect this behavoir, only return ACCESS_DENIED
                // when the client really doesn't have any access. We want to
                // return ACCESS_DENIED to prevent anonymous clients from acquiring
                // handles.
                //
                if ( MappedDesiredAccess == 0 ) {
                    fNoAccessRequested = TRUE;
                    MappedDesiredAccess = MAXIMUM_ALLOWED;
                }

                NtStatus = NtAccessCheckAndAuditAlarm(
                               &SampSamSubsystem,
                               (PVOID)Context,
                               &SampObjectInformation[ ObjectType ].ObjectTypeName,
                               ObjectName,
                               SecurityDescriptor,
                               MappedDesiredAccess,
                               &SampObjectInformation[ ObjectType ].GenericMapping,
                               ObjectCreation,
                               &Context->GrantedAccess,
                               &AccessStatus,
                               &Context->AuditOnClose
                               );

                if ( fNoAccessRequested ) {

                    MappedDesiredAccess = 0;

                    if ( NT_SUCCESS( NtStatus )
                     &&  NT_SUCCESS( AccessStatus ) ) {

                        Context->GrantedAccess = 0;
                    }
                }

                //
                // Stop impersonating the client
                //

                SampRevertToSelf(ImpersonatingNullSession);

            }
        }
    }
        
  
Error:

    //
    // Free up the security descriptor
    //

    if (NULL!=SecurityDescriptor) {

        MIDL_user_free( SecurityDescriptor );

    }

    if (UserToken!=INVALID_HANDLE_VALUE)
    {
        NtClose(UserToken);
    }
    

    //
    // If we got an error back from the access check, return that as
    // status.  Otherwise, return the access check status.
    //

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

  
    return(AccessStatus);
}


VOID
SampAuditOnClose(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This service performs auditing necessary during a handle close operation.

    This service may ONLY be called if the corresponding call to
    SampValidateObjectAccess() during openned returned TRUE.



Arguments:

    Context - This must be the same value that was passed to the corresponding
        SampValidateObjectAccess() call.  This value is used for auditing
        purposes only.

Return Value:

    None.


--*/
{

    SAMTRACE("SampAuditOnClose");

    //FIX, FIX - Call NtAuditClose() (or whatever it is).

    return;

    DBG_UNREFERENCED_PARAMETER( Context );

}


VOID
SampRemoveAnonymousChangePasswordAccess(
    IN OUT PSECURITY_DESCRIPTOR     Sd
    )

/*++

Routine Description:

    This routine removes USER_CHANGE_PASSWORD access from
    any GRANT aces in the discretionary acl that have either
    the WORLD or ANONYMOUS SIDs in the ACE.

Parameters:

    Sd - Is a pointer to a security descriptor of a SAM USER
         object.

Returns:

    None.

--*/
{
    NTSTATUS
        NtStatus = STATUS_SUCCESS;

    PACL
        Dacl;

    ULONG
        i,
        AceCount;

    PACE_HEADER
        Ace;

    BOOLEAN
        DaclPresent = FALSE,
        DaclDefaulted = FALSE;

    SAMTRACE("SampRemoveAnonymousChangePasswordAccess");


    NtStatus = RtlGetDaclSecurityDescriptor( Sd,
                                             &DaclPresent,
                                             &Dacl,
                                             &DaclDefaulted
                                           );

    ASSERT(NT_SUCCESS(NtStatus));
    if (!NT_SUCCESS(NtStatus))
    {
        return;
    }

    if ( !DaclPresent || (Dacl == NULL)) {
        return;
    }

    if ((AceCount = Dacl->AceCount) == 0) {
        return;
    }

    for ( i = 0, Ace = FirstAce( Dacl ) ;
          i < AceCount  ;
          i++, Ace = NextAce( Ace )
        ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

                if ( (RtlEqualSid( SampWorldSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart )) ||
                     (RtlEqualSid( SampAnonymousSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart ))) {

                    //
                    // Turn off CHANGE_PASSWORD access
                    //

                    ((PACCESS_ALLOWED_ACE)Ace)->Mask &= ~USER_CHANGE_PASSWORD;
                }
            }
        }
    }

    return;
}


NTSTATUS
SampRemoveAnonymousAccess(
    IN OUT PSECURITY_DESCRIPTOR *    Sd,
    IN OUT PULONG                    SdLength,
    IN ULONG                         AccessToRemove,
    IN SAMP_OBJECT_TYPE              ObjectType
    )

/*++

Routine Description:

    This routine removes removes the DOMAIN_LIST_ACCOUNTS bit from the
    World ACE and adds an ace granting it to AUTHENTICATED USERS.

Parameters:

    Sd - Is a pointer to a pointer to asecurity descriptor of a SAM DOMAIN
         object. If the SD needs to be changed a new one will be allocated
         and this one freed.

    SdLength - Length of the security descriptor, which will be modified
        if a new SD is allocated.

Returns:

    None.

--*/
{
    NTSTATUS
        NtStatus = STATUS_SUCCESS,
        Status = STATUS_SUCCESS;
    PACL
        Dacl;

    ULONG
        i,
        AceCount;

    PACE_HEADER
        Ace;

    ACCESS_MASK GrantedAccess = 0;

    BOOLEAN
        DaclPresent = FALSE,
        DaclDefaulted = FALSE;


    NtStatus = RtlGetDaclSecurityDescriptor( *Sd,
                                             &DaclPresent,
                                             &Dacl,
                                             &DaclDefaulted
                                            );

    ASSERT(NT_SUCCESS(NtStatus));
    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }

    if ( !DaclPresent || (Dacl == NULL)) {
        return(STATUS_SUCCESS);
    }

    if ((AceCount = Dacl->AceCount) == 0) {
        return(STATUS_SUCCESS);
    }

    for ( i = 0, Ace = FirstAce( Dacl ) ;
          i < AceCount  ;
          i++, Ace = NextAce( Ace )
        ) {

        if ( !(((PACE_HEADER)Ace)->AceFlags & INHERIT_ONLY_ACE)) {

            if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

                if ( (RtlEqualSid( SampWorldSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart )) ||
                     (RtlEqualSid( SampAnonymousSid, &((PACCESS_ALLOWED_ACE)Ace)->SidStart ))) {

                    //
                    // Turn off the access to remove
                    //

                    GrantedAccess |= (((PACCESS_ALLOWED_ACE)Ace)->Mask) & (AccessToRemove);
                    ((PACCESS_ALLOWED_ACE)Ace)->Mask &= ~(AccessToRemove);
                }
            }
        }
    }

    //
    // If AccessToRemove was granted everyone, add an ACE for
    // AUTHENTICATED USER granting it AccessToRemove
    //

    if (GrantedAccess != 0 ) {
        PSECURITY_DESCRIPTOR SdCopy = NULL;
        PSECURITY_DESCRIPTOR NewSd = NULL;
        PACL NewDacl = NULL;
        ULONG NewDaclSize;
        ULONG TempSize;
        SECURITY_DESCRIPTOR TempSd;

        //
        // Copy the SD to absolute so we can modify it.
        //

        Status = RtlCopySecurityDescriptor(
                    *Sd,
                    &SdCopy
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Now get the create a new dacl
        //

        NewDaclSize = Dacl->AclSize +
                        sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                        RtlLengthSid(SampAuthenticatedUsersSid);

        NewDacl = MIDL_user_allocate(NewDaclSize);

        if (NewDacl == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = RtlCreateAcl( NewDacl, NewDaclSize, ACL_REVISION2);
        ASSERT( NT_SUCCESS(Status) );

        //
        // Add the ACEs from the old DACL into this DACL.
        //

        Status = RtlAddAce(
                    NewDacl,
                    ACL_REVISION2,
                    0,
                    FirstAce(Dacl),
                    Dacl->AclSize - sizeof(ACL)
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Add the new ace
        //

        Status = RtlAddAccessAllowedAce(
                    NewDacl,
                    ACL_REVISION2,
                    GrantedAccess,
                    SampAuthenticatedUsersSid
                    );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Build a dummy SD to pass to RtlSetSecurityObject that contains
        // the new DACL.
        //

        Status = RtlCreateSecurityDescriptor(
                    &TempSd,
                    SECURITY_DESCRIPTOR_REVISION1
                    );
        ASSERT(NT_SUCCESS(Status));

        Status = RtlSetDaclSecurityDescriptor(
                    &TempSd,
                    TRUE,               // DACL present,
                    NewDacl,
                    FALSE               // not defaulted
                    );
        ASSERT(NT_SUCCESS(Status));

        //
        // Now merge the existing SD with the new security descriptor
        //

        Status = RtlSetSecurityObject(
                    DACL_SECURITY_INFORMATION,
                    &TempSd,
                    &SdCopy,
                    &SampObjectInformation[ObjectType].GenericMapping,
                    NULL                // no token
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Now copy the SD, which into one allocated with MIDL_user_allocate
        //


        TempSize = RtlLengthSecurityDescriptor( SdCopy );
        NewSd = MIDL_user_allocate(TempSize);
        if (NewSd == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            NewSd,
            SdCopy,
            TempSize
            );

        MIDL_user_free(*Sd);
        *Sd = NewSd;
        *SdLength = TempSize;
        NewSd = NULL;

Cleanup:
        if (SdCopy != NULL) {
            RtlFreeHeap(RtlProcessHeap(),0, SdCopy );
        }
        if (NewDacl != NULL) {
            MIDL_user_free(NewDacl);
        }
        if (NewSd != NULL) {
            MIDL_user_free(NewSd);
        }
    }

    return Status;
}

TOKEN_SOURCE SourceContext;


NTSTATUS
SampCreateNullToken(
    )

/*++

Routine Description:

    This function creates a token representing a null logon.

Arguments:


Return Value:

    The status value of the NtCreateToken() call.



--*/

{
    NTSTATUS Status;

    TOKEN_USER UserId;
    TOKEN_PRIMARY_GROUP PrimaryGroup;
    TOKEN_GROUPS GroupIds;
    TOKEN_PRIVILEGES Privileges;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE ImpersonationQos;
    LARGE_INTEGER ExpirationTime;
    LUID LogonId = SYSTEM_LUID;

    SAMTRACE("SampCreateNullToken");



    UserId.User.Sid = SampAnonymousSid;
    UserId.User.Attributes = 0;
    GroupIds.GroupCount = 0;
    Privileges.PrivilegeCount = 0;
    PrimaryGroup.PrimaryGroup = SampAnonymousSid;
    ExpirationTime.LowPart = 0xfffffff;
    ExpirationTime.LowPart = 0x7ffffff;


    //
    // Build a token source for SAM.
    //

    Status = NtAllocateLocallyUniqueId( &SourceContext.SourceIdentifier );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    strncpy(SourceContext.SourceName,"SamSS   ",sizeof(SourceContext.SourceName));


    //
    // Set the object attributes to specify an Impersonation impersonation
    // level.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
    ImpersonationQos.ImpersonationLevel = SecurityImpersonation;
    ImpersonationQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    ImpersonationQos.EffectiveOnly = TRUE;
    ImpersonationQos.Length = (ULONG)sizeof(SECURITY_QUALITY_OF_SERVICE);
    ObjectAttributes.SecurityQualityOfService = &ImpersonationQos;

    Status = NtCreateToken(
                 &SampNullSessionToken,    // Handle
                 (TOKEN_ALL_ACCESS),       // DesiredAccess
                 &ObjectAttributes,        // ObjectAttributes
                 TokenImpersonation,       // TokenType
                 &LogonId,                  // Authentication LUID
                 &ExpirationTime,          // Expiration Time
                 &UserId,                  // User ID
                 &GroupIds,                // Group IDs
                 &Privileges,              // Privileges
                 NULL,                     // Owner
                 &PrimaryGroup,            // Primary Group
                 NULL,                     // Default Dacl
                 &SourceContext            // TokenSource
                 );

    return Status;

}


NTSTATUS
SampCreateUserToken(
    IN PSAMP_OBJECT UserContext,
    IN  HANDLE      PassedInToken,
    OUT HANDLE      *UserToken
    )

/*++

Routine Description:

    This function creates a token representing a null logon.

Arguments:


Return Value:

    The status value of the NtCreateToken() call.



--*/

{
    NTSTATUS Status;

    TOKEN_USER UserId;
    TOKEN_PRIMARY_GROUP PrimaryGroup;
    TOKEN_GROUPS GroupIds;
    TOKEN_PRIVILEGES Privileges;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE ImpersonationQos;
    LARGE_INTEGER ExpirationTime;
    LUID LogonId = SYSTEM_LUID;
    PSID UserSid = NULL;
    BOOLEAN EnableLimitBlankPasswordUse = FALSE;

    SAMTRACE("SampCreateUserToken");


    //
    // Test  for LimitBlankPasswordUse
    //

    if ((SampLimitBlankPasswordUse) && (!SampUseDsData))
    {
        BOOL Administrator = FALSE;
        NT_OWF_PASSWORD  NtOwfPassword;
        LM_OWF_PASSWORD  LmOwfPassword;
        BOOLEAN          LmPasswordNonNull = FALSE,
                         NtPasswordNonNull = FALSE,
                         NtPasswordPresent = FALSE,
                         PasswordPresent   = TRUE;
                         
        //
        // Get the caller
        //

        Status = SampGetCurrentClientSid(PassedInToken, &UserSid, &Administrator);
        if (!NT_SUCCESS(Status)) {

            goto Error;
        }

        //
        // Check if current password is blank
        //

        Status = SampRetrieveUserPasswords(
                        UserContext,
                        &LmOwfPassword,
                        &LmPasswordNonNull,
                        &NtOwfPassword,
                        &NtPasswordPresent,
                        &NtPasswordNonNull
                        );

        if (!NT_SUCCESS(Status)) {
         
            goto Error;
        }

       
        PasswordPresent = (( NtPasswordPresent && NtPasswordNonNull)
                             || ( LmPasswordNonNull));

        if ((Administrator )
            ||(RtlEqualSid(UserSid,SampLocalSystemSid))
            ||(PasswordPresent)) {
            
            // 
            // In these cases limit blank password use does not apply
            // Don't restrict an admin or local system, or if a password
            // is present on an account
            //

            MIDL_user_free(UserSid);
            UserSid = NULL;
        }
        else {

            EnableLimitBlankPasswordUse = TRUE;
        }
    }

    if ((SampIsForceGuestEnabled() || EnableLimitBlankPasswordUse)
            && !SampIsClientLocal())
    {
        //
        // if force guest or is enabled 
        // or LimitBlankPasswordUse is enabled and client is not local
        // then build a token with only the anonymous SID in 
        // it
        //
        
        UserId.User.Sid = SampAnonymousSid;
        UserId.User.Attributes = 0;
        GroupIds.GroupCount = 1;
        GroupIds.Groups[0].Sid = SampNetworkSid;
        GroupIds.Groups[0].Attributes = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
        Privileges.PrivilegeCount = 0;
        PrimaryGroup.PrimaryGroup = SampNetworkSid;
        ExpirationTime.LowPart = 0xfffffff;
        ExpirationTime.LowPart = 0x7ffffff;
    }
    else if (EnableLimitBlankPasswordUse)
    {
        UserId.User.Sid = UserSid;
        UserId.User.Attributes = 0;
        Privileges.PrivilegeCount = 0;
        PrimaryGroup.PrimaryGroup = UserSid;
        GroupIds.GroupCount = 0;
        ExpirationTime.LowPart = 0xfffffff;
        ExpirationTime.LowPart = 0x7ffffff;
    }
    else
    {

        //
        // Get the user Sid
        //

        Status = SampCreateFullSid(
                    SampDefinedDomains[UserContext->DomainIndex].Sid,
                    UserContext->TypeBody.User.Rid,
                    &UserSid
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }

        UserId.User.Sid = UserSid;
        UserId.User.Attributes = 0;
        GroupIds.GroupCount = 1;
        GroupIds.Groups[0].Sid = SampWorldSid;
        GroupIds.Groups[0].Attributes = SE_GROUP_MANDATORY| SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
        Privileges.PrivilegeCount = 0;
        PrimaryGroup.PrimaryGroup = SampWorldSid;
        ExpirationTime.LowPart = 0xfffffff;
        ExpirationTime.LowPart = 0x7ffffff;
    }


    //
    // Build a token source for SAM.
    //

    //
    // Set the object attributes to specify an Impersonation impersonation
    // level.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
    ImpersonationQos.ImpersonationLevel = SecurityImpersonation;
    ImpersonationQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    ImpersonationQos.EffectiveOnly = TRUE;
    ImpersonationQos.Length = (ULONG)sizeof(SECURITY_QUALITY_OF_SERVICE);
    ObjectAttributes.SecurityQualityOfService = &ImpersonationQos;

    Status = NtCreateToken(
                 UserToken,                // Handle
                 (TOKEN_ALL_ACCESS),       // DesiredAccess
                 &ObjectAttributes,        // ObjectAttributes
                 TokenImpersonation,       // TokenType
                 &LogonId,                  // Authentication LUID
                 &ExpirationTime,          // Expiration Time
                 &UserId,                  // User ID
                 &GroupIds,                // Group IDs
                 &Privileges,              // Privileges
                 NULL,                     // Owner
                 &PrimaryGroup,            // Primary Group
                 NULL,                     // Default Dacl
                 &SourceContext            // TokenSource
                 );

Error:

    if (NULL!=UserSid)
    {
        MIDL_user_free(UserSid);
    }

    return Status;

}

ULONG
SampSecureRpcInit(
    PVOID Ignored
    )
/*++

Routine Description:

    This routine waits for the NTLMSSP service to start and then registers
    security information with RPC to allow authenticated RPC to be used to
    SAM.  It also registers an SPX endpoint if FPNW is installed.

Arguments:

    Ignored - required parameter for starting a thread.

Return Value:

    None.

--*/
{

#define MAX_RPC_RETRIES 30

    ULONG RpcStatus = ERROR_SUCCESS;
    ULONG LogStatus = ERROR_SUCCESS;
    ULONG RpcRetry;
    ULONG RpcSleepTime = 10 * 1000;     // retry every ten seconds
    RPC_BINDING_VECTOR * BindingVector = NULL;
    RPC_POLICY rpcPolicy;
    BOOLEAN AdditionalTransportStarted = FALSE;

    SAMTRACE("SampSecureRpcInit");

    rpcPolicy.Length = sizeof(RPC_POLICY);
    rpcPolicy.EndpointFlags = RPC_C_DONT_FAIL;
    rpcPolicy.NICFlags = 0;

    RpcStatus = RpcServerRegisterAuthInfoW(
                    NULL,                   // server principal name
                    RPC_C_AUTHN_WINNT,
                    NULL,                   // no get key function
                    NULL                    // no get key argument
                    );

    if (RpcStatus != 0) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Could not register auth. info: %d\n",
                   RpcStatus));

        goto ErrorReturn;
    }

    //
    // If the Netware server is installed, register the SPX protocol.
    // Since the transport may not be loaded yet, retry a couple of times
    // if we get a CANT_CREATE_ENDPOINT error (meaning the transport isn't
    // there).
    //

    if (SampNetwareServerInstalled) {
        RpcRetry = MAX_RPC_RETRIES;
        while (RpcRetry != 0) {

            RpcStatus = RpcServerUseProtseqExW(
                            L"ncacn_spx",
                            10,
                            NULL,           // no security descriptor
                            &rpcPolicy
                            );

            //
            // If it succeded break out of the loop.
            //
            if (RpcStatus == ERROR_SUCCESS) {
                break;
            }
            Sleep(RpcSleepTime);
            RpcRetry--;
            continue;

        }

        if (RpcStatus != 0) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS:  Could not register SPX endpoint: %d\n",
                       RpcStatus));

            LogStatus = RpcStatus;
        } else {
            AdditionalTransportStarted = TRUE;
        }

    }

    //
    // do the same thing all over again with TcpIp
    //

    if (SampIpServerInstalled) {

        RpcRetry = MAX_RPC_RETRIES;
        while (RpcRetry != 0) {

            RpcStatus = RpcServerUseProtseqExW(
                            L"ncacn_ip_tcp",
                            10,
                            NULL,           // no security descriptor
                            &rpcPolicy
                            );

            //
            // If it succeeded, break out of the loop.
            //

            if (RpcStatus == ERROR_SUCCESS) {
                 break;
             }
            Sleep(RpcSleepTime);
            RpcRetry--;
            continue;

        }

        if (RpcStatus != 0) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS:  Could not register TCP endpoint: %d\n",
                       RpcStatus));

            LogStatus = RpcStatus;
        } else {
            AdditionalTransportStarted = TRUE;
        }

    }

    //
    // do the same thing all over again with apple talk
    //

    if (SampAppletalkServerInstalled) {

        RpcRetry = MAX_RPC_RETRIES;
        while (RpcRetry != 0) {

            RpcStatus = RpcServerUseProtseqW(
                            L"ncacn_at_dsp",
                            10,
                            NULL            // no security descriptor
                            );

            //
            // If it succeeded, break out of the loop.
            //

            if (RpcStatus == ERROR_SUCCESS) {
                 break;
             }
            Sleep(RpcSleepTime);
            RpcRetry--;
            continue;

        }

        if (RpcStatus != 0) {
            KdPrint(("SAMSS:  Could not register Appletalk endpoint: %d\n", RpcStatus ));
            LogStatus = RpcStatus;
        } else {
            AdditionalTransportStarted = TRUE;
        }

    }

    //
    // do the same thing all over again with Vines
    //

    if (SampVinesServerInstalled) {

        RpcRetry = MAX_RPC_RETRIES;
        while (RpcRetry != 0) {

            RpcStatus = RpcServerUseProtseqW(
                            L"ncacn_vns_spp",
                            10,
                            NULL            // no security descriptor
                            );

            //
            // If it succeeded, break out of the loop.
            //

            if (RpcStatus == ERROR_SUCCESS) {
                 break;
             }
            Sleep(RpcSleepTime);
            RpcRetry--;
            continue;

        }

        if (RpcStatus != 0) {
            KdPrint(("SAMSS:  Could not register Vines endpoint: %d\n", RpcStatus ));
            LogStatus = RpcStatus;
        } else {
            AdditionalTransportStarted = TRUE;
        }
    }

    //
    // If we started an additional transport, go on to register the endpoints
    //

    if (AdditionalTransportStarted) {

        RpcStatus = RpcServerInqBindings(&BindingVector);
        if (RpcStatus != 0) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Could not inq bindings: %d\n",
                       RpcStatus));

            goto ErrorReturn;
        }
        RpcStatus = RpcEpRegister(
                        samr_ServerIfHandle,
                        BindingVector,
                        NULL,                   // no uuid vector
                        L""                     // no annotation
                        );

        RpcBindingVectorFree(&BindingVector);
        if (RpcStatus != 0) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Could not register endpoints: %d\n",
                       RpcStatus));

            goto ErrorReturn;
        }

    }

ErrorReturn:

    //
    // RpcStatus's will contain more serious errors
    //
    if ( RpcStatus != ERROR_SUCCESS) {
        LogStatus = RpcStatus;
    }

    if ( LogStatus != ERROR_SUCCESS ) {

        if (!(SampIsSetupInProgress(NULL)))
        {
            SampWriteEventLog(
                EVENTLOG_ERROR_TYPE,
                0,  // Category
                SAMMSG_RPC_INIT_FAILED,
                NULL, // User Sid
                0, // Num strings
                sizeof(ULONG), // Data size
                NULL, // String array
                (PVOID)&LogStatus // Data
                );
        }
    }

    return(RpcStatus);
}


BOOLEAN
SampStartNonNamedPipeTransports(
    )
/*++

Routine Description:

    This routine checks to see if we should listen on a non-named pipe
    transport.  We check the registry for flags indicating that we should
    listen on Tcp/Ip and SPX. There is a flag
    in the registry under system\currentcontrolset\Control\Lsa\
    NetwareClientSupport and TcpipClientSupport indicating whether or not
    to setup the endpoint.


Arguments:


Return Value:

    TRUE - Netware (FPNW or SmallWorld) is installed and the SPX endpoint
        should be started.

    FALSE - Either Netware is not installed, or an error occurred while
        checking for it.
--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    UCHAR Buffer[100];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    ULONG KeyValueLength = 100;
    ULONG ResultLength;
    PULONG SpxFlag;

    SAMTRACE("SampStartNonNamedPipeTransport");

    SampNetwareServerInstalled = FALSE;
    SampIpServerInstalled = FALSE;

    //
    // Open the Lsa key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        return(FALSE);
    }

    //
    // Query the NetwareClientSupport value
    //

    RtlInitUnicodeString(
        &KeyName,
        L"NetWareClientSupport"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );

    SampDumpNtQueryValueKey(&KeyName,
                            KeyValuePartialInformation,
                            KeyValueInformation,
                            KeyValueLength,
                            &ResultLength);


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            SpxFlag = (PULONG) KeyValueInformation->Data;

            if (*SpxFlag == 1) {
                SampNetwareServerInstalled = TRUE;
            }
        }

    }
    //
    // Query the Tcp/IpClientSupport  value
    //

    RtlInitUnicodeString(
        &KeyName,
        L"TcpipClientSupport"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );

    SampDumpNtQueryValueKey(&KeyName,
                            KeyValuePartialInformation,
                            KeyValueInformation,
                            KeyValueLength,
                            &ResultLength);


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            SpxFlag = (PULONG) KeyValueInformation->Data;

            if (*SpxFlag == 1) {
                SampIpServerInstalled = TRUE;
            }
        }

    }

    //
    // Query the AppletalkClientSupport  value
    //

    RtlInitUnicodeString(
        &KeyName,
        L"AppletalkClientSupport"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            SpxFlag = (PULONG) KeyValueInformation->Data;

            if (*SpxFlag == 1) {
                SampAppletalkServerInstalled = TRUE;
            }
        }

    }

    //
    // Query the VinesClientSupport  value
    //

    RtlInitUnicodeString(
        &KeyName,
        L"VinesClientSupport"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            SpxFlag = (PULONG) KeyValueInformation->Data;

            if (*SpxFlag == 1) {
                SampVinesServerInstalled = TRUE;
            }
        }

    }


    NtClose(KeyHandle);

    if ( SampNetwareServerInstalled || SampIpServerInstalled
      || SampAppletalkServerInstalled || SampVinesServerInstalled )
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    };
}

VOID
SampCheckNullSessionAccess(
    IN HKEY LsaKey 
    )
/*++

Routine Description:

    This routine checks to see if we should restict null session access.
    in the registry under system\currentcontrolset\Control\Lsa\
    RestrictAnonymous indicating whether or not to restrict access.
    If access is restricted then you need to be an authenticated user to
    get DOMAIN_LIST_ACCOUNTS or GROUP_LIST_MEMBERS or ALIAS_LIST_MEMBERS
    access.

Arguments:

    LsaKey -- an open key to Control\LSA
    
Return Value:

    None - this routines sets the SampRestictNullSessionAccess global.

--*/
{
    DWORD WinError;
    DWORD dwSize, dwValue, dwType;

    dwSize = sizeof(dwValue);
    WinError = RegQueryValueExA(LsaKey,
                                "RestrictAnonymous",
                                NULL,
                                &dwType,
                                (LPBYTE)&dwValue,
                                &dwSize);
    
    if ((ERROR_SUCCESS == WinError) && 
        (REG_DWORD == dwType) &&
        (1 <= dwValue)) {
        SampRestrictNullSessions = TRUE;
    } else {
        SampRestrictNullSessions = FALSE;
    }

    if (!SampRestrictNullSessions) {

        //
        // Try again with the SAM specific key.  Note that "RestrictAnonymous"
        // key is global to NT and several different components read it and
        // behave differently.  "RestrictAnonymousSam" controls the SAM
        // behavior only.
        //
        dwSize = sizeof(dwValue);
        WinError = RegQueryValueExA(LsaKey,
                                    "RestrictAnonymousSam",
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwValue,
                                    &dwSize);
        
        if ((ERROR_SUCCESS == WinError) && 
            (REG_DWORD == dwType) &&
            (1 <= dwValue)) {
            SampRestrictNullSessions = TRUE;
        }
    }
}




NTSTATUS
SampDsGetObjectSDAndClassId(
    IN PDSNAME   ObjectDsName,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT ULONG    *SecurityDescriptorLength,
    OUT ULONG    *ObjectClass
    )
/*++
Routine Description:

    this routine read security descriptor and object class of the object 
    from DS
    
Parameters:

    ObjectDsName - Object Name in DS
    
    SecurityDescriptor - Security descriptor of the object 
    
    SecurityDescriptorLength - Length of security descriptor
    
    ObjectClass - Object Class of this object    

Return Value:


--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DirError = 0, i;
    READARG     ReadArg;
    READRES     *ReadRes = NULL;
    COMMARG     *CommArg = NULL;
    ENTINFSEL   EntInf;
    ATTR        Attr[2];
    ATTRVAL     *pAVal;


    
    //
    // initialize return values
    // 

    *SecurityDescriptor = NULL;
    *SecurityDescriptorLength = 0;
    *ObjectClass = 0;


    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EntInf, sizeof(ENTINF));
    RtlZeroMemory(Attr, sizeof(ATTR) * 2);


    Attr[0].attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    Attr[1].attrTyp = ATT_OBJECT_CLASS; 


    EntInf.AttrTypBlock.attrCount = 2;
    EntInf.AttrTypBlock.pAttr = Attr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInf;
    ReadArg.pObject = ObjectDsName;

    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);

    DirError = DirRead(&ReadArg, &ReadRes);

    if (NULL == ReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError,&ReadRes->CommRes);
    }

    SampClearErrors();

    if (NT_SUCCESS(NtStatus))
    {
        ASSERT(NULL != ReadRes->entry.AttrBlock.pAttr);

        for (i = 0; i < ReadRes->entry.AttrBlock.attrCount; i++)
        {
            pAVal = ReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal; 
            ASSERT((NULL != pAVal[0].pVal) && (0 != pAVal[0].valLen));

            if (ATT_NT_SECURITY_DESCRIPTOR == ReadRes->entry.AttrBlock.pAttr[i].attrTyp)
            {
                *SecurityDescriptor = MIDL_user_allocate(pAVal[0].valLen);
                if (NULL == *SecurityDescriptor)
                {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }
                else
                {
                    *SecurityDescriptorLength = pAVal[0].valLen;
                    RtlZeroMemory(*SecurityDescriptor,pAVal[0].valLen);
                    RtlCopyMemory(*SecurityDescriptor,
                                  pAVal[0].pVal,
                                  pAVal[0].valLen
                                  );
                }
            }
            else if (ATT_OBJECT_CLASS == ReadRes->entry.AttrBlock.pAttr[i].attrTyp)
            {
                *ObjectClass = *((UNALIGNED ULONG *) pAVal[0].pVal);
            }
            else
            {
                NtStatus = STATUS_INTERNAL_ERROR;
                break;
            }
        }
    }


    return( NtStatus );
}


NTSTATUS
SampExtendedEnumerationAccessCheck(
    IN OUT BOOLEAN * pCanEnumEntireDomain
    )
/*++

Routine Description:

    This routine tries to determine whether the caller can enumerate the
    entire domain or not. It is a hotfix for Windows 2000 SP2. 
    
    Enumerate entire domain can be costly, especially for a large domain, 
    like Redmond - ITG. 
    
    To put a stop of this enumerate everybody behaviour and do not break
    any down level applications, we introduce an extended access control 
    right, SAM-Enumerate-Entire-Domain, which applies on Server Object ONLY. 
    By using this new access control right, administrators can shut down 
    those downlevel enumeration API's (SamEnum*, SampQueryDisplayInformation) 
    alone to everyone except a subset of people. 

    If a downlevel enumerate call is made, in addition to DS object 
    permissions, the permissions on SAM server object is checked. If the 
    security descriptor on server object does not allow access to execute
    Enumeration API, the client is limited to ONLY one ds paged search.
    For the small subset of people who have been granted this permission, 
    they can enumerate the entire domain in the old fashion.
  

Parameters:

    pCanEnumEntireDomain - pointer to boolean, used to return the result of
                           access check


Return Value:

    STATUS_SUCCESS
        pCanEnumEntireDomain - TRUE    caller has the permission
                             - FALSE   caller doesn't have the permission

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG       SecurityDescriptorLength;
    ULONG       ObjectClass;

    GUID                ClassGuid; 
    ULONG               ClassGuidLength = sizeof(GUID);
    OBJECT_TYPE_LIST    ObjList[2];
    DWORD               Results[2];
    DWORD               GrantedAccess[2];
    GENERIC_MAPPING     GenericMapping = DS_GENERIC_MAPPING;
    ACCESS_MASK         DesiredAccess;
    BOOLEAN             bTemp = FALSE;
    BOOLEAN             ImpersonatingNullSession = FALSE;  
    
    // 
    // init return value
    // 

    *pCanEnumEntireDomain = TRUE;

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }

    // 
    // retrieve the special security descriptor and DS class ID 
    // 

    NtStatus = SampDsGetObjectSDAndClassId(
                            SampServerObjectDsName,
                            &SecurityDescriptor,
                            &SecurityDescriptorLength,
                            &ObjectClass
                            );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Get the Class GUID
    // 
    
    NtStatus = SampGetClassAttribute(
                                ObjectClass, 
                                ATT_SCHEMA_ID_GUID,
                                &ClassGuidLength, 
                                &ClassGuid
                                );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }
    
    ASSERT(ClassGuidLength == sizeof(GUID));


    // 
    // Setup Object List
    // 
    
    ObjList[0].Level = ACCESS_OBJECT_GUID;
    ObjList[0].Sbz = 0;
    ObjList[0].ObjectType = &ClassGuid;    
    //
    // Every control access guid is considered to be in it's own property
    // set. To achieve this, we treat control access guids as property set
    // guids. 
    //
    ObjList[1].Level = ACCESS_PROPERTY_SET_GUID;
    ObjList[1].Sbz = 0;
    ObjList[1].ObjectType = (GUID *)&GUID_CONTROL_DsSamEnumEntireDomain;

    //
    // Assume full access
    //

    Results[0] = 0;
    Results[0] = 0;

    //
    // Impersonate the client
    // 
    NtStatus = SampImpersonateClient(&ImpersonatingNullSession);

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Set the desired access;
    // 

    DesiredAccess = RIGHT_DS_CONTROL_ACCESS;

    //
    // Map the desired access to contain no generic access
    // 
    MapGenericMask(&DesiredAccess, &GenericMapping);

    NtStatus = NtAccessCheckByTypeResultListAndAuditAlarm(
                                &SampSamSubsystem,          // SubSystemName
                                (PVOID) NULL,               // HandleId or NULL
                                &SampObjectInformation[ SampServerObjectType ].ObjectTypeName, // ObjectTypeName
                                &SampServerObjectName,      // ObjectName
                                SecurityDescriptor,         // SD
                                NULL,                       // This machine account's SID
                                DesiredAccess,              // Desired Access 
                                AuditEventDirectoryServiceAccess,   // Audit Type
                                0,                          // Flags
                                ObjList,                    // Object Type List
                                2,                          // Object Typy List Length
                                &GenericMapping,            // Generic Mapping
                                FALSE,                      // Object Creation 
                                GrantedAccess,              // Granted Status
                                Results,                    // Access Status
                                &bTemp);                    // Generate On Close
    
    // 
    // Stop impersonating the client
    // 
    
    SampRevertToSelf(ImpersonatingNullSession);
    
    if (NT_SUCCESS(NtStatus))
    {
        // 
        // Ok, we checked access, Now, access is granted if either 
        // we were granted access on the entire object (i.e. Results[0] 
        // is NULL ) or we were granted explicit rights on the access
        // guid (i.e. Results[1] is NULL). 
        // 
        
        if ( Results[0]  && Results[1] )
        {
            *pCanEnumEntireDomain = FALSE;
        }
    }

Error:

    IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);

    if (SecurityDescriptor)
    {
        MIDL_user_free(SecurityDescriptor);
    }

    return( NtStatus );
}




VOID
SampRevertToSelf(
    BOOLEAN fImpersonatingAnonymous
    )
/*++

  This function reverts to Self using the correct function based on
  DS mode / registry mode


--*/
{
    if (SampUseDsData)
    {
        UnImpersonateAnyClient();
    }
    else
    {
        if (fImpersonatingAnonymous)
        {
            SamIRevertNullSession();
        }
        else
        {
            RpcRevertToSelf();
        }
    }
}


NTSTATUS
SampImpersonateClient(
    BOOLEAN * fImpersonatingAnonymous
    )
/*++

    This function impersonates a client by calling the appropriate
    routines depending upon DS mode / Registry Mode

--*/
{
    *fImpersonatingAnonymous = FALSE;

    if (SampUseDsData) {

        return (I_RpcMapWin32Status(ImpersonateAnyClient()));
    } else {

        NTSTATUS NtStatus;

        NtStatus = I_RpcMapWin32Status(RpcImpersonateClient( NULL));

        if (NtStatus == RPC_NT_CANNOT_SUPPORT) {
            
            NtStatus = SamIImpersonateNullSession();

            *fImpersonatingAnonymous = TRUE;
        }

        return (NtStatus);
    }
}

BOOLEAN
SampIsForceGuestEnabled()
/*++

    Routine Description

    Checks to see if the force guest setting is enabled.
    Force guest is enabled if the reg key is set or if this
    is the personal edition. Force guest is never enabled
    on DC's

    1. On joined machines (includes DC's), the forceguest regkey is ignored and 
       assumed to be 0 (no dumb down).

    2. On unjoined machines (including servers),  NTLM follows the reg key 
       setting HKLM\System\CurrentControlSet\Control\Lsa\ForceGuest
	   - Exception to #2: On PERsonal, which is always unjoined, the reg key is 
         ignored and assumed to be 1 (dumb down).

    

  --*/
{
     OSVERSIONINFOEXW osvi;

    //
    // Force guest is never enabled for DC's ie DS mode
    //

    if (SampUseDsData)
    {
        return(FALSE);
    }
    else
    {
        //
        // Determine if we are running Personal SKU
        // Force Guest is always enabled in personal SKU
        //

        if (SampPersonalSKU)
        {
            return TRUE;
        } 
        else if (SampIsMachineJoinedToDomain)
        {
            //
            // ForceGuest is always disabled if machine is joined to a Domain
            // 
            return( FALSE );
        }
    }

    //
    // if the force guest key is turned on then return the value.
    //

    return(SampForceGuest);
    
}

BOOLEAN
SampIsClientLocal()
/*++

  This routine tests if the client is a local named pipe based caller.

  TRUE is returned if the client is a local named pipe  based caller
  FALSE is returned otherwise.

--*/
{
    NTSTATUS NtStatus;
    ULONG    ClientLocalFlag = FALSE;

    NtStatus = I_RpcMapWin32Status(I_RpcBindingIsClientLocal( NULL, &ClientLocalFlag));
    if ((NT_SUCCESS(NtStatus)) && ( ClientLocalFlag))
    {
        return(TRUE);
    }

    return(FALSE);
}


NTSTATUS
SampGetCurrentClientSid(
    IN  HANDLE   ClientToken OPTIONAL,
    OUT PSID    *ppSid,
    OUT BOOL     *Administrator
    )
/*++
Routine Description:

    This routine gets the current client SID, 

Parameter:

    ppSid - used to return the client SID
    
Return Value:

    NtStatus

    ppSid - caller is responsible to free it

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PTOKEN_USER User = NULL;


    //
    // Initialize return value
    // 

    *ppSid = NULL;

    // 
    // Get Sid
    // 
    NtStatus = SampGetCurrentUser( ClientToken, &User, Administrator );

    if (NT_SUCCESS(NtStatus))
    {
        ULONG   SidLength = RtlLengthSid(User->User.Sid);

        //
        // allocate memory
        // 
        *ppSid = MIDL_user_allocate(SidLength);

        if (NULL == (*ppSid))
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            //
            // copy over
            // 
            RtlZeroMemory(*ppSid, SidLength);
            RtlCopyMemory(*ppSid, User->User.Sid, SidLength);
        }
    }


    if (User)
        MIDL_user_free(User);

    return(NtStatus);
}

NTSTATUS
SampGetCurrentOwnerAndPrimaryGroup(
    OUT PTOKEN_OWNER * Owner,
    OUT PTOKEN_PRIMARY_GROUP * PrimaryGroup
    )
/*++

    Routine Description

        This routine Impersonates the Client and obtains the owner and
        its primary group from the Token

    Parameters:

        Owner -- The Owner sid is returned in here
        PrimaryGroup The User's Primary Group is returned in here

    Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{

    HANDLE      ClientToken = INVALID_HANDLE_VALUE;
    BOOLEAN     fImpersonating = FALSE;
    ULONG       RequiredLength=0;
    NTSTATUS    NtStatus  = STATUS_SUCCESS;
    BOOLEAN     ImpersonatingNullSession = FALSE;


    //
    // Initialize Return Values
    //

    *Owner = NULL;
    *PrimaryGroup = NULL;

    //
    // Impersonate the Client
    //

    NtStatus = SampImpersonateClient(&ImpersonatingNullSession);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    fImpersonating = TRUE;

    //
    // Grab the User's Sid
    //

    NtStatus = NtOpenThreadToken(
                   NtCurrentThread(),
                   TOKEN_QUERY,
                   TRUE,            //OpenAsSelf
                   &ClientToken
                   );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Query the Client Token For User's SID
    //

    NtStatus = NtQueryInformationToken(
                    ClientToken,
                    TokenOwner,
                    NULL,
                    0,
                    &RequiredLength
                    );

    if ((STATUS_BUFFER_TOO_SMALL == NtStatus) && ( RequiredLength > 0))
    {
        //
        // Alloc Memory
        //

        *Owner = MIDL_user_allocate(RequiredLength);
        if (NULL==*Owner)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token
        //

        NtStatus = NtQueryInformationToken(
                        ClientToken,
                        TokenOwner,
                        *Owner,
                        RequiredLength,
                        &RequiredLength
                        );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

    }

    //
    // Query the Client Token For User's PrimaryGroup
    //

    RequiredLength = 0;

    NtStatus = NtQueryInformationToken(
                    ClientToken,
                    TokenPrimaryGroup,
                    NULL,
                    0,
                    &RequiredLength
                    );

    if ((STATUS_BUFFER_TOO_SMALL == NtStatus) && ( RequiredLength > 0))
    {
        //
        // Alloc Memory
        //

        *PrimaryGroup = MIDL_user_allocate(RequiredLength);
        if (NULL==*PrimaryGroup)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token
        //

        NtStatus = NtQueryInformationToken(
                        ClientToken,
                        TokenPrimaryGroup,
                        *PrimaryGroup,
                        RequiredLength,
                        &RequiredLength
                        );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

    }


Error:

    //
    // Clean up on Error
    //

    if (!NT_SUCCESS(NtStatus))
    {
        if (*Owner)
        {
            MIDL_user_free(*Owner);
            *Owner = NULL;
        }

        if (*PrimaryGroup)
        {
            MIDL_user_free(*PrimaryGroup);
            *PrimaryGroup = NULL;
        }
    }

    if (fImpersonating)
        SampRevertToSelf(ImpersonatingNullSession);

    if (INVALID_HANDLE_VALUE!=ClientToken)
        NtClose(ClientToken);

    return NtStatus;

}




NTSTATUS
SampGetCurrentUser(
    IN  HANDLE        UserToken OPTIONAL,
    OUT PTOKEN_USER * User,
    OUT BOOL        * Administrator
    )
/*++

    Routine Description

        This routine Impersonates the Client and obtains the user
        field from the Token. If a user token is passed in then
        the user token is used instead of impersonation

    Parameters:

        UserToken -- The user's token can be optionally passed in here
        User -- The user's SID and attribute are returned in here

    Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{

    HANDLE      ClientToken = INVALID_HANDLE_VALUE;
    HANDLE      TokenToQuery;
    BOOLEAN     fImpersonating = FALSE;
    ULONG       RequiredLength=0;
    NTSTATUS    NtStatus  = STATUS_SUCCESS;
    BOOLEAN     ImpersonatingNullSession = FALSE;


    //
    // Initialize Return Values
    //

    *User = NULL;

    if (ARGUMENT_PRESENT(UserToken))
    {
        TokenToQuery = UserToken;
    }
    else
    {
        //
        // Impersonate the Client
        //

        NtStatus = SampImpersonateClient(&ImpersonatingNullSession);
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        fImpersonating = TRUE;

        //
        // Grab the Client Token
        //

        NtStatus = NtOpenThreadToken(
                       NtCurrentThread(),
                       TOKEN_QUERY,
                       TRUE,            //OpenAsSelf
                       &ClientToken
                       );

        if (!NT_SUCCESS(NtStatus))
            goto Error;

        TokenToQuery = ClientToken;
    }

    //
    // Query the Client Token For User's SID
    //

    NtStatus = NtQueryInformationToken(
                    TokenToQuery,
                    TokenUser,
                    NULL,
                    0,
                    &RequiredLength
                    );

    if ((STATUS_BUFFER_TOO_SMALL == NtStatus) && ( RequiredLength > 0))
    {
        //
        // Alloc Memory
        //

        *User = MIDL_user_allocate(RequiredLength);
        if (NULL==*User)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Query the Token
        //

        NtStatus = NtQueryInformationToken(
                        TokenToQuery,
                        TokenUser,
                        *User,
                        RequiredLength,
                        &RequiredLength
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

    }

    if (!CheckTokenMembership(
            TokenToQuery,SampAdministratorsAliasSid,Administrator))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }


Error:

    //
    // Clean up on Error
    //


    if (!NT_SUCCESS(NtStatus))
    {
        if (*User)
        {
            MIDL_user_free(*User);
            *User = NULL;
        }
    }

    if (fImpersonating)
        SampRevertToSelf(ImpersonatingNullSession);

    if (INVALID_HANDLE_VALUE!=ClientToken)
        NtClose(ClientToken);

    return NtStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\ridmgr.c ===
/*++

Copyright (c) 1990 - 1997  Microsoft Corporation

Module Name:

    ridmgr.c

Abstract:

    This file contains services for the multi-master Relative Identifier (RID)
    allocator, a.k.a. the distributed RID Manager in NT5.

    The RID Manager allows accounts to be created on any domain controller
    (DC) in the domain, rather than just at the PDC as in previous versions
    of NT. After an account has been successfully created, its data is rep-
    licated to other DC's in the domain.

    The distributed RID Manager model is as follows. When a DC is joined to
    a domain, it updates several objects in the DS for RID management. An
    initial pool of RID's is requested from the RID Manager. This request
    is made via the Floating Single Master Operation (FSMO), which allows
    one and only one DC at a time to change the size of the available RID
    pool. The FSMO operation is assumed to be asynchronous, so will return
    before the RID pool has actually been allocated in most cases.

    Subsequently, the requesting DC reads its allocated-RID attribute, from
    which it can determine that it has a valid RID pool. Once the RID pool
    has been allocated, the DC can begin assigning RID's to new accounts.

    When a pool is nearing exhaustion, i.e. a threshold is reached, the DC
    makes a request for another RID pool.

    The FSMO is set up to handle both inter- and intra-site requests for
    new RID pools, provided that the sites are RPC'able from one another.

    The DC/DSA that is the current FSMO owner is named by a distinguished
    name (DN), which is stored in the RoleOwner property of the RID Manager
    object itself. On exactly one DC, the RoleOwner will be the same name
    as that DC's (DSA) DN. Other replicas of the RoleOwner attribute will
    also contain this information via replicated data.

    It is possible that the name will differ on other DCs in the event that
    some other DC has requested ownership. That is, suppose that there are 3
    DC's in a domain and DC1 is the current RoleOwner, and hence, is the RID
    Manager.

    Next, DC2 requests ownership from DC1. Simultaneously, DC3 requests a
    new RID pool from the RID Manager (named in the RoleOwner). Because of
    replication latency, DC3 is unaware that DC2 is now the RoleOwner, and
    not DC1. Upon reaching DC1, inspecting the RoleOwner attribute, DC3's
    FSMO operation will discover that DC2 is the current RID Manager, and
    hence will return this information to DC3 so that it can retry the op-
    eration.

    =======================================================================

    RID management is defined by three objects and their attributes:

    (1) Sam-Domain Object (an auxillary class of the domain class)

        RID Manager Reference DN attribute

    (2) RID-Manager Object (lives in the System container)

        Role Owner attribute (the DN of the DC/DSA machine)
        RID Pool Available attribute

    (3) RID-Set Object (lives under the Computer object)

        RID Pool Allocated attribute
        RID Pool Previously Allocated attribute
        RID Pool Used attribute
        RID Next Rid attribute

    The DN of the RID Manager is stored in an attribute on the domain object
    for easy access. From this information, the location of the RID Manager
    object is known via a single read operation.

    The FSMO Role Owner is an attribute stored on the RID Manager object. So,
    reading the domain object to get the RID Manager DN, allows a second read
    to access the FSMO DN.

    The total pool of available RIDs, at any time, is stored in the RID
    Pool Availalble attribute of the RID Manager.

    The RID-Set object, one per DC/DSA machine in the domain, contains
    the RID data specific to that DC/DSA, such as the next RID.


    Locking Model - Theory of Operation
    -----------------------------------

    There are three mechanisms used for achieving serialization:

    1) The SAM Lock:  (an nt resource) used to serialize access to global data
                      for all SAM calls

    Specifically for the rid manager, the SAM lock is used to serialize writes
    to the rid set object to avoid jet write conflicts (since a regular SAM
    CreateUser could cause a write [using a rid] and the rid request
    thread could try to be updating the rid set with more rids)

    The SAM lock is acquired in two places:

        i) when the local DC is the rid manager, the lock is acquired before
           starting the transaction that will eventually write to the rid
           set object.  See ridmgr.c::SamIFloatingSingleMasterOpEx().
       ii) when local DC is NOT the rid manager, the lock is acquired just
           after the RPC call to acquire the rids has returned but just before
           the transaction is started to apply the results of the RPC call (ie
           write to the rid set object). See dsamain\dra\drancrep.c::ReqFsmoOpAux()

    N.B.  The SAM lock must be grabbed before starting a DS transaction.

    2) RidMgrCriticalSection: (critical section) used to serialize rid requests
       (used only in the server portion of rid management).

       Specifically, it guards writes to the domain-wide rid manager object that
       keeps the global rid pool.  Hence it is only used in one place:
       ridmgr.c::SamIFloatingSingleMasterOpEx().

    N.B.  The RidMgrCriticalSection must be grabbed before starting a DS transaction.

    3) SampDcRidRequestPending: (boolean) used to prevent multiple requests for
       rids  (used only in the client portion of rid management)

       SampDcRidRequestPending is typically set to TRUE in
       SampRequestRidPoolAsynchronously, which then creates a thread that executes
       SampRequestRidPool.

       SampRequestRidPool sets SampDcRidRequestPending to FALSE when it is
       finished, whether in success or failure.

       As a special case, SampDomainRidInitialization sets SampDcRidRequestPending
       to TRUE as it directly calls SampRequestRidPool.

    N.B.  To prevent race conditions, SampDcRidRequestPending must be set to TRUE
    only when the SAM lock is held, which it is when SampGetNextRid (which
    calls SampRequestRidPoolAsynchronously) is called.

Author:

    Chris Mayhall (ChrisMay) 11-Jul-1996

Environment:

    User Mode - Win32

Revision History:

    11-Jul-1996 ChrisMay
        Created initial file.
    25-Jul-1996 ChrisMay
        Added domain initialization and corresponding changes in ntds.exe.
    23-Aug-1996 ChrisMay
        Made domain initialization work for multiple hosted domains and for
        domain information stored in the DS.
    08-Oct-1996 ChrisMay
        Miscellaneous cleanup.
    09-Dec-1996 ChrisMay
        Remove dead/obsolete code, further clean up needed to support mult-
        iple hosted domains.
    31-Jan-1997 ChrisMay
        Miscellaneous bug fixes and more scaffold routines.
    18-Feb-1997 ChrisMay
        Added code to resume with the NextRid of the NT4 Account domain after
        upgrading the NT4 DC to an NT5 DC.
    05-Mar-1997 ChrisMay
        Updated the RID Manager to use the new schema, maintaining routines
        that use the old schema for DC upgrades.
    14-Mar-1997 ChrisMay
        Change RID Manager creation so that it does not specify a temporary
        RoleOwner name, but instead, creates the object with the RoleOwner
        name.
    21-Apr-1997 ChrisMay
        Create the RID Manager object with the SD specified in the schema.
    09-May-1997 ChrisMay
        If-def'd away references to old RID schema--remove the code altogether
        after a successful testing for a few days.
    02-Jun-1997 ChrisMay
        Added an in-memory RID cache to reduce the number of RID updates to
        the NTDS-DSA object. Converted remaining SamKdPrint's to SampDiagPrint
        to reduce debug output. Added a check to SampAllowAccountCreation
        that verifies the DC is not being restored from backup and that it
        has an initial RID pool (before attempting to assign a RID). Added
        routines to read/write the RID cache HWM to the registry for crash
        recovery. Re-enabled dynamic RID pool requests based on a RID thresh-
        old. Added registry keys for testing hooks (so that testers can set
        RID ranges appropriately).
    15-Oct-1997 ChrisMay
        Added routine to read the RID Manager during startup, then create the
        object only if it does not exist, rather then attempt creation each
        boot.
    22-Oct-1997 ChrisMay
        Added code to convert from old schema to new schema, such that the
        RID Manager object now lives in the System container, while the RID
        attributes now live on the RID-Set object, in under a give Computer
        object. New schema.
    28-Oct-1997 ChrisMay
        Replaced calls to GetConfigParam with GetConfigurationName, replaced
        SampInitializeDsName with AppendRDN for better consistency. Cleaned
        up name-buffer allocation.

--*/


// Manifest Constants (used in this file)

#define MAX_RID_OBJ_UPDATE  10
#define MAX_FSMO_RETRY      100000
#define MAX_EVENT_STRINGS   8

#define RID_SET             "RID Set"
#define RID_SET_W           L"RID Set"
#define RID_SET_W_CN        L"CN=RID Set"

#define RID_MGR             "RID Manager$"
#define RID_MGR_W           L"RID Manager$"
#define RID_MGR_W_CN        L"CN=RID Manager$"

#define SYSTEM_W            L"System"
#define SYSTEM_CN           "CN=System"
#define SYSTEM_W_CN         L"CN=System"

#define COMPUTERS_W         L"Computers"
#define COMPUTERS_CN        "CN=Computers"
#define COMPUTERS_W_CN      L"CN=Computers"

#define DOMAIN_RIDS_W       L"Domain RIDs"
#define DOMAIN_RIDS_CN      "CN=Domain RIDs"

#define SAMP_RID_FAILURE_NOTIFY_FREQ 100
#define SAMP_TIME_TO_LOG_RID_FAILURE(x)  \
                                 ( ((x) % SAMP_RID_FAILURE_NOTIFY_FREQ) == 0 )


// Includes

#include <samsrvp.h>
#include "ntlsa.h"
#include "lmcons.h"         // LM20_PWLEN
#include "msaudite.h"
#include <ntlsa.h>
#include <nlrepl.h>         // I_NetNotifyMachineAccount prototype
#include <dslayer.h>
#include <dsutilp.h>
#include <dsdomain.h>
#include <objids.h>
#include <dsconfig.h>       // GetConfigurationName
#include <stdlib.h>
#include <ridmgr.h>
#include <sdconvrt.h>       // SampGetDefaultSecurityDescriptorForClass
#include <ntdsa.h>          // Floating Single Master Operations (FSMO)
#include <malloc.h>
#include <filtypes.h>


//============================================================================
//
//                           RID Manager Global Data
//
//============================================================================

// Global variables are maintained for certain RID values, such as the domain
// minimum and maximum RIDs, and not just manifest constants. This is done so
// that these values can be set from the debugger (or test application) in
// order to test boundary conditions without having to create 16 million ac-
// counts. Note that these variables should always be referenced in the code
// and not the constants explicitly.

ULONG SampMinimumDomainRid;
ULONG SampMaximumDomainRid;
ULONG SampRidThreshold;
ULONG SampRidBlockSize;
ULONG SampRidCacheSize;
ULONG CachedNextRid=0;
ULONG SampCachedRidsLeft = 0;

//
// This critical section guards writes to the rid manager object to avoid
// write conflicts.
//
CRITICAL_SECTION RidMgrCriticalSection;
PCRITICAL_SECTION RidMgrCritSect;

//
// This boolean guards against the local rid manager code making multiple
// rid requests at once.  There is exactly 1 or 0 rid requests at any time
//
BOOLEAN SampDcRidRequestPending = FALSE;

//
// The DS object representing the RID manager is cached in here
//

DSNAME CachedRidManagerObject;


//
// The DS object representing the RID set object is returned in here
//

DSNAME CachedRidSetObject;


//============================================================================
//
//                           RID Manager Forward Decls
//
//============================================================================

NTSTATUS
SampFindRidManager(
    OUT PDSNAME *RidManager
    );

NTSTATUS
SampRequestRidPool(
    IN PDSNAME RidManager,
    IN BOOLEAN VerboseLogging
    );

NTSTATUS
SampRequestRidPoolAsynchronously(
    IN DSNAME * RidManager
    );

DWORD
SampSetupRidRegistryKey(
    IN HKEY KeyHandle,
    IN PCHAR ValueName,
    IN OUT PULONG Rid
    );

NTSTATUS
SampFindComputerObject(
    IN  PDSNAME DsaObject,
    OUT PDSNAME *ComputerObject
    );

NTSTATUS
SampFindRidObjectEx(
    IN  PDSNAME ComputerObject,
    OUT PDSNAME *RidObject
    );

SampObtainRidInfo(
    IN  PDSNAME  DsaObject, OPTIONAL
    OUT PDSNAME  *RidObject,
    OUT PRIDINFO RidInfo
    );

NTSTATUS
SampInitNextRid(
    PDSNAME  RidObject,
    PRIDINFO RidInfo
    );

NTSTATUS
SampSetupRidPoolNotification(
    PDSNAME RidManagerObject
    );


//============================================================================
//
//                         RID Manager Helper Routines
//
//============================================================================

VOID
SampSetRidManagerReference(PRIDINFO RidInfo, PDSNAME RidObject)
{
    RidInfo->RidManagerReference = RidObject;
}

VOID
SampGetRidManagerReference(PRIDINFO RidInfo, PDSNAME *RidObject)
{
    *RidObject = RidInfo->RidManagerReference;
}

VOID
SampSetRoleOwner(PRIDINFO RidInfo, PDSNAME RidObject)
{
    RidInfo->RoleOwner = RidObject;
}

VOID
SampGetRoleOwner(PRIDINFO RidInfo, PDSNAME *RidObject)
{
    *RidObject = RidInfo->RoleOwner;
}

VOID
SampSetRidPoolAvailable(PRIDINFO RidInfo, ULONG high, ULONG low)
{
    RidInfo->RidPoolAvailable.HighPart = (high);
    RidInfo->RidPoolAvailable.LowPart = (low);
}

VOID
SampGetRidPoolAvailable(PRIDINFO RidInfo, PULONG high, PULONG low)
{
    *(high) = RidInfo->RidPoolAvailable.HighPart;
    *(low) = RidInfo->RidPoolAvailable.LowPart;
}

VOID
SampSetDcCount(PRIDINFO RidInfo, ULONG Count)
{
    RidInfo->RidDcCount = (Count);
}

VOID
SampGetDcCount(PRIDINFO RidInfo, PULONG Count)
{
    *(Count) = RidInfo->RidDcCount;
}

VOID
SampSetRidPoolAllocated(PRIDINFO RidInfo, ULONG high, ULONG low)
{
    RidInfo->RidPoolAllocated.HighPart = (high);
    RidInfo->RidPoolAllocated.LowPart = (low);
}

VOID
SampGetRidPoolAllocated(PRIDINFO RidInfo, PULONG high, PULONG low)
{
    *(high) = RidInfo->RidPoolAllocated.HighPart;
    *(low) = RidInfo->RidPoolAllocated.LowPart;
}

VOID
SampSetRidPoolPrevAlloc(PRIDINFO RidInfo, ULONG high, ULONG low)
{
    RidInfo->RidPoolPrevAlloc.HighPart = (high);
    RidInfo->RidPoolPrevAlloc.LowPart = (low);
}

VOID
SampGetRidPoolPrevAlloc(PRIDINFO RidInfo, PULONG high, PULONG low)
{
    *(high) = RidInfo->RidPoolPrevAlloc.HighPart;
    *(low) = RidInfo->RidPoolPrevAlloc.LowPart;
}

VOID
SampSetRidPoolUsed(PRIDINFO RidInfo, ULONG high, ULONG low)
{
    RidInfo->RidPoolUsed.HighPart = (high);
    RidInfo->RidPoolUsed.LowPart = (low);
}

VOID
SampGetRidPoolUsed(PRIDINFO RidInfo, PULONG high, PULONG low)
{
    *(high) = RidInfo->RidPoolUsed.HighPart;
    *(low) = RidInfo->RidPoolUsed.LowPart;
}

VOID
SampSetRid(PRIDINFO RidInfo, ULONG NextRid)
{
    RidInfo->NextRid = (NextRid);
}

VOID
SampGetRid(PRIDINFO RidInfo, PULONG NextRid)
{
    *(NextRid) = RidInfo->NextRid;
}

VOID
SampSetRidFlags(PRIDINFO RidInfo, RIDFLAG Flags)
{
    RidInfo->Flags = (Flags);
}

VOID
SampGetRidFlags(PRIDINFO RidInfo, PRIDFLAG Flags)
{
    *(Flags) = RidInfo->Flags;
}

BOOLEAN
CheckOpResult(OPRES *OpResult)
{
    if (NULL != OpResult)
    {
        // There is a valid operation-result structure, so check it for the
        // extended error.

        if (FSMO_ERR_SUCCESS == OpResult->ulExtendedRet)
        {
            return(TRUE);
        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: FSMO extended error code = %lu\n",
                           OpResult->ulExtendedRet));

            return(FALSE);
        }
    }
    else
    {
        // A NULL OpResult means that DirOperationControl was unable to
        // allocate memory for the operation-result structure. In this
        // case, it is unlikely that the rest of the operation could have
        // worked.

        return(FALSE);
    }
}

VOID
SampWriteEventLogWithError(
    IN USHORT EventType,
    IN ULONG MessageId,
    IN ULONG WinError
    )
{
   

    DWORD           WinError2 = ERROR_SUCCESS;
    UNICODE_STRING  Error = {0, 0, NULL};
    PUNICODE_STRING StringPointers = &Error;
    ULONG           Length;

    Length = FormatMessage( (FORMAT_MESSAGE_FROM_SYSTEM |
                             FORMAT_MESSAGE_ALLOCATE_BUFFER),
                             NULL, // no source
                             WinError,
                             0, // let the system decide the language
                             (LPWSTR)&Error.Buffer,
                             0, // buffer is to be allocated
                             NULL // no inserts
                             );
    if ( Length > 0 ) {
        Error.MaximumLength = (USHORT) Length * sizeof(WCHAR);
        Error.Length = (USHORT) Length * sizeof(WCHAR);
    } else {
        WinError2 = GetLastError();
    }

    if ( ERROR_SUCCESS == WinError2 )
    {
        SampWriteEventLog( EventType,
                           0,    // no category
                           MessageId,
                           NULL, // no sid
                           1, // number of strings
                           0, // size of data
                           &StringPointers,
                           NULL
                            );

    }

    if ( Error.Buffer )
    {
        LocalFree( Error.Buffer );
    }
}

NTSTATUS
SampFindComputerObject(
    IN  PDSNAME DsaObject,
    OUT PDSNAME *ComputerObject
    )
/*++

Routine Description:

    This routine returns the computer object for the specified dsa object.

Parameters:

    DsaObject - Pointer, the dsname of a dsa

    ComputerObject - Pointer, allocated from the thread heap

Return Values:

    STATUS_SUCCESS - The DSA's computer object was found and accessed.

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    DirError = 0;

    READARG   ReadArg;
    READRES  *ReadResult;
    ENTINFSEL EISelection; // Entry Information Selection
    ATTRBLOCK ReadAttrBlock;
    COMMARG  *CommArg;
    ATTR      Attr;
    PDSNAME   ServerDsName = NULL;
    PDSNAME   BaseDsName = DsaObject;

    //
    // Some initial assumptions
    //
    ASSERT( SampExistsDsTransaction() );
    ASSERT( ComputerObject );

    // Initialize the outbound parameters.
    *ComputerObject = NULL;

    if ( NULL == BaseDsName )
    {
        ULONG NameSize = 0;

        NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                        &NameSize,
                                        NULL );

        if ( STATUS_BUFFER_TOO_SMALL == NtStatus )
        {
            SAMP_ALLOCA(BaseDsName,NameSize );
            if (NULL!=BaseDsName)
            {

                NtStatus = GetConfigurationName( 
                                DSCONFIGNAME_DSA,
                                &NameSize,
                                BaseDsName 
                                );
            }
            else
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if ( !NT_SUCCESS(NtStatus) )
        {
            return NtStatus;
        }

    }

    //
    // Depending on the build installed, the server reference attribute
    // maybe on the server object, ntdsa object, or not exist.  Handle
    // all three cases, doing the common case, the server object, first.
    //

    SAMP_ALLOCA(ServerDsName,BaseDsName->structLen );
    if (NULL==ServerDsName)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TrimDSNameBy( BaseDsName, 1, ServerDsName );

    //
    // Read the rid set reference property
    //

    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_SERVER_REFERENCE;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EISelection.AttrTypBlock = ReadAttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EISelection;
    ReadArg.pObject = ServerDsName;

    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);

    DirError = DirRead(&ReadArg, &ReadResult);

    if (NULL==ReadResult)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadResult->CommRes);
    }

    SampClearErrors();

    if ( STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus )
    {
        //
        // Maybe the attribute is on the ntdsa  object
        //
        ReadArg.pObject = BaseDsName;
        THFree( ReadResult );
        ReadResult = 0;

        DirError = DirRead(&ReadArg, &ReadResult);

        if (NULL==ReadResult)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadResult->CommRes);
        }

        SampClearErrors();

    }

    if ( NT_SUCCESS(NtStatus) )
    {
        //
        // Extract the value
        //
        ATTRBLOCK AttrBlock;
        PDSNAME   pVal = NULL;
        ATTRVAL *AttrVal = NULL;
        ULONG ValCount = 0;
        ULONG ValLength = 0;
        ULONG Index = 0;

        ASSERT(NULL != ReadResult);

        AttrBlock = ReadResult->entry.AttrBlock;
        AttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
        ValCount = AttrBlock.pAttr[0].AttrVal.valCount;

        for (Index = 0; Index < ValCount; Index++)
        {
            pVal = (PDSNAME)(AttrVal[Index].pVal);
            ValLength = AttrVal[Index].valLen;
            ASSERT(1 == ValCount);
        }
        ASSERT(NULL != pVal);
        *ComputerObject = pVal;

    }
    else if ( (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
           && (NULL == DsaObject ) )
    {
        //
        // There is no server reference, do a full search if the
        // search is for the local computer
        //
        PDSNAME DomainDn = NULL;
        ULONG   Length = 0;
        WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH+2];


        ASSERT( FALSE && "Can't find computer object!" );

        // This code should eventually be removed

        //
        // Get the root domain
        //

        NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                        &Length,
                                        DomainDn);

        SAMP_ALLOCA(DomainDn ,Length );
        if (NULL==DomainDn)
        {
           return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                        &Length,
                                        DomainDn);

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = STATUS_NO_TRUST_SAM_ACCOUNT;

            Length = sizeof( ComputerName );
            RtlZeroMemory(ComputerName, Length);
            Length /= sizeof(WCHAR);

            if (GetComputerName(ComputerName, &Length))
            {
                ATTR ComputerNameAttr;
                ATTRVAL ComputerNameAttrVal;
                PDSNAME  Object = NULL;

                ComputerNameAttr.AttrVal.pAVal = &ComputerNameAttrVal;

                ComputerNameAttr.attrTyp = ATT_SAM_ACCOUNT_NAME;
                ComputerNameAttr.AttrVal.valCount = 1;

                wcscat(ComputerName, L"$");
                Length++;

                ComputerNameAttr.AttrVal.pAVal->valLen = Length * sizeof(WCHAR);
                ComputerNameAttr.AttrVal.pAVal->pVal = (PUCHAR)ComputerName;

                NtStatus = SampDsDoUniqueSearch(0, DomainDn, &ComputerNameAttr, &Object);

                if ( NT_SUCCESS( NtStatus ) )
                {
                    Length = Object->structLen;
                    (*ComputerObject) = (PDSNAME) THAlloc( Length );
                    if ( (*ComputerObject) )
                    {
                        RtlCopyMemory( (*ComputerObject), Object, Length );
                        MIDL_user_free( Object );
                    }
                    else
                    {
                        NtStatus = STATUS_NO_MEMORY;
                    }
                }
            }

            if ( STATUS_OBJECT_NAME_NOT_FOUND == NtStatus )
            {
                NtStatus = STATUS_NO_TRUST_SAM_ACCOUNT;
            }
        }
    }


    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return( NtStatus );

}


NTSTATUS
SampFindRidObjectEx(
    IN  PDSNAME ComputerObject,
    OUT PDSNAME *RidObject
    )
/*++

Routine Description:

    This routine returns the rid object for the specified computer object,
    if it exists.

Parameters:

    ComputerObject - Pointer, the dsname of a dsa

    RidObject      - Pointer, allocated from the thread heap

Return Values:

    STATUS_SUCCESS - The DSA's computer object was found and accessed.

    STATUS_DS_NO_ATTRIBUTE_OR_VALUE - the object does not exist

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    DirError = 0;

    READARG   ReadArg;
    READRES  *ReadResult;
    ENTINFSEL EISelection; // Entry Information Selection
    ATTRBLOCK ReadAttrBlock;
    COMMARG  *CommArg;
    ATTR      Attr;

    //
    // Some initial assumptions
    //
    ASSERT( SampExistsDsTransaction() );
    ASSERT( ComputerObject );
    ASSERT( RidObject );

    // Initialize the outbound parameters.
    *RidObject = NULL;

    //
    // Read the rid set reference property
    //
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_RID_SET_REFERENCES;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EISelection.AttrTypBlock = ReadAttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EISelection;
    ReadArg.pObject = ComputerObject;

    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);

    DirError = DirRead(&ReadArg, &ReadResult);

    if (NULL==ReadResult)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadResult->CommRes);
    }

    if ( NT_SUCCESS(NtStatus) )
    {
        // Once the RID Set Reference object has been found and read, extract
        // the RID Set DN of interest (currently only one domain is handled)
        // and return that DN for subsequent usage.

        ATTRBLOCK AttrBlock;
        PDSNAME   pVal = NULL;
        ATTRVAL *AttrVal = NULL;
        ULONG ValCount = 0;
        ULONG ValLength = 0;
        ULONG Index = 0;

        ASSERT(NULL != ReadResult);

        AttrBlock = ReadResult->entry.AttrBlock;
        AttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
        ValCount = AttrBlock.pAttr[0].AttrVal.valCount;

        for (Index = 0; Index < ValCount; Index++)
        {
            pVal = (PDSNAME)(AttrVal[Index].pVal);
            ValLength = AttrVal[Index].valLen;
            ASSERT(1 == ValCount);
        }
        ASSERT(NULL != pVal);
        *RidObject = pVal;

    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();


    return( NtStatus );
}



SampObtainRidInfo(
    IN  PDSNAME  DsaObject, OPTIONAL
    OUT PDSNAME  *RidObject, OPTIONAL
    OUT PRIDINFO RidInfo
    )
/*++

Routine Description:

    This function returns the rid information for a given dsa.

Parameters:

    DsaObject - the dsa object

    RidObject - pointer to the dn of the ridobject

    RidInfo - the structure to be filled in

Return Values:

    STATUS_SUCCESS - The rid information was retrieved

    STATUS_OBJECT_NOT_FOUND - the rid object was not found

    STATUS_NO_SAM_TRUST_ACCOUNT - the computer object could be found

    STATUS_DS_NO_ATTRIBUTE_OR_VALUE - the reference does not exist


    Resource errors from the ds

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDSNAME  ComputerObject = NULL;
    PDSNAME  LocalRidObject = NULL;

    ASSERT( SampExistsDsTransaction() );

    if ( RidObject )
    {
        *RidObject = NULL;
    }

    if ((fNullUuid(&CachedRidSetObject.Guid)) || (NULL!=DsaObject))
    {
        //
        // We have not yet visited the RID set object. Try to find it
        //

        NtStatus = SampFindComputerObject( DsaObject, &ComputerObject );
        if ( NT_SUCCESS( NtStatus ) )
        {
            //
            // Ok, now try and find the rid object
            //
            NtStatus = SampFindRidObjectEx( ComputerObject, &LocalRidObject);
            THFree( ComputerObject );
        }
    }
    else
    {
        LocalRidObject = &CachedRidSetObject;
    }


    if ( NT_SUCCESS( NtStatus ) )
    {

        //
        // Ok, now try to read it
        //
        NtStatus = SampReadRidObjectInfo( LocalRidObject, RidInfo );

        if ( NT_SUCCESS( NtStatus ) )
        {
            if ( RidObject )
            {
                *RidObject = LocalRidObject;
            }

        }
    }


    ASSERT( SampExistsDsTransaction() );

    return NtStatus;
}


NTSTATUS
SampGetMachineDnName(
    OUT PWCHAR *MachineDnName,
    OUT PULONG NameLength
    )

/*++

Routine Description:

    This routine queries the system registry for the DN (distinguished name)
    of this DSA and passes it back. If not found, the output buffer is left
    unaltered.

Parameters:

    MachineDnName - Pointer, return buffer containing the DN of this DSA.

    NameLength - Pointer, returned length of the Machine DN name.

Return Values:

    STATUS_SUCCESS - The DSA's DN was found and accessed.

    Other status codes as per the registry API.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE RegistryKey = 0;
    HANDLE Handle = 0;
    ACCESS_MASK DesiredAccess = KEY_READ;
    KEY_VALUE_INFORMATION_CLASS KeyInformationClass = KeyValueFullInformation;
    PBYTE Buffer = NULL;
    ULONG Length = 0;
    ULONG ResultLength = 0;
    PKEY_VALUE_FULL_INFORMATION KeyInformation = NULL;

    SAMTRACE("SampGetMachineDnName");

    RtlZeroMemory(&KeyName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&ValueName, sizeof(UNICODE_STRING));

    RtlInitUnicodeString(&KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NTDS\\Parameters");
    RtlInitUnicodeString(&ValueName, L"Machine DN Name");

    ASSERT((0 < KeyName.Length) && (0 < ValueName.Length));

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               RegistryKey,
                               NULL);

    NtStatus = NtOpenKey(&Handle, DesiredAccess, &ObjectAttributes);

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = NtQueryValueKey(Handle, 
                                   &ValueName, 
                                   KeyInformationClass,
                                   NULL,
                                   0,
                                   &ResultLength
                                   );

        if (STATUS_BUFFER_TOO_SMALL == NtStatus)
        {
            Length = ResultLength;

            SAMP_ALLOCA(Buffer,Length ); 
            if (NULL!=Buffer)
            {

                RtlZeroMemory(Buffer, sizeof(Buffer));

                NtStatus = NtQueryValueKey(Handle,
                                       &ValueName,
                                       KeyInformationClass,
                                       (PVOID)Buffer,
                                       Length,
                                       &ResultLength);
            }
            else
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS(NtStatus))
            {
                PBYTE KeyValue = NULL;
                ULONG KeyValueLength = 0;

                ASSERT(NULL != Buffer);

                KeyInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

                ASSERT(KeyValueFullInformation == KeyInformation->Type);
                ASSERT((0 < ResultLength) && (ResultLength <= Length));

                // The DSA's DN was found and read successfully from the registry
                // so copy it to the output buffer and return. Use byte offset,
                // not KeyInformation offset, to access the data.

                KeyValue = &(Buffer[KeyInformation->DataOffset]);
                KeyValueLength = KeyInformation->DataLength;

                // SampDiagPrint(RID_MANAGER,
                //               ("SAMSS: Key Value = %ws; Value Length = %lu\n",
                //                KeyValue,
                //                KeyValueLength));

                *MachineDnName = RtlAllocateHeap(RtlProcessHeap(), 0, KeyValueLength);

                if (NULL == *MachineDnName)
                {
                    *NameLength = 0;
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                else
                {
                    RtlZeroMemory(*MachineDnName, KeyValueLength);

                    RtlCopyMemory(*MachineDnName,
                                  KeyValue,
                                  KeyValueLength);

                    *NameLength = KeyValueLength;


                    // SampDiagPrint(RID_MANAGER,
                    //               ("SAMSS: MachineDnName = %ws; Name Length = %lu\n",
                    //                MachineDnName,
                    //                *NameLength));

                    NtStatus = STATUS_SUCCESS;
                }
            }
            else
            {
                SampDiagPrint(RID_MANAGER,
                              ("SAMSS: NtQueryValueKey status = 0x%lx\n",
                               NtStatus));
            }
        }

        CloseHandle(Handle);
    }
    else
    {
        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: NtOpenKey status = 0x%lx\n", NtStatus));
    }

    return(NtStatus);
}


NTSTATUS
SampExtractReadResults(
    IN RID_OBJECT_TYPE ObjectType,
    IN READRES *ReadResult,
    OUT PRIDINFO RidInfo
    )

/*++

Routine Description:

    This routine reads the data from a DS data structure and tansforms it into
    the RIDINFO stucture so that it can be manipulated by the RID management
    code with less runtime overhead.

Arguments:

    ObjectType - Enum, RidManagerReference, RidManager, or RidObject.

    ReadResult - Pointer, input DS data.

    RidInfo - Pointer, returned RID information.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ATTRBLOCK AttrBlock;
    ATTRTYP AttrType = 0;
    ATTRVAL *AttrVal = NULL;
    ULONG Index = 0;
    ULONG Length = 0;
    ULONG StringLength = 0;

    SAMTRACE("SampExtractReadResults");

    if ((NULL == ReadResult) || (NULL == RidInfo))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    ASSERT((ObjectType == RidManagerReferenceType) ||
           (ObjectType == RidManagerType) ||
           (ObjectType == RidObjectType));

    RtlZeroMemory(&AttrBlock, sizeof(ATTRBLOCK));

    AttrBlock = ReadResult->entry.AttrBlock;

    // Determine whether the object is the RID Manager Reference, the RID
    // Manager, or the RID Object. Once this is determined, check the flag
    // in the RIDINFO structure to determine which attributes are being
    // asked for and extract them accordingly from the DS attribute block.
    // This is done by iterating through the returned (from a DS read op-
    // eration) ATTRBLOCK, copying the data into the RIDINFO stucture. Note
    // that space is allocated by this routine for the variable-length data
    // so needs to be released by the calling routine.

    if (RidManagerReferenceType == ObjectType)
    {
        for (Index = 0; Index < AttrBlock.attrCount; Index++)
        {
            AttrType = AttrBlock.pAttr[Index].attrTyp;
            AttrVal = AttrBlock.pAttr[Index].AttrVal.pAVal;
            Length = AttrVal->valLen;

            switch (AttrType)
            {

            case ATT_RID_MANAGER_REFERENCE:
                RidInfo->RidManagerReference = (PDSNAME) AttrVal->pVal;

                break;

            default:
                NtStatus = STATUS_INTERNAL_ERROR;
                SampDiagPrint(RID_MANAGER,
                              ("SAMSS: ExtractReadResults, undefined attribute error\n"));
                break;

            }
        }
    }
    else if (RidManagerType == ObjectType)
    {
        for (Index = 0; Index < AttrBlock.attrCount; Index++)
        {
            AttrType = AttrBlock.pAttr[Index].attrTyp;
            AttrVal = AttrBlock.pAttr[Index].AttrVal.pAVal;
            Length = AttrVal->valLen;

            switch (AttrType)
            {

            case ATT_FSMO_ROLE_OWNER:
                RidInfo->RoleOwner = (PDSNAME) AttrVal->pVal;

                break;

            case ATT_RID_AVAILABLE_POOL:
                RidInfo->RidPoolAvailable = *(ULARGE_INTEGER *)(AttrVal->pVal);
                break;

            default:
                NtStatus = STATUS_INTERNAL_ERROR;
                SampDiagPrint(RID_MANAGER,
                              ("SAMSS: ExtractReadResults, undefined attribute error\n"));
                break;

            }
        }
    }
    else if (RidObjectType == ObjectType)
    {
        for (Index = 0; Index < AttrBlock.attrCount; Index++)
        {
            AttrType = AttrBlock.pAttr[Index].attrTyp;
            AttrVal = AttrBlock.pAttr[Index].AttrVal.pAVal;

            switch (AttrType)
            {

            case ATT_RID_ALLOCATION_POOL:
                RidInfo->RidPoolAllocated = *(ULARGE_INTEGER *)(AttrVal->pVal);
                break;

            case ATT_RID_PREVIOUS_ALLOCATION_POOL:
                RidInfo->RidPoolPrevAlloc = *(ULARGE_INTEGER *)(AttrVal->pVal);
                break;

            case ATT_RID_USED_POOL:
                RidInfo->RidPoolUsed = *(ULARGE_INTEGER *)(AttrVal->pVal);
                break;

            case ATT_RID_NEXT_RID:
                RidInfo->NextRid = *(ULONG *)(AttrVal->pVal);
                break;

            default:
                NtStatus = STATUS_INTERNAL_ERROR;
                SampDiagPrint(RID_MANAGER,
                              ("SAMSS: ExtractReadResults, undefined attribute error\n"));
                break;

            }
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}


//============================================================================
//
//                         Rid Manager Logging/Dumping Routines
//
//============================================================================

VOID
SampDumpRidInfo(
    PRIDINFO RidInfo
    )
{
    SAMTRACE("SampDumpRidInfo");

    if (NULL == RidInfo)
    {
        SampDiagPrint(RID_MANAGER, ("SAMSS: Dump RidInfo pointer = 0x%lx\n", RidInfo));
        return;
    }

    if (NULL != RidInfo->RidManagerReference)
    {
        SampDiagPrint(RID_MANAGER,
            ("SAMSS: Reference       = %ws\n",
             RidInfo->RidManagerReference->StringName));
    }

    if (NULL != RidInfo->RoleOwner)
    {
        SampDiagPrint(RID_MANAGER,
            ("SAMSS: Role Owner      = %ws\n",
             RidInfo->RoleOwner->StringName));
    }

    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Pool Available  = %lu - %lu\n",
         RidInfo->RidPoolAvailable.LowPart, RidInfo->RidPoolAvailable.HighPart));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: DC Count        = %lu\n",
         RidInfo->RidDcCount));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Pool Allocated  = %lu - %lu\n",
         RidInfo->RidPoolAllocated.LowPart, RidInfo->RidPoolAllocated.HighPart));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Prev Pool Alloc = %lu - %lu\n",
         RidInfo->RidPoolPrevAlloc.LowPart, RidInfo->RidPoolPrevAlloc.HighPart));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Used Pool       = %lu - %lu\n",
         RidInfo->RidPoolUsed.LowPart, RidInfo->RidPoolUsed.HighPart));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Next RID        = %lu\n",
         RidInfo->NextRid));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Flags           = 0x%lx\n",
         RidInfo->Flags));

    return;
}



VOID
SampLogRidValues(
    IN ULONG MinDomRid,
    IN ULONG MaxDomRid,
    IN ULONG BlockSize,
    IN ULONG MinAvailRid,
    IN ULONG MaxAvailRid,
    IN ULONG MinAllocRid,
    IN ULONG MaxAllocRid,
    IN ULONG NextRid,
    IN USHORT EventType,
    IN NTSTATUS NtStatus
    )
{
    ULONG i = 0;
    WCHAR String[MAX_EVENT_STRINGS][64];
    UNICODE_STRING UnicodeString[MAX_EVENT_STRINGS];
    PUNICODE_STRING EventString[MAX_EVENT_STRINGS];

    wsprintf(String[0], L"Minimum Domain RID = %lu", MinDomRid);
    RtlInitUnicodeString(&UnicodeString[0], String[0]);

    wsprintf(String[1], L"Maximum Domain RID = %lu", MaxDomRid);
    RtlInitUnicodeString(&UnicodeString[1], String[1]);

    wsprintf(String[2], L"RID Pool Size = %lu", BlockSize);
    RtlInitUnicodeString(&UnicodeString[2], String[2]);

    wsprintf(String[3], L"Minimum Available RID = %lu", MinAvailRid);
    RtlInitUnicodeString(&UnicodeString[3], String[3]);

    wsprintf(String[4], L"Maximum Available RID = %lu", MaxAvailRid);
    RtlInitUnicodeString(&UnicodeString[4], String[4]);

    wsprintf(String[5], L"Minimum Allocated RID = %lu", MinAllocRid);
    RtlInitUnicodeString(&UnicodeString[5], String[5]);

    wsprintf(String[6], L"Maximum Allocated RID = %lu", MaxAllocRid);
    RtlInitUnicodeString(&UnicodeString[6], String[6]);

    wsprintf(String[7], L"Current RID Value = %lu", NextRid);
    RtlInitUnicodeString(&UnicodeString[7], String[7]);

    for (i = 0; i < MAX_EVENT_STRINGS; i++)
    {
        EventString[i] = &UnicodeString[i];
    }

    // During system startup, record the RID values in the event log. The
    // NT status code of the RID-Manager initialization is also recorded.
    SampWriteEventLog(EventType,
                      0,
                      SAMMSG_RID_MANAGER_INITIALIZATION,
                      NULL,
                      MAX_EVENT_STRINGS,
                      sizeof(NTSTATUS),
                      EventString,
                      (PVOID)(&NtStatus));

    return;
}


//============================================================================
//
//                         Rid Manager Memory Routines
//
//============================================================================

VOID
SampFreeModArgAttrs(
    ATTRMODLIST *AttrMod
    )
{
    SAMTRACE("SampFreeModArgAttrs");

    if (NULL != AttrMod)
    {
        ATTRMODLIST *AttrModTmp = AttrMod;
        ATTR Attr;
        ATTRVAL *AttrVal;

        // Note that the "Attr" member is an embedded struct that was copied
        // into the AttrMod at creation time, so is not released here.

        while (NULL != AttrMod)
        {
            AttrModTmp = AttrMod->pNextMod;
            Attr = AttrMod->AttrInf;
            AttrVal = Attr.AttrVal.pAVal;
            THFree(AttrVal);
            THFree(AttrMod);
            AttrMod = AttrModTmp;
        }
    }

    return;
}


VOID
SampFreeReadResultAttrs(
    READRES *ReadResult
    )
{
    SAMTRACE("SampFreeReadResultAttrs");

    if (NULL != ReadResult)
    {
        ATTRBLOCK *AttrBlock = &(ReadResult->entry.AttrBlock);

        if (NULL != AttrBlock)
        {
            if (NULL != AttrBlock->pAttr)
            {
                ULONG i, j;

                for(i = 0; i < AttrBlock->attrCount; i++)
                {
                    if (NULL != AttrBlock->pAttr[i].AttrVal.pAVal)
                    {
                        for(j = 0; j < AttrBlock->pAttr[i].AttrVal.valCount; j++)
                        {
                            if (NULL != AttrBlock->pAttr[i].AttrVal.pAVal[j].pVal)
                            {
                                THFree(AttrBlock->pAttr[i].AttrVal.pAVal[j].pVal);
                            }
                        }

                        THFree(AttrBlock->pAttr[i].AttrVal.pAVal);
                    }
                }

                THFree(AttrBlock->pAttr);
            }

            // Don't THFree(AttrBlock) cause it was structure copied into the
            // ENTINF! Who knows if the source AttrBlock was ever released by
            // the originating routine!
        }

        THFree(ReadResult->entry.pName);
    }

    return;
}


//============================================================================
//
//                        Rid Manager Reference Routines
//
//============================================================================


NTSTATUS
SampUpdateRidManagerReference(
    IN PDSNAME RidMgrRef,
    IN PDSNAME RidMgr
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampUpdateRidManagerReference");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidMgrRef) && (NULL != RidMgr))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        MODIFYARG ModArg;
        MODIFYRES *pModRes;
        COMMARG *CommArg;
        ULONG RetCode;
        ATTR Attr;
        ATTRVALBLOCK AttrValBlock;
        ATTRVAL AttrVal;

        ASSERT((NULL != RidMgr) && (NULL != RidMgrRef->StringName));

        memset( &ModArg, 0, sizeof( ModArg ) );
        ModArg.pObject = RidMgrRef;

        ModArg.FirstMod.pNextMod = NULL;
        ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

        AttrVal.valLen = RidMgr->structLen;
        AttrVal.pVal = (PUCHAR)RidMgr;

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RID Manager = %ws\n",
                       RidMgr->StringName));

        AttrValBlock.valCount = 1;
        AttrValBlock.pAVal = &AttrVal;

        Attr.attrTyp = ATT_RID_MANAGER_REFERENCE;
        Attr.AttrVal = AttrValBlock;

        ModArg.FirstMod.AttrInf = Attr;
        ModArg.count = 1;

        CommArg = &(ModArg.CommArg);

        BuildStdCommArg(CommArg);

        RetCode = DirModifyEntry(&ModArg, &pModRes);

        if (NULL==pModRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
        }

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry status = %d\n",
                           RetCode));
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry NT status = %d\n",
                           NtStatus));
        }

    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


NTSTATUS
SampReadRidManagerReferenceInfo(
    IN PDSNAME RidMgrRef,
    OUT PRIDINFO RidInfo
    )

/*++

Routine Description:

    This routine reads the RID Manager Reference data from the DS backing
    store, returning it in the format of the RIDINFO structure. This routine
    obtains the the DN of the RID Manager.

Arguments:

    RidMgrRef - Pointer, RDN DS name of the RID Manager Reference object.

    RidInfo - Pointer, returned data containing the DN of the RID Manager.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    STATUS_NO_MEMORY if the returned buffers could not be allocated.

    Other DS error codes that have been mapped to an NTSTATUS can be returned
    from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampReadRidManagerReferenceInfo");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidMgrRef) && (NULL != RidInfo))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        READARG ReadArg;
        READRES *ReadResult = NULL;
        ENTINFSEL EISelection; // Entry Information Selection
        ATTRBLOCK ReadAttrBlock;
        COMMARG *CommArg;
        ULONG RetCode = 0;
        ULONG Index = 0;
        ATTR *Attr = NULL;

        ASSERT(NULL != RidMgrRef->StringName);

        RtlZeroMemory(&ReadArg, sizeof(READARG));
        RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
        RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

        Attr = (ATTR *)DSAlloc(sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (NULL == Attr)
        {
            return(STATUS_NO_MEMORY);
        }

        RtlZeroMemory(Attr, sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (RID_REFERENCE & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_MANAGER_REFERENCE;
            Index++;
        }

        ReadAttrBlock.attrCount = Index;
        ReadAttrBlock.pAttr = Attr;

        EISelection.AttrTypBlock = ReadAttrBlock;
        EISelection.attSel = EN_ATTSET_LIST;
        EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

        ReadArg.pSel = &EISelection;
        ReadArg.pObject = RidMgrRef;
        CommArg = &(ReadArg.CommArg);
        BuildStdCommArg(CommArg);

        RetCode = DirRead(&ReadArg, &ReadResult);

        if (NULL==ReadResult)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&ReadResult->CommRes);
        }

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampExtractReadResults(RidManagerReferenceType,
                                              ReadResult,
                                              RidInfo);

        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirRead (RidManagerRef) status = 0x%lx\n",
                           NtStatus));
        }

        THFree(Attr);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampExtractReadResults status = 0x%lx\n",
                           NtStatus));
        }

    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


//============================================================================
//
//                              Validation Routines
//
//============================================================================

NTSTATUS
SampVerifyStartupEnv(
    IN PDSNAME RidMgr
    )

/*++

Routine Description:

    The purpose of this routine is to determine whether or not the initial
    startup environment for the RID Manager is valid on a replica (B)DC.

    After replicating the domain information to the replica DC and for
    some reason the RID Manager object is NOT replicated (perhaps due to
    network problems), subsequent reboot of the replica DC could cause the
    RID Manager object to be re-created on that DC. This routine detects
    such a situation and returns an error code, as well as preventing the
    creation of the RID Manager object on the BDC (it is only created on
    the PDC).

    If the RID Manager object does not exist, on the replica DC, then the
    replica DC will not be able to allocate an initial RID pool and should
    prevent account creation until the object exists.

Arguments:

    RidMgr - Pointer, RDN DS name of the RID Manager object.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampVerifyStartupEnv");

    if (NULL != RidMgr)
    {
        NT_PRODUCT_TYPE NtProductType;
        DOMAIN_SERVER_ROLE ServerRole;

        // Get the server role from the SAM global domain information array,
        // using the DS Account domain, i.e. DOMAIN_START_DS + 1. Note that
        // the DS Builtin domain is at index DOMAIN_START_DS.

        RtlGetNtProductType(&NtProductType);
        ServerRole = SampDefinedDomains[DOMAIN_START_DS + 1].ServerRole;

        // SampDiagPrint(RID_MANAGER,
        //               ("SAMSS: NtProductType = %d ServerRole = %d\n",
        //                NtProductType,
        //                ServerRole));

        if ((NtProductLanManNt == NtProductType) &&
            (DomainServerRoleBackup == ServerRole))
        {
            // The server is a BDC, so make sure that the RID Manager object
            // already exists on this machine (via replication). If it does
            // not exist, this is an error, and no RID pool can be allocated
            // to this DSA at this time. Retry later. Attempt to read the RID
            // available pool as the basic existence test.

            RIDINFO RidInfo;
            RIDFLAG Flag = RID_AVAILABLE_POOL;

            RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
            SampSetRidFlags(&RidInfo, Flag);

            NtStatus = SampReadRidManagerInfo(RidMgr, &RidInfo);
        }
        else
        {
            // The server is a PDC, so continue on as usual, no further
            // checking necessary.

            NtStatus = STATUS_SUCCESS;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}


NTSTATUS
SampVerifyRidManagerExists(
    IN PDSNAME RidMgr
    )

/*++

Routine Description:

    The purpose of this routine is to find out whether the RID Manager$
    object exists on the given DSA.

Arguments:

    RidMgr - Pointer, RDN DS name of the RID Manager object.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampRidManagerExists");

    if (NULL != RidMgr)
    {
        RIDINFO RidInfo;
        RIDFLAG Flag = RID_AVAILABLE_POOL;

        RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
        SampSetRidFlags(&RidInfo, Flag);

        // Attempt to read a must-have attribute on the RID Manager to verify
        // that the object exists.

        NtStatus = SampReadRidManagerInfo(RidMgr, &RidInfo);
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}




//============================================================================
//
//                              Rid Manager Routines
//
//============================================================================


NTSTATUS
SampCreateRidManager(
    IN PDSNAME RidMgr
    )

/*++

Routine Description:

    This routine creates the RID Manager object in the DS tree, if it does
    not already exist. The RID Manager contains the Role Owner and domain-
    wide RID pool that is available.

    The Role Owner is the current DC (a.k.a. DSA) that has the rights to
    modify either the Role Owner value or the available RID pool. As each DC
    requests a RID allocation from the pool, the RID Manager subtracts this
    allocation from the bottom of the available pool.

Arguments:

    RidMgr - Pointer, RDN DS name of the RID Manager object.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    USHORT EventType = 0;

    SAMTRACE("SampCreateRidManager");

    ASSERT( SampExistsDsTransaction() );

    if (NULL != RidMgr)
    {
        PWCHAR MachineDnName = NULL;
        ULONG Length = 0;
        PDSNAME RoleOwnerDsName = NULL;
        ULONG RoleOwnerDsNameLength = 0;
        BOOLEAN TrustedClient = TRUE;
        PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
        ULONG SecurityDescriptorLength = 0;

        ASSERT((NULL != RidMgr) && (NULL != RidMgr->StringName));

        // The DS disallows setting the DN attribute to a temporary
        // object that does not yet exist in the DS so, determine the
        // RoleOwner's DN and set it during object creation.

        NtStatus = SampGetMachineDnName(&MachineDnName, &Length);

        if (NT_SUCCESS(NtStatus))
        {
            ASSERT(NULL != MachineDnName);
            ASSERT(0 < Length);
            SAMP_ALLOCA(RoleOwnerDsName,DSNameSizeFromLen(Length));
            if (NULL==RoleOwnerDsName)
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
            SampInitializeDsName(RoleOwnerDsName,
                                 NULL,
                                 0,
                                 MachineDnName,
                                 Length);

            RoleOwnerDsNameLength = RoleOwnerDsName->structLen;
            RtlFreeHeap(RtlProcessHeap(), 0, MachineDnName);
        }

        NtStatus = SampGetDefaultSecurityDescriptorForClass(
                                            CLASS_RID_MANAGER,
                                            &SecurityDescriptorLength,
                                            TrustedClient,
                                            &SecurityDescriptor);

        if (NT_SUCCESS(NtStatus))
        {
            NTSTATUS NtStatusTemp = STATUS_SUCCESS;
            ULONG ObjectClass = CLASS_RID_MANAGER;
            WCHAR RidMgrRDN[] = RID_MGR_W;
            ULONG RidMgrRDNLength = (sizeof(RidMgrRDN) - 2);
            LARGE_INTEGER RidPoolAvailable = {0, 0};
            ULONG RidPoolAvailableLength = sizeof(ULARGE_INTEGER);
            ULONG IsCritical = 1;
            ULONG SystemFlags = FLAG_DOMAIN_DISALLOW_RENAME |
                                FLAG_DOMAIN_DISALLOW_MOVE |
                                FLAG_DISALLOW_DELETE ;
            ADDARG AddArg;
            ADDRES *pAddRes;
            COMMARG *CommArg;
            ULONG RetCode;

            ATTRTYP Type[] =
            {
                ATT_NT_SECURITY_DESCRIPTOR,
                ATT_OBJECT_CLASS,
                ATT_COMMON_NAME,
                ATT_FSMO_ROLE_OWNER,
                ATT_RID_AVAILABLE_POOL,
                ATT_SYSTEM_FLAGS,
                ATT_IS_CRITICAL_SYSTEM_OBJECT
            };

            ATTRVAL Value[] =
            {
                {SecurityDescriptorLength,    (PUCHAR)SecurityDescriptor},
                {sizeof(ULONG),               (PUCHAR)&ObjectClass},
                {RidMgrRDNLength,             (PUCHAR)RidMgrRDN},
                {RoleOwnerDsNameLength,       (PUCHAR)RoleOwnerDsName},
                {RidPoolAvailableLength,      (PUCHAR)&RidPoolAvailable},
                {sizeof(ULONG),               (PUCHAR)&SystemFlags},
                {sizeof(ULONG),               (PUCHAR)&IsCritical}

            };

            DEFINE_ATTRBLOCK7(AttrBlock, Type, Value);

            ASSERT(NULL != SecurityDescriptor);
            ASSERT(0 < SecurityDescriptorLength);

            memset( &AddArg, 0, sizeof( AddArg ) );
            AddArg.pObject = RidMgr;
            AddArg.AttrBlock = AttrBlock;
            CommArg = &(AddArg.CommArg);

            BuildStdCommArg(CommArg);

            RetCode = DirAddEntry(&AddArg, &pAddRes);

            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirAddEntry status (RID Mgr) = %d\n", RetCode));

            if (NULL==pAddRes)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                NtStatus = SampMapDsErrorToNTStatus(RetCode,&pAddRes->CommRes);
            }

            // Must end the DS transaction regardless of error status,
            // otherwise a SAM write lock is held.

            if (!NT_SUCCESS(NtStatus))
            {
                // Catch any change to the error-mapping layer. The ex-
                // pected failure is that the RID Manager object already
                // exists, which is an update error (updError) and this
                // should map to SAMP_OBJ_EXISTS.

                ASSERT(updError == RetCode);
                #if (DBG == 1)
                if (updError == RetCode)
                {
                    ASSERT(SAMP_OBJ_EXISTS == NtStatus);
                }
                #endif
            }

            if (NULL != SecurityDescriptor)
            {
                MIDL_user_free(SecurityDescriptor);
            }
        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampGetDefaultSecurityDescriptorForClass status = 0x%lx\n",
                           NtStatus));
        }

    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    (NT_SUCCESS(NtStatus)) ?
        (EventType = EVENTLOG_INFORMATION_TYPE) :
        (EventType = EVENTLOG_ERROR_TYPE);


    //
    // This is only interesting if it fails
    //
    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampWriteEventLog(EventType,
                          0,
                          SAMMSG_RID_MANAGER_CREATION,
                          NULL,
                          0,
                          sizeof(NtStatus),
                          NULL,
                          &NtStatus);
    }


    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


NTSTATUS
SampUpdateRidManager(
    IN PDSNAME RidMgr,
    IN PRIDINFO RidInfo
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampUpdateRidManager");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidMgr) && (NULL != RidInfo))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        MODIFYARG ModArg;
        MODIFYRES *pModRes;
        COMMARG *CommArg;
        ATTRMODLIST *AttrMod;
        ATTRMODLIST *AttrModTmp = NULL; // Fix build w/ new x86 compiler
        ULONG RetCode = 0;
        ULONG Index = 0;
        ATTRVAL *AttrVal;
        ATTRVALBLOCK AttrValBlock;
        ATTR *Attr;

        ASSERT(NULL != RidMgr->StringName);

        //
        // One of the 2 flags must be passed in by the caller
        //

        ASSERT((RidInfo->Flags & RID_ROLE_OWNER) ||
                   (RidInfo->Flags & RID_AVAILABLE_POOL));

        if (RID_ROLE_OWNER & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = RidInfo->RoleOwner->structLen;
            AttrVal->pVal = (PUCHAR)RidInfo->RoleOwner;
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_FSMO_ROLE_OWNER;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: RoleOwner StringName = %ws\n",
                RidInfo->RoleOwner->StringName));
        }

        if (RID_AVAILABLE_POOL & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = sizeof(ULARGE_INTEGER);
            AttrVal->pVal = (PUCHAR)&(RidInfo->RidPoolAvailable);
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_RID_AVAILABLE_POOL;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: Rid Pool Available = %lu - %lu\n",
                RidInfo->RidPoolAvailable.LowPart,
                RidInfo->RidPoolAvailable.HighPart));
        }

        memset( &ModArg, 0, sizeof( ModArg ) );
        ModArg.FirstMod = *AttrModTmp;
        ModArg.count = (USHORT)Index;
        ModArg.pObject = RidMgr;

        ASSERT(0 < Index);

        CommArg = &(ModArg.CommArg);

        BuildStdCommArg(CommArg);


        //
        // Turn on Urgent Replication for Updates to the RID manager
        // object
        //

        CommArg->Svccntl.fUrgentReplication = TRUE;

        RetCode = DirModifyEntry(&ModArg, &pModRes);

        if (NULL==pModRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
        }

        SampFreeModArgAttrs(AttrModTmp);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry status = %d\n",
                           RetCode));
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry NT status = %d\n",
                           NtStatus));
        }

    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}




NTSTATUS
SampReadRidManagerInfoEx(
    IN PDSNAME RidMgr,
    OUT PRIDINFO RidInfo
    )

/*++

Routine Description:

    This routine reads the RID Manager data from the DS backing store, re-
    turning it in the format of the RIDINFO structure. This routine obtains
    the DN of the current Role Owner (a.k.a. the RID Manager) and the pool
    of RIDs available to any DC in the domain.

Arguments:

    RidMgrRef - Pointer, RDN DS name of the RID Manager Reference object.

    fCloseTransactions - Indicates that we should close the transaction ( ie
                         not running in caller's transaction )

    RidInfo - Pointer, returned data containing the DN of the RID Manager.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    STATUS_NO_MEMORY if the returned buffers could not be allocated.

    Other DS error codes that have been mapped to an NTSTATUS can be returned
    from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampReadRidManagerInfo");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidMgr) && (NULL != RidInfo))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        READARG ReadArg;
        READRES *ReadResult = NULL;
        ENTINFSEL EISelection; // Entry Information Selection
        ATTRBLOCK ReadAttrBlock;
        COMMARG *CommArg;
        ULONG RetCode = 0;
        ULONG Index = 0;
        ATTR *Attr = NULL;

        ASSERT(NULL != RidMgr->StringName);

        RtlZeroMemory(&ReadArg, sizeof(READARG));
        RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
        RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

        Attr = (ATTR *)DSAlloc(sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (NULL == Attr)
        {
            return(STATUS_NO_MEMORY);
        }

        RtlZeroMemory(Attr, sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (RID_ROLE_OWNER & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_FSMO_ROLE_OWNER;
            Index++;
        }

        if (RID_AVAILABLE_POOL & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_AVAILABLE_POOL;
            Index++;
        }

        ReadAttrBlock.attrCount = Index;
        ReadAttrBlock.pAttr = Attr;

        EISelection.AttrTypBlock = ReadAttrBlock;
        EISelection.attSel = EN_ATTSET_LIST;
        EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

        ReadArg.pSel = &EISelection;
        ReadArg.pObject = RidMgr;
        CommArg = &(ReadArg.CommArg);
        BuildStdCommArg(CommArg);

        RetCode = DirRead(&ReadArg, &ReadResult);

        if (NULL==ReadResult)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&ReadResult->CommRes);
        }

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampExtractReadResults(RidManagerType,
                                              ReadResult,
                                              RidInfo);

        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirRead (RidManager) status = 0x%lx\n",
                           NtStatus));
        }

        THFree(Attr);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampExtractReadResults status = 0x%lx\n",
                           NtStatus));
        }

    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


NTSTATUS
SampReadRidManagerInfo(
    IN PDSNAME RidMgr,
    OUT PRIDINFO RidInfo
    )
{
    return (SampReadRidManagerInfoEx(
                RidMgr,
                RidInfo
                ));
}

//============================================================================
//
//                              Rid Object Routines
//
//============================================================================


NTSTATUS
SampUpdateRidSetReferences(
    IN PDSNAME ComputerObject,
    IN PDSNAME RidObject
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    MODIFYARG ModArg;
    MODIFYRES *pModRes;
    COMMARG *CommArg;
    ULONG RetCode;
    ATTR Attr;
    ATTRVALBLOCK AttrValBlock;
    ATTRVAL AttrVal;

    RtlZeroMemory(&ModArg, sizeof(ModArg));
    ModArg.pObject = ComputerObject;

    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = RidObject->structLen;
    AttrVal.pVal = (PUCHAR)RidObject;

    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;

    Attr.attrTyp = ATT_RID_SET_REFERENCES;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    CommArg = &(ModArg.CommArg);

    BuildStdCommArg(CommArg);

    // Whenever a new RID Set object is created, its DN is stored as a RID
    // Set Reference on the Computer object (for this DSA).

    RetCode = DirModifyEntry(&ModArg, &pModRes);

    if (NULL==pModRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
    }

    return(NtStatus);
}


NTSTATUS
SampCreateRidObject(
    IN PDSNAME ComputerObject,
    IN PDSNAME RidObject
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG Length = 0;
    ULONG Status = 0;
    ADDARG AddArg;
    ADDRES *pAddRes;
    COMMARG *CommArg;

    BOOLEAN TrustedClient = TRUE;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG SecurityDescriptorLength = 0;

    ASSERT( SampExistsDsTransaction() );

    if ((NULL == ComputerObject) || (NULL == RidObject))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    // Allocate space for the RID Set object DN plus some padding overhead
    // for extra characters (e.g. "cn=") added by AppendRDN.

    // Create and set default attributes needed to create the RID
    // Set object. All RID ranges are initialized to zero for now
    // and are updated later.


    NtStatus = SampGetDefaultSecurityDescriptorForClass(
                                        CLASS_RID_SET,
                                        &SecurityDescriptorLength,
                                        TrustedClient,
                                        &SecurityDescriptor);

    if (NT_SUCCESS(NtStatus))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        ULONG ObjectClass = CLASS_RID_SET;
        WCHAR RidObjRDN[] = RID_SET_W;
        ULONG RidObjRDNLength = (sizeof(RidObjRDN) - 2);
        LARGE_INTEGER RidAllocPool = {0, 0};
        LARGE_INTEGER RidPrevPool = {0, 0};
        LARGE_INTEGER RidUsedPool = {0, 0};
        ULONG RidNextRid = 0;

        ATTRTYP Type[] =
        {
            ATT_NT_SECURITY_DESCRIPTOR,
            ATT_OBJECT_CLASS,
            ATT_COMMON_NAME,
            ATT_RID_ALLOCATION_POOL,
            ATT_RID_PREVIOUS_ALLOCATION_POOL,
            ATT_RID_NEXT_RID,
            ATT_RID_USED_POOL
        };

        ATTRVAL Value[] =
        {
            {SecurityDescriptorLength,    (PUCHAR)SecurityDescriptor},
            {sizeof(ULONG),               (PUCHAR)&ObjectClass},
            {RidObjRDNLength,             (PUCHAR)RidObjRDN},
            {sizeof(ULARGE_INTEGER),      (PUCHAR)&RidAllocPool},
            {sizeof(ULARGE_INTEGER),      (PUCHAR)&RidPrevPool},
            {sizeof(ULONG),               (PUCHAR)&RidNextRid},
            {sizeof(ULARGE_INTEGER),      (PUCHAR)&RidUsedPool}
        };

        DEFINE_ATTRBLOCK7(AttrBlock, Type, Value);

        ASSERT(NULL != SecurityDescriptor);
        ASSERT(0 < SecurityDescriptorLength);

        memset( &AddArg, 0, sizeof( AddArg ) );
        AddArg.pObject = RidObject;
        AddArg.AttrBlock = AttrBlock;
        CommArg = &(AddArg.CommArg);

        BuildStdCommArg(CommArg);

        // Add the RID Set Object to the DS, and if successful,
        // update the RID Set References DN on the Computer object
        // with the DN of this new object.

        Status = DirAddEntry(&AddArg, &pAddRes);

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: DirAddEntry status (RID Object) = %d\n", Status));

        if (NULL==pAddRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(Status,&pAddRes->CommRes);
        }

        if ( NT_SUCCESS(NtStatus)
          || NtStatus == STATUS_USER_EXISTS )
        {
            NtStatus = SampUpdateRidSetReferences(ComputerObject,
                                                  RidObject);

            if ( !NT_SUCCESS(NtStatus) )
            {
                SampDiagPrint(RID_MANAGER,
                              ("SAMSS: SampUpdateRidSetReferences status = 0x%lx\n",
                               NtStatus));
            }

        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirAddEntry for RidSetObject status = 0x%lx\n",
                           NtStatus));
        }

        if (NULL != SecurityDescriptor)
        {
            MIDL_user_free(SecurityDescriptor);
        }
    }
    else
    {
        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: SampGetDefaultSecurityDescriptorForClass status = 0x%lx\n",
                       NtStatus));
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


NTSTATUS
SampUpdateRidObject(
    IN PDSNAME RidObj,
    IN PRIDINFO RidInfo,
    IN BOOLEAN fLazyCommit,     // if set to TRUE, let JET commit lazily  
    IN BOOLEAN fAuthoritative   // If set to TRUE, force it to win against any existing
                                // version anywhere in the enterprise
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    NTSTATUS NtStatusTemp = STATUS_SUCCESS;
    MODIFYARG ModArg;
    MODIFYRES *pModRes;
    COMMARG *CommArg;
    ATTRMODLIST *AttrMod;
    ATTRMODLIST *AttrModTmp = NULL; // Fix build w/ new x86 compiler
    ULONG RetCode;
    ULONG Index = 0;
    ATTRVAL *AttrVal;
    ATTRVALBLOCK AttrValBlock;
    ATTR *Attr;

    SAMTRACE("SampUpdateRidObject");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidObj) && (NULL != RidInfo))
    {
        if (RID_ALLOCATED_POOL & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = sizeof(ULARGE_INTEGER);
            AttrVal->pVal = (PUCHAR)&(RidInfo->RidPoolAllocated);
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_RID_ALLOCATION_POOL;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: Rid Pool Allocated = %lu - %lu\n",
                RidInfo->RidPoolAllocated.LowPart,
                RidInfo->RidPoolAllocated.HighPart));
        }

        if (RID_PREV_ALLOC_POOL & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = sizeof(ULARGE_INTEGER);
            AttrVal->pVal = (PUCHAR)&(RidInfo->RidPoolPrevAlloc);
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_RID_PREVIOUS_ALLOCATION_POOL;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: Rid Pool Prev Alloc = %lu - %lu\n",
                RidInfo->RidPoolPrevAlloc.LowPart,
                RidInfo->RidPoolPrevAlloc.HighPart));
        }

        if (RID_USED_POOL & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = sizeof(ULARGE_INTEGER);
            AttrVal->pVal = (PUCHAR)&(RidInfo->RidPoolUsed);
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_RID_USED_POOL;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: Rid Pool Used = %lu - %lu\n",
                RidInfo->RidPoolUsed.LowPart,
                RidInfo->RidPoolUsed.HighPart));
        }

        if (RID_NEXT_RID & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = sizeof(ULONG);
            AttrVal->pVal = (PUCHAR)&(RidInfo->NextRid);
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_RID_NEXT_RID;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: Next Rid = %lu\n", RidInfo->NextRid));
        }

        memset( &ModArg, 0, sizeof( ModArg ) );
        ModArg.FirstMod = *AttrModTmp;
        ModArg.count = (USHORT)Index;
        ModArg.pObject = RidObj;

        ASSERT(0 < Index);

        CommArg = &(ModArg.CommArg);

        BuildStdCommArg(CommArg);

        if (fAuthoritative)
        {
            // We are asked to force this change to win everywhere
            // set the appropriate SVCCNTL bit to 1
            CommArg->Svccntl.fAuthoritativeModify = TRUE;
        }

        RetCode = DirModifyEntry(&ModArg, &pModRes);

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: DirModifyEntry (RidObject) RetCode = 0x%lx\n",
                       RetCode));

        if (NULL==pModRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
        }

        SampFreeModArgAttrs(AttrModTmp);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry status = %d\n",
                           RetCode));
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry NT status = %d\n",
                           NtStatus));
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


NTSTATUS
SampInitNextRid(
    PDSNAME  RidObject,
    PRIDINFO RidInfo
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;

    ASSERT( SampExistsDsTransaction() );

    if ( 0 == RidInfo->NextRid )
    {
        //
        // This function is only useful when an initial
        // rid pool has been allocated
        //

        ASSERT( RidInfo->NextRid == 0 );
        ASSERT( RidInfo->RidPoolPrevAlloc.LowPart == 0 );
        ASSERT( RidInfo->RidPoolPrevAlloc.HighPart == 0 );
        ASSERT( RidInfo->RidPoolAllocated.LowPart != 0 );
        ASSERT( RidInfo->RidPoolAllocated.HighPart != 0 );

        //
        // Move the allocated pool in to our local pool
        //
        RidInfo->RidPoolPrevAlloc = RidInfo->RidPoolAllocated;

        //
        // Start the first rid from the bottom
        //
        RidInfo->NextRid = RidInfo->RidPoolPrevAlloc.LowPart;

        SampSetRidFlags( RidInfo, RID_PREV_ALLOC_POOL | RID_NEXT_RID );

        NtStatus = SampUpdateRidObject(RidObject,
                                       RidInfo,
                                       FALSE,       // commit immediately
                                       FALSE );

        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampUpdateRidObject status 0x%x\n",
                           NtStatus) );
        }

    }

    ASSERT( SampExistsDsTransaction() );

    SampClearErrors();

    return  NtStatus;
}

NTSTATUS
SampReadRidObjectInfo(
    IN PDSNAME RidObj,
    OUT PRIDINFO RidInfo
    )

/*++

Routine Description:

    This routine reads the RID Object data from the DS backing store, re-
    turning it in the format of the RIDINFO structure. This routine obtains
    the allocated RID pool, the previously allocated RID pool, the used RID
    pool, and the next RID that can be assigned to an account. Each DC (DSA)
    has a distinct RID Object, which stores this information about the RIDs
    owned by the DC.

Arguments:

    RidMgrRef - Pointer, RDN DS name of the RID Manager Reference object.

    RidInfo - Pointer, returned data containing the DN of the RID Manager.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    STATUS_NO_MEMORY if the returned buffers could not be allocated.

    Other DS error codes that have been mapped to an NTSTATUS can be returned
    from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampReadRidObjectInfo");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidObj) && (NULL != RidInfo))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        READARG ReadArg;
        READRES *ReadResult = NULL;
        ENTINFSEL EISelection; // Entry Information Selection
        ATTRBLOCK ReadAttrBlock;
        COMMARG *CommArg;
        ULONG RetCode = 0;
        ULONG Index = 0;
        ATTR *Attr = NULL;

        RtlZeroMemory(&ReadArg, sizeof(READARG));
        RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
        RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

        Attr = (ATTR *)DSAlloc(sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (NULL == Attr)
        {
            return(STATUS_NO_MEMORY);
        }

        RtlZeroMemory(Attr, sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (RID_ALLOCATED_POOL & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_ALLOCATION_POOL;
            Index++;
        }

        if (RID_PREV_ALLOC_POOL & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_PREVIOUS_ALLOCATION_POOL;
            Index++;
        }

        if (RID_USED_POOL & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_USED_POOL;
            Index++;
        }

        if (RID_NEXT_RID & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_NEXT_RID;
            Index++;
        }

        ReadAttrBlock.attrCount = Index;
        ReadAttrBlock.pAttr = Attr;

        EISelection.AttrTypBlock = ReadAttrBlock;
        EISelection.attSel = EN_ATTSET_LIST;
        EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

        ReadArg.pSel = &EISelection;
        ReadArg.pObject = RidObj;
        CommArg = &(ReadArg.CommArg);
        BuildStdCommArg(CommArg);

        RetCode = DirRead(&ReadArg, &ReadResult);

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: DirRead (RidObject) retcode = 0x%lx\n",
                       RetCode));

        if (NULL==ReadResult)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&ReadResult->CommRes);
        }


        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampExtractReadResults(RidObjectType,
                                              ReadResult,
                                              RidInfo);

            // BUG: Need a routine to free the memory inside RidInfo.
        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirRead (RidObject) status = 0x%lx\n",
                           NtStatus));

        }

        THFree(Attr);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampExtractReadResults status = 0x%lx\n",
                           NtStatus));
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


//============================================================================
//
//          Invalidating an existing RID pool to throw away the current
//          RID range allocated
//              - can be called only at startup before
//                  SampDomainRidInitialization()
//              - this invalidation is authoritative i.e. we will force it to
//                  win against any other version in the enterprise
//
//============================================================================

NTSTATUS
SampInvalidateRidRange(BOOLEAN fAuthoritative)
{
    NTSTATUS NtStatus, TempNtStatus;


    PDSNAME pDSNameRidObject = NULL;
    RIDINFO RidObjectInfo;
    RIDFLAG Flags;
    PVOID   pTHSSave = NULL;


    SAMTRACE("SampInvalidateRidRange");

    __try
    {
        // save the thread state
        pTHSSave = THSave();

        //
        // This assert is really just a place holder to understand who
        // is calling us.  This routine closes the transaction, so
        // caller's so not be expecting to get have a transaction
        // when leaving this function.
        //
        ASSERT( !SampExistsDsTransaction() );

        NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
        if (!NT_SUCCESS(NtStatus))
        {
            __leave;
        }

        RtlZeroMemory(&RidObjectInfo, sizeof(RIDINFO));
        Flags = (   RID_ALLOCATED_POOL
                    | RID_PREV_ALLOC_POOL
                    | RID_USED_POOL
                    | RID_NEXT_RID);

        SampSetRidFlags(&RidObjectInfo, Flags);

        // First try to read all the RID info to sanity check that all required
        // fields of the RID range info exist
        // Note: This read doesn't serve any useful purpose except to make sure that
        // all fields expected on the RID object really exist.
        NtStatus = SampObtainRidInfo(NULL,&pDSNameRidObject, &RidObjectInfo);
        if (!NT_SUCCESS(NtStatus))
        {
            // Failed to read the RID object
            SampDiagPrint(RID_MANAGER,
                ("SAMSS: SampReadRidObjectInfo status = 0x%lx\n",
                NtStatus));

            __leave;
        }

        // Invalidate the RID range by resetting the ranges and next rid values to 0
        //SampSetRidPoolAllocated(&RidObjectInfo, 0, 0);
        SampSetRidPoolPrevAlloc(&RidObjectInfo, 0, 0);
        SampSetRidPoolUsed(&RidObjectInfo, 0, 0);
        SampSetRid(&RidObjectInfo, 0);
        SampSetRidFlags(&RidObjectInfo, Flags);

        NtStatus = SampUpdateRidObject(pDSNameRidObject, &RidObjectInfo, FALSE, fAuthoritative);
        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                ("SAMSS: SampUpdateRidObject status = 0x%lx\n",
                NtStatus));

            __leave;
        }
    }
    __finally
    {


        TempNtStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                     TransactionCommit : TransactionAbort );

        if ( !NT_SUCCESS( TempNtStatus ) )
        {
            SampDiagPrint(RID_MANAGER,
                ("SAMSS: SampMaybeEndDsTransaction status = 0x%lx\n",
                TempNtStatus));
        }


        // restore the original thread state if appropriate
        if (pTHSSave)
        {
            THRestore(pTHSSave);
        }



    }

    return (NtStatus);
}


//============================================================================
//
//                           Rid Request/Allocation
//
//============================================================================


VOID
SampComputeRidThreshold(
    IN ULONG MaximumAllocatedRid,
    OUT PULONG RidThreshold
    )

/*++

Routine Description:

    This routine calculates the RID threshold value, which is used to deter-
    mine whether or not to request another RID pool. If the value of NextRid
    is greater than RidThreshold, then typically, a new pool is allocated.

    Whenever a DC (DSA) creates a new account, a RID is assigned to that ac-
    count. Each DC has a finite pool of RIDs allocated to it at any point in
    time.

    As RIDs are assigned, the allocation pool shrinks and eventually reaches
    a threshold. Upon reaching the threshold, the DC submits a request to the
    RID Manager for another RID pool.

    If the allocation is made, the current RID pool is saved in the previous
    RID pool attribute and the new RID pool is saved in the current pool. This
    way, the remaining RIDs (between the threshold and the end of the pool)
    can still be used for assignment, rather than throwing them away. When
    the previous RID pool is completely exhausted, the next RID comes from the
    current RID pool.

    // BUG: Change RID threshold calculation to a "RID consumption rate".

Arguments:

    MaximumAllocatedRid - The maximum RID that this DC has allocated to it.

    RidThreshold - Pointer, returned RID value that is the threshold RID.

Return Value:

    None.

--*/

{
    SAMTRACE("SampComputeRidThreshold");

    ASSERT(NULL != RidThreshold);

    // The MaximumAllocatedRid is the largest RID currently allocated to
    // the DC. This value should always be greater than the starting RID
    // in a domain, and no greater than the domain's maximum RID. It also
    // must be greater than the threshold factor, otherwise an internal
    // error has occurred. The value of SampRidThreshold is defined in
    // ridmgr.h as a static percentage of the overall size of the allocated
    // RID pool. In the future, it may be more accurate to define the
    // threshold in terms of a "RID consumption rate" instead of a static
    // value.

    ASSERT(MaximumAllocatedRid > SampMinimumDomainRid);
    ASSERT(MaximumAllocatedRid <= SampMaximumDomainRid);
    ASSERT(MaximumAllocatedRid > SampRidThreshold);

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: MaximumAllocatedRid = %lu Computed Threshold = %lu\n",
                   MaximumAllocatedRid,
                   SampRidThreshold));

    *RidThreshold = MaximumAllocatedRid - SampRidThreshold;

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: RidThreshold = %lu\n", *RidThreshold));

    // The computed RID threshold should always be less than the maximum
    // RID in the DC's current RID pool and larger than the domain's small-
    // est RID.

    ASSERT(*RidThreshold > SampMinimumDomainRid);
    ASSERT(*RidThreshold < MaximumAllocatedRid);

    return;
}



NTSTATUS
SampFindRidManager(
    OUT PDSNAME *RidManager
    )

/*++

Routine Description:

    This routine returns the DSNAME of the RID Manager object, as set in
    the RID Manager Reference attribute of the DS Domain object.

Arguments:

    RidManager - Pointer to the DN of the returned RID Manager.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RIDFLAG Flags = RID_REFERENCE;
    PDSNAME Parent = NULL;
    ULONG DsNameLength = 0;
    RIDINFO RidInfo;

    SAMTRACE("SampFindRidManager");

    if ((NULL != RidManager) && (fNullUuid(&CachedRidManagerObject.Guid)))
    {

        DsNameLength = 0;
        NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                        &DsNameLength,
                                        Parent);

        ASSERT(STATUS_BUFFER_TOO_SMALL == NtStatus);
        if (STATUS_BUFFER_TOO_SMALL == NtStatus)
        {
            SAMP_ALLOCA(Parent,DsNameLength );
            if (NULL==Parent)
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }

            NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                            &DsNameLength,
                                            Parent);
        }

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RID Manager Reference = %ws\n",
                       Parent->StringName));


        RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
        SampSetRidFlags(&RidInfo, Flags);

        NtStatus = SampReadRidManagerReferenceInfo(Parent, &RidInfo);

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RID Manager = %ws\n",
                       RidInfo.RidManagerReference->StringName));

        if (NT_SUCCESS(NtStatus))
        {
            // Just set the outbound name pointer to the returned buffer,
            // which was allocated by SampReadRidManagerReferenceInfo. The
            // caller must release the buffer.

            *RidManager = RidInfo.RidManagerReference;

        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampReadRidManagerReferenceInfo status = 0x%lx\n",
                           NtStatus));
        }

    }
    else if (NULL!=RidManager)
    {

        //
        // Give back the cached Rid manager object, so that time is saved
        //

        *RidManager = &CachedRidManagerObject;
    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(NtStatus);
}





NTSTATUS
SamIFloatingSingleMasterOpEx(
    IN  PDSNAME  RidManager,
    IN  PDSNAME  TargetDsa,
    IN  ULONG    OpCode,
    IN  ULARGE_INTEGER *ClientAllocPool,
    OUT PDSNAME **ObjectArray OPTIONAL
    )

/*++

Routine Description:

    This routine is the worker routine for RID-pool allocations. This function
    assumes the DC that is running this function is the RID FSMO owner.

    This entire routine is done in one ds transaction.

    Steps are as follows:

    Find the computer object for the target dsa
    If no rid object exists for it, create one
    Get a pool of rid's from the rid manager object
    Assign that pool of rids to the rid object
    Return the rid object

Arguments:

    TargetDsa - Pointer to the DN of the RID Manager.

    OpCode - FSMO operation requested.

    ClientAllocVersion - the version of the client's AllocPool attribute

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;

    RIDFLAG Flags = 0;
    RIDINFO RidInfo;

    PDSNAME ComputerObject = NULL;
    PDSNAME RidObject      = NULL;
    PDSNAME LocalDsaObject = NULL;

    ULONG MaxRidAvail = 0;
    ULONG MinRidAvail = 0;

    ULONG MaxRidAlloc = 0;
    ULONG MinRidAlloc = 0;
    ULONG MaxRidPrev = 0;
    ULONG MinRidPrev = 0;
    ULONG NextRid = 0;

    ULONG MinRidTemp = 0;

    BOOLEAN fCreateRidObject = FALSE;
    BOOLEAN fLockHeld = FALSE;
    BOOLEAN fKeepThreadState = FALSE;

    SAMP_DS_TRANSACTION_CONTROL CommitType = TransactionCommit;
    SAMP_DS_TRANSACTION_CONTROL AbortType = TransactionAbort;

    ULONG Length = 0;

    SAMTRACE("SamIFloatingSingleMasterOpEx");


    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: Servicing Rid Request from %ls\n",
                   TargetDsa->StringName));

    //
    // Parameter check
    //
    ASSERT( RidManager );
    ASSERT( TargetDsa );

    //
    // Retrieve a local variable
    //
    Length = 0;
    LocalDsaObject = NULL;
    NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                    &Length,
                                    LocalDsaObject);
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        SAMP_ALLOCA(LocalDsaObject,Length);
        if (NULL==LocalDsaObject)
        {
           return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                        &Length,
                                        LocalDsaObject);
    }
    if ( !NT_SUCCESS( NtStatus ) )
    {
        return NtStatus;
    }

    //
    // Determine if we need to keep our thread state
    //
    if ( THQuery() )
    {
        fKeepThreadState = TRUE;
        CommitType = TransactionCommitAndKeepThreadState;
        AbortType = TransactionAbortAndKeepThreadState;
    }

    //
    // We should not be called in a transaction, nor should the ds
    // have a write lock on SAM
    //
    ASSERT( !SampExistsDsTransaction() );
    ASSERT( !SampIsWriteLockHeldByDs() );


    //
    // If this is the local dsa calling wait for write access to the
    // rid object, so write conflicts can be avioded.
    //
    if ( NameMatched( LocalDsaObject, TargetDsa ) )
    {
        SampAcquireSamLockExclusive();
        fLockHeld = TRUE;
    }

    //
    // Many servers maybe calling in to get rid pools.  To avoid write
    // conflicts on the rid manager object, guard writes with a critical section
    //
    RtlEnterCriticalSection( RidMgrCritSect );

    //
    // Start a write transaction
    //
    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // Read first object we'll need:
    // the target's computer object
    //
    Flags = RID_ALLOCATED_POOL | RID_PREV_ALLOC_POOL | RID_NEXT_RID ;
    RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
    SampSetRidFlags(&RidInfo, Flags);

    NtStatus = SampFindComputerObject( TargetDsa, &ComputerObject );
    if ( NT_SUCCESS( NtStatus ) )
    {
        //
        // Ok, now try and find the rid object
        //
        NtStatus = SampFindRidObjectEx( ComputerObject, &RidObject);
        if ( NT_SUCCESS( NtStatus ) )
        {
            //
            // Ok, now try to read it
            //
            NtStatus = SampReadRidObjectInfo( RidObject, &RidInfo );
            if ( NtStatus == STATUS_OBJECT_NAME_NOT_FOUND )
            {
                //
                // This is acceptable when then rid set object has
                // been deleted since the reference will still point
                // to the deleted object. The RID on the deleted RID
                // Set are lost, RID reclamation is a very difficult 
                // problem to solve in view of security considerations
                // that a SID can never be reused
                //

                fCreateRidObject = TRUE;
                NtStatus = STATUS_SUCCESS;
            }

        }
        else if ( NtStatus == STATUS_DS_NO_ATTRIBUTE_OR_VALUE )
        {
            fCreateRidObject = TRUE;
            NtStatus = STATUS_SUCCESS;
        }
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    if ( fCreateRidObject )
    {
        ULONG   DsNameSize = 0;

        DsNameSize = (ULONG)DSNameSizeFromLen( ComputerObject->NameLen +  
                                               wcslen(RID_SET_W) + 
                                               4 ); 

        RidObject = THAlloc( DsNameSize );

        if ( !RidObject )
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlZeroMemory( RidObject, DsNameSize );

        AppendRDN(ComputerObject,
                  RidObject,
                  DsNameSize,
                  RID_SET_W,
                  0,
                  ATT_COMMON_NAME);

        // Create the RID object with DN NewRidObject and update the
        // associated attributes on ComputerObject.

        NtStatus = SampCreateRidObject( ComputerObject, RidObject );

        if ( NT_SUCCESS( NtStatus )
          || (NtStatus == STATUS_USER_EXISTS)
          || (NtStatus == STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS) )
        {
            NtStatus = SampReadRidObjectInfo( RidObject, &RidInfo );
        }
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    ASSERT( ComputerObject );
    ASSERT( RidObject );

    //
    // Put the values in convienent variables
    //

    SampGetRidPoolAllocated(&RidInfo, &MaxRidAlloc, &MinRidAlloc);
    SampGetRidPoolPrevAlloc(&RidInfo, &MaxRidPrev, &MinRidPrev);
    SampGetRid(&RidInfo, &NextRid);

    ASSERT( NextRid <= MaxRidPrev );
    ASSERT( NextRid >= MinRidPrev );

    //
    // First determine if we need to really to allocate a pool or not
    //
    if (  ClientAllocPool != 0
       && ClientAllocPool->HighPart != 0
       && ClientAllocPool->HighPart < MaxRidAlloc ) {

        //
        // The client has allocated rid pool that is less the version
        // that we, the rid master, already has.  So to satisfy this client,
        // all we need to do is return the version we have locally on this
        // DS
        //
        NtStatus = STATUS_SUCCESS;
        goto Cleanup;

    }

    //
    // Now we have the information about the target's dsa's current rid pool
    // "carve of a rid pool"
    //
    Flags = RID_AVAILABLE_POOL|RID_ROLE_OWNER;
    RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
    SampSetRidFlags(&RidInfo, Flags);

    NtStatus = SampReadRidManagerInfoEx(RidManager, &RidInfo);

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // Make sure we are the role owner
    //
    if ( !NameMatched( RidInfo.RoleOwner, LocalDsaObject ) )
    {
        NtStatus = STATUS_INVALID_OWNER;
        goto Cleanup;
    }

    SampGetRidPoolAvailable(&RidInfo, &MaxRidAvail, &MinRidAvail);

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: Available RID Range = %lu - %lu\n",
                   MinRidAvail,
                   MaxRidAvail));

    // Save the minimum available RID in a temporary and increment
    // the minimum available RID by the block size. Increasing the
    // minimum available RID is how the pool of available RIDs is
    // reduced during allocation.

    MinRidTemp = MinRidAvail;
    MinRidAvail += SampRidBlockSize;

    if (MinRidAvail > MaxRidAvail)
    {
        // If the (new) minimum is greater than the maximum RID, set
        // the minimum available RID to the maximum available RID,
        // indicating that the domain's RID pool has been consumed.
        // Use the last (partial) RID pool available to the DC rather
        // than throwing it away.

        MinRidAvail = MaxRidAvail;
    }

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: Available RID Range = %lu - %lu\n",
                   MinRidAvail,
                   MaxRidAvail));

    ASSERT(MinRidAvail <= MaxRidAvail);

    if (MinRidAvail <= MaxRidAvail)
    {
        Flags = RID_AVAILABLE_POOL;

        SampSetRidFlags( &RidInfo, Flags );
        SampSetRidPoolAvailable(&RidInfo, MaxRidAvail, MinRidAvail);

        // Update the RID Manager with the new range of available
        // RIDs, reflecting the allocation. The available RID pool
        // has now been reduced in size. The next step is to give
        // this pool to the requesting DC (below).

        NtStatus = SampUpdateRidManager(RidManager, &RidInfo);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampUpdateRidManager status = 0x%lx\n",
                           NtStatus));
        }
    }
    else
    {
        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: All RIDs have been used for this domain\n"));

        NtStatus = STATUS_NO_MORE_RIDS;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    // The RID Manager's available RID pool has been reduced, make the
    // allocation to the requesting DC.

    MinRidAlloc = MinRidTemp;

    // If the minimum available RID equals the maximum available
    // RID, there is one remaining RID available in the domain,
    // namely the domain's maximum RID. If this is the case, then
    // set the maximum allocated RID to the minimum available
    // RID; otherwise set it to one less than the minimum avail-
    // able RID (the non-boundary case) to avoid overlapping RID
    // ranges across allocations.

    (MinRidAvail == MaxRidAvail) ?
        (MaxRidAlloc = MinRidAvail) :
        (MaxRidAlloc = (MinRidAvail - 1));

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: MinRidPrev = %lu MaxRidPrev = %lu\n",
                   MinRidPrev,
                   MaxRidPrev));

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: MinRidAlloc = %lu MaxRidAlloc = %lu\n",
                   MinRidAlloc,
                   MaxRidAlloc));

    ASSERT((MinRidPrev <= MaxRidPrev) &&
       (MaxRidPrev <= MinRidAlloc) &&
       (MinRidAlloc <= MaxRidAlloc));

    Flags = RID_ALLOCATED_POOL;
    SampSetRidFlags( &RidInfo, Flags );
    SampSetRidPoolAllocated(&RidInfo, MaxRidAlloc, MinRidAlloc);

    NtStatus = SampUpdateRidObject(RidObject, &RidInfo, FALSE, FALSE);

    if (!NT_SUCCESS(NtStatus))
    {
        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: SampUpdateRidObject status = 0x%lx\n",
                       NtStatus));
        goto Cleanup;
    }

    //
    // That's it - fall through to cleanup
    //

Cleanup:

    ASSERT( SampExistsDsTransaction() );

    if ( NT_SUCCESS( NtStatus ) )
    {
        NtStatus = SampMaybeEndDsTransaction( CommitType );
    }
    else
    {
        // We need to keep our thread state
        IgnoreStatus = SampMaybeEndDsTransaction( AbortType );
    }

    if ( fKeepThreadState )
    {
        ASSERT( THQuery() );

        //
        // Lose our SAM status
        //
        SampSetSam( FALSE );
    }

    //
    // We have commited our changes, so we can release our critical sections
    //
    RtlLeaveCriticalSection( RidMgrCritSect );

    if ( fLockHeld )
    {
        SampReleaseSamLockExclusive();
    }


    //
    // Set the out parameter
    //
    if ( NT_SUCCESS( NtStatus ) )
    {
        if ( ObjectArray )
        {
            // We pass back the value using heap memory so there should
            // be a thread state
            ASSERT( THQuery() );

            //
            // The rid manager object gets automatically returned -
            // we need to return the rid object and computer object
            // since the computer object's reference to the rid object
            // may have been updated.
            //
            *ObjectArray = (PDSNAME*) THAlloc( 3 * sizeof(PDSNAME) );
            if ( *ObjectArray )
            {
                RtlZeroMemory( *ObjectArray, 3 * sizeof(PDSNAME) );
                (*ObjectArray)[0] = RidObject;
                (*ObjectArray)[1] = ComputerObject;
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
    }

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: Servicing Rid Request from %ls finished with 0x%x\n",
                   TargetDsa->StringName, NtStatus));

    return( NtStatus );
}


NTSTATUS
SampRequestRidPool(
    IN PDSNAME RidManager,
    IN BOOLEAN VerboseLogging
    )

/*++

Routine Description:

    This routine calls the Floating Single Master Operation (a.k.a FSMO) to
    request a new RID pool from the role owner (the current RID Manager). It
    is assumed that this routine is asynchronous, hence, can return before
    the new RID pool has actually been allocated to the requesting DC.

    The requesting DC finds out that it has been granted a new RID pool by
    reading the allocated RID pool attribute. This is typically done in the
    normal course of RID allocation or assignment. There is no notification
    event generated to alert the requesting DC that the RID pool has been
    allocated.

Arguments:

    RidManager - Pointer to the DN of the current RID Manager.

    VerboseLogging - if TRUE, log all events

    RetryMaximum - Maximum number of times the RID request will be attempted.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG  OpCode = SAMP_REQUEST_RID_POOL;
    OPARG  OpArg;
    OPRES  *OpResult = NULL;
    OpType Operation;
    USHORT RetryCount = 0;
    USHORT EventType = 0;
    RIDINFO RidInfo;
    DWORD WinError = ERROR_SUCCESS;
    ULONG  WaitTime = SAMP_RID_DEFAULT_RETRY_INTERVAL; // Our default is 30 seconds before we try a new request
    ULONG Status = 0;
    RIDFLAG Flags = (RID_ALLOCATED_POOL |
                         RID_PREV_ALLOC_POOL |
                         RID_NEXT_RID);
    PDSNAME RidObject;

   

    SAMTRACE("SampRequestRidPool");

    //
    // Parameter check
    //
    ASSERT( RidManager );

    //
    // This function has been written to control its own transactioning
    //
    ASSERT( !SampExistsDsTransaction() );

    //
    // We are going of the machine! By no means should the write lock be held
    //
    ASSERT( !SampIsWriteLockHeldByDs() );

    //
    // The thread that started this request should have already set the
    // guard to TRUE.
    //
    ASSERT( SampDcRidRequestPending == TRUE );


    RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
    SampSetRidFlags(&RidInfo, Flags);



    do
    {
        // This is the retry loop for acquiring the RID FSMO owner
        // role. This loop will repeat for RetryMaximum times. Note
        // that while waiting (sleep) between retries, the thread
        // state is destroyed so as to reduce resource consumption
        // while blocked.

        //
        // Reset the error code displayed to the user
        //

        WinError = ERROR_SUCCESS;

        //
        // If verbose logging is enabled then log an event saying that we are about
        // to acquire a RID pool.
        //

        if ( VerboseLogging ) {

            SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                              0,
                              SAMMSG_REQUESTING_NEW_RID_POOL,
                              NULL,
                              0,
                              0,
                              NULL,
                              NULL);
        }


        //
        // Create a thread state, if thread state creation fails,
        // set the error code to not enough memory and break out
        // of the loop
        //
        
        Status = THCreate( CALLERTYPE_SAM );

        
        if (Status)
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        SampSetDsa(TRUE);

        //
        // Request a RID pool from the FSMO role owner
        //
        
        RtlZeroMemory(&OpArg, sizeof(OPARG));
        OpArg.eOp = OP_CTRL_RID_ALLOC;

        Status = DirOperationControl(&OpArg, &OpResult);

        // If either the status or the extended-error indicates a
        // failure of any kind, continue retrying the operation until
        // the maximum retry limit is reached.

        if ( NULL == OpResult ) {

            // Indicate what the problem was
            WinError = ERROR_NOT_ENOUGH_MEMORY;

            // get out of this loop
            break;

        }
        else if (Status)
        {

            //
            // Dir Operation control failed due to one reason or other
            //

            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: FSMO DirOperationControl status = %lu\n",
                           Status));


            //
            // Some error was hit -- try to get the most accurate win32 error
            // to describe the failure
            //
            switch ( OpResult->ulExtendedRet ) {
                case FSMO_ERR_SUCCESS:

                    //
                    // Actually FSMO_ERR_SUCCESS can come back if the operation
                    // failed locally as part of a commit etc but not in the remote
                    // DC. In that case if we have retried more than SAMP_RID_LOCAL_UPDATE_RETRY_CUTOFF
                    // times then backoff to 30 min RID pool request intervals
                    //

                    if (RetryCount>SAMP_RID_LOCAL_UPDATE_RETRY_CUTOFF)
                    {
                        // WaitTime is in milliseconds

                        WaitTime = SAMP_RID_LOCAL_UPDATER_ERROR_RETRY_INTERVAL;
                    }

                    //
                    // Fall through the Default path, which translates to DirError returned
                    //

                case FSMO_ERR_COULDNT_CONTACT:
                    WinError = ERROR_DS_COULDNT_CONTACT_FSMO;
                    break;
                case FSMO_ERR_UPDATE_ERR:
                    WinError  = ERROR_DS_BUSY;
                    break;
                case FSMO_ERR_OWNER_DELETED:
                    WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
                    break;
                case FSMO_ERR_REFUSING_ROLES:
                    WinError = ERROR_DS_REFUSING_FSMO_ROLES;
                    break;
                case FSMO_ERR_MISSING_SETTINGS:
                    WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
                    break;
                case FSMO_ERR_DIR_ERROR:
                    WinError = ERROR_DS_DATABASE_ERROR;
                    break;
                case FSMO_ERR_ACCESS_DENIED:
                    WinError = ERROR_DS_DRA_ACCESS_DENIED;
                    break;
                default:
                    //
                    // This covers
                    //
                    //  FSMO_ERR_UNKNOWN_OP
                    //  FSMO_ERR_NOT_OWNER
                    //  FSMO_ERR_EXCEPTION
                    //  FSMO_ERR_UNKNOWN_CALLER
                    //  FSMO_ERR_RID_ALLOC
                    //  FSMO_ERR_PENDING_OP
                    //  FSMO_ERR_MISMATCH
                    //
                    WinError = DirErrorToWinError( Status, &OpResult->CommRes);
                    break;
            }

            //
            // An error of some kind has occurred which is either a 
            // connectivity failure of some sort, or a failure to update
            // the pool locally. Wait for specified wait time and then
            // retry the operation
            //

            //
            // If this is the first time this error has occured then write
            // out an event log indicating the error
            //

            if (0==RetryCount)
            {
                SampWriteEventLogWithError(
                              EVENTLOG_ERROR_TYPE,
                              SAMMSG_RID_REQUEST_STATUS_FAILURE,
                              WinError);
            }

            //
            // Release resources before waiting.

            THDestroy();

            //
            // Wait for either shut down to occur or for the system to
            // for time out period, which is 30 seconds.
            //

            WaitForSingleObject(SampAboutToShutdownEventHandle,WaitTime);

            //
            // Reset the wait time back to  the default of 30 seconds.
            // if we waited because of a database error for 30 minutes
            // and subsequently failed due to a network error, then we should
            // retry again in 30 seconds and not after 30 mins.
            //

            WaitTime = SAMP_RID_DEFAULT_RETRY_INTERVAL;
        }

        RetryCount++;

        //
        // Log a successful RID pool acquire message
        // if either verbose logging is enabled, or 
        // if we previously failed to acquire a RID pool
        //

        if (( ERROR_SUCCESS == WinError ) &&
           ( (VerboseLogging ) || (RetryCount>1)))
        {

            SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                              0,
                              SAMMSG_RID_REQUEST_STATUS_SUCCESS,
                              NULL,
                              0,
                              sizeof(WinError),
                              NULL,
                              &WinError);

     
        }

    } while ((ERROR_SUCCESS!=WinError) && 
             (SampServiceState==SampServiceEnabled));

    //
    // Check if we successfully allocated a RID pool
    //

    if (WinError!=ERROR_SUCCESS)
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

   //
   // the AllocatedPool has already been
   // updated with a new pool.  All we need to do, is catch
   // the boundary case where next rid is 0 and update ourselves
   // This case can happen when the initial rid pool is acquired
   // and when the rid pool is invalidated
   //
           

    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );
    if ( NT_SUCCESS( NtStatus ) )
    {
        NtStatus = SampObtainRidInfo( NULL,
                                      &RidObject,
                                      &RidInfo );
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    SampDumpRidInfo(&RidInfo);

    NtStatus = SampInitNextRid( RidObject,
                                &RidInfo );

        

Cleanup:

    if ( SampExistsDsTransaction() )
    {
        SampMaybeEndDsTransaction( NT_SUCCESS( NtStatus ) ? TransactionCommit :
                                   TransactionAbort );

    }

   
    //
    // If we succeeded in getting a Rid Pool then turn back on our
    // writable flag
    //


    if (NT_SUCCESS(NtStatus))
    {

        I_NetLogonSetServiceBits(DS_DS_FLAG,DS_DS_FLAG);

    }

    //
    // Whether in success or failure, the rid request is over
    //

    SampDcRidRequestPending = FALSE;

    //
    // Make sure we left our state as we came in
    //
    ASSERT( !SampExistsDsTransaction() );
    ASSERT( !SampIsWriteLockHeldByDs() );

    return(NtStatus);
}


NTSTATUS
SampAsynchronousRidPoolRequest(
    LPVOID Parameter
    )

/*++

Routine Description:

    This routine is called whenever a RID pool is needed "out of band",
    meaning that the request for a RID pool is done in a new thread so
    that the primary thread of the caller can continue on.

Arguments:

    Parameter - Pointer, request information, contains the DS name of the
        RID Manager object, flag indicating whether or not FSMO role owner-
        ship is being requested, and the maximum number of retries to con-
        tact the current FSMO role owner.

Return Value:

    STATUS_SUCCESS if the RID pool was acquired, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDSNAME RidManager = (PDSNAME)Parameter;


    //
    // Increment the Active Thread Count, so that shutdown will
    // wait for this thread
    //

    SampIncrementActiveThreads();

    NtStatus = SampRequestRidPool(
                    RidManager,
                     FALSE
                     );

    if (NT_SUCCESS(NtStatus))
    {
        // Since this routine is called during first-time DC boot, be sure
        // to set SampRidManagerInitialized after successfull acquisition of
        // a RID pool. Note that this flag is set whenever this routine re-
        // turns successfully, and is benign to do so if the flag was set
        // previously.

        SampRidManagerInitialized = TRUE;
    }

    RtlFreeHeap(RtlProcessHeap(), 0, Parameter);

    SampDecrementActiveThreads();

    return(NtStatus);
}


NTSTATUS
SampRequestRidPoolAsynchronously(
    IN DSNAME * RidManager
    )
/*++

    This routine does the work of requesting a Rid pool in a
    background thread. That is it creates the thread that would
    go and request a RID pool


    Parameters

        RidManager -- The RId manager object, needed for passing into the
        Rid pool request routine

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    ThreadID;
    PVOID    Parameter;
    HANDLE   ThreadHandle;


    Parameter = RtlAllocateHeap(RtlProcessHeap(),
                                        0,
                                        RidManager->structLen);

    if (NULL == Parameter)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto ErrorCase;
    }

    RtlCopyMemory(Parameter, RidManager, RidManager->structLen);

    SampDcRidRequestPending = TRUE;

    ThreadHandle = CreateThread(NULL,//Attributes,
                                0,//StackSize,
                                SampAsynchronousRidPoolRequest,
                                Parameter,
                                0,//CreateFlags,
                                &ThreadID);

    if (NULL == ThreadHandle)
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: CreateThread returned NULL handle\n"));

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SampDcRidRequestPending = FALSE;
        RtlFreeHeap(RtlProcessHeap(),0,Parameter);
        goto ErrorCase;
    }
    else
    {
        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RID request thread ID = 0x%lx\n",
                       ThreadID));


        CloseHandle(ThreadHandle);
    }

ErrorCase:

    return NtStatus;
}


NTSTATUS
SampGetNextRid(
    IN PSAMP_OBJECT DomainContext,
    OUT PULONG Rid
    )

/*++

Routine Description:

    This routine returns the next available RID from the current allocation
    pool (for this DC). If the RID value is greater than the threshold of the
    current allocation pool (i.e. there are only a limited number of RIDs
    left in the current pool), then a request for more RIDs is generated.
    Requests for new RID pools is accomplished via the FSMO (Floating Single
    Master Operation) mechanism in the DS.

    Because allocated RID pools are disjoint from one another, there will be
    effective "gaps" in the RID space for any single DC. This routine will
    "step over" gaps in the RID space, always returning the next RID that
    can be assigned to a new account.

    The RID value is incremented with each account creation. This value is
    cached in memory, but also written to the registry for persistence a-
    cross reboots. Writing to the registry is much cheaper than writing to
    the DS each time the RID is incremented. The RID cache is a finite size
    and is decremented with each increment to the RID value. When the cache
    size reaches zero, the value of the current RID is written to the DS.
    The registry is not the primary backing store for the RID value, but is
    just used as a cheaper way to maintain the RID value as it changes, and
    across reboots.

    Multiple threads can call this routine concurrently, as it is protected
    by the SAM Lock

    Note that this routine has been written to avoid assigning RIDs from
    pools that it does not own--seems natural enough, but sometimes diffi-
    cult in real practice due to threading, overlapping transactions, and
    DC crashes. Therefore, after the RID value is incremented, several
    "sanity" checks are performed to catch a bogus RID. In certain cases,
    an error is returned, which will prevent account creation with a bad
    RID. In other cases, this may lead to another attempt to acquire FSMO
    ownership in order to get a new RID pool.

    The routine has also been written so that rebooting a DC which is in
    "RID trouble" will clear the internal state and allow account creation
    to continue.

    This routine is ONLY used in DS case. However there are 2 flavors in DS 
    case. 
    
    1. SAM API (downlevel). The Caller should hold SAM lock already, 
       so within this routine, we will open a new DS transaction (if no
       DS transaction opened yet) and acquire a new RID from DS. 
       
       Note: in this case, we will not commit the DS transaction within
             this routine. Indeed, SAM will either commit or abort the 
             whole account creation operation as a one transaction. So
             that we won't lost a unused RID due to failed operation.  
             We can do it only in downlevel SAM creation case, that is 
             because the SAM / DS database is guarded by SAM lock to 
             serialize all write/read operations. 
             
    2. Loopback case. If it is a loopback client, the caller will not 
       hold SAM lock before calling into this routine. So this routine
       will need to acquire SAM lock, save existing DS transaction,
       then start a new DS transaction. Once retrieving the next RID, 
       we will commit the new DS transaction and restore the old 
       transaction, also release SAM lock. 
       
       This scheme will guanrantee the SAM account RID uniqueness, because
       we always acquire the SAM lock before update the next RID value
       in DS. 
       
       However the side effect of doing that is losing a unused RID if
       the whole account creation failed.             


Arguments:

    Rid - Pointer to the returned Relative ID (RID).

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    Other DS error codes that have been mapped to an NTSTATUS can be returned
    from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    RIDINFO  RidInfo;
    RIDFLAG  Flags;
    PDSNAME  RidManager = NULL;
    ULONG    Length = 0;
    BOOLEAN  fRequestNewRidPool = FALSE;
    BOOLEAN  fUpdatePrevPool = FALSE;

    PDSNAME  ComputerObject = NULL;
    PDSNAME  NewRidObject = NULL;

    ULONG    AllocHigh = 0;
    ULONG    AllocLow = 0;
    ULONG    PrevAllocHigh = 0;
    ULONG    PrevAllocLow = 0;
    ULONG    RidThreshold = 0;
    ULONG    NextRidOnDatabase=0;

    BOOLEAN  AlreadyNotifiedUserOfError = FALSE;

    PVOID   *pTHState = NULL;

    SAMTRACE("SampGetNextRid");

    ASSERT( Rid );

    RtlZeroMemory(&RidInfo, sizeof(RIDINFO));

    if (!SampRidManagerInitialized)
    {
        return STATUS_NO_RIDS_ALLOCATED;
    }

    if (DomainContext->LoopbackClient) 
    {
        ASSERT(SampUseDsData && THQuery());
        pTHState = THSave();
        ASSERT( pTHState );

        ASSERT( !SampCurrentThreadOwnsLock() && "Should NOT have SAM lock\n");
        SampAcquireSamLockExclusive();

        if (!NT_SUCCESS(NtStatus)) {
            goto ErrorCase;
        }
    }
    else
    {
        ASSERT( SampCurrentThreadOwnsLock() );
    }


    // Read the RID Object's data to determine the value of the next RID
    // that can be assigned, as well as the allocation pool.

    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

    if ( NT_SUCCESS( NtStatus ) )
    {

        Flags = RID_NEXT_RID | RID_ALLOCATED_POOL | RID_PREV_ALLOC_POOL;
        SampSetRidFlags(&RidInfo, Flags);

        NtStatus = SampObtainRidInfo( NULL,
                                      &NewRidObject,
                                      &RidInfo );

    }

    if ( !NT_SUCCESS(NtStatus) )
    {
        goto ErrorCase;
    }

    SampDumpRidInfo(&RidInfo);


    //
    // Put the current values of the various RID pools into local
    // variables for easier access.
    //

    SampGetRidPoolAllocated(&RidInfo, &AllocHigh, &AllocLow);
    SampGetRidPoolPrevAlloc(&RidInfo, &PrevAllocHigh, &PrevAllocLow);
    SampGetRid(&RidInfo, Rid);

    //
    // Increment the RID value by one to dole out the next Rid
    //

    if ((*Rid <= PrevAllocHigh) && (*Rid <= SampMaximumDomainRid))
    {
        (*Rid) += 1;
        NextRidOnDatabase = (*Rid);
    }

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: SampCachedRidsLeft = %lu CachedNextRid = %lu Rid = %lu\n",
                   SampCachedRidsLeft,
                   CachedNextRid,
                   *Rid));



    // After incrementing the RID to its next value, perform various
    // checks. If a RID threshold has been reached at least one time,
    // the previous-RID pool may still contain unused RIDs (because
    // the RID threshold is reached before actual exhaustion). So, if
    // there are still some RIDs in the previous pool, continue to
    // use them before starting to use RIDs from the current pool.

    if (*Rid < SampMinimumDomainRid)
    {
        // The RID is less than the legal minimum RID value, which
        // will occur if the very first request for a RID pool has
        // not yet been fulfilled. The RID value has only been init-
        // ialized to zero (as part of first-time initialization),
        // and no RID pools have been allocated to this DC--the DC
        // is not yet ready to create accounts, so return an error
        // code, allowing the caller to retry the operation later if
        // desired.

        ASSERT((*Rid == 1) || (*Rid == CachedNextRid));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: No RIDs have been assigned\n"));

        NtStatus = STATUS_NO_RIDS_ALLOCATED;

        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,
                          SAMMSG_NO_RIDS_ASSIGNED,
                          NULL,
                          0,
                          sizeof(NTSTATUS),
                          NULL,
                          (PVOID)(&NtStatus));

        AlreadyNotifiedUserOfError = TRUE;

        //
        // This is the case of having no RID pool
        //

        fRequestNewRidPool = TRUE;
 

        goto RequestNewRidPool;
    }

    if (*Rid > SampMaximumDomainRid)
    {
        // The maximum domain RID was surpassed, so no further
        // accounts can be created in the domain, bail out, and
        // exit from the critical section properly.

        
        NtStatus = STATUS_NO_MORE_RIDS;

        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,
                          SAMMSG_MAX_DOMAIN_RID,
                          NULL,
                          0,
                          sizeof(NTSTATUS),
                          NULL,
                          (PVOID)(&NtStatus));

        AlreadyNotifiedUserOfError = TRUE;

        goto ErrorCase;
    }

    if ( *Rid > PrevAllocHigh )
    {

        //
        // The maximum RID of the previous pool was surpassed, so
        // continue with the minimum RID of the new pool, hopping
        // over the gap in the RID space.  This is accomplished by
        // copying in the (next) Allocated Rid Pool
        //

        // We should not skip any rids
        ASSERT( *Rid == PrevAllocHigh + 1 );

        if ( PrevAllocHigh != AllocHigh )
        {
            ASSERT( PrevAllocLow != AllocLow );

            // The next pool should be greater than our last pool
            ASSERT( PrevAllocHigh > PrevAllocLow );
            ASSERT( AllocLow > PrevAllocHigh );
            ASSERT( AllocHigh > AllocLow );

            //
            // Start using the new rid pool
            //
            PrevAllocHigh = AllocHigh;
            PrevAllocLow = AllocLow;
            fUpdatePrevPool = TRUE;

            //
            // Go to the bottom of the previous pool again.
            //

            *Rid = PrevAllocLow;
            NextRidOnDatabase = *Rid;

        }
        else
        {
            //
            // We have exhausted this rid pool and a new rid pool
            // does not yet exist
            //
            NtStatus = STATUS_NO_MORE_RIDS;

            SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                              0,
                              SAMMSG_MAX_DC_RID,
                              NULL,
                              0,
                              sizeof(NTSTATUS),
                              NULL,
                              (PVOID)(&NtStatus));

            AlreadyNotifiedUserOfError = TRUE;

            fRequestNewRidPool = TRUE;

            //
            // Tell netlogon to stop advertising this DC as writable
            //

            I_NetLogonSetServiceBits(DS_DS_FLAG,0);


            goto RequestNewRidPool;

        }
    }

    // As a final test, make sure the RID is within a legal range,
    // i.e. either within the previous pool or the current pool. Do
    // this test before computing the RID threshold so as to avoid
    // erroneous calls to acquire a new RID pool.
    //
    // The assert is used to catch a RID that is not within either
    // the previous pool or the current pool. The permanent test,
    // however, excludes a RID that is larger than the currently
    // allocated maximum from the test. Why? This is so that the
    // boundary case of (*Rid == AllocHigh + 1) will fall through
    // allowing retries for RID-pool acquisition below. Without this
    // exception to the rule, a given DC that has exhausted its RID
    // pool AND has not been able to successfully acquire a new RID
    // pool, will get "stuck" at the value AllocHigh + 1, possibly
    // forcing major Administrator intervention.

    ASSERT( (*Rid >= PrevAllocLow) && (*Rid <= PrevAllocHigh) );

    if ( !(*Rid >= PrevAllocLow) && (*Rid <= PrevAllocHigh) )
    {
        WCHAR String[64];
        UNICODE_STRING UnicodeString;
        PUNICODE_STRING EventString[1];

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RID [%lu] out of valid range\n",
                   *Rid));

        NtStatus = STATUS_INTERNAL_ERROR;

        wsprintf(String, L"%lu", *Rid);
        RtlInitUnicodeString(&UnicodeString, String);
        EventString[0] = &UnicodeString;

        AlreadyNotifiedUserOfError = TRUE;

        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,
                          SAMMSG_INVALID_RID,
                          NULL,
                          1,
                          sizeof(NTSTATUS),
                          EventString,
                          (PVOID)(&NtStatus));


        goto ErrorCase;
    }



    // Determine if the RID threshold of the allocation pool
    // has been reached. If the threshold has been reached, submit a
    // request for another RID allocation pool.
    SampComputeRidThreshold( AllocHigh, &RidThreshold );
    if ( *Rid > RidThreshold )
    {
        //
        // Request a new pool if the current pool is previous pool.
        // That is, if we don't have a new rid pool.
        //
        ASSERT( PrevAllocHigh == AllocHigh );
        ASSERT( PrevAllocLow == AllocLow );
        if ( PrevAllocHigh == AllocHigh ) {

            fRequestNewRidPool = TRUE;

        }
    }

    // Note that the test needs to be "*Rid > RidThreshold" and not
    // just equality. This way, if the DC has been unsuccessful at
    // acquiring a new RID pool for any reason, retry attempts can
    // occur with subsequent account creation. This holds true across
    // reboot scenarios as well. The flag SampDcRidRequestPending is
    // used to guard against overlapping requests for a new RID pool.

RequestNewRidPool:

    if ( ( TRUE == fRequestNewRidPool )
      && ( FALSE == SampDcRidRequestPending) )
    {
        NTSTATUS TempNtStatus = STATUS_SUCCESS;

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RID = %lu, requesting a new RID pool\n",
                      *Rid));

        TempNtStatus = SampFindRidManager(&RidManager);

        if (NT_SUCCESS(TempNtStatus))
        {
            HANDLE ThreadHandle = NULL;
            LPSECURITY_ATTRIBUTES Attributes = NULL;
            DWORD StackSize = 0;
            LPVOID Parameter = NULL;
            DWORD CreateFlags = 0;
            DWORD ThreadID = 0;

            // Submit the request for a new RID pool. The next time
            // the RID pool is read, the values will be updated or
            // not depending on whether or not this request has been
            // processed. Consequently, the RID threshold must be
            // chosen with this asynchonicity in mind. That is, the
            // RID threshold must be large enough to support ongoing
            // account creation during possibly lengthy delays in
            // RID allocation, particularly in the inter-site cases.

            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: Requesting RID pool.\n"));

            // SampRequestRidPool may go off-machine to acquire FSMO
            // role ownership, and this is happening inside a SAM
            // transaction. Consequently, a new thread is spun off to
            // do the work of acquiring the FSMO role ownership so
            // that the calling routine will not be blocked with an
            // open transaction. An error code is returned, however,
            // allowing the caller to handle the account-creation
            // failure appropriately, such as retrying the operation
            // or notifying the administrator.

            ASSERT(NULL != RidManager);

            //
            // Ignore the status returned. Do not assign anything to
            // NtStatus at this point
            //

            TempNtStatus = SampRequestRidPoolAsynchronously(RidManager);

        }
    }

    // Errors that could have occurred at this point are failure
    // while attempting to find the current Role Owner or failure
    // attempting to request a new RID pool. Although these oper-
    // ations are distributed and potentially asynchronous, the
    // error returned from these routines will more likely indicate
    // a local failure (such as out of memory, etc.), in which
    // case, do not update the RID Object.

    if ( NT_SUCCESS(NtStatus)  )
    {
        // Update the next-RID and RID-pool-used attributes. The back-
        // ing store is only updated when the in-memory cache has been
        // exhausted. This is done to reduce the number of updates to
        // the store, so that subsequent replication activity is also
        // reduced.


        Flags = RID_NEXT_RID;

        if ( fUpdatePrevPool )
        {
            Flags |= RID_PREV_ALLOC_POOL;
            SampSetRidPoolPrevAlloc(&RidInfo, PrevAllocHigh, PrevAllocLow);
        }


        SampSetRidFlags(&RidInfo, Flags);

        ASSERT(0!=NextRidOnDatabase);

        SampSetRid(&RidInfo, NextRidOnDatabase);

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: Updating the RID object:\n"));
        SampDumpRidInfo(&RidInfo);

        // 
        // Let JET commit lazily
        // 
        NtStatus = SampUpdateRidObject(NewRidObject, &RidInfo, TRUE, FALSE);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampUpdateRidObject status = 0x%lx\n",
                           NtStatus));
        }

    }

    //
    // That's it - fall through
    //

ErrorCase:

    if (DomainContext->LoopbackClient)
    {
        SampMaybeEndDsTransaction(NT_SUCCESS(NtStatus) ? 
                                  TransactionCommit : TransactionAbort);

        SampReleaseSamLockExclusive();

        if (pTHState)
        {
            THRestore( pTHState );
        }

    }
    else
    {
        ASSERT( SampCurrentThreadOwnsLock() );
    }

    //
    // Keep the Transaction Open for further processing by SAM
    //

    if (!NT_SUCCESS(NtStatus) && !AlreadyNotifiedUserOfError )
    {
        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,
                          SAMMSG_GET_NEXT_RID_ERROR,
                          NULL,
                          0,
                          sizeof(NTSTATUS),
                          NULL,
                          (PVOID)(&NtStatus));
    }



    return(NtStatus);
}


//============================================================================
//
//                 Domain RID Initialization/Uninitialization
//
//============================================================================

// The SAM RID initialization and uninitialzation routines are never called
// concurrently on any given DC, so do not need to be protected by the RID
// critical section. These routines are only called in the context of SAM/LSA
// initialization within a single thread.




DWORD
SampSetupRidRegistryKey(
    IN HKEY KeyHandle,
    IN PCHAR ValueName,
    IN OUT PULONG Rid
    )

/*++

Routine Description:

    This routine creates the initial RID-management values in the registry.
    If the values already exist, they are read and returned.

Arguments:

    KeyHandle - Handle, registry RID key.

    ValueName - Pointer, registry value name.

    Rid - Pointer, returned RID value.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    Other registry error codes.

--*/

{
    DWORD Status = ERROR_SUCCESS;
    ULONG ReservedParameter = 0;
    PULONG pReservedParameter = NULL;
    DWORD Type = REG_DWORD;
    ULONG Data = 0;
    ULONG Length = sizeof(DWORD);

    Data = 0;
    Length = sizeof(DWORD);

    // Read the RID value from the registry. If it does not exist, go ahead
    // and slam in a zero value. If it does exist, just return the current
    // value and let the caller figure out whether or not it is valid.

    Status = RegQueryValueExA(KeyHandle,
                              ValueName,
                              pReservedParameter,
                              &Type,
                              (PBYTE)&Data,
                              &Length);

    if (ERROR_SUCCESS != Status)
    {
        Data = 0;
        Length = sizeof(DWORD);

        Status = RegSetValueExA(KeyHandle,
                                ValueName,
                                ReservedParameter,
                                REG_DWORD,
                                (PVOID)&Data,
                                Length);
    }

    *Rid = Data;

    return(Status);
}


VOID
SampInitializeRidRanges(
    OUT PULONG SampMinimumDomainRid,
    OUT PULONG SampMaximumDomainRid,
    OUT PULONG SampRidThreshold,
    OUT PULONG SampRidBlockSize,
    OUT PULONG SampRidCacheSize
    )

/*++

Routine Description:


    NOTE: THIS ROUTINE IS OBSOLETE AND CAN BE REMOVED AFTER SOME TESTING.


    This routine sets up the RID Manager registry keys that contain things
    such as the min/max domain RID values, threshold value, etc. In general,
    this registry key (and its values) are not used by the RID manager--the
    RID manager uses the DS RID objects to read/write these values.

    The purpose of this key and its values are:

    -A hook for administrators so that they can override the DS RID values
     in case of an emergency repair.

    -A hook for testers so that they can set RID ranges and thresholds to
     small values in order to exercise the entire RID management code base.

Arguments:

    SampMinimunDomainRid - Pointer, smallest allowed RID in the domain.

    SampMaximunDomainRid - Pointer, largest allowed RID in the domain.

    SampRidThreshold - Pointer, threshold that when reached triggers a
        request for a new RID pool. If a RID block size is 100, the thres-
        hold set to 20 will mean that a new pool is requested when 80
        RIDs have been consumed via account creation.

    SampRidBlockSize - Pointer, the number of RIDs in the requested alloc-
        ation block.

    SampRidCacheSize - Pointer, the number of RIDs in the in-memory block
        of RIDs. The cache size is typically set to one percent of the
        block size, meaning that the RID attributes (NextRid and UsedRid-
        Pool) on the NTDS-DSA object are only updated after one percent
        of the block has been assigned, thereby reducing the overall number
        of disk writes during account creation. So, if the allocation
        block size is 100,000, the NTDS-DSA object RID attributes are up-
        dated only after each 1,000 account creations.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    Other registry error codes.

--*/

{
    DWORD Status = ERROR_SUCCESS;
    HKEY KeyHandle = INVALID_HANDLE_VALUE;
    CHAR RidConfigSection[256];

    // Initialize RID Manager global data. Globals are used for various RID
    // values so that they can be reset in the debugger or from test apps,
    // registry keys are read/set so that administrators can change the RID
    // values from the registry in a repair or testing situation.
    //
    // First, set the variables to the well-defined values of a healthy DC.
    //
    // Next, create or open the RID registry key (under the NTDS key) and
    // read each of the settings. If the values do not exist (first time set-
    // up), then default zero values are written to the registry. If non-
    // zero values do exist in the registry, then use these values to over-
    // ride the the well-defined values. Reset the variables iff all of the
    // registry key values are there and are valid. Allowing only a subset
    // of the variables to be set from the registry will likely lead to a
    // bogus set of RID values and a messed-up domain controller.
    //
    // Note: If the registry RID values are reset (say for testing purposes)
    // the DC must be rebooted in order for SAM and the RID manager to read
    // and use these new values.
    //
    // Note: If you must mess with the RID values from the registry, here
    // are the guidelines:
    //
    // 1. The minimum RID is the smallest allowed domain RID, and must be
    // greater than or equal to SAMP_MINIMUM_DOMAIN_RID.
    //
    // 2. The maximum RID is the largest allowed domain RID, and must be
    // less than or equal to SAMP_MAXIMUM_DOMAIN_RID. Naturally, it should
    // also be greater than the minimum RID.
    //
    // 3. The RID threshold triggers the action of allocating a new RID pool.
    // This value must be less than the RID block size (see next) and is
    // typically set to be 20% of the block size (i.e. when only 20% of the
    // pool remains, request another).
    //
    // 4. The RID block size is the chunk of RIDs that get allocated when
    // a RID request is made. This value is typically set in the tens of
    // thousands range, and must be larger than the threshold size. Its nicer
    // if the two values are not relatively prime (i.e. have a common divisor
    // greater than one).
    //
    // 5. The RID cache size probably shouldn't (at this time) be changed, so
    // if you want it to work, set it to the same value as SAMP_RID_CACHE_SIZE.

    *SampMinimumDomainRid = SAMP_MINIMUM_DOMAIN_RID;
    *SampMaximumDomainRid = SAMP_MAXIMUM_DOMAIN_RID;
    *SampRidThreshold = SAMP_RID_THRESHOLD;
    *SampRidBlockSize = SAMP_RID_BLOCK_SIZE;
    *SampRidCacheSize = SAMP_RID_CACHE_SIZE;

    sprintf(RidConfigSection, "%s\\RID Values", DSA_CONFIG_ROOT);
    Status = RegCreateKeyA(HKEY_LOCAL_MACHINE, RidConfigSection, &KeyHandle);

    if (ERROR_SUCCESS == Status)
    {
        CHAR MinValueName[] = "Minimum RID";
        CHAR MaxValueName[] = "Maximum RID";
        CHAR RidThreshold[] = "RID Threshold";
        CHAR BlockSize[] = "RID Block Size";
        CHAR CacheSize[] = "RID Cache Size";
        CHAR szCachedNextRid[] = "Cached Next RID";

        ULONG SampMinimumDomainRidTemp = 0;
        ULONG SampMaximumDomainRidTemp = 0;
        ULONG SampRidThresholdTemp = 0;
        ULONG SampRidBlockSizeTemp = 0;
        ULONG SampRidCacheSizeTemp = 0;

        ULONG CachedNextRidTemp = 0;

        Status = SampSetupRidRegistryKey(KeyHandle,
                                          MinValueName,
                                          &SampMinimumDomainRidTemp);

        if (ERROR_SUCCESS != Status)
        {
            goto IgnoreRegistryCase;
        }

        Status = SampSetupRidRegistryKey(KeyHandle,
                                          MaxValueName,
                                          &SampMaximumDomainRidTemp);

        if (ERROR_SUCCESS != Status)
        {
            goto IgnoreRegistryCase;
        }

        Status = SampSetupRidRegistryKey(KeyHandle,
                                          RidThreshold,
                                          &SampRidThresholdTemp);

        if (ERROR_SUCCESS != Status)
        {
            goto IgnoreRegistryCase;
        }

        Status = SampSetupRidRegistryKey(KeyHandle,
                                          BlockSize,
                                          &SampRidBlockSizeTemp);

        if (ERROR_SUCCESS != Status)
        {
            goto IgnoreRegistryCase;
        }

        Status = SampSetupRidRegistryKey(KeyHandle,
                                          CacheSize,
                                          &SampRidCacheSizeTemp);

        if (ERROR_SUCCESS != Status)
        {
            goto IgnoreRegistryCase;
        }

        // CachedNextRid persistently saves the RID cache HWM in case of a
        // system crash with a dirty RID cache. It is always initialized to
        // zero during SAM initialization, and reset as the cache comes into
        // use during account creation (see SampGetNextRid).

        Status = SampSetupRidRegistryKey(KeyHandle,
                                          szCachedNextRid,
                                          &CachedNextRidTemp);

        if (ERROR_SUCCESS != Status)
        {
            goto IgnoreRegistryCase;
        }

        // Verify the values that were returned from the registry, before
        // overriding the well-defined values. The above calls to SampSet-
        // upRidRegistryKeys will set default values to zero when they are
        // created for the first time. If these values are not changed,
        // they will be ignored because the following set of validations
        // will fail until valid values are placed in the registry.

        if (SAMP_MINIMUM_DOMAIN_RID > SampMinimumDomainRidTemp)
        {
            // SampDiagPrint(RID_MANAGER,
            //           ("SAMSS: Invalid minimum RID value [%lu] in registry\n",
            //           SampMinimumDomainRidTemp));

            goto IgnoreRegistryCase;
        }

        if ((SAMP_MAXIMUM_DOMAIN_RID < SampMaximumDomainRidTemp) ||
            (SampMinimumDomainRidTemp >= SampMaximumDomainRidTemp))
        {
            SampDiagPrint(RID_MANAGER,
                      ("SAMSS: Invalid maximum RID value [%lu] in registry\n",
                       SampMaximumDomainRidTemp));

            goto IgnoreRegistryCase;
        }

        if ((0 == SampRidThresholdTemp) ||
            (SAMP_RID_BLOCK_SIZE < SampRidThresholdTemp))
        {
            SampDiagPrint(RID_MANAGER,
                      ("SAMSS: Invalid RID threshold value [%lu] in registry\n",
                       SampRidThresholdTemp));

            goto IgnoreRegistryCase;
        }

        if (0 == SampRidBlockSizeTemp)
        {
            SampDiagPrint(RID_MANAGER,
                      ("SAMSS: Invalid RID block size value [%lu] in registry\n",
                       SampRidBlockSizeTemp));

            goto IgnoreRegistryCase;
        }


        if (SampRidCacheSizeTemp > SampRidBlockSizeTemp)
        {
            SampDiagPrint(RID_MANAGER,
                      ("SAMSS: Invalid RID cache size value [%lu] in registry\n",
                       SampRidCacheSizeTemp));

            goto IgnoreRegistryCase;
        }

        // Override the well-defined RID values iff all registry values are
        // present and valid.

        SampDiagPrint(RID_MANAGER,
            ("SAMSS: Overriding default RID values with registry settings\n"));

        *SampMinimumDomainRid = SampMinimumDomainRidTemp;
        *SampMaximumDomainRid = SampMaximumDomainRidTemp;
        *SampRidThreshold = SampRidThresholdTemp;
        *SampRidBlockSize = SampRidBlockSizeTemp;
        *SampRidCacheSize = SampRidCacheSizeTemp;
    }
    else
    {
        // If the key cannot be created or opened, blow off the registry
        // values and just continue on with the well-defined RID values,
        // as would happen in a normally running system.

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RegCreate/OpenKey status = %lu\n",
                       Status));

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: Cannot access registry key %s\n",
                       RidConfigSection));
    }

IgnoreRegistryCase:

    if ( INVALID_HANDLE_VALUE != KeyHandle )
        RegCloseKey(KeyHandle);

    return;
}

NTSTATUS
SampInitializeRidManager(
    IN PDSNAME RidMgrObject,
    IN PDSNAME DsaObject,
    IN PDSNAME DomainObject,
    OUT BOOLEAN *NewRidManager
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RIDINFO RidMgrInfo;

    RtlZeroMemory(&RidMgrInfo, sizeof(RIDINFO));


    //======================Create the RID Manager Object=====================

    // Find out if the RID Manager exists, create the (new schema) RID
    // Manager object in the System container if it does not exist.

    NtStatus = SampVerifyRidManagerExists(RidMgrObject);

    if ( !NT_SUCCESS(NtStatus) )
    {
        // Create the RID Manager for this DSA (a.k.a. DC). Assume
        // that any unsuccessful error code returned from the read
        // implies that the RID Manager does not exist and needs to
        // be created.

        NtStatus = SampCreateRidManager(RidMgrObject);

        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }

        *NewRidManager = TRUE;

    }

    //======================Initialize RID Manager Object=====================

    // The boot-up sequence initializes the RID Reference, RID Manager, and
    // RID Object with initial, default values. Upon successful completion
    // of this phase, an initial RID pool is obtained from the current RID
    // Manager in the domain. Note that if the objects exist, from a prev-
    // ious session, they are not re-initialized because they must retain
    // previous values.

 
    // Set initial values for the RID Manager. The first NT DC that is
    // upgraded to an NT5 DC will create the RID Manager. In doing so,
    // the RID Manager will start its available RID pool at the current
    // value of the domain's NextRid value. This way, RIDs corresponding
    // to previously created accounts (prior to the upgrade) are preserv-
    // ed.

    if ( *NewRidManager )
    {
        PSAMP_OBJECT DomainContext = NULL;
        ULONG MinimumStartingRid = 0;
        ULONG Length = 0;
        ULONG DomainIndex = 0;


        // Make sure that the "next RID" that the RID manager starts with
        // is the one in the DS Account domain and not the Builtin domain
        // or some other random domain.

        DomainIndex = DOMAIN_START_DS + 1;

        

        MinimumStartingRid = SampDefinedDomains[DomainIndex].UnmodifiedFixed.NextRid;

       


        // Add a "delta" of 100 to the value of NextRid before setting
        // the minimum RID for the domain. Since the upgrade scenarios
        // include NT4 BDC to NT5 DC upgrades, there may be a few ac-
        // counts not yet replicated to this DC at the time of the up-
        // grade. In practice, this should only be a few accounts, so
        // incrementing by the minimum starting RID by 100 should cov-
        // er any latency problems. The Domain Administrator should
        // synchronize the domain controller to the rest of the domain
        // before performing an upgrade to reduce this problem.
        
        MinimumStartingRid += 100;
        ASSERT(SAMP_RESTRICTED_ACCOUNT_COUNT < MinimumStartingRid);

        RtlZeroMemory(&RidMgrInfo, sizeof(RIDINFO));

        // Store the location of the Role Owner in the RID Manager
        // object. This is a one-time initialization, indicating
        // that this is the the first DC in the domain, hence, the
        // first RID Manager of the domain. By default, then, the
        // first DC/DSA in the domain takes the role of the RID
        // Manager (and the DC/DSA is the RoleOwner). Indicate in the
        // flags that the role owner and available pool are being
        // updated.
       

        SampSetRoleOwner(&RidMgrInfo, DsaObject);
        SampSetRidPoolAvailable(&RidMgrInfo,
                                SampMaximumDomainRid,
                                MinimumStartingRid);
        SampSetRidFlags(&RidMgrInfo, RID_ROLE_OWNER | RID_AVAILABLE_POOL);

        NtStatus = SampUpdateRidManager(RidMgrObject,
                                        &RidMgrInfo);

        if ( !NT_SUCCESS( NtStatus ) )
        {
            goto Cleanup;
        }

        //
        // Update the reference to the rid manager
        //
        NtStatus = SampUpdateRidManagerReference(DomainObject,
                                                 RidMgrObject);

        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
    }

Cleanup:

        return(NtStatus);
}


NTSTATUS
SampDomainAsyncRidInitialization(
    PVOID p OPTIONAL
    )
//
// A wrapper for SampDomainRidInitialization, this routine
// is a callback routine for LsaIRegsiterNotification.
//
{
    return(SampDomainRidInitialization(FALSE));

    UNREFERENCED_PARAMETER( p );
}

NTSTATUS
SampDomainRidInitialization(
    IN BOOLEAN fSynchronous
    )

/*++

Routine Description:

    This routine is the initialization procedure for the RID Manager code
    and objects. It is executed whenever a domain controller is booted. In
    order to keep system boot time to a reasonable duration, any lengthy
    operations required during initialization should be started in a new
    thread.

    This routine creates the initial RID-management objects in the DS when
    installing a new domain controller (DC), or reinitializes them if they
    already exist from a prior installation. Because RID management is a
    critical part of a normally functioning DC, failure to initialize RID
    pools correctly will cause SAM, and hence, LSA to return an error code
    from their initialization sequences. Logon will be limited to a local
    Administrator account (presumably enough to repair the DC).

    Note that the terms "DSA" and "DC" are used interchangeably. A DC
    contains one instance of a DSA per hosted domain on that DC--in the
    first product, there is one DSA per DC. In the future, there can be
    several DSA's per DC, each acting as a domain controller for each
    different hosted domain.

    In particular, each DC is represented by one RID Object in the DS. The
    RID Object's distinguished name (DN) is constructed by appending the
    machine DN onto the "RID Set" string.

    When multiple domains are hosted on a single DC, there will be several
    DSA's per DC, hence, the need for several RID Objects per DC--one for
    each DSA's hosted domain.

    Overview of the RID Manager initialization steps:

    1)
    Initialize Globals
    Wait For RPCSS To Start

    2)
    Start a write transaction
    Verify RID Manager Is Not Created On A BDC
    Create the RID Manager Object
    Initialize RID Manager Object
    Initialize RID Manager Reference Object
    Read RID Manager Reference Object
    End transaction

    3)
    Start a write transaction
    Read RID Objects if possible and upgrade if necessary
    End transaction

    4)
    If necessary, request a rid pool ( this may go off the machine )

    5)
    Start a write transaction
    If necessary update local rid object with new rid pool
    End transaction

    6)
    Start read transaction
    Validate RID Objects
    End transaction

    7)
    Log RID Manager Initialization Status

Arguments:

    fSynchronous -- Tells us that the RID manager has been started synchronously
                    at initialization time. Synchronous initialization can successfully
                    complete if no off machine operations are required

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    STATUS_INVALID_PARAMETER if the root name of the domain could not be
        located in the registry.

    Other DS error codes that have been mapped to an NTSTATUS can be returned
    from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    RIDINFO RidInfo;
   
    RIDINFO RidMgrInfoOld;
    RIDINFO RidObjectInfo;

    PDSNAME RidMgrObject = NULL;
    PDSNAME RidObject = NULL;
    PDSNAME Parent = NULL;

    PDSNAME DomainObject = NULL;
    PDSNAME DsaObject    = NULL;

    USHORT VerifyCount = 1;

    BOOLEAN   fRequestNewRidPool = FALSE;
    BOOLEAN   fInitRidManager = FALSE;
    BOOLEAN   fInitRidObject  = FALSE;
    BOOLEAN   fInitialized = FALSE;
    ULONG     Length = 0;
    ULONG     Status = 0;
    DWORD     IgnoreError = 0;

    RIDFLAG   Flags = 0;
    ULONG     DsaLength = 0;
    NTSTATUS  TempNtStatus;

    BOOLEAN   fActiveThread = FALSE;
    BOOLEAN   fTransactionOpen = FALSE;

    SAMTRACE("SampDomainRidInitialization");

    //
    // If we are no longer enabled, return without rescheduling
    //
    if (SampServiceState != SampServiceEnabled) {
        // This shouldn't happen the first time through!
        ASSERT( !fSynchronous );
        return(STATUS_INVALID_SERVER_STATE);
    }

    //
    // Init stack space
    //
    RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
    RtlZeroMemory(&RidMgrInfoOld, sizeof(RIDINFO));
    RtlZeroMemory(&RidObjectInfo, sizeof(RIDINFO));

    if (fSynchronous)
    {
        //
        // The first Time Around initialize the Globals and the critical Section
        //

        //===========================Initialize Globals===========================

        RtlZeroMemory(&CachedRidManagerObject, sizeof(DSNAME));
        CachedRidManagerObject.structLen = DSNameSizeFromLen(0);
        RtlZeroMemory(&CachedRidSetObject, sizeof(DSNAME));
        CachedRidSetObject.structLen = DSNameSizeFromLen(0);



        // CachedNextRid holds the in-memory value of the "next RID". It is ref-
        // erenced, while the size of SampCachedRidsLeft is greater than zero, in-
        // stead of updating the backing store for each RID assignment.

        CachedNextRid = 0;
        SampCachedRidsLeft = 0;

        // This call provides a registry-based override to the defaul RID para-
        // meter sizes. The registry values can be "tuned" for testing, admini-
        // strator configuration, etc. If the registry keys are not present or
        // their values are zero, they are not used, and the default constant
        // values are used instead (see ridmgr.h)

        SampInitializeRidRanges(&SampMinimumDomainRid,
                                &SampMaximumDomainRid,
                                &SampRidThreshold,
                                &SampRidBlockSize,
                                &SampRidCacheSize);

        SampRidManagerInitialized = FALSE;
        SampDcRidRequestPending = FALSE;

        // Define a critical section to synchronize access to RID Manager global
        // data.

        RidMgrCritSect = &RidMgrCriticalSection;

        __try
        {
            InitializeCriticalSection(RidMgrCritSect);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        // If critical section initialization failed then return error.
        if (!NT_SUCCESS(NtStatus))
        {
            return (NtStatus);
        }
    }

    //
    // Increment the active thread count if we are being called in the 
    // background
    //
    if (!fSynchronous)
    {
        SampIncrementActiveThreads();
        fActiveThread = TRUE;
    }
  
    //
    // Prepare the dsname for the well known location of the rid manager
    // object
    //
  
    Length = 0;
    DomainObject = NULL;
    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                    &Length,
                                    DomainObject);

    if ( NtStatus == STATUS_BUFFER_TOO_SMALL)
    {
        SAMP_ALLOCA(DomainObject,Length);
        if (NULL==DomainObject)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                        &Length,
                                        DomainObject);

    }

    if ( !NT_SUCCESS(NtStatus) )
    {
        goto Cleanup;
    }


    Length = (ULONG)DSNameSizeFromLen( DomainObject->NameLen + 
                                       wcslen(SYSTEM_W) + 
                                       4 );

    SAMP_ALLOCA(Parent,Length );
    if (NULL==Parent)
    {
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
       goto Cleanup;
    }
      
    RtlZeroMemory(Parent, Length);

    Status = AppendRDN(DomainObject,
                       Parent,
                       Length,
                       SYSTEM_W,
                       0,
                       ATT_COMMON_NAME);


    Length = (ULONG)DSNameSizeFromLen( Parent->NameLen + 
                                       wcslen(RID_MGR_W) +
                                       4);

    SAMP_ALLOCA(RidMgrObject,Length );
    if (NULL==RidMgrObject)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(RidMgrObject, Length);

    Status = AppendRDN(Parent,
                       RidMgrObject,
                       Length, 
                       RID_MGR_W,
                       0,
                       ATT_COMMON_NAME);


    //
    // The attempt to create rid objects and their associated references is
    // retried until success. All the object creations are performed in a 
    // single transaction.
    //

    //============== Get NTDS Setting DN  ==========================
    //    Need to read NTDS Setting DN each every time in the loop
    //    otherwise, if the server moved sites before rid manager
    //    has been initialized, we will loop forever
    //==============================================================

    DsaLength = 0;
    DsaObject = NULL;
    NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                    &DsaLength,
                                    DsaObject);

    if ( NtStatus == STATUS_BUFFER_TOO_SMALL)
    {
        //
        // Allocate Memory from Heap instead of stack.
        //
        DsaObject = (PDSNAME) RtlAllocateHeap(RtlProcessHeap(), 0, DsaLength);

        if (NULL == DsaObject)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            RtlZeroMemory(DsaObject, DsaLength);

            NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                            &DsaLength,
                                            DsaObject);
        }
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //============== Create a transaction for the rid mgr initialization ==

    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }
    fTransactionOpen = TRUE;


    //
    // Initialize the RID manager object , the object is created if it does
    // not exist and the initial available RID pool is set on it.
    //

    NtStatus = SampInitializeRidManager(
                        RidMgrObject,
                        DsaObject,
                        DomainObject,
                        &fInitRidManager
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //===================Create New and Read Old RID Objects==================
    // Read the RID Object if it exists. The RID
    // object contains the RID pools for this DC (one pool for each hosted
    // domain.

    //
    // If the RID object does not exist, then it will be created when
    // we request an initial rid pool.
    //
    Flags = (RID_ALLOCATED_POOL |
             RID_PREV_ALLOC_POOL |
             RID_USED_POOL |
             RID_NEXT_RID);
    SampSetRidFlags(&RidObjectInfo, Flags);

    NtStatus = SampObtainRidInfo( DsaObject,
                                 &RidObject,
                                 &RidObjectInfo  );
    if ( NT_SUCCESS( NtStatus ) )
    {
        //
        // The RID set object exists
        // Let's see what shape our rid pool is in and
        // determine what sort of initialiazation needs
        // to be done
        //
        if ( RidObjectInfo.NextRid == 0 )
        {
            //
            // This should be a completely fresh rid object.
            // This can happend when the rid pool has been
            // invalided, or when we obtained a rid pool,
            // but failed to update our local information
            //

           fRequestNewRidPool = TRUE;
        }
    }
        
    else if ( (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
           || (NtStatus == STATUS_DS_NO_ATTRIBUTE_OR_VALUE) )
    {
        //
        // The rid object could not be found, the process of
        // acquiring a new RID pool will result in us obtaining
        // a new RID set object.
        //
        fInitRidObject = TRUE;
        NtStatus = STATUS_SUCCESS;
    }

    //
    // Clean up transactions
    //

    TempNtStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                              TransactionCommit :
                                              TransactionAbort );

    fTransactionOpen = FALSE;

    if ( NT_SUCCESS( NtStatus ) && !NT_SUCCESS( TempNtStatus ) )
    {
        NtStatus = TempNtStatus;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

   
    //=======================Request An Initial RID Pool======================

    
    //
    // Request a RID pool if we either created a rid manager, or needed to
    // create a RID set , or if we found that our current pool was empty
    // In the last 2 cases do not go off machine to obtain a rid pool if 
    // this is the main initialization thread ( fSynchronous set to true )
    //

    if ((fInitRidManager) || 
        (!fSynchronous && fInitRidObject ) || 
        (!fSynchronous && fRequestNewRidPool))
    {
        //
        // If we need a rid pool and this is not the case of the first
        // DC in the domain starting up, then we most probably need to
        // go off machine for the rid pool. Return a failure if this is
        // the mainline init thread, so that this task is spawned again
        // in the background.
        //

     
        
        SampDcRidRequestPending = TRUE;

        NtStatus = SampRequestRidPool(
                        RidMgrObject,
                        FALSE
                        );
        if (!NT_SUCCESS(NtStatus))
        {
           goto Cleanup;
        }
    }
    else if ((fInitRidObject || fRequestNewRidPool) && fSynchronous)
    {
        //
        // Needing to get a RID pool and go off machine for that , 
        // but mainline initialization thread. Return a failure , and
        // the initialization will be retried in the background
        //

        NtStatus = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    //
    // If we are here, the RID set object has been created, we have
    // a RID pool etc
    //


    //
    // Begin a transaction
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }
    fTransactionOpen = TRUE;

    //
    // Read the Rid Set object
    //

    NtStatus = SampObtainRidInfo( DsaObject,
                                 &RidObject,
                                 &RidObjectInfo  
                                 );

    if (!NT_SUCCESS(NtStatus))
    {
       goto Cleanup;
    }
    

    //
    // Register the object with base DS to ensure that it is
    // not deleted
    //

    IgnoreError = DirProtectEntry(RidObject);
    
    //
    // Maintain the GUID of the cached RID manager object in memory
    // This speeds up further references to the RID manager object
    //

    RtlCopyMemory(&CachedRidManagerObject.Guid,
                  &RidMgrObject->Guid,
                  sizeof(GUID)
                 );
    //
    // Maintain the GUID of the RID set object in memory
    // This speeds up further references to the RID set object
    //

    RtlCopyMemory(&CachedRidSetObject.Guid,
                  &RidObject->Guid,
                  sizeof(GUID));

    //
    // Tell the DS to callback when the global rid pool changes
    // so that we can make sure our rid pool is always a subset
    // of the global rid pool.
    //

    NtStatus = SampSetupRidPoolNotification( RidMgrObject );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // We have a valid rid pool
    //
    SampRidManagerInitialized = TRUE;

Cleanup:

    if (DsaObject)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, DsaObject);
        DsaObject = NULL;
    }

    //
    // Close all open transactions.
    //
    if (fTransactionOpen) {

        SampMaybeEndDsTransaction(NT_SUCCESS(NtStatus) ?
                                  TransactionCommit :
                                  TransactionAbort);
    }

    if (fActiveThread) {

        SampDecrementActiveThreads();
    }

    // 
    // Reschedule as necessary
    //
    if ( !NT_SUCCESS(NtStatus) ) {

        PVOID fRet = NULL;

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampDomainRidInitialization status = 0x%lx; rescheduling\n",
                   NtStatus));

        do {

            //
            // LsaIRegisterNotification can fail on resource errors
            // keep retrying until it succeeds
            //
            fRet = LsaIRegisterNotification(
                    SampDomainAsyncRidInitialization,
                    NULL,
                    NOTIFIER_TYPE_INTERVAL,
                    0,           // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    30,          // wait for 30 seconds
                    NULL         // no handle
                    );

            if ( !fRet ) {
                // Wait one minute before retry
                WaitForSingleObject(SampAboutToShutdownEventHandle,60000);
            }

        } while ( !fRet && (SampServiceState == SampServiceEnabled));

    } else {

        // We should be fully initialized
        ASSERT( TRUE ==  SampRidManagerInitialized );


    }


    return( NtStatus );

}



NTSTATUS
SampDomainRidUninitialization(
    VOID
    )

/*++

Routine Description:

    This routine un-initializes various RID Manager data and releases re-
    sources, such as critical sections, back to the OS.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampDomainRidUninitialization");

    DeleteCriticalSection(RidMgrCritSect);

    return(NtStatus);
}

BOOL
SampNotifyPrepareToImpersonate(
    ULONG Client,
    ULONG Server,
    VOID **ImpersonateData
    )
//
// This function is called by the core DS as preparation for a call to
// SampNotifyProcessRidManagerDelta.  Since SAM does not have a
// client context, we set the thread state fDSA to TRUE.
//
{
    SampSetDsa( TRUE );

    return TRUE;
}

VOID
SampNotifyStopImpersonation(
    ULONG Client,
    ULONG Server,
    VOID *ImpersonateData
    )
//
// Called after SampNotifyProcessRidManagerDelta, this function
// undoes the effect of SampNotifyPrepareToImpersonate
//
{

    SampSetDsa( FALSE );

    return;
}

VOID
SampNotifyProcessRidManagerDelta(
    ULONG hClient,
    ULONG hServer,
    ENTINF *EntInf
    )
/*++

Routine Description:

    This callback is used when the global rid manager object is changed.
    This function compares our local rid pool with the current rid pool
    to make sure the former is a subset of the latter; if not, the current
    rid pool is invalidated.

Arguments:

    hClient - ignored
    hServer - ignored
    EntInf  - the pointer to the rid manager data

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PDSNAME  RidObject = NULL;
    ULONG    Flags = 0;

    RIDINFO  RidInfo;
    ULARGE_INTEGER  RidPoolAvailable;

    BOOL     fFoundRidPool = FALSE;
    BOOL     fLockAcquired = FALSE;
    BOOL     fTransaction  = FALSE;
    BOOL     fUpdateRidObject = FALSE;

    THSTATE  *pTHSSave = NULL;

    ULONG    i;

    // Parameter check
    ASSERT( EntInf );

    RtlZeroMemory( &RidInfo, sizeof(RidInfo) );
    RtlZeroMemory( &RidPoolAvailable, sizeof(RidPoolAvailable) );

    //
    // N.B. This function is called with a read transaction
    //
    pTHSSave = THSave();

    // Grab the SAM lock in case we have to update the rid pool information
    // so to avoid a write conflict
    SampAcquireReadLock();
    fLockAcquired = TRUE;

    // Start a transaction
    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampMaybeBeginTransaction failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }
    fTransaction = TRUE;

    //
    // Get the local rid pool
    //
    Flags = ( RID_ALLOCATED_POOL | RID_PREV_ALLOC_POOL );
    SampSetRidFlags(&RidInfo, Flags);

    NtStatus = SampObtainRidInfo( NULL,
                                 &RidObject,
                                 &RidInfo );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampObtainRidInfo failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Extract the available (global) rid pool
    //
    for ( i = 0; i < EntInf->AttrBlock.attrCount; i++)
    {
        ATTR *Attr = &EntInf->AttrBlock.pAttr[i];

        if ( Attr->attrTyp == ATT_RID_AVAILABLE_POOL )
        {
            ASSERT( Attr->AttrVal.valCount == 1 );
            RidPoolAvailable = *(ULARGE_INTEGER *)(Attr->AttrVal.pAVal[0].pVal);
            fFoundRidPool = TRUE;
        }
    }

    if ( !fFoundRidPool )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RidPool not returned with notification.\n"));

        goto Cleanup;
    }

    //
    // Now for some logic
    //
    if (  (RidInfo.RidPoolPrevAlloc.LowPart > RidPoolAvailable.HighPart)
       || (RidInfo.RidPoolPrevAlloc.HighPart > RidPoolAvailable.HighPart) )
    {
        SampSetRidPoolPrevAlloc( &RidInfo, 0, 0 );
        fUpdateRidObject = TRUE;
    }

    if (  (RidInfo.RidPoolAllocated.LowPart > RidPoolAvailable.HighPart)
       || (RidInfo.RidPoolAllocated.HighPart > RidPoolAvailable.HighPart) )
    {

        SampSetRidPoolAllocated( &RidInfo, 0, 0 );
        fUpdateRidObject = TRUE;
    }

    if ( fUpdateRidObject )
    {
        //
        // This assert is here to trap cases where we have to invalidate
        // the rid pool.  This should _only_ be in extreme backup and restore.
        // scenarios.  It is harmless to ignore since we recover. However, we
        // obviously lose some RID's forever.
        //
        ASSERT( FALSE && "Invalidating rid pool" );

        NtStatus = SampUpdateRidObject( RidObject,
                                        &RidInfo,
                                        FALSE, // commit immediately
                                        FALSE  // not authoritative
                                       );

        if ( !NT_SUCCESS( NtStatus ) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Update to invalidate rid pool failed\n"));

            goto Cleanup;
        }
    }

    //
    // That's it - fall through to cleanup;
    //

Cleanup:

    if ( fTransaction )
    {
        NtStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ? TransactionCommit : TransactionAbort );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Commit to invalidate rid pool failed 0x%x\n",
                       NtStatus));

            // Ignore error;
        }
    }

    if ( fLockAcquired )
    {
        SampReleaseReadLock();
    }

    if ( pTHSSave )
    {
        THRestore( pTHSSave );
    }

    return;
}


NTSTATUS
SampSetupRidPoolNotification(
    PDSNAME RidManagerObject
    )
/*++

Routine Description:

    This routine tells the DS to notify us when the rid manager object
    changes so we can verify that our local rid pool is a subset of the global
    rid pool.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DirError = 0;

    SEARCHARG   searchArg;
    NOTIFYARG   notifyArg;
    NOTIFYRES*  notifyRes = NULL;
    ENTINFSEL   entInfSel;
    ATTR        attr;
    FILTER      filter;

    // Parameter check
    ASSERT( RidManagerObject );

    //
    // init notify arg
    //
    notifyArg.pfPrepareForImpersonate = SampNotifyPrepareToImpersonate;
    notifyArg.pfTransmitData = SampNotifyProcessRidManagerDelta;
    notifyArg.pfStopImpersonating = SampNotifyStopImpersonation;
    notifyArg.hClient = 0;

    //
    // init search arg
    //
    ZeroMemory(&searchArg, sizeof(SEARCHARG));
    ZeroMemory(&entInfSel, sizeof(ENTINFSEL));
    ZeroMemory(&filter, sizeof(FILTER));
    ZeroMemory(&attr, sizeof(ATTR));

    searchArg.pObject = RidManagerObject;

    InitCommarg(&searchArg.CommArg);
    searchArg.choice = SE_CHOICE_BASE_ONLY;
    searchArg.bOneNC = TRUE;

    searchArg.pSelection = &entInfSel;
    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    entInfSel.AttrTypBlock.attrCount = 1;
    entInfSel.AttrTypBlock.pAttr = &attr;
    attr.attrTyp = ATT_RID_AVAILABLE_POOL;

    searchArg.pFilter = &filter;
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_TRUE;

    DirError = DirNotifyRegister(&searchArg, &notifyArg, &notifyRes);

    if ( DirError != 0 ) {

        NtStatus = SampMapDsErrorToNTStatus(DirError, &notifyRes->CommRes);
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: DirNotifyRegister init failed with 0x%x\n",
                    NtStatus ));
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\server.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    server.c

Abstract:

    This file contains services related to the SAM "server" object.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    08-Oct-1996 ChrisMay
        Added crash-recovery code.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dnsapi.h>
#include <samtrace.h>
#include <dslayer.h>
#include <attids.h>





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SamrConnect4(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ULONG ClientRevision,
    IN ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    See SamrConnect3.
    
    N.B.  This routine is here just so a particular NT4 samlib.dll can
    connect to an NT5 samsrv.dll.  This particular samsrv.dll is used by
    Boeing and when it was delivered to them, the dll mistakenly had
    an extra RPC function which now causes interoperability problems.
    
    This extra function solves this problem.

Arguments:

    See SamrConnect3.

Return Value:

    See SamrConnect3.


--*/
{
    return SamrConnect3( ServerName,
                         ServerHandle,
                         ClientRevision,
                         DesiredAccess );

}

NTSTATUS
SamrConnect3(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ULONG ClientRevision,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This service is the dispatch routine for SamConnect.  It performs
    an access validation to determine whether the caller may connect
    to SAM for the access specified.  If so, a context block is established.
    This is different from the SamConnect call in that the entire server
    name is passed instead of just the first character.


Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    DesiredAccess - Specifies the accesses desired to the SERVER object.


Return Value:

    Status values returned by SamIConnect().


--*/
{
    BOOLEAN TrustedClient;

    SAMTRACE("SamrConnect3");

    //
    // If we ever want to support trusted remote clients, then the test
    // for whether or not the client is trusted can be made here and
    // TrustedClient set appropriately.  For now, all remote clients are
    // considered untrusted.

    

    TrustedClient = FALSE;


    return SampConnect(
                ServerName, 
                ServerHandle, 
                ClientRevision,
                DesiredAccess, 
                TrustedClient, 
                FALSE, 
                TRUE,          // NotSharedByMultiThreads
                FALSE
                );

}



NTSTATUS
SamrConnect2(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This service is the dispatch routine for SamConnect.  It performs
    an access validation to determine whether the caller may connect
    to SAM for the access specified.  If so, a context block is established.
    This is different from the SamConnect call in that the entire server
    name is passed instead of just the first character.


Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    DesiredAccess - Specifies the accesses desired to the SERVER object.


Return Value:

    Status values returned by SamIConnect().


--*/
{
    BOOLEAN TrustedClient;

    SAMTRACE("SamrConnect2");

    //
    // If we ever want to support trusted remote clients, then the test
    // for whether or not the client is trusted can be made here and
    // TrustedClient set appropriately.  For now, all remote clients are
    // considered untrusted.

    TrustedClient = FALSE;


    return SampConnect(
                ServerName, 
                ServerHandle, 
                SAM_CLIENT_PRE_NT5, 
                DesiredAccess, 
                TrustedClient, 
                FALSE,
                TRUE,          // NotSharedByMultiThreads
                FALSE
                );

}


NTSTATUS
SamrConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This service is the dispatch routine for SamConnect.  It performs
    an access validation to determine whether the caller may connect
    to SAM for the access specified.  If so, a context block is established


Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine. The name contains only a single character.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    DesiredAccess - Specifies the accesses desired to the SERVER object.


Return Value:

    Status values returned by SamIConnect().


--*/
{
    BOOLEAN TrustedClient;

    SAMTRACE("SamrConnect");


    //
    // If we ever want to support trusted remote clients, then the test
    // for whether or not the client is trusted can be made here and
    // TrustedClient set appropriately.  For now, all remote clients are
    // considered untrusted.

    
    TrustedClient = FALSE;

    return SampConnect(
                NULL, 
                ServerHandle, 
                SAM_CLIENT_PRE_NT5,
                DesiredAccess, 
                TrustedClient, 
                FALSE,
                TRUE,          // NotSharedByMultiThreads
                FALSE
                );

}

NTSTATUS
SamIConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN     TrustedClient
    )

/*++

Routine Description:

    This service is the in process SAM connect routine  It performs
    an access validation to determine whether the caller may connect
    to SAM for the access specified.  If so, a context block is established


Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine. The name contains only a single character.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    TrustedClient - Indicates that the caller is a trusted client.

    DesiredAccess - Specifies the accesses desired to the SERVER object.


Return Value:

    Status values returned by SampConnect().


--*/
{
  
    SAMTRACE("SamIConnect");

    return SampConnect(NULL, 
                       ServerHandle, 
                       SAM_CLIENT_LATEST,
                       DesiredAccess, 
                       TrustedClient, 
                       FALSE, 
                       FALSE,        // NotSharedByMultiThreads
                       FALSE 
                       );

}




NTSTATUS
SampConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ULONG       ClientRevision,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN NotSharedByMultiThreads,
    IN BOOLEAN InternalCaller
    )

/*++

Routine Description:

    This service is the dispatch routine for SamConnect.  It performs
    an access validation to determine whether the caller may connect
    to SAM for the access specified.  If so, a context block is established


    NOTE: If the caller is trusted, then the DesiredAccess parameter may
          NOT contain any Generic access types or MaximumAllowed.  All
          mapping must be done by the caller.

Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    DesiredAccess - Specifies the accesses desired to the SERVER object.

    TrustedClient - Indicates whether the client is known to be part of
        the trusted computer base (TCB).  If so (TRUE), no access validation
        is performed and all requested accesses are granted.  If not
        (FALSE), then the client is impersonated and access validation
        performed against the SecurityDescriptor on the SERVER object.

    LoopbackClient - Indicates that the caller is a loopback client. If 
        so (TRUE), SAM lock will not be acquired. If not (FALSE), we will 
        grab SAM lock.

    NotSharedByMultiThread - Indicates that the ServerHandle would be 
        Shared by multiple threads or not. RPC clients will not share SAM handle.
        Only in process client (netlogon, lsa, kerberos) will have a global 
        ServerHandle or domain handle shared across multiple callers.

    InternalCaller - Indicates that the client is an internal caller that
                     

Return Value:


    STATUS_SUCCESS - The SERVER object has been successfully openned.

    STATUS_INSUFFICIENT_RESOURCES - The SAM server processes doesn't
        have sufficient resources to process or accept another connection
        at this time.

    Other values as may be returned from:

            NtAccessCheckAndAuditAlarm()


--*/
{
    NTSTATUS            NtStatus;
    PSAMP_OBJECT        Context;
    BOOLEAN             fLockAcquired = FALSE;
    BOOLEAN             fAcquireLockAttemp = FALSE;

    UNREFERENCED_PARAMETER( ServerName ); //Ignored by this routine

    SAMTRACE_EX("SamIConnect");

    //
    // If the SAM server is not initialized, reject the connection.
    //

    if ((SampServiceState != SampServiceEnabled) && (!InternalCaller )){

        return(STATUS_INVALID_SERVER_STATE);
    }

    //
    // Do WMI start type event trace 
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidConnect
                   );

    //
    // Create the server context
    // we don't use DomainIndex field in Server Object, so 
    // feel free to use any thing - SampDsGetPrimaryDomainStart();
    // or in the future, find the correct domain index to support multiple 
    // hosted domain.
    // 

    Context = SampCreateContextEx(SampServerObjectType, // type
                                  TrustedClient,        // trusted client
                                  SampUseDsData,        // ds mode
                                  NotSharedByMultiThreads, // NotSharedByMultiThreads
                                  LoopbackClient,       // LoopbackClient
                                  FALSE,                // laze commit
                                  FALSE,                // persis across calls
                                  FALSE,                // Buffer writes
                                  FALSE,                // Opened By DCPromo
                                  SampDsGetPrimaryDomainStart() // DomainIndex 
                                  );

    if (Context != NULL) {

        //
        // Grab SAM lock if necessary
        // 

        SampMaybeAcquireReadLock(Context, 
                                 DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                                 &fLockAcquired);
        fAcquireLockAttemp = TRUE;

        if (SampUseDsData)
        {
            SetDsObject(Context);

            // 
            // Windows 2000 and Whistler support only a single domain to 
            // be hosted on a DC. Future releases may host more than 1 domain.
            // Add Logic Here for figuring out which Domain to connect to
            // for multiple hosted domain support.
            //

            Context->ObjectNameInDs = SampServerObjectDsName;

            NtStatus = SampMaybeBeginDsTransaction( TransactionRead );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }
        else
        {


            //
            // The RootKey for a SERVER object is the root of the SAM database.
            // This key should not be closed when the context is deleted.
            //

            Context->RootKey = SampKey;
        }

        //
        // Set the Client Revision
        //

        Context->ClientRevision = ClientRevision;


        //
        // The rootkeyname has been initialized to NULL inside CreateContext.
        //

        //
        // Perform access validation ...
        //

        NtStatus = SampValidateObjectAccess(
                       Context,                 //Context
                       DesiredAccess,           //DesiredAccess
                       FALSE                    //ObjectCreation
                       );



        //
        // if we didn't pass the access test, then free up the context block
        // and return the error status returned from the access validation
        // routine.  Otherwise, return the context handle value.
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampDeleteContext( Context );
        } else {
            (*ServerHandle) = Context;
        }

    } else {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

Error: 

    if (SampUseDsData)
    {
        SampMaybeEndDsTransaction(TransactionCommit);
    }

    if (fAcquireLockAttemp)
    {
        SampMaybeReleaseReadLock( fLockAcquired );
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    //
    // Do a WMI end type event trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidConnect
                   );

    return(NtStatus);

}

NTSTATUS
SamILoopbackConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE * ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    )

/*++

Routine Description:

    This service is does the connect operation for DS loopback.
    It calls SampConnect setting the trusted bit and loopback client


Arguments:

    ServerName - Name of the node this SAM reside on.  Ignored by this
        routine. The name contains only a single character.

    ServerHandle - If the connection is successful, the value returned
        via this parameter serves as a context handle to the openned
        SERVER object.

    DesiredAccess - Specifies the accesses desired to the SERVER object.

    TrusteClient - Flag indicating trusted client status.  Used to bypass
        certain validation checks - eg: group member validation during 
        adds for cross domain move.

Return Value:

    Status values returned by SamIConnect().


--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    SAMTRACE_EX("SamLoopbackConnect");

    //
    // Call SampConnect as trusted client, as we wish to avoid
    // the access ck on the SAM server object.
    //
    // Call SampConnect as loopback client, as we don't need the lock
    // 
    NtStatus = SampConnect(NULL,                // Server Name
                           ServerHandle,        // return Server Handle 
                           SAM_CLIENT_LATEST,   // Client Revision
                           DesiredAccess,       // DesiredAccess
                           TRUE,                // Trusted Client
                           TRUE,                // Loopback Client
                           TRUE,                // NotSharedByMultiThreads 
                           FALSE                // Internal Caller
                           );

    if (NT_SUCCESS(NtStatus))
    {
        ((PSAMP_OBJECT) (*ServerHandle))->TrustedClient = TrustedClient;
        ((PSAMP_OBJECT) (*ServerHandle))->LoopbackClient = TRUE;
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return (NtStatus);
}


NTSTATUS
SamrShutdownSamServer(
    IN SAMPR_HANDLE ServerHandle
    )

/*++

Routine Description:

    This service shuts down the SAM server.

    In the long run, this routine will perform an orderly shutdown.
    In the short term, it is useful for debug purposes to shutdown
    in a brute force un-orderly fashion.

Arguments:

    ServerHandle - Received from a previous call to SamIConnect().

Return Value:

    STATUS_SUCCESS - The services completed successfully.


    STATUS_ACCESS_DENIED - The caller doesn't have the appropriate access
        to perform the requested operation.


--*/
{

    NTSTATUS            NtStatus, IgnoreStatus;
    PSAMP_OBJECT        ServerContext;
    SAMP_OBJECT_TYPE    FoundType;

    SAMTRACE_EX("SamrShutdownSamServer");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidShutdownSamServer
                   );

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }

    //
    // Validate type of, and access to server object.
    //

    ServerContext = (PSAMP_OBJECT)ServerHandle;
    NtStatus = SampLookupContext(
                   ServerContext,
                   SAM_SERVER_SHUTDOWN,            // DesiredAccess
                   SampServerObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {


        //
        // Signal the event that will cut loose the main thread.
        // The main thread will then exit - causing the walls to
        // come tumbling down.
        //

        IgnoreStatus = RpcMgmtStopServerListening(0);
        ASSERT(NT_SUCCESS(IgnoreStatus));



        //
        // De-reference the server object
        //

        IgnoreStatus = SampDeReferenceContext( ServerContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the write lock and roll-back the transaction
    //

    IgnoreStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidShutdownSamServer
                   );

    return(NtStatus);

}


NTSTATUS
SamrLookupDomainInSamServer(
    IN SAMPR_HANDLE ServerHandle,
    IN PRPC_UNICODE_STRING Name,
    OUT PRPC_SID *DomainId
    )

/*++

Routine Description:

    This service

Arguments:

    ServerHandle - A context handle returned by a previous call
    to SamConnect().

    Name - contains the name of the domain to look up.

    DomainSid - Receives a pointer to a buffer containing the SID of
        the domain.  The buffer pointed to must be deallocated by the
        caller using MIDL_user_free() when no longer needed.


Return Value:


    STATUS_SUCCESS - The services completed successfully.

    STATUS_ACCESS_DENIED - The caller doesn't have the appropriate access
        to perform the requested operation.

    STATUS_NO_SUCH_DOMAIN - The specified domain does not exist at this
        server.


    STATUS_INVALID_SERVER_STATE - Indicates the SAM server is currently
        disabled.




--*/
{

    NTSTATUS                NtStatus, IgnoreStatus;
    PSAMP_OBJECT            ServerContext;
    SAMP_OBJECT_TYPE        FoundType;
    ULONG                   i, SidLength;
    BOOLEAN                 DomainFound;
    BOOLEAN                 fLockAcquired = FALSE;
    PSID                    FoundSid;
    ULONG                   DomainStart;
    WCHAR                   *NullTerminatedName = NULL;

    SAMTRACE_EX("SamrLookupDomainInSamServer");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidLookupDomainInSamServer
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (DomainId != NULL);
    ASSERT ((*DomainId) == NULL);

    if (!(Name->Length>0 && NULL!=Name->Buffer))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);

        goto Error;
    }



    //
    // The name passed in may not be null terminated
    //


    NullTerminatedName  = MIDL_user_allocate(Name->Length+sizeof(WCHAR));
    if (NULL==NullTerminatedName)
    {
        NtStatus = STATUS_NO_MEMORY;
        SAMTRACE_RETURN_CODE_EX(NtStatus);

        goto Error;
    }

    RtlCopyMemory(NullTerminatedName,Name->Buffer,Name->Length);

    //
    // NULL terminate the name
    //

    NullTerminatedName[Name->Length/sizeof(WCHAR)] = 0;


    //
    // Acquire Read lock if necessary
    // 

    ServerContext = (PSAMP_OBJECT)ServerHandle;
    SampMaybeAcquireReadLock(ServerContext, 
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // If Product Type is DC, and not recovering from a crash, then use
    // DS-based domains information, otherwise fall back to the registry.
    //

    DomainStart = SampDsGetPrimaryDomainStart();



    //
    // Validate type of, and access to object.
    //

    NtStatus = SampLookupContext(
                   ServerContext,
                   SAM_SERVER_LOOKUP_DOMAIN,
                   SampServerObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {



        //
        // Set our default completion status
        //

        NtStatus = STATUS_NO_SUCH_DOMAIN;


        //
        // Search the list of defined domains for a match.
        //

        DomainFound = FALSE;
        for (i = DomainStart;
             (i<SampDefinedDomainsCount && (!DomainFound));
             i++ ) {

             if (
                    (RtlEqualDomainName(&SampDefinedDomains[i].ExternalName, (PUNICODE_STRING)Name) )
                    || ((NULL!=SampDefinedDomains[i].DnsDomainName.Buffer) &&
                         (DnsNameCompare_W(SampDefinedDomains[i].DnsDomainName.Buffer, NullTerminatedName)))
                ) {


                 DomainFound = TRUE;


                 //
                 // Allocate and fill in the return buffer
                 //

                SidLength = RtlLengthSid( SampDefinedDomains[i].Sid );
                FoundSid = MIDL_user_allocate( SidLength );
                if (FoundSid != NULL) {
                    NtStatus =
                        RtlCopySid( SidLength, FoundSid, SampDefinedDomains[i].Sid );

                    if (!NT_SUCCESS(NtStatus) ) {
                        MIDL_user_free( FoundSid );
                        NtStatus = STATUS_INTERNAL_ERROR;
                    }

                    (*DomainId) = FoundSid;
                }
                else
                {

                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
             }

        }



        //
        // De-reference the  object
        //

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SampDeReferenceContext( ServerContext, FALSE );

        } else {

            IgnoreStatus = SampDeReferenceContext( ServerContext, FALSE );
        }
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);

    //
    // Free the null terminated name
    //

    if (NULL!=NullTerminatedName)
        MIDL_user_free(NullTerminatedName);

    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidLookupDomainInSamServer
                   );

    return(NtStatus);
}


NTSTATUS
SamrEnumerateDomainsInSamServer(
    IN SAMPR_HANDLE ServerHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This API lists all the domains defined in the account database.
    Since there may be more domains than can fit into a buffer, the
    caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires SAM_SERVER_ENUMERATE_DOMAINS access to the
    SamServer object.

Arguments:

    ConnectHandle - Handle obtained from a previous SamConnect call.

    EnumerationContext - API specific handle to allow multiple calls
        (see below).  This is a zero based index.

    Buffer - Receives a pointer to the buffer where the information
        is placed.  The information returned is contiguous
        SAM_RID_ENUMERATION data structures.  However, the
        RelativeId field of each of these structures is not valid.
        This buffer must be freed when no longer needed using
        SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no addition entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have the access required
        to enumerate the domains.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_SERVER_STATE - Indicates the SAM server is
        currently disabled.



--*/
{
    NTSTATUS                    NtStatus, IgnoreStatus;
    ULONG                       i;
    PSAMP_OBJECT                Context = NULL;
    SAMP_OBJECT_TYPE            FoundType;
    ULONG                       TotalLength = 0;
    ULONG                       NewTotalLength;
    PSAMP_ENUMERATION_ELEMENT   SampHead, NextEntry, NewEntry;
    BOOLEAN                     LengthLimitReached = FALSE;
    PSAMPR_RID_ENUMERATION      ArrayBuffer;
    ULONG                       ArrayBufferLength;
    ULONG                       DsDomainStart = SampDsGetPrimaryDomainStart();
    BOOLEAN                     fLockAcquired = FALSE;

    SAMTRACE_EX("SamrEnumerateDomainsInSamServer");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidEnumerateDomainsInSamServer
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (ServerHandle != NULL);
    ASSERT (EnumerationContext != NULL);
    ASSERT (  Buffer  != NULL);
    ASSERT ((*Buffer) == NULL);
    ASSERT (CountReturned != NULL);


    //
    // Initialize the list of names being returned.
    // This is a singly linked list.
    //

    SampHead = NULL;


    //
    // Initialize the count returned
    //

    (*CountReturned) = 0;



    //
    // Acquire Read Lock if neccessary
    // 

    Context = (PSAMP_OBJECT)ServerHandle;
    SampMaybeAcquireReadLock(Context, 
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);


    //
    // Validate type of, and access to object.
    //

    NtStatus = SampLookupContext(
                   Context,
                   SAM_SERVER_ENUMERATE_DOMAINS,
                   SampServerObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {


        //
        // Enumerating domains is easy.  We keep a list in memory.
        // All we have to do is use the enumeration context as an
        // index into the defined domains array.
        //



        //
        // Set our default completion status
        // Note that this is a SUCCESS status code.
        // That is NT_SUCCESS(STATUS_MORE_ENTRIES) will return TRUE.

        //

        NtStatus = STATUS_MORE_ENTRIES;

        //
        // If Product Type is DC and it is not recovering from a crash,
        // then reference DS-based domain data instead of the registry-
        // based data. Otherwise, use the registry-based domain data.
        //

        if (TRUE == SampUseDsData)
        {
            // Domain Controller
            if ((ULONG)(*EnumerationContext) < DsDomainStart)
                 *EnumerationContext = DsDomainStart;
        }


        //
        // Search the list of defined domains for a match.
        //

        for ( i = (ULONG)(*EnumerationContext);
              ( (i < SampDefinedDomainsCount) &&
                (NT_SUCCESS(NtStatus))        &&
                (!LengthLimitReached)           );
              i++ ) {


            //
            // See if there is room for the next name.  If TotalLength
            // is still zero then we haven't yet even gotten one name.
            // We have to return at least one name even if it exceeds
            // the length request.
            //


            NewTotalLength = TotalLength +
                             sizeof(UNICODE_STRING) +
                             (ULONG)SampDefinedDomains[i].ExternalName.Length +
                             sizeof(UNICODE_NULL);

            if ( (NewTotalLength < PreferedMaximumLength)  ||
                 (TotalLength == 0) ) {

                if (NewTotalLength > SAMP_MAXIMUM_MEMORY_TO_USE) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {


                    TotalLength = NewTotalLength;
                    (*CountReturned) += 1;

                    //
                    // Room for this name as well.
                    // Allocate a new return list entry, and a buffer for the
                    // name.
                    //

                    NewEntry = MIDL_user_allocate(sizeof(SAMP_ENUMERATION_ELEMENT));
                    if (NewEntry == NULL) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    } else {

                        NewEntry->Entry.Name.Buffer =
                            MIDL_user_allocate(
                                (ULONG)SampDefinedDomains[i].ExternalName.Length +
                                sizeof(UNICODE_NULL)
                                );

                        if (NewEntry->Entry.Name.Buffer == NULL) {
                            MIDL_user_free(NewEntry);
                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        } else {

                            //
                            // Copy the name into the return buffer
                            //

                            RtlCopyMemory( NewEntry->Entry.Name.Buffer,
                                           SampDefinedDomains[i].ExternalName.Buffer,
                                           SampDefinedDomains[i].ExternalName.Length
                                           );
                            NewEntry->Entry.Name.Length = SampDefinedDomains[i].ExternalName.Length;
                            NewEntry->Entry.Name.MaximumLength = NewEntry->Entry.Name.Length + (USHORT)sizeof(UNICODE_NULL);
                            UnicodeTerminate((PUNICODE_STRING)(&NewEntry->Entry.Name));


                            //
                            // The Rid field of the ENUMERATION_INFORMATION is not
                            // filled in for domains.
                            // Just for good measure, set it to zero.
                            //

                            NewEntry->Entry.RelativeId = 0;



                            //
                            // Now add this to the list of names to be returned.
                            //

                            NewEntry->Next = (PSAMP_ENUMERATION_ELEMENT)SampHead;
                            SampHead = NewEntry;
                        }

                    }
                }

            } else {

                LengthLimitReached = TRUE;

            }

        }




        if ( NT_SUCCESS(NtStatus) ) {

            //
            // Set the enumeration context
            //

            (*EnumerationContext) = (*EnumerationContext) + (*CountReturned);



            //
            // If we are returning the last of the names, then change our
            // status code to indicate this condition.
            //

            if ( ((*EnumerationContext) >= SampDefinedDomainsCount) ) {

                NtStatus = STATUS_SUCCESS;
            }




            //
            // Build a return buffer containing an array of the
            // SAM_RID_ENUMERATIONs pointed to by another
            // buffer containing the number of elements in that
            // array.
            //

            (*Buffer) = MIDL_user_allocate( sizeof(SAMPR_ENUMERATION_BUFFER) );

            if ( (*Buffer) == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            } else {

                (*Buffer)->EntriesRead = (*CountReturned);

                ArrayBufferLength = sizeof( SAM_RID_ENUMERATION ) *
                                     (*CountReturned);
                ArrayBuffer  = MIDL_user_allocate( ArrayBufferLength );
                (*Buffer)->Buffer = ArrayBuffer;

                if ( ArrayBuffer == NULL) {

                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    MIDL_user_free( (*Buffer) );

                }   else {

                    //
                    // Walk the list of return entries, copying
                    // them into the return buffer
                    //

                    NextEntry = SampHead;
                    i = 0;
                    while (NextEntry != NULL) {

                        NewEntry = NextEntry;
                        NextEntry = NewEntry->Next;

                        ArrayBuffer[i] = NewEntry->Entry;
                        i += 1;

                        MIDL_user_free( NewEntry );
                    }

                }

            }
        }




        if ( !NT_SUCCESS(NtStatus) ) {

            //
            // Free the memory we've allocated
            //

            NextEntry = SampHead;
            while (NextEntry != NULL) {

                NewEntry = NextEntry;
                NextEntry = NewEntry->Next;

                MIDL_user_free( NewEntry->Entry.Name.Buffer );
                MIDL_user_free( NewEntry );
            }

            (*EnumerationContext) = 0;
            (*CountReturned)      = 0;
            (*Buffer)             = NULL;

        }

        //
        // De-reference the  object
        // Note that NtStatus could be STATUS_MORE_ENTRIES, which is a
        // successful return code - we want to make sure we return that,
        // without wiping it out here.
        //

        if ( NtStatus == STATUS_SUCCESS ) {

            NtStatus = SampDeReferenceContext( Context, FALSE );

        } else {

            IgnoreStatus = SampDeReferenceContext( Context, FALSE );
        }
    }



    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock( fLockAcquired );



    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidEnumerateDomainsInSamServer
                   );

    return(NtStatus);

}

NTSTATUS
SamrConnect5(
    IN  PSAMPR_SERVER_NAME ServerName,
    IN  ACCESS_MASK DesiredAccess,
    IN  ULONG InVersion,
    IN  SAMPR_REVISION_INFO  *InRevisionInfo,
    OUT ULONG  *OutVersion,
    OUT SAMPR_REVISION_INFO *OutRevisionInfo,
    OUT SAMPR_HANDLE *ServerHandle
    )
/*++

Routine Description:

    This routine establishes a RPC binding handle to the local SAM server.
    
    The difference between this SamrConnect and others is that this allows
    for the server to communicate to the client what features are currently
    supported (in addition to the client telling the server what revision
    the client is at).

Arguments:

    ServerName      - Name of the node this SAM reside on.  Ignored by this
                      routine.

    DesiredAccess   - Specifies the accesses desired to the SERVER object.
    
    InVersion       - the version of the InRevisionInfo
    
    InRevisionInfo  - information about the client
    
    OutVersion      - the version of OutRevisionInfo the server is returning to 
                      the client
                 
    OutRevisionInfo - information about the server sent back to the client
                     
    ServerHandle    - If the connection is successful, the value returned
                      via this parameter serves as a context handle to the
                      opened SERVER object.


Return Value:


    STATUS_SUCCESS - The SERVER object has been successfully openned.

    STATUS_INSUFFICIENT_RESOURCES - The SAM server processes doesn't
        have sufficient resources to process or accept another connection
        at this time.
        
    STATUS_ACCESS_DENIED - client not granted a handle
    
    STATUS_NOT_SUPPORTED - the client message is not understood

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (InVersion != 1) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // N.B. OutVersion needs to be set regardless of return status.
    // What to fill OutRevisionInfo with is an open question and zero's
    // is a reasonable default.
    //
    *OutVersion = 1;
    RtlZeroMemory(OutRevisionInfo, sizeof(*OutRevisionInfo));

    NtStatus = SampConnect(ServerName, 
                           ServerHandle, 
                           InRevisionInfo->V1.Revision,
                           DesiredAccess, 
                           FALSE, // not trusted
                           FALSE, // not loopback
                           TRUE,  // NotSharedByMultiThreads
                           FALSE  // not an internal caller
                           );

    if (NT_SUCCESS(NtStatus)) {

        ULONG Features;

        OutRevisionInfo->V1.Revision = SAM_NETWORK_REVISION_LATEST;

        if ( SampIsExtendedSidModeEmulated(&Features) ) {
            OutRevisionInfo->V1.SupportedFeatures = Features; 
        }
    }

    return NtStatus;
}


NTSTATUS
SampDsProtectServerObject(
    IN PVOID Parameter                                   
    )
/*++
Routine Description:

    This routine updates SystemFlags attribute on SAM Server object to prevent 
    it from being deleted or renamed.

        Read ServerObject first, OR the systemFlags bit, then update if necessary
    
Parameters:

    None

Return Value:
    
    NTSTATUS code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       RetCode = 0;
    ULONG       SystemFlags = 0;
    COMMARG     *pCommArg = NULL;
    READARG     ReadArg;
    READRES     *pReadRes = NULL;
    ATTR        ReadAttr;
    ATTRBLOCK   ReadAttrBlock;
    ENTINFSEL   EntInfSel;
    MODIFYARG   ModArg;
    MODIFYRES   *pModRes = NULL;
    ATTR        Attr;
    ATTRVAL     AttrVal;
    ATTRVALBLOCK    AttrValBlock;
    BOOLEAN     fEndDsTransaction = FALSE;



    //
    // open a DS transaction
    // 

    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }
    fEndDsTransaction = TRUE;        


    //
    // read the original value of SystemFlags attribute
    //
    memset( &ReadArg, 0, sizeof(ReadArg) );
    memset( &EntInfSel, 0, sizeof(EntInfSel) );
    memset( &ReadAttr, 0, sizeof(ReadAttr) );

    ReadAttr.attrTyp = ATT_SYSTEM_FLAGS;
    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &ReadAttr;

    EntInfSel.AttrTypBlock = ReadAttrBlock;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInfSel;
    ReadArg.pObject = SampServerObjectDsName;

    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg( pCommArg );

    //
    // call DS routine
    // 
    RetCode = DirRead(&ReadArg, &pReadRes);
    if (NULL == pReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode, &pReadRes->CommRes);
    }
    SampClearErrors();

    if ( NT_SUCCESS(NtStatus) )
    {
        ASSERT(ATT_SYSTEM_FLAGS == pReadRes->entry.AttrBlock.pAttr[0].attrTyp);
        SystemFlags = *((ULONG *)pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal); 
    }
    else if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
    }
    else
    {
        // fail with other error
        goto Error;
    }


    //
    // if systemFlags is correct, do nothing. 
    // 
    if ((SystemFlags & FLAG_DISALLOW_DELETE) &&
        (SystemFlags & FLAG_DOMAIN_DISALLOW_RENAME) &&
        (SystemFlags & FLAG_DOMAIN_DISALLOW_MOVE))
    {
        goto Error;
    }

    //
    // set the right value
    // 

    SystemFlags |= FLAG_DISALLOW_DELETE | 
                   FLAG_DOMAIN_DISALLOW_RENAME |
                   FLAG_DOMAIN_DISALLOW_MOVE;

    //
    // Update SystemFlags attribute
    // 

    memset( &ModArg, 0, sizeof(ModArg) );
    ModArg.pObject = SampServerObjectDsName;

    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = sizeof(ULONG);
    AttrVal.pVal = (PUCHAR) &SystemFlags;

    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;

    Attr.attrTyp = ATT_SYSTEM_FLAGS;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    pCommArg = &(ModArg.CommArg);
    BuildStdCommArg( pCommArg );

    RetCode = DirModifyEntry(&ModArg, &pModRes);
    if (NULL==pModRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
    }

Error:

    if (fEndDsTransaction)
    {
        SampMaybeEndDsTransaction( TransactionCommit );
    }

    //
    // register worker routine again if failed
    // 
    if (!NT_SUCCESS(NtStatus))
    {
        LsaIRegisterNotification(
                    SampDsProtectServerObject,
                    NULL,
                    NOTIFIER_TYPE_INTERVAL,
                    0,
                    NOTIFIER_FLAG_ONE_SHOT,
                    300,        // wait for 5 minutes: 300 secound
                    0
                    );
    }

    return( NtStatus ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\site.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    site.c

Abstract:

    This file contains the routines to maintain the global site information.
    
    
    Thoery of Operation for Maintaining Global Site info
    ----------------------------------------------------
    
    SAM maintains global state about the site that the server is in as well
    as the site settings for this site.  Of course, both pieces of information
    could change at any time, and SAM should not need to be restarted in
    order to have these changes take effect.
    
    SampSiteInfo is a global that contains: the GUID of our Ntds Settings 
    object, the GUID of our site and the Options for our site.  Certain
    notifications (to be discussed shortly) will cause this information to 
    be updated.  The update occurs in the following manner:
    
    1)  the SampSiteInfoLock critical section is acquired                         
    2)  a DS transaction is started
    3)  our DSA is read, located by GUID
    4)  we trim the returned string name by 3 to obtain the site DN
    5)  the site DN is read to obtain the site GUID; SampSiteInfo is updated
    6)  the well known RDN "Ntds Site Settings" is appended to the site DN
        and this object is read to obtain the Options attribute; SampSiteInfo
        is updated
    7)  a notification on the "Ntds Site Settings" obtain is registered (via
        (DirNotifyRegister)
    8)  Any old notification is removed (DirNotifyUnRegsiter) ( a non fatal 
        operation)
    9)  the DS transaction is ended
    10) the SampSiteInfoLock critical section is released
    11) if an fatal error occurred then reshedule update task in one minute
    
       
    The above algorithm is executed in the context of a "task" 
    (SampUpdateSiteInfo) scheduled via LsaIRegisterNotification.  The task is 
    
    1) run once during startup
    2) scheduled to run whenever a notification occurs due to a change to the 
       Site Settings object
    3) scheduled to run whenever a notification occurs due to a site change 
       (SamINotifyServerDelta)
    4) scheduled whenever an error occurs during its execution
    
    Since multiple instances of SampUpdateSiteInfo can be running at once,
    the code is gaurded by SampSiteInfoLock.  This is needed to synchronize
    not the update of the variable SampSiteInfo, but to serialize the calls to
    DirNotifyRegister and DirNotifyUnRegister.

    This mechanism is bootstrapped by using GetConfigurationName to obtain
    the Ntds Settings object GUID the first time SampUpdateSiteInfo is run.
    
        
Author:

    Colin Brace   (ColinBr)  28-Feb-2000

Environment:

    User Mode - Win32

Revision History:

    ColinBr        28-Feb-00

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <ntdsa.h>
#include <filtypes.h>
#include <attids.h>
#include <dslayer.h>
#include <dsdomain.h>
#include <samtrace.h>
#include <malloc.h>
#include <dsconfig.h>
#include <mappings.h>
#include <winsock2.h>
#define _AVOID_REPL_API
#include <nlrepl.h>
#include <stdlib.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Data                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



//
// Global infomation about our current site
//
typedef struct _SAMP_SITE_INFORMATION {

    GUID    NtdsSettingsGuid;
    GUID    SiteGuid;
    ULONG   Options;  // on Ntds Settings object
    LPWSTR  SiteName;

} SAMP_SITE_INFORMATION, *PSAMP_SITE_INFORMATION;

PSAMP_SITE_INFORMATION SampSiteInfo = NULL;

//
// A lock to prevent concurrent updates on the global site information
//
CRITICAL_SECTION SampSiteInfoLock;

#define SampLockSiteInfo()                                      \
{                                                               \
    NTSTATUS _IgnoreStatus;                                     \
   _IgnoreStatus = RtlEnterCriticalSection(&SampSiteInfoLock);  \
   ASSERT(NT_SUCCESS(_IgnoreStatus));                           \
}

#define SampUnLockSiteInfo()                                    \
{                                                               \
    NTSTATUS _IgnoreStatus;                                     \
   _IgnoreStatus = RtlLeaveCriticalSection(&SampSiteInfoLock);  \
   ASSERT(NT_SUCCESS(_IgnoreStatus));                           \
}

//
// A global to indicate whether we need to log a successful
// site information update.  This is only necessary if we hit
// a failure and needed to reschdule the refresh.
//
BOOLEAN SampLogSuccessfulSiteUpdate;

//
// This global remembers the handle returned by DirRegisterNotify
// so that the notification can be removed.
//
DWORD SampSiteNotificationHandle;

// Since the handle can be 0, we need more state to indicate whether it
// is set
BOOLEAN SampSiteNotificationHandleSet = FALSE;


//
// An Empty site affinity
//
SAMP_SITE_AFFINITY SampNullSiteAffinity;

#define GCLESS_DEFAULT_SITE_STICKINESS_DAYS  180

#define ENTRY_HAS_EXPIRED(entry, standard) \
    ((-1) == CompareFileTime((FILETIME*)&(entry),(FILETIME*)&(standard)))

#define ENTRY_IS_EMPTY(x)  (!memcmp((x), &SampNullSiteAffinity, sizeof(SampNullSiteAffinity)))

#define ONE_SECOND_IN_FILETIME (10 * (1000*1000))


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SampUpdateSiteInfo(
    VOID
    );

NTSTATUS
SampSetupSiteNotification(
    IN DSNAME *SiteSettingsDN
    );

NTSTATUS
SampDelayedFreeCallback(
    PVOID pv
    );

VOID
SampFreeSiteInfo(
    IN PSAMP_SITE_INFORMATION *p
    );
    

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
NTSTATUS
SampInitSiteInformation(
    VOID
    )
/*++

Routine Description:

    This routine is called during SAM's initialiazation path.  Its purpose
    is to initialize the global site information.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS, or a fatal resourse error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG Size;

    if ( !SampUseDsData ) {

        return STATUS_SUCCESS;
    }
   // Init the critical section
   try {
       NtStatus = RtlInitializeCriticalSectionAndSpinCount(&SampSiteInfoLock, 100);
   } except ( 1 ) {
       NtStatus =  STATUS_NO_MEMORY;
   }
   if (!NT_SUCCESS(NtStatus))
       return (NtStatus);

    // Init the global structure
    SampSiteInfo = NULL;

    RtlZeroMemory( &SampNullSiteAffinity, sizeof(SampNullSiteAffinity));

    SampLogSuccessfulSiteUpdate = FALSE;

    // Fill the global structure and setup the notification
    SampUpdateSiteInfo();

    return STATUS_SUCCESS;

}

    

NTSTATUS
SampGetSiteDNInfo(
    IN  DSNAME*  DsaDN,
    OUT DSNAME** pSiteDN OPTIONAL,
    OUT DSNAME** pSiteSettingsDN OPTIONAL
    )
/*++

Routine Description:

    This routine determines the current site dn and ntds site settings
    dn.  No transaction is needed or started.

Arguments:

    pSiteDN - a heap allocated DSNAME if the Site; caller must free with
              midl_user_free
              
    pSiteSettingsDN - a heap allocated DSNAME if the Site; caller must free with
              midl_user_free
              
Return Value:

    STATUS_SUCCESS, or a fatal resourse error

--*/
{

    NTSTATUS   NtStatus = STATUS_SUCCESS;
    DSNAME     *SiteDN = NULL;
    DSNAME     *SiteSettingsDN = NULL;
    LPWSTR      SiteSettingsCN = L"NTDS Site Settings";
    ULONG       Size;

    NtStatus = STATUS_NO_MEMORY;
    SiteDN = (DSNAME*) midl_user_allocate(DsaDN->structLen);
    if ( SiteDN ) {
        RtlZeroMemory(SiteDN, DsaDN->structLen);
        if ( TrimDSNameBy(DsaDN, 3, SiteDN) == 0) {
    
            Size = DsaDN->structLen + sizeof(SiteSettingsCN);
    
            SiteSettingsDN = (DSNAME*)midl_user_allocate(Size);
            if ( SiteSettingsDN ) {
                RtlZeroMemory(SiteSettingsDN, Size);
                AppendRDN(SiteDN,
                          SiteSettingsDN,
                          Size,
                          SiteSettingsCN,
                          0,
                          ATT_COMMON_NAME
                          );
                NtStatus = STATUS_SUCCESS;
            }
        }
    }

    if ( !NT_SUCCESS(NtStatus) ) {
        if ( SiteDN ) midl_user_free(SiteDN);
        if ( SiteSettingsDN ) midl_user_free(SiteSettingsDN);
        return NtStatus;
    }

    if ( pSiteDN ) {
        *pSiteDN = SiteDN;
    } else {
        midl_user_free(SiteDN);
    }

    if ( pSiteSettingsDN) {
        *pSiteSettingsDN = SiteSettingsDN;
    } else {
        midl_user_free(SiteSettingsDN);
    }

    return STATUS_SUCCESS;

}

VOID
SampUpdateSiteInfo(
    VOID
    )
/*++

Routine Description:

    This routine queries the DS for the current site information.
    Currently, this means the options attribute on the ntds site 
    settings object.
    
Arguments:

    None

Return Value:

    None -- on error, it reschedules itself to run.

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS NtStatus2;
    ULONG    DirError = 0;
    DSNAME   *SiteSettingsDN = NULL;
    DSNAME   *SiteDN = NULL;
    GUID     NullGuid = {0};
    DSNAME   *DsaDN = NULL;
    DSNAME   Buffer;

    WCHAR    *SiteNameBuffer;
    ULONG    SiteNameLength;
    ATTRTYP  AttrType;

    READARG     ReadArg;
    READRES     * pReadRes = NULL;
    ENTINFSEL   EntInf;
    ATTR        Attr;
    BOOLEAN     fTransOpen = FALSE;
    BOOLEAN     fGroupCacheNowEnabled = FALSE;

    PSAMP_SITE_INFORMATION NewSiteInfo = NULL;

    PSAMP_SITE_INFORMATION OldSiteInfo = NULL;

    PVOID      PtrToFree = NULL;

    // This only makes sense on a DC
    ASSERT( SampUseDsData );
    if ( !SampUseDsData ) {
        return;
    }

    // Lock the global structure before the transaction start
    SampLockSiteInfo();

    //
    // Allocate the new structure
    //
    NewSiteInfo = midl_user_allocate(sizeof(*NewSiteInfo));

    if (NULL == NewSiteInfo ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(NewSiteInfo, sizeof(*NewSiteInfo));

    //
    // Remember the old version
    //
    OldSiteInfo = SampSiteInfo;

    //
    // Bootstrap ourselves by getting our DSA guid from global memory
    // in ntdsa (which is where GetConfigurationName gets if from)
    //
    if ( NULL == OldSiteInfo ) {

        ULONG Size = 0;

        NtStatus = GetConfigurationName(
                        DSCONFIGNAME_DSA,
                        &Size,
                        NULL
                        );
        ASSERT(STATUS_BUFFER_TOO_SMALL == NtStatus);
        SAMP_ALLOCA(DsaDN,Size);
        if (NULL!=DsaDN) {
            NtStatus = GetConfigurationName(
                           DSCONFIGNAME_DSA,
                           &Size,
                           DsaDN
                           );
        
            ASSERT(NT_SUCCESS(NtStatus));

            RtlCopyMemory(&NewSiteInfo->NtdsSettingsGuid,
                          &DsaDN->Guid,
                          sizeof(GUID));
        } else {
           
           NtStatus = STATUS_INSUFFICIENT_RESOURCES;
           goto Cleanup;
        }


    } else {

        RtlCopyMemory(&NewSiteInfo->NtdsSettingsGuid,
                      &OldSiteInfo->NtdsSettingsGuid,
                      sizeof(GUID));
    }
    ASSERT(!IsEqualGUID(&NullGuid, &NewSiteInfo->NtdsSettingsGuid));


    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }
    fTransOpen = TRUE;


    //
    // Read the dsa object so we can determine the site.  Note that
    // asking GetConfigurationName is not gaurenteed to work since the 
    // global data in ntdsa is not gaurenteed to be updated by the time
    // we are notified here in SAM.
    //
    if (NULL == DsaDN) {

        // Set up a GUID based name
        DsaDN = &Buffer;
        RtlZeroMemory(DsaDN,  sizeof(Buffer));
        RtlCopyMemory(&DsaDN->Guid, &NewSiteInfo->NtdsSettingsGuid, sizeof(GUID));
        DsaDN->structLen = sizeof(DSNAME);

        RtlZeroMemory(&Attr, sizeof(ATTR));
        RtlZeroMemory(&EntInf, sizeof(ENTINFSEL));
        RtlZeroMemory(&ReadArg, sizeof(READARG));
    
        Attr.attrTyp = ATT_OBJ_DIST_NAME;
    
        EntInf.AttrTypBlock.attrCount = 1;
        EntInf.AttrTypBlock.pAttr = &Attr;
        EntInf.attSel = EN_ATTSET_LIST;
        EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
    
        ReadArg.pSel = &EntInf;
        ReadArg.pObject = DsaDN;
    
        InitCommarg(&(ReadArg.CommArg));
    
        DirError = DirRead(&ReadArg, &pReadRes);
    
        if (NULL == pReadRes){
           NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {
           NtStatus = SampMapDsErrorToNTStatus(DirError, &pReadRes->CommRes);
        }
        THClearErrors();
    
        if (NT_SUCCESS(NtStatus)) {
    
           ASSERT(1==pReadRes->entry.AttrBlock.attrCount);
           ASSERT(ATT_OBJ_DIST_NAME == pReadRes->entry.AttrBlock.pAttr[0].attrTyp);
           DsaDN = (DSNAME*)pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;
        
        }  else {
    
            // Can't read the DSA object? This is fatal.
            goto Cleanup;
        }
    }
    ASSERT(DsaDN && (DsaDN->NameLen > 0));


    //
    // Get the ntds site settings object
    //
    NtStatus = SampGetSiteDNInfo( DsaDN,
                                 &SiteDN,
                                 &SiteSettingsDN );

    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus ) ) {
        goto Cleanup;
    }

    //
    // Set the site name
    //
    SiteNameBuffer = alloca(SiteDN->NameLen);
    SiteNameLength = SiteDN->NameLen;
    DirError = GetRDNInfoExternal(SiteDN,
                                  SiteNameBuffer,
                                  &SiteNameLength,
                                  &AttrType);
    ASSERT(0 == DirError && (SiteNameLength > 0));

    NewSiteInfo->SiteName = midl_user_allocate((SiteNameLength + 1) * sizeof(WCHAR));
    if (NewSiteInfo->SiteName) {
        RtlCopyMemory(NewSiteInfo->SiteName, SiteNameBuffer, SiteNameLength*sizeof(WCHAR));
        NewSiteInfo->SiteName[SiteNameLength] = L'\0';
    } else {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    //
    // Read the options field
    //
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&EntInf, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadArg, sizeof(READARG));

    Attr.attrTyp = ATT_OPTIONS;

    EntInf.AttrTypBlock.attrCount = 1;
    EntInf.AttrTypBlock.pAttr = &Attr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInf;
    ReadArg.pObject = SiteSettingsDN;

    InitCommarg(&(ReadArg.CommArg));

    DirError = DirRead(&ReadArg, &pReadRes);

    if (NULL == pReadRes){
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {
       NtStatus = SampMapDsErrorToNTStatus(DirError, &pReadRes->CommRes);
    }
    THClearErrors();

    if (NT_SUCCESS(NtStatus)) {

       ASSERT(1==pReadRes->entry.AttrBlock.attrCount);
       ASSERT(ATT_OPTIONS == pReadRes->entry.AttrBlock.pAttr[0].attrTyp);
       ASSERT( sizeof(DWORD) == pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen);

       NewSiteInfo->Options = *((DWORD*)pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
    
    } else if (NtStatus == STATUS_DS_NO_ATTRIBUTE_OR_VALUE){

        // No attribute -> No flags
        NewSiteInfo->Options = 0;
        NtStatus = STATUS_SUCCESS;

    } else {

        // There should be no other kinds of error codes on a read
        // Object name not found can happen when the DC changes site
        // between the call to GetConfigurationName and the 
        // SampMaybeBeginDsTransaction, in this case, simply
        // reschedule
        if (STATUS_OBJECT_NAME_NOT_FOUND != NtStatus) {
            ASSERT( NT_SUCCESS( NtStatus ) );
        }
        goto Cleanup;
    }

    //
    // Read the site object to get its GUID
    //
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&EntInf, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadArg, sizeof(READARG));

    Attr.attrTyp = ATT_OBJ_DIST_NAME;

    EntInf.AttrTypBlock.attrCount = 1;
    EntInf.AttrTypBlock.pAttr = &Attr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInf;
    ReadArg.pObject = SiteDN;

    InitCommarg(&(ReadArg.CommArg));

    DirError = DirRead(&ReadArg, &pReadRes);

    if (NULL == pReadRes){
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {
       NtStatus = SampMapDsErrorToNTStatus(DirError, &pReadRes->CommRes);
    }
    THClearErrors();

    if (NT_SUCCESS(NtStatus)) {

        RtlCopyMemory(&NewSiteInfo->SiteGuid, 
                      &ReadArg.pObject->Guid, 
                      sizeof(GUID));
    } else {

        // There should be no other kinds of error codes on a read
        // Object name not found can happen when the DC changes site
        // between the call to GetConfigurationName and the 
        // SampMaybeBeginDsTransaction, in this case, simply
        // reschedule
        if (STATUS_OBJECT_NAME_NOT_FOUND != NtStatus) {
            ASSERT( NT_SUCCESS( NtStatus ) );
        }
        goto Cleanup;
    }


    //
    // Re-register a notification on the new site
    //
    NtStatus = SampSetupSiteNotification( SiteSettingsDN );
    if ( !NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    fGroupCacheNowEnabled = ((NewSiteInfo->Options & 
                              NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED) ==
                              NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED);


    //
    // We have a new value; note the use of InterlockExchangePointer.
    // Since there is no read lock on the value, other threads could
    // be accessing it now
    //
    PtrToFree = InterlockedExchangePointer(&SampSiteInfo, NewSiteInfo);
    NewSiteInfo = NULL;
    if ( PtrToFree ) {
            LsaIRegisterNotification(
                    SampDelayedFreeCallback,
                    PtrToFree,
                    NOTIFIER_TYPE_INTERVAL,
                    0,        // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    3600,     // wait for 60 min
                    NULL      // no handle
                    );
    }

Cleanup:


    if ( fTransOpen ) {
        NtStatus2 = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                               TransactionCommit :
                                               TransactionAbort );
        if (!NT_SUCCESS(NtStatus2) && NT_SUCCESS(NtStatus)) {
            NtStatus = NtStatus2;
        }
    }

    // Release the site info
    SampUnLockSiteInfo();

    if ( SiteSettingsDN ) {
        midl_user_free( SiteSettingsDN );
    }

    if ( SiteDN ) {
        midl_user_free( SiteDN );
    }

    if ( NewSiteInfo ) {
        SampFreeSiteInfo(&NewSiteInfo);
    }

    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // Notify the user on failure and try again.
        //
        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                          0,     // no category
                          SAMMSG_SITE_INFO_UPDATE_FAILED,
                          NULL,  // no sid
                          0,
                          sizeof(NTSTATUS),
                          NULL,
                          (PVOID)(&NtStatus));

        LsaIRegisterNotification(
                SampUpdateSiteInfoCallback,
                NULL,
                NOTIFIER_TYPE_INTERVAL,
                0,            // no class
                NOTIFIER_FLAG_ONE_SHOT,
                60,          // wait for 1 min
                NULL        // no handle
                );
                                       
        SampLogSuccessfulSiteUpdate = TRUE;


    } else {

        if ( SampLogSuccessfulSiteUpdate ) {

            if ( fGroupCacheNowEnabled ) {

                SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                  0,     // no category
                                  SAMMSG_SITE_INFO_UPDATE_SUCCEEDED_ON,
                                  NULL,  // no sid
                                  0,
                                  0,
                                  NULL,
                                  NULL);
            } else {

                SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                  0,     // no category
                                  SAMMSG_SITE_INFO_UPDATE_SUCCEEDED_OFF,
                                  NULL,  // no sid
                                  0,
                                  0,
                                  NULL,
                                  NULL);
            }



            SampLogSuccessfulSiteUpdate = FALSE;
        }
    }

    return;

}



BOOLEAN
SampIsGroupCachingEnabled(
    IN PSAMP_OBJECT AccountContext
    )
/*++

Routine Description:

    This routine determines whether SAM should use group caching or
    not.  To disable the entire feature, simply hard code this routine
    to return FALSE.  Otherwise, it will return a status based on the
    role of the machine (GC or not) and the current settings of the site
    object.

Arguments:

    None.

Return Value:
    
    TRUE if SAM should use group caching; FALSE otherwise.

--*/
{
    BOOLEAN fGroupCachingEnabled = TRUE;


    // Group caching is never enabled on a GC
    if ( SampAmIGC() ) {
        fGroupCachingEnabled = FALSE;
    }

    // Group caching is never enabled in a Mixed Domain
    if (DownLevelDomainControllersPresent(AccountContext->DomainIndex)) {
        fGroupCachingEnabled = FALSE;
    }

    if ( fGroupCachingEnabled ) {

        PSAMP_SITE_INFORMATION volatile SiteInfo = SampSiteInfo;

        if (SiteInfo) {

            fGroupCachingEnabled = ((SiteInfo->Options & 
                                    NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED) ==
                                    NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED);

        } else {

            fGroupCachingEnabled = FALSE;

        }
    
    
    }

    return fGroupCachingEnabled;

}


BOOL
SampSiteNotifyPrepareToImpersonate(
    ULONG Client,
    ULONG Server,
    VOID **ImpersonateData
    )
//
// This function is called by the core DS as preparation for a call to
// SampSiteNotifyProcessDelta.  Since SAM does not have a
// client context, we set the thread state fDSA to TRUE.
//
{
    SampSetDsa( TRUE );

    return TRUE;
}

VOID
SampSiteNotifyStopImpersonation(
    ULONG Client,
    ULONG Server,
    VOID *ImpersonateData
    )
//
// Called after SampSiteNotifyProcessDelta, this function
// undoes the effect of SampNotifyPrepareToImpersonate
//
{

    SampSetDsa( FALSE );

    return;
}


NTSTATUS
SampUpdateSiteInfoCallback(
    PVOID pv
/*++

Routine Description:

    This routine is a wrapper for SampUpdateSiteInfo.  Its purpose is to
    be used as a callback when registering a callback in the LSA's process
    wide thread pool.  When SampUpdateSiteInfo() fails is reschedules
    itself to run using this routine.

Arguments:

    pv -- unused.

Return Value:

    STATUS_SUCCESS

--*/
    )
{
    SampUpdateSiteInfo();

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(pv);
}
VOID
SampSiteNotifyProcessDelta(
    ULONG hClient,
    ULONG hServer,
    ENTINF *EntInf
    )
/*++

Routine Description:

    This routine is a callback for notifications to the site object.
    
    to be 
    This callback is used when the global rid manager object is changed.
    This function compares our local rid pool with the current rid pool
    to make sure the former is a subset of the latter; if not, the current
    rid pool is invalidated.

Arguments:

    hClient - ignored
    hServer - ignored
    EntInf  - the pointer to the requested data

Return Value:

    None.

--*/
{
    //
    // Normally, one would simply use the EntInf structure
    // however since updates to the SampSiteInfo are serialized
    // it is a violation to grab the lock _inside_ a transaction
    // So register a callback so that we can get a fresh view
    // of the database after grabbing the lock.
    //
    LsaIRegisterNotification(
            SampUpdateSiteInfoCallback,
            NULL,
            NOTIFIER_TYPE_INTERVAL,
            0,            // no class
            NOTIFIER_FLAG_ONE_SHOT,
            1,          // wait for a second
            NULL        // no handle
            );

    return;
}

NTSTATUS
SampSetupSiteNotification(
    IN DSNAME* SiteSettingsDN
    )
/*++

Routine Description:

    This routine registers SAM to be notified when the current ntds site
    settings object is modified.

Arguments:

    SiteSettingsDN -- the DN of the object to setup a notification for

Return Value:

    STATUS_SUCCESS, or resource error

--*/
{


    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DirError = 0;

    SEARCHARG   searchArg;
    NOTIFYARG   notifyArg;
    NOTIFYRES*  notifyRes = NULL;
    ENTINFSEL   entInfSel;
    ATTR        attr;
    FILTER      filter;

    DWORD       oldHandle = SampSiteNotificationHandle;
    BOOLEAN     oldHandleSet = SampSiteNotificationHandleSet;

    //
    // init notify arg
    //
    notifyArg.pfPrepareForImpersonate = SampSiteNotifyPrepareToImpersonate;
    notifyArg.pfTransmitData = SampSiteNotifyProcessDelta;
    notifyArg.pfStopImpersonating = SampSiteNotifyStopImpersonation;
    notifyArg.hClient = 0;

    //
    // init search arg
    //
    ZeroMemory(&searchArg, sizeof(SEARCHARG));
    ZeroMemory(&entInfSel, sizeof(ENTINFSEL));
    ZeroMemory(&filter, sizeof(FILTER));
    ZeroMemory(&attr, sizeof(ATTR));


    searchArg.pObject = SiteSettingsDN;

    InitCommarg(&searchArg.CommArg);
    searchArg.choice = SE_CHOICE_BASE_ONLY;
    searchArg.bOneNC = TRUE;

    searchArg.pSelection = &entInfSel;
    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    entInfSel.AttrTypBlock.attrCount = 1;
    entInfSel.AttrTypBlock.pAttr = &attr;
    attr.attrTyp = ATT_OPTIONS;

    searchArg.pFilter = &filter;
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_TRUE;

    DirError = DirNotifyRegister(&searchArg, &notifyArg, &notifyRes);

    if ( DirError != 0 ) {

        NtStatus = SampMapDsErrorToNTStatus(DirError, &notifyRes->CommRes);

    }

    if ( NT_SUCCESS(NtStatus)) {

        SampSiteNotificationHandle = notifyRes->hServer;
        SampSiteNotificationHandleSet = TRUE;

        if ( oldHandleSet ) {

            //
            // Remove the old notification
            //
            DirError = DirNotifyUnRegister(oldHandle,
                                           &notifyRes);
            ASSERT( 0 == DirError );
        }
    }

    return NtStatus;

}

#define SampNamesMatch(x, y)                                        \
  ((CSTR_EQUAL == CompareString(DS_DEFAULT_LOCALE,                  \
                                DS_DEFAULT_LOCALE_COMPARE_FLAGS,    \
                                (x)->Buffer,                        \
                                (x)->Length/sizeof(WCHAR),          \
                                (y)->Buffer,                        \
                                (y)->Length/sizeof(WCHAR) )))

BOOLEAN
SampCheckForSiteAffinityUpdate(
    IN  PSAMP_OBJECT          AccountContext,
    IN  ULONG                 Flags,
    IN  PSAMP_SITE_AFFINITY pOldSA,
    OUT PSAMP_SITE_AFFINITY pNewSA,
    OUT BOOLEAN*            fDeleteOld
    )
/*++

Routine Description:

    This routine takes an existing Site Affinity value and determines
    if it needs updating. See spec for details of algorithm.

Arguments:

    AccountContext -- the account that may have some site affinity
    
    Flags -- Flags as passed to SamIUpdateLogonStatistics
    
    pOldSA -- existing Site Affinity value.
    
    pNewSA -- new Site Affinity value to write
    
    fDeleteOld -- flag to indicate whether to delete old SA; set to TRUE
                  if a new value is to be written; FALSE otherwise

Return Value:

    TRUE if a new Site Affinity needs to be written to the DS
    FALSE otherwise

--*/
{
    BOOLEAN fUpdate = FALSE;
    DWORD   err;
    ULONG   siteStickiness;
    LARGE_INTEGER timeTemp, timeBestAfter;
    PSAMP_SITE_INFORMATION volatile SiteInfo = SampSiteInfo;

    if ( !SampIsGroupCachingEnabled(AccountContext) ) {
        return FALSE;
    }

    if (SiteInfo == NULL) {
        return FALSE;
    }

    if (!AccountContext->TypeBody.User.fCheckForSiteAffinityUpdate) {
        return FALSE;
    }

    (*fDeleteOld) = FALSE;

    err = GetConfigParam(GCLESS_SITE_STICKINESS,
                         &siteStickiness,
                         sizeof(siteStickiness));
    if (err) {
        siteStickiness = GCLESS_DEFAULT_SITE_STICKINESS_DAYS*24*60;
    }
    // Update at the half the frequency
    //
    // Note that the "half" is implemented by dividing the number of seconds
    // not minutes so that settings of small values like 1, or 3 minutes are
    // effective.
    //
    timeTemp.QuadPart = Int32x32To64(siteStickiness * 60/2, ONE_SECOND_IN_FILETIME);
    GetSystemTimeAsFileTime((FILETIME*)&timeBestAfter);
    timeBestAfter.QuadPart -= timeTemp.QuadPart;


    if ( ENTRY_IS_EMPTY(pOldSA) ) {
        fUpdate = TRUE;
    } else if (ENTRY_HAS_EXPIRED(pOldSA->TimeStamp, timeBestAfter)) {
        fUpdate = TRUE;
        *fDeleteOld = TRUE;
    }


    if (fUpdate) {

        //
        // Make sure that the client is from our site
        //
        if ( SampNoGcLogonEnforceKerberosIpCheck
         &&  AccountContext->TypeBody.User.ClientInfo.Type == SamClientIpAddr) {
    
            //
            // An IP address was given -- see if it is in one of our subnets if
            // we have any
            //
            BOOL NotInSite = FALSE;
            ULONG i;
            DWORD NetStatus;
            SOCKET_ADDRESS SocketAddress;
            SOCKADDR SockAddr;
            LPWSTR SiteName = NULL;
            UNICODE_STRING OurSite, ClientSite;

            RtlInitUnicodeString(&OurSite, SiteInfo->SiteName);

            RtlZeroMemory(&SocketAddress, sizeof(SocketAddress));
            RtlZeroMemory(&SockAddr, sizeof(SockAddr));
            SocketAddress.iSockaddrLength = sizeof(SockAddr);
            SocketAddress.lpSockaddr = &SockAddr;
            SockAddr.sa_family = AF_INET;
            ((PSOCKADDR_IN)&SockAddr)->sin_addr.S_un.S_addr = AccountContext->TypeBody.User.ClientInfo.Data.IpAddr;

            NetStatus = I_NetLogonAddressToSiteName(&SocketAddress,
                                                    &SiteName);
            if ( 0 == NetStatus
              && SiteName != NULL ) {

                RtlInitUnicodeString(&ClientSite, SiteName);

                if (!SampNamesMatch(&ClientSite, &OurSite)) {
                    NotInSite = TRUE;
                }

            }
    
            if (SiteName) {
                I_NetLogonFree(SiteName);
            }

            if (NotInSite) {
                return FALSE;
            }
        }

        if ( SampNoGcLogonEnforceNTLMCheck
          && (Flags & USER_LOGON_TYPE_NTLM)
          && !( (Flags & USER_LOGON_INTER_FAILURE)
             || (Flags & USER_LOGON_INTER_SUCCESS_LOGON)) ) {
            //
            // If this is not an interactive logon attempt
            // don't update the site affinity
            //
            return FALSE;
        }

    }

    if (fUpdate) {

        //
        // Since a GUID is a large structure, safely extract the pointer
        // to make sure the compiler uses the same value while deferencing
        // the GUID.
        //
        pNewSA->SiteGuid = SiteInfo->SiteGuid;
        GetSystemTimeAsFileTime((FILETIME*)&pNewSA->TimeStamp);
    }

    return fUpdate;
}

NTSTATUS
SampFindUserSiteAffinity(
    IN PSAMP_OBJECT AccountContext,
    IN ATTRBLOCK* Attrs,
    OUT SAMP_SITE_AFFINITY *pSiteAffinity
    )
/*++

Routine Description:

    This routine iterates through the given AttrBlock looking for the site
    affinity attribute.  If found, it then searches for a value that corresponds
    to the current site. If found that value is returned via pSiteAffinity

Arguments:

    AccountContext -- the account that may have some site affinity
    
    Attrs -- an attrblock of attributes
    
    pSiteAffinity -- the site affinity if found

Return Value:

    STATUS_SUCCESS if site affinity value exists
    
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMP_SITE_AFFINITY *pSA = NULL;
    GUID SiteGuid;
    ULONG i, j;
    // don't optimize this variable    
    PSAMP_SITE_INFORMATION volatile SiteInfo = SampSiteInfo;

    if ( !SampIsGroupCachingEnabled(AccountContext) ) {
        return STATUS_UNSUCCESSFUL;
    }

    if (NULL == SiteInfo) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Since a GUID is a large structure, safely extract the pointer
    // to make sure the compiler uses the same value while deferencing
    // the GUID.
    //
    RtlCopyMemory(&SiteGuid, &SiteInfo->SiteGuid, sizeof(GUID));

    //
    // Iterate through looking for a value that matches 
    // our site
    //
    for (i = 0; i < Attrs->attrCount; i++) {

        if ( Attrs->pAttr[i].attrTyp == SAMP_FIXED_USER_SITE_AFFINITY ) {
            //
            // Found the attribute -- now find a value for our site,
            // if any
            //
            ATTRVALBLOCK *pAttrVal = &Attrs->pAttr[i].AttrVal;
            for (j = 0; j < pAttrVal->valCount; j++ ) {


                ASSERT(pAttrVal->pAVal[j].valLen == sizeof(SAMP_SITE_AFFINITY));\
                pSA = (SAMP_SITE_AFFINITY*) pAttrVal->pAVal[j].pVal;

                if (IsEqualGUID(&pSA->SiteGuid, &SiteGuid)) {

                    // Got it
                    break;

                } else {
                    pSA = NULL;
                }
            }
        }
    }

    if ( pSA ) {
        RtlCopyMemory( pSiteAffinity, pSA, sizeof(SAMP_SITE_AFFINITY) );
    } else {
        NtStatus = STATUS_UNSUCCESSFUL;
    }

    return NtStatus;
}


NTSTATUS
SampDelayedFreeCallback(
    PVOID pv
    )
{
    if ( pv ) {

        SampFreeSiteInfo( (PSAMP_SITE_INFORMATION*) &pv );
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SampRefreshSiteAffinity(
    IN PSAMP_OBJECT AccountContext
    )

/*++

Routine Description:

    This routine performs a database to obtain the site affinity. 
    
    N.B. This routine can start a transaction that is left open for the caller.
    
Arguments:

    AccountContext -- the account that may have some site affinity

Return Value:

    STATUS_SUCCESS; an unexpected resource error otherwise
    
--*/
{
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    ATTRBLOCK AttrToRead;
    ATTR      SAAttr;
    ATTRBLOCK AttrRead;
    SAMP_SITE_AFFINITY NewSA;

    ASSERT(AccountContext);
    ASSERT(AccountContext->ObjectNameInDs);

    RtlZeroMemory(&AttrToRead, sizeof(AttrToRead));
    RtlZeroMemory(&SAAttr, sizeof(SAAttr));
    RtlZeroMemory(&AttrRead, sizeof(AttrRead));

    AttrToRead.attrCount =1;
    AttrToRead.pAttr = &(SAAttr);

    SAAttr.AttrVal.valCount =0;
    SAAttr.AttrVal.pAVal = NULL;
    SAAttr.attrTyp = SAMP_FIXED_USER_SITE_AFFINITY;

    NtStatus = SampDsRead(AccountContext->ObjectNameInDs,
                        0,
                        AccountContext->ObjectType,
                        &AttrToRead,
                        &AttrRead);

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampFindUserSiteAffinity(AccountContext,
                                            &AttrRead,
                                            &NewSA);

        if (NT_SUCCESS(NtStatus)) {

            // Found it -- update the context
            AccountContext->TypeBody.User.SiteAffinity = NewSA;

        } else {

            // No SA to our site? Set to zero
            RtlZeroMemory(&AccountContext->TypeBody.User.SiteAffinity, 
                          sizeof(AccountContext->TypeBody.User.SiteAffinity));
            NtStatus = STATUS_SUCCESS;
        }

    } else if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus) {

        // No SA at all? Set to zero
        RtlZeroMemory(&AccountContext->TypeBody.User.SiteAffinity, 
                      sizeof(AccountContext->TypeBody.User.SiteAffinity));
        NtStatus = STATUS_SUCCESS;

    }

    return NtStatus;

}


VOID
SampFreeSiteInfo(
    PSAMP_SITE_INFORMATION *pp
    )
{
    PSAMP_SITE_INFORMATION p = *pp;
    if (p) {
        if (p->SiteName) {
            midl_user_free( p->SiteName);
        }
        midl_user_free( p);
        *pp = NULL;
    }
}


NTSTATUS
SampExtractClientIpAddr(
    IN handle_t     BindingHandle OPTIONAL,
    IN SAMPR_HANDLE UserHandle OPTIONAL,    
    IN PSAMP_OBJECT Context
    )
/*++

Routine Description:

    This routine extracts the IP address of the client caller from the
    BindinHandle or UserHandle.  If an IP address is present, this routine 
    places the address in the ClientInfo structure of the Context.
    
Arguments:

    BindingHandle - an RPC binding handle
                                       
    UserHandle - an RPC context handle
    
    Context - the SAM representation of the RPC context handle
    
Return Value:

    STATUS_SUCCESS; an unexpected RPC error otherwise
    
--*/
{
    RPC_BINDING_HANDLE ClientBinding = NULL;
    RPC_BINDING_HANDLE ServerBinding = NULL;
    LPSTR StringBinding = NULL;
    LPSTR NetworkAddr = NULL;
    DWORD ClientIpAddr = 0;
    ULONG Error = 0;

    //
    // Exactly one OPTIONAL parameter is required
    //
    ASSERT(  ((NULL == BindingHandle) && (NULL != UserHandle))
          || ((NULL != BindingHandle) && (NULL == UserHandle)) );

    // 
    // Get the RPC binding handle from the context handle.
    //
    // N.B. The handle returned by RpcSsGetContextBinding is valid for the 
    //      lifetime of UserHandle.  It does not need to be closed.
    //
    if (UserHandle) {
        Error = RpcSsGetContextBinding(UserHandle, &ClientBinding);
        if (Error) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: RpcSsGetContextBinding failed %d\n", Error));
            goto Cleanup;
        }
    } else {
        ClientBinding = BindingHandle;
    }

    //
    // Derive a partially bound handle with the client's network address.
    //
    Error = RpcBindingServerFromClient(ClientBinding, &ServerBinding);
    if (Error) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RpcBindingServerFromClient failed %d\n",
                   Error));
        goto Cleanup;
    }

    //
    // Convert binding handle into string form, which contains, amongst
    // other things, the network address of the client.
    //
    Error = RpcBindingToStringBindingA(ServerBinding, &StringBinding);
    if (Error) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RpcBindingToStringBinding failed %d\n",
                   Error));
        goto Cleanup;
    }

    //
    // Parse out the network address.
    //
    Error = RpcStringBindingParseA(StringBinding,
                                   NULL,
                                   NULL,
                                   &NetworkAddr,
                                   NULL,
                                   NULL);
    if (Error) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RpcStringBindingParse failed %d\n",
                   Error));
        goto Cleanup;
    }

    //
    // Extract the Ip Address, if any
    //
    ClientIpAddr = inet_addr(NetworkAddr);
    if (0 != ClientIpAddr) {
        Context->TypeBody.User.ClientInfo.Type = SamClientIpAddr;
        Context->TypeBody.User.ClientInfo.Data.IpAddr = ClientIpAddr;
    }

Cleanup:

    if (NetworkAddr) {
        RpcStringFreeA(&NetworkAddr);
    }
    if (StringBinding) {
        RpcStringFreeA(&StringBinding);
    }
    if (ServerBinding) {
        RpcBindingFree(&ServerBinding);
    }

    return I_RpcMapWin32Status(Error);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\string.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    string.c

Abstract:

    This file contains services for retrieving and replacing string field
    values.


Author:

    Jim Kelly    (JimK)  10-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampGetUnicodeStringField(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING SubKeyName,
    OUT PUNICODE_STRING *String
    )

/*++

Routine Description:

    This service retrieves a unicode string from a named sub-key of
    the root key provided in the Context argument.

    The returned unicode string is returned in two buffers allocated
    using MIDL_user_allocate() and are therefore suitable for returning as
    [out] parameters of an RPC call.  The first buffer will be the unicode
    string body.  The second buffer will contain the unicode string
    characters and will include 2 bytes of zeros.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    Context - Pointer to an active context block whose RootKey is valid.

    SubKeyName - The name of the sub-key containing the unicode string
        to retrieve.

    String - Receives a pointer to a set of allocated buffers containing
        the unicode string.  The buffers are allocated using
        MIDL_userAllocate().  If any errors are returned, these buffers
        will not be allocated.

Return Value:


    STATUS_SUCCESS - The string value has been successfully retrieved.

    STATUS_NO_MEMORY - There was insufficient memory to allocate a
        buffer to read the unicode string into.

    STATUS_INTERNAL_ERROR - The value of the sub-key seems to have changed
        during the execution of this service.  This should not happen since
        the service must be called with the WRITE LOCK held.

    Other error values are those returned by:

            NtQueryValueKey()


--*/
{

    NTSTATUS NtStatus, IgnoreStatus;
    HANDLE SubKeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG StringLength, ActualStringLength, IgnoreKeyValueType;
    PUNICODE_STRING StringBody;
    PCHAR CharacterBuffer;
    LARGE_INTEGER LastWriteTime;

    SAMTRACE("SampGetUnicodeStringField");

    //
    // Prepare for failure
    //

    *String = NULL;


    //
    // Open the named sub-key ...
    //

    InitializeObjectAttributes(
        &ObjectAttributes,          // Resultant object attributes
        SubKeyName,                 // Relative Name
        OBJ_CASE_INSENSITIVE,       // Attributes
        Context->RootKey,           // Parent key handle
        NULL                        // SecurityDescriptor
        );

    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(       // Don't use NtCreateKey() - it must already exist
                   &SubKeyHandle,
                   KEY_READ,
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }



    //
    // Query the length of the unicode string in the sub-key
    //

    NtStatus = RtlpNtQueryValueKey(
                   SubKeyHandle,
                   &IgnoreKeyValueType,
                   NULL,                    // No buffer yet
                   &StringLength,
                   &LastWriteTime
                   );

    SampDumpRtlpNtQueryValueKey(&IgnoreKeyValueType,
                                NULL,
                                &StringLength,
                                &LastWriteTime);

    if (!NT_SUCCESS(NtStatus)) {
        IgnoreStatus = NtClose( SubKeyHandle );
        return(NtStatus);
    }



    //
    // Allocate buffers for both the string body and the
    // character buffer.
    //

    CharacterBuffer = MIDL_user_allocate( StringLength + sizeof(UNICODE_NULL) );
    StringBody      = MIDL_user_allocate( sizeof(UNICODE_STRING) );

    if ((CharacterBuffer == NULL) || (StringBody == NULL)) {

        //
        // We couldn't allocate pool ...
        //

        IgnoreStatus = NtClose( SubKeyHandle );

        if (CharacterBuffer != NULL) {
            MIDL_user_free( CharacterBuffer );
        }
        if (StringBody != NULL) {
            MIDL_user_free( StringBody );
        }

        return(STATUS_NO_MEMORY);
    }



    //
    // Initialize the string body
    //

    StringBody->Length        = (USHORT)StringLength;
    StringBody->MaximumLength = (USHORT)StringLength + (USHORT)sizeof(UNICODE_NULL);
    StringBody->Buffer        = (PWSTR)CharacterBuffer;

    //
    // Read the string value into the character buffer.
    //

    NtStatus = RtlpNtQueryValueKey(
                   SubKeyHandle,
                   &IgnoreKeyValueType,
                   CharacterBuffer,
                   &ActualStringLength,
                   &LastWriteTime
                   );

    SampDumpRtlpNtQueryValueKey(&IgnoreKeyValueType,
                                CharacterBuffer,
                                &ActualStringLength,
                                &LastWriteTime);

    if (NT_SUCCESS(NtStatus)) {
        if (ActualStringLength != StringLength) {

            //
            // Hmmm - we just queuried the length and got StringLength.
            //        Then we read the buffer and its different, yet the
            //        whole time we've held the write lock.  Something
            //        has messed up our database.
            //

            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }

    if (!NT_SUCCESS(NtStatus)) {

        IgnoreStatus = NtClose( SubKeyHandle );

        MIDL_user_free( CharacterBuffer );
        MIDL_user_free( StringBody );

        return(NtStatus);
    }


    //
    // Null terminate the string
    //

    UnicodeTerminate(StringBody);
    *String = StringBody;

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\syskey.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    syskey.c

Abstract:

    This file contains services related to syskeying the machine.


Author:

    Murli Satagopan    (MurliS)  1 October 1998

Environment:

    User Mode - Win32

Revision History:

   
--*/
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <ntlsa.h>
#include "lmcons.h"                                    // LM20_PWLEN
#include "msaudite.h"
#include <nlrepl.h>                   // I_NetNotifyMachineAccount prototype
#include <ridmgr.h>
#include <enckey.h>
#include <wxlpc.h>
#include <cryptdll.h>
#include <pek.h>
#include "sdconvrt.h"
#include "dslayer.h"
#include <samtrace.h>

BOOLEAN
SampIsMachineSyskeyed();

NTSTATUS
SampUpdateEncryption(
    IN SAMPR_HANDLE ServerHandle
    );

BOOLEAN
SampSyskeysAreInconsistent = FALSE;


NTSTATUS
SampClearPreviousPasswordEncryptionKey(
   IN PSAMP_OBJECT DomainContext,
   PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  WriteLockHeld = FALSE;
    SAMP_OBJECT_TYPE FoundType;
    BOOLEAN  ContextReferenced = FALSE;

    
    Status = SampAcquireWriteLock();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    WriteLockHeld = TRUE;

    //
    // Reference the context
    //

    Status = SampLookupContext(
                DomainContext,
                0,
                SampDomainObjectType,           // ExpectedType
                &FoundType
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    ContextReferenced = TRUE;

    V1aFixed->PreviousKeyId = 0;

    //
    // Store them back to the in memory context
    //

    Status = SampSetFixedAttributes(
                DomainContext,
                V1aFixed
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = SampStoreObjectAttributes(
                DomainContext,
                TRUE // Use the existing key handle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // We don't want these changes replicated so set transaction within
    // domain to be false.
    //

    SampSetTransactionWithinDomain(FALSE);

    //
    // Commit the changes. We have to munch with the defined domains
    // because they are only updated on a transaction within a domain
    // and we don't want a transaction within a domain.
    //

    Status = SampDeReferenceContext(DomainContext, TRUE);
    ContextReferenced = FALSE;

    Status = SampCommitAndRetainWriteLock();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Update in memory state
    //

    RtlCopyMemory(
        &SampDefinedDomains[DomainContext->DomainIndex].UnmodifiedFixed,
        V1aFixed,
        sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)
        );

    SampPreviousKeyId = 0;

Cleanup:

    if (ContextReferenced)
    {
        SampDeReferenceContext(DomainContext,FALSE);
    }

    if (WriteLockHeld)
    {
        SampReleaseWriteLock(FALSE);
    }

    return(Status);
}

NTSTATUS
SampPerformSyskeyAccessCheck(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING OldBootKey,
    IN PRPC_UNICODE_STRING NewBootKey
    )
{
    PSAMP_OBJECT DomainContext = NULL;
    SAMP_OBJECT_TYPE FoundType;
    NTSTATUS     Status = STATUS_SUCCESS;
    NTSTATUS     IgnoreStatus,TempStatus;

    //
    // Acquire the read Lock
    //

    SampAcquireReadLock();

    //
    // Reference the domain handle, once so that an 
    // access check can be enforced; the check enforces that the 
    // handle passed in by the client was opened with 
    // DOMAIN_WRITE_PASSWORD_PARAMS
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    Status = SampLookupContext(
                DomainContext,
                DOMAIN_WRITE_PASSWORD_PARAMS,
                SampDomainObjectType,           // ExpectedType
                &FoundType
                );

    if (NT_SUCCESS(Status))
    {

        //
        // If that passed, now validate that the old syskey 
        // passed in genuine.
        //

        KEEncKey EncryptedPasswordEncryptionKey;
        KEClearKey DecryptionKey;
        ULONG      DecryptStatus;
        KEClearKey SessionKey;

        RtlCopyMemory(
            &EncryptedPasswordEncryptionKey,
            SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].UnmodifiedFixed.DomainKeyInformation,
            sizeof(EncryptedPasswordEncryptionKey)
            );

        DecryptionKey.dwLength = sizeof(KEClearKey);
        DecryptionKey.dwVersion = KE_CUR_VERSION;

            
        RtlCopyMemory(
            DecryptionKey.ClearKey,
            OldBootKey->Buffer,
            KE_KEY_SIZE
            );

        DecryptStatus = KEDecryptKey(
                            &DecryptionKey,
                            &EncryptedPasswordEncryptionKey,
                            &SessionKey,
                            0                   // flags
                            );

        if (KE_OK!=DecryptStatus)
        {
            Status = STATUS_WRONG_PASSWORD;
        }

        RtlZeroMemory(&SessionKey,sizeof(SessionKey));
        
        //
        // Dereference the context. Do not commit
        //

        IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);
    }

    SampReleaseReadLock();

    return(Status);
}

NTSTATUS
SampChangeSyskeyInDs(
    IN WX_AUTH_TYPE BootOptions,
    IN PRPC_UNICODE_STRING NewBootKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS TempStatus;

    //
    // Begin a DS transaction to set the information in the DS.
    //

    Status = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // Make the change in the DS.
    //

    Status = DsChangeBootOptions(
                (WX_AUTH_TYPE)BootOptions,
                0,
                NewBootKey->Buffer,
                NewBootKey->Length
                );

    //
    // Commit or rollback the change in the DS.
    //

    TempStatus = SampMaybeEndDsTransaction(
                    (NT_SUCCESS(Status)) ? 
                     TransactionCommit:TransactionAbort
                     );


    if (!NT_SUCCESS(Status))
    {
        Status = TempStatus;
    }

    return(Status);
}


NTSTATUS
SampSetBootKeyInformationInRegistrySAM(
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PRPC_UNICODE_STRING OldBootKey OPTIONAL,
    IN PRPC_UNICODE_STRING NewBootKey,
    IN BOOLEAN EnablingEncryption,
    IN BOOLEAN ChangingSyskey,
    IN BOOLEAN ChangingPasswordEncryptionKey,
    OUT PUNICODE_STRING NewEncryptionKey
    )
/*++

  Routine Description:

    This routine is used to change the syskey, or password encryption 
    key in registy SAM. It is also used to enable syskey encryption
    in registy SAM

  Arguments:

    BootOptions - Boot options to store, may be:
        SamBootKeyNone - don't do any special encryption of secrets
        SamBootKeyStored - Store a password somewhere which is used for
            encrypting secrets
        SamBootKeyPassword - Prompt the user for a password boot key.
        SamBootKeyDisk - Store the boot key on a disk.
        SamBootKeyChangePasswordEncryptionKey -- change the password encryption keys
    OldBootKey - When changing the boot key this contains the old boot key.
    NewBootKey - When setting or changing the boot key this contains the
        new boot key.

    EnablingEncryption -- Set to true when we are enabling syskey by default.
                          In this condition we should not call LSA ( LSA should
                          already be syskey'd ).

    ChangingSyskey     -- Set to true to indicate that the operation requested by 
                          the client is to change the syskey

    ChangingPasswordEncryptionKey -- Set to true to indicate that the operation requested
                          by the client is to change the password encryption key

    NewEncryptionKey   -- If a new password encryption key were generated, this parameter
                          returns in the clear


  Return Values:

    STATUS_SUCCESS - The call succeeded.
    STATUS_INVALID_PARAMETER - The mix of parameters was illegal, such as
       not providing a new password when enabling encryption

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT DomainContext = NULL;
    ULONG DomainIndex = 0;
    SAMP_OBJECT_TYPE FoundType;
    USHORT DomainKeyAuthType = 0;
    USHORT DomainKeyFlags = 0;
    BOOLEAN ChangingType = FALSE;
    KEClearKey OldInputKey;
    KEClearKey InputKey;
    KEClearKey PasswordEncryptionKey;
    KEEncKey EncryptedPasswordEncryptionKey;
    ULONG KeStatus;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed = NULL;
    BOOLEAN     ContextReferenced = FALSE;
    BOOLEAN     UpdateEncryption = FALSE;
    BOOLEAN     RXactActive = FALSE;
    BOOLEAN     WriteLockHeld = FALSE; 


    //
    // Convert the boot option to an auth type
    //

    DomainKeyFlags = SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED;
    DomainKeyAuthType = (USHORT) BootOptions;

    //
    // If this is a change of the password encryption key and a previous
    // attempt at changing the password encryption key has failed, then
    // first attempt to get all user accounts to the latest key before
    // proceeding on changing the password encryption key.
    //

    if ((0!=SampPreviousKeyId) && (ChangingPasswordEncryptionKey))
    {
        Status = SampUpdateEncryption(NULL);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Acquire the SAM Write Lock; In Registry mode this starts a registry
    // transaction.
    //

    Status = SampAcquireWriteLock();
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    WriteLockHeld = TRUE;

    if (SampUseDsData)
    { 
        // 
        // In DS mode begin a Registry transaction by hand -acquire lock 
        // will not do because we are in DS mode. We will use this registry
        // transaction to update the key information in the safe boot hive
        //

        Status = RtlStartRXact( SampRXactContext );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        RXactActive = TRUE;
    }

    //
    // Use the domain context in SampDefinedDomains. Using the defined domains below will result
    // in safe boot context in DS mode, and a normal domain context in DS mode. The code below
    // will apply the new syskey to the regular SAM hive on workstations and servers and to the 
    // the safe boot hive in DS mode.
    //

    DomainContext = (SAMPR_HANDLE) 
                        SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].Context;
    

    //
    // Reference the context; we have already performed an access check, so O.K to pass in a 0 for
    // desired options.
    //

    Status = SampLookupContext(
                DomainContext,
                0,
                SampDomainObjectType,           // ExpectedType
                &FoundType
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    ContextReferenced = TRUE;

    DomainIndex = DomainContext->DomainIndex;

    //
    // We don't want this change to replicate to NT 4.0 BDC's. Normally in registry mode there
    // are no NT 4.0 BDC's to worry about and in DS mode generally the serial # and change log
    // is managed through notifications by the DS. However there is one important special case
    // in the system -- this is the case of GUI setup when upgrading from an NT 4.0 DC. In this
    // instance, we are still registry mode ( DS is created on subsequent dcpromo ), and having
    // SampTransactionWithinDomain set will cause change notifications to the netlogon.log
    //

    SampSetTransactionWithinDomain(FALSE);

    //
    // Get the fixed length data for the domain so we can modify it.
    //

    Status = SampGetFixedAttributes(
                DomainContext,
                TRUE, // make copy
                (PVOID *)&V1aFixed
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
     
    //
    // Initialize input key to be the new syskey
    //

    RtlZeroMemory(
        &InputKey,
        sizeof(KEClearKey)
        );

    InputKey.dwVersion = KE_CUR_VERSION;
    InputKey.dwLength = sizeof(KEClearKey);
    RtlCopyMemory(
        InputKey.ClearKey,
        NewBootKey->Buffer,
        NewBootKey->Length
        );

    //
    // Intiialized old input key to be the old syskey
    // Note: We have already verified at this point that the
    // old syskey is present for all cases except the case
    // where the system is enabling encryption for the first
    // time.
    //

    RtlZeroMemory(
            &OldInputKey,
            sizeof(KEClearKey)
            );

    if (ARGUMENT_PRESENT(OldBootKey))
    {

        OldInputKey.dwVersion = KE_CUR_VERSION;
        OldInputKey.dwLength = sizeof(KEClearKey);

        RtlCopyMemory(
            OldInputKey.ClearKey,
            OldBootKey->Buffer,
            OldBootKey->Length
            );
    }

    //
    // Check to see if they are setting or changing a password
    // or wanting to change password encryption keys.
    //

    if (ChangingSyskey) {
        
        //
        // Get the old information out of the domain structures
        //

        RtlCopyMemory(
            &EncryptedPasswordEncryptionKey,
            V1aFixed->DomainKeyInformation,
            sizeof(KEEncKey)
            );

        //
        // Re-encrypt the domain structures with the new syskey
        // provided.
        // 

        ASSERT(ARGUMENT_PRESENT(OldBootKey));

        KeStatus = KEChangeKey(
                        &OldInputKey,
                        &InputKey,
                        &EncryptedPasswordEncryptionKey,
                        0                       // no flags
                        );
        if (KeStatus == KE_BAD_PASSWORD) {
            Status = STATUS_WRONG_PASSWORD;
            goto Cleanup;
        }
        if (KeStatus != KE_OK) {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        //
        // if the boot option type is being changed then,
        // update the type information in SAM
        //

        if (V1aFixed->DomainKeyAuthType != DomainKeyAuthType) {

            V1aFixed->DomainKeyAuthType = DomainKeyAuthType;
        }
    } else {
    
        //
        // Our intention is to either generate a new password encryption
        // key, or change the existing password encryption key.
        // Either way, generate the session key now.
        //

        // Note:
        // KEEncryptKey is a misnomer ... it not only encrypts the key, it
        // also generates a new key that is used to encrypt passwords. 
        //

        if (KEEncryptKey(
                &InputKey,
                &EncryptedPasswordEncryptionKey,
                &PasswordEncryptionKey,
                0                               // no flags
                ) != KE_OK) 
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }


        if (ARGUMENT_PRESENT(NewEncryptionKey))
        {
            NewEncryptionKey->Length = NewEncryptionKey->MaximumLength = sizeof(PasswordEncryptionKey.ClearKey);
            NewEncryptionKey->Buffer = MIDL_user_allocate(sizeof(PasswordEncryptionKey.ClearKey));
            if (NULL==NewEncryptionKey->Buffer)
            {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            RtlCopyMemory(
                NewEncryptionKey->Buffer,
                PasswordEncryptionKey.ClearKey,
                NewEncryptionKey->Length
                );
        }

        //
        // Update the boot options if we are enabling syskey
        // Leave the boot options alone if we are updating the
        // password encryption key.
        //

        if (EnablingEncryption)
        {
            V1aFixed->DomainKeyFlags = DomainKeyFlags;
            V1aFixed->DomainKeyAuthType = DomainKeyAuthType;
            V1aFixed->CurrentKeyId = 1;
            V1aFixed->PreviousKeyId = 0;
        }

        if (ChangingPasswordEncryptionKey)
        {
            //
            // If we are changing the password encryption key then
            // we need to re-encrypt all the passwords now. The 
            // algorithm that we follow is as follows
            //
            //     1. Update and roll over the key
            //     2. Write out any passwords. One or more passwords
            //        are re-written
            //
            //
            // Set the previous key value equal to the current key
            // value. Note this is a safe operation to copy the value
            // of the key before the commit, as we have already ensured
            // that we do not have any password encrypted using the 
            // the previous key value.
            //

            RtlCopyMemory(
                SampSecretSessionKeyPrevious,
                SampSecretSessionKey,
                sizeof(SampSecretSessionKey)
                );

            RtlCopyMemory(
                &V1aFixed->DomainKeyInformationPrevious,
                &V1aFixed->DomainKeyInformation,
                sizeof(V1aFixed->DomainKeyInformation)
                );

            V1aFixed->PreviousKeyId = V1aFixed->CurrentKeyId;
            V1aFixed->CurrentKeyId++;

            //
            // Set the boolean to update the encryption on all
            // passwords. After we commit this change, we will
            // re-encrypt all passwords
            //

            UpdateEncryption = TRUE; 

        }
       
    }
   
    //
    // Now update the structures we are changing.
    //

    RtlCopyMemory(
        V1aFixed->DomainKeyInformation,
        &EncryptedPasswordEncryptionKey,
        sizeof(EncryptedPasswordEncryptionKey)
        );

    //
    // Store them back to the in memory context
    //

    Status = SampSetFixedAttributes(
                DomainContext,
                V1aFixed
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = SampStoreObjectAttributes(
                DomainContext,
                TRUE // Use the existing key handle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // We don't want these changes replicated so set transaction within
    // domain to be false.
    //

    SampSetTransactionWithinDomain(FALSE);

    //
    // Commit the changes. We have to munch with the defined domains
    // because they are only updated on a transaction within a domain
    // and we don't want a transaction within a domain.
    //

    Status = SampDeReferenceContext(DomainContext, TRUE);
    ContextReferenced = FALSE;
    
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

   
        
    if (SampUseDsData)
    {
        //
        // In DS mode , commit the registry transaction by hand
        // as CommitAndRetainWriteLock will not commit the write
        // lock.
        //

        Status = RtlApplyRXact(SampRXactContext);
        RXactActive = FALSE;

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Commit the changes, requesting an immediate flush.
    // Note the write lock is still being retained after the commit
    // to update in memory state
    //
      
    FlushImmediately = TRUE;
    Status = SampCommitAndRetainWriteLock();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Copy the new data into the in-memory object now that it has been
    // committed to disk.
    //

    RtlCopyMemory(
        &SampDefinedDomains[DomainIndex].UnmodifiedFixed,
        V1aFixed,
        sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)
        );

    //
    // Update the new password encryption key in memory
    //

    if (EnablingEncryption || ChangingPasswordEncryptionKey)
    {
        RtlCopyMemory(
            SampSecretSessionKey,
            PasswordEncryptionKey.ClearKey,
            sizeof(PasswordEncryptionKey.ClearKey)
            );
    }

    SampCurrentKeyId = V1aFixed->CurrentKeyId;
    SampPreviousKeyId = V1aFixed->PreviousKeyId;

    //
    // Release the Write Lock
    //

    SampReleaseWriteLock(FALSE);
    WriteLockHeld = FALSE;
    
    //
    // Changes have been committed at this point, if required update encryption
    //

    if (UpdateEncryption)
    {
        //
        // We don't allow this operation in DS mode.
        //

        ASSERT(!SampUseDsData);

        Status = SampUpdateEncryption(NULL);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // At this point, we have written out the new key, the previous key and updated
        // the encryption. It is now time to clear out the previous key
        //

        Status = SampClearPreviousPasswordEncryptionKey(
                        DomainContext,
                        V1aFixed
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

Cleanup:
  
    //
    // Otherwise rollback any changes
    //

    if ((DomainContext != NULL) && (ContextReferenced)) {
        (VOID) SampDeReferenceContext(DomainContext, FALSE);
    }

    //
    // If we are in DS mode then abort the registry transaction by Hand
    //

    if (RXactActive)
    {
       RtlAbortRXact( SampRXactContext );
       RXactActive = FALSE;
    }


    if (WriteLockHeld)
    {
        SampReleaseWriteLock(FALSE);
    }

    RtlZeroMemory(
        &InputKey,
        sizeof(InputKey)
        );

    RtlZeroMemory(
        &OldInputKey,
        sizeof(OldInputKey)
        );

    if (V1aFixed != NULL) {
        MIDL_user_free(V1aFixed);
    }
 
    return(Status);
    
}


NTSTATUS
SampSetBootKeyInformation(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PRPC_UNICODE_STRING OldBootKey OPTIONAL ,
    IN PRPC_UNICODE_STRING NewBootKey,
    IN BOOLEAN SuppressAccessCk,
    IN BOOLEAN EnablingSyskey,
    IN BOOLEAN ChangingSyskey,
    IN BOOLEAN ChangingPasswordEncryptionKey,
    OUT PUNICODE_STRING NewEncryptionKey OPTIONAL,
    OUT BOOLEAN * SyskeyChangedInLsa
    )
/*++

Routine Description:

    This routine enables secret data encryption and sets the flag indicating
    how the password is obtained. If we weren't previously encrypting
    secret data then NewBootKey must not be NULL. If we were already
    encrypting secret data and NewBootKey is non-null then we are changing
    the password and OldBootKey must be non-null.

    You can't disable encryption after enabling it.


Arguments:

    DomainHandle - Handle to a domain object open for DOMAIN_WRITE_PASSWORD_PARAMS.
    BootOptions - Boot options to store, may be:
        SamBootKeyNone - don't do any special encryption of secrets
        SamBootKeyStored - Store a password somewhere which is used for
            encrypting secrets
        SamBootKeyPassword - Prompt the user for a password boot key.
        SamBootKeyDisk - Store the boot key on a disk.
    OldBootKey - When changing the boot key this contains the old boot key.
    NewBootKey - When setting or changing the boot key this contains the
        new boot key.

    SuppressAccessCk   -- Set to true when called from an inprocess caller, to 
                          suppress the ck on the domain handle
    EnablingEncryption -- Set to true when we are enabling syskey by default.
                          In this condition we should not call LSA ( LSA should
                          already be syskey'd ).

    ChangingSyskey     -- Set to true to indicate that the operation requested by 
                          the client is to change the syskey

    ChangingPasswordEncryptionKey -- Set to true to indicate that the operation requested
                          by the client is to change the password encryption key

    NewEncryptionKey   -- If a new password encryption key were generated, this parameter
                          returns in the clear

    SyskeyChangedInLsa -- TRUE if the syskey was changed in LSA. This is used in error
                          handling, as the syskey could have been changed in LSA, but then
                          not changed in SAM/ DS.

Return Value:

    STATUS_SUCCESS - The call succeeded.
    STATUS_INVALID_PARAMETER - The mix of parameters was illegal, such as
       not providing a new password when enabling encryption

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT DomainContext = NULL;
    ULONG DomainIndex = 0;
    SAMP_OBJECT_TYPE FoundType;

    //
    // Initialize return values
    //

    *SyskeyChangedInLsa = FALSE;

    //
    // On a domain controller when we syskey we change state in the DS,
    // as well in the registry for the safe mode hives. If a domain controller
    // is booted into safe mode we will not allow the syskey settings to be
    // changed.
    //

    if (LsaISafeMode())
    {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // if SAM and LSA syskey's are inconsistent then fail the call,
    // no further syskey change is allowed till reboot. Syskey's could
    // become inconsistent, if a previous call to this routine, changed
    // the syskey value in LSA, but not in SAM. The syskey logic maintains
    // the old syskey, encrypted with the new syskey, so there is recovery possible
    // for one failure, but not further; till the next reboot. The condition 
    // below ensures that subsequent requests to change the syskey will be failed
    // till the reboot if one failure occurs.
    //

    if (SampSyskeysAreInconsistent)
    {
        return STATUS_INVALID_SERVER_STATE;
    }

    //
    // We don't allow changing of password encryption keys ( presently ) on a 
    // domain controller
    //

    if ((SampUseDsData) && (ChangingPasswordEncryptionKey))
    {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // If a previous password encryption key change was attempted and was unsuccessful,
    // then block a subsequent syskey change till the password encryption key change
    // is successful
    //

    if ((0!=SampPreviousKeyId) && (ChangingSyskey))
    {
        return STATUS_INVALID_SERVER_STATE;
    }


    //
    // Validate the boot options
    //

    switch(BootOptions) {
    case SamBootKeyStored:
    case SamBootKeyPassword:
    case SamBootKeyDisk:
        
        //
        // These 3 options are used to change how the syskey is supplied
        // at startup.
        //

    case SamBootChangePasswordEncryptionKey:
        
        //
        // This option implies a change of the password encryption keys
        //
        break;

        //
        // SamBootKeyNone was used in NT 4.0 to denote a machine that is
        // not syskey'd. In w2k and whistler we are always syskey'd, so
        //
    case SamBootKeyNone:
    default:
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If the new NewBootKey is not specified then fail the call
    // with STATUS_INVALID_PARAMETER. Since we are syskey'd by default
    // this parameter must be supplied. The NewBootKey parameter in this
    // function is a new syskey. Since we do not support a mode where
    // we are not syskey'd or allow the caller to remove syskey, therefore
    // fail the call now.
    //

    if ((NULL==NewBootKey) || (NewBootKey->Length > KE_KEY_SIZE))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If encryption is already enabled and they haven't provided
    // an old syskey, fail now.
    //

    if (!EnablingSyskey) {
        if (!ARGUMENT_PRESENT(OldBootKey)) {
             Status = STATUS_INVALID_PARAMETER;
            return(STATUS_INVALID_PARAMETER);
        } else if (OldBootKey->Length != KE_KEY_SIZE) {
            Status = STATUS_INVALID_PARAMETER;
            return(STATUS_INVALID_PARAMETER);
        }
    }

    //
    // The caller can do only one of 3 things -- EnablingSyskey, ChangingSyskey
    // or ChangingPasswordEncryptionKey. Check that the caller is indeed 
    // requesting exactly one of these operations
    //

    if (EnablingSyskey ) {
        if (ChangingSyskey ||ChangingPasswordEncryptionKey) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    else if (ChangingSyskey) {
        if (ChangingPasswordEncryptionKey) { 
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    else if (!ChangingPasswordEncryptionKey) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Perform an access ck first. The caller can request a suppression
    // of an access check. This happens only at boot time, where it is the
    // system that is wanting to syskey the machine and hence suppresses 
    // the access check. Syskey Access check verfies that the caller has
    // write rights on domain password parameters and also does an authentication
    // check that the old syskey passed in checks out O.K
    //

    if (!SuppressAccessCk)
    {
        Status = SampPerformSyskeyAccessCheck(
                        DomainHandle,
                        OldBootKey,
                        NewBootKey
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }        
    }

    //
    // First Set the boot key and Boot option in the LSA.
    //

    if (ChangingSyskey)
    {

        Status = LsaISetBootOption(
                    BootOptions,
                    OldBootKey->Buffer,
                    OldBootKey->Length,
                    NewBootKey->Buffer,
                    NewBootKey->Length
                    );

        if (NT_SUCCESS(Status))
        {
            //
            // If the syskey was changed in the LSA, return that
            // info to the caller. For client initiated call, we
            // are not allowed to fail the client RPC call, if the
            // syskey has been changed in LSA
            //

            *SyskeyChangedInLsa = TRUE;
        }
    }
    else if (ChangingPasswordEncryptionKey)
    {
        Status = LsaIChangeSecretCipherKey(
                    NewBootKey->Buffer
                    );
    }


    //
    // If Change in LSA was failed bail now. Note recovery is still
    // possble if the change in LSA succeeds, but changes in SAM or
    // DS are failed. The reason for this is that we store the old
    // syskey in lsa, and at boot time know to retry with the older
    // key.
    //

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Next change the syskey in the DS. If the DS operation succeeds
    // then proceed on to changing the syskey in SAM. If the DS 
    // option fails, then bail right now. The error handling comment 
    // above will apply. No Syskey change in DS is attempted if this
    // is not DS mode.
    //

    if ((SampUseDsData ) &&
       (ChangingSyskey || EnablingSyskey))
    {

        Status = SampChangeSyskeyInDs(
                    (WX_AUTH_TYPE) BootOptions,
                    NewBootKey
                    );
        //
        // Bail right away if DS failed
        //

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // At this point syskey has been changed in LSA, and the DS. The syskey
    // needs to be changed in Registry SAM. In DS mode these are the SAM
    // hives used for restore mode.
    //

    Status = SampSetBootKeyInformationInRegistrySAM(
                    BootOptions,
                    OldBootKey,
                    NewBootKey,
                    EnablingSyskey,
                    ChangingSyskey,
                    ChangingPasswordEncryptionKey,
                    NewEncryptionKey
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:

    if (ARGUMENT_PRESENT(NewBootKey) && (NewBootKey->Buffer != NULL)) {
        RtlZeroMemory(
            NewBootKey->Buffer,
            NewBootKey->Length
            );
    }

    if (ARGUMENT_PRESENT(OldBootKey) && (OldBootKey->Buffer != NULL)) {
        RtlZeroMemory(
            OldBootKey->Buffer,
            OldBootKey->Length
            );
    }

    return(Status);

    
}

NTSTATUS
SamrSetBootKeyInformation(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PRPC_UNICODE_STRING OldBootKey OPTIONAL ,
    IN PRPC_UNICODE_STRING NewBootKey OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  fSyskeyChangedInLsa = FALSE;


    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetBootKeyInformation
                   );

    //
    // Since we are syskey'd by default on a w2k server, old and new keys
    // must be supplied
    //

    if (  (OldBootKey == NULL) ||
          (OldBootKey->Length != KE_KEY_SIZE) || 
          (OldBootKey->Buffer == NULL)  ||
          (NewBootKey == NULL) ||
          (NewBootKey->Length != KE_KEY_SIZE) ||
          (NewBootKey->Buffer == NULL) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Error;
        
    }

    Status = SampSetBootKeyInformation(
                DomainHandle,
                BootOptions,
                OldBootKey,
                NewBootKey,
                FALSE, // suppress access check
                FALSE, // Enabling syskey
                (SamBootChangePasswordEncryptionKey!=BootOptions),  // Changing syskey
                (SamBootChangePasswordEncryptionKey==BootOptions),  // Changing password encryption key
                NULL, 
                &fSyskeyChangedInLsa
                );

    //
    // If the syskey was changed in lsa but not in SAM/DS the above call will fail, but the boolean
    // fSyskeyChangedInLsa will be true. In that case we are not allowed to fail this call.
    //

    if (fSyskeyChangedInLsa)
    {
        if (!NT_SUCCESS(Status))
        {
            //
            // if the syskey was changed in LSA and not in SAM, then block
            // further changes to the syskey. This is because SAM can recover
            // only if the syskey is out of date by just one key 
            // This blocking is implemented by setting the global boolean
            // Reboot would clear the boolean as well as set the recovery 
            // logic.
            //
            SampSyskeysAreInconsistent = TRUE;
        }
        Status = STATUS_SUCCESS;
    }

Error:

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetBootKeyInformation
                   );

    return(Status);
}


NTSTATUS
SamIGetBootKeyInformation(
    IN SAMPR_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    )
/*++

Routine Description:

    This routine returns the boot options for the domain. It is only
    valid when called from the AccountDomain.


Arguments:

    DomainHandle - Handle to the account domain object open for
        DOMAIN_READ_PASSWORD_PARAMETERS
    BootOptions - Receives the boot options from the domain.


Return Value:

    STATUS_SUCCESS - The call succeeded.

--*/
{
    NTSTATUS Status;
    PSAMP_OBJECT DomainContext;
    ULONG DomainIndex;
    SAMP_OBJECT_TYPE FoundType;

    //
    // Not Supported in DS Mode
    //

    if (TRUE==SampUseDsData)
    {
        *BootOptions = DsGetBootOptions();
        return STATUS_SUCCESS;
    }


   

    SampAcquireReadLock();
    
    if (0!=DomainHandle)
    {

        DomainContext = (PSAMP_OBJECT)DomainHandle;
    }
    else
    {
        DomainContext = SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].Context;
    }

    Status = SampLookupContext(
                DomainContext,
                DOMAIN_READ_PASSWORD_PARAMETERS,
                SampDomainObjectType,           // ExpectedType
                &FoundType
                );
    if (!NT_SUCCESS(Status)) {
        DomainContext = NULL;
        goto Cleanup;
    }

    //
    // Verify that the caller passed in the correct domain handle
    //

    DomainIndex = DomainContext->DomainIndex;

    *BootOptions = (SAMPR_BOOT_TYPE) SampDefinedDomains[DomainIndex].UnmodifiedFixed.DomainKeyAuthType;

Cleanup:
    
    if (DomainContext != NULL) {

        (VOID) SampDeReferenceContext( DomainContext, FALSE );
    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();

    return(Status);
}

NTSTATUS
SamrGetBootKeyInformation(
    IN SAMPR_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    )
/*++

Routine Description:

    This routine returns the boot options for the domain. It is only
    valid when called from the AccountDomain.


Arguments:

    DomainHandle - Handle to the account domain object open for
        DOMAIN_READ_PASSWORD_PARAMETERS
    BootOptions - Receives the boot options from the domain.


Return Value:

    STATUS_SUCCESS - The call succeeded.

--*/
{
    NTSTATUS Status;
    PSAMP_OBJECT DomainContext;
    ULONG DomainIndex;
    SAMP_OBJECT_TYPE FoundType;
    ULONG            LsaBootType;

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetBootKeyInformation
                   );

   
    SampAcquireReadLock();
    
   
    DomainContext = (PSAMP_OBJECT)DomainHandle;
   
    Status = SampLookupContext(
                DomainContext,
                DOMAIN_READ_PASSWORD_PARAMETERS,
                SampDomainObjectType,           // ExpectedType
                &FoundType
                );
    if (!NT_SUCCESS(Status)) {
        DomainContext = NULL;
        goto Cleanup;
    }

    Status = LsaIGetBootOption(&LsaBootType);

    if (NT_SUCCESS(Status))
    {
        *BootOptions = (SAMPR_BOOT_TYPE)LsaBootType;
    }

Cleanup:
    
    if (DomainContext != NULL) {

        (VOID) SampDeReferenceContext( DomainContext, FALSE );
    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetBootKeyInformation
                   );

    return(Status);
}

NTSTATUS
SampApplyDefaultSyskey()

/*++

  Routine Description

    This routine changes the system such that the system is syskey'd so that
    the system stores the key ( scattered in the registry ). It first checks
    the system state before it embarks on syskey'ing the system

--*/
{
    UCHAR Syskey[16]; // the syskey is 128 bits in size
    ULONG SyskeyLength = sizeof(Syskey);
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RPC_UNICODE_STRING NewBootKey;
    UNICODE_STRING     PasswordEncryptionKey;
    BOOLEAN            fSyskeyChangedInLsa = FALSE;
    
  


    //
    // First Check to see if the machine is syskey'd
    //

     if (!SampIsMachineSyskeyed() && !LsaISafeMode())
    {
        
        // Set the upgrade flag
        SampUpgradeInProcess = TRUE;



        //
        // Query the syskey from LSA.
        //

        NtStatus = LsaIHealthCheck(
                        NULL,
                        LSAI_SAM_STATE_RETRIEVE_SESS_KEY, 
                        Syskey,
                        &SyskeyLength
                        );

        if (!NT_SUCCESS(NtStatus))
        {

            //
            // This means that SAM is not syskey'd and LSA is not syskey'd. This will happen only
            // when upgrading a non syskey'd system.
            //


            //
            // Tell the LSA to generate a new Syskey and also generate its own password encryption
            // key etc.
            //

            NtStatus =  LsaIHealthCheck(
                            NULL,
                            LSAI_SAM_GENERATE_SESS_KEY, 
                            NULL,
                            0
                            );

            //
            // If that succeeded, then query the syskey from Lsa.
            //

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = LsaIHealthCheck(
                                NULL,
                                LSAI_SAM_STATE_RETRIEVE_SESS_KEY, 
                                Syskey,
                                &SyskeyLength
                                );
            }

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }

        ASSERT(SyskeyLength==sizeof(Syskey));

        

        //
        // Save it in SAM. If this operation fails, the machine is syskey with system
        // saves key, but is not syskey'd according to SAM. THe machine will still continue
        // to boot correctly as SAM will tell winlogon on next boot that all is o.k and discard
        // the passed in syskey. SAM will re syskey the machine upon next boot.
        //

        NewBootKey.Buffer = (WCHAR *) Syskey;
        NewBootKey.Length = sizeof(Syskey);
        NewBootKey.MaximumLength = sizeof(Syskey);

        NtStatus = SampSetBootKeyInformation(
                        SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].Context,
                        SamBootKeyStored,
                        NULL,
                        &NewBootKey,
                        TRUE, // Suppress access check
                        TRUE, // Enabling syskey
                        FALSE,// Changing syskey
                        FALSE,// Changing password encryption key
                        &PasswordEncryptionKey,
                        &fSyskeyChangedInLsa
                        );

       

        if (NT_SUCCESS(NtStatus))
        {
            RtlCopyMemory(
                SampSecretSessionKey, 
                PasswordEncryptionKey.Buffer, 
                PasswordEncryptionKey.Length
                );

            SampCurrentKeyId = 1;
            SampPreviousKeyId = 0;
            SampSecretEncryptionEnabled = TRUE;
        }
    }


Error:

    // Clear the upgrade flag ( it might have been set in this routine 
    SampUpgradeInProcess = FALSE;

    //
    // Clear the syskey in the LSA
    //

     LsaIHealthCheck(
                    NULL,
                    LSAI_SAM_STATE_CLEAR_SESS_KEY, 
                    NULL,
                    0
                    );

    return(NtStatus);
}



BOOLEAN
SampIsMachineSyskeyed()
{
    
    //
    // If the safe boot hive is syskey'd or registry mode is syskey'd then 
    // we are syskey'd
    //

    if ((SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX]
            .UnmodifiedFixed.DomainKeyFlags & SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED) != 0)
    {
        return (TRUE);
    }

    //
    // Else if we are in DS mode , and DS is syskey'd then we are syskey'd
    //

    if (SampUseDsData && (SamBootKeyNone!=DsGetBootOptions()))
    {
        return(TRUE);
    }



    return(FALSE);
}

NTSTATUS
SampInitializeSessionKey(
    VOID
    )
/*++

Routine Description:

    This routine initializes the session key information by reading the
    stored data from the Sam defined domains structures and decrypting
    it with the key provided by winlogon. This routine also adds a default
    syskey if it detects that the machine is not syskey'd

Arguments:



Return Value:

    TRUE - Successfully initialize the session key information.
    FALSE - Something failed during initialization

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AccountDomainIndex = -1, BuiltinDomainIndex = -1, Index;
    HANDLE WinlogonHandle = NULL;
    UCHAR PasswordBuffer[16];
    ULONG PasswordBufferSize = sizeof(PasswordBuffer);
    KEClearKey DecryptionKey;
    KEClearKey OldDecryptionKey;
    KEClearKey SessionKey;
    KEEncKey EncryptedSessionKey;
    BOOLEAN  PreviousSessionKeyExists = FALSE;
    ULONG Tries = 0;
    ULONG DecryptStatus = KE_OK;
    ULONG KeyLength;
    UNICODE_STRING NewSessionKey;
    ULONG          SampSessionKeyLength;

    
        

    //
    // In DS mode, use the safe boot account domain, in registry mode use
    // the normal account domain.
    //

    AccountDomainIndex = SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX;

    //
    // Figure out whether or not we are doing encryption.
    // If we are syskey'd then set the global SampSecretEncryption enabled
    // to true
    //

    SampSecretEncryptionEnabled = FALSE;
    if ((SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyFlags &
        SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED) != 0) {

        //
        // Set the boolean according to whether syskey encryption is
        // enabled or not.
        //

        SampSecretEncryptionEnabled = TRUE;
    }
 
    DecryptionKey.dwLength = sizeof(KEClearKey);
    DecryptionKey.dwVersion = KE_CUR_VERSION;
        
    RtlZeroMemory(
            DecryptionKey.ClearKey,
            KE_KEY_SIZE
            );

    OldDecryptionKey.dwLength = sizeof(KEClearKey);
    OldDecryptionKey.dwVersion = KE_CUR_VERSION;
        
    RtlZeroMemory(
            OldDecryptionKey.ClearKey,
            KE_KEY_SIZE
            );

    if (SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.PreviousKeyId!=0)
    {
        PreviousSessionKeyExists = TRUE;
    }

    //
    // Query the Syskey from LSA
    //

    Status = LsaIHealthCheck(
                NULL,
                LSAI_SAM_STATE_RETRIEVE_SESS_KEY, 
                DecryptionKey.ClearKey,
                &KeyLength
                );

    if (NT_SUCCESS(Status))
    {

        if (!SampSecretEncryptionEnabled)
        {
            //
            // if secret encryption is not enabled just bail.
            //

            goto Cleanup;
        }

        //
        // LSA has the key, get the key from LSA and decrypt the password encryption
        // key
        //

        //
        // Build the input parameters for the key decryption routine.
        //

        RtlCopyMemory(
            &EncryptedSessionKey,
            SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyInformation,
            sizeof(EncryptedSessionKey)
            );

        DecryptStatus = KEDecryptKey(
                            &DecryptionKey,
                            &EncryptedSessionKey,
                            &SessionKey,
                            0                   // flags
                            );

        if (KE_BAD_PASSWORD==DecryptStatus)
        {
            //
            // We have encountered a key mismatch betweeen SAM and LSA. This could be because
            // a change of syskey failed after changing the syskey in the LSA. If so retrieve
            // the old syskey from LSA and 
            //

            Status = LsaIHealthCheck(
                        NULL,
                        LSAI_SAM_STATE_OLD_SESS_KEY,
                        OldDecryptionKey.ClearKey,
                        &KeyLength
                        );

            if (NT_SUCCESS(Status))
            {
                ULONG KeStatus;

                 RtlCopyMemory(
                        &EncryptedSessionKey,
                        SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyInformation,
                        sizeof(EncryptedSessionKey)
                        );

                 DecryptStatus = KEDecryptKey(
                                    &OldDecryptionKey,
                                    &EncryptedSessionKey,
                                    &SessionKey,
                                    0                   // flags
                                    );

                 if (KE_OK==DecryptStatus)
                 {    
                      KEEncKey NewEncryptedSessionKey;


                      //
                      // Since we don't allow a syskey change after a failure to change password 
                      // encryption key and don't allow a password encryption after a failure to
                      // change syskey; we cannot be in a state where we need to recover using an
                      // old syskey and simultaneously also recover from a failure to change password
                      // encryption key, using an old password encryption key.
                      //

                      ASSERT(!PreviousSessionKeyExists);
                     
                     //
                     // We decrypted O.K with old key, change the database here; to encrypt with the new key
                     //

                      RtlCopyMemory(
                            &NewEncryptedSessionKey,
                            SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyInformation,
                            sizeof(NewEncryptedSessionKey)
                            );

                      KeStatus = KEChangeKey(
                                    &OldDecryptionKey,
                                    &DecryptionKey,
                                    &NewEncryptedSessionKey,
                                    0  // no flags
                                    );

                      //
                      // We just decrypted fine with the old key
                      //

                      ASSERT(KE_OK==KeStatus);


                     //
                     // Now update the structures we are changing.
                     //

                     Status = SampAcquireWriteLock();
                     if (!NT_SUCCESS(Status))
                     {
                         goto Cleanup;
                     }

                     SampSetTransactionDomain(AccountDomainIndex);

                     RtlCopyMemory(
                        SampDefinedDomains[AccountDomainIndex].CurrentFixed.DomainKeyInformation,
                        &NewEncryptedSessionKey,
                        sizeof(NewEncryptedSessionKey)
                        );

                    //
                    // Commit the change
                    //

                    Status = SampReleaseWriteLock(TRUE);
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }
                   
                }
                else
                {
                    ASSERT(FALSE && "Syskey Mismatch");
                    Status = STATUS_UNSUCCESSFUL;
                    goto Cleanup;
                    
                }
            }
        }
        else if (DecryptStatus !=KE_OK)
        {
            ASSERT(FALSE && "Syskey Mismatch");
            Status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        //
        // If we are here then the key has been encrypted correctly
        // either by new or old syskey.
        //

        RtlCopyMemory(
            SampSecretSessionKey,
            SessionKey.ClearKey,
            KE_KEY_SIZE
            );

        //
        // Get the previous session key  
        //

        if (PreviousSessionKeyExists)
        {
             KEEncKey EncryptedSessionKeyPrevious;
             KEClearKey SessionKeyPrevious;
             ULONG      TempDecryptStatus;
    
    

             RtlCopyMemory(
                 &EncryptedSessionKeyPrevious,
                 SampDefinedDomains[AccountDomainIndex].CurrentFixed.DomainKeyInformationPrevious,
                 sizeof(EncryptedSessionKeyPrevious)
                 );

             TempDecryptStatus = KEDecryptKey(
                                    &DecryptionKey,
                                    &EncryptedSessionKeyPrevious,
                                    &SessionKeyPrevious,
                                    0
                                    );

             //
             // The decryption should decrypt fine, as we just used
             // the syskey to decrypt the latest password encryption key
             //
             ASSERT(KE_OK == TempDecryptStatus);

             RtlCopyMemory(
                SampSecretSessionKeyPrevious,
                SessionKeyPrevious.ClearKey,
                KE_KEY_SIZE
                );

             RtlZeroMemory(
                 &SessionKeyPrevious,
                 sizeof(KEClearKey)
                 );
        }

        SampCurrentKeyId = SampDefinedDomains[AccountDomainIndex].CurrentFixed.CurrentKeyId;
        SampPreviousKeyId = SampDefinedDomains[AccountDomainIndex].CurrentFixed.PreviousKeyId;

        //
        // Assert that we either don't have an old key, or if we have an old key it is not 
        // more than one off in terms of key sequence with the current key.
        //

        ASSERT((SampPreviousKeyId==0) || (SampCurrentKeyId==(SampPreviousKeyId+1)));

        RtlZeroMemory(
            &SessionKey,
            sizeof(KEClearKey)
            );

    }
    else if ((SampProductType!=NtProductLanManNt ) || (SampIsDownlevelDcUpgrade()))
    {
        //
        //
        // Fall back to calling Winlogon to obtain the key information
        // do so , only if we are booting to registry mode. If booting to 
        // DS mode, then DS will do this fallback. This should happen
        // really only during GUI setup. Note we do not test for SampUseDsData as this
        // variable is not set during this time
        //

        Status = WxConnect(
                    &WinlogonHandle
                    );

        //
        // If encryption is not enabled, tell winlogon. If winlogon isn't running
        // the LPC server, that is o.k. This may happen in NT4 as the act of "syskeying"
        // a DC was not transacted. Therefore to successfully upgrade a damaged NT4 machine
        // we have this test.
        //

        if (!SampSecretEncryptionEnabled)
        {
           
                (VOID) WxReportResults(
                            WinlogonHandle,
                            STATUS_SUCCESS
                            );

            Status = STATUS_SUCCESS;
            goto Cleanup;
        }


        //
        // If encryption is enabled and there is no LPC server, fail now.
        //

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        for (Tries = 0; Tries < SAMP_BOOT_KEY_RETRY_COUNT ; Tries++ )
        {

            DecryptionKey.dwLength = sizeof(KEClearKey);
            DecryptionKey.dwVersion = KE_CUR_VERSION;
            RtlZeroMemory(
                DecryptionKey.ClearKey,
                KE_KEY_SIZE
                );

            KeyLength = KE_KEY_SIZE;
            Status = WxGetKeyData(
                        WinlogonHandle,
                        (WX_AUTH_TYPE) SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyAuthType,
                        KeyLength,
                        DecryptionKey.ClearKey,
                        &KeyLength
                        );
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            //
            // Build the input parameters for the key decryption routine.
            //

            RtlCopyMemory(
                &EncryptedSessionKey,
                SampDefinedDomains[AccountDomainIndex].UnmodifiedFixed.DomainKeyInformation,
                sizeof(EncryptedSessionKey)
                );

            DecryptStatus = KEDecryptKey(
                                &DecryptionKey,
                                &EncryptedSessionKey,
                                &SessionKey,
                                0                   // flags
                                );


            Status = WxReportResults(
                        WinlogonHandle,
                        ((DecryptStatus == KE_OK) ? STATUS_SUCCESS :
                            ((DecryptStatus == KE_BAD_PASSWORD) ?
                                STATUS_WRONG_PASSWORD :
                                STATUS_INTERNAL_ERROR))
                            );
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            if (DecryptStatus == KE_OK)
            {
                break;
            }

        }

        if (DecryptStatus != KE_OK) {
            Status = STATUS_WRONG_PASSWORD;
            goto Cleanup;
        }

       

        //
        // Initialize the RC4key for use and clear the session key from memory
        //

        RtlCopyMemory(
            SampSecretSessionKey,
            SessionKey.ClearKey,
            KE_KEY_SIZE
            );

        SampCurrentKeyId = 1;
        SampPreviousKeyId = 0;

        RtlZeroMemory(
            &SessionKey,
            sizeof(KEClearKey)
            );

        //
        // Notify LSA of SAM's password encryption key, to unroll any
        // any secrets encrypted with the password encryption key 
        //

        SampSessionKeyLength =  SAMP_SESSION_KEY_LENGTH;
        LsaIHealthCheck( NULL,
                         LSAI_SAM_STATE_UNROLL_SP4_ENCRYPTION,
                         ( PVOID )&SampSecretSessionKey,
                          &SampSessionKeyLength); 

        //
        // Pass the syskey to LSA so, that it can be used in encryption of
        // secrets. Set the upgrade in progress bit, so that LSA can come back
        // and make sam calls to retrieve boot state.
        //

        SampUpgradeInProcess = TRUE;


        LsaIHealthCheck( 
            NULL,
            LSAI_SAM_STATE_SESS_KEY,
            ( PVOID )&DecryptionKey.ClearKey,
            &KeyLength
            );

        SampUpgradeInProcess = FALSE;

        //
        // Eat the key
        //

        RtlZeroMemory(
           &DecryptionKey,
           sizeof(KEClearKey)
           );

    
    }
    else
    {
        //
        // DC is being upgraded and we are in GUI setup
        // reset the status to STATUS_SUCCESS
        // and proceed over, the DS will initialize the password
        // encryption key. It is assumed that no changes to the
        // Safe boot hives are made during the GUI setup phase 
        // of a DC upgrade.
        // 
  
         Status = STATUS_SUCCESS;
    }

Cleanup:

    if (WinlogonHandle != NULL) {
        NtClose(WinlogonHandle);
    }
    
    return(Status);
}


BOOLEAN
SamIIsSetupInProgress(OUT BOOLEAN * fUpgrade)
{
  return(SampIsSetupInProgress(fUpgrade));
}

BOOLEAN
SamIIsDownlevelDcUpgrade()
{
  return(SampIsDownlevelDcUpgrade());
}

BOOLEAN
SamIIsRebootAfterPromotion()
{
  ULONG PromoteData;
  return((BOOLEAN)SampIsRebootAfterPromotion(&PromoteData));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\usrlogon.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    user.c

Abstract:

    This file contains services related fast logon API's


Author:

    Murli Satagopan - Murlis (4/8/97 ) Created

Environment:

    User Mode - Win32

Revision History:

    4/8/96 Created

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <lmcons.h>
#include <nturtl.h>
#include <ntlsa.h>              // need for nlrepl.h
#include <nlrepl.h>             // I_NetNotifyMachineAccount prototype
#include <msaudite.h>
#include <rc4.h>                // rc4_key(), rc4()
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>             // ATT_*
#include <dslayer.h>
#include <sdconvrt.h>
#include <ridmgr.h>
#include <dnsapi.h>

NTSTATUS
SampDsCheckObjectTypeAndFillContext(
    SAMP_OBJECT_TYPE    ObjectType,
    PSAMP_OBJECT        NewContext,
    IN  ULONG           WhichFields,
    IN  ULONG           ExtendedFields,
    IN  BOOLEAN  OverrideLocalGroupCheck
    );

NTSTATUS
SampRetrieveUserMembership(
    IN PSAMP_OBJECT UserContext,
    IN BOOLEAN MakeCopy,
    OUT PULONG MembershipCount,
    OUT PGROUP_MEMBERSHIP *Membership OPTIONAL
    );

NTSTATUS
SampParseName(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING DnsDomainName,
    PUNICODE_STRING ParsedSamAccountName,
    BOOLEAN         *LookupByParsedName
    )
{
    ULONG    NumChars = AccountName->Length/sizeof(WCHAR);
    ULONG    Current = 0;
    UNICODE_STRING    ParsedDomainName;

    *LookupByParsedName = FALSE;

    //
    // Look for the @ sign
    //
    for (Current=0;Current<NumChars; Current++)
    {
        if (L'@'==AccountName->Buffer[Current])
        {
            //
            // AccountName contains @ Char.
            //

            *ParsedSamAccountName = *AccountName;
            ParsedSamAccountName->Length = (USHORT) Current * sizeof(WCHAR);
            ParsedDomainName.Length = ParsedDomainName.MaximumLength = (USHORT)
                    (AccountName->Length - (Current + 1) * sizeof(WCHAR));

            // 1 for the NULL terminator.

            ParsedDomainName.Buffer = MIDL_user_allocate(ParsedDomainName.Length + sizeof(WCHAR));
            if (NULL==ParsedDomainName.Buffer)
            {
                return(STATUS_NO_MEMORY);
            }

            ParsedDomainName.Buffer[ParsedDomainName.Length/sizeof(WCHAR)] = 0;
            RtlCopyMemory(
                ParsedDomainName.Buffer,
                AccountName->Buffer+Current+1,
                ParsedDomainName.Length
                );

            if ((ParsedDomainName.Length > 0 ) &&
               (DnsNameCompare_W(DnsDomainName->Buffer,ParsedDomainName.Buffer)))
            {
                *LookupByParsedName = TRUE;          
            }

            MIDL_user_free(ParsedDomainName.Buffer);

            return(STATUS_SUCCESS);
        }
    }

    return (STATUS_SUCCESS);
}


NTSTATUS
SampLookupUserByUPNOrAccountName(
    DSNAME * DomainObject,
    PUNICODE_STRING DnsDomainName,
    PUNICODE_STRING AccountName,
    DSNAME  ** UserObject
    )

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Check to see if an object by the UPN exists
    //

    NtStatus = SampDsLookupObjectByAlternateId(
                    DomainObject,
                    ATT_USER_PRINCIPAL_NAME,
                    AccountName,
                    UserObject
                    );

    if (!NT_SUCCESS(NtStatus))
    {

        //
        // Try the SAM account name -- lookup by UPN failed
        //

         NtStatus = SampDsLookupObjectByName(
                        DomainObject,
                        SampUserObjectType,
                        AccountName,
                        UserObject
                        );

         if (!NT_SUCCESS(NtStatus))
         {
             UNICODE_STRING ParsedSamAccountName;
             BOOLEAN        LookupByParsedName = FALSE;

             //
             // Scan for an @ sign and try to parse the name
             // into account name and UPN
             //

             NtStatus = SampParseName(
                            AccountName,
                            DnsDomainName,
                            &ParsedSamAccountName,
                            &LookupByParsedName
                            );

             if (NT_SUCCESS(NtStatus))
             {
                 if (LookupByParsedName)
                 {
                     NtStatus = SampDsLookupObjectByName(
                                    DomainObject,
                                    SampUserObjectType,
                                    &ParsedSamAccountName,
                                    UserObject
                                    );
                 }
                 else
                 {
                     NtStatus = STATUS_NO_SUCH_USER;
                 }
             }
         }
    }

    return(NtStatus);
}

                            




NTSTATUS
SampGetReverseMembershipTransitive(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        Flags,
    OUT PSID_AND_ATTRIBUTES_LIST   List
    )
/*++

  Routine Description

    Gets the  transitive reverse membership of a user


  Arguments:

    User Handle -- handle of the User object, whose reverse membership is desired
    Flags       -- Flags for controlling the operation. Currently no flags
    cSids       -- Count of Sids
    rpSids      -- Array of Sids

--*/
{

    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        IgnoreStatus;
    DSNAME          *UserObjectName = NULL;
    PSID            *DsSids=NULL;
    SAMP_OBJECT_TYPE FoundType;


    //
    // Parameter Validation
    //

    ASSERT(List);
    List->Count = 0;

    NtStatus = SampDsGetReverseMemberships(
                    AccountContext->ObjectNameInDs,
                    Flags,
                    &(List->Count),
                    &DsSids
                    );

    if (NT_SUCCESS(NtStatus))
    {
         //
         // Copy in the Sids, using MIDL_user_allocate
         //

         List->SidAndAttributes = MIDL_user_allocate(List->Count * sizeof(SID_AND_ATTRIBUTES));

         if (NULL!=List->SidAndAttributes)
         {
             ULONG  Index;
             ULONG  SidLen;

             //
             // Zero out the returned Memory
             //

             RtlZeroMemory(List->SidAndAttributes, (List->Count)* sizeof(SID_AND_ATTRIBUTES));

             //
             // Copy the Sids
             //

             for (Index=0;Index<List->Count;Index++)
             {
                 SidLen = RtlLengthSid(DsSids[Index]);

                 (List->SidAndAttributes)[Index].Sid= MIDL_user_allocate(SidLen);

                 if (NULL!=(List->SidAndAttributes)[Index].Sid)
                 {
                     RtlCopyMemory((List->SidAndAttributes[Index]).Sid,DsSids[Index],SidLen);
                     (List->SidAndAttributes)[Index].Attributes = SE_GROUP_ENABLED|SE_GROUP_MANDATORY|
                                                        SE_GROUP_ENABLED_BY_DEFAULT;
                 }
                 else
                 {
                     NtStatus = STATUS_NO_MEMORY;
                     break;
                 }
             }

         }
         else
         {
             NtStatus = STATUS_NO_MEMORY;
         }
     }


    if (!NT_SUCCESS(NtStatus)) {

        ULONG Index;

        if (List->SidAndAttributes)
        {
            for (Index=0;Index < List->Count;Index++)
            {
                if ((List->SidAndAttributes)[Index].Sid)
                    MIDL_user_free((List->SidAndAttributes)[Index].Sid);
            }

            MIDL_user_free(List->SidAndAttributes);
        }

        List->Count = 0;


    }

    if (NULL!=DsSids)
        THFree(DsSids);

    return( NtStatus );

}

NTSTATUS
SampGetUserLogonInformationRegistryMode(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  USER_INFORMATION_CLASS UserInformationClass,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
/*++

    This is the Registry Mode SAM Logon Information Routine.
    This is used by ( or will eventually be used ) during logon's
    on Workstations and member server's when logging on to an account
    in the local database.

    Paramerters:

        Same as SamIGetUserLogonInformation

    Return Values:

        STATUS_SUCCESS:
        Other Error Codes
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMP_OBJECT_TYPE FoundType;
    PSAMP_OBJECT     DomainContext;
    SID_NAME_USE     Use;
    ULONG            Rid;
    PSAMP_OBJECT     AccountContext=NULL;
    ULONG            MembershipCount;
    PGROUP_MEMBERSHIP Membership=NULL;
    BOOLEAN          fLockAcquired = FALSE;
    PVOID            DomainSid = NULL;
    ULONG            WhichFields = 0;


    //
    // In Registry mode, we always fetch all fields
    //

    WhichFields = USER_ALL_READ_GENERAL_MASK         |
                              USER_ALL_READ_LOGON_MASK           |
                              USER_ALL_READ_ACCOUNT_MASK         |
                              USER_ALL_READ_PREFERENCES_MASK     |
                              USER_ALL_READ_TRUSTED_MASK;

    //
    // Acquire the Read Lock
    //

    SampAcquireReadLock();
    fLockAcquired = TRUE;


    *Buffer = NULL;
    RtlZeroMemory(ReverseMembership, sizeof(SID_AND_ATTRIBUTES_LIST));


    //
    // Validate type of, and access to the object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LOOKUP|DOMAIN_READ,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );
    if (NT_SUCCESS(NtStatus))
    {

        if (Flags & SAM_OPEN_BY_SID)
        {

            NtStatus = SampSplitSid(
                          AccountName->Buffer,
                          &DomainSid,
                          &Rid
                          );

            if ((NT_SUCCESS(NtStatus))
                && (!RtlEqualSid(DomainSid,SampDefinedDomains[DomainContext->DomainIndex].Sid)))
            {
                NtStatus = STATUS_NO_SUCH_USER;
            }
        }
        else
        {
           //
           // Get the Rid of the Account
           //

           NtStatus = SampLookupAccountRid(
                        DomainContext,
                        SampUserObjectType,
                        AccountName,
                        STATUS_NO_SUCH_USER,
                        &Rid,
                        &Use
                        );
        }

        if (NT_SUCCESS(NtStatus))
        {
            //
            // Create an Account Context
            //

            NtStatus = SampCreateAccountContext(
                            SampUserObjectType,
                            Rid,
                            TRUE, // Trusted Client
                            FALSE,// Loopback Client
                            TRUE, // Object Exisits
                            &AccountContext
                            );
            if (NT_SUCCESS(NtStatus))
            {
                //
                // Query Information
                //

                //
                // Clear the transaction in domain flag first, as
                // as SampQueryInformationUserInternal will call
                // LookupContext, which will set the TransactionDomain
                // flag
                //

                SampSetTransactionWithinDomain(FALSE);

                NtStatus = SampQueryInformationUserInternal(
                                AccountContext,
                                UserInformationClass,
                                TRUE, // Lock is already held
                                WhichFields,
                                0,
                                Buffer
                                );
                if (NT_SUCCESS(NtStatus))
                {

                    NtStatus = SampUpdateAccountDisabledFlag(
                                    AccountContext,
                                    &((*Buffer)->All.UserAccountControl)
                                    );

                    if (NT_SUCCESS(NtStatus))
                    {
                        //
                        // Get the User's Reverse Membership in Groups
                        //

                        NtStatus =  SampRetrieveUserMembership(
                                        AccountContext,
                                        FALSE, // Make copy
                                        &MembershipCount,
                                        &Membership
                                        );
                        if ((NT_SUCCESS(NtStatus))&& (MembershipCount>0))
                        {
                            ULONG i;

                            //
                            // Create the Sid and Attributes form of ReverseMembership
                            //

                            ReverseMembership->Count = MembershipCount;
                            ReverseMembership->SidAndAttributes = MIDL_user_allocate(
                                                        ReverseMembership->Count
                                                        * sizeof(SID_AND_ATTRIBUTES));

                            if (NULL!=ReverseMembership->SidAndAttributes)
                            {
                                ULONG  Index;
                                ULONG  SidLen;

                                //
                                // Zero out the returned Memory
                                //

                                RtlZeroMemory(ReverseMembership->SidAndAttributes,
                                        (ReverseMembership->Count)* sizeof(SID_AND_ATTRIBUTES));

                                //
                                // Convert the Rids to Sids and Then Copy Them
                                //

                                for (Index=0;
                                        (Index<ReverseMembership->Count)&&(NT_SUCCESS(NtStatus));
                                                Index++)
                                {
                                    (ReverseMembership->SidAndAttributes)[Index].Attributes
                                            = Membership[Index].Attributes;
                                    NtStatus = SampCreateFullSid(
                                                SampDefinedDomains[SampTransactionDomainIndex].Sid,
                                                Membership[Index].RelativeId,
                                                &((ReverseMembership->SidAndAttributes)[Index].Sid)
                                                );
                                }

                                if ((ARGUMENT_PRESENT(UserHandle))&&(NT_SUCCESS(NtStatus)))
                                {
                                    *UserHandle = AccountContext;
                                }
                            }
                            else
                            {
                                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                            }
                        }
                    }
                }
            }
        }

        SampDeReferenceContext2(DomainContext,FALSE);
    }

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // Free the reverse membership information
        //

        if (ReverseMembership->SidAndAttributes)
        {
            SamIFreeSidAndAttributesList(ReverseMembership);
        }

        ReverseMembership->Count = 0;

        //
        // Free the User All Information
        //

        if (NULL!=*Buffer)
        {
            SamIFree_SAMPR_USER_INFO_BUFFER(*Buffer,UserAllInformation);
            *Buffer=NULL;
        }

        if (NULL!=AccountContext)
        {
            SampDeleteContext(AccountContext);
        }
    }

    if (NULL!=DomainSid)
       MIDL_user_free(DomainSid);

    if (fLockAcquired)
        SampReleaseReadLock();

    return NtStatus;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//         SAM I calls to be used by NT5 in process clients                 //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampGetUserLogonInformation(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    IN  ULONG           ExtendedFields,
    IN  USER_INFORMATION_CLASS UserInformationClass,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
/*++

    Routine Description

        This Routine  Gets all the information for logging on a
        a user, including the full transitive reverse membership.
        The transitive reverse membership, if necessary is obtained
        by going to a G.C. A user handle is also returned, in case
        the caller requested it for sub-authentication. This function
        is efficient in its usage of the Sam Lock, except for the
        sub-authentication case


    Parameters

        Flags -- Controls the operation of the routine. The Following Flags
                 are defined Currently

                    SAM_GET_MEMBERSHIPS_NO_GC

                            Go to GC to get reverse memberships

                    SAM_GET_MEMBERSHIPS_TWO_PHASE

                            Get the reverse memberships in the
                            2 phase fashion for logon's. Can be
                            used to save additional positioning
                            cycles while logging on to a domain
                            controller

                    SAM_GET_MEMBERSHIPS_MIXED_DOMAIN

                            Forces Reverse membership evaluation
                            to be identical to that of an NT4 Domain

                    SAM_NO_MEMBERSHIPS

                            Does Not Retreive Any reverse memberships.
                            Useful while evaluating special accounts
                            that are known to not have any group memberships

                    SAM_OPEN_BY_ALTERNATE_ID

                            The Account Parameter specifies an Alternate
                            Id that is used to locate the account. Instead
                            of the SAM account name.

                    SAM_OPEN_BY_GUID

                            The AccountName->Buffer is a pointer to
                            the GUID of the account object

                    SAM_OPEN_BY_SID

                            The AccountName->Buffer is a pointer to the
                            SID of the account object.




        DomainSid -- Indicates the Users Domain

        AccountName -- Indicates the Users Account Name

        Buffer -- Builds the User All formation structure,
                        specifying passwords, account lockout and such

        ReverseMembership  -- The full transtive reverse membership of the
                        user, does not contain the local group membership
                        in the builtin domain

        UserHandle  -- Optional User Handle for Sub- Authentication packages.

    Return Values:

        STATUS_SUCCESS
        Other Error codes depending upon error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    PSAMP_OBJECT    NewContext=NULL, DomainContext = (PSAMP_OBJECT) DomainHandle;
    PSAMP_OBJECT    SubAuthenticationContext=NULL;
    UNICODE_STRING  KdcAccount;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;

    SAMTRACE_EX("SamIGetUserLogonInformation");

    if (FALSE==SampUseDsData)
    {
        //
        // Registry Mode Sam, call the Equivalent Registry mode
        // routine
        //

        NtStatus = SampGetUserLogonInformationRegistryMode(
                        DomainHandle,
                        Flags,
                        AccountName,
                        UserInformationClass,
                        Buffer,
                        ReverseMembership,
                        UserHandle
                        );
        SAMTRACE_RETURN_CODE_EX(NtStatus);

        return NtStatus;

    }
    else
    {
        PDSNAME     DomainObject = NULL;
        PDSNAME     UserObject = NULL;
        BOOLEAN     fMixedDomain = FALSE;
        ULONG       DomainIndex=0;
        PUNICODE_STRING DnsDomainName = NULL;


        *Buffer = NULL;
        RtlZeroMemory(ReverseMembership,sizeof(SID_AND_ATTRIBUTES_LIST));

        //
        // This routine executes without any locks held and therefore
        // is vulnerable for the database to be shut down while executng
        // database queries. Therefore update state saying that we are
        // executing so that the shutdown code waits for us.
        //

        NtStatus = SampIncrementActiveThreads();
        if (!NT_SUCCESS(NtStatus))
            return NtStatus;

        //
        // Obtain the Domain Object corresponding to the domain
        // Sid
        //


        //
        // We are not Validating the Domain Handle passed in by
        // our clients and using it straight away. This is because
        // the validation code is single threaded and we do not want
        // to incur the performance penalty. This call is made only
        // by trusted callers and to that extent we trust them
        //

        DomainIndex = ((PSAMP_OBJECT)DomainHandle)->DomainIndex;
        DomainObject = SampDefinedDomains[DomainIndex].Context->ObjectNameInDs;
        fMixedDomain = SampDefinedDomains[DomainIndex].IsMixedDomain;
        DnsDomainName = &SampDefinedDomains[DomainIndex].DnsDomainName;

        //
        // Begin a Ds Transaction.
        //

        NtStatus = SampMaybeBeginDsTransaction(TransactionRead);

        if (!NT_SUCCESS(NtStatus))
            goto Error;



        //
        // Create a Context for the User Object
        //

        NewContext = SampCreateContextEx(
                        SampUserObjectType,
                        TRUE, // Trusted Client
                        TRUE, // DS mode
                        TRUE, // Thread Safe
                        DomainContext->LoopbackClient, // Loopback Client
                        TRUE, // Lazy Commit
                        TRUE, // PersisAcrossCalls
                        FALSE,// BufferWrites
                        FALSE,// Opened By DCPromo
                        DomainIndex
                        );

        if (NULL==NewContext)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // For the passed in Account name, obtain the FQDN of the
        // user object. The caller has several ways of specifying the
        // name
        //  1. As an account name -- This is a default. A DS search is done
        //     to convert this to a FQDN
        //
        //  2. An alternate id -- This is typically done when the user wishes
        //     to authenticate using a certificate
        //
        //  3. The caller has specified a UPN or an SPN
        //
        //  4. A GUID specifying the user object.
        //
        //  5. A SID specifying the user object.
        //

        if (Flags & SAM_OPEN_BY_ALTERNATE_ID)
        {
            //
            // Caller Wants to Open the account by Alternate Id
            //
            NtStatus = SampDsLookupObjectByAlternateId(
                            DomainObject,
                            ATT_ALT_SECURITY_IDENTITIES,
                            AccountName,
                            &UserObject
                            );
        }
        else if (Flags & SAM_OPEN_BY_UPN)
        {
            //
            // Caller Wants to Open the account by User Principal Name
            //
            NtStatus = SampDsLookupObjectByAlternateId(
                            DomainObject,
                            ATT_USER_PRINCIPAL_NAME,
                            AccountName,
                            &UserObject
                            );
        }
        else if (Flags & SAM_OPEN_BY_SPN)
        {
            //
            // Caller Wants to Open the account by User Principal Name
            //
            NtStatus = SampDsLookupObjectByAlternateId(
                            DomainObject,
                            ATT_SERVICE_PRINCIPAL_NAME,
                            AccountName,
                            &UserObject
                            );
        }
        else if (Flags & SAM_OPEN_BY_GUID)
        {
            //
            // The passed in name is the GUID of the user object. There is no need to
            // lookup the database.
            //


            UserObject = MIDL_user_allocate(sizeof(DSNAME));
            if (NULL!=UserObject)
            {
                RtlZeroMemory(UserObject,sizeof(DSNAME));
                RtlCopyMemory(&UserObject->Guid,AccountName->Buffer,sizeof(GUID));
                UserObject->structLen = DSNameSizeFromLen(0);
            }
            else
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else if (Flags & SAM_OPEN_BY_SID)
        {
            //
            // The passed in name is the SID of the user object. Construct a SID only
            // DS name after validating the SID. There is no need to lookup the database
            //

            if ((RtlValidSid(AccountName->Buffer))
                    && (AccountName->Length<=sizeof(NT4SID))
                    && (AccountName->Length==RtlLengthSid(AccountName->Buffer)))
            {
                UserObject = MIDL_user_allocate(sizeof(DSNAME));
                if (NULL!=UserObject)
                {
                    RtlZeroMemory(UserObject,sizeof(DSNAME));
                    RtlCopyMemory(&UserObject->Sid,AccountName->Buffer,AccountName->Length);
                    UserObject->SidLen = AccountName->Length;
                    UserObject->structLen = DSNameSizeFromLen(0);
                }
                else
                {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            else
            {
                NtStatus = STATUS_INVALID_PARAMETER;
            }
        }
        else if (Flags & SAM_OPEN_BY_UPN_OR_ACCOUNTNAME)
        {
            NtStatus = SampLookupUserByUPNOrAccountName(
                            DomainObject,
                            DnsDomainName,
                            AccountName,
                            &UserObject
                            );

        }
        else
        {
            //
            // Lookup the object by Name
            //

            NtStatus = SampDsLookupObjectByName(
                        DomainObject,
                        SampUserObjectType,
                        AccountName,
                        &UserObject
                        );
        }

        if (!NT_SUCCESS(NtStatus))
            goto Error;

        //
        // Initialize the DS object portion on the new context.
        //

        NewContext->ObjectNameInDs = UserObject;
        NewContext->DomainIndex = DomainIndex;
        NewContext->GrantedAccess = USER_ALL_ACCESS;
        SetDsObject(NewContext);

        //
        // Read all the properties in one stroke. This results in
        // in a single DirRead call. All "interesting" properties
        // are prefetched by this routine. This eliminates any
        // further DS calls to read additional properties.
        //


        NtStatus = SampDsCheckObjectTypeAndFillContext(
                            SampUserObjectType,
                            NewContext,
                            WhichFields,
                            ExtendedFields,
                            FALSE // override local group check
                            );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        //
        // After the successful completion of SampDsCheckObjectTypeAndFillContext
        // the DSName pointed to by UserObject, should have the SID in it. This
        // is because the DS, annotates the name with any missing components.
        //

        ASSERT(UserObject->SidLen>0);


        //
        // Obtain the Rid from Sid. Note SampSplitSid should never
        // fail, with a NULL domainSid parameter.
        //

        IgnoreStatus = SampSplitSid(
                                &(UserObject->Sid),
                                NULL ,
                                &(NewContext->TypeBody.User.Rid)
                                );

        ASSERT(NT_SUCCESS(IgnoreStatus));


       


        //
        // Query Information Regarding the User Object. This is a
        // completely in memory operation.
        //

        NtStatus = SampQueryInformationUserInternal(
                        NewContext,
                        UserInformationClass,
                        TRUE, // Lock is not held, but we do not
                              // want to end the transaction in
                              // inside of SampQueryInformationUserInteral
                              // There fore pass a TRUE.
                        WhichFields,
                        ExtendedFields,
                        Buffer
                        );

        if (!NT_SUCCESS(NtStatus))
            goto Error;


        //
        // Update the account disabled flag in the user information requested
        // This routine enables the admin account for purposes of logon, if
        // the machine is booted in to Safe mode
        //

        if ((0==WhichFields) // 0 is special case, means get all fields
           || (WhichFields & USER_ALL_USERACCOUNTCONTROL ))
        {
            PULONG pUserAccountControl = NULL;

            switch(UserInformationClass)
            {
                case UserAllInformation:
                    pUserAccountControl = &((*Buffer)->All.UserAccountControl);
                    break;
                case UserInternal6Information:
                    pUserAccountControl = &(((PUSER_INTERNAL6_INFORMATION)(*Buffer))->I1.UserAccountControl);
                    break;
                default:
                    ASSERT(FALSE && "UnsupportedInformationLevel");
                    NtStatus = STATUS_INVALID_PARAMETER;
                    goto Error;
            }

            NtStatus = SampUpdateAccountDisabledFlag(
                                    NewContext,
                                    pUserAccountControl
                                    );
        }

        if (!NT_SUCCESS(NtStatus))
            goto Error;

        //
        // If caller did not prohibit us from getting memberships then
        // retrieve reverse memberships
        //

        if (!(Flags & SAM_NO_MEMBERSHIPS))
        {
            //
            // Obtain the Transitive Reverse Membership, if necessary goto G.C
            //


            //
            // Do not go to the G.C for the krbtgt account. The krbtgt
            // is not renamable and in a win2k domain it is enforced that
            // only the account with the RID DOMAIN_USER_RID_KRBTGT can
            // and will have this name. The name is never localized.
            //

            RtlInitUnicodeString(&KdcAccount,L"krbtgt");
            if (0==RtlCompareUnicodeString(AccountName,&KdcAccount,TRUE))
            {
                Flags |= SAM_GET_MEMBERSHIPS_NO_GC;
            }

            // Do not go to the G.C for DC's and interdomain trust accounts 
            if (((*Buffer)->All.UserAccountControl) & 
                  (USER_SERVER_TRUST_ACCOUNT|USER_INTERDOMAIN_TRUST_ACCOUNT))
            {
                Flags |= SAM_GET_MEMBERSHIPS_NO_GC;
            }

            if (fMixedDomain)
            {
                Flags|= SAM_GET_MEMBERSHIPS_MIXED_DOMAIN;
            }

            //
            // Sp case this DC's computer account
            //

            if ((NULL!=SampComputerObjectDsName) &&
               (0==memcmp(&SampComputerObjectDsName->Guid,
                        &NewContext->ObjectNameInDs->Guid,sizeof(GUID))))
            {
                Flags|= SAM_GET_MEMBERSHIPS_NO_GC;
            }

        

            NtStatus = SampGetReverseMembershipTransitive(
                            NewContext,
                            Flags,
                            ReverseMembership
                            );

            //
            // We we tried going to the GC and could not reach a GC
            // the above routine returns a special success code 
            // (STATUS_DS_MEMBERSHIP_EVAULATED_LOCALLY ). If the
            // registry flag for allowing logons is not set and if
            // it is not the administrator account then fail the
            // logon with STATUS_NO_LOGON_SERVERS.
            //

            if ((STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY==NtStatus)
                && (!SampIgnoreGCFailures)
                && (DOMAIN_USER_RID_ADMIN!=NewContext->TypeBody.User.Rid))
            {
                if (SampIsGroupCachingEnabled(NewContext)) {
                    NewContext->TypeBody.User.fNoGcAvailable = TRUE;
                    NtStatus = STATUS_SUCCESS;
                } else {
                    NtStatus = STATUS_NO_LOGON_SERVERS;
                }
            }

            if (!NT_SUCCESS(NtStatus))
                goto Error;
        }

        //
        // If the caller asked for a user handle, then add one reference to it
        // and pass back the new context
        //

        if (ARGUMENT_PRESENT(UserHandle))
        {
            *UserHandle = NewContext;
            SampReferenceContext(NewContext);

            if (!(Flags & SAM_NO_MEMBERSHIPS)) {
                NewContext->TypeBody.User.fCheckForSiteAffinityUpdate = TRUE;
            }
        }

    }

Error:

    //
    // End Any Open Transactions
    //

    IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Free the context, if necessary
    //

    if (NewContext)
    {
        // Free the context, ignore any changes.
        if ((ARGUMENT_PRESENT(UserHandle)) && (NT_SUCCESS(NtStatus)))
        {
            IgnoreStatus = SampDeReferenceContext(NewContext,FALSE);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
        else
        {
             SampDeleteContext(NewContext);
             if (ARGUMENT_PRESENT(UserHandle))
             {
                 *UserHandle = NULL;
             }
        }

    }


    if (!NT_SUCCESS(NtStatus))
    {


        //
        // Free the reverse membership information
        //

        if (ReverseMembership->SidAndAttributes)
        {
            SamIFreeSidAndAttributesList(ReverseMembership);
        }

        ReverseMembership->Count = 0;
        ReverseMembership->SidAndAttributes = NULL;

        //
        // Free the User All Information
        //

        if ((NULL!=Buffer)&& (NULL!=*Buffer))
        {
            SamIFree_SAMPR_USER_INFO_BUFFER(*Buffer,UserAllInformation);
            *Buffer=NULL;
        }

    }




    //
    // Decrement the Active Thread Count
    //

    SampDecrementActiveThreads();

    SAMTRACE_RETURN_CODE_EX(NtStatus);
    return NtStatus;

}

NTSTATUS
SamIGetUserLogonInformation(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{

    return(SampGetUserLogonInformation(
                DomainHandle,
                Flags,
                AccountName,
                0, // which fields
                0, // extended fields
                UserAllInformation, // information class
                Buffer,
                ReverseMembership,
                UserHandle
                ));
}

NTSTATUS
SamIGetUserLogonInformationEx(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{
    return(SampGetUserLogonInformation(
                DomainHandle,
                Flags,
                AccountName,
                WhichFields, // which fields
                0, // extended fields
                UserAllInformation, // information class
                Buffer,
                ReverseMembership,
                UserHandle
                ));
}

NTSTATUS
SamIGetUserLogonInformation2(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    IN  ULONG           ExtendedFields,
    OUT PUSER_INTERNAL6_INFORMATION * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    )
{
    return(SampGetUserLogonInformation(
                DomainHandle,
                Flags,
                AccountName,
                WhichFields, // which fields
                ExtendedFields, // extended fields
                UserInternal6Information, // information class
                (PSAMPR_USER_INFO_BUFFER *)Buffer,
                ReverseMembership,
                UserHandle
                ));
}


NTSTATUS
SamIGetResourceGroupMembershipsTransitive(
    IN SAMPR_HANDLE         DomainHandle,
    IN PSAMPR_PSID_ARRAY    SidArray,
    ULONG                   Flags,
    OUT PSAMPR_PSID_ARRAY * Membership
    )
/*++

   Routine Description

   This routine retrieves the transitive reverse membership of the
   given set of sids in resource groups

   Parameters

        DomainHandle -- Handle to Domain object

        SidArray   -- Set of Sids whose reverse membership needs to
                     be evaluated

        Flags     -- Flags to control operation of the routine. Currently
                     no flags are defined.

        Membership -- Returned reverse membership set


   Return Values

        STATUS_SUCCESS
        Other error codes to indicate resource failures

--*/
{
    PSAMP_OBJECT    DomainContext = (PSAMP_OBJECT) DomainHandle;
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        IgnoreStatus;
    PDSNAME         *ResolvedNames=NULL;
    PDSNAME         *pMemberships=NULL;
    PSID            *pSidHistory=NULL;
    ULONG           cMemberships=0;
    ULONG           cSidHistory=0;
    BOOLEAN         fMixedDomain = FALSE;
    ULONG           i=0;

   

   
    //
    // This routine executes without any locks held and therefore
    // is vulnerable for the database to be shut down while executng
    // database queries. Therefore update state saying that we are
    // executing so that the shutdown code waits for us.
    //

    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
        return NtStatus;


    //
    // Reference the context while we are using it.
    //

    SampReferenceContext(DomainContext);


    *Membership = MIDL_user_allocate(sizeof(SAMPR_PSID_ARRAY));
    if (NULL==*Membership)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Initialize Return Values
    //

    RtlZeroMemory(*Membership,sizeof(SAMPR_PSID_ARRAY));

    //
    // If we are not in DS mode then return right away. Do not
    // merge in any memberships we are still O.K without it
    // Note we are returning a STATUS_SUCCESS , with no memberhships

    if (!SampUseDsData)
    {
        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

   
    //
    // Not necessary to grab the lock for referring to IsMixedDomain in  
    // the defined domains array. 
    //

    fMixedDomain = SampDefinedDomains[DomainContext->DomainIndex].IsMixedDomain;


    if (fMixedDomain)
    {
        //
        // Nothing to Do, just bail
        //
        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    //
    // Convert the SIDS to SID only DS Names
    //

    NtStatus = SampDsResolveSids(
                    (PSID) SidArray->Sids,
                    SidArray->Count,
                    RESOLVE_SIDS_SID_ONLY_NAMES_OK,
                    &ResolvedNames
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // begin a read only transaction
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Get the resource group memberships
    //

    NtStatus = SampGetMemberships(
                    ResolvedNames,
                    SidArray->Count,
                    DomainContext->ObjectNameInDs,
                    RevMembGetResourceGroups,
                    &cMemberships,
                    &pMemberships,
                    NULL,
                    &cSidHistory,
                    &pSidHistory
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Merge in the SIDs and Sid Histories into the
    // SAMPR_PSID_ARRAY
    //

    (*Membership)->Sids = (PSAMPR_SID_INFORMATION)
            MIDL_user_allocate((cMemberships+cSidHistory) * sizeof(PRPC_SID));
    if (NULL==(*Membership)->Sids)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // First the  Sids
    //

    for (i=0;i<cMemberships;i++)
    {
        (*Membership)->Sids[(*Membership)->Count].SidPointer
            = (PSID)MIDL_user_allocate(pMemberships[i]->SidLen);
        if (NULL==((*Membership)->Sids[i].SidPointer))
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory((*Membership)->Sids[i].SidPointer,
                      &pMemberships[i]->Sid,
                      pMemberships[i]->SidLen
                      );
        (*Membership)->Count++;
    }


    //
    // Then the SID History
    //

    for (i=0;i<cSidHistory;i++)
    {
        (*Membership)->Sids[(*Membership)->Count].SidPointer
            = (PSID) MIDL_user_allocate(RtlLengthSid(pSidHistory[i]));
        if (NULL==((*Membership)->Sids[(*Membership)->Count].SidPointer))
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory((*Membership)->Sids[(*Membership)->Count].SidPointer,
                      pSidHistory[i],
                      RtlLengthSid(pSidHistory[i])
                      );
        (*Membership)->Count++;
    }






Error:

    //
    // End Any Open Transactions in DS mode.
    //

    if (SampUseDsData)
    {
        IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Perform any necessary cleanup
    //

    if (NULL!=ResolvedNames)
    {
        for (i=0; i<SidArray->Count;i++)
        {
            if (NULL!=ResolvedNames[i])
            {
                MIDL_user_free(ResolvedNames[i]);
            }

        }

        MIDL_user_free(ResolvedNames);
    }

    if (!NT_SUCCESS(NtStatus))
    {
        SamIFreeSidArray(*Membership);
        *Membership = NULL;
    }

    SampDeReferenceContext2(DomainContext,FALSE);

    //
    // Decrement the Active Thread Count
    //

    SampDecrementActiveThreads();

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return NtStatus;

}


NTSTATUS
SamIOpenAccount(
    IN SAMPR_HANDLE         DomainHandle,
    IN ULONG                AccountRid,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    OUT SAMPR_HANDLE        *AccountHandle
    )
/*++

    Given a Domain Handle and the Rid of the Account, this routine opens
    an account handle for that account. All the properties of the account are prefetched
    into the handle, to make subsequent SAM queries faster . The Handle is marked with
    all access.


    Parameters:

        DomainHandle --- Handle to the Domain in which the account is to be opened.
        AccountRid   --- The Rid of the account
        ObjectType   --- The type of the object. Must be a SAM account object type, else status
                         invalid parameter would be retunred
        AccountHandle -- Handle to the account

    Return Values

        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER
        Other Error codes to indicate Various error conditions

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMP_OBJECT_TYPE    SamObjectType;
    PSAMP_OBJECT        DomainContext = (PSAMP_OBJECT)DomainHandle;
    PSAMP_OBJECT        NewContext = NULL;
    ACCESS_MASK         AllAccess;
    DSNAME              *AccountObject = NULL;
    PSID                AccountSid = NULL;
    PSID                DomainSid = NULL;
    NTSTATUS            NotFoundStatus = STATUS_INTERNAL_ERROR;
   
    //
    // Translate Security DB object Types to SAM object Types
    //
    switch (ObjectType)
    {
    case SecurityDbObjectSamUser:
            SamObjectType = SampUserObjectType;
            AllAccess     = USER_ALL_ACCESS;
            NotFoundStatus = STATUS_NO_SUCH_USER;
            break;

    case SecurityDbObjectSamGroup:
            SamObjectType = SampGroupObjectType;
            AllAccess     = GROUP_ALL_ACCESS;
            NotFoundStatus = STATUS_NO_SUCH_GROUP;
            break;

    case SecurityDbObjectSamAlias:
            SamObjectType = SampAliasObjectType;
            AllAccess     = ALIAS_ALL_ACCESS;
            NotFoundStatus = STATUS_NO_SUCH_ALIAS;
            break;

    default:

            return(STATUS_INVALID_PARAMETER);
    }

    //
    // This routine executes without any locks held and therefore
    // is vulnerable for the database to be shut down while executng
    // database queries. Therefore update state saying that we are
    // executing so that the shutdown code waits for us.
    //

    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
        return NtStatus;

    //
    // If we are in Registry Mode then call Sam Open Account.
    // Do the Same for the Builtin Domain
    //

    SampReferenceContext(DomainContext);
    DomainSid = SampDefinedDomains[DomainContext->DomainIndex].Sid;

    if ((IsBuiltinDomain(DomainContext->DomainIndex)) || (!IsDsObject(DomainContext)))
    {
        
        SampDeReferenceContext2(DomainContext,FALSE);

        SampDecrementActiveThreads();

        return(SampOpenAccount(
                    SamObjectType,
                    DomainHandle,
                    AllAccess,
                    AccountRid,
                    FALSE,
                    AccountHandle
                    ));
    }


    //
    // We are in DS mode and are not the builtin domain. Perform a fast open and 
    // mark the context as thread safe
    //

    NtStatus = SampCreateFullSid(DomainSid,AccountRid,&AccountSid);

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Create a Context for the account Object
    //


    NewContext = SampCreateContextEx(
                    SamObjectType,
                    TRUE, // Trusted Client
                    TRUE, // DS mode
                    TRUE, // Thread Safe
                    DomainContext->LoopbackClient, // Loopback Client
                    TRUE, // Lazy Commit
                    TRUE, // PersisAcrossCalls
                    FALSE,// BufferWrites
                    FALSE,// Opened By DCPromo
                    DomainContext->DomainIndex
                    );

    if (NULL==NewContext)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

   
   
    //
    // Construct a SID only DS Name based on the passed in Account Rid
    //

     AccountObject = MIDL_user_allocate(sizeof(DSNAME));
     if (NULL==AccountObject)
     {
         NtStatus = STATUS_INSUFFICIENT_RESOURCES;
         goto Error;
     }


    
    RtlZeroMemory(AccountObject,sizeof(DSNAME));
    RtlCopyMemory(&AccountObject->Sid,AccountSid,RtlLengthSid(AccountSid));
    AccountObject->SidLen = RtlLengthSid(AccountSid);
    AccountObject->structLen = DSNameSizeFromLen(0);


    //
    // Initialize the DS object portion on the new context.
    //

    NewContext->ObjectNameInDs = AccountObject;
    NewContext->DomainIndex = DomainContext->DomainIndex;
    NewContext->GrantedAccess = AllAccess;
    SetDsObject(NewContext);


    //
    // Prefetch all properties after checking Object type
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    NtStatus = SampDsCheckObjectTypeAndFillContext(
                        SamObjectType,
                        NewContext,
                        0,
                        0,
                        FALSE // override local group check
                        );
    //
    // If We got a name error then reset the failure
    // status to object not found
    //
 
    if ((STATUS_OBJECT_NAME_INVALID==NtStatus)
         || (STATUS_OBJECT_NAME_NOT_FOUND==NtStatus))
    {
        NtStatus = NotFoundStatus;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;
    
    //
    // Set the Rid
    //

    switch (ObjectType)
    {
    case SecurityDbObjectSamUser:
            
            NewContext->TypeBody.User.Rid = AccountRid;
            break;

    case SecurityDbObjectSamGroup:
         
            NewContext->TypeBody.Group.Rid = AccountRid;
            break;

    case SecurityDbObjectSamAlias:
           
            NewContext->TypeBody.Alias.Rid = AccountRid;
            break;

    default:

            ASSERT(FALSE && "Should Never Hit Here");
            break;
     }


     *AccountHandle = NewContext;
     

Error:

     if ((!NT_SUCCESS(NtStatus)) && (NULL!=NewContext))
     {
         SampDeleteContext(NewContext);
     }

     SampDeReferenceContext2(DomainContext,FALSE);

     //
     // End all Open Transactions
     //

     SampMaybeEndDsTransaction(TransactionCommit);

     if (NULL!=AccountSid)
     {
         MIDL_user_free(AccountSid);
     }

     SampDecrementActiveThreads();

     return NtStatus;
     
}





NTSTATUS
SamIGetAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    )
/*++

  Routine Description.

  In process version of SamrGetAliasMembership. Does different things
  for mixed mode, registry mode vs native mode.

  Parameters

    Same As SamrGetAliasMembership

  Return Values

    Same As SamrGetAliasMembership

--*/
{

    ULONG DomainIndex = ((PSAMP_OBJECT)DomainHandle)->DomainIndex;

    if ( (!SampUseDsData)
        || (SampDefinedDomains[DomainIndex].IsMixedDomain )
        || (SampDefinedDomains[DomainIndex].IsBuiltinDomain))

    {
        //
        // Do exactly what SamrGetAliasMembership did
        //

        return (SamrGetAliasMembership(DomainHandle,SidArray,Membership));
    }
    else
    {
        //
        // return a 0 length membership
        //

        Membership->Count = 0;
        Membership->Element = NULL;

    }


    return(STATUS_SUCCESS);
}


NTSTATUS
SamINetLogonPing(
    IN  SAMPR_HANDLE    DomainHandle,
    IN  PUNICODE_STRING AccountName,
    OUT BOOLEAN *       AccountExists,
    OUT PULONG          UserAccountControl
    )
/*++
Routine Description:

    This routine will based on a Domain Handle and on the account name will
    tell if the account exists and return the user account control.
    
Parameters:

    DomainHandle - The domain where the account name can be found
    
    AccountName - The account name for which to find the useraccountcontrol
    
    AccountExists - This will tell the call if the account exists or not
    
    UserAccountControl - This will have the return of the useraccountcontrol

Return Values:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL
    
--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    DWORD    DsErr  = 0;
    BOOL     IncrementedThreads = FALSE;
    ULONG    UserFlags = 0;

    //make sure that we are not in sam registry mode
    if (!SampUseDsData)
    {
        status = STATUS_NOT_SUPPORTED;    
        goto cleanup;
    }

    status = SampIncrementActiveThreads();
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    } else {
        IncrementedThreads = TRUE;
    }

    if ( !THQuery() ) {
        DsErr = THCreate(CALLERTYPE_SAM);
        if (0!=DsErr)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }
    }

    status = SampNetlogonPing(SampDefinedDomains[((PSAMP_OBJECT)DomainHandle)->DomainIndex].DsDomainHandle,
                              AccountName,
                              AccountExists,
                              &UserFlags
                              );
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    status = SampFlagsToAccountControl(UserFlags,
                                       UserAccountControl);
    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }
    
    cleanup:

    if (0==DsErr) {
        THDestroy();
    }

    if ( TRUE == IncrementedThreads ) {
        SampDecrementActiveThreads();
    }

    return status;


}

NTSTATUS
SamIUPNFromUserHandle(
    IN  SAMPR_HANDLE UserHandle,
    OUT BOOLEAN     *UPNDefaulted,
    OUT PUNICODE_STRING UPN
    )

/*++

    This is a simple helper routine to efficiently return the UPN given a user handle

    Parameters are as follows

    UserHandle -- Handle to the user object
    UPNDefaulted -- Boolean indicates that the UPN has been defaulted
    UPN          -- Unicode string returning the UPN

--*/
{
    PSAMP_OBJECT UserContext = (PSAMP_OBJECT) UserHandle;
    SAMP_OBJECT_TYPE    FoundType;
    BOOLEAN             ContextReferenced = FALSE;
    NTSTATUS            NtStatus = STATUS_SUCCESS;

    NtStatus = SampLookupContext(
                    UserContext,
                    0,
                    SampUserObjectType,
                    &FoundType
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    ContextReferenced = TRUE;

    UPN->Length = UserContext->TypeBody.User.UPN.Length;
    UPN->MaximumLength = UserContext->TypeBody.User.UPN.Length;

    UPN->Buffer = MIDL_user_allocate(UPN->Length);
    if (NULL==UPN->Buffer)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlCopyMemory(
            UPN->Buffer,
            UserContext->TypeBody.User.UPN.Buffer,
            UPN->Length
            );

    *UPNDefaulted =  UserContext->TypeBody.User.UpnDefaulted;

Error:

    if (ContextReferenced)
    {
        SampDeReferenceContext(UserContext, FALSE);
    }

    return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\user.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    user.c

Abstract:

    This file contains services related to the SAM "user" object.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    10-Oct-1996 ChrisMay
        Added SamIOpenUserByAlternateId for new security packages.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <lmcons.h>
#include <nturtl.h>
#include <ntlsa.h>              // need for nlrepl.h
#include <nlrepl.h>             // I_NetNotifyMachineAccount prototype
#include <msaudite.h>
#include <rc4.h>                // rc4_key(), rc4()
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>             // ATT_*
#include <dslayer.h>
#include <sdconvrt.h>
#include <ridmgr.h>
#include <enckey.h>
#include <wxlpc.h>
#include <lmaccess.h>
#include <malloc.h>
#include <samtrace.h>
#include <dnsapi.h>
#include <cryptdll.h>
#include <notify.h>
#include <md5.h>
#include <safeboot.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LARGE_INTEGER
SampGetPasswordMustChange(
    IN ULONG UserAccountControl,
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    );


NTSTATUS
SampStorePasswordExpired(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN PasswordExpired
    );


NTSTATUS
SampRetrieveUserPasswords(
    IN PSAMP_OBJECT Context,
    OUT PLM_OWF_PASSWORD LmOwfPassword,
    OUT PBOOLEAN LmPasswordNonNull,
    OUT PNT_OWF_PASSWORD NtOwfPassword,
    OUT PBOOLEAN NtPasswordPresent,
    OUT PBOOLEAN NtPasswordNonNull
    );

NTSTATUS
SampRetrieveUserMembership(
    IN PSAMP_OBJECT UserContext,
    IN BOOLEAN MakeCopy,
    OUT PULONG MembershipCount,
    OUT PGROUP_MEMBERSHIP *Membership OPTIONAL
    );

NTSTATUS
SampReplaceUserMembership(
    IN PSAMP_OBJECT UserContext,
    IN ULONG MembershipCount,
    IN PGROUP_MEMBERSHIP Membership
    );

NTSTATUS
SampRetrieveUserLogonHours(
    IN PSAMP_OBJECT Context,
    OUT PLOGON_HOURS LogonHours
    );


NTSTATUS
SampDeleteUserKeys(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampCheckPasswordHistory(
    IN PVOID EncryptedPassword,
    IN ULONG EncryptedPasswordLength,
    IN USHORT PasswordHistoryLength,
    IN ULONG HistoryAttributeIndex,
    IN PSAMP_OBJECT Context,
    IN BOOLEAN CheckHistory,
    OUT PUNICODE_STRING OwfHistoryBuffer
    );

NTSTATUS
SampAddPasswordHistory(
    IN PSAMP_OBJECT Context,
    IN ULONG HistoryAttributeIndex,
    IN PUNICODE_STRING NtOwfHistoryBuffer,
    IN PVOID EncryptedPassword,
    IN ULONG EncryptedPasswordLength,
    IN USHORT PasswordHistoryLength
    );

NTSTATUS
SampMatchworkstation(
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations
    );

USHORT
SampQueryBadPasswordCount(
    PSAMP_OBJECT UserContext,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed
    );

VOID
SampUpdateAccountLockedOutFlag(
    PSAMP_OBJECT Context,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    PBOOLEAN IsLocked
    );

NTSTATUS
SampCheckForAccountLockout(
    IN PSAMP_OBJECT AccountContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    IN BOOLEAN  V1aFixedRetrieved
    );

PVOID
DSAlloc(
    IN ULONG Length
    );


NTSTATUS
SampEnforceDefaultMachinePassword(
    PSAMP_OBJECT AccountContext,
    PUNICODE_STRING NewPassword,
    PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo
    );


NTSTATUS
SampCheckStrongPasswordRestrictions(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING FullName,
    PUNICODE_STRING Password,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION  PasswordChangeFailureInfo OPTIONAL
    );

PWSTR
SampLocalStringToken(
    PWSTR    String,
    PWSTR    Token,
    PWSTR    * NextStringStart
    );


NTSTATUS
SampStoreAdditionalDerivedCredentials(
    IN PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
    IN PSAMP_OBJECT UserContext,
    IN PUNICODE_STRING ClearPassword
    );

NTSTATUS
SampObtainEffectivePasswordPolicy(
   OUT PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
   IN PSAMP_OBJECT AccountContext,
   IN BOOLEAN      WriteLockAcquired
   );

NTSTATUS
SampDsUpdateLastLogonTimeStamp(
    IN PSAMP_OBJECT AccountContext,
    IN LARGE_INTEGER LastLogon,
    IN ULONG SyncInterval
    );


VOID
SampGetRequestedAttributesForUser(
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN ULONG WhichFields,
    OUT PRTL_BITMAP AttributeAccessTable
    );

NTSTATUS
SampValidatePresentAndStoredCombination(
    IN BOOLEAN NtPresent,
    IN BOOLEAN LmPresent,
    IN BOOLEAN StoredNtPasswordPresent,
    IN BOOLEAN StoredNtPasswordNonNull,
    IN BOOLEAN StoredLmPasswordNonNull
    );


NTSTATUS
SampCopyA2D2Attribute(
    IN PUSER_ALLOWED_TO_DELEGATE_TO_LIST Src,
    OUT PUSER_ALLOWED_TO_DELEGATE_TO_LIST *Dest
    );

NTSTATUS
SampRandomizeKrbtgtPassword(
    IN PSAMP_OBJECT        AccountContext,
    IN OUT PUNICODE_STRING ClearTextPassword,
    IN BOOLEAN FreeOldPassword,
    OUT BOOLEAN *FreeRandomizedPassword
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SamrOpenUser(
        IN SAMPR_HANDLE DomainHandle,
        IN ACCESS_MASK DesiredAccess,
        IN ULONG UserId,
        OUT SAMPR_HANDLE *UserHandle
    )


/*++

    This API opens an existing user  in the account database.  The user
    is specified by a ID value that is relative to the SID of the
    domain.  The operations that will be performed on the user  must be
    declared at this time.

    This call returns a handle to the newly opened user  that may be
    used for successive operations on the user.   This handle may be
    closed with the SamCloseHandle API.



Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the user.   These access types are reconciled
        with the Discretionary Access Control list of the user  to
        determine whether the accesses will be granted or denied.

    UserId -  Specifies the relative ID value of the user  to be
        opened.

    UserHandle -  Receives a handle referencing the newly opened
        user.   This handle will be required in successive calls to
        operate on the user.

Return Values:

    STATUS_SUCCESS - The user  was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_NO_SUCH_USER  - The specified user  does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

--*/
{
    NTSTATUS            NtStatus, IgnoreStatus;
    SAMP_OBJECT_TYPE    FoundType;
    PSAMP_OBJECT        DomainContext = (PSAMP_OBJECT) DomainHandle;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrOpenUser");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidOpenUser
                   );


    NtStatus = SampOpenAccount(
                   SampUserObjectType,
                   DomainHandle,
                   DesiredAccess,
                   UserId,
                   FALSE,
                   UserHandle
                   );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Don't check Domain Password Policy read access for loopback client 
        // Because for loopback client, we have already checked the 
        // DOMAIN_READ_PASSWORD_PARAMETERS access when we opened the DomainHandle
        // if password change operation is detected. 
        // 

        if ( DomainContext->TrustedClient || DomainContext->LoopbackClient )
        {
            ((PSAMP_OBJECT)(*UserHandle))->TypeBody.User.DomainPasswordInformationAccessible = TRUE;
        }
        else
        {
            //
            // If the domain handle allows reading the password
            // parameters, note that in the context to make life
            // easy for SampGetUserDomainPasswordInformation().
            //
            if (RtlAreAllAccessesGranted( DomainContext->GrantedAccess, DOMAIN_READ_PASSWORD_PARAMETERS)) 
            {
                ((PSAMP_OBJECT)(*UserHandle))->TypeBody.User.DomainPasswordInformationAccessible = TRUE;
            }
            else
            {
                ((PSAMP_OBJECT)(*UserHandle))->TypeBody.User.DomainPasswordInformationAccessible = FALSE;
            }

        }
    }


    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidOpenUser
                   );

    return(NtStatus);
}


NTSTATUS
SamrDeleteUser(
    IN OUT SAMPR_HANDLE *UserHandle
    )


/*++

Routine Description:

    This API deletes a user from the account database.  If the account
    being deleted is the last account in the database in the ADMIN
    group, then STATUS_LAST_ADMIN is returned, and the Delete fails.

    Note that following this call, the UserHandle is no longer valid.

Parameters:

    UserHandle - The handle of an opened user to operate on.  The handle must be
        openned for DELETE access.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_LAST_ADMIN - Cannot delete the last enabled administrator account

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/

{
    SAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed;
    UNICODE_STRING              UserName;
    NTSTATUS                    NtStatus, IgnoreStatus, TmpStatus;
    PSAMP_OBJECT                AccountContext = (PSAMP_OBJECT)(*UserHandle);
    PSAMP_DEFINED_DOMAINS       Domain = NULL;
    SAMP_OBJECT_TYPE            FoundType;
    PSID                        AccountSid = NULL;
    PGROUP_MEMBERSHIP           Groups = NULL;
    ULONG                       ObjectRid,
                                GroupCount,
                                DomainIndex,
                                i;
    BOOLEAN                     fLockAcquired = FALSE;

    DECLARE_CLIENT_REVISION(*UserHandle);


    SAMTRACE_EX("SamrDeleteUser");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidDeleteUser
                   );


    //
    // Grab the lock
    //

    NtStatus = SampMaybeAcquireWriteLock(AccountContext, &fLockAcquired);
    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }



    //
    // Validate type of, and access to object.
    //
    NtStatus = SampLookupContext(
                   AccountContext,
                   DELETE,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );



    if (NT_SUCCESS(NtStatus)) {


        ObjectRid = AccountContext->TypeBody.User.Rid;

        //
        // Get a pointer to the domain this object is in.
        // This is used for auditing.
        //

        DomainIndex = AccountContext->DomainIndex;
        Domain = &SampDefinedDomains[ DomainIndex ];

        //
        // built-in accounts can't be deleted, unless the caller is trusted
        //

        if ( !AccountContext->TrustedClient ) {

            NtStatus = SampIsAccountBuiltIn( ObjectRid );
        }


        if (!IsDsObject(AccountContext))
        {

            //
            // Get the list of groups this user is a member of.
            // Remove the user from each group. Need not do this
            // for DS Case
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampRetrieveUserMembership(
                               AccountContext,
                               FALSE, // Make copy
                               &GroupCount,
                               &Groups
                               );


                if (NT_SUCCESS(NtStatus)) {

                    ASSERT( GroupCount >  0);
                    ASSERT( Groups != NULL );


                    //
                    // Remove the user from each group.
                    //

                    for ( i=0; i<GroupCount && NT_SUCCESS(NtStatus); i++) {

                        NtStatus = SampRemoveUserFromGroup(
                                       AccountContext,
                                       Groups[i].RelativeId,
                                       ObjectRid
                                       );
                    }
                }
            }

            //
            // So far, so good.  The user has been removed from all groups.
            // Now remove the user from all aliases
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampCreateAccountSid(AccountContext, &AccountSid);

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampRemoveAccountFromAllAliases(
                                   AccountSid,
                                   NULL,
                                   FALSE,
                                   NULL,
                                   NULL,
                                   NULL
                                   );
                }
            }
        }

        //
        // Get the AccountControl flags for when we update
        // the display cache, and to let Netlogon know if this
        // is a machine account that is going away.
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampRetrieveUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );
        }

        //
        // Now we just need to clean up the user keys themselves.
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // First get and save the account name for
            // I_NetNotifyLogonOfDelta.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_USER_ACCOUNT_NAME,
                           TRUE,    // Make copy
                           &UserName
                           );

            if (NT_SUCCESS(NtStatus)) {

                //
                // This must be done before we invalidate contexts, because our
                // own handle to the group gets closed as well.
                //

                if (IsDsObject(AccountContext))
                {
                    NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs,
                                                  0     // delete object itself only
                                                  );

                    //
                    // In Windows 2000 (NT5), an object has children cannot be
                    // deleted till its children are deleted first. Thus for
                    // Net API compatibility, we have to change the
                    // delete behavior from a delete object to delete tree.
                    //

                    if ((!AccountContext->LoopbackClient) &&
                        (STATUS_DS_CANT_ON_NON_LEAF == NtStatus)
                       )
                    {
                        //
                        // We only checked the right and access control for
                        // deleting the object itself, not check the right to
                        // delete all the children underneath, so turn off fDSA
                        // here, let core DS do the rest of check.
                        //

                        SampSetDsa(FALSE);

                        NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs,
                                                      SAM_DELETE_TREE
                                                      );
                    }


                    if (NT_SUCCESS(NtStatus) && (!IsDsObject(AccountContext)) )
                    {
                        //
                        // Decrement the group count
                        //

                        NtStatus = SampAdjustAccountCount(SampUserObjectType, FALSE );
                    }

                }
                else
                {
                    NtStatus = SampDeleteUserKeys( AccountContext );
                }

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // We must invalidate any open contexts to this user.
                    // This will close all handles to the user's keys.
                    // THIS IS AN IRREVERSIBLE PROCESS.
                    //

                    SampInvalidateObjectContexts( AccountContext, ObjectRid );

                    //
                    // Commit the whole mess
                    //

                    NtStatus = SampCommitAndRetainWriteLock();

                    if ( NT_SUCCESS( NtStatus ) ) {

                        SAMP_ACCOUNT_DISPLAY_INFO AccountInfo;

                        //
                        // Update the cached Alias Information in Registry Mode
                        // in DS mode, Alias Information is updated through
                        // SampNotifyReplicatedInChange
                        //

                        if (!IsDsObject(AccountContext))
                        {
                            IgnoreStatus = SampAlRemoveAccountFromAllAliases(
                                               AccountSid,
                                               FALSE,
                                               NULL,
                                               NULL,
                                               NULL
                                               );

                            //
                            // Update the display information
                            //

                            AccountInfo.Name = UserName;
                            AccountInfo.Rid = ObjectRid;
                            AccountInfo.AccountControl = V1aFixed.UserAccountControl;
                            RtlInitUnicodeString(&AccountInfo.Comment, NULL);
                            RtlInitUnicodeString(&AccountInfo.FullName, NULL);

                            IgnoreStatus = SampUpdateDisplayInformation(
                                                            &AccountInfo,
                                                            NULL,
                                                            SampUserObjectType
                                                            );
                            ASSERT(NT_SUCCESS(IgnoreStatus));
                        }



                        //
                        // Audit the deletion before we free the write lock
                        // so that we have access to the context block.
                        //

                        //
                        // N.B. Deletion audits in the DS are performed in 
                        // the notification routine on transaction commit.
                        //
                        if (SampDoAccountAuditing(DomainIndex) &&
                            (!IsDsObject(AccountContext)) &&
                            NT_SUCCESS(NtStatus) ) {

                            SampAuditUserDelete(DomainIndex, 
                                                &UserName,
                                                &ObjectRid,
                                                V1aFixed.UserAccountControl
                                                );
                        }

                        //
                        // Notify netlogon of the change
                        //

                        SampNotifyNetlogonOfDelta(
                            SecurityDbDelete,
                            SecurityDbObjectSamUser,
                            ObjectRid,
                            &UserName,
                            (DWORD) FALSE,  // Replicate immediately
                            NULL            // Delta data
                            );

                        //
                        // Do delete auditing
                        //

                        if (NT_SUCCESS(NtStatus)) {
                            (VOID) NtDeleteObjectAuditAlarm(
                                        &SampSamSubsystem,
                                        *UserHandle,
                                        AccountContext->AuditOnClose
                                        );
                        }


                    }
                }

                SampFreeUnicodeString( &UserName );
            }
        }

        //
        // De-reference the object, discarding changes, and delete the context
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));


        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // If we actually deleted the user, delete the context and
            // let RPC know that the handle is invalid.
            //

            SampDeleteContext( AccountContext );

            (*UserHandle) = NULL;
        }

    } //end_if

    //
    // Free the lock -
    //
    // Everything has already been committed above, so we must indicate
    // no additional changes have taken place.
    //
    //
    //

    TmpStatus = SampMaybeReleaseWriteLock( fLockAcquired, FALSE );

    if (NtStatus == STATUS_SUCCESS) {
        NtStatus = TmpStatus;
    }

    //
    // If necessary, free the AccountSid.
    //

    if (AccountSid != NULL) {

        MIDL_user_free(AccountSid);
        AccountSid = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidDeleteUser
                   );

    return(NtStatus);
}


NTSTATUS
SamrQueryInformationUser(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    OUT PSAMPR_USER_INFO_BUFFER *Buffer
    )
{
    //
    // This is a thin veil to SamrQueryInformationUser2().
    // This is needed so that new-release systems can call
    // this routine without the danger of passing an info
    // level that release 1.0 systems didn't understand.
    //

    return( SamrQueryInformationUser2(UserHandle, UserInformationClass, Buffer ) );
}


NTSTATUS
SamrQueryInformationUser2(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    OUT PSAMPR_USER_INFO_BUFFER *Buffer
    )

/*++

Routine Description:

    User object QUERY information routine.

Arguments:

    UserHandle - RPC context handle for an open user object.

    UserInformationClass - Type of information being queried.

    Buffer - To receive the output (queried) information.


Return Value:


    STATUS_INVALID_INFO_CLASS - An unknown information class was requested.
        No information has been returned.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to
        return(the requested information in.


--*/
{
    NTSTATUS    NtStatus;
    ULONG       WhichFields;
    DECLARE_CLIENT_REVISION(UserHandle);

    SAMTRACE_EX("SamrQueryInformationUser2");


    WhichFields = USER_ALL_READ_GENERAL_MASK         |
                              USER_ALL_READ_LOGON_MASK           |
                              USER_ALL_READ_ACCOUNT_MASK         |
                              USER_ALL_READ_PREFERENCES_MASK     |
                              USER_ALL_READ_TRUSTED_MASK;

    NtStatus = SampQueryInformationUserInternal(
                    UserHandle,
                    UserInformationClass,
                    FALSE,
                    WhichFields,
                    0,
                    Buffer
                    );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    return NtStatus;
}

NTSTATUS
SampQueryInformationUserInternal(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN BOOLEAN  LockHeld,
    IN ULONG    FieldsForUserAllInformation,
    IN ULONG    ExtendedFieldsForUserInternal6Information,
    OUT PSAMPR_USER_INFO_BUFFER *Buffer
    )
/*++

Routine Description:

    Internal User object QUERY information routine.

Arguments:

    UserHandle - RPC context handle for an open user object.

    UserInformationClass - Type of information being queried.

    Buffer - To receive the output (queried) information.


Return Value:


    STATUS_INVALID_INFO_CLASS - An unknown information class was requested.
        No information has been returned.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to
        return(the requested information in.


--*/
{

    NTSTATUS                NtStatus;
    NTSTATUS                IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    PSAMP_DEFINED_DOMAINS   Domain;
    PUSER_ALL_INFORMATION   All;
    SAMP_OBJECT_TYPE        FoundType;
    ACCESS_MASK             DesiredAccess;
    ULONG                   i, WhichFields = 0;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN                 NoErrorsYet;
    LM_OWF_PASSWORD         LmOwfPassword;
    NT_OWF_PASSWORD         NtOwfPassword;
    BOOLEAN                 NtPasswordNonNull, LmPasswordNonNull;
    BOOLEAN                 NtPasswordPresent;

    //
    // Used for tracking allocated blocks of memory - so we can deallocate
    // them in case of error.  Don't exceed this number of allocated buffers.
    //                                      ||
    //                                      vv
    PVOID                   AllocatedBuffer[64];
    ULONG                   AllocatedBufferCount = 0;
    LARGE_INTEGER           TempTime;
    BOOLEAN                 LockAcquired = FALSE;

    SAMTRACE("SampQueryInformationUserInternal");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQueryInformationUser
                   );


    #define RegisterBuffer(Buffer)                                      \
        {                                                               \
            if ((Buffer) != NULL) {                                     \
                                                                        \
                ASSERT(AllocatedBufferCount <                           \
                       sizeof(AllocatedBuffer) / sizeof(*AllocatedBuffer)); \
                                                                        \
                AllocatedBuffer[AllocatedBufferCount++] = (Buffer);     \
            }                                                           \
        }

    #define AllocateBuffer(NewBuffer, Size)                             \
        {                                                               \
            (NewBuffer) = MIDL_user_allocate(Size);                     \
            RegisterBuffer(NewBuffer);                                  \
            if (NULL!=NewBuffer)                                        \
                RtlZeroMemory(NewBuffer,Size);                          \
        }                                                               \



    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Buffer != NULL);
    ASSERT ((*Buffer) == NULL);

    if (!((Buffer!=NULL)&&(*Buffer==NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }


    //
    // Set the desired access based upon information class.
    //
    switch (UserInformationClass) {

    case UserInternal3Information:
    case UserAllInformation:
    case UserInternal6Information:

        //
        // For trusted clients, we will return everything.  For
        // others, we will return everything that they have access to.
        // In either case, we'll have to look at some variables in the
        // context so we'll do the work after the SampLookupContext()
        // below.
        //

        DesiredAccess = 0;
        break;

    case UserAccountInformation:

        DesiredAccess = (USER_READ_GENERAL      |
                        USER_READ_PREFERENCES   |
                        USER_READ_LOGON         |
                        USER_READ_ACCOUNT);
        break;

    case UserGeneralInformation:
    case UserPrimaryGroupInformation:
    case UserNameInformation:
    case UserAccountNameInformation:
    case UserFullNameInformation:
    case UserAdminCommentInformation:

        DesiredAccess = USER_READ_GENERAL;
        break;


    case UserPreferencesInformation:

        DesiredAccess = (USER_READ_PREFERENCES |
                        USER_READ_GENERAL);
        break;


    case UserLogonInformation:

        DesiredAccess = (USER_READ_GENERAL      |
                        USER_READ_PREFERENCES   |
                        USER_READ_LOGON         |
                        USER_READ_ACCOUNT);
        break;

    case UserLogonHoursInformation:
    case UserHomeInformation:
    case UserScriptInformation:
    case UserProfileInformation:
    case UserWorkStationsInformation:

        DesiredAccess = USER_READ_LOGON;
        break;


    case UserControlInformation:
    case UserExpiresInformation:
    case UserParametersInformation:

        DesiredAccess = USER_READ_ACCOUNT;
        break;



    case UserInternal1Information:
    case UserInternal2Information:

        //
        // These levels are only queryable by trusted clients.  The code
        // below will check AccountContext->TrustedClient after calling
        // SampLookupContext, and only return the data if it is TRUE.
        //

        DesiredAccess = (ACCESS_MASK)0;    // Trusted client; no need to verify
        break;


    case UserSetPasswordInformation:        // Can't query password
    default:

        NtStatus = STATUS_INVALID_INFO_CLASS;
        goto Error;

    } // end_switch




    //
    // Allocate the info structure
    //

    switch (UserInformationClass)
    {
    case UserInternal6Information:
        AllocateBuffer(*Buffer,sizeof(USER_INTERNAL6_INFORMATION));
        break;
    default:
        AllocateBuffer(*Buffer, sizeof(SAMPR_USER_INFO_BUFFER) );
    }

    if ((*Buffer) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }




    AccountContext = (PSAMP_OBJECT)UserHandle;

    //
    // Acquire the Read lock if required
    //

    if (!LockHeld)
    {
        SampMaybeAcquireReadLock(AccountContext, 
                                 DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                                 &LockAcquired);
    }

    //
    // Validate type of, and access to object.
    //

    NtStatus = SampLookupContext(
                    AccountContext,
                    DesiredAccess,
                    SampUserObjectType,           // ExpectedType
                    &FoundType
                    );


    if ((STATUS_ACCESS_DENIED==NtStatus)
        && (UserParametersInformation==UserInformationClass)
        && (IsDsObject(AccountContext))
        && ( AccountContext->TypeBody.User.UparmsInformationAccessible))
    {

        //
        // In DS mode if we are asking for user parms, check if the saved access ck
        // indicates that we have access to that then allow the read to proceed
        //

         NtStatus = SampLookupContext(
                        AccountContext,
                        0,
                        SampUserObjectType,           // ExpectedType
                        &FoundType
                        );
    }




    if (NT_SUCCESS(NtStatus)) {

        //
        // If the information level requires, retrieve the V1_FIXED record
        // from the registry.
        //

        switch (UserInformationClass) {

        case UserInternal3Information:
        case UserInternal6Information:
            //
            // Only trusted clients may query for this class.
            //

            if ( !AccountContext->TrustedClient ) {
                NtStatus = STATUS_INVALID_INFO_CLASS;
                break;
            }

            //
            // Drop through to the UserAll case
            //

        case UserAllInformation: {

            //
            // We weren't able to check the security stuff above, so do
            // it now.
            //

            if ( AccountContext->TrustedClient ) {

                //
                // Give everything to trusted clients, except fields that
                // can't be queried at all.
                //

                if ( 0==FieldsForUserAllInformation)
                {
                     WhichFields = USER_ALL_READ_GENERAL_MASK |
                                   USER_ALL_READ_LOGON_MASK |
                                   USER_ALL_READ_ACCOUNT_MASK |
                                   USER_ALL_READ_PREFERENCES_MASK |
                                   USER_ALL_READ_TRUSTED_MASK;
                }
                else
                {

                     WhichFields = FieldsForUserAllInformation;
                }

            } else {


                //
                // Only return fields that the caller has access to.
                //

                WhichFields = 0;

                if ( RtlAreAllAccessesGranted(
                    AccountContext->GrantedAccess,
                    USER_READ_GENERAL ) ) {

                    WhichFields |= USER_ALL_READ_GENERAL_MASK;
                }

                if ( RtlAreAllAccessesGranted(
                    AccountContext->GrantedAccess,
                    USER_READ_LOGON ) ) {

                    WhichFields |= USER_ALL_READ_LOGON_MASK;
                }

                if ( RtlAreAllAccessesGranted(
                    AccountContext->GrantedAccess,
                    USER_READ_ACCOUNT ) ) {

                    WhichFields |= USER_ALL_READ_ACCOUNT_MASK;
                }

                if ( RtlAreAllAccessesGranted(
                    AccountContext->GrantedAccess,
                    USER_READ_PREFERENCES ) ) {

                    WhichFields |= USER_ALL_READ_PREFERENCES_MASK;
                }

                if ( WhichFields == 0 ) {

                    //
                    // Caller doesn't have access to ANY fields.
                    //

                    NtStatus = STATUS_ACCESS_DENIED;
                    break;
                }
            }
        }

        //
        // fall through to pick up the V1aFixed information
        //

        case UserGeneralInformation:
        case UserPrimaryGroupInformation:
        case UserPreferencesInformation:
        case UserLogonInformation:
        case UserAccountInformation:
        case UserControlInformation:
        case UserExpiresInformation:
        case UserInternal2Information:

            NtStatus = SampRetrieveUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );


            break;

        default:

            NtStatus = STATUS_SUCCESS;

        } // end_switch

        if (NT_SUCCESS(NtStatus)) {

            PUSER_INTERNAL6_INFORMATION Internal6 = NULL;

            //
            // case on the type information requested
            //

            switch (UserInformationClass) {

            case UserInternal6Information:

                 Internal6 = (PUSER_INTERNAL6_INFORMATION) (*Buffer);


                 if ((ExtendedFieldsForUserInternal6Information &
                            USER_EXTENDED_FIELD_A2D2 ) &&
                     (NULL!=AccountContext->TypeBody.User.A2D2List))

                 {
                    NtStatus = SampCopyA2D2Attribute(
                                    AccountContext->TypeBody.User.A2D2List,
                                    &Internal6->A2D2List
                                    );

                     if (NT_SUCCESS(NtStatus)){
                         RegisterBuffer(Internal6->A2D2List);
                         Internal6->ExtendedFields |= USER_EXTENDED_FIELD_A2D2;
                     }
                 }

                 if ((NT_SUCCESS(NtStatus)) &&
                    (ExtendedFieldsForUserInternal6Information 
                                        & USER_EXTENDED_FIELD_UPN )) 
                 {
                    NtStatus = SampDuplicateUnicodeString(
                                    &AccountContext->TypeBody.User.UPN,
                                    &Internal6->UPN
                                    );

                     if (NT_SUCCESS(NtStatus)){
                         RegisterBuffer(Internal6->UPN.Buffer);
                         Internal6->ExtendedFields |= USER_EXTENDED_FIELD_UPN;
                         Internal6->UPNDefaulted =  AccountContext->TypeBody.User.UpnDefaulted;
                     }
                 }
                 
            case UserInternal3Information:
            case UserAllInformation:
        

                //
                // All and Internal3 are the same except Internal3 has
                // an extra field. Internal6 is the same as internal 3
                // information, except that it has more extra fields.
                //

                All = (PUSER_ALL_INFORMATION)(*Buffer);

                Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

                if ((NT_SUCCESS(NtStatus)) &&
                    (WhichFields & ( USER_ALL_PASSWORDMUSTCHANGE |
                     USER_ALL_NTPASSWORDPRESENT )) ) {

                    //
                    // These fields will need some info from
                    // SampRetrieveUserPasswords().
                    //

                    NtStatus = SampRetrieveUserPasswords(
                                    AccountContext,
                                    &LmOwfPassword,
                                    &LmPasswordNonNull,
                                    &NtOwfPassword,
                                    &NtPasswordPresent,
                                    &NtPasswordNonNull
                                    );
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_USERNAME ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ACCOUNT_NAME,
                                   TRUE,    // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->All.UserName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->UserName.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_FULLNAME ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->FullName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->FullName.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_USERID ) ) {

                    All->UserId = V1aFixed.UserId;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PRIMARYGROUPID ) ) {

                    All->PrimaryGroupId = V1aFixed.PrimaryGroupId;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_ADMINCOMMENT ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ADMIN_COMMENT,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->AdminComment)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->AdminComment.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_USERCOMMENT ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_USER_COMMENT,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->UserComment) // Body
                                   );
                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->UserComment.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_HOMEDIRECTORY ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->HomeDirectory)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->HomeDirectory.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_HOMEDIRECTORYDRIVE ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->HomeDirectoryDrive)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->HomeDirectoryDrive.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_SCRIPTPATH ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_SCRIPT_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->ScriptPath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->ScriptPath.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PROFILEPATH ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PROFILE_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->ProfilePath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->ProfilePath.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_WORKSTATIONS ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_WORKSTATIONS,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->WorkStations)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->WorkStations.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_LASTLOGON ) ) {

                    All->LastLogon = V1aFixed.LastLogon;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_LASTLOGOFF ) ) {

                    All->LastLogoff = V1aFixed.LastLogoff;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_LOGONHOURS ) ) {

                    NtStatus = SampRetrieveUserLogonHours(
                                   AccountContext,
                                   (PLOGON_HOURS)&(All->LogonHours)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        if (All->LogonHours.LogonHours != NULL) {

                            RegisterBuffer(All->LogonHours.LogonHours);
                        }
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_BADPASSWORDCOUNT ) ) {

                    All->BadPasswordCount = SampQueryBadPasswordCount( AccountContext, &V1aFixed );

                    if (UserInformationClass == UserInternal3Information) {
                        (*Buffer)->Internal3.LastBadPasswordTime = V1aFixed.LastBadPasswordTime;
                    }

                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_LOGONCOUNT ) ) {

                    All->LogonCount = V1aFixed.LogonCount;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PASSWORDCANCHANGE ) ) {

                    if ( !NtPasswordNonNull && !LmPasswordNonNull ) {

                        //
                        // Null passwords can be changed immediately.
                        //

                        All->PasswordCanChange = SampHasNeverTime;

                    } else {

                        All->PasswordCanChange = SampAddDeltaTime(
                                                     V1aFixed.PasswordLastSet,
                                                     Domain->UnmodifiedFixed.MinPasswordAge);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields &
                     (USER_ALL_PASSWORDMUSTCHANGE|USER_ALL_PASSWORDEXPIRED) ) ) {

                    All->PasswordMustChange = SampGetPasswordMustChange(
                                                  V1aFixed.UserAccountControl,
                                                  V1aFixed.PasswordLastSet,
                                                  Domain->UnmodifiedFixed.MaxPasswordAge);
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PASSWORDEXPIRED ) ) {

                    LARGE_INTEGER TimeNow;

                    NtStatus = NtQuerySystemTime( &TimeNow );
                    if (NT_SUCCESS(NtStatus)) {
                        if ( TimeNow.QuadPart >= All->PasswordMustChange.QuadPart) {

                            All->PasswordExpired = TRUE;

                        } else {

                            All->PasswordExpired = FALSE;
                        }
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PASSWORDLASTSET ) ) {

                    All->PasswordLastSet = V1aFixed.PasswordLastSet;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_ACCOUNTEXPIRES ) ) {

                    All->AccountExpires = V1aFixed.AccountExpires;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_USERACCOUNTCONTROL ) ) {

                    All->UserAccountControl = V1aFixed.UserAccountControl;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PARAMETERS ) ) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PARAMETERS,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&(All->Parameters)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer(All->Parameters.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_COUNTRYCODE ) ) {

                    All->CountryCode = V1aFixed.CountryCode;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_CODEPAGE ) ) {

                    All->CodePage = V1aFixed.CodePage;
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_NTPASSWORDPRESENT ) ) {

                    ASSERT( WhichFields & USER_ALL_LMPASSWORDPRESENT);

                    All->LmPasswordPresent = LmPasswordNonNull;
                    All->NtPasswordPresent = NtPasswordNonNull;

                    RtlInitUnicodeString(&All->LmPassword, NULL);
                    RtlInitUnicodeString(&All->NtPassword, NULL);

                    if ( LmPasswordNonNull ) {

                        All->LmPassword.Buffer =
                            MIDL_user_allocate( LM_OWF_PASSWORD_LENGTH );

                        if ( All->LmPassword.Buffer == NULL ) {

                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                        } else {

                            RegisterBuffer(All->LmPassword.Buffer);

                            All->LmPassword.Length = LM_OWF_PASSWORD_LENGTH;
                            All->LmPassword.MaximumLength =
                                LM_OWF_PASSWORD_LENGTH;
                            RtlCopyMemory(
                                All->LmPassword.Buffer,
                                &LmOwfPassword,
                                LM_OWF_PASSWORD_LENGTH
                                );
                        }
                    }

                    if ( NT_SUCCESS( NtStatus ) ) {

                        if ( NtPasswordPresent ) {

                            All->NtPassword.Buffer =
                                MIDL_user_allocate( NT_OWF_PASSWORD_LENGTH );

                            if ( All->NtPassword.Buffer == NULL ) {

                                NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                            } else {

                                RegisterBuffer(All->NtPassword.Buffer);

                                All->NtPassword.Length = NT_OWF_PASSWORD_LENGTH;
                                All->NtPassword.MaximumLength =
                                    NT_OWF_PASSWORD_LENGTH;
                                RtlCopyMemory(
                                    All->NtPassword.Buffer,
                                    &NtOwfPassword,
                                    NT_OWF_PASSWORD_LENGTH
                                    );
                            }
                        }
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_PRIVATEDATA ) ) {

                    All->PrivateDataSensitive = TRUE;

                    NtStatus = SampGetPrivateUserData(
                                   AccountContext,
                                   (PULONG)
                                   (&(All->PrivateData.Length)),
                                   (PVOID *)
                                   (&(All->PrivateData.Buffer))
                                   );
                    if (NT_SUCCESS(NtStatus)) {

                        All->PrivateData.MaximumLength =
                            All->PrivateData.Length;

                        RegisterBuffer(All->PrivateData.Buffer);
                    }
                }

                if ( (NT_SUCCESS( NtStatus )) &&
                    ( WhichFields & USER_ALL_SECURITYDESCRIPTOR ) ) {

                    NtStatus = SampGetObjectSD(
                                   AccountContext,
                                   &(All->SecurityDescriptor.Length),
                                   (PSECURITY_DESCRIPTOR *)
                                   &(All->SecurityDescriptor.SecurityDescriptor)
                                   );
                    if (NT_SUCCESS(NtStatus)) {

                        if ((IsDsObject(AccountContext))
                            && (!((AccountContext->TrustedClient)
                                &&(UserAllInformation==UserInformationClass))))
                        {
                            //
                            // For a DS object downgrade the security descrriptor
                            // to NT4. Do not do so for the Logon Case ( Trusted
                            // Client Asking for UserAllInformation). NT4 Replication
                            // uses UserInternal3Information, so we are OK in throwing
                            // in this performance hack. This is an important
                            // performance optimization, because security descriptor
                            // conversion is a slow process.
                            //

                            PSID                    SelfSid;
                            PSECURITY_DESCRIPTOR    Nt5SD =
                                All->SecurityDescriptor.SecurityDescriptor;


                            All->SecurityDescriptor.SecurityDescriptor = NULL;

                            //
                            // Get the Self Sid
                            //

                            if (AccountContext->ObjectNameInDs->SidLen>0)
                                SelfSid = &(AccountContext->ObjectNameInDs->Sid);
                            else
                                SelfSid = SampDsGetObjectSid(
                                                AccountContext->ObjectNameInDs);

                            if (NULL!=SelfSid)
                            {


                                NtStatus = SampConvertNt5SdToNt4SD(
                                                Nt5SD,
                                                AccountContext,
                                                SelfSid,
                                                &All->SecurityDescriptor.SecurityDescriptor
                                                );

                                if (NT_SUCCESS(NtStatus))
                                {

                                    //
                                    // Free the original security descriptor
                                    //

                                    MIDL_user_free(Nt5SD);

                                    //
                                    // Compute length of new NT4 Security Descriptor
                                    //

                                    All->SecurityDescriptor.Length =
                                        GetSecurityDescriptorLength(
                                            All->SecurityDescriptor.SecurityDescriptor
                                            );

                                    RegisterBuffer(All->SecurityDescriptor.SecurityDescriptor);
                                }
                            }
                            else
                            {
                                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                            }
                        }
                        else
                        {
                            RegisterBuffer(All->SecurityDescriptor.SecurityDescriptor);
                        }


                    }
                }

                if ( NT_SUCCESS( NtStatus ) ) {

                    All->WhichFields = WhichFields;
                }

                break;

            case UserAccountInformation:

                NoErrorsYet = TRUE;


                (*Buffer)->Account.UserId           = V1aFixed.UserId;
                (*Buffer)->Account.PrimaryGroupId   = V1aFixed.PrimaryGroupId;

                (*Buffer)->Account.LastLogon =
                    *((POLD_LARGE_INTEGER)&V1aFixed.LastLogon);

                (*Buffer)->Account.LastLogoff =
                    *((POLD_LARGE_INTEGER)&V1aFixed.LastLogoff);


                (*Buffer)->Account.BadPasswordCount = SampQueryBadPasswordCount( AccountContext, &V1aFixed );
                (*Buffer)->Account.LogonCount       = V1aFixed.LogonCount;

                (*Buffer)->Account.PasswordLastSet =
                    *((POLD_LARGE_INTEGER)&V1aFixed.PasswordLastSet);

                (*Buffer)->Account.AccountExpires =
                    *((POLD_LARGE_INTEGER)&V1aFixed.AccountExpires);

                (*Buffer)->Account.UserAccountControl = V1aFixed.UserAccountControl;


                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ACCOUNT_NAME,
                                   TRUE,    // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.UserName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.UserName.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.FullName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.FullName.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.HomeDirectory)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.HomeDirectory.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.HomeDirectoryDrive)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.HomeDirectoryDrive.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_SCRIPT_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.ScriptPath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.ScriptPath.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }



                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PROFILE_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.ProfilePath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.ProfilePath.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }



                if (NoErrorsYet == TRUE) {

                        NtStatus = SampGetUnicodeStringAttribute(
                                       AccountContext,
                                       SAMP_USER_ADMIN_COMMENT,
                                       TRUE, // Make copy
                                       (PUNICODE_STRING)&((*Buffer)->Account.AdminComment) // Body
                                       );

                        if (NT_SUCCESS(NtStatus)) {

                            RegisterBuffer((*Buffer)->Account.AdminComment.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }



                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_WORKSTATIONS,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Account.WorkStations)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Account.WorkStations.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }




                //
                // Now get the logon hours
                //


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampRetrieveUserLogonHours(
                                   AccountContext,
                                   (PLOGON_HOURS)&((*Buffer)->Account.LogonHours)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        if ((*Buffer)->Account.LogonHours.LogonHours != NULL) {

                            RegisterBuffer((*Buffer)->Account.LogonHours.LogonHours);
                        }

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }

                break;


            case UserGeneralInformation:


                (*Buffer)->General.PrimaryGroupId   = V1aFixed.PrimaryGroupId;



                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_ACCOUNT_NAME,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->General.UserName)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->General.UserName.Buffer);

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->General.FullName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->General.FullName.Buffer);

                        NtStatus = SampGetUnicodeStringAttribute(
                                       AccountContext,
                                       SAMP_USER_ADMIN_COMMENT,
                                       TRUE, // Make copy
                                       (PUNICODE_STRING)&((*Buffer)->General.AdminComment) // Body
                                       );

                        if (NT_SUCCESS(NtStatus)) {

                            RegisterBuffer((*Buffer)->General.AdminComment.Buffer);

                            NtStatus = SampGetUnicodeStringAttribute(
                                           AccountContext,
                                           SAMP_USER_USER_COMMENT,
                                           TRUE, // Make copy
                                           (PUNICODE_STRING)&((*Buffer)->General.UserComment) // Body
                                           );
                            if (NT_SUCCESS(NtStatus)) {

                                RegisterBuffer((*Buffer)->General.UserComment.Buffer);
                            }
                        }
                    }
                }


                break;


            case UserNameInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_ACCOUNT_NAME,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Name.UserName) // Body
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Name.UserName.Buffer);

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Name.FullName) // Body
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Name.FullName.Buffer);
                    }
                }


                break;


            case UserAccountNameInformation:

                //
                // Get copy of the string we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_ACCOUNT_NAME,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->AccountName.UserName) // Body
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->AccountName.UserName.Buffer);
                }


                break;


            case UserFullNameInformation:

                //
                // Get copy of the string we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_FULL_NAME,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->FullName.FullName) // Body
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->FullName.FullName.Buffer);
                }


                break;


            case UserAdminCommentInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_ADMIN_COMMENT,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->AdminComment.AdminComment) // Body
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->AdminComment.AdminComment.Buffer);
                }


                break;


            case UserPrimaryGroupInformation:


                (*Buffer)->PrimaryGroup.PrimaryGroupId   = V1aFixed.PrimaryGroupId;

                break;


            case UserPreferencesInformation:


                (*Buffer)->Preferences.CountryCode  = V1aFixed.CountryCode;
                (*Buffer)->Preferences.CodePage     = V1aFixed.CodePage;



                //
                // Read the UserComment field from the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_USER_COMMENT,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Preferences.UserComment) // Body
                               );
                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Preferences.UserComment.Buffer);

                    //
                    // This field isn't used, but make sure RPC doesn't
                    // choke on it.
                    //

                    (*Buffer)->Preferences.Reserved1.Length = 0;
                    (*Buffer)->Preferences.Reserved1.MaximumLength = 0;
                    (*Buffer)->Preferences.Reserved1.Buffer = NULL;
                }


                break;


            case UserParametersInformation:


                //
                // Read the Parameters field from the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_PARAMETERS,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Parameters.Parameters)
                               );
                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Parameters.Parameters.Buffer);
                }


                break;


            case UserLogonInformation:

                NoErrorsYet = TRUE;

                Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

                (*Buffer)->Logon.UserId           = V1aFixed.UserId;
                (*Buffer)->Logon.PrimaryGroupId   = V1aFixed.PrimaryGroupId;

                (*Buffer)->Logon.LastLogon =
                    *((POLD_LARGE_INTEGER)&V1aFixed.LastLogon);

                (*Buffer)->Logon.LastLogoff =
                    *((POLD_LARGE_INTEGER)&V1aFixed.LastLogoff);

                (*Buffer)->Logon.BadPasswordCount = V1aFixed.BadPasswordCount;

                (*Buffer)->Logon.PasswordLastSet =
                    *((POLD_LARGE_INTEGER)&V1aFixed.PasswordLastSet);

                TempTime = SampAddDeltaTime(
                                V1aFixed.PasswordLastSet,
                                Domain->UnmodifiedFixed.MinPasswordAge );

                (*Buffer)->Logon.PasswordCanChange =
                    *((POLD_LARGE_INTEGER)&TempTime);


                TempTime = SampGetPasswordMustChange(
                                V1aFixed.UserAccountControl,
                                V1aFixed.PasswordLastSet,
                                Domain->UnmodifiedFixed.MaxPasswordAge);

                (*Buffer)->Logon.PasswordMustChange =
                    *((POLD_LARGE_INTEGER)&TempTime);


                (*Buffer)->Logon.LogonCount       = V1aFixed.LogonCount;
                (*Buffer)->Logon.UserAccountControl = V1aFixed.UserAccountControl;


                //
                // If there is no password on the account then
                // modify the password can/must change times
                // so that the password never expires and can
                // be changed immediately.
                //

                NtStatus = SampRetrieveUserPasswords(
                                AccountContext,
                                &LmOwfPassword,
                                &LmPasswordNonNull,
                                &NtOwfPassword,
                                &NtPasswordPresent,
                                &NtPasswordNonNull
                                );

                if (NT_SUCCESS(NtStatus)) {

                    if ( !NtPasswordNonNull && !LmPasswordNonNull ) {

                        //
                        // The password is NULL.
                        // It can be changed immediately.
                        //

                        (*Buffer)->Logon.PasswordCanChange =
                            *((POLD_LARGE_INTEGER)&SampHasNeverTime);

                    }
                } else {
                    NoErrorsYet = FALSE;
                }


                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ACCOUNT_NAME,
                                   TRUE,    // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.UserName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.UserName.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.FullName)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.FullName.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.HomeDirectory)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.HomeDirectory.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.HomeDirectoryDrive)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.HomeDirectoryDrive.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_SCRIPT_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.ScriptPath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.ScriptPath.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }



                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PROFILE_PATH,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.ProfilePath)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.ProfilePath.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }



                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_WORKSTATIONS,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Logon.WorkStations)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Logon.WorkStations.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }




                //
                // Now get the logon hours
                //


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampRetrieveUserLogonHours(
                                   AccountContext,
                                   (PLOGON_HOURS)&((*Buffer)->Logon.LogonHours)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        if ((*Buffer)->Logon.LogonHours.LogonHours != NULL) {

                            RegisterBuffer((*Buffer)->Logon.LogonHours.LogonHours);
                        }

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }

                break;


            case UserLogonHoursInformation:

                NtStatus = SampRetrieveUserLogonHours(
                               AccountContext,
                               (PLOGON_HOURS)&((*Buffer)->LogonHours.LogonHours)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    if ((*Buffer)->LogonHours.LogonHours.LogonHours != NULL) {

                        RegisterBuffer((*Buffer)->LogonHours.LogonHours.LogonHours);
                    }
                }

                break;


            case UserHomeInformation:

                NoErrorsYet = TRUE;

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                if (NoErrorsYet == TRUE) {


                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Home.HomeDirectory)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Home.HomeDirectory.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }


                if (NoErrorsYet == TRUE) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   TRUE, // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->Home.HomeDirectoryDrive)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->Home.HomeDirectoryDrive.Buffer);

                    } else {
                        NoErrorsYet = FALSE;
                    }
                }

                break;


            case UserScriptInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_SCRIPT_PATH,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Script.ScriptPath)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Script.ScriptPath.Buffer);
                }

                break;


            case UserProfileInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_PROFILE_PATH,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Profile.ProfilePath)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Profile.ProfilePath.Buffer);
                }

                break;


            case UserWorkStationsInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_WORKSTATIONS,
                               TRUE, // Make copy
                               (PUNICODE_STRING)&((*Buffer)->WorkStations.WorkStations)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->WorkStations.WorkStations.Buffer);
                }

                break;


            case UserControlInformation:

                (*Buffer)->Control.UserAccountControl     = V1aFixed.UserAccountControl;
                break;


            case UserExpiresInformation:

                (*Buffer)->Expires.AccountExpires     = V1aFixed.AccountExpires;

                break;


            case UserInternal1Information:

                if ( AccountContext->TrustedClient ) {

                    //
                    // PasswordExpired is a 'write only' flag.
                    // We always return FALSE on read.
                    //

                    (*Buffer)->Internal1.PasswordExpired = FALSE;

                    //
                    // Retrieve the OWF passwords.
                    // Since this is a trusted client, we don't need to
                    // reencrypt the OWFpasswords we return - so we stuff
                    // the OWFs into the structure that holds encryptedOWFs.
                    //

                    ASSERT( ENCRYPTED_LM_OWF_PASSWORD_LENGTH == LM_OWF_PASSWORD_LENGTH );
                    ASSERT( ENCRYPTED_NT_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH );

                    NtStatus = SampRetrieveUserPasswords(
                                    AccountContext,
                                    (PLM_OWF_PASSWORD)&(*Buffer)->Internal1.
                                            EncryptedLmOwfPassword,
                                    &(*Buffer)->Internal1.
                                            LmPasswordPresent,
                                    (PNT_OWF_PASSWORD)&(*Buffer)->Internal1.
                                            EncryptedNtOwfPassword,
                                    &NtPasswordPresent,
                                    &(*Buffer)->Internal1.NtPasswordPresent // Return the Non-NULL flag here
                                    );

                } else {

                    //
                    // This information is only queryable by trusted
                    // clients.
                    //

                    NtStatus = STATUS_INVALID_INFO_CLASS;
                }

                break;


            case UserInternal2Information:

                if ( AccountContext->TrustedClient ) {

                    (*Buffer)->Internal2.LastLogon =
                        *((POLD_LARGE_INTEGER)&V1aFixed.LastLogon);

                    (*Buffer)->Internal2.LastLogoff =
                        *((POLD_LARGE_INTEGER)&V1aFixed.LastLogoff);

                    (*Buffer)->Internal2.BadPasswordCount  = V1aFixed.BadPasswordCount;
                    (*Buffer)->Internal2.LogonCount        = V1aFixed.LogonCount;

                } else {

                    //
                    // This information is only queryable by trusted
                    // clients.
                    //

                    NtStatus = STATUS_INVALID_INFO_CLASS;
                }

                break;

            }

        }

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

    //
    // Free the read lock
    //


    if (!LockHeld)
    {
        SampMaybeReleaseReadLock(LockAcquired);
    }



    //
    // If we didn't succeed, free any allocated memory
    //

    if (!NT_SUCCESS(NtStatus)) {
        for ( i=0; i<AllocatedBufferCount ; i++ ) {
            MIDL_user_free( AllocatedBuffer[i] );
        }

        (*Buffer) = NULL;
    }

Error:

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQueryInformationUser
                   );

    return(NtStatus);

}


NTSTATUS
SampIsUserAccountControlValid(
    IN PSAMP_OBJECT Context,
    IN ULONG UserAccountControl
    )

/*++

Routine Description:

    This routine checks a UserAccountControl field to make sure that
    the bits set make sense.

    NOTE: if the set operation is also setting passwords, it must set the
    passwords BEFORE calling this routine!


Parameters:

    Context - the context of the account being changed.

    UserAccountControl - the field that is about to be set.


Return Values:

    STATUS_SUCCESS - The UserAccountControl field is valid.

    STATUS_SPECIAL_ACCOUNT - The administrator account can't be disabled.

    STATUS_INVALID_PARAMETER - an undefined bit is set, or more than one
        account type bit is set.

    STATUS_INVALID_PARAMETER_MIX - USER_PASSWORD_NOT_REQUIRED has been
        turned off, but there isn't a bonafide password on the account.

--*/

{
    NTSTATUS  NtStatus = STATUS_SUCCESS;


    SAMTRACE("SampIsUserAccountControlValid");



    //
    // Make sure that undefined bits aren't set.
    //

    if ( ( UserAccountControl & ~(NEXT_FREE_ACCOUNT_CONTROL_BIT - 1) ) != 0 ) {

        DbgPrint("SAM: Setting undefined AccountControl flag(s): 0x%lx for user %d\n",
                 UserAccountControl, Context->TypeBody.User.Rid);

        return (STATUS_INVALID_PARAMETER);
    }


     //
     // Make sure that the krbtgt account is'nt enabled
     //

     if (!( UserAccountControl & USER_ACCOUNT_DISABLED )) {

         if ( Context->TypeBody.User.Rid == DOMAIN_USER_RID_KRBTGT ) {

             return( STATUS_SPECIAL_ACCOUNT );
         }
     }

     //
     // Don't allow the restore mode administrator account to be
     // disabled
     //

     if ((UserAccountControl & USER_ACCOUNT_DISABLED ) &&
         (Context->TypeBody.User.Rid == DOMAIN_USER_RID_ADMIN) &&
         (LsaISafeMode()))
     {
         return( STATUS_SPECIAL_ACCOUNT);
     }


  
    //
    // Make sure that exactly one of the account type bits is set.
    //

    switch ( UserAccountControl & USER_ACCOUNT_TYPE_MASK ) {


        case USER_NORMAL_ACCOUNT:
        case USER_SERVER_TRUST_ACCOUNT:
        case USER_WORKSTATION_TRUST_ACCOUNT:
        case USER_INTERDOMAIN_TRUST_ACCOUNT:

            break;


        case USER_TEMP_DUPLICATE_ACCOUNT:

            //
            // Temp duplicate accounts were a concept in Lan Manager
            // that has outlived its usefulness, therefore banish them
            //

        default:

            return( STATUS_INVALID_PARAMETER );
    }

    //
    // If USER_PASSWORD_NOT_REQUIRED is turned off, make sure that there
    // already is a password.  Note that this requires that the password
    // be set before calling this routine, if both are being done at once.
    //
    // Do not enforce this check for Machine Accounts. The fear here is that
    // we may break net join from downlevel clients. Also this is not a real
    // issue as we expect machines to automatically set very strong passwords.
    //
    // Further enforce this policy only when password length policy is being
    // set, else this would break net user /add in the simple case.
    //
    // Finally, should not enforce it for Trusted Client (such as Inter Domain
    // move object, they may set UserAccountControl first, then set password
    // later)
    //


    if (( ( UserAccountControl & USER_PASSWORD_NOT_REQUIRED ) == 0 )
        && ((UserAccountControl & USER_MACHINE_ACCOUNT_MASK )==0)
        && (SampDefinedDomains[Context->DomainIndex].UnmodifiedFixed.MinPasswordLength>0)
        && ((UserAccountControl & USER_ACCOUNT_DISABLED)==0)
        && (!Context->TrustedClient) )
    {

        NT_OWF_PASSWORD NtOwfPassword;
        LM_OWF_PASSWORD LmOwfPassword;
        BOOLEAN LmPasswordNonNull, NtPasswordPresent, NtPasswordNonNull;

        NtStatus = SampRetrieveUserPasswords(
                       Context,
                       &LmOwfPassword,
                       &LmPasswordNonNull,
                       &NtOwfPassword,
                       &NtPasswordPresent,
                       &NtPasswordNonNull
                       );

        if ( NT_SUCCESS( NtStatus ) &&
            ( (!LmPasswordNonNull) && (!NtPasswordNonNull) ) ) {
            NtStatus = STATUS_PASSWORD_RESTRICTION;
        }
    }

    //
    // Ensure that only trusted callers can set USER_INTERDOMAIN_TRUST_ACCOUNT. NT5 trust
    // management is always done through trusted domain objects
    //

    if ((NT_SUCCESS(NtStatus))
        && (UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)
        && (!Context->TrustedClient))
    {
        NtStatus = STATUS_ACCESS_DENIED;
    }


    return( NtStatus );
}




NTSTATUS
SampValidatePrivilegedAccountControlFlags(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        UserAccountControl,
    IN SAMP_V1_0A_FIXED_LENGTH_USER * V1aFixed
    )
/*++
Routine Description:

    This routine is called in SampSetUserAccountControl() aimed to resolve
    the following two problems:

    First - "Trusted for delegation" option on machine accounts have security
            impacts. In detail, some NT4 domains grant users the right to
            create machine accounts, thereby listing the end-user as the owner
            on these objects. NT5 (Windows 2000) machine object owners have the
            right by DEFAULT to enable the "trusted for delegation" option.
            This means that when these systems upgrades to NT5 their owners
            (end-users) can enable this option.

            Solution: use a new security privilege to set the trusted for
            delegation account flag. The security privilege plus the access
            control right to modify the account control flag will be required
            to enable the delegation option. Bug ID: 234784

    Second- There is a serious security flaw with delegation in NT5.0.
            Specifically an user who is granted the authority to join a
            workstation, or create a user can manipulate the user account
            control to be a server trust account. This is sufficient to install
            an NT4 BDC. We need to check that the rights required on the Domain
            NC head (account domain) to replicate is required to create
            a server trust account. Bug 238411

Parameters:

    AccountContext - Pointer to an object.

    UserAccountControl - New UserAccountControl

    V1aFixed - Pointer to the old data in object context.


Return Values:

    STATUS_SUCCESS - client passed all check

    STATUS_PRIVILEGE_NOT_HELD - donot have the privilege the enable
                                the trusted for delegation option.

    STATUS_ACCESS_DENIED - can not create a Domain Controller Account.

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    SAMTRACE("SampValidatePrivilegedAccountControlFlags");

    //
    // check whether the client has privilege to set/unset the trusted for
    // delegation on this account or not.
    //

    if (((USER_TRUSTED_FOR_DELEGATION & UserAccountControl) !=
        (USER_TRUSTED_FOR_DELEGATION & V1aFixed->UserAccountControl)
       ) ||
       ((USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION & UserAccountControl) !=
        (USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION & V1aFixed->UserAccountControl)
       ))
    {

        //
        // If trusted_for_delegation is changed, check whether
        // the client holds the privilege.
        //

        NtStatus = SampRtlWellKnownPrivilegeCheck(
                                    TRUE,                               // please impersonate this client
                                    SE_ENABLE_DELEGATION_PRIVILEGE,     // privilege to check
                                    NULL
                                    );
    }

    //
    // check whether the client has the right to create a Domain Controller
    // account.
    //

    //
    // the right required on the domain NC head to replicate is tested
    // at here
    //

    if (NT_SUCCESS(NtStatus) &&
        (!AccountContext->TrustedClient) &&
        (USER_SERVER_TRUST_ACCOUNT & UserAccountControl) &&
        !(USER_SERVER_TRUST_ACCOUNT & V1aFixed->UserAccountControl)
       )
    {
        NtStatus = SampValidateDomainControllerCreation(AccountContext);
    }

    return NtStatus;

}

NTSTATUS
SampEnforceComputerClassForDomainController(
    IN PSAMP_OBJECT AccountContext
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ATTRTYP  ObjectClassTyp[] = {SAMP_FIXED_USER_OBJECTCLASS};
    ATTRVAL  ObjectClassVal[] = {0,NULL};
    ATTRBLOCK ObjectClassResults;
    ULONG     i;
    BOOLEAN   IsComputer = FALSE;
    UNICODE_STRING UserName;
    DEFINE_ATTRBLOCK1(ObjectClassBlock,ObjectClassTyp,ObjectClassVal);

    NtStatus = SampDsRead(
                    AccountContext->ObjectNameInDs,
                    0,
                    SampUserObjectType,
                    &ObjectClassBlock,
                    &ObjectClassResults
                    );

    if (NT_SUCCESS(NtStatus))
    {
        for (i=0;i<ObjectClassResults.pAttr[0].AttrVal.valCount;i++)
        {
            if (CLASS_COMPUTER==
                (*((ULONG *)ObjectClassResults.pAttr[0].AttrVal.pAVal[i].pVal)))
            {
                IsComputer = TRUE;
            }
        }
    }

    if (!IsComputer)
    {
        //
        // Event log the failure
        //

        NtStatus = SampGetUnicodeStringAttribute(
                        AccountContext,
                        SAMP_USER_ACCOUNT_NAME,
                        FALSE,    // Make copy
                        &UserName
                        );

        if (NT_SUCCESS(NtStatus))
        {
                        
            PUNICODE_STRING StringPointers = &UserName;

            SampWriteEventLog(
                    EVENTLOG_ERROR_TYPE,
                    0,
                    SAMMSG_DC_NEEDS_TO_BE_COMPUTER,
                    NULL,
                    1,
                    0,
                    &StringPointers,
                    NULL
                    );
        }

        NtStatus = STATUS_PRENT4_MACHINE_ACCOUNT;

    }

    return(NtStatus);
}



NTSTATUS
SampSetUserAccountControl(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        UserAccountControl,
    IN IN SAMP_V1_0A_FIXED_LENGTH_USER * V1aFixed,
    IN BOOLEAN      ChangePrimaryGroupId,
    OUT BOOLEAN     *AccountUnlocked,
    OUT BOOLEAN     *AccountGettingMorphed,
    OUT BOOLEAN     *KeepOldPrimaryGroupMembership
    )
/*++

  Routine Description

    This routine performs all the steps in changing the user account control.
    It
        1. Checks for valid combination of user account control
        2. Checks if the machine account bits are being changed to user account
           or vice versa
        3. Checks to see if the account lockout flag is being cleared
        4. Changes Primary group id to new defaults if caller indicates so

    Parameters:

        AccountContext --- Open context to the account at hand
        UserAccountControl -- The new user account control
        V1aFixed       --- The V1aFixed that has just been retrieved from the account control
        ChangePrimaryGroupId -- Changes primary group id to new defaults if caller indicates so
        AccountGettingMorphed -- TRUE returned here if machine/user translations are taking place
        KeepOldPrimaryGroupMembership - TRUE returned here if 1) Domain Controller's PrimaryGroupId
                                        is changed and 2) the previous primary group id is not the
                                        default one. In this case, we should add the old primary
                                        group id to its (this account) reverse membership list.

    Return Values:

        STATUS_SUCCESS
        Other Error Codes
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  CurrentlyLocked = FALSE;
    BOOLEAN  Unlocking = FALSE;


    *AccountGettingMorphed = FALSE;
    *AccountUnlocked = FALSE;

    //
    // Password expired bit, is computed, cannot be set 
    // However, applications read and simply or in additional
    // user account control flags. Therefore silently mask out
    // that bit

    UserAccountControl &= ~((ULONG) USER_PASSWORD_EXPIRED );

    NtStatus = SampIsUserAccountControlValid(
                        AccountContext,
                        UserAccountControl
                        );

    //
    // Apply additional checks for untrusted client,
    // only in DS case.
    //

    if (NT_SUCCESS(NtStatus) &&
        !(AccountContext->TrustedClient) &&
        IsDsObject(AccountContext)
       )
    {
        NtStatus = SampValidatePrivilegedAccountControlFlags(
                                        AccountContext,
                                        UserAccountControl,
                                        V1aFixed
                                        );
    }


    //
    // If a domain controller is being created verify that the
    // object class is class computer ( ie going from non server
    // trust account to server trust account
    //

    if ((NT_SUCCESS(NtStatus)) &&
        (IsDsObject(AccountContext)) &&
        (!AccountContext->TrustedClient) &&
        (( UserAccountControl & USER_SERVER_TRUST_ACCOUNT)!=0) &&
        ((V1aFixed->UserAccountControl & USER_SERVER_TRUST_ACCOUNT)==0))
    {
        NtStatus = SampEnforceComputerClassForDomainController(AccountContext);
    }



    if ( NT_SUCCESS( NtStatus ) ) {

        if ( ( V1aFixed->UserAccountControl &
            USER_MACHINE_ACCOUNT_MASK ) !=
            ( UserAccountControl &
            USER_MACHINE_ACCOUNT_MASK ) ) {

           *AccountGettingMorphed = TRUE;

           //
           // Urgently changes from WORKSTATION to SERVER Trust and vis
           // versa
           //
           if (  (V1aFixed->UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT)
              && (UserAccountControl & USER_SERVER_TRUST_ACCOUNT)  )
           {
               AccountContext->ReplicateUrgently = TRUE;
           }
           if (  (V1aFixed->UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
              && (UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT)  )
           {
               AccountContext->ReplicateUrgently = TRUE;
           }
        }

        //
        // Untrusted clients can:
        //
        //   1) leave the the ACCOUNT_AUTO_LOCK flag set.
        //   2) Clear the ACCOUNT_AUTO_LOCK flag.
        //
        // They can't set it.  So, we must AND the user's
        // flag value with the current value and set that
        // in the UserAccountControl field.
        //

        if (!(AccountContext->TrustedClient)) {

            //
            // Minimize the passed in AccountControl
            // with the currently set value.
            //

            UserAccountControl =
                (V1aFixed->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED)?
                UserAccountControl:
                ((~((ULONG) USER_ACCOUNT_AUTO_LOCKED)) & UserAccountControl);

            //
            // If an untrusted client is unlocking the account,
            // then we also need to re-set the BadPasswordCount.
            // Trusted clients are expected to explicitly set
            // the BadPasswordCount.
            //

            CurrentlyLocked = (V1aFixed->UserAccountControl &
                               USER_ACCOUNT_AUTO_LOCKED) != 0;
            Unlocking = (UserAccountControl &
                         USER_ACCOUNT_AUTO_LOCKED) == 0;

            if (CurrentlyLocked && Unlocking) {

                *AccountUnlocked = TRUE;

                SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                               (SAMP_LOG_ACCOUNT_LOCKOUT,
                               "UserId: 0x%x  Manually unlocked\n", V1aFixed->UserId));

                V1aFixed->BadPasswordCount = 0;

                if (IsDsObject(AccountContext))
                {

                    //
                    // Set the lockout time to 0
                    //

                    RtlZeroMemory(&AccountContext->TypeBody.User.LockoutTime,
                                   sizeof(LARGE_INTEGER) );

                    NtStatus = SampDsUpdateLockoutTime(AccountContext);

                }

                //
                // Event Log Account Unlock
                // 
                if ( NT_SUCCESS(NtStatus) && 
                     SampDoAccountAuditing(AccountContext->DomainIndex) )
                {
                    NTSTATUS        TmpNtStatus = STATUS_SUCCESS;
                    UNICODE_STRING  AccountName;
                    PSAMP_DEFINED_DOMAINS   Domain = NULL;

                    TmpNtStatus = SampGetUnicodeStringAttribute(
                                        AccountContext, 
                                        SAMP_USER_ACCOUNT_NAME,
                                        FALSE,      // Don't make copy
                                        &AccountName
                                        );

                    if (NT_SUCCESS(TmpNtStatus))
                    {
                        Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

                        SampAuditAnyEvent(
                            AccountContext,
                            STATUS_SUCCESS,                         
                            SE_AUDITID_ACCOUNT_UNLOCKED,        // Audit ID
                            Domain->Sid,                        // Domain SID
                            NULL,                               // Additional Info
                            NULL,                               // Member Rid (unused)
                            NULL,                               // Member Sid (unused)
                            &AccountName,                       // Account Name
                            &Domain->ExternalName,              // Domain Name
                            &AccountContext->TypeBody.User.Rid, // Account Rid
                            NULL                                // Privilege
                            );

                    } // TmpNtStatus

                } // if DoAudit
            }

        }

        //
        // If the account is getting morphed, and it is DS mode, then check to see if
        // we have to change the primary group of the object.
        //

        if (  (NT_SUCCESS(NtStatus))
           && (*AccountGettingMorphed)
           && (IsDsObject(AccountContext))
           )
        {
            //
            // The algorithm to use is:
            //
            // if the account is morphed and is a Domain Controller right now,
            // then enforce the PrimaryGroupID to be DOMAIN_GROUP_RID_CONTROLLERS
            // no matter what.
            //
            // otherwise if the old Primary Group is the default one then the new
            // primarygroup will be changed to the defaults.
            //

            if (USER_SERVER_TRUST_ACCOUNT & UserAccountControl)
            {
                if (V1aFixed->PrimaryGroupId
                    != SampDefaultPrimaryGroup(AccountContext, V1aFixed->UserAccountControl))
                {
                    *KeepOldPrimaryGroupMembership = TRUE;
                }

                V1aFixed->PrimaryGroupId = SampDefaultPrimaryGroup(
                                                    AccountContext,
                                                    UserAccountControl
                                                    );

                ASSERT(V1aFixed->PrimaryGroupId = DOMAIN_GROUP_RID_CONTROLLERS);
            }
            else if(ChangePrimaryGroupId &&
                    (V1aFixed->PrimaryGroupId == SampDefaultPrimaryGroup(
                                                    AccountContext,
                                                    V1aFixed->UserAccountControl)))
            {
                V1aFixed->PrimaryGroupId = SampDefaultPrimaryGroup(
                                                AccountContext,
                                                UserAccountControl
                                                );
            }

        }

       


    }


    //
    // If the USER_SMARTCARD_REQUIRED flag is being set, then randomize the
    // password
    //

    if ((NT_SUCCESS(NtStatus)) &&
        (( UserAccountControl & USER_SMARTCARD_REQUIRED)!=0) &&
        ((V1aFixed->UserAccountControl & USER_SMARTCARD_REQUIRED)==0))
    {
        LM_OWF_PASSWORD LmOwfPassword;
        NT_OWF_PASSWORD NtOwfPassword;

        if (!CDGenerateRandomBits((PUCHAR) &LmOwfPassword, sizeof(LmOwfPassword)))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }

        if ((NT_SUCCESS(NtStatus))
           && (!CDGenerateRandomBits((PUCHAR) &NtOwfPassword, sizeof(NtOwfPassword))))
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }

        if (NT_SUCCESS(NtStatus))
        {

            NtStatus = SampStoreUserPasswords(
                            AccountContext,
                            &LmOwfPassword,
                            TRUE,
                            &NtOwfPassword,
                            TRUE,
                            FALSE,
                            PasswordSet,
                            NULL,
                            NULL
                            );
        }
    }

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Now set the account control flags
        //

        V1aFixed->UserAccountControl = UserAccountControl;
    }


    return NtStatus;
}



NTSTATUS
SampCalculateLmPassword(
    IN PUNICODE_STRING NtPassword,
    OUT PCHAR *LmPasswordBuffer
    )

/*++

Routine Description:

    This service converts an NT password into a LM password.

Parameters:

    NtPassword - The Nt password to be converted.

    LmPasswordBuffer - On successful return, points at the LM password
                The buffer should be freed using MIDL_user_free

Return Values:

    STATUS_SUCCESS - LMPassword contains the LM version of the password.

    STATUS_NULL_LM_PASSWORD - The password is too complex to be represented
        by a LM password. The LM password returned is a NULL string.


--*/
{

#define LM_BUFFER_LENGTH    (LM20_PWLEN + 1)

    NTSTATUS       NtStatus;
    ANSI_STRING    LmPassword;

    SAMTRACE("SampCalculateLMPassword");

    //
    // Prepare for failure
    //

    *LmPasswordBuffer = NULL;


    //
    // Compute the Ansi version to the Unicode password.
    //
    //  The Ansi version of the Cleartext password is at most 14 bytes long,
    //      exists in a trailing zero filled 15 byte buffer,
    //      is uppercased.
    //

    LmPassword.Buffer = MIDL_user_allocate(LM_BUFFER_LENGTH);
    if (LmPassword.Buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    LmPassword.MaximumLength = LmPassword.Length = LM_BUFFER_LENGTH;
    RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    NtStatus = RtlUpcaseUnicodeStringToOemString( &LmPassword, NtPassword, FALSE );


    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // The password is longer than the max LM password length
        //

        NtStatus = STATUS_NULL_LM_PASSWORD; // Informational return code
        RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

    }




    //
    // Return a pointer to the allocated LM password
    //

    if (NT_SUCCESS(NtStatus)) {

        *LmPasswordBuffer = LmPassword.Buffer;

    } else {

        MIDL_user_free(LmPassword.Buffer);
    }

    return(NtStatus);
}



NTSTATUS
SampCalculateLmAndNtOwfPasswords(
    IN PUNICODE_STRING ClearNtPassword,
    OUT PBOOLEAN LmPasswordPresent,
    OUT PLM_OWF_PASSWORD LmOwfPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )
/*++

Routine Description:

    This routine calculates the LM and NT OWF passwordw from the cleartext
    password.

Arguments:

    ClearNtPassword - A Cleartext unicode password

    LmPasswordPresent - indicates whether an LM OWF password could be
        calculated

    LmOwfPassword - Gets the LM OWF hash of the cleartext password.

    NtOwfPassword - Gets the NT OWF hash of the cleartext password.


Return Value:

--*/
{
    PCHAR LmPassword = NULL;
    NTSTATUS NtStatus;

    SAMTRACE("SampCalculateLmAndNtOwfPassword");

    //
    // First compute the LM password.  If the password is too complex
    // this may not be possible.
    //


    NtStatus = SampCalculateLmPassword(
                ClearNtPassword,
                &LmPassword
                );

    //
    // If it faield because the LM password could not be calculated, that
    // is o.k.
    //

    if (NtStatus != STATUS_SUCCESS) {

        if (NtStatus == STATUS_NULL_LM_PASSWORD) {
            *LmPasswordPresent = FALSE;
            NtStatus = STATUS_SUCCESS;

        }

    } else {

        //
        // Now compute the OWF passwords
        //

        *LmPasswordPresent = TRUE;

        NtStatus = RtlCalculateLmOwfPassword(
                        LmPassword,
                        LmOwfPassword
                        );

    }


    if (NT_SUCCESS(NtStatus)) {

        NtStatus = RtlCalculateNtOwfPassword(
                        ClearNtPassword,
                        NtOwfPassword
                   );
    }

    if (LmPassword != NULL) {
        MIDL_user_free(LmPassword);
    }

    return(NtStatus);

}



NTSTATUS
SampDecryptPasswordWithKey(
    IN PSAMPR_ENCRYPTED_USER_PASSWORD EncryptedPassword,
    IN PBYTE Key,
    IN ULONG KeySize,
    IN BOOLEAN UnicodePasswords,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    struct RC4_KEYSTRUCT Rc4Key;
    NTSTATUS NtStatus;
    OEM_STRING OemPassword;
    PSAMPR_USER_PASSWORD Password = (PSAMPR_USER_PASSWORD) EncryptedPassword;

    SAMTRACE("SampDecryptPasswordWithKey");

    //
    // Decrypt the key.
    //

    rc4_key(
        &Rc4Key,
        KeySize,
        Key
        );

    rc4(&Rc4Key,
        sizeof(SAMPR_ENCRYPTED_USER_PASSWORD),
        (PUCHAR) Password
        );

    //
    // Check that the length is valid.  If it isn't bail here.
    //

    if (Password->Length > SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return(STATUS_WRONG_PASSWORD);
    }


    //
    // Convert the password into a unicode string.
    //

    if (UnicodePasswords) {
        NtStatus = SampInitUnicodeString(
                        ClearNtPassword,
                        (USHORT) (Password->Length + sizeof(WCHAR))
                   );
        if (NT_SUCCESS(NtStatus)) {

            ClearNtPassword->Length = (USHORT) Password->Length;

            RtlCopyMemory(
                ClearNtPassword->Buffer,
                ((PCHAR) Password->Buffer) +
                    (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                    Password->Length,
                Password->Length
                );
            NtStatus = STATUS_SUCCESS;
        }
    } else {

        //
        // The password is in the OEM character set.  Convert it to Unicode
        // and then copy it into the ClearNtPassword structure.
        //

        OemPassword.Buffer = ((PCHAR)Password->Buffer) +
                                (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                                Password->Length;

        OemPassword.Length = (USHORT) Password->Length;


        NtStatus = RtlOemStringToUnicodeString(
                        ClearNtPassword,
                        &OemPassword,
                        TRUE            // allocate destination
                    );
    }

    return(NtStatus);
}


NTSTATUS
SampDecryptPasswordWithSessionKeyNew(
    IN SAMPR_HANDLE UserHandle,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD_NEW EncryptedPassword,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:

    This routine decrypts encrypted password using new algorithm. 
    
    the old encryption method exposes plain text password.
    See WinSE Bug 9254 for more details. 
    
    The fix (this routine) was introduced in Win 2000 SP2, and NT4 SP7.
    

Arguments:

    UserHandle - User Handle

    EncryptedPassword - Encrypted Password

    ClearNtPassword - return clear password

Return Value:

--*/
{
    NTSTATUS            NtStatus;
    USER_SESSION_KEY    UserSessionKey;
    MD5_CTX             Md5Context;
    OEM_STRING          OemPassword;
    struct RC4_KEYSTRUCT Rc4Key;
    PSAMPR_USER_PASSWORD_NEW    UserPassword = (PSAMPR_USER_PASSWORD_NEW) EncryptedPassword;


    SAMTRACE("SampDecryptPasswordWithSessionKeyNew");

    NtStatus = RtlGetUserSessionKeyServer(
                    (RPC_BINDING_HANDLE)UserHandle,
                    &UserSessionKey
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    MD5Init(&Md5Context);

    MD5Update(&Md5Context,
              (PUCHAR) UserPassword->ClearSalt,
              SAM_PASSWORD_ENCRYPTION_SALT_LEN
              );

    MD5Update(&Md5Context,
              (PUCHAR) &UserSessionKey,
              sizeof(UserSessionKey)
              );

    MD5Final(&Md5Context);

    rc4_key(&Rc4Key,
            MD5DIGESTLEN,
            Md5Context.digest
            );


    rc4(&Rc4Key,
        sizeof(SAMPR_ENCRYPTED_USER_PASSWORD_NEW) - SAM_PASSWORD_ENCRYPTION_SALT_LEN,
        (PUCHAR) UserPassword
        );

    //
    // Check that the length is valid.  If it isn't bail here.
    //

    if (UserPassword->Length > SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return(STATUS_WRONG_PASSWORD);
    }

    NtStatus = SampInitUnicodeString(ClearNtPassword,
                                     (USHORT) (UserPassword->Length + sizeof(WCHAR))
                                     );

    if (NT_SUCCESS(NtStatus))
    {
        ClearNtPassword->Length = (USHORT) UserPassword->Length;

        RtlCopyMemory(ClearNtPassword->Buffer,
                      ((PUCHAR) UserPassword) + 
                          (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                          UserPassword->Length,
                      UserPassword->Length
                      );
    }

    return( NtStatus );
}

NTSTATUS
SampDecryptPasswordWithSessionKeyOld(
    IN SAMPR_HANDLE UserHandle,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD EncryptedPassword,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{

    NTSTATUS NtStatus;
    USER_SESSION_KEY UserSessionKey;

    SAMTRACE("SampDecryptPasswordWithSessionKeyOld");

    NtStatus = RtlGetUserSessionKeyServer(
                    (RPC_BINDING_HANDLE)UserHandle,
                    &UserSessionKey
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    return(SampDecryptPasswordWithKey(
                EncryptedPassword,
                (PUCHAR) &UserSessionKey,
                sizeof(USER_SESSION_KEY),
                TRUE,
                ClearNtPassword
                ) );

}


NTSTATUS
SampDecryptPasswordWithSessionKey(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PSAMPR_USER_INFO_BUFFER Buffer,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    NTSTATUS NtStatus;
    USER_SESSION_KEY UserSessionKey;

    SAMTRACE("SampDecryptPasswordWithSessionKey");


    switch( UserInformationClass )
    {
    case UserInternal4InformationNew:

        NtStatus = SampDecryptPasswordWithSessionKeyNew(
                        UserHandle,
                        &Buffer->Internal4New.UserPassword,
                        ClearNtPassword
                        );
        break;

    case UserInternal5InformationNew:

        NtStatus = SampDecryptPasswordWithSessionKeyNew(
                        UserHandle,
                        &Buffer->Internal5New.UserPassword,
                        ClearNtPassword
                        );

        break;

    case UserInternal4Information:

        NtStatus = SampDecryptPasswordWithSessionKeyOld(
                        UserHandle, 
                        &Buffer->Internal4.UserPassword,
                        ClearNtPassword
                        );

        break;

    case UserInternal5Information:

        NtStatus = SampDecryptPasswordWithSessionKeyOld(
                        UserHandle,
                        &Buffer->Internal5.UserPassword,
                        ClearNtPassword
                        );

        break;

    default:

        NtStatus = STATUS_INTERNAL_ERROR;
        break;
    }

    return( NtStatus );
}




NTSTATUS
SampCheckPasswordRestrictions(
    IN SAMPR_HANDLE UserHandle,
    PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
    PUNICODE_STRING NewNtPassword,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL
    )

/*++

Routine Description:

    This service is called to make sure that the password presented meets
    our quality requirements.


Arguments:

    UserHandle - Handle to a user.

    DomainPasswordInfo -- Indicates the password policy to enforce

    NewNtPassword - Pointer to the UNICODE_STRING containing the new
        password.

    PasswordChangeFailureInfo -- Indicates error information regarding 
                                 the password change operation


Return Value:

    STATUS_SUCCESS - The password is acceptable.

    STATUS_PASSWORD_RESTRICTION - The password is too short, or is not
        complex enough, etc.

    STATUS_INVALID_RESOURCES - There was not enough memory to do the
        password checking.

    STATUS_NO_MEMORY - Return by SampGetUnicodeStringAttribute, or
        by SampCheckStrongPasswordRestrictions. no enough memory.


--*/
{
    USER_DOMAIN_PASSWORD_INFORMATION  PasswordInformation = {0, 0};
    NTSTATUS                          NtStatus;
    PWORD                             CharInfoBuffer = NULL;
    ULONG                             i;
    PSAMP_DEFINED_DOMAINS             Domain;
    SAMP_V1_0A_FIXED_LENGTH_USER      V1aFixed;
    PSAMP_OBJECT                      AccountContext = (PSAMP_OBJECT) UserHandle;


    SAMTRACE("SampCheckPasswordRestrictions");


    //
    // Query information domain to get password length and
    // complexity requirements.
    //


    //
    // When the user was opened, we checked to see if the domain handle
    // allowed access to the domain password information.  Check that here.
    //

    if ( !( AccountContext->TypeBody.User.DomainPasswordInformationAccessible ) ) {

        NtStatus = STATUS_ACCESS_DENIED;

    } else {

        //
        // If the user account is a machine account or
        // service accounts such as the krbtgt account,
        // then restrictions are generally not enforced.
        // This is so that simple initial passwords can be
        // established.  IT IS EXPECTED THAT COMPLEX PASSWORDS,
        // WHICH MEET THE MOST STRINGENT RESTRICTIONS, WILL BE
        // AUTOMATICALLY ESTABLISHED AND MAINTAINED ONCE THE MACHINE
        // JOINS THE DOMAIN.  It is the UI's responsibility to
        // maintain this level of complexity.
        //


        NtStatus = SampRetrieveUserV1aFixed(
                       AccountContext,
                       &V1aFixed
                       );

        if (NT_SUCCESS(NtStatus)) {
            if (((V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)!= 0 )
                ||(DOMAIN_USER_RID_KRBTGT==V1aFixed.UserId)){

                PasswordInformation.MinPasswordLength = 0;
                PasswordInformation.PasswordProperties = 0;
            } else {

                PasswordInformation.MinPasswordLength = DomainPasswordInfo->MinPasswordLength;
                PasswordInformation.PasswordProperties = DomainPasswordInfo->PasswordProperties;
            }
        }
    }

    //
    // For Machine accounts if the special Domain flag for refuse password change is set,
    // then disallow any account creation except the default
    //

    if ((NT_SUCCESS(NtStatus)) && (
            (V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
            || (V1aFixed.UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT)))
    {
        NtStatus = SampEnforceDefaultMachinePassword(
                        AccountContext,
                        NewNtPassword,
                        DomainPasswordInfo
                        );

        //
        // If this failed with password restriction it means that refuse password change
        // is set for machine acounts
        //

        if ((STATUS_PASSWORD_RESTRICTION==NtStatus) 
                && (ARGUMENT_PRESENT(PasswordChangeFailureInfo)))
        {
            PasswordChangeFailureInfo->ExtendedFailureReason = 
                    SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT;
        }

    }


    if ( NT_SUCCESS( NtStatus ) ) {

        if ( (USHORT)( NewNtPassword->Length / sizeof(WCHAR) ) < PasswordInformation.MinPasswordLength ) {

            NtStatus = STATUS_PASSWORD_RESTRICTION;
            if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
            {
                PasswordChangeFailureInfo->ExtendedFailureReason 
                    = SAM_PWD_CHANGE_PASSWORD_TOO_SHORT;
            }

        } else if ( (USHORT) ( NewNtPassword->Length / sizeof(WCHAR) ) > PWLEN) {

            //
            // The password should be less than PWLEN -- 256
            // 

            NtStatus = STATUS_PASSWORD_RESTRICTION;
            if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
            {
                PasswordChangeFailureInfo->ExtendedFailureReason 
                    = SAM_PWD_CHANGE_PASSWORD_TOO_LONG;
            }

        } else {

            //
            // Check strong password complexity.
            //

            if ( PasswordInformation.PasswordProperties & DOMAIN_PASSWORD_COMPLEX ) {

                // Make sure that the password meets our requirements for
                // complexity.  If it's got an odd byte count, it's
                // obviously not a hand-entered UNICODE string so we'll
                // consider it complex by default.
                //

                if ( !( NewNtPassword->Length & 1 ) ) {

                    UNICODE_STRING  AccountName;
                    UNICODE_STRING  FullName;

                    RtlInitUnicodeString(&AccountName, NULL);

                    RtlInitUnicodeString(&FullName, NULL);

                    NtStatus = SampGetUnicodeStringAttribute(
                                        AccountContext,
                                        SAMP_USER_ACCOUNT_NAME,
                                        TRUE,    // Make copy
                                        &AccountName
                                        );

                    if ( NT_SUCCESS(NtStatus) ) {

                        NtStatus = SampGetUnicodeStringAttribute(
                                            AccountContext,
                                            SAMP_USER_FULL_NAME,
                                            TRUE, // Make copy
                                            &FullName
                                            );

                        if ( NT_SUCCESS(NtStatus) ) {

                            NtStatus = SampCheckStrongPasswordRestrictions(
                                                    &AccountName,
                                                    &FullName,
                                                    NewNtPassword,
                                                    PasswordChangeFailureInfo
                                                    );

                        }
                    }

                    if ( AccountName.Buffer != NULL ) {
                        MIDL_user_free ( AccountName.Buffer );
                        AccountName.Buffer = NULL;
                    }

                    if ( FullName.Buffer != NULL ) {
                        MIDL_user_free ( FullName.Buffer );
                        FullName.Buffer = NULL;
                    }
                }
            }
        }
    }

    return( NtStatus );
}

////////////////////////////////////////////////////////////////////////

NTSTATUS
SampCheckStrongPasswordRestrictions(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING FullName,
    PUNICODE_STRING Password,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL
    )

/*++

Routine Description:

    This routine is notified of a password change. It will check the
    password's complexity. The new Strong Password must meet the
    following criteria:
    1. Password must contain characters from at least 3 of the
       following 5 classes:

       Description                             Examples:
       1       English Upper Case Letters      A, B, C,   Z
       2       English Lower Case Letters      a, b, c,  z
       3       Westernized Arabic Numerals     0, 1, 2,  9
       4       Non-alphanumeric             ("Special characters")
                                            (`~!@#$%^&*_-+=|\\{}[]:;\"'<>,.?)
       5       Any linguistic character: alphabetic, syllabary, or ideographic 
               (localization issue)

    2. Password can not contain your account name or any part of
       user's full name.


    Note: This routine does NOT check password's length, since password
          length restriction has already been enforced by NT4 SAM if you
          set it correctly.

Arguments:

    AccountName - Name of user whose password changed

    FullName - Full name of the user whose password changed

    Password - Cleartext new password for the user

Return Value:

    STATUS_SUCCESS if the specified Password is suitable (complex, long, etc).
        The system will continue to evaluate the password update request
        through any other installed password change packages.

    STATUS_PASSWORD_RESTRICTION
        if the specified Password is unsuitable. The password change
         on the specified account will fail.

    STATUS_NO_MEMORY

--*/
{

                    // assume the password in not complex enough
    NTSTATUS NtStatus = STATUS_PASSWORD_RESTRICTION;
    USHORT     cchPassword = 0;
    USHORT     i = 0;
    USHORT     NumInPassword = 0;
    USHORT     UpperInPassword = 0;
    USHORT     LowerInPassword = 0;
    USHORT     AlphaInPassword = 0;
    USHORT     SpecialCharInPassword = 0;
    PWSTR     token = NULL;
    PWSTR     _password = NULL;
    PWSTR    _accountname = NULL;
    PWSTR    _fullname = NULL;
    PWSTR    TempString = NULL;
    PWORD    CharType = NULL;


    SAMTRACE("SampCheckStrongPasswordRestrictions");


    // check if the password contains at least 3 of 4 classes.


    CharType = MIDL_user_allocate( Password->Length );

    if ( CharType == NULL ) {

        NtStatus = STATUS_NO_MEMORY;
        goto SampCheckStrongPasswordFinish;
    }

    cchPassword = Password->Length / sizeof(WCHAR);
    if(GetStringTypeW(
           CT_CTYPE1,
           Password->Buffer,
           cchPassword,
           CharType)) {

        for(i = 0 ; i < cchPassword ; i++) {

            //
            // keep track of what type of characters we have encountered
            //

            if(CharType[i] & C1_DIGIT) {
                NumInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_UPPER) {
                UpperInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_LOWER) {
                LowerInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_ALPHA) {
                AlphaInPassword = 1;
                continue;
            }

        } // end of track character type.

        _password = MIDL_user_allocate(Password->Length + sizeof(WCHAR));

        if ( _password == NULL ) {

            NtStatus = STATUS_NO_MEMORY;
            goto SampCheckStrongPasswordFinish;
        }
        else {

            RtlZeroMemory( _password, Password->Length + sizeof(WCHAR));
        }

        wcsncpy(_password,
                Password->Buffer,
                Password->Length/sizeof(WCHAR)
                );

        if (wcspbrk (_password, L"(`~!@#$%^&*_-+=|\\{}[]:;\"'<>,.?)/") != NULL) {

                SpecialCharInPassword = 1 ;
        }

        //
        // Indicate whether we encountered enough password complexity
        //

        if( (NumInPassword + LowerInPassword + UpperInPassword + AlphaInPassword +
                SpecialCharInPassword) < 3) {

            NtStatus = STATUS_PASSWORD_RESTRICTION;
            if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
            {
                PasswordChangeFailureInfo->ExtendedFailureReason = SAM_PWD_CHANGE_NOT_COMPLEX;
            }
            goto SampCheckStrongPasswordFinish;

        } else {

            //
            // now we resort to more complex checking
            //
            _accountname = MIDL_user_allocate(AccountName->Length + sizeof(WCHAR));

            if ( _accountname == NULL ) {

                NtStatus = STATUS_NO_MEMORY;
                goto SampCheckStrongPasswordFinish;
            }
            else {

                RtlZeroMemory( _accountname, AccountName->Length + sizeof(WCHAR));
            }

            wcsncpy(_accountname,
                    AccountName->Buffer,
                    AccountName->Length/sizeof(WCHAR)
                    );

            _fullname = MIDL_user_allocate(FullName->Length + sizeof(WCHAR));

            if ( _fullname == NULL ) {

                NtStatus = STATUS_NO_MEMORY;
                goto SampCheckStrongPasswordFinish;
            }
            else {

                RtlZeroMemory( _fullname, FullName->Length + sizeof(WCHAR));
            }

            wcsncpy(_fullname,
                    FullName->Buffer,
                    FullName->Length/sizeof(WCHAR)
                    );

            _wcsupr(_password);
            _wcsupr(_accountname);
            _wcsupr(_fullname);

            if ( (AccountName->Length >= 3 * sizeof(WCHAR)) &&
                    wcsstr(_password, _accountname) ) {

                    NtStatus = STATUS_PASSWORD_RESTRICTION;
                    if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
                    {
                        PasswordChangeFailureInfo->ExtendedFailureReason
                            = SAM_PWD_CHANGE_USERNAME_IN_PASSWORD;
                    }
                    goto SampCheckStrongPasswordFinish;

            }

            token = SampLocalStringToken(_fullname, L" ,.\t-_#",&TempString);

            while ( token != NULL ) {

                if ( wcslen(token) >= 3 && wcsstr(_password, token) ) {

                    NtStatus = STATUS_PASSWORD_RESTRICTION;
                    if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
                    {
                        PasswordChangeFailureInfo->ExtendedFailureReason
                            = SAM_PWD_CHANGE_FULLNAME_IN_PASSWORD;
                    }
                    goto SampCheckStrongPasswordFinish;

                }

                token = SampLocalStringToken(NULL, L" ,.\t-_#",&TempString);
            }


            NtStatus = STATUS_SUCCESS ;

        }

    } // if GetStringTypeW failed, NtStatus will by default equal to
      // STATUS_PASSWORD_RESTRICTION


SampCheckStrongPasswordFinish:

    if ( CharType != NULL ) {
        RtlZeroMemory( CharType, Password->Length );
        MIDL_user_free( CharType );
    }

    if ( _password != NULL ) {
        RtlZeroMemory( _password, Password->Length + sizeof(WCHAR) );
        MIDL_user_free( _password );
    }

    if ( _accountname != NULL ) {
        RtlZeroMemory( _accountname, AccountName->Length + sizeof(WCHAR) );
        MIDL_user_free( _accountname );
    }

    if ( _fullname != NULL ) {
        RtlZeroMemory( _fullname, FullName->Length + sizeof(WCHAR) );
        MIDL_user_free( _fullname );
    }

    return ( NtStatus );
}

/////////////////////////////////////////////////////////////////////

PWSTR
SampLocalStringToken(
    PWSTR    String,
    PWSTR    Token,
    PWSTR    * NextStringStart
    )
/*++

Routine Description:

    This routine will find next token in the first parameter "String".

Arguments:

    String - Pointer to a string, which contains (a) token(s).

    Token  - Delimiter Set. They could be " ,.\t-_#"

    NextStringStart - Used to keep the start point to search next token.

Return Value:

    A pointer to the token.

--*/

{
    USHORT    Index;
    USHORT    Tokens;
    PWSTR    StartString;
    PWSTR    EndString;
    BOOLEAN    Found;

    //
    // let StartString points to the start point of the string.
    //

    if (String != NULL) {

        StartString = String;
    }
    else {

        if (*NextStringStart == NULL) {
            return(NULL);
        }
        else {
            StartString = *NextStringStart;
        }
    }

    Tokens = (USHORT)wcslen(Token);

    //
    // Find the beginning of the string. pass all beginning delimiters.
    //

    while (*StartString != L'\0') {

        Found = FALSE;
        for (Index = 0; Index < Tokens; Index ++) {

            if (*StartString == Token[Index]) {

                StartString ++;
                Found = TRUE;
                break;
            }
        }
        if ( !Found ) {

            break;
        }
    }


    //
    // If there are no more tokens in this string
    //

    if (*StartString == L'\0') {

        *NextStringStart = NULL;
        return ( NULL );
    }

    EndString = StartString + 1;

    while ( *EndString != L'\0' ) {

        for (Index = 0; Index < Tokens; Index ++) {

            if (*EndString == Token[Index]) {

                *EndString = L'\0';
                *NextStringStart = EndString + 1;
                return ( StartString );
            }
        }
        EndString ++;
    }

    *NextStringStart = NULL;

    return ( StartString );

}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

LARGE_INTEGER
SampCalcEndOfLastLogonTimeStamp(
    LARGE_INTEGER   LastLogonTimeStamp,
    ULONG           SyncInterval
    )
/*++
Routine Description:

    This routine calculates the last logon time stamp update schedule

Parameters:

    LastLogonTimeStamp - last logon time

    SyncInterval - discrepency in days between the replicated 
                   LastLogonTimeStamp attribute and non-replicated lastLognTime
                   attribute

Return Value:

    when should SAM update last logon time stamp

--*/
{
    LARGE_INTEGER       UpdateInterval;     
    USHORT              RandomValue = 0x7FFF;

    //
    // if update interval is 0, this attribute is disabled.
    // no update will be scheduled. 
    //

    if (0 == SyncInterval)
    {
        return(SampWillNeverTime);
    }


    //
    // calculate update interval (by 100 nanosecond)
    // 
    // 
    // SyncInterval contains the interval by days.
    // so need to convert days to filetime, which is number of 100-nanosecond 
    // since 01/01/1601.  time (-1) to make it a delta time.
    // Be careful about Large integer multiply, put a limit of any variable to 
    // make sure no overflow.
    // SyncInterval is in range of 1 ~ 100,000. RandomValue is 0 ~ 7FFFF
    // 
   
    if (SyncInterval > SAMP_LASTLOGON_TIMESTAMP_SYNC_SWING_WINDOW)
    {
        //
        // generate a random number. To simplifiy calculation, always use positive.
        // if failed, pick up the max (signed)
        // 

        if (!RtlGenRandom(&RandomValue, sizeof(USHORT)))
        {
            RandomValue = 0x7FFF;
        }
        RandomValue &= 0x7FFF;

        UpdateInterval.QuadPart = SyncInterval - ((SAMP_LASTLOGON_TIMESTAMP_SYNC_SWING_WINDOW * RandomValue) / 0x7FFF);
    }
    else
    {
        UpdateInterval.QuadPart = SyncInterval;
    }
    
    UpdateInterval.QuadPart *= 24 * 60 * 60;
    UpdateInterval.QuadPart *= 1000 * 10000;
    UpdateInterval.QuadPart *= -1;

//
// checked build only. If CurrentControlSet\Control\Lsa\UpdateLastLogonTSByMinute
// is set, the value of LastLogonTimeStampSyncInterval will be a "unit" by minute
// instead of "days", which helps to test this feature.   So checked build only.
// 

#if DBG
    if (SampLastLogonTimeStampSyncByMinute)
    {
        UpdateInterval.QuadPart /= (24 * 60);
    }
#endif

    return(SampAddDeltaTime(LastLogonTimeStamp, UpdateInterval));
}


NTSTATUS
SampDsSuccessfulLogonSet(
   IN PSAMP_OBJECT AccountContext,
   IN ULONG        Flags,
   IN ULONG        LastLogonTimeStampSyncInterval,
   IN SAMP_V1_0A_FIXED_LENGTH_USER * V1aFixed
   )
/*++

    Routine Description

        This routine, sets just the attributes corresponding to logon statistics,
        as opposed to writing out the user fixed attributes, which results in a
        large number of attributes being written out during every logon. This is called
        on successful logons.

    Parameters

        AccountContext -- Sam context for the user account.
        Flags          -- the client flags indicating the nature of the logon
        LastLogonTimeStampSyncInterval -- Update Interval for LastLogonTimeStamp attr
        V1aFixed       -- Pointer to a structure containing the modified properties

    Return Values

        STATUS_SUCCESS
        Other Error codes from the flushing
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LARGE_INTEGER LastLogon = V1aFixed->LastLogon;
    LARGE_INTEGER LastLogoff = V1aFixed->LastLogoff;
    LARGE_INTEGER NewLastLogonTimeStamp = V1aFixed->LastLogon;
    LARGE_INTEGER EndOfLastLogonTimeStamp;
    ULONG         BadPasswordCount = (ULONG) V1aFixed->BadPasswordCount;
    SAMP_V1_0A_FIXED_LENGTH_USER OldV1aFixed;
    ULONG         LogonCount = (ULONG) V1aFixed->LogonCount;
    SAMP_SITE_AFFINITY  OldSA = AccountContext->TypeBody.User.SiteAffinity;
    SAMP_SITE_AFFINITY  NewSA;
    BOOLEAN fDeleteOld = FALSE;

#define MAX_SUCCESS_LOGON_ATTS  6

    ATTR          Attrs[MAX_SUCCESS_LOGON_ATTS];
    ULONG         Operations[MAX_SUCCESS_LOGON_ATTS];

    ATTRVAL LastLogonAttrVal = {sizeof(LastLogon),(UCHAR *)&LastLogon};
    ATTRVAL LogonCountAttrVal = {sizeof(LogonCount),(UCHAR *)&LogonCount};
    ATTRVAL BadPasswordAttrVal = {sizeof(BadPasswordCount),(UCHAR *)&BadPasswordCount};
    ATTRVAL OldSAAttrVal = {sizeof(OldSA),(UCHAR *)&OldSA};
    ATTRVAL NewSAAttrVal = {sizeof(NewSA),(UCHAR *)&NewSA};
    ATTRVAL LastLogonTimeStampAttrVal = {sizeof(NewLastLogonTimeStamp), (UCHAR *)&NewLastLogonTimeStamp};

    ATTRBLOCK LogonStatAttrblock;
    ULONG attrCount = 0;

    RtlZeroMemory(&LogonStatAttrblock, sizeof(LogonStatAttrblock));
    LogonStatAttrblock.pAttr = Attrs;
    LogonStatAttrblock.attrCount = 0;

    if ((Flags & USER_LOGON_NO_WRITE) == 0) {

        // Always update the last logon
        Attrs[attrCount].attrTyp = SAMP_FIXED_USER_LAST_LOGON;
        Attrs[attrCount].AttrVal.valCount = 1;
        Attrs[attrCount].AttrVal.pAVal = &LastLogonAttrVal;
        Operations[attrCount] = REPLACE_ATT;
        attrCount++;
    
        // update the last logon time stamp based upon whether the 
        // TimeStamp is too old or not.
    
        EndOfLastLogonTimeStamp = SampCalcEndOfLastLogonTimeStamp(
                                        AccountContext->TypeBody.User.LastLogonTimeStamp,
                                        LastLogonTimeStampSyncInterval
                                        );
    
        if ((NewLastLogonTimeStamp.QuadPart > EndOfLastLogonTimeStamp.QuadPart) &&
           (SampDefinedDomains[AccountContext->DomainIndex].BehaviorVersion 
                    >= DS_BEHAVIOR_WHISTLER ))
        {
            Attrs[attrCount].attrTyp = SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP;
            Attrs[attrCount].AttrVal.valCount = 1;
            Attrs[attrCount].AttrVal.pAVal = &LastLogonTimeStampAttrVal;
            Operations[attrCount] = REPLACE_ATT;
            attrCount++;
    
            // update the in memory copy
            AccountContext->TypeBody.User.LastLogonTimeStamp = NewLastLogonTimeStamp;
        }
    
        // Always update the logon count
        Attrs[attrCount].attrTyp = SAMP_FIXED_USER_LOGON_COUNT;
        Attrs[attrCount].AttrVal.valCount = 1;
        Attrs[attrCount].AttrVal.pAVal = &LogonCountAttrVal;
        Operations[attrCount] = REPLACE_ATT;
        attrCount++;
    
        //
        // If the bad password count was already a 0 then no need to update it
        // once again
        //
        NtStatus = SampRetrieveUserV1aFixed(
                        AccountContext,
                        &OldV1aFixed
                        );
    
        if (!NT_SUCCESS(NtStatus) ||
                (OldV1aFixed.BadPasswordCount!=BadPasswordCount))
        {
            Attrs[attrCount].attrTyp = SAMP_FIXED_USER_BAD_PWD_COUNT;
            Attrs[attrCount].AttrVal.valCount = 1;
            Attrs[attrCount].AttrVal.pAVal = &BadPasswordAttrVal;
            Operations[attrCount] = REPLACE_ATT;
            attrCount++;
        }
    }

    //
    // Determine if the site affinity needs updating
    //
    if (SampCheckForSiteAffinityUpdate(AccountContext,
                                      Flags,
                                      &OldSA, 
                                      &NewSA, 
                                      &fDeleteOld)) {


        NTSTATUS Status2;

        //
        // N.B. In this case the site affinity on the AccountContext is
        // cached, so refresh the site affinity and reevaluate
        //
        Status2 = SampRefreshSiteAffinity(AccountContext);
        if (NT_SUCCESS(Status2)) {

            OldSA = AccountContext->TypeBody.User.SiteAffinity;
            if (SampCheckForSiteAffinityUpdate(AccountContext,
                                              Flags, 
                                              &OldSA, 
                                              &NewSA, 
                                              &fDeleteOld)) {

            if (fDeleteOld) {
                Attrs[attrCount].attrTyp = SAMP_FIXED_USER_SITE_AFFINITY;
                Attrs[attrCount].AttrVal.valCount = 1;
                Attrs[attrCount].AttrVal.pAVal = &OldSAAttrVal;
                Operations[attrCount] = REMOVE_VALUE;
                attrCount++;
            }
    
            Attrs[attrCount].attrTyp = SAMP_FIXED_USER_SITE_AFFINITY;
            Attrs[attrCount].AttrVal.valCount = 1;
            Attrs[attrCount].AttrVal.pAVal = &NewSAAttrVal;
            Operations[attrCount] = ADD_VALUE;
            attrCount++;
            }
        }
    }
    LogonStatAttrblock.attrCount = attrCount;


    //
    // Make the Ds call to directly set the attribute. Take into account,
    // lazy commit settings in the context. If the previous call to
    // Retrieve V1a Fixed failed, then still go an try to update the
    // logon statics anyway. The useful performance optimizations of reducing
    // updates to Bad password count does not come into play though
    //

    if (attrCount > 0) {

        NtStatus = SampDsSetAttributesEx(
                        AccountContext->ObjectNameInDs,
                        AccountContext->LazyCommit?SAM_LAZY_COMMIT:0,
                        Operations,
                        SampUserObjectType,
                        &LogonStatAttrblock
                        );
    }

    return NtStatus;
}

NTSTATUS
SampDsFailedLogonSet(
   IN PSAMP_OBJECT AccountContext,
   IN ULONG        Flags,
   IN SAMP_V1_0A_FIXED_LENGTH_USER * V1aFixed
   )
/*++

    Routine Description

        This routine, sets just the attributes corresponding to logon statistics,
        as opposed to writing out the user fixed attributes, which results in a
        large number of attributes being written out during every logon. This is
        called on failed logons.

    Parameters

        AccountContext -- Sam context for the user account.
        
        Flags -- the client flags indicating the nature of the failed logon
        
        V1aFixed       -- Pointer to a structure containing the modified properties

    Return Values

        STATUS_SUCCESS
        Other Error codes from the flushing
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (Flags & USER_LOGON_NO_LOGON_SERVERS) {

        //
        // Simply check if the site affinity needs updating
        //
        SAMP_SITE_AFFINITY  OldSA = AccountContext->TypeBody.User.SiteAffinity;
        SAMP_SITE_AFFINITY  NewSA;
        BOOLEAN fDeleteOld;
        ATTR Attrs[2];
        ULONG Operations[2];
        ATTRVAL OldSAAttrVal = {sizeof(OldSA),(UCHAR *)&OldSA};
        ATTRVAL NewSAAttrVal = {sizeof(NewSA),(UCHAR *)&NewSA};
        ATTRBLOCK AttrBlock;
        ULONG attrCount = 0;

        RtlZeroMemory(&AttrBlock, sizeof(AttrBlock));

        if (SampCheckForSiteAffinityUpdate(AccountContext,
                                           Flags,  
                                          &OldSA, 
                                          &NewSA, 
                                          &fDeleteOld)) {

            NTSTATUS Status2;
    
            //
            // N.B. In this case the site affinity on the AccountContext is
            // cached, so refresh the site affinity and reevaluate
            //
            Status2 = SampRefreshSiteAffinity(AccountContext);
            if (NT_SUCCESS(Status2)) {
    
                OldSA = AccountContext->TypeBody.User.SiteAffinity;
                if (SampCheckForSiteAffinityUpdate(AccountContext,
                                                   Flags, 
                                                  &OldSA, 
                                                  &NewSA, 
                                                  &fDeleteOld)) {
    
                    if (fDeleteOld) {
                        Attrs[attrCount].attrTyp = SAMP_FIXED_USER_SITE_AFFINITY;
                        Attrs[attrCount].AttrVal.valCount = 1;
                        Attrs[attrCount].AttrVal.pAVal = &OldSAAttrVal;
                        Operations[attrCount] = REMOVE_VALUE;
                        attrCount++;
                    }
            
                    Attrs[attrCount].attrTyp = SAMP_FIXED_USER_SITE_AFFINITY;
                    Attrs[attrCount].AttrVal.valCount = 1;
                    Attrs[attrCount].AttrVal.pAVal = &NewSAAttrVal;
                    Operations[attrCount] = ADD_VALUE;
                    attrCount++;
        
                    AttrBlock.pAttr = Attrs;
                    AttrBlock.attrCount = attrCount;
        
                    NtStatus = SampDsSetAttributesEx(
                                    AccountContext->ObjectNameInDs,
                                    AccountContext->LazyCommit?SAM_LAZY_COMMIT:0,
                                    Operations,
                                    SampUserObjectType,
                                    &AttrBlock
                                    );
                }
            }
        }

    } else {

        LARGE_INTEGER LastBadPasswordTime = V1aFixed->LastBadPasswordTime;
        ULONG         BadPasswordCount = (ULONG) V1aFixed->BadPasswordCount;
    
        ATTRTYP       LogonStatAttrs[]={
                                            SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME,
                                            SAMP_FIXED_USER_BAD_PWD_COUNT
                                       };
        ATTRVAL       LogonStatValues[]={
                                            {sizeof(LastBadPasswordTime),(UCHAR *) &LastBadPasswordTime},
                                            {sizeof(BadPasswordCount),(UCHAR *) &BadPasswordCount}
                                        };
    
        DEFINE_ATTRBLOCK2(LogonStatAttrblock,LogonStatAttrs,LogonStatValues);

        
        //
        // On failure, we always would want to update the user object
        //
        ASSERT( (Flags & USER_LOGON_NO_WRITE) == 0 );

        //
        // Make the Ds call to directly set the attribute. Take into account,
        // lazy commit settings in the context. If the previous call to
        // Retrieve V1a Fixed failed, then still go an try to update the
        // logon statics anyway. The useful performance optimizations of reducing
        // updates to Bad password count does not come into play though
        //
        NtStatus = SampDsSetAttributes(
                        AccountContext->ObjectNameInDs,
                        0, // No lazy commit for failed logons.
                        REPLACE_ATT,
                        SampUserObjectType,
                        &LogonStatAttrblock
                        );
    }



    return NtStatus;
}



NTSTATUS
SamrSetInformationUser2(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PSAMPR_USER_INFO_BUFFER Buffer
    )
{
    //
    // This is a thin veil to SamrSetInformationUser().
    // This is needed so that new-release systems can call
    // this routine without the danger of passing an info
    // level that release 1.0 systems didn't understand.
    //


    return( SamrSetInformationUser(
                UserHandle,
                UserInformationClass,
                Buffer
                ) );
}

NTSTATUS
SamrSetInformationUser(
    IN SAMPR_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PSAMPR_USER_INFO_BUFFER Buffer
    )


/*++

Routine Description:


    This API modifies information in a user record.  The data modified
    is determined by the UserInformationClass parameter.
    In general, a user may call GetInformation with class
    UserLogonInformation, but may only call SetInformation with class
    UserPreferencesInformation.  Access type USER_WRITE_ACCOUNT allows
    changes to be made to all fields.

    NOTE: If the password is set to a new password then the password-
    set timestamp is reset as well.



Parameters:

    UserHandle - The handle of an opened user to operate on.

    UserInformationClass - Class of information provided.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -----------------------         ------------------------
        UserGeneralInformation          USER_WRITE_ACCOUNT and
                                        USER_WRITE_PREFERENCES

        UserPreferencesInformation      USER_WRITE_PREFERENCES

        UserParametersInformation       USER_WRITE_ACCOUNT

        UserLogonInformation            (Can't set)

        UserLogonHoursInformation       USER_WRITE_ACCOUNT

        UserAccountInformation          (Can't set)

        UserNameInformation             USER_WRITE_ACCOUNT
        UserAccountNameInformation      USER_WRITE_ACCOUNT
        UserFullNameInformation         USER_WRITE_ACCOUNT
        UserPrimaryGroupInformation     USER_WRITE_ACCOUNT
        UserHomeInformation             USER_WRITE_ACCOUNT
        UserScriptInformation           USER_WRITE_ACCOUNT
        UserProfileInformation          USER_WRITE_ACCOUNT
        UserAdminCommentInformation     USER_WRITE_ACCOUNT
        UserWorkStationsInformation     USER_WRITE_ACCOUNT
        UserSetPasswordInformation      USER_FORCE_PASSWORD_CHANGE
        UserControlInformation          USER_WRITE_ACCOUNT
        UserExpiresInformation          USER_WRITE_ACCOUNT

        UserInternal1Information        USER_FORCE_PASSWORD_CHANGE
        UserInternal2Information        (Trusted client only)
        UserInternal3Information        (Trusted client only) -
        UserInternal4Information        Similar to All Information
        UserInternal5Information        Similar to SetPassword
        UserAllInformation              Will set fields that are
                                        requested by caller.  Access
                                        to fields to be set must be
                                        held as defined above.


    Buffer - Buffer containing a user info struct.



Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/

{
    NTSTATUS                NtStatus = STATUS_SUCCESS,
                            IgnoreStatus;

    PSAMP_OBJECT            AccountContext = (PSAMP_OBJECT) UserHandle;

    PUSER_ALL_INFORMATION   All = NULL;

    SAMP_OBJECT_TYPE        FoundType;

    PSAMP_DEFINED_DOMAINS   Domain;

    ACCESS_MASK             DesiredAccess;

    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;

    UNICODE_STRING          OldAccountName,
                            ApiList,
                            NewAdminComment,
                            NewAccountName,
                            NewFullName,
                            *NewAccountNameToRemove = NULL;

    NT_OWF_PASSWORD         NtOwfPassword;

    LM_OWF_PASSWORD         LmOwfPassword;

    USER_SESSION_KEY        UserSessionKey;

    BOOLEAN                 LmPresent;
    BOOLEAN                 NtPresent;
    BOOLEAN                 PasswordExpired = FALSE;

    ULONG                   ObjectRid,
                            OldUserAccountControl = 0,
                            OldPrimaryGroupId = 0,
                            DomainIndex,
                            LocalLastLogonTimeStampSyncInterval;

    BOOLEAN                 UserAccountControlChanged = FALSE,
                            MustUpdateAccountDisplay = FALSE,
                            MustQueryV1aFixed = TRUE,
                            ReplicateImmediately = FALSE,
                            TellNetlogon = TRUE,
                            AccountGettingMorphed = FALSE,
                            SystemChangesPrimaryGroupId = FALSE,
                            KeepOldPrimaryGroupMembership = FALSE,
                            AccountLockedOut, 
                            fLockAcquired = FALSE,
                            RemoveAccountNameFromTable = FALSE,
                            AccountUnlocked = FALSE,
                            fSetUserPassword = FALSE;

    SECURITY_DB_DELTA_TYPE  DeltaType = SecurityDbChange;
    UNICODE_STRING          ClearTextPassword;
    BOOLEAN                 ClearTextPasswordPresent = FALSE;
    UNICODE_STRING          AccountName;
    ULONG                   UserRid = 0;
    BOOLEAN                 PrivilegedMachineAccountCreate=FALSE;
    BOOLEAN                 FlushOnlyLogonProperties = FALSE;

    ULONG                   RemainingFlags = 0;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;

    SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(RequestedAttributes)



    TIME_FIELDS
        T1;

    DECLARE_CLIENT_REVISION(UserHandle);

    SAMTRACE_EX("SamrSetInformationUser");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetInformationUser
                   );

    //
    // Initialization.
    //

    ClearTextPassword.Buffer = NULL;
    ClearTextPassword.Length = 0;
    AccountName.Buffer = NULL;
    SAMP_INIT_SAM_ATTRIBUTE_BITMASK(RequestedAttributes)

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    if (Buffer == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // Reset any strings that we'll be freeing in clean-up code
    //

    RtlInitUnicodeString(&OldAccountName, NULL);
    RtlInitUnicodeString(&NewAccountName, NULL);
    RtlInitUnicodeString(&NewFullName, NULL);
    RtlInitUnicodeString(&NewAdminComment, NULL);


    //
    // Set the desired access based upon the Info class
    //

    switch (UserInformationClass) {

    case UserPreferencesInformation:
        DesiredAccess = USER_WRITE_PREFERENCES;
        break;

    case UserParametersInformation:
    case UserLogonHoursInformation:
    case UserNameInformation:
    case UserAccountNameInformation:
    case UserFullNameInformation:
    case UserPrimaryGroupInformation:
    case UserHomeInformation:
    case UserScriptInformation:
    case UserProfileInformation:
    case UserAdminCommentInformation:
    case UserWorkStationsInformation:
    case UserControlInformation:
    case UserExpiresInformation:

        DesiredAccess = USER_WRITE_ACCOUNT;
        break;

    case UserSetPasswordInformation:
    case UserInternal1Information:
    case UserInternal5Information:
    case UserInternal5InformationNew:

        DeltaType = SecurityDbChangePassword;
        DesiredAccess = USER_FORCE_PASSWORD_CHANGE;
        break;



    case UserAllInformation:
    case UserInternal3Information:
    case UserInternal4Information:
    case UserInternal4InformationNew:

        //////////////////////////////////////////////////////////////
        //                                                          //
        //  !!!! WARNING !!!!                                       //
        //                                                          //
        //  Be warned that the buffer structure for                 //
        //  UserInternal3/4Information MUST begin with the same     //
        //  structure as UserAllInformation.                        //
        //                                                          //
        //////////////////////////////////////////////////////////////

        DesiredAccess = 0;

        All = (PUSER_ALL_INFORMATION)Buffer;

        if ( ( All->WhichFields == 0 ) ||
            ( All->WhichFields & USER_ALL_WRITE_CANT_MASK ) ) {

            //
            // Passed in something (no fields to set), or is
            // trying to set fields that can't be set.
            //

            NtStatus = STATUS_INVALID_PARAMETER;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
        }

        //
        // If the user is the special account Administrator, return an
        // error if trying to set the expiry information, except to the value
        // that means that the account never expires.
        //

        if ( (All->WhichFields & USER_ALL_ACCOUNTEXPIRES) &&
             (!(AccountContext->TrustedClient)) &&
             ( AccountContext->TypeBody.User.Rid == DOMAIN_USER_RID_ADMIN )) {

            LARGE_INTEGER AccountNeverExpires, Temp;

            AccountNeverExpires = RtlConvertUlongToLargeInteger(
                                      SAMP_ACCOUNT_NEVER_EXPIRES
                                      );

            OLD_TO_NEW_LARGE_INTEGER(All->AccountExpires, Temp);

            if (!( Temp.QuadPart == AccountNeverExpires.QuadPart)) {

                NtStatus = STATUS_SPECIAL_ACCOUNT;
                goto Error;
            }
        }

        //
        // If the caller is trying to set trusted values, assume the
        // caller is trusted, leave DesiredAccess = 0, and proceed.
        // We'll check to make sure caller is trusted later.
        //

        if ( !(All->WhichFields & USER_ALL_WRITE_TRUSTED_MASK) ) {

            //
            // Set desired access based on which fields the caller is
            // trying to change.
            //
            if ( All->WhichFields & USER_ALL_WRITE_ACCOUNT_MASK ) {

                DesiredAccess |= USER_WRITE_ACCOUNT;
            }

            if ( All->WhichFields & USER_ALL_WRITE_PREFERENCES_MASK ) {

                DesiredAccess |= USER_WRITE_PREFERENCES;
            }


            if ( All->WhichFields & USER_ALL_WRITE_FORCE_PASSWORD_CHANGE_MASK ) {

                DesiredAccess |= USER_FORCE_PASSWORD_CHANGE;
            }

            ASSERT( DesiredAccess != 0 );
        }


        break;

    case UserInternal2Information:

        //
        // These levels are only setable by trusted clients.  The code
        // below will check AccountContext->TrustedClient after calling
        // SampLookupContext, and only set the data if it is TRUE.
        //

        DesiredAccess = (ACCESS_MASK)0;    // trusted client; no need to verify
        break;

    case UserGeneralInformation:
    case UserAccountInformation:
    case UserLogonInformation:
    default:

        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;

    } // end_switch


    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)UserHandle;
    ObjectRid = AccountContext->TypeBody.User.Rid;
    PrivilegedMachineAccountCreate =
            AccountContext->TypeBody.User.PrivilegedMachineAccountCreate;

    //
    // Compensating logic for NET API.
    // If privilege was used to create machine accounts, then mask the
    // which fields bit to just the password
    //

    if ((UserAllInformation==UserInformationClass)
            && (PrivilegedMachineAccountCreate))
    {
         All->WhichFields &= USER_ALL_WRITE_FORCE_PASSWORD_CHANGE_MASK;
         DesiredAccess = USER_FORCE_PASSWORD_CHANGE;
    }


    //
    // Only Proceed without grabbing the write lock, if
    // UserInternal2Information is being set on a thread
    // safe context
    //

    if ((!AccountContext->NotSharedByMultiThreads || !IsDsObject(AccountContext)) ||
        (UserInternal2Information!=UserInformationClass))
    {
        //
        // Grab the lock, if required
        //

        NtStatus = SampAcquireWriteLock();
        if (!NT_SUCCESS(NtStatus))
        {
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
        }

        fLockAcquired = TRUE;

        //
        // Determine what attributes will be referenced
        //
        SampGetRequestedAttributesForUser(UserInformationClass,
                                          All ? All->WhichFields : 0,
                                         &RequestedAttributes);


        //
        // Perform a lookup context, for non thread safe context's.
        //

        NtStatus = SampLookupContextEx(
                        AccountContext,
                        DesiredAccess,
                        SampUseDsData ? (&RequestedAttributes) : NULL,
                        SampUserObjectType,           // ExpectedType
                        &FoundType
                        );

    }
    else
    {

        //
        // For a thread safe context, writing just logon
        // statistics , just reference the context
        //

        ASSERT(AccountContext->TrustedClient);
        SampReferenceContext(AccountContext);
    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get a pointer to the domain this object is in.
        // This is used for auditing.
        //

        DomainIndex = AccountContext->DomainIndex;
        Domain = &SampDefinedDomains[ DomainIndex ];

        //
        // get a local copy of LastLogonTimeStampSyncInterval
        // 

        LocalLastLogonTimeStampSyncInterval = 
            SampDefinedDomains[DomainIndex].LastLogonTimeStampSyncInterval;

        //
        // Get the user's rid. This is used for notifying other
        // packages of a password change.
        //

        UserRid = AccountContext->TypeBody.User.Rid;


        //
        // If this information level contains reversibly encrypted passwords
        // it is not allowed if the DOMAIN_PASSWORD_NO_CLEAR_CHANGE bit is
        // set.  If that happens, return an error indicating that
        // the older information level should be used.
        //

        if ((UserInformationClass == UserInternal4Information) ||
            (UserInformationClass == UserInternal4InformationNew) ||
            (UserInformationClass == UserInternal5Information) ||
            (UserInformationClass == UserInternal5InformationNew) ) {

            if (Domain->UnmodifiedFixed.PasswordProperties &
                DOMAIN_PASSWORD_NO_CLEAR_CHANGE) {

                NtStatus = RPC_NT_INVALID_TAG;
            }

        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // If the information level requires, retrieve the V1_FIXED
            // record from the registry.  We need to fetch V1_FIXED if we
            // are going to change it or if we need the AccountControl
            // flags for display cache updating.
            //
            // The following information levels change data that is in the cached
            // display list.
            //

            switch (UserInformationClass) {

            case UserAllInformation:
            case UserInternal3Information:
            case UserInternal4Information:
            case UserInternal4InformationNew:

                if ( ( All->WhichFields &
                    ( USER_ALL_USERNAME | USER_ALL_FULLNAME |
                    USER_ALL_ADMINCOMMENT | USER_ALL_USERACCOUNTCONTROL ) )
                    == 0 ) {

                    //
                    // We're not changing any of the fields in the display
                    // info, we don't update the account display.
                    //

                    break;
                }

            case UserControlInformation:
            case UserNameInformation:
            case UserAccountNameInformation:
            case UserFullNameInformation:
            case UserAdminCommentInformation:

                MustUpdateAccountDisplay = TRUE;
            }

            //
            // These levels involve updating the V1aFixed structure
            //

            switch (UserInformationClass) {

            case UserAllInformation:

                 MustQueryV1aFixed = TRUE;

            case UserInternal3Information:
            case UserInternal4Information:
            case UserInternal4InformationNew:

                //
                // Earlier, we might have just trusted that the caller
                // was a trusted client.  Check it out here.
                //

                if (  ( DesiredAccess == 0 ) &&
                    ( !AccountContext->TrustedClient ) ) {

                    NtStatus = STATUS_ACCESS_DENIED;
                    break;
                }

                //
                // Otherwise fall through
                //

            case UserPreferencesInformation:
            case UserPrimaryGroupInformation:
            case UserControlInformation:
            case UserExpiresInformation:
            case UserSetPasswordInformation:
            case UserInternal1Information:
            case UserInternal2Information:
            case UserInternal5Information:
            case UserInternal5InformationNew:

                MustQueryV1aFixed = TRUE;

                break;

            default:

                NtStatus = STATUS_SUCCESS;

            } // end_switch


        }

        if ( NT_SUCCESS( NtStatus ) &&
            ( MustQueryV1aFixed || MustUpdateAccountDisplay ) ) {

            NtStatus = SampRetrieveUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );

            if (NT_SUCCESS(NtStatus)) {

                //
                // Store away the old account control flags for cache update
                //

                OldUserAccountControl = V1aFixed.UserAccountControl;

                //
                // Store away the old Primary Group Id for detecting wether we need
                // to modify the user's membership
                //

                OldPrimaryGroupId = V1aFixed.PrimaryGroupId;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // case on the type information requested
            //

            switch (UserInformationClass) {

            case UserAllInformation:
            case UserInternal3Information:
            case UserInternal4Information:
            case UserInternal4InformationNew:

                //
                // Set the string data
                //

                if ( All->WhichFields & USER_ALL_WORKSTATIONS ) {

                    if ( (All->WorkStations.Length > 0) &&
                         (All->WorkStations.Buffer == NULL) ) {

                         NtStatus = STATUS_INVALID_PARAMETER;
                    }

                    if ( NT_SUCCESS( NtStatus ) ) {
                        
                        if ( !AccountContext->TrustedClient ) {
    
                            //
                            // Convert the workstation list, which is given
                            // to us in UI/Service format, to API list format
                            // before storing it.  Note that we don't do this
                            // for trusted clients, since they're just
                            // propogating data that has already been
                            // converted.
                            //
    
                            NtStatus = SampConvertUiListToApiList(
                                           &(All->WorkStations),
                                           &ApiList,
                                           FALSE );
                        } else {
                            ApiList = All->WorkStations;
                        }
                    }

                    if ( NT_SUCCESS( NtStatus ) ) {

                        NtStatus = SampSetUnicodeStringAttribute(
                                       AccountContext,
                                       SAMP_USER_WORKSTATIONS,
                                       &ApiList
                                       );
                    }
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_USERNAME ) ) {

                    NtStatus = SampChangeUserAccountName(
                                    AccountContext,
                                    &(All->UserName),
                                    V1aFixed.UserAccountControl,
                                    &OldAccountName
                                    );

                    if (!NT_SUCCESS(NtStatus)) {

                        OldAccountName.Buffer = NULL;
                    }

                    //
                    // Get the Address of New Account Name
                    // 
                    NewAccountNameToRemove = &(All->UserName);

                    //
                    // RemoveAccountNameFromTable tells us whether
                    // the caller (this routine) is responsable 
                    // to remove the name from the table. 
                    // 
                    RemoveAccountNameFromTable = 
                        AccountContext->RemoveAccountNameFromTable;

                    //
                    // reset to FALSE
                    // 
                    AccountContext->RemoveAccountNameFromTable = FALSE;
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_FULLNAME ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   &(All->FullName)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_HOMEDIRECTORY ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   &(All->HomeDirectory)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_HOMEDIRECTORYDRIVE ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   &(All->HomeDirectoryDrive)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_SCRIPTPATH ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_SCRIPT_PATH,
                                   &(All->ScriptPath)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_PROFILEPATH ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PROFILE_PATH,
                                   &(All->ProfilePath)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_ADMINCOMMENT ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ADMIN_COMMENT,
                                   &(All->AdminComment)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_USERCOMMENT ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_USER_COMMENT,
                                   &(All->UserComment)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_PARAMETERS ) ) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PARAMETERS,
                                   &(All->Parameters)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_LOGONHOURS ) ) {

                    //
                    // Set the LogonHours
                    //

                    NtStatus = SampReplaceUserLogonHours(
                                   AccountContext,
                                   &(All->LogonHours)
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) && (
                    ( All->WhichFields & USER_ALL_NTPASSWORDPRESENT ) ||
                    ( All->WhichFields & USER_ALL_LMPASSWORDPRESENT ) ) ) {

                    NT_OWF_PASSWORD     NtOwfBuffer;
                    LM_OWF_PASSWORD     LmOwfBuffer;
                    PLM_OWF_PASSWORD    TmpLmBuffer;
                    PNT_OWF_PASSWORD    TmpNtBuffer;
                    BOOLEAN             TmpLmPresent;
                    BOOLEAN             TmpNtPresent;




                    //
                    // Get the effective domain policy
                    //


                    NtStatus = SampObtainEffectivePasswordPolicy(
                                    &DomainPasswordInfo,
                                    AccountContext,
                                    TRUE
                                    );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        break;
                    }

                    //
                    // Get copy of the account name to pass to
                    // notification packages.
                    //

                    NtStatus = SampGetUnicodeStringAttribute(
                                    AccountContext,
                                    SAMP_USER_ACCOUNT_NAME,
                                    TRUE,    // Make copy
                                    &AccountName
                                    );

                    if (!NT_SUCCESS(NtStatus)) {
                        break;
                    }


                    if ((UserInformationClass == UserInternal3Information) ||
                        ((UserInformationClass == UserAllInformation) && 
                         (!AccountContext->TrustedClient) &&
                         (!AccountContext->LoopbackClient))
                        ){


                        //
                        // Hashed passwords were sent.
                        //

                        if ( AccountContext->TrustedClient ) {

                            //
                            // Set password buffers as trusted client has
                            // indicated.
                            //

                            if ( All->WhichFields & USER_ALL_LMPASSWORDPRESENT ) {

                                TmpLmBuffer = (PLM_OWF_PASSWORD)All->LmPassword.Buffer;
                                TmpLmPresent = All->LmPasswordPresent;

                            } else {

                                TmpLmBuffer = (PLM_OWF_PASSWORD)NULL;
                                TmpLmPresent = FALSE;
                            }

                            if ( All->WhichFields & USER_ALL_NTPASSWORDPRESENT ) {

                                TmpNtBuffer = (PNT_OWF_PASSWORD)All->NtPassword.Buffer;
                                TmpNtPresent = All->NtPasswordPresent;

                            } else {

                                TmpNtBuffer = (PNT_OWF_PASSWORD)NULL;
                                TmpNtPresent = FALSE;
                            }

                        } else {

                            //
                            // This call came from the client-side.
                            // The OWFs will have been encrypted with the session
                            // key across the RPC link.
                            //
                            // Get the session key and decrypt both OWFs
                            //

                            NtStatus = RtlGetUserSessionKeyServer(
                                           (RPC_BINDING_HANDLE)UserHandle,
                                           &UserSessionKey
                                           );

                            if ( !NT_SUCCESS( NtStatus ) ) {
                                break; // out of switch
                            }

                            //
                            // Decrypt the LM OWF Password with the session key
                            //

                            if ( All->WhichFields & USER_ALL_LMPASSWORDPRESENT ) {

                                NtStatus = RtlDecryptLmOwfPwdWithUserKey(
                                               (PENCRYPTED_LM_OWF_PASSWORD)
                                                   All->LmPassword.Buffer,
                                               &UserSessionKey,
                                               &LmOwfBuffer
                                               );
                                if ( !NT_SUCCESS( NtStatus ) ) {
                                    break; // out of switch
                                }

                                TmpLmBuffer = &LmOwfBuffer;
                                TmpLmPresent = All->LmPasswordPresent;

                            } else {

                                TmpLmBuffer = (PLM_OWF_PASSWORD)NULL;
                                TmpLmPresent = FALSE;
                            }

                            //
                            // Decrypt the NT OWF Password with the session key
                            //

                            if ( All->WhichFields & USER_ALL_NTPASSWORDPRESENT ) {

                                NtStatus = RtlDecryptNtOwfPwdWithUserKey(
                                               (PENCRYPTED_NT_OWF_PASSWORD)
                                               All->NtPassword.Buffer,
                                               &UserSessionKey,
                                               &NtOwfBuffer
                                               );

                                if ( !NT_SUCCESS( NtStatus ) ) {
                                    break; // out of switch
                                }

                                TmpNtBuffer = &NtOwfBuffer;
                                TmpNtPresent = All->NtPasswordPresent;

                            } else {

                                TmpNtBuffer = (PNT_OWF_PASSWORD)NULL;
                                TmpNtPresent = FALSE;
                            }

                        }

                    } else {

                        BOOLEAN AccountControlChange = FALSE;
                        BOOLEAN MachineAccount=FALSE;
                        BOOLEAN MachineOrTrustAccount = FALSE;
                        BOOLEAN NoPasswordRequiredForAccount = FALSE;


                        AccountControlChange = ((A