        _spMediaElem2.Release();
    }

    if (_spPlayerHTMLElem2.p)
    {
        _spPlayerHTMLElem2.Release();
    }

    if (_spBodyElem.p)
    {
        _spBodyElem.Release();
    }

    if (_spBrowser.p)
    {
        _spBrowser.Release();
    }

    if (_hwnd && ::IsWindow(_hwnd))
    {
        ::DestroyWindow(_hwnd);
        _hwnd = NULL;
    }

    return S_OK;
}


STDMETHODIMP
CMediaBarPlayer::GetVideoHwnd(HWND * pHwnd)
{
    if (pHwnd)
        *pHwnd = _hwnd;

    return S_OK;
}

static const PWSTR ppszInterestingEvents[] = 
{ 
    WZ_ONMEDIACOMPLETE,
    WZ_ONMEDIAERROR,
    WZ_ONEND,
    WZ_ONTRACKCHANGE    
};

//+-------------------------------------------------------------------------
// Attaches to player events
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_AttachPlayerEvents(BOOL fAttach)
{
    HRESULT hr = E_FAIL;

    CComPtr<IDispatchEx> spDispEx;
    CComPtr<IHTMLElement2> spElem2;

    hr = _GetElementDispatch(WZ_PLAYER, &spDispEx);
    ERROREXIT(hr)

    hr = spDispEx->QueryInterface(IID_TO_PPV(IHTMLElement2, &spElem2));
    ERROREXIT(hr)
    
    hr = S_OK;
    for (DWORD i = 0; i < ARRAYSIZE(ppszInterestingEvents); i++)
    {
        if (fAttach)
        {
            VARIANT_BOOL bSuccess = FALSE;
            // Try to attach all events. We don't care if they fail
            if (FAILED(spElem2->attachEvent(ppszInterestingEvents[i], static_cast<IDispatch*>(this), &bSuccess)))
            {
                hr = S_FALSE;
            }
        }
        else
        {
            // Try to detact all events. We don't care if they fail
            hr = spElem2->detachEvent(ppszInterestingEvents[i], static_cast<IDispatch*>(this));
        }
    }


done:
    return hr;
}


//+-------------------------------------------------------------------------
// Hooks property change notifications
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_HookPropNotifies()
{
    HRESULT hr = E_FAIL;
    CComPtr<ITIMEState> spTimeState;
    CComPtr<IConnectionPointContainer> spConPtCont;

    if (!_spMediaElem || _spPropNotifyCP.p || _dwCookiePropNotify)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = _spMediaElem->get_currTimeState(&spTimeState);
    ERROREXIT(hr)

    hr = spTimeState->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &spConPtCont));
    ERROREXIT(hr)

    hr = spConPtCont->FindConnectionPoint(IID_IPropertyNotifySink, &_spPropNotifyCP);
    ERROREXIT(hr)

    hr = _spPropNotifyCP->Advise(static_cast<IUnknown*>(static_cast<IDispatch*>(this)), &_dwCookiePropNotify);
    ERROREXIT(hr)
    
    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Unhooks property change notifications
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_UnhookPropNotifies()
{
    if (_spPropNotifyCP.p)
    {
        if (_dwCookiePropNotify != 0)
        {
            IGNORE_HR(_spPropNotifyCP->Unadvise(_dwCookiePropNotify));
        }
        _spPropNotifyCP.Release();
    }
    _dwCookiePropNotify = 0;

    return S_OK;
}


//+-------------------------------------------------------------------------
// Invokes a method on the given element
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_InvokeDocument(LPWSTR pstrElem, INVOKETYPE it, LPWSTR pstrName, VARIANT * pvarArg)
{
    HRESULT hr = E_FAIL;
    DISPPARAMS dispparams = {NULL, NULL, 0, 0};
    CComPtr<IDispatchEx> spDispEx;
    CComBSTR sbstrName; 
    DISPID dispid = 0;
    DISPID dispidProp = 0;

    sbstrName.m_str = SysAllocString(pstrName);
    if (!sbstrName.m_str)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    hr = _GetElementDispatch(pstrElem, &spDispEx);
    ERROREXIT(hr)

    hr = spDispEx->GetDispID(sbstrName, fdexNameEnsure, &dispid);
    ERROREXIT(hr)

    switch (it)
    {
        case IT_METHOD:
        {
            dispparams.rgvarg = pvarArg;
            dispparams.cArgs = (pvarArg ? 1 : 0);

            hr = spDispEx->InvokeEx(dispid, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, NULL, NULL, NULL);
            ERROREXIT(hr)
        }
        break;
    
        case IT_PUT:
        {
            dispidProp = DISPID_PROPERTYPUT;

            if (!pvarArg)
            {
                hr = E_INVALIDARG;
                goto done;
            }

            dispparams.rgvarg = pvarArg;
            dispparams.rgdispidNamedArgs = &dispidProp;
            dispparams.cArgs = 1;
            dispparams.cNamedArgs = 1;

            hr = spDispEx->InvokeEx(dispid, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT, &dispparams, NULL, NULL, NULL);
            ERROREXIT(hr)
        }
        break;
    
        case IT_GET:
        {
            if (!pvarArg)
            {
                hr = E_INVALIDARG;
                goto done;
            }

            hr = spDispEx->InvokeEx(dispid, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET, &dispparams, pvarArg, NULL, NULL);
            ERROREXIT(hr)
        }
        break;
    }

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Gets the dispatch ptr of the document 
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_GetDocumentDispatch(IDispatch ** ppDocDisp)
{
    HRESULT hr = E_FAIL;

    if (!ppDocDisp)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (!_spBrowser)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = _spBrowser->get_Document(ppDocDisp);
    ERROREXIT(hr)

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// Gets the ITIMEBodyElement interface
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_GetBodyElement(ITIMEBodyElement ** ppBodyElem)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;

    if (!ppBodyElem)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = _InvokeDocument(WZ_BODY, IT_GET, WZ_REGISTERED_TIME_NAME, &svarArg);
    ERROREXIT(hr)

    hr = ::VariantChangeType(&svarArg, &svarArg, NULL, VT_DISPATCH);
    ERROREXIT(hr)

    if (NULL == V_DISPATCH(&svarArg))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = V_DISPATCH(&svarArg)->QueryInterface(IID_TO_PPV(ITIMEBodyElement, ppBodyElem));
    ERROREXIT(hr)

    ASSERT(ppBodyElem);

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Gets the ITIMEMediaElement interface
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_GetMediaElement(ITIMEMediaElement ** ppMediaElem)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;

    if (!ppMediaElem)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    hr = _InvokeDocument(WZ_PLAYER, IT_GET, WZ_REGISTERED_TIME_NAME, &svarArg);
    ERROREXIT(hr)

    hr = ::VariantChangeType(&svarArg, &svarArg, NULL, VT_DISPATCH);
    ERROREXIT(hr)

    if (NULL == V_DISPATCH(&svarArg))
    {
        hr = E_FAIL;
        goto done;
    }

    hr = V_DISPATCH(&svarArg)->QueryInterface(IID_TO_PPV(ITIMEMediaElement, ppMediaElem));
    ERROREXIT(hr)

    ASSERT(ppMediaElem);

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Gets the IDispatchEx pointer of the named element
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_GetElementDispatch(LPWSTR pstrElem, IDispatchEx ** ppDispEx)
{
    HRESULT hr = E_FAIL;
    CComPtr<IDispatch> spElemDisp;
    CComPtr<IDispatch> spDocDisp;
    CComPtr<IHTMLDocument2> spDoc2;
    CComPtr<IHTMLElementCollection> spAll;
    CComVariant svarName;
    CComVariant svarIndex;

    if (!ppDispEx || !pstrElem)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    V_VT(&svarName) = VT_BSTR;
    V_BSTR(&svarName) = SysAllocString(pstrElem);

    if (NULL == V_BSTR(&svarName))
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    V_VT(&svarIndex) = VT_I4;
    V_I4(&svarIndex) = 0;

    hr = _GetDocumentDispatch(&spDocDisp);
    ERROREXIT(hr)

    // WebOC returns S_OK even if doc disp is not available
    if (!spDocDisp.p)
    {
        hr = E_FAIL;
        goto done;
    }

    hr = spDocDisp->QueryInterface(IID_TO_PPV(IHTMLDocument2, &spDoc2));
    ERROREXIT(hr)

    hr = spDoc2->get_all(&spAll);
    ERROREXIT(hr)

    hr = spAll->item(svarName, svarIndex, &spElemDisp);
    ERROREXIT(hr)

    if (spElemDisp.p)
    {
        hr = spElemDisp->QueryInterface(IID_TO_PPV(IDispatchEx, ppDispEx));
        ERROREXIT(hr)
    }
    else
    {
        hr = E_FAIL;
        goto done;
    }

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Stuff to be done when document is loaded
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_OnDocumentComplete()
{
    HRESULT hr = E_FAIL;

    // store off a pointer to the media element behavior
    hr = _GetMediaElement(&_spMediaElem);
    ERROREXIT(hr)

    hr = _spMediaElem->QueryInterface(IID_TO_PPV(ITIMEMediaElement2, &_spMediaElem2));
    ERROREXIT(hr)

    // store off a pointer to the player's HTML element
    {
        CComPtr<IDispatchEx> spPlayerDisp;

        hr = _GetElementDispatch(WZ_PLAYER, &spPlayerDisp);
        ERROREXIT(hr)

        if (!spPlayerDisp.p)
        {
            hr = E_FAIL;
            goto done;
        }

        hr = spPlayerDisp->QueryInterface(IID_TO_PPV(IHTMLElement2, &_spPlayerHTMLElem2)); 
        ERROREXIT(hr)
    }

    // store off a pointer to the body element
    hr = _GetBodyElement(&_spBodyElem);
    ERROREXIT(hr)

    // Attach to player events
    hr = _AttachPlayerEvents(TRUE);
    ERROREXIT(hr)

    // Hook Property notifications
    hr = _HookPropNotifies();
    ERROREXIT(hr)

    // set the type if deferred
    if (_sbstrType.m_str)
    {
        hr = put_type(_sbstrType);
        _sbstrType.Empty();
        ERROREXIT(hr)
    }

    // set the url if deferred
    if (_sbstrUrl.m_str)
    {
        hr = put_url(_sbstrUrl);
        _sbstrUrl.Empty();
        ERROREXIT(hr)
    }

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// Stuff to be done when Media is ready
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_OnMediaComplete()
{
    // notify the media bar
    if (_pMediaBar)
    {
        _pMediaBar->Notify(MEDIACOMPLETE);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Stuff to be done when Media is ready
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_OnTrackChange()
{
    // notify the media bar
    if (_pMediaBar)
    {
        _pMediaBar->Notify(TRACK_CHANGE);
    }

    return S_OK;
}



//+-------------------------------------------------------------------------
// Stuff to be done when track is finished
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_OnEnd()
{
    // notify the media bar
    if (_pMediaBar)
    {
        _pMediaBar->Notify(MEDIA_TRACK_FINISHED);
    }
    return S_OK;
}


//+-------------------------------------------------------------------------
// notification that there was some error playing the Media stream
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::_OnMediaError(int iErrCode)
{
    CComPtr<IDispatch> spWMP;
    if (_spMediaElem && SUCCEEDED(_spMediaElem->get_playerObject(&spWMP)))
    {
        VARIANT varError;
        if (SUCCEEDED(GetProp(spWMP, L"error", &varError)))
        {
            CallMethod(varError.pdispVal, L"webHelp");
        }
        VariantClear(&varError);
    }
    // notify the media bar
    if (_pMediaBar)
    {
        _pMediaBar->OnMediaError(iErrCode);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Handle property change notifications
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::OnChanged(DISPID dispid)
{
    // notify the media bar
    if (_pMediaBar)
    {
        _pMediaBar->Notify(dispid);
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////
//
// IMediaBarPlayer
//
////////////////////////////////////////////////////////////////////////////



//+-------------------------------------------------------------------------
// Init the player 
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Init(HWND hWnd, IMediaBar * pMediaBar)
{
    HRESULT hr = E_FAIL;

    if (!pMediaBar)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    // store a weak ref to prevent circular reference
    _pMediaBar = pMediaBar;

    hr = _CreateHost(hWnd);
    ERROREXIT(hr)

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        DeInit();
    }

    return hr;
}

//+-------------------------------------------------------------------------
// DeInit the player 
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::DeInit()
{
    _pMediaBar = NULL;

    return _DestroyHost();
}

//+-------------------------------------------------------------------------
// sets the media clip type
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::put_type(BSTR bstrType)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;
    CComVariant svarEmpty;

    svarArg.vt = VT_NULL;
    svarEmpty.vt = VT_NULL;

    if (!IsReady())
    {
        _sbstrType.m_str = ::SysAllocString(bstrType);
        if (bstrType && !_sbstrType)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }
        goto done;
    }

    if (bstrType)
    {
        V_VT(&svarArg) = VT_BSTR;
        V_BSTR(&svarArg) = SysAllocString(bstrType);
        if (NULL == V_BSTR(&svarArg))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    // always stop the player
    hr = _spMediaElem->endElement();
    ERROREXIT(hr)

    hr = _spMediaElem->put_src(svarEmpty);
    ERROREXIT(hr)

    hr = _spMediaElem->put_type(svarArg);
    ERROREXIT(hr)

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// sets the media clip url 
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::put_url(BSTR bstrUrl)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;
    CComVariant svarEmpty;

    svarArg.vt = VT_NULL;
    svarEmpty.vt = VT_NULL;

    if (!IsReady())
    {
        _sbstrUrl.m_str = ::SysAllocString(bstrUrl);
        if (bstrUrl && !_sbstrUrl)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }
        goto done;
    }

    if (bstrUrl)
    {
        V_VT(&svarArg) = VT_BSTR;
        V_BSTR(&svarArg) = SysAllocString(bstrUrl);
        if (NULL == V_BSTR(&svarArg))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    // always stop the player
    hr = _spMediaElem->endElement();
    ERROREXIT(hr)

    hr = _spMediaElem->put_src(svarArg);
    ERROREXIT(hr)

    // always start the player
    hr = _spMediaElem->beginElement();
    ERROREXIT(hr)

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// gets the media clip url
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::get_url(BSTR * pbstrUrl)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;

    if (!pbstrUrl || !IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    *pbstrUrl = NULL;

    hr = _spMediaElem->get_src(&svarArg);
    ERROREXIT(hr)

    hr = svarArg.ChangeType(VT_BSTR);
    ERROREXIT(hr)

    if (svarArg.bstrVal)
    {
        *pbstrUrl = SysAllocString(svarArg.bstrVal);
        if (NULL == *pbstrUrl)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}


//+-------------------------------------------------------------------------
// gets the player attribute
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::get_player(BSTR * pbstrPlayer)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;

    if (!pbstrPlayer || !IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    *pbstrPlayer = NULL;

    hr = _spMediaElem->get_player(&svarArg);
    ERROREXIT(hr)

    hr = svarArg.ChangeType(VT_BSTR);
    ERROREXIT(hr)

    if (svarArg.bstrVal)
    {
        *pbstrPlayer = SysAllocString(svarArg.bstrVal);
        if (NULL == *pbstrPlayer)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
    }

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// sets the volume
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::put_volume(double dblVolume)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;
    
    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    V_VT(&svarArg) = VT_R8;
    V_R8(&svarArg) = dblVolume;

    hr = _spMediaElem->put_volume(svarArg);
    ERROREXIT(hr)

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// gets the volume
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::get_volume(double * pdblVolume)
{
    return E_NOTIMPL;
}


//+-------------------------------------------------------------------------
// gets the media element pointer
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::get_mediaElement(ITIMEMediaElement ** ppMediaElem)
{
    if (!ppMediaElem || !_spMediaElem)
    {
        return E_FAIL;
    }

    *ppMediaElem = _spMediaElem;
    (_spMediaElem.p)->AddRef();

    return S_OK;
}


//+-------------------------------------------------------------------------
// sets the mute
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::put_mute(BOOL bMute)
{
    HRESULT hr = E_FAIL;
    CComVariant svarArg;

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    V_VT(&svarArg) = VT_BOOL;
    V_BOOL(&svarArg) = bMute ? VARIANT_TRUE : VARIANT_FALSE;

    hr = _spMediaElem->put_mute(svarArg);
    ERROREXIT(hr)

    hr = S_OK;
done:
    return hr;
}

//+-------------------------------------------------------------------------
// gets the mute
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::get_mute(BOOL * pbMute)
{
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
// plays the media
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Play()
{
    if (!IsReady())
        return E_FAIL;

    return _spMediaElem->beginElement();
}


//+-------------------------------------------------------------------------
// stops the media
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Stop()
{
    if (!IsReady())
        return E_FAIL;

    return _spMediaElem->endElement();
}


//+-------------------------------------------------------------------------
// pauses the media
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Pause()
{
    if (!IsReady())
        return E_FAIL;

    return _spMediaElem->pauseElement();
}

//+-------------------------------------------------------------------------
// resumes the media
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Resume()
{
    if (!IsReady())
        return E_FAIL;

    return _spMediaElem->resumeElement();
}


//+-------------------------------------------------------------------------
// seeks the media to the given progress
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Seek(double dblProgress)
{
    HRESULT hr = E_FAIL;
    CComPtr<ITIMEState> spTimeState;
    double dblActiveDur = 0.0;
    double dblSeekTime = 0.0;
    VARIANT_BOOL vbActive = VARIANT_FALSE;

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    if (!IsPlayList())
    {
        hr = _spMediaElem->get_currTimeState(&spTimeState);
        ERROREXIT(hr)

        hr = spTimeState->get_activeDur(&dblActiveDur);
        ERROREXIT(hr)

        hr = spTimeState->get_isActive(&vbActive);
        ERROREXIT(hr)

        // ISSUE: workaround for IE6 #20622
        // if the clip has ended, reactivate it in the paused state
        if (VARIANT_FALSE == vbActive)
        {
            _spMediaElem->beginElement();
            _spMediaElem->pauseElement();
        }

        if (TIME_INFINITE == dblActiveDur)
        {
            // we shouldn't be allowed to seek
            goto done;
        }
        else
        {
            Clamp(0.0, dblProgress, 1.0);
            dblSeekTime = dblActiveDur *  dblProgress;
        }

        // seek the body
        hr = _spMediaElem->seekActiveTime(dblSeekTime);
        ERROREXIT(hr)

        hr = S_OK;
    }
    else
    {
        CComPtr<ITIMEPlayList> spPlayList;
        CComPtr<ITIMEPlayItem> spPlayItem;
        CComPtr<ITIMEMediaNative> spMediaNative;

        hr = _spMediaElem->get_playList(&spPlayList);
        if (SUCCEEDED(hr) && spPlayList)
        {
            hr = spPlayList->get_activeTrack(&spPlayItem);
            if (SUCCEEDED(hr) && spPlayItem)
            {
                spPlayItem->get_dur(&dblActiveDur);
                dblSeekTime = dblActiveDur * dblProgress;

                hr = _spMediaElem->QueryInterface(IID_TO_PPV(ITIMEMediaNative, &spMediaNative));
                if (SUCCEEDED(hr) && spMediaNative)
                {
                    spMediaNative->seekActiveTrack(dblSeekTime);
                }
            }
        }
    }

done:
    return hr;
}

//+-------------------------------------------------------------------------
// Resize the video to fit in the given window size, preserving aspect ratio 
//--------------------------------------------------------------------------
STDMETHODIMP
CMediaBarPlayer::Resize(LONG* plHeight, LONG* plWidth, BOOL fClampMaxSizeToNaturalSize)
{
    HRESULT hr = E_FAIL;
    long lMediaWidth = 0;
    long lMediaHeight = 0;
    long lResizeWidth = 0;
    long lResizeHeight = 0;
    float flWndAspect = 0.0f; 
    float flMediaAspect = 0.0f; 

    if (!IsReady() || !plHeight || !plWidth || (0 == (*plHeight)) || (0 == (*plWidth)))
    {
        goto done;
    }

    hr = _spMediaElem->get_mediaWidth(&lMediaWidth);
    ERROREXIT(hr)

    hr = _spMediaElem->get_mediaHeight(&lMediaHeight);
    ERROREXIT(hr)

    // do resize only if both dimensions are non-zero
    if (0 != lMediaWidth &&  0 != lMediaHeight)
    {
        // if natural media size <= window size and max size is clamped to natural media size
        if (    fClampMaxSizeToNaturalSize
            &&  lMediaWidth <= (*plWidth) 
            &&  lMediaHeight <= (*plHeight))
        {
            // set the media back to it's natural size
            lResizeHeight = lMediaHeight;
            lResizeWidth = lMediaWidth;
        }
        else        
        {
            // resize the media to the window size

            flWndAspect = (float) (*plHeight) / (float) (*plWidth); 
            flMediaAspect = (float) lMediaHeight / (float) lMediaWidth; 

            if (flMediaAspect <= flWndAspect)
            {
                // set width to window width and compute the height according to aspect ratio
                lResizeWidth = (long)(*plWidth);
                lResizeHeight = (long)(lResizeWidth * flMediaAspect);
            }
            else
            {
                // set height to window height and compute the width according to aspect ratio
                lResizeHeight = (long)(*plHeight);
                lResizeWidth = (long)(lResizeHeight / flMediaAspect);
            }
        }

        // set the resized height and width on the HTML element
        {
            CComPtr<IHTMLStyle> spStyle;
            CComPtr<IHTMLElement2> spHTMLElem;

            hr = _spPlayerHTMLElem2->QueryInterface(IID_PPV_ARG(IHTMLElement2, &spHTMLElem));
            ERROREXIT(hr)

            // Using runtimeStyle instead of style. 
            // (Previously, we did the reverse as a work around for IE6 #20625. But now style is broken.)
            hr = spHTMLElem->get_runtimeStyle(&spStyle);
            ERROREXIT(hr)

            hr = spStyle->put_pixelWidth(lResizeWidth);
            ERROREXIT(hr)

            hr = spStyle->put_pixelHeight(lResizeHeight);
            ERROREXIT(hr)
        }
    }

    *plWidth  = lResizeWidth ;
    *plHeight = lResizeHeight;
    
    hr = S_OK;
    
done:
    return hr;
}


////////////////////////////////////////////////////////////////////////////
//
// IDispatch
//
////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//  Name: Invoke
// 
//  Abstract:
//    This switches on the dispid looking for dispid's of events
//    that it should handle.  Note, this is called for all events
//    fired from the window, only the selected events are handled.
//--------------------------------------------------------------------------
STDMETHODIMP CMediaBarPlayer::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID /*riid*/,
    /* [in] */ LCID /*lcid*/,
    /* [in] */ WORD /*wFlags*/,
    /* [out][in] */ DISPPARAMS* pDispParams,
    /* [out] */ VARIANT* pVarResult,
    /* [out] */ EXCEPINFO* /*pExcepInfo*/,
    /* [out] */ UINT* puArgErr)
{
    HRESULT hr = E_FAIL;

    switch (dispIdMember)
    {
    case 0: //this is the case for events that have been hooked using attachEvent
        {
            CComBSTR sbstrEvent;
            CComPtr <IHTMLEventObj> pEventObj;
            
            if ((NULL != pDispParams) && (NULL != pDispParams->rgvarg) &&
                (V_VT(&(pDispParams->rgvarg[0])) == VT_DISPATCH))
            {
                hr = THR((pDispParams->rgvarg[0].pdispVal)->QueryInterface(IID_IHTMLEventObj, (void**)&pEventObj));
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            else
            {
                ASSERT(0 && "Unexpected dispparam values passed to CEventMgr::Invoke(dispid = 0)");
                hr = E_UNEXPECTED;
                goto done;
            }
            
            hr = THR(pEventObj->get_type(&sbstrEvent));
            
            if (0 == StrCmpIW(WZ_TRACKCHANGE, sbstrEvent))
            {
                _OnTrackChange();
            }
            if (0 == StrCmpIW(WZ_MEDIACOMPLETE, sbstrEvent))
            {
                _OnMediaComplete();
            }
            else if (0 == StrCmpIW(WZ_MEDIAERROR, sbstrEvent))
            {

                int iErrCode = -1;

                // Get the param if available
                CComPtr<IHTMLEventObj2> spEventObj2;
                CComVariant svarParam;
                CComBSTR sbstrParam(WZ_PARAM);

                hr = pEventObj->QueryInterface(IID_IHTMLEventObj2, (void**) &spEventObj2);
                if (SUCCEEDED(hr) && sbstrParam.m_str)
                {
                    // get the params
                    hr = spEventObj2->getAttribute(sbstrParam, 0, &svarParam);
                    if (SUCCEEDED(hr))
                    {
                        // change type to int
                        hr = svarParam.ChangeType(VT_I4);
                        if (SUCCEEDED(hr))
                        {
                            iErrCode = V_I4(&svarParam);
                        }
                    }
                }
                _OnMediaError(iErrCode);
            }
            else if (0 == StrCmpIW(WZ_END, sbstrEvent))
            {
                _OnEnd();
            }
        }
        break;
        
    case 259: // DISPID_DOCUMENTCOMPLETE
        {
            hr = _OnDocumentComplete();
            ERROREXIT(hr)
        }
        break;
    }

    hr = S_OK;
  done:
    return S_OK;
}

///////////////////////////////////////////////////////////////
//  Name: _InitEventSink
// 
//  Abstract:
//    Finds a connection point on the HTMLDocument interface
//    and passes this as an event handler.
///////////////////////////////////////////////////////////////
STDMETHODIMP
CMediaBarPlayer::_InitEventSink()
{
    // Get a connection point to the container
    CComPtr<IConnectionPointContainer> spDocCPC; 

    HRESULT hr = E_FAIL;

    hr = _spBrowser->QueryInterface(IID_IConnectionPointContainer, (void**)&spDocCPC);
    ERROREXIT(hr)

    hr = THR(spDocCPC->FindConnectionPoint(DIID_DWebBrowserEvents2, &_spDocConPt ));
    ERROREXIT(hr)
    
    hr = THR(_spDocConPt->Advise(static_cast<IUnknown*>(static_cast<DWebBrowserEvents2*>(this)), &_dwDocumentEventConPtCookie));
    ERROREXIT(hr)

    hr = S_OK;
done:
    if (FAILED(hr))
    {
        _DeInitEventSink();
    }
    return hr;  
}


///////////////////////////////////////////////////////////////
//  Name: _DeInitEventSink
// 
///////////////////////////////////////////////////////////////
STDMETHODIMP
CMediaBarPlayer::_DeInitEventSink()
{
    //release the document connection points
    if (_spDocConPt)
    {
        if (_dwDocumentEventConPtCookie != 0)
        {
            IGNORE_HR(_spDocConPt->Unadvise(_dwDocumentEventConPtCookie));
        }
        _spDocConPt.Release();
    }
    _dwDocumentEventConPtCookie = 0;

    return S_OK;
}


double 
STDMETHODCALLTYPE 
CMediaBarPlayer::GetTrackProgress()
{
    if (IsReady())
    {
        if (!IsPlayList())
        {
            CComPtr<ITIMEState> spTimeState;
            if (SUCCEEDED(_spMediaElem->get_currTimeState(&spTimeState)) && spTimeState)
            {
                double dblProgress  = 0.0;
                if (SUCCEEDED(spTimeState->get_progress(&dblProgress)))
                {
                    return dblProgress;
                }                                    
            }
        }
        else
        {
            CComPtr<ITIMEMediaNative> spMediaNative;
            double dblProgress, dblActiveDur;
            CComPtr<ITIMEPlayList> spPlayList;
            CComPtr<ITIMEPlayItem> spPlayItem;

            if (SUCCEEDED(_spMediaElem->get_playList(&spPlayList)) && spPlayList)
            {
                if (SUCCEEDED(spPlayList->get_activeTrack(&spPlayItem)) && spPlayItem)
                {
                    spPlayItem->get_dur(&dblActiveDur);
                    if (SUCCEEDED(_spMediaElem->QueryInterface(IID_TO_PPV(ITIMEMediaNative, &spMediaNative))) && spMediaNative)
                    {
                        spMediaNative->get_activeTrackTime(&dblProgress);
                        return dblProgress / dblActiveDur;
                    }
                }
            }
        }
    }
    return 0.0;
}

double 
STDMETHODCALLTYPE 
CMediaBarPlayer::GetTrackTime()
{
    if (IsReady())
    {
        CComPtr<ITIMEState> spTimeState;
        if (SUCCEEDED(_spMediaElem->get_currTimeState(&spTimeState)) && spTimeState)
        {
            double dblTime = 0.0;
            if (SUCCEEDED(spTimeState->get_simpleTime(&dblTime)))
            {
                return dblTime;
            }
        }
    }
    return 0.0;
}
    
double 
STDMETHODCALLTYPE 
CMediaBarPlayer::GetTrackLength()
{
    if (IsReady())
    {
        double dblDur = 0.0;

        if (SUCCEEDED(_spMediaElem->get_mediaDur(&dblDur)))
            return dblDur ;
    }
    return 0.0;
}

// Returns a progress between 0 and 100 and whether this is download or buffering progress
STDMETHODIMP
CMediaBarPlayer::GetBufProgress(double * pdblProg, ProgressType * ppt)
{
    HRESULT hr = E_FAIL;
    VARIANT_BOOL vb = VARIANT_FALSE;

    if (!pdblProg || !ppt)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (!IsReady())
    {
        hr = E_FAIL;
        goto done;
    }

    *pdblProg = 0.0;
    *ppt = PT_None;

    hr = _spMediaElem2->get_isStreamed(&vb);
    if (FAILED(hr))
    {
        goto done;
    }

    if (VARIANT_TRUE == vb)
    {
        CComVariant svarBufProg;

        hr = _spMediaElem2->get_bufferingProgress(&svarBufProg);
        if (SUCCEEDED(hr))
        {
            *ppt = PT_Buffering;
            if (SUCCEEDED(svarBufProg.ChangeType(VT_R8)))
            {
                *pdblProg = V_R8(&svarBufProg);
            }
        }
    }
    else
    {
        CComVariant svarDownloadProg;

        hr = _spMediaElem2->get_downloadProgress(&svarDownloadProg);
        if (SUCCEEDED(hr))
        {
            *ppt = PT_Download;
            if (SUCCEEDED(svarDownloadProg.ChangeType(VT_R8)))
            {
                *pdblProg = V_R8(&svarDownloadProg);
            }
        }
    }
    
done:
    return hr;
}

VARIANT_BOOL STDMETHODCALLTYPE 
CMediaBarPlayer::isMuted()
{
    VARIANT_BOOL vbMuted = VARIANT_FALSE;
    if (IsReady())
    {
        CComPtr<ITIMEState> spTimeState;
        if (SUCCEEDED(_spMediaElem->get_currTimeState(&spTimeState)) && spTimeState)
        {
            spTimeState->get_isMuted(&vbMuted);
        }
    }
    return vbMuted;
}

VARIANT_BOOL STDMETHODCALLTYPE 
CMediaBarPlayer::isPaused()
{
    VARIANT_BOOL vbPaused = VARIANT_FALSE;
    if (IsReady())
    {
        CComPtr<ITIMEState> spTimeState;
        if (SUCCEEDED(_spMediaElem->get_currTimeState(&spTimeState)) && spTimeState)
        {
            spTimeState->get_isPaused(&vbPaused);
        }
    }
    return vbPaused;
}

VARIANT_BOOL STDMETHODCALLTYPE 
CMediaBarPlayer::isStopped()
{
    VARIANT_BOOL vbActive = VARIANT_FALSE;
    if (IsReady())
    {
        CComPtr<ITIMEState> spTimeState;
        if (SUCCEEDED(_spMediaElem->get_currTimeState(&spTimeState)) && spTimeState)
        {
            spTimeState->get_isActive(&vbActive);
        }
    }
    return (vbActive ? VARIANT_FALSE : VARIANT_TRUE);
}

STDMETHODIMP
CMediaBarPlayer::Next()
{
    return _SetTrack(TT_Next);;
}

STDMETHODIMP
CMediaBarPlayer::Prev()
{
    return _SetTrack(TT_Prev);
}

STDMETHODIMP
CMediaBarPlayer::_SetTrack(TrackType tt)
{
    HRESULT hr = E_FAIL;
    CComPtr<ITIMEPlayList> spPlayList;
    
    if (!IsReady())
    {
        goto done;
    }

    hr = _spMediaElem->get_playList(&spPlayList);
    ERROREXIT(hr)

    if (NULL != spPlayList.p)
    {
        if (TT_Next == tt)
        {
            hr = spPlayList->nextTrack();
            ERROREXIT(hr)
        }
        else if (TT_Prev == tt)
        {
            hr = spPlayList->prevTrack();
            ERROREXIT(hr)
        }
    }

    hr = S_OK;
done:
    return hr;
}

LONG_PTR 
STDMETHODCALLTYPE 
CMediaBarPlayer::GetPlayListItemIndex()
{
    CComPtr<ITIMEPlayList> spPlayList;
    long lIndex = -1;

    if (IsReady())
    {
        if (SUCCEEDED(_spMediaElem->get_playList(&spPlayList)))
        {
            CComPtr<ITIMEPlayItem> spPlayItem;
            if (spPlayList && SUCCEEDED(spPlayList->get_activeTrack(&spPlayItem)))
            {
                if (spPlayItem && SUCCEEDED(spPlayItem->get_index(&lIndex)))
                    return lIndex;
            }
        }
    }
    return (LONG_PTR)lIndex;
}

LONG_PTR 
STDMETHODCALLTYPE 
CMediaBarPlayer::GetPlayListItemCount()
{
    CComPtr<ITIMEPlayList> spPlayList;
    LONG lLength = 0;

    if (IsReady())
    {
        if (SUCCEEDED(_spMediaElem->get_playList(&spPlayList)))
        {
            if (spPlayList && SUCCEEDED(spPlayList->get_length(&lLength)))
            {
                return lLength;
            }
        }
    }
    return lLength;
}

HRESULT  
STDMETHODCALLTYPE 
CMediaBarPlayer::SetActiveTrack( long lIndex)
{
    CComPtr<ITIMEPlayList> spPlayList;
    HRESULT hr = S_OK;

    if (IsReady())
    {
        hr = _spMediaElem->get_playList(&spPlayList);
        ERROREXIT(hr);

        if (spPlayList)
        {
            VARIANT vIndex;
            VariantInit(&vIndex);

            vIndex.vt   = VT_I4;
            vIndex.lVal = lIndex;

            hr = spPlayList->put_activeTrack(vIndex) ;
            ERROREXIT(hr);
        }
        else
        {
            hr = S_FALSE;
        }
    }
    
done :   
    return hr ;
}

BOOL 
STDMETHODCALLTYPE 
CMediaBarPlayer::IsPausePossible()
{
    if (IsReady())
    {
        VARIANT_BOOL vbIsPausePossible = VARIANT_FALSE;

        if (SUCCEEDED(_spMediaElem->get_canPause(&vbIsPausePossible)))
        {
            return (vbIsPausePossible == VARIANT_TRUE) ? TRUE : FALSE;
        }
    }
    return FALSE;
}

BOOL 
STDMETHODCALLTYPE 
CMediaBarPlayer::IsSeekPossible()
{
   if (IsReady())
    {
        VARIANT_BOOL vbIsSeekPossible = VARIANT_FALSE;

        if (SUCCEEDED(_spMediaElem->get_canSeek(&vbIsSeekPossible)))
        {
            return (vbIsSeekPossible  == VARIANT_TRUE) ? TRUE : FALSE;
        }
    }
    return FALSE;
}

BOOL 
STDMETHODCALLTYPE 
CMediaBarPlayer::IsStreaming()
{
   if (IsReady())
    {
        VARIANT_BOOL vbIsStreaming = VARIANT_FALSE;

        if (SUCCEEDED(_spMediaElem2->get_isStreamed(&vbIsStreaming)))
        {
            return (vbIsStreaming  == VARIANT_TRUE) ? TRUE : FALSE;
        }
    }
    return FALSE;
}

BOOL 
STDMETHODCALLTYPE 
CMediaBarPlayer::IsPlayList()
{
    VARIANT_BOOL vbIsPlayList = VARIANT_FALSE;

    if (IsReady())
    {
        if (SUCCEEDED(_spMediaElem->get_hasPlayList(&vbIsPlayList)))
        {
            return (vbIsPlayList == VARIANT_TRUE) ? TRUE : FALSE;
        }
    }
    return FALSE;
}

BOOL 
STDMETHODCALLTYPE 
CMediaBarPlayer::IsSkippable()
{
    BOOL fRet = TRUE;
    // We need to check if the client has specified CLIENTSKIP="no" and respect that. This is to prevent 
    // the media bar from allowing the user to skip server-side stuff, which is a no-no. There are legal restrictions
    // related to this.
    CComDispatchDriverEx spWMP;
    if (_spMediaElem && SUCCEEDED(_spMediaElem->get_playerObject(&spWMP)) && spWMP)
    {
        CComVariant vtControls;
        HRESULT hr = spWMP.GetPropertyByName(L"controls", &vtControls);
        if (SUCCEEDED(hr))
        {
            CComDispatchDriverEx pwmpControls;
            pwmpControls = vtControls;

            // We're only checking for next (but not back), and assuming that NOSKIP will affect only "next".
            CComVariant vtNext = "Next";
            CComVariant vtEnabled;
            hr = pwmpControls.GetPropertyByName1(L"isAvailable", &vtNext, &vtEnabled);
            if (SUCCEEDED(hr) && (V_VT(&vtEnabled) == VT_BOOL))
            {
                fRet = (V_BOOL(&vtEnabled) == VARIANT_TRUE);
            }
        }
    }
    return fRet;
}



#ifdef SINKWMP
HRESULT CMediaBarPlayer::InitWMPSink()
{
    if (!_spWMP)
    {
        if (SUCCEEDED(_spMediaElem->get_playerObject(&_spWMP)))
        {
            CComPtr<IConnectionPointContainer> pcpc;
            
            HRESULT hr = _spWmp->QueryInterface(IID_TO_PPV(IConnectionPointContainer, &pcpc));
            if (SUCCEEDED(hr))
            {
                hr = pcpc->FindConnectionPoint(DIID__WMPOCXEvents, &_spWMPCP);
            }
            if (SUCCEEDED(hr))
            {
                hr = _spWMPCP->Advise(GetUnknown(), &_dwWMPCookie);
                if (FAILED(hr))
                {
                    m_pcpMediaEvents.Release();
                    m_dwMediaEventsCookie = 0;
                }
            }
        }
    }
    return S_OK;
}
#endif

HRESULT CMediaBarPlayer::GetProp(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* pvarResult, DISPPARAMS* pParams)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPPARAMS  params      = {NULL, NULL, 0, 0};

    if (!pParams)
    {
        pParams = &params;
    }

    if (!pDispatch)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pwzProp, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
            pParams, pvarResult, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}

HRESULT CMediaBarPlayer::CallMethod(IDispatch* pDispatch, OLECHAR* pwzMethod, VARIANT* pvarResult, VARIANT* pvarArgument1)
{
    DISPID      dispid      = NULL;
    HRESULT     hr          = S_OK;
    DISPPARAMS  params      = {pvarArgument1, NULL, 0, 0};

    if (NULL != pvarArgument1)
    {
        params.cArgs = 1;
    }

    if (!pDispatch)
    {
        hr = E_POINTER;
        goto done;
    }

    hr = pDispatch->GetIDsOfNames(IID_NULL, &pwzMethod, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
            &params, pvarResult, NULL, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

// For use with VC6
#pragma warning(4:4519)  //default template arguments are only allowed on a class template; ignored
#pragma warning(4:4242)  //'initializing' : conversion from 'unsigned int' to 'unsigned short', possible loss of data

// Extra error checking (catches false errors, but useful to run every so often)
#if 0
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4709)   // command operator w/o index expression
#endif

// Sundown: forcing value to bool
#pragma warning(disable:4800)

// This stuff must run on Win95
#define _WIN32_WINDOWS      0x0400

#ifndef WINVER
#define WINVER              0x0400
#endif

#define _OLEAUT32_       // get DECLSPEC_IMPORT stuff right, we are defing these
#define _BROWSEUI_       // define bruiapi as functions exported instead of imported
#define _WINMM_          // for DECLSPEC_IMPORT in mmsystem.h
#define _WINX32_         // get DECLSPEC_IMPORT stuff right for WININET API
#define _URLCACHEAPI     // get DECLSPEC_IMPORT stuff right for WININET CACHE API
#define _UXTHEME_        // get DECLSPEC_IMPORT stuff right for uxtheme

#ifndef STRICT
#define STRICT
#endif

// Map KERNEL32 unicode string functions to SHLWAPI
// This is needed way up here.
#define lstrcmpW    StrCmpW
#define lstrcmpiW   StrCmpIW
#define lstrcpyW    StrCpyW
#define lstrcpynW   StrCpyNW
#define lstrcatW    StrCatW


//
// Enable channel code for IE4 upgrades.
//
#define ENABLE_CHANNELS

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

/////////////////////////////////////////////////////////////////////////
//
//  ATL / OLE HACKHACK
//
//  Include <w95wraps.h> before anything else that messes with names.
//  Although everybody gets the wrong name, at least it's *consistently*
//  the wrong name, so everything links.
//
//  NOTE:  This means that while debugging you will see functions like
//  CWindowImplBase__DefWindowProcWrapW when you expected to see
//  CWindowImplBase__DefWindowProc.
//
#define POST_IE5_BETA // turn on post-split iedev stuff
#include <w95wraps.h>

#include <windows.h>

// VariantInit is a trivial function -- avoid using OleAut32, use intrinsic
// version of memset for a good size win
// (it's here so that atl (in stdafx.h) gets it too)
#define VariantInit(p) memset(p, 0, sizeof(*(p)))

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#define HLINK_NO_GUIDS
#include <hlink.h>
#include <wininet.h>
#include <winineti.h>
#include <urlmon.h>
#undef GetClassInfo
#include <shlobj.h>
#include <exdispid.h>
#undef GetClassInfo
#include <objidl.h>

#include <shlwapi.h>

//#include <shconv.h>   // replacement for atlconv.h if ATL is not included below

#if defined(__cplusplus) && !defined(DONT_USE_ATL)
// (stdafx.h must come before windowsx.h)
#include "stdafx.h"             // ATL header file for this component

// AtlMisc.h needs some defines from AtlApp.h
#ifndef __ATLAPP_H__
#include "AtlApp.h"
#endif

// include CString, CSize, CRect, CPoint, CFindFile from WTL10
// see %_NTROOT%\public\sdk\inc\wtl10
#include "AtlMisc.h"

// Include LBSTR::CString
#include <locbstr.h>

#endif

#include <windowsx.h>

#include <shellapi.h>

#include <crtfree.h>

#include <ole2ver.h>
#include <olectl.h>
#include <hliface.h>
#include <docobj.h>
#define DLL_IS_ROOTABLE
#include <ccstock.h>
#include <ccstock2.h>
#include <port32.h>

#include <shellp.h>
#include <ieguidp.h>
#include <isguids.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <dispex.h>     // IDispatchEx
#include <perhist.h>
#include <shobjidl.h>
#include <iepriv.h>


#include <help.h>
#include <krnlcmn.h>    // GetProcessDword

#include <multimon.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <urlhist.h>

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
#include <winineti.h>    // Cache APIs & structures
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>

#include <propset.h>        // If this ever becomes a problem, remove this once OLE adds an official header

#include <regapix.h>        // MAXIMUM_SUB_KEY_LENGTH, MAXIMUM_VALUE_NAME_LENGTH, MAXIMUM_DATA_LENGTH

#include <browseui.h>
#include <shdocvw.h>
#include <commctrl.h>
#include <shfusion.h>


//
// WARNING: Don't add private header files in shdocvw here randomly, which
//  will force us to re-compiling everything. Keep those private headers
//  out of priv.h
//  
// #include <iface.h>
#include "globals.h"
#include "runonnt.h"
#include "util.h"
#include "brutil.h"
#include "qistub.h"
#ifdef DEBUG
#include "dbutil.h"
#endif

// Include the automation definitions...
#include <exdisp.h>
#include <exdispid.h>
#include <brdispp.h>
#include <ocmm.h>
#include <mshtmhst.h>
#include <simpdata.h>
#include <htiface.h>
#include <objsafe.h>

#include "shui.h"
#define URLID_URLBASE           0
#define URLID_LOCATION          1
/////// URLID_FTPFOLDER         2 // Taken by a pre-release FTP Folder dll
#define URLID_PROTOCOL          3

// If stdshnor.bmp  or stdshhot.bmp are modifed, change this number to reflect the 
// new number of glyphs
#define NUMBER_SHELLGLYPHS      47
#define MAX_SHELLGLYPHINDEX     SHELLTOOLBAR_OFFSET + NUMBER_SHELLGLYPHS - 1

// Increment steps. For changing the with of the TB buttons. For localization
#define WIDTH_FACTOR            4

//
// Neutral ANSI/UNICODE types and macros... 'cus Chicago seems to lack them
//

#define DLL_IS_UNICODE         (sizeof(TCHAR) == sizeof(WCHAR))

//===========================================================================
// ITEMIDLIST
//===========================================================================

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

#define SEN_FIRST       (0U-550U)       // ;Internal



#ifdef __cplusplus

//
//  Pseudoclass for the variable-sized OLECMDTEXT structure.
//  You need to declare it as a class (and not a BYTE buffer that is
//  suitable cast) because BYTE buffers are not guaranteed to be aligned.
//
template <int n>
class OLECMDTEXTV : public OLECMDTEXT {
    WCHAR wszBuf[n-1];          // "-1" because OLECMDTEXT includes 1 wchar
};

extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */

void CInternetToolbar_CleanUp();
void CUserAssist_CleanUp(DWORD dwReason, LPVOID lpvReserved);
void CBrandBand_CleanUp();
STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes);


// Count of images Currently - 2 (Normal and Hot)
#define CIMLISTS                2


typedef struct tagIMLCACHE
{
    HIMAGELIST arhiml[CIMLISTS];
    HIMAGELIST arhimlPendingDelete[CIMLISTS];
    COLORREF cr3D;
    BOOL fSmallIcons;
    BOOL fUseClassicGlyphs;
} IMLCACHE;
    
void IMLCACHE_CleanUp(IMLCACHE * pimlCache, DWORD dwFlags);
#define IML_DELETEPENDING   0x01
#define IML_DESTROY         0x02

extern const ITEMIDLIST c_idlDesktop;
typedef const BYTE *LPCBYTE;

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

#define EnterModeless() AddRef()       // Used for selfref'ing
#define ExitModeless() Release()

//
// Debug helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

BOOL    IsStringContained(LPCTSTR pcszBigger, LPCTSTR pcszSuffix);

#endif // DEBUG

//
//  In DEBUG, send all our class registrations through a wrapper that
//  checks that the class is on our unregister-at-unload list.
//
#ifdef DEBUG
#undef  SHRegisterClass
#undef    RegisterClass
#define SHRegisterClass       SHRegisterClassD
#define   RegisterClass         RegisterClassD

STDAPI_(BOOL) SHRegisterClassD(CONST WNDCLASS* pwc);
STDAPI_(ATOM)   RegisterClassD(CONST WNDCLASS* pwc);
#ifdef UNICODE
#define RealSHRegisterClass   SHRegisterClassW
#define   RealRegisterClass     RegisterClassWrapW
#else
#define RealSHRegisterClass   SHRegisterClassA
#define   RealRegisterClass     RegisterClassA
#endif // UNICODE
#endif // DEBUG

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow sends interthreadmessages,
//  which is not obvious.
//
#ifdef DEBUG
#undef  FindWindow
#undef  FindWindowEx
#define FindWindow              FindWindowD
#define FindWindowEx            FindWindowExD

STDAPI_(HWND) FindWindowD  (LPCTSTR lpClassName, LPCTSTR lpWindowName);
STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName);
#ifdef UNICODE
#define RealFindWindowEx        FindWindowExWrapW
#else
#define RealFindWindowEx        FindWindowExA
#endif // UNICODE
#endif // DEBUG


//
// Trace/dump/break flags specific to shell32\.
//   (Standard flags defined in shellp.h)
//

// Break flags
#define BF_ONDUMPMENU       0x10000000      // Stop after dumping menus
#define BF_ONLOADED         0x00000010      // Stop when loaded

// Trace flags
#define TF_UEM              0x00000010      // UEM stuff
#define TF_AUTOCOMPLETE     0x00000100      // AutoCompletion

// The following aren't really valid until the ccshell.ini file is updated.
#define TF_SHDLIFE          0x00000200
#define TF_SHDREF           0x00000400
#define TF_SHDPERF          0x00000800
#define TF_SHDAUTO          0x00001000
#define TF_MENUBAND         0x00002000      // Menu band messages
#define TF_SITEMAP          0x00004000      // Sitemap messages
#define TF_SHDTHREAD        0x00008000      // Thread management
#define TF_SHDCONTROL       0x00010000      // ActiveX Control
#define TF_SHDAPPHACK       0x00020000      // Hack for app-bug
#define TF_SHDBINDING       0x00040000      // Moniker binding
#define TF_SHDPROGRESS      0x00080000      // Download progress
#define TF_SHDNAVIGATE      0x00100000      // Navigation
#define TF_SHDUIACTIVATE    0x00200000      // UI-Activation/Deactivation
#define TF_OCCONTROL        0x00400000      // OC Hosting Window Control
#define TF_PIDLWRAP         0x00800000      // Pidl / Protocol wrapping
#define TF_REGCHECK         0x00000100      // Registry check stuff
#define TF_COCREATE         0x02000000      // WinList/CoCreate(Browser only)
#define TF_URLNAMESPACE     0x04000000      // URL Name Space
#define TF_BAND             0x08000000      // Bands (ISF Band, etc)
#define TF_TRAVELLOG        0x10000000      // TravelLog and Navigation stack 
#define TF_DDE              0x20000000      // PMDDE traces
#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2

#define TF_ACCESSIBILITY    TF_CUSTOM2      // accessibility messages: tabstop handling, get/lose tab focus, accelerators



//There is some thinking that says this should be removed, but why risk the regression
#define TF_OBJECTCACHE      TF_TRAVELLOG

// (Re-use TF_CUSTOM1 and TF_CUSTOM2 by defining a TF_ value in your
// local file to one of these values while you have the file checked 
// out.)

// Dump flags
#define DF_SITEMAP          0x00000001      // Sitemap
#define DF_MEMLEAK          0x00000002      // Dump leaked memory at the end
#define DF_DEBUGQI          0x00000004      // Alloc stub object for each QI
#define DF_DEBUGQINOREF     0x00000008      // No AddRef/Release QI stub
#define DF_DEBUGMENU        0x00000010      // Dump menu handles
#define DF_URL              0x00000020      // Display URLs
#define DF_AUTOCOMPLETE     0x00000040      // AutoCompletion
#define DF_DELAYLOADDLL     0x00000080      // Delay-loaded DLL
#define DF_SHELLLIST        0x00000100      // CShellList contents
#define DF_INTSHCUT         0x00000200      // Internet shortcut structs
#define DF_URLPROP          0x00000400      // URL properties
#define DF_MSGHOOK          0x00000800      // Menu MessageFilter 
#define DF_GETMSGHOOK       0x00001000      // GetMessageFilter 
#define DF_TRANSACCELIO     0x00002000      // GetMessageFilter 

// Prototype flags
#define PF_USERMENUS        0x00000001      // Use traditional USER menu bar
#define PF_NEWFAVMENU       0x00000002      // New favorites menu
#define PF_NOBROWSEUI       0x00001000          // don't use browseui
#define PF_FORCEANSI        0x00002000      // Assume that Shell32 is ANSI

// global object array - used for class factory, auto registration, type libraries, oc information
//

#include "cfdefs.h"

#define OIF_ALLOWAGGREGATION  0x0001
#define OIF_DONTIECREATE      0x0002

//
// global variables
//
//
// Function prototypes
//
STDAPI CMyHlinkSrc_CreateInstance(REFCLSID rclsid, DWORD grfContext, REFIID riid, LPVOID* ppvOut);
STDAPI CMyHlinkSrc_OleCreate(CLSID rclsid, REFIID riid, DWORD renderOpt,
                             FORMATETC* pFormatEtc, IOleClientSite* pclient,
                             IStorage* pstg, LPVOID* ppvOut);

STDAPI CMyHlinkSrc_OleLoad(IStorage* pstg, REFIID riid, IOleClientSite* pclient, LPVOID* ppvOut);

HRESULT SHRegisterTypeLib(void);
VOID SHCheckRegistry(void);

STDAPI_(IBindCtx *) BCW_Create(IBindCtx* pibc);

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);


#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH
#define MAX_NAME_STRING     INTERNET_MAX_PATH_LENGTH
#define MAX_BROWSER_WINDOW_TITLE   128

#define REG_SUBKEY_FAVORITESA            "\\MenuOrder\\Favorites"
#define REG_SUBKEY_FAVORITES             TEXT(REG_SUBKEY_FAVORITESA)

//
//  Class names
//
#define c_szExploreClass TEXT("ExploreWClass")
#define c_szIExploreClass TEXT("IEFrame")
#ifdef IE3CLASSNAME
#define c_szCabinetClass TEXT("IEFrame")
#else
#define c_szCabinetClass TEXT("CabinetWClass")
#endif
#define c_szAutoSuggestClass TEXT("Auto-Suggest Dropdown")

// Stack allocated BSTR (to avoid calling SysAllocString)
typedef struct _SA_BSTR {
    ULONG   cb;
    WCHAR   wsz[MAX_URL_STRING];
} SA_BSTR;

// A "fake" variants for use on the stack - usable for [in] parameters only!!!
typedef struct _SA_BSTRGUID {
    UINT  cb;
    WCHAR wsz[39];
} SA_BSTRGUID;
#define InitFakeBSTR(pSA_BSTR, guid) SHStringFromGUIDW((guid), (pSA_BSTR)->wsz, ARRAYSIZE((pSA_BSTR)->wsz)), (pSA_BSTR)->cb = (38*sizeof(WCHAR))

STDAPI _SetStdLocation(LPTSTR szPath, UINT id);

STDAPI CDocObjectHost_AddPages(LPARAM that, HWND hwnd, HINSTANCE hinst, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
STDAPI_(void) CDocObjectHost_GetCurrentPage(LPARAM that, LPTSTR szBuf, UINT cchMax);

//
// a couple bogus pidls
//
#define PIDL_LOCALHISTORY ((LPCITEMIDLIST)-1)
#define PIDL_NOTHING      ((LPCITEMIDLIST)-2)

#define CALLWNDPROC WNDPROC

// Smartly delay load OLEAUT32
HRESULT VariantClearLazy(VARIANTARG *pvarg);
#define VariantClear VariantClearLazy
WINOLEAUTAPI VariantCopyLazy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc);
#define VariantCopy VariantCopyLazy

#ifdef UNICODE
#define StrToOleStrN(wsz, cchWsz, pstr, cchPstr) StrCpyNW(wsz, pstr, cchWsz)
#define IsDBCSLeadByte(x) ((x), FALSE)
#else
#pragma message("need to thunk StrToOleStrN")
#define IsDBCSLeadByte(x) IsDBCSLeadByteEx(CP_ACP,x)
#endif

#define ILIsEqual(p1, p2)   IEILIsEqual(p1, p2, FALSE)


#ifdef __cplusplus
//
// C++ modules only
//
#include <shstr.h>

extern "C" const ITEMIDLIST s_idlNULL;

// helper routines for view state stuff

IStream *GetDesktopRegStream(DWORD grfMode, LPCTSTR pszName, LPCTSTR pszStreams);
IStream *GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCTSTR pszName, LPCTSTR pszStreamMRU, LPCTSTR pszStreams);

// StreamHeader Signatures
#define STREAMHEADER_SIG_CADDRESSBAND        0xF432E001
#define STREAMHEADER_SIG_CADDRESSEDITBOX     0x24F92A92

#define CoCreateInstance IECreateInstance
HRESULT IECreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);

#endif

extern HRESULT LoadHistoryShellFolder(IUnknown *punkSFHistory, IHistSFPrivate **pphsfHistory); // from urlhist.cpp
extern void CUrlHistory_CleanUp();

#ifdef UNIX
UINT GetCurColorRes(void);
EXTERN_C HRESULT CoCreateInternetExplorer( REFIID iid, DWORD dwClsContext, void **ppvunk );
// Although, UNIX is not exactly right here, because i386
// doesn't require any alignment, but that holds true for
// all the UNIXs we plan IE for.
#define ALIGN4(cb)         (((unsigned)(cb) % 4)? (unsigned)(cb)+(4-((unsigned)(cb)%4)) : (unsigned)(cb))
#define ALIGN4_IF_UNIX(cb) ALIGN4(cb)
#else
#define ALIGN4_IF_UNIX(cb)
#endif


// Dummy union macros for code compilation on platforms not
// supporting nameless stuct/union

#ifdef NONAMELESSUNION
#define DUMMYUNION_MEMBER(member)   DUMMYUNIONNAME.##member
#define DUMMYUNION2_MEMBER(member)  DUMMYUNIONNAME2.##member
#define DUMMYUNION3_MEMBER(member)  DUMMYUNIONNAME3.##member
#define DUMMYUNION4_MEMBER(member)  DUMMYUNIONNAME4.##member
#define DUMMYUNION5_MEMBER(member)  DUMMYUNIONNAME5.##member
#else
#define DUMMYUNION_MEMBER(member)    member
#define DUMMYUNION2_MEMBER(member)   member
#define DUMMYUNION3_MEMBER(member)   member
#define DUMMYUNION4_MEMBER(member)   member
#define DUMMYUNION5_MEMBER(member)   member
#endif

#undef COMCTL32_VERSION
#define COMCTL32_VERSION 5          // Browseui is stuck with Version 5 comctl32 because it has to run downlevel.


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#undef ExpandEnvironmentStrings
#define ExpandEnvironmentStrings #error "Use SHExpandEnvironmentStrings instead"

// Uncomment the following define to enable ATL components to be built in 
// browseui.dll. You'll also have to perform the following steps:
// 1. modify the type library in brdispp.idl (Note that this is for private components only)
// 2. modify selfreg.inx to register your components
// 3. copy atl.cpp and atl.h from shdocvw, and modify to return the appropriate classes
// 4. add atl.* to the makefile
// #define ATL_ENABLED

#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\regkeys.h ===
#define  SZ_REGKEY_IEXPLOREA     "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE"
#define  SZ_REGKEY_IEXPLORE      TEXT(SZ_REGKEY_IEXPLOREA)
#define  c_szIexploreKey         SZ_REGKEY_IEXPLORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\player.h ===
// MediaBarPlayer.h

#pragma once

#ifndef __MEDIABARPLAYER_H_
#define __MEDIABARPLAYER_H_

#include "exdisp.h"
#ifdef SINKWMP
#include "wmp\wmp_i.c"
#include "wmp\wmp.h"
#include "wmp\wmpids.h"
#endif

#define MEDIACOMPLETE   -1
#define MEDIA_TRACK_FINISHED    -2
#define TRACK_CHANGE    -3

////////////////////////////////////////////////////////////////
// IMediaBar

// {3AE35551-8362-49fc-BC4F-F5715BF4291E}
static const IID IID_IMediaBar = 
{ 0x3ae35551, 0x8362, 0x49fc, { 0xbc, 0x4f, 0xf5, 0x71, 0x5b, 0xf4, 0x29, 0x1e } };

interface IMediaBar : public IUnknown
{
public:
    STDMETHOD(Notify)(long lReason) = 0;
    STDMETHOD(OnMediaError)(int iErrCode) = 0;
};


HRESULT CMediaBarPlayer_CreateInstance(REFIID riid, void ** ppvObj); 



/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  DANGER !!!  
//
// ISSUE: dilipk: till I find a way to include mstime.h without compile errors, explicitly declaring the interfaces
//                This is DANGEROUS because changes in mstime.idl could break media bar
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// fwd declarations (See end of file for definitions)

interface IMediaBarPlayer;
interface ITIMEElement;
interface ITIMEBodyElement;
interface ITIMEMediaElement;
interface ITIMEState;
interface ITIMEElementCollection;
interface ITIMEActiveElementCollection;
interface ITIMEPlayList;
interface ITIMEPlayItem;
interface ITIMEMediaNative;

EXTERN_C const IID IID_ITIMEMediaElement2;

typedef enum _TimeState
{   
    TS_Inactive = 0,
    TS_Active   = 1,
    TS_Cueing   = 2,
    TS_Seeking  = 3,
    TS_Holding  = 4
} TimeState;

////////////////////////////////////////////////////////////////////////////
// MediaBarPlayer 

// {f810fb9c-5587-47f1-a7cb-838cc4ca979f}
DEFINE_GUID(CLSID_MediaBarPlayer, 0xf810fb9c, 0x5587, 0x47f1, 0xa7, 0xcb, 0x83, 0x8c, 0xc4, 0xca, 0x97, 0x9f);

// {0c84b786-af32-47bc-a904-d8ebae3d5f96}
static const IID IID_IMediaBarPlayer = 
{ 0x0c84b786, 0xaf32, 0x47bc, { 0xa9, 0x04, 0xd8, 0xeb, 0xae, 0x3d, 0x5f, 0x96 } };

typedef enum _ProgressType
{
    PT_Download = 0,
    PT_Buffering = 1,
    PT_None = 2
} ProgressType;

typedef enum _TrackType
{
    TT_Next = 0,
    TT_Prev = 1,
    TT_None = 2
} TrackType;


interface 
__declspec(uuid("0c84b786-af32-47bc-a904-d8ebae3d5f96")) 
IMediaBarPlayer : public IUnknown
{
public:
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_url( 
        /* [retval][out] */ BSTR __RPC_FAR *url) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_url( 
        /* [in] */ BSTR url) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_player( 
        /* [retval][out] */ BSTR __RPC_FAR *player) = 0;

    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_type( 
    /* [in] */ BSTR url) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_volume( 
        /* [retval][out] */ double __RPC_FAR *volume) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_volume( 
        /* [in] */ double volume) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mute( 
        /* [retval][out] */ BOOL __RPC_FAR *mute) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_mute( 
        /* [in] */ BOOL mute) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mediaElement( 
        /* [retval][out] */ ITIMEMediaElement __RPC_FAR *__RPC_FAR *ppMediaElement) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Init( 
        HWND hWnd,
        IMediaBar __RPC_FAR *pMediaBar) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DeInit( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Play( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Seek( 
        double Progress) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Resize(
        LONG* height, LONG* width, BOOL fClampMaxSizeToNaturalSize = TRUE) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetVideoHwnd(
        HWND * pHwnd) = 0;

    virtual double STDMETHODCALLTYPE GetTrackTime( void ) = 0;
    
    virtual double STDMETHODCALLTYPE GetTrackLength( void ) = 0;

    virtual double STDMETHODCALLTYPE GetTrackProgress( void ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBufProgress( double * pdblProg, ProgressType * ppt) = 0;

    virtual VARIANT_BOOL STDMETHODCALLTYPE isMuted( void ) = 0;

    virtual VARIANT_BOOL STDMETHODCALLTYPE isPaused( void ) = 0;

    virtual VARIANT_BOOL STDMETHODCALLTYPE isStopped( void ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Next( void ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Prev( void ) = 0;

    virtual LONG_PTR STDMETHODCALLTYPE GetPlayListItemCount( void ) = 0;

    virtual LONG_PTR STDMETHODCALLTYPE GetPlayListItemIndex( void ) = 0;

    virtual HRESULT  STDMETHODCALLTYPE SetActiveTrack( long lIndex) = 0;

    virtual BOOL STDMETHODCALLTYPE IsPausePossible() = 0;

    virtual BOOL STDMETHODCALLTYPE IsSeekPossible()  = 0;

    virtual BOOL STDMETHODCALLTYPE IsStreaming()  = 0;

    virtual BOOL STDMETHODCALLTYPE IsPlayList( void ) = 0;

    virtual BOOL STDMETHODCALLTYPE IsSkippable() = 0;
};


//////////////////////////////////////////////////////////////////////////////////////
// ITIMEElement

interface     ITIMEElement : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_accelerate( 
            /* [retval][out] */ VARIANT *__MIDL_0010) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_accelerate( 
            /* [in] */ VARIANT __MIDL_0011) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_autoReverse( 
            /* [retval][out] */ VARIANT *__MIDL_0012) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_autoReverse( 
            /* [in] */ VARIANT __MIDL_0013) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_begin( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_begin( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_decelerate( 
            /* [retval][out] */ VARIANT *__MIDL_0014) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_decelerate( 
            /* [in] */ VARIANT __MIDL_0015) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_dur( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_dur( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_end( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_end( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_fill( 
            /* [retval][out] */ BSTR *f) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_fill( 
            /* [in] */ BSTR f) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mute( 
            /* [retval][out] */ VARIANT *b) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_mute( 
            /* [in] */ VARIANT b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_repeatCount( 
            /* [retval][out] */ VARIANT *c) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_repeatCount( 
            /* [in] */ VARIANT c) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_repeatDur( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_repeatDur( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_restart( 
            /* [retval][out] */ BSTR *__MIDL_0016) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_restart( 
            /* [in] */ BSTR __MIDL_0017) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_speed( 
            /* [retval][out] */ VARIANT *speed) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_speed( 
            /* [in] */ VARIANT speed) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_syncBehavior( 
            /* [retval][out] */ BSTR *sync) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_syncBehavior( 
            /* [in] */ BSTR sync) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_syncTolerance( 
            /* [retval][out] */ VARIANT *tol) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_syncTolerance( 
            /* [in] */ VARIANT tol) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_syncMaster( 
            /* [retval][out] */ VARIANT *b) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_syncMaster( 
            /* [in] */ VARIANT b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeAction( 
            /* [retval][out] */ BSTR *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_timeAction( 
            /* [in] */ BSTR time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeContainer( 
            /* [retval][out] */ BSTR *__MIDL_0018) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_volume( 
            /* [retval][out] */ VARIANT *val) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_volume( 
            /* [in] */ VARIANT val) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_currTimeState( 
            /* [retval][out] */ ITIMEState **TimeState) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeAll( 
            /* [retval][out] */ ITIMEElementCollection **allColl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeChildren( 
            /* [retval][out] */ ITIMEElementCollection **childColl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_timeParent( 
            /* [retval][out] */ ITIMEElement **parent) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isPaused( 
            /* [retval][out] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE beginElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE beginElementAt( 
            /* [in] */ double parentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE endElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE endElementAt( 
            /* [in] */ double parentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE pauseElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE resetElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE resumeElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE seekActiveTime( 
            /* [in] */ double activeTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE seekSegmentTime( 
            /* [in] */ double segmentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE seekTo( 
            /* [in] */ LONG repeatCount,
            /* [in] */ double segmentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE documentTimeToParentTime( 
            /* [in] */ double documentTime,
            /* [retval][out] */ double *parentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE parentTimeToDocumentTime( 
            /* [in] */ double parentTime,
            /* [retval][out] */ double *documentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE parentTimeToActiveTime( 
            /* [in] */ double parentTime,
            /* [retval][out] */ double *activeTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE activeTimeToParentTime( 
            /* [in] */ double activeTime,
            /* [retval][out] */ double *parentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE activeTimeToSegmentTime( 
            /* [in] */ double activeTime,
            /* [retval][out] */ double *segmentTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE segmentTimeToActiveTime( 
            /* [in] */ double segmentTime,
            /* [retval][out] */ double *activeTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE segmentTimeToSimpleTime( 
            /* [in] */ double segmentTime,
            /* [retval][out] */ double *simpleTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE simpleTimeToSegmentTime( 
            /* [in] */ double simpleTime,
            /* [retval][out] */ double *segmentTime) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_endSync( 
            /* [retval][out] */ BSTR *es) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_endSync( 
            /* [in] */ BSTR es) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_activeElements( 
            /* [retval][out] */ ITIMEActiveElementCollection **activeColl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasMedia( 
            /* [out][retval] */ VARIANT_BOOL *flag) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE nextElement( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE prevElement( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_updateMode( 
            /* [retval][out] */ BSTR *updateMode) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_updateMode( 
            /* [in] */ BSTR updateMode) = 0;
        
    };


//////////////////////////////////////////////////////////////////////////////////////
// ITIMEMediaElement

extern "C" const IID IID_ITIMEMediaElement;

interface ITIMEMediaElement : public ITIMEElement
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_clipBegin( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_clipBegin( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_clipEnd( 
            /* [retval][out] */ VARIANT *time) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_clipEnd( 
            /* [in] */ VARIANT time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_player( 
            /* [retval][out] */ VARIANT *id) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_player( 
            /* [in] */ VARIANT id) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_src( 
            /* [retval][out] */ VARIANT *url) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_src( 
            /* [in] */ VARIANT url) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ VARIANT *mimetype) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_type( 
            /* [in] */ VARIANT mimetype) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_abstract( 
            /* [retval][out] */ BSTR *abs) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_author( 
            /* [retval][out] */ BSTR *auth) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_copyright( 
            /* [retval][out] */ BSTR *cpyrght) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasAudio( 
            /* [out][retval] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasVisual( 
            /* [out][retval] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mediaDur( 
            /* [retval][out] */ double *dur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mediaHeight( 
            /* [retval][out] */ long *height) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mediaWidth( 
            /* [retval][out] */ long *width) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_playerObject( 
            /* [retval][out] */ IDispatch **ppDisp) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_playList( 
            /* [retval][out] */ ITIMEPlayList **pPlayList) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_rating( 
            /* [retval][out] */ BSTR *rate) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_title( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasPlayList( 
            /* [retval][out] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_canPause( 
            /* [out][retval] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_canSeek( 
            /* [out][retval] */ VARIANT_BOOL *b) = 0;
        
    };


//////////////////////////////////////////////////////////////////////////////////////
// ITIMEMediaElement2

    interface ITIMEMediaElement2 : public ITIMEMediaElement
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_earliestMediaTime( 
            /* [retval][out] */ VARIANT *earliestMediaTime) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_latestMediaTime( 
            /* [retval][out] */ VARIANT *latestMediaTime) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_minBufferedMediaDur( 
            /* [retval][out] */ VARIANT *minBufferedMediaDur) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_minBufferedMediaDur( 
            /* [in] */ VARIANT minBufferedMediaDur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_downloadTotal( 
            /* [retval][out] */ VARIANT *downloadTotal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_downloadCurrent( 
            /* [retval][out] */ VARIANT *downloadCurrent) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isStreamed( 
            /* [retval][out] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bufferingProgress( 
            /* [retval][out] */ VARIANT *bufferingProgress) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_hasDownloadProgress( 
            /* [retval][out] */ VARIANT_BOOL *b) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_downloadProgress( 
            /* [retval][out] */ VARIANT *downloadProgress) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [retval][out] */ BSTR *mimeType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE seekToFrame( 
            /* [in] */ long frameNr) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE decodeMimeType( 
            /* [in] */ TCHAR *header,
            /* [in] */ long headerSize,
            /* [out] */ BSTR *mimeType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_currentFrame( 
            /* [retval][out] */ long *currFrame) = 0;
        
    };

    
//////////////////////////////////////////////////////////////////////////////////////
// ITIMEState

    interface ITIMEState : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_activeDur( 
            /* [out][retval] */ double *dur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_activeTime( 
            /* [out][retval] */ double *time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isActive( 
            /* [out][retval] */ VARIANT_BOOL *active) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isOn( 
            /* [out][retval] */ VARIANT_BOOL *on) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isPaused( 
            /* [out][retval] */ VARIANT_BOOL *paused) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_isMuted( 
            /* [out][retval] */ VARIANT_BOOL *muted) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_parentTimeBegin( 
            /* [out][retval] */ double *time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_parentTimeEnd( 
            /* [out][retval] */ double *time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_progress( 
            /* [out][retval] */ double *progress) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_repeatCount( 
            /* [out][retval] */ LONG *count) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_segmentDur( 
            /* [out][retval] */ double *dur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_segmentTime( 
            /* [out][retval] */ double *time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_simpleDur( 
            /* [out][retval] */ double *dur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_simpleTime( 
            /* [out][retval] */ double *time) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_speed( 
            /* [out][retval] */ float *speed) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_state( 
            /* [out][retval] */ TimeState *timeState) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_stateString( 
            /* [out][retval] */ BSTR *state) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_volume( 
            /* [out][retval] */ float *vol) = 0;
        
    };

//////////////////////////////////////////////////////////////////////////////////////
// ITIMEBodyElement

extern "C" const IID IID_ITIMEBodyElement;

interface ITIMEBodyElement : public ITIMEElement
{
public:
};

//////////////////////////////////////////////////////////////////////////////////////
// ITIMEPlayList

    interface ITIMEPlayList : public IDispatch
    {
    public:
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_activeTrack( 
            /* [in] */ VARIANT vTrack) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_activeTrack( 
            /* [retval][out] */ ITIMEPlayItem **pPlayItem) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_dur( 
            double *dur) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in][defaultvalue] */ VARIANT varIndex,
            /* [retval][out] */ ITIMEPlayItem **pPlayItem) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ long *p) = 0;
        
        virtual /* [hidden][restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [retval][out] */ IUnknown **p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE nextTrack( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE prevTrack( void) = 0;
        
    };

//////////////////////////////////////////////////////////////////////////////////////
// ITIMEPlayItem

    interface ITIMEPlayItem : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_abstract( 
            /* [retval][out] */ BSTR *abs) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_author( 
            /* [retval][out] */ BSTR *auth) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_copyright( 
            /* [retval][out] */ BSTR *cpyrght) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_dur( 
            /* [retval][out] */ double *dur) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_index( 
            /* [retval][out] */ long *index) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_rating( 
            /* [retval][out] */ BSTR *rate) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_src( 
            /* [retval][out] */ BSTR *src) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_title( 
            /* [retval][out] */ BSTR *title) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setActive( void) = 0;
        
    };

//////////////////////////////////////////////////////////////////////////////////////
// ITIMEMediaNative
    const GUID IID_ITIMEMediaNative = {0x3e3535c0,0x445b,0x4ef4,{0x8a,0x38,0x4d,0x37,0x9c,0xbc,0x98,0x28}};

    interface ITIMEMediaNative : public IUnknown
    {
    public:
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE seekActiveTrack( 
            /* [in] */ double dblSeekTime) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_activeTrackTime( 
            /* [retval][out] */ double *dblActiveTrackTime) = 0;
        
    };

////////////////////////////////////////////////////////////////
// CMediaBarPlayer

class
__declspec(uuid("210e94fa-5e4e-4580-aecb-f01abbf73de6")) 
CMediaBarPlayer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IMediaBarPlayer,
    public IPropertyNotifySink,
    public CComCoClass<CMediaBarPlayer, &CLSID_MediaBarPlayer>,
//    public IDispatchImpl<_WMPOCXEvents, &DIID__WMPOCXEvents, (CONST)&LIBID_WMPOCX>,
    public IDispatchImpl<DWebBrowserEvents2, &DIID_DWebBrowserEvents2, &LIBID_SHDocVw>
{
public:
    CMediaBarPlayer();
    virtual ~CMediaBarPlayer();

    BEGIN_COM_MAP(CMediaBarPlayer)
        COM_INTERFACE_ENTRY(IMediaBarPlayer)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(DIID_DWebBrowserEvents2, IDispatch)
#ifdef SINKWMP
        COM_INTERFACE_ENTRY_IID(DIID__WMPOCXEvents, IDispatch)
#endif
    END_COM_MAP();

    /*
    DECLARE_REGISTRY(CLSID_MediaBarPlayer,
                     LIBID __T(".MediaBarPlayer.1"),
                     LIBID __T(".MediaBarPlayer"),
                     0,
                     THREADFLAGS_BOTH);
    */

    ////////////////////////////////////////////////////////////////
    // IMediaBarPlayer 

    STDMETHOD(put_url)(BSTR bstrUrl);
    STDMETHOD(get_url)(BSTR * pbstrUrl);

    STDMETHOD(get_player)(BSTR * pbstrPlayer);

    STDMETHOD(put_type)(BSTR bstrType);

    STDMETHOD(put_volume)(double dblVolume);
    STDMETHOD(get_volume)(double * pdblVolume);

    STDMETHOD(put_mute)(BOOL bMute);
    STDMETHOD(get_mute)(BOOL * pbMute);

    STDMETHOD(get_mediaElement)(ITIMEMediaElement ** ppMediaElem);

    STDMETHOD(Init)(HWND hwnd, IMediaBar * pMediaBar);

    STDMETHOD(DeInit)();

    STDMETHOD(Play)();

    STDMETHOD(Stop)();

    STDMETHOD(Pause)();

    STDMETHOD(Resume)();

    STDMETHOD(Seek)(double dblProgress);

    STDMETHOD(Resize)(LONG* lHeight, LONG* lWidth, BOOL fClampMaxSizeToNaturalSize = TRUE);

    STDMETHOD(GetVideoHwnd)(HWND * pHwnd);

    double STDMETHODCALLTYPE GetTrackTime();
    
    double STDMETHODCALLTYPE GetTrackLength();

    double STDMETHODCALLTYPE GetTrackProgress( void ) ;

    STDMETHOD(GetBufProgress)(double * pdblProg, ProgressType * ppt);

    VARIANT_BOOL STDMETHODCALLTYPE isMuted();

    VARIANT_BOOL STDMETHODCALLTYPE isPaused();

    VARIANT_BOOL STDMETHODCALLTYPE isStopped();

    STDMETHOD(Next)();

    STDMETHOD(Prev)();

    LONG_PTR STDMETHODCALLTYPE GetPlayListItemCount( void );

    LONG_PTR STDMETHODCALLTYPE GetPlayListItemIndex( void );

    HRESULT  STDMETHODCALLTYPE SetActiveTrack(long lIndex);

    BOOL STDMETHODCALLTYPE IsPausePossible() ;

    BOOL STDMETHODCALLTYPE IsSeekPossible()  ;

    BOOL STDMETHODCALLTYPE IsStreaming() ;
        
    BOOL STDMETHODCALLTYPE IsPlayList( void );

    BOOL STDMETHODCALLTYPE IsSkippable();

    ////////////////////////////////////////////////////////////////
    // IDispatch

    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS  *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO *pExcepInfo,
        /* [out] */ UINT *puArgErr);

    ////////////////////////////////////////////////////////////////
    // IPropertyNotifySink

    STDMETHOD(OnChanged)(DISPID dispid);
    STDMETHOD(OnRequestEdit)(DISPID dispid) { return S_OK; }

private:
    // *** Methods ***
    enum INVOKETYPE {IT_GET, IT_PUT, IT_METHOD};

    STDMETHOD(_CreateHost)(HWND hWnd);
    STDMETHOD(_DestroyHost)();

    STDMETHOD(_GetDocumentDispatch)(IDispatch ** ppDocDisp);

    STDMETHOD(_GetElementDispatch)(LPWSTR pstrElem, IDispatchEx ** ppDispEx);
    STDMETHOD(_GetMediaElement)(ITIMEMediaElement ** ppMediaElem);
    STDMETHOD(_GetBodyElement)(ITIMEBodyElement ** ppBodyaElem);
    STDMETHOD(_InvokeDocument)(LPWSTR pstrElem, INVOKETYPE it, LPWSTR pstrName, VARIANT * pvarArg);

    STDMETHOD(_OnDocumentComplete)();
    STDMETHOD(_OnMediaComplete)();
    STDMETHOD(_OnTrackChange)();
    STDMETHOD(_OnEnd)();
    STDMETHOD(_OnMediaError)(int iErrCode);

    STDMETHOD(_InitEventSink)();
    STDMETHOD(_DeInitEventSink)();

    STDMETHOD(_AttachPlayerEvents)(BOOL fAttach);

    STDMETHOD(_HookPropNotifies)();
    STDMETHOD(_UnhookPropNotifies)();

    STDMETHOD(_Navigate)(BSTR bstrUrl);

    STDMETHOD(_SetTrack)(TrackType tt);

    // ISSUE: dilipk: optimize this to check only the last reference stored since that would validate all others
    bool IsReady() { return     (NULL != _spMediaElem.p)
                            &&  (NULL != _spMediaElem2.p)
                            &&  (NULL != _spBrowser.p) 
                            &&  (NULL != _spBodyElem.p) 
                            &&  (NULL != _spPlayerHTMLElem2.p); }

    // *** Data ***
    CComPtr<IWebBrowser2>           _spBrowser;
    CComPtr<ITIMEMediaElement>      _spMediaElem;
    CComPtr<ITIMEMediaElement2>     _spMediaElem2;
    CComPtr<ITIMEBodyElement>       _spBodyElem;
    CComPtr<IHTMLElement2>          _spPlayerHTMLElem2;

    IMediaBar *                     _pMediaBar;

    DWORD                           _dwDocumentEventConPtCookie;
    DWORD                           _dwCookiePropNotify;
    CComPtr<IConnectionPoint>       _spDocConPt;
    CComPtr<IConnectionPoint>       _spPropNotifyCP;
    CComBSTR                        _sbstrType;
    CComBSTR                        _sbstrUrl;
    HWND                            _hwnd;

#ifdef SINKWMP
    CComPtr<IDispatch>              _spWMP;
    CComPtr<IConnectionPoint>        _spWMPCP;
    DWORD                         _dwWMPCookie;
    HRESULT                        InitWMPSink();
#endif

    HRESULT GetProp(IDispatch* pDispatch, OLECHAR* pwzProp, VARIANT* pvarResult, DISPPARAMS* pParams = NULL);
    HRESULT CallMethod(IDispatch* pDispatch, OLECHAR* pwzMethod, VARIANT* pvarResult = NULL, VARIANT* pvarArgument1 = NULL);
};

#endif // __MEDIABARPLAYER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\proxy.cpp ===
#include "priv.h"
#include "hnfblock.h"
#include <trayp.h>
#include "desktop.h"
#include "shbrows2.h"
#include "resource.h"
#include "onetree.h"
#include "apithk.h"
#include <regitemp.h>

#include "mluisupp.h"

//forward declaration of private function
BOOL  _private_ParseField(LPCTSTR pszData, int n, LPTSTR szBuf, int iBufLen);


BOOL _RootsEqual(HANDLE hCR, DWORD dwProcId, LPCITEMIDLIST pidlRoot)
{
    BOOL bSame = FALSE;
    if (hCR)
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)SHLockShared(hCR, dwProcId);
        if (pidl)
        {
            bSame = ILIsEqualRoot(pidlRoot, pidl);
            SHUnlockShared(pidl);
        }
    }
    return bSame;
}


// NOTE: this export is new to IE5, so it can move to browseui
// along with the rest of this proxy desktop code
BOOL SHOnCWMCommandLine(LPARAM lParam)
{
    HNFBLOCK hnf = (HNFBLOCK)lParam;
    IETHREADPARAM *piei = ConvertHNFBLOCKtoNFI(hnf);
    if (piei)
        return SHOpenFolderWindow(piei);

    // bad params passed, normal failure case
    return FALSE;
}


//---------------------------------------------------------------------------
// This proxy desktop window procedure is used when we are run and we
// are not the shell.  We are a hidden window which will simply respond
// to messages like the ones that create threads for folder windows.
// This window procedure will close after all of the open windows
// associated with it go away.
class CProxyDesktop
{
private:
    static LRESULT CALLBACK ProxyWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    friend CProxyDesktop *CreateProxyDesktop(IETHREADPARAM *piei);
    friend BOOL SHCreateFromDesktop(PNEWFOLDERINFO pfi);

    CProxyDesktop() {};
    ~CProxyDesktop();

    HWND            _hwnd;
    LPITEMIDLIST    _pidlRoot;
};

CProxyDesktop::~CProxyDesktop()
{
    ILFree(_pidlRoot);
}

LRESULT CALLBACK CProxyDesktop::ProxyWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CProxyDesktop *pproxy = (CProxyDesktop *)GetWindowPtr0(hwnd);

    switch (msg)
    {
    case WM_CREATE:
        pproxy = (CProxyDesktop *)((CREATESTRUCT *)lParam)->lpCreateParams;
        SetWindowPtr0(hwnd, pproxy);

        pproxy->_hwnd = hwnd;
        return 0;   // success

    case WM_DESTROY:
        if (pproxy)
            pproxy->_hwnd = NULL;
        return 0;

    case CWM_COMMANDLINE:
        SHOnCWMCommandLine(lParam);
        break;

    case CWM_COMPAREROOT:
        return _RootsEqual((HANDLE)lParam, (DWORD)wParam, pproxy->_pidlRoot);

    default:
        return DefWindowProcWrap(hwnd, msg, wParam, lParam);
    }
    return 0;
}

CProxyDesktop *CreateProxyDesktop(IETHREADPARAM *piei)
{
    CProxyDesktop *pproxy = new CProxyDesktop();
    if (pproxy)
    {
        WNDCLASS wc = {0};
        wc.lpfnWndProc = CProxyDesktop::ProxyWndProc;
        wc.cbWndExtra = SIZEOF(CProxyDesktop *);
        wc.hInstance = HINST_THISDLL;
        wc.hbrBackground = (HBRUSH)(COLOR_DESKTOP + 1);
        wc.lpszClassName = DESKTOPPROXYCLASS;

        SHRegisterClass(&wc);

        if (CreateWindowEx(WS_EX_TOOLWINDOW, DESKTOPPROXYCLASS, DESKTOPPROXYCLASS,
            WS_POPUP, 0, 0, 0, 0, NULL, NULL, HINST_THISDLL, pproxy))
        {
            if (ILIsRooted(piei->pidl))
            {
                pproxy->_pidlRoot = ILCloneFirst(piei->pidl);
                if (pproxy->_pidlRoot == NULL)
                {
                    DestroyWindow(pproxy->_hwnd);
                    pproxy = NULL;
                }
            }
        }
        else
        {
            delete pproxy;
            pproxy = NULL;
        }
    }
    return pproxy;
}


// REVIEW: maybe just check (hwnd == GetShellWindow())

STDAPI_(BOOL) IsDesktopWindow(HWND hwnd)
{
    TCHAR szName[80];

    GetClassName(hwnd, szName, ARRAYSIZE(szName));
    if (!lstrcmp(szName, DESKTOPCLASS))
    {
        GetWindowText(hwnd, szName, ARRAYSIZE(szName));
        return !lstrcmp(szName, PROGMAN);
    }
    return FALSE;
}

typedef struct
{
    HWND hwndDesktop;
    HANDLE hCR;
    DWORD dwProcId;
    HWND hwndResult;
} FRDSTRUCT;

BOOL CALLBACK FindRootEnumProc(HWND hwnd, LPARAM lParam)
{
    FRDSTRUCT *pfrds = (FRDSTRUCT *)lParam;
    TCHAR szClassName[40];

    GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName));
    if (lstrcmpi(szClassName, DESKTOPPROXYCLASS) == 0)
    {
        ASSERT(hwnd != pfrds->hwndDesktop);

        if (SendMessage(hwnd, CWM_COMPAREROOT, (WPARAM)pfrds->dwProcId, (LPARAM)pfrds->hCR))
        {
            // Found it, so stop enumerating
            pfrds->hwndResult = hwnd;
            return FALSE;
        }
    }
    return TRUE;
}

BOOL RunSeparateDesktop()
{
    DWORD bSeparate = FALSE;

    if (SHRestricted(REST_SEPARATEDESKTOPPROCESS))
        bSeparate = TRUE;
    else
    {
        SHELLSTATE ss;

        SHGetSetSettings(&ss, SSF_SEPPROCESS, FALSE);
        bSeparate = ss.fSepProcess;

        if (!bSeparate)
        {
            DWORD cbData = SIZEOF(bSeparate);
            SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, TEXT("DesktopProcess"), NULL, &bSeparate, &cbData);
        }
    }
    return bSeparate;

}

//  if we need to force some legacy rootet explorers into their own process, implement this.
//#define _RootRunSeparateProcess(pidlRoot)  ILIsRooted(pidlRoot)  OLD BEHAVIOR
#define _RootRunSeparateProcess(pidlRoot)  FALSE

HWND FindRootedDesktop(LPCITEMIDLIST pidlRoot)
{
    HWND hwndDesktop = GetShellWindow();    // This is the "normal" desktop

    if (!RunSeparateDesktop() && !_RootRunSeparateProcess(pidlRoot) && hwndDesktop)
    {
        ASSERT(IsDesktopWindow(hwndDesktop));
        return hwndDesktop;
    }

    FRDSTRUCT frds;
    frds.hwndDesktop = hwndDesktop;
    frds.hwndResult = NULL;     // Initalize to no matching rooted expl
    frds.dwProcId = GetCurrentProcessId();
    frds.hCR = SHAllocShared(pidlRoot, ILGetSize(pidlRoot), frds.dwProcId);
    if (frds.hCR)
    {
        EnumWindows(FindRootEnumProc, (LPARAM)&frds);
        SHFreeShared(frds.hCR, frds.dwProcId);
    }

    return frds.hwndResult;
}


UINT _GetProcessHotkey(void)
{
    STARTUPINFO si = {SIZEOF(si)};
    GetStartupInfo(&si);
    return (UINT)(DWORD_PTR)si.hStdInput;
}

void FolderInfoToIEThreadParam(PNEWFOLDERINFO pfi, IETHREADPARAM *piei)
{
    piei->uFlags = pfi->uFlags;
    piei->nCmdShow = pfi->nShow;
    piei->wHotkey = _GetProcessHotkey();
    
    ASSERT(pfi->pszRoot == NULL);       // explorer always converts to a PIDL for us

    //  we no longer support rooted explorers this way
    //  it should have been filtered out above us.
    ASSERT(!pfi->pidlRoot);
    ASSERT(!(pfi->uFlags & (COF_ROOTCLASS | COF_NEWROOT)));
    ASSERT(IsEqualGUID(pfi->clsid, CLSID_NULL));

    if (pfi->pidl) 
    {
        piei->pidl = ILClone(pfi->pidl);
    } 
    //  COF_PARSEPATH means that we should defer the parsing of the pszPath
    else if (!(pfi->uFlags & COF_PARSEPATH) && pfi->pszPath && pfi->pszPath[0])
    {
        //  maybe should use IECreateFromPath??
        //  or maybe we should parse relative to the root??
        piei->pidl = ILCreateFromPathA(pfi->pszPath);
    }
}

// IE4 Integrated delay loads CreateFromDesktop from SHDOCVW.DLL
// So we need to keep this function here. Forward to the correct
// implementation in SHELL32 (if integrated) or SHDOC41 (if not)
BOOL SHCreateFromDesktop(PNEWFOLDERINFO pfi)
{
    IETHREADPARAM *piei = SHCreateIETHREADPARAM(NULL, 0, NULL, NULL);
    if (piei)
    {
        //  ASSUMING UNICODE COMPILE!
        LPCTSTR pszPath = NULL;
        HWND hwndDesktop;

        if (pfi->uFlags & COF_PARSEPATH)
        {
            ASSERT(!pfi->pidl);
            pszPath = (LPCTSTR) pfi->pszPath;
        }

        FolderInfoToIEThreadParam(pfi, piei);

        if (pfi->uFlags & COF_SEPARATEPROCESS)
        {
            hwndDesktop = NULL;         // Assume no desktop process exists
        }
        else
        {
            hwndDesktop = FindRootedDesktop(piei->pidl);
        }

        if (hwndDesktop)
        {
            DWORD dwProcId;
            DWORD dwThreadId = GetWindowThreadProcessId(hwndDesktop, &dwProcId);
            AllowSetForegroundWindow(dwProcId);
            HNFBLOCK hBlock = ConvertNFItoHNFBLOCK(piei, pszPath, dwProcId);
            if (hBlock)
            {
                PostMessage(hwndDesktop, CWM_COMMANDLINE, 0, (LPARAM)hBlock);

                HANDLE hExplorer = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, dwProcId );
                if ( hExplorer )
                {
                    // wait for input idle 10 seconds.
                    WaitForInputIdle( hExplorer, 10000 );
                    CloseHandle( hExplorer );
                }
            }
        }
        else
        {
            HRESULT hrInit = SHCoInitialize();

            CProxyDesktop *pproxy = CreateProxyDesktop(piei);
            if (pproxy)
            {
                // CRefThread controls this processes reference count. browser windows use this
                // to keep this process (window) around and this also lets thrid parties hold 
                // references to our process, MSN uses this for example

                LONG cRefMsgLoop;
                IUnknown *punkRefMsgLoop;
                if (SUCCEEDED(SHCreateThreadRef(&cRefMsgLoop, &punkRefMsgLoop)))
                {
                    SHSetInstanceExplorer(punkRefMsgLoop);

                    //  we needed to wait for this for the CoInit()
                    if (pszPath)
                        piei->pidl = ILCreateFromPath(pszPath);

                    SHOpenFolderWindow(piei);
                    piei = NULL;                // OpenFolderWindow() takes ownership of this
                    punkRefMsgLoop->Release();  // we now depend on the browser window to keep our msg loop
                }

                MSG msg;
                while (GetMessage(&msg, NULL, 0, 0))
                {
                    if (cRefMsgLoop == 0)
                        break; // no more refs on this thread, done

                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
                delete pproxy;
            }

            SHCoUninitialize(hrInit);
        }

        if (piei)
            SHDestroyIETHREADPARAM(piei);
    }
    return TRUE;        // no one pays attention to this
}
        

HNFBLOCK ConvertNFItoHNFBLOCK(IETHREADPARAM* pInfo, LPCTSTR pszPath, DWORD dwProcId)
{
    UINT    uSize;
    UINT    uPidl;
    UINT    uPidlSelect;
    UINT    uPidlRoot;
    UINT    upszPath;
    PNEWFOLDERBLOCK pnfb;
    LPBYTE  lpb;
    HNFBLOCK hBlock;
    LPVOID pidlRootOrMonitor = NULL; // pidlRoot or &hMonitor

    uSize = SIZEOF(NEWFOLDERBLOCK);
    if (pInfo->pidl)
    {
        uPidl = ILGetSize(pInfo->pidl);
        uSize += uPidl;
    }
    if (pInfo->pidlSelect)
    {
        uPidlSelect = ILGetSize(pInfo->pidlSelect);
        uSize += uPidlSelect;
    }

    if (pInfo->uFlags & COF_HASHMONITOR)
    {
        pidlRootOrMonitor = &pInfo->pidlRoot;
        uPidlRoot = sizeof(HMONITOR);
        uSize += uPidlRoot;
    }
    else if (pInfo->pidlRoot)
    {
        pidlRootOrMonitor = pInfo->pidlRoot;
        uPidlRoot = ILGetSize(pInfo->pidlRoot);
        uSize += uPidlRoot;
    }

    if (pszPath) {
        upszPath = CbFromCch(lstrlen(pszPath) + 1);
        uSize += upszPath;
    }

    hBlock = (HNFBLOCK)SHAllocShared(NULL, uSize, dwProcId);
    if (hBlock == NULL)
        return NULL;

    pnfb = (PNEWFOLDERBLOCK)SHLockShared(hBlock, dwProcId);
    if (pnfb == NULL)
    {
        SHFreeShared(hBlock, dwProcId);
        return NULL;
    }

    pnfb->dwSize      = uSize;
    pnfb->uFlags      = pInfo->uFlags;
    pnfb->nShow       = pInfo->nCmdShow;
    pnfb->dwHwndCaller= PtrToInt(pInfo->hwndCaller);
    pnfb->dwHotKey    = pInfo->wHotkey;
    pnfb->clsid       = pInfo->clsid;
    pnfb->clsidInProc = pInfo->clsidInProc;
    pnfb->oidl        = 0;
    pnfb->oidlSelect  = 0;
    pnfb->oidlRoot    = 0;
    pnfb->opszPath    = 0;

    lpb = (LPBYTE)(pnfb+1);     // Point just past the structure

    if (pInfo->pidl)
    {
        memcpy(lpb,pInfo->pidl,uPidl);
        pnfb->oidl = (int)(lpb-(LPBYTE)pnfb);
        lpb += uPidl;
    }
    if (pInfo->pidlSelect)
    {
        memcpy(lpb,pInfo->pidlSelect,uPidlSelect);
        pnfb->oidlSelect = (int)(lpb-(LPBYTE)pnfb);
        lpb += uPidlSelect;
    }

    if (pidlRootOrMonitor)
    {
        memcpy(lpb, pidlRootOrMonitor, uPidlRoot);
        pnfb->oidlRoot = (int)(lpb-(LPBYTE)pnfb);
        lpb += uPidlRoot;
    }

    if (pszPath)
    {
        memcpy(lpb, pszPath, upszPath);
        pnfb->opszPath = (int)(lpb-(LPBYTE)pnfb);
        lpb += upszPath;
    }
    SHUnlockShared(pnfb);
    return hBlock;
}

IETHREADPARAM* ConvertHNFBLOCKtoNFI(HNFBLOCK hBlock)
{
    BOOL fFailure = FALSE;
    IETHREADPARAM* piei = NULL;
    if (hBlock)
    {
        DWORD dwProcId = GetCurrentProcessId();
        PNEWFOLDERBLOCK pnfb = (PNEWFOLDERBLOCK)SHLockShared(hBlock, dwProcId);
        if (pnfb)
        {
            if (pnfb->dwSize >= SIZEOF(NEWFOLDERBLOCK))
            {
                piei = SHCreateIETHREADPARAM(NULL, pnfb->nShow, NULL, NULL);
                if (piei)
                {
                    LPITEMIDLIST pidl = NULL;
                    piei->uFlags      = pnfb->uFlags;
                    piei->hwndCaller  = IntToPtr_(HWND, pnfb->dwHwndCaller);
                    piei->wHotkey     = pnfb->dwHotKey;
                    piei->clsid       = pnfb->clsid;
                    piei->clsidInProc = pnfb->clsidInProc;

                    if (pnfb->oidlSelect)
                        piei->pidlSelect = ILClone((LPITEMIDLIST)((LPBYTE)pnfb+pnfb->oidlSelect));

                    if (pnfb->oidlRoot)
                    {
                        LPITEMIDLIST pidlRoot = (LPITEMIDLIST)((LPBYTE)pnfb+pnfb->oidlRoot);
                        if (pnfb->uFlags & COF_HASHMONITOR)
                        {
                            piei->pidlRoot = (LPITEMIDLIST)*(UNALIGNED HMONITOR *)pidlRoot;
                        }
                        else
                        {
                            piei->pidlRoot = ILClone(pidl);
                        }
                    }

                    if (pnfb->oidl)
                        pidl = ILClone((LPITEMIDLIST)((LPBYTE)pnfb+pnfb->oidl));

                    if (pidl) 
                    {
                        piei->pidl = pidl;
                    } 
                    
                    // we pass this string through because msn fails the cocreateinstane of
                    // their desktop if another one is up and running, so we can't convert
                    // this from path to pidl except in the current process context
                    if (pnfb->opszPath) 
                    {
                        LPTSTR pszPath = (LPTSTR)((LPBYTE)pnfb+pnfb->opszPath);
                        HRESULT hr = E_FAIL;
                        
                        if (ILIsRooted(pidl))
                        {
                            //  let the root handle the parsing.
                            IShellFolder *psf;
                            if (SUCCEEDED(IEBindToObject(pidl, &psf)))
                            {
                                hr = IShellFolder_ParseDisplayName(psf, NULL, NULL, pszPath, NULL, &(piei->pidl), NULL);
                                psf->Release();
                            }
                        }
                        else
                            IECreateFromPath(pszPath, &(piei->pidl));

                        // APP COMPAT: these two specific return result codes are the two we ignored for win95.
                        // APP COMPAT: MSN 1.3 Classic accidentally on purpose returns one of these...
                        if ( !piei->pidl )
                        {
                            // failed, report the error to the user ... (will only fail for paths)
                            ASSERT( !PathIsURL( pszPath))

                            if (! (piei->uFlags & COF_NOTUSERDRIVEN) && ( hr != E_OUTOFMEMORY ) && ( hr != HRESULT_FROM_WIN32( ERROR_CANCELLED )))
                            {
                                MLShellMessageBox(
                                                  NULL,
                                                  MAKEINTRESOURCE( IDS_NOTADIR ),
                                                  MAKEINTRESOURCE( IDS_CABINET ),
                                                  MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND,
                                                  pszPath);
                            }
                            fFailure = TRUE;
                        }
                    }

                }
            }
            SHUnlockShared(pnfb);
        }
        SHFreeShared(hBlock, dwProcId);
    }

    // if we really failed somewhere, return NULL
    if (fFailure)
    {
        SHDestroyIETHREADPARAM(piei);
        piei = NULL;
    }
    return piei;
}


// Check the registry for a shell root under this CLSID.
BOOL GetRootFromRootClass(LPCTSTR pszGUID, LPTSTR pszPath, int cchPath)
{
    TCHAR szClass[MAX_PATH];

    wnsprintf(szClass, ARRAYSIZE(szClass), TEXT("CLSID\\%s\\ShellExplorerRoot"), pszGUID);

    DWORD cbPath = cchPath * sizeof(TCHAR);

    return SHGetValueGoodBoot(HKEY_CLASSES_ROOT, szClass, NULL, NULL, (BYTE *)pszPath, &cbPath) == ERROR_SUCCESS;
}

// format is ":<hMem>:<hProcess>"

LPITEMIDLIST IDListFromCmdLine(LPCTSTR pszCmdLine, int i)
{
    LPITEMIDLIST pidl = NULL;
    TCHAR szField[80];

    if (_private_ParseField(pszCmdLine, i, szField, ARRAYSIZE(szField)) && szField[0] == TEXT(':'))
    {
        // Convert the string of format ":<hmem>:<hprocess>" into a pointer
        HANDLE hMem = LongToHandle(StrToLong(szField + 1));
        LPTSTR pszNextColon = StrChr(szField + 1, TEXT(':'));
        if (pszNextColon)
        {
            DWORD dwProcId = (DWORD)StrToLong(pszNextColon + 1);
            LPITEMIDLIST pidlGlobal = (LPITEMIDLIST) SHLockShared(hMem, dwProcId);
            if (pidlGlobal)
            {
                if (!IsBadReadPtr(pidlGlobal, 1))
                    pidl = ILClone(pidlGlobal);

                SHUnlockShared(pidlGlobal);
                SHFreeShared(hMem, dwProcId);
            }
        }
    }
    return pidl;
}

#define MYDOCS_CLSIDW L"{450d8fba-ad25-11d0-98a8-0800361b1103}" // CLSID_MyDocuments

LPITEMIDLIST MyDocsIDList(void)
{
    LPITEMIDLIST pidl = NULL;
    IShellFolder *psf;
    HRESULT hres = SHGetDesktopFolder(&psf);
    if (SUCCEEDED(hres))
    {
        hres = psf->ParseDisplayName(NULL, NULL, L"::" MYDOCS_CLSIDW, NULL, &pidl, NULL);
        psf->Release();
    }

    // Win95/NT4 case, go for the real MyDocs folder
    if (FAILED(hres))
    {
        hres = SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl);
    }
    return SUCCEEDED(hres) ? pidl : NULL;
}


BOOL SHExplorerParseCmdLine(PNEWFOLDERINFO pfi)
{
    int i;
    TCHAR szField[MAX_PATH];

    LPCTSTR pszCmdLine = GetCommandLine();
    pszCmdLine = PathGetArgs(pszCmdLine);

    // empty command line -> explorer My Docs
    if (*pszCmdLine == 0)
    {
        pfi->uFlags = COF_CREATENEWWINDOW | COF_EXPLORE;

        // try MyDocs first?
        pfi->pidl = MyDocsIDList();
        if (pfi->pidl == NULL)
        {
            TCHAR szPath[MAX_PATH];
            GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
            PathStripToRoot(szPath);
            pfi->pidl = ILCreateFromPath(szPath);
        }

        return BOOLFROMPTR(pfi->pidl);
    }

    // Arguments must be separated by '=' or ','
    for (i = 1; _private_ParseField(pszCmdLine, i, szField, ARRAYSIZE(szField)); i++)
    {
        if (lstrcmpi(szField, TEXT("/N")) == 0)
        {
            pfi->uFlags |= COF_CREATENEWWINDOW | COF_NOFINDWINDOW;
        }
        else if (lstrcmpi(szField, TEXT("/S")) == 0)
        {
            pfi->uFlags |= COF_USEOPENSETTINGS;
        }
        else if (lstrcmpi(szField, TEXT("/E")) == 0)
        {
            pfi->uFlags |= COF_EXPLORE;
        }
        else if (lstrcmpi(szField, TEXT("/ROOT")) == 0)
        {
            LPITEMIDLIST pidlRoot = NULL;
            CLSID *pclsidRoot = NULL;
            CLSID clsid;

            RIPMSG(!pfi->pidl, "SHExplorerParseCommandLine: (/ROOT) caller passed bad params");

            // of the form:
            //     /ROOT,{clsid}[,<path>]
            //     /ROOT,/IDLIST,:<hmem>:<hprocess>
            //     /ROOT,<path>

            if (!_private_ParseField(pszCmdLine, ++i, szField, ARRAYSIZE(szField)))
                return FALSE;

            // {clsid}
            if (GUIDFromString(szField, &clsid))
            {
                TCHAR szGUID[GUIDSTR_MAX];
                StrCpyN(szGUID, szField, SIZECHARS(szGUID));

                // {clsid} case, if not path compute from the registry
                if (!_private_ParseField(pszCmdLine, ++i, szField, ARRAYSIZE(szField)))
                {
                    // path must come from the registry now
                    if (!GetRootFromRootClass(szGUID, szField, ARRAYSIZE(szField)))
                    {
                        return FALSE;   // bad command line
                    }
                }

                IECreateFromPath(szField, &pidlRoot);
                pclsidRoot = &clsid;

            }
            else if (lstrcmpi(szField, TEXT("/IDLIST")) == 0)
            {
                // /IDLIST
                pidlRoot = IDListFromCmdLine(pszCmdLine, ++i);
            }
            else
            {
                // <path>
                IECreateFromPath(szField, &pidlRoot);
            }

            // fix up bad cmd line "explorer.exe /root," case
            if (pidlRoot == NULL)
            {
                HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, &pfi->pidlRoot);
                if (FAILED(hr))
                {
                    pfi->pidlRoot = NULL;
                }
            }

            if (pidlRoot)
            {
                pfi->pidl = ILRootedCreateIDList(pclsidRoot, pidlRoot);
                ILFree(pidlRoot);
            }
        }
        else if (lstrcmpi(szField, TEXT("/INPROC")) == 0)
        {
            // Parse and skip the next arg or 2
            if (!_private_ParseField(pszCmdLine, ++i, szField, ARRAYSIZE(szField)))
            {
                return FALSE;
            }

            // The next arg must be a GUID
            if (!GUIDFromString(szField, &pfi->clsidInProc))
            {
                return FALSE;
            }

            pfi->uFlags |= COF_INPROC;
        }
        else if (lstrcmpi(szField, TEXT("/SELECT")) == 0)
        {
            pfi->uFlags |= COF_SELECT;
        }
        else if (lstrcmpi(szField, TEXT("/NOUI")) == 0)
        {
            pfi->uFlags |= COF_NOUI;
        }
        else if (lstrcmpi(szField, TEXT("-embedding")) == 0)
        {
            pfi->uFlags |= COF_AUTOMATION;
        }
        else if (lstrcmpi(szField, TEXT("/IDLIST")) == 0)
        {
            LPITEMIDLIST pidl = IDListFromCmdLine(pszCmdLine, ++i);

            if (pidl)
            {
                if (pfi->pidl)
                {
                    // again, this is kind of bogus (see comment below). If we already have a
                    // pidl, free it and use the new one.
                    ILFree(pfi->pidl);
                }

                pfi->pidl = pidl;
            }
            else if (pfi->pidl == NULL)
            {
                // if we didn't have a pidl before and we dont have one now, we are in trouble, so get out
                return FALSE;
            }
        }
        else if (lstrcmpi(szField, TEXT("/SEPARATE")) == 0)
        {
            pfi->uFlags |= COF_SEPARATEPROCESS;
        }
        else
        {
            LPITEMIDLIST pidl = ILCreateFromPath(szField);
            if (!pidl)
            {
                //
                //  LEGACY - if this is unparseable, then guess it is relative path
                //  this catches "explorer ." as opening the current directory
                //
                TCHAR szDir[MAX_PATH];
                TCHAR szCombined[MAX_PATH];
                GetCurrentDirectory(SIZECHARS(szDir), szDir);

                PathCombine(szCombined, szDir, szField);

                pidl = ILCreateFromPath(szCombined);
            }

            // this is kind of bogus: we have traditionally passed both the idlist (/idlist,:580:1612) and the path
            // (C:\Winnt\Profiles\reinerf\Desktop) as the default command string to explorer (see HKCR\Folder\shell
            // \open\command). Since we have both a /idlist and a path, we have always used the latter so that is what
            // we continue to do here.
            if (pfi->pidl)
            {
                ILFree(pfi->pidl);  // free the /idlist pidl and use the one from the path
            }

            pfi->pidl = pidl;
            if (pidl)  
            {
                pfi->uFlags |= COF_NOTRANSLATE;     // pidl is abosolute from the desktop
            }
            else
            {
                pfi->pszPath = (LPSTR) StrDup(szField);
                if (pfi->pszPath)
                {
                    pfi->uFlags |= COF_PARSEPATH;
                }
            }
        }
    }
    return TRUE;
}

#define ISSEP(c)   ((c) == TEXT('=')  || (c) == TEXT(','))
#define ISWHITE(c) ((c) == TEXT(' ')  || (c) == TEXT('\t') || (c) == TEXT('\n') || (c) == TEXT('\r'))
#define ISNOISE(c) ((c) == TEXT('"'))

#define QUOTE   TEXT('"')
#define COMMA   TEXT(',')
#define SPACE   TEXT(' ')
#define EQUAL   TEXT('=')

/* BOOL ParseField(szData,n,szBuf,iBufLen)
 *
 * Given a line from SETUP.INF, will extract the nth field from the string
 * fields are assumed separated by comma's.  Leading and trailing spaces
 * are removed.
 *
 * ENTRY:
 *
 * szData    : pointer to line from SETUP.INF
 * n         : field to extract. ( 1 based )
 *             0 is field before a '=' sign
 * szDataStr : pointer to buffer to hold extracted field
 * iBufLen   : size of buffer to receive extracted field.
 *
 * EXIT: returns TRUE if successful, FALSE if failure.
 *
 * Copied from shell32\util.cpp 
 * note that this is now used to parse the Explorer command line
 * --ccooney
 */
BOOL  _private_ParseField(LPCTSTR pszData, int n, LPTSTR szBuf, int iBufLen)
{
    BOOL  fQuote = FALSE;
    LPCTSTR pszInf = pszData;
    LPTSTR ptr;
    int   iLen = 1;
    
    if (!pszData || !szBuf)
        return FALSE;
    
        /*
        * find the first separator
    */
    while (*pszInf && !ISSEP(*pszInf))
    {
        if (*pszInf == QUOTE)
            fQuote = !fQuote;
        pszInf = CharNext(pszInf);
    }
    
    if (n == 0 && *pszInf != TEXT('='))
        return FALSE;
    
    if (n > 0 && *pszInf == TEXT('=') && !fQuote)
        // Change pszData to point to first field
        pszData = ++pszInf; // Ok for DBCS
    
                           /*
                           *   locate the nth comma, that is not inside of quotes
    */
    fQuote = FALSE;
    while (n > 1)
    {
        while (*pszData)
        {
            if (!fQuote && ISSEP(*pszData))
                break;
            
            if (*pszData == QUOTE)
                fQuote = !fQuote;
            
            pszData = CharNext(pszData);
        }
        
        if (!*pszData)
        {
            szBuf[0] = 0;      // make szBuf empty
            return FALSE;
        }
        
        pszData = CharNext(pszData); // we could do ++ here since we got here
        // after finding comma or equal
        n--;
    }
    
    /*
    * now copy the field to szBuf
    */
    while (ISWHITE(*pszData))
        pszData = CharNext(pszData); // we could do ++ here since white space can
    // NOT be a lead byte
    fQuote = FALSE;
    ptr = szBuf;      // fill output buffer with this
    while (*pszData)
    {
        if (*pszData == QUOTE)
        {
            //
            // If we're in quotes already, maybe this
            // is a double quote as in: "He said ""Hello"" to me"
            //
            if (fQuote && *(pszData+1) == QUOTE)    // Yep, double-quoting - QUOTE is non-DBCS
            {
                if (iLen < iBufLen)
                {
                    *ptr++ = QUOTE;
                    ++iLen;
                }
                pszData++;                   // now skip past 1st quote
            }
            else
                fQuote = !fQuote;
        }
        else if (!fQuote && ISSEP(*pszData))
            break;
        else
        {
            if ( iLen < iBufLen )
            {
                *ptr++ = *pszData;                  // Thank you, Dave
                ++iLen;
            }
            
            if ( IsDBCSLeadByte(*pszData) && (iLen < iBufLen) )
            {
                *ptr++ = pszData[1];
                ++iLen;
            }
        }
        pszData = CharNext(pszData);
    }
    /*
    * remove trailing spaces
    */
    while (ptr > szBuf)
    {
        ptr = CharPrev(szBuf, ptr);
        if (!ISWHITE(*ptr))
        {
            ptr = CharNext(ptr);
            break;
        }
    }
    *ptr = 0;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\progress.cpp ===
// Display the Progress Dialog for the progress on the completion of some
//    generic operation.  This is most often used for Deleting, Uploading, Copying,
//    Moving and Downloading large numbers of files.

#include "priv.h"
#include "resource.h"
#include "mluisupp.h"

// this is how long we wait for the UI thread to create the progress hwnd before giving up
#define WAIT_PROGRESS_HWND 10*1000 // ten seconds


STDAPI CProgressDialog_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

class CProgressDialog 
                : public IProgressDialog
                , public IOleWindow
                , public IActionProgressDialog
                , public IActionProgress
                , public IObjectWithSite
{
public:
    CProgressDialog();

    // IUnknown
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // IProgressDialog
    STDMETHODIMP StartProgressDialog(HWND hwndParent, IUnknown * punkEnableModless, DWORD dwFlags, LPCVOID pvResevered);
    STDMETHODIMP StopProgressDialog(void);
    STDMETHODIMP SetTitle(LPCWSTR pwzTitle);
    STDMETHODIMP SetAnimation(HINSTANCE hInstAnimation, UINT idAnimation);
    STDMETHODIMP_(BOOL) HasUserCancelled(void);
    STDMETHODIMP SetProgress(DWORD dwCompleted, DWORD dwTotal);
    STDMETHODIMP SetProgress64(ULONGLONG ullCompleted, ULONGLONG ullTotal);
    STDMETHODIMP SetLine(DWORD dwLineNum, LPCWSTR pwzString, BOOL fCompactPath, LPCVOID pvResevered);
    STDMETHODIMP SetCancelMsg(LPCWSTR pwzCancelMsg, LPCVOID pvResevered);
    STDMETHODIMP Timer(DWORD dwAction, LPCVOID pvResevered);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND * phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    //  IActionProgressDialog
    STDMETHODIMP Initialize(SPINITF flags, LPCWSTR pszTitle, LPCWSTR pszCancel);
    STDMETHODIMP Stop();

    //  IActionProgress
    STDMETHODIMP Begin(SPACTION action, SPBEGINF flags);
    STDMETHODIMP UpdateProgress(ULONGLONG ulCompleted, ULONGLONG ulTotal);
    STDMETHODIMP UpdateText(SPTEXT sptext, LPCWSTR pszText, BOOL fMayCompact);
    STDMETHODIMP QueryCancel(BOOL * pfCancelled);
    STDMETHODIMP ResetCancel();
    STDMETHODIMP End();

    //  IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punk) { IUnknown_Set(&_punkSite, punk); return S_OK; }
    STDMETHODIMP GetSite(REFIID riid, void **ppv) { *ppv = 0; return _punkSite ? _punkSite->QueryInterface(riid, ppv) : E_FAIL;}

    // Other Public Methods
    static INT_PTR CALLBACK ProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    static DWORD CALLBACK ThreadProc(LPVOID pvThis) { return ((CProgressDialog *) pvThis)->_ThreadProc(); };
    static DWORD CALLBACK SyncThreadProc(LPVOID pvThis) { return ((CProgressDialog *) pvThis)->_SyncThreadProc(); };

private:
    ~CProgressDialog(void);
    LONG       _cRef;

    // State Accessible thru IProgressDialog
    LPWSTR      _pwzTitle;                  // This will be used to cache the value passed to IProgressDialog::SetTitle() until the dialog is displayed
    UINT        _idAnimation;
    HINSTANCE   _hInstAnimation;
    LPWSTR      _pwzLine1;                  // NOTE:
    LPWSTR      _pwzLine2;                  // these are only used to init the dialog, otherwise, we just
    LPWSTR      _pwzLine3;                  // call through on the main thread to update the dialog directly.
    LPWSTR      _pwzCancelMsg;              // If the user cancels, Line 1 & 2 will be cleared and Line 3 will get this msg.

    // Other internal state.
    HWND        _hwndDlgParent;             // parent window for message boxes
    HWND        _hwndProgress;              // dialog/progress window
    DWORD       _dwFirstShowTime;           // tick count when the dialog was first shown (needed so we don't flash it up for an instant)

    SPINITF     _spinitf;
    SPBEGINF    _spbeginf;
    IUnknown   *_punkSite;
    HINSTANCE   _hinstFree;
    
    BOOL        _fCompletedChanged;         // has the _dwCompleted changed since last time?
    BOOL        _fTotalChanged;             // has the _dwTotal changed since last time?
    BOOL        _fChangePosted;             // is there a change pending?
    BOOL        _fCancel;
    BOOL        _fTermThread;
    BOOL        _fThreadRunning;
    BOOL        _fInAction;
    BOOL        _fMinimized;
    BOOL        _fScaleBug;                 // Comctl32's PBM_SETRANGE32 msg will still cast it to an (int), so don't let the high bit be set.
    BOOL        _fNoTime;
    BOOL        _fReleaseSelf;
    BOOL        _fInitialized;

    // Progress Values and Calculations
    DWORD       _dwCompleted;               // progress completed
    DWORD       _dwTotal;                   // total progress
    DWORD       _dwPrevRate;                // previous progress rate (used for computing time remaining)
    DWORD       _dwPrevTickCount;           // the tick count when we last updated the progress time
    DWORD       _dwPrevCompleted;           // the ammount we had completed when we last updated the progress time
    DWORD       _dwLastUpdatedTimeRemaining;// tick count when we last update the "Time remaining" field, we only update it every 5 seconds
    DWORD       _dwLastUpdatedTickCount;    // tick count when SetProgress was last called, used to calculate the rate
    UINT        _iNumTimesSetProgressCalled;// how many times has the user called SetProgress?

    // Private Member Functions
    DWORD _ThreadProc(void);
    DWORD _SyncThreadProc(void);
    BOOL _OnInit(HWND hDlg);
    BOOL _ProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    void _PauseAnimation(BOOL bStop);
    void _UpdateProgressDialog(void);
    void _AsyncUpdate(void);
    HRESULT _SetProgressTime(void);
    void _SetProgressTimeEst(DWORD dwSecondsLeft);
    void _UserCancelled(void);
    HRESULT _DisplayDialog(void);
    void _CompactProgressPath(LPCWSTR pwzStrIn, BOOL fCompactPath, UINT idDlgItem, LPWSTR pwzStrOut, DWORD cchSize);
    HRESULT _SetLineHelper(LPCWSTR pwzNew, LPWSTR * ppwzDest, UINT idDlgItem, BOOL fCompactPath);
    HRESULT _SetTitleBarProgress(DWORD dwCompleted, DWORD dwTotal);
    HRESULT _BeginAction(SPBEGINF flags);
    void _SetModeless(BOOL fModeless);
    void _ShowProgressBar(HWND hwnd);
};

//#define TF_PROGRESS 0xFFFFFFFF
#define TF_PROGRESS 0x00000000

// REVIEW, we should tune this size down as small as we can
// to get smoother multitasking (without effecting performance)
#define MIN_MINTIME4FEEDBACK    5       // is it worth showing estimated time to completion feedback?
#define MS_TIMESLICE            2000    // ms, (MUST be > 1000!) first average time to completion estimate

#define SHOW_PROGRESS_TIMEOUT   1000    // 1 second
#define MINSHOWTIME             2000    // 2 seconds

// progress dialog message
#define PDM_SHUTDOWN     WM_APP
#define PDM_TERMTHREAD  (WM_APP + 1)
#define PDM_UPDATE      (WM_APP + 2)

// progress dialog timer messages
#define ID_SHOWTIMER    1

#ifndef UNICODE
#error "This code will only compile UNICODE for perf reasons.  If you really need an ANSI browseui, write all the code to convert."
#endif // !UNICODE

// compacts path strings to fit into the Text1 and Text2 fields

void CProgressDialog::_CompactProgressPath(LPCWSTR pwzStrIn, BOOL fCompactPath, UINT idDlgItem, LPWSTR pwzStrOut, DWORD cchSize)
{
    WCHAR wzFinalPath[MAX_PATH];
    LPWSTR pwzPathToUse = (LPWSTR)pwzStrIn;

    // We don't compact the path if the dialog isn't displayed yet.
    if (fCompactPath && _hwndProgress)
    {
        RECT rc;
        int cxWidth;

        StrCpyNW(wzFinalPath, (pwzStrIn ? pwzStrIn : L""), ARRAYSIZE(wzFinalPath));

        // get the size of the text boxes
        HWND hwnd = GetDlgItem(_hwndProgress, idDlgItem);
        if (EVAL(hwnd))
        {
            HDC hdc;
            HFONT hfont;
            HFONT hfontSave;

            hdc = GetDC(_hwndProgress);
            hfont = (HFONT)SendMessage(_hwndProgress, WM_GETFONT, 0, 0);
            hfontSave = (HFONT)SelectObject(hdc, hfont);

            GetWindowRect(hwnd, &rc);
            cxWidth = rc.right - rc.left;

            ASSERT(cxWidth >= 0);
            PathCompactPathW(hdc, wzFinalPath, cxWidth);

            SelectObject(hdc, hfontSave);
            ReleaseDC(_hwndProgress, hdc);
        }
        pwzPathToUse = wzFinalPath;
    }

    StrCpyNW(pwzStrOut, (pwzPathToUse ? pwzPathToUse : L""), cchSize);
}

HRESULT CProgressDialog::_SetLineHelper(LPCWSTR pwzNew, LPWSTR * ppwzDest, UINT idDlgItem, BOOL fCompactPath)
{
    WCHAR wzFinalPath[MAX_PATH];

    _CompactProgressPath(pwzNew, fCompactPath, idDlgItem, wzFinalPath, ARRAYSIZE(wzFinalPath));

    Str_SetPtrW(ppwzDest, wzFinalPath); // No, so cache the value for later.

    // Does the dialog exist?
    if (_hwndProgress)
       SetDlgItemText(_hwndProgress, idDlgItem, wzFinalPath);

    return S_OK;
}


HRESULT CProgressDialog::_DisplayDialog(void)
{
    TraceMsg(TF_PROGRESS, "CProgressDialog::_DisplayDialog()");
    // Don't force ourselves into the foreground if a window we parented is already in the foreground:
    
    // This is part of the fix for NT bug 298163 (the confirm replace dialog was deactivated
    // by the progress dialog)
    HWND hwndCurrent = GetForegroundWindow();
    BOOL fChildIsForeground = FALSE;
    while (NULL != (hwndCurrent = GetParent(hwndCurrent)))
    {
        if (_hwndProgress == hwndCurrent)
        {
            fChildIsForeground = TRUE;
            break;
        }
    }
    
    if (fChildIsForeground)
    {
        ShowWindow(_hwndProgress, SW_SHOWNOACTIVATE);
    }
    else
    {
        ShowWindow(_hwndProgress, SW_SHOW);
        SetForegroundWindow(_hwndProgress);
    }
    
    SetFocus(GetDlgItem(_hwndProgress, IDCANCEL));
    return S_OK;
}

DWORD CProgressDialog::_SyncThreadProc()
{
    _InitComCtl32();        // Get ready for the Native Font Control
    _hwndProgress = CreateDialogParam(MLGetHinst(), MAKEINTRESOURCE(DLG_PROGRESSDIALOG),
                                          _hwndDlgParent, ProgressDialogProc, (LPARAM)this);

    _fThreadRunning = (_hwndProgress != NULL);
    return TRUE;
}

DWORD CProgressDialog::_ThreadProc(void)
{
    if (_hwndProgress)
    {
        //  WARNING - copy perf goes way down if this is normal or 
        //  better priority.  the default thread pri should be low.
        //  however if there are situations in which it should be higher,
        //  we can add SPBEGINF bits to support it.
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);
    
        SetTimer(_hwndProgress, ID_SHOWTIMER, SHOW_PROGRESS_TIMEOUT, NULL);

        // Did if finish while we slept?
        if (!_fTermThread)
        {
            // No, so display the dialog.
            MSG msg;

            while(GetMessage(&msg, NULL, 0, 0))
            {
                if (_fTermThread && (GetTickCount() - _dwFirstShowTime) > MINSHOWTIME)
                {
                    // we were signaled to finish and we have been visible MINSHOWTIME,
                    // so its ok to quit
                    break;
                }

                if (!IsDialogMessage(_hwndProgress, &msg))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }

        DestroyWindow(_hwndProgress);
        _hwndProgress = NULL;
    }

    //  this is for callers that dont call stop
    ENTERCRITICAL;
    _fThreadRunning = FALSE;

    if (_fReleaseSelf)
        Release();
    LEAVECRITICAL;
    return 0;
}

DWORD FormatMessageWrapW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID, LPWSTR pwzBuffer, DWORD cchSize, ...)
{
    va_list vaParamList;

    va_start(vaParamList, cchSize);
    DWORD dwResult = FormatMessageW(dwFlags, lpSource, dwMessageID, dwLangID, pwzBuffer, cchSize, &vaParamList);
    va_end(vaParamList);

    return dwResult;
}

DWORD FormatMessageWrapA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID, LPSTR pszBuffer, DWORD cchSize, ...)
{
    va_list vaParamList;

    va_start(vaParamList, cchSize);
    DWORD dwResult = FormatMessageA(dwFlags, lpSource, dwMessageID, dwLangID, pszBuffer, cchSize, &vaParamList);
    va_end(vaParamList);

    return dwResult;
}

#define TIME_DAYS_IN_YEAR               365
#define TIME_HOURS_IN_DAY               24
#define TIME_MINUTES_IN_HOUR            60
#define TIME_SECONDS_IN_MINUTE          60

void _FormatMessageWrapper(LPCTSTR pszTemplate, DWORD dwNum1, DWORD dwNum2, LPTSTR pszOut, DWORD cchSize)
{
    // Is FormatMessageWrapW implemented?
    if (g_bRunOnNT5)
    {
        FormatMessageWrapW(FORMAT_MESSAGE_FROM_STRING, pszTemplate, 0, 0, pszOut, cchSize, dwNum1, dwNum2);
    }
    else
    {
        CHAR szOutAnsi[MAX_PATH];
        CHAR szTemplateAnsi[MAX_PATH];

        SHTCharToAnsi(pszTemplate, szTemplateAnsi, ARRAYSIZE(szTemplateAnsi));
        FormatMessageWrapA(FORMAT_MESSAGE_FROM_STRING, szTemplateAnsi, 0, 0, szOutAnsi, ARRAYSIZE(szOutAnsi), dwNum1, dwNum2);
        SHAnsiToTChar(szOutAnsi, pszOut, cchSize);
    }
}


#define CCH_TIMET_TEMPLATE_SIZE         120     // Should be good enough, even with localization bloat.
#define CCH_TIME_SIZE                    170     // Should be good enough, even with localization bloat.

void _SetProgressLargeTimeEst(DWORD dwSecondsLeft, LPTSTR pszOut, DWORD cchSize)
{
    // Yes.
    TCHAR szTemplate[CCH_TIMET_TEMPLATE_SIZE];
    DWORD dwMinutes = (dwSecondsLeft / TIME_SECONDS_IN_MINUTE);
    DWORD dwHours = (dwMinutes / TIME_MINUTES_IN_HOUR);
    DWORD dwDays = (dwHours / TIME_HOURS_IN_DAY);

    if (dwDays)
    {
        dwHours %= TIME_HOURS_IN_DAY;

        // It's more than a day, so display days and hours.
        if (1 == dwDays)
        {
            if (1 == dwHours)
                LoadString(MLGetHinst(), IDS_TIMEEST_DAYHOUR, szTemplate, ARRAYSIZE(szTemplate));
            else
                LoadString(MLGetHinst(), IDS_TIMEEST_DAYHOURS, szTemplate, ARRAYSIZE(szTemplate));
        }
        else
        {
            if (1 == dwHours)
                LoadString(MLGetHinst(), IDS_TIMEEST_DAYSHOUR, szTemplate, ARRAYSIZE(szTemplate));
            else
                LoadString(MLGetHinst(), IDS_TIMEEST_DAYSHOURS, szTemplate, ARRAYSIZE(szTemplate));
        }

        _FormatMessageWrapper(szTemplate, dwDays, dwHours, pszOut, cchSize);
    }
    else
    {
        // It's let than a day, so display hours and minutes.
        dwMinutes %= TIME_MINUTES_IN_HOUR;

        // It's more than a day, so display days and hours.
        if (1 == dwHours)
        {
            if (1 == dwMinutes)
                LoadString(MLGetHinst(), IDS_TIMEEST_HOURMIN, szTemplate, ARRAYSIZE(szTemplate));
            else
                LoadString(MLGetHinst(), IDS_TIMEEST_HOURMINS, szTemplate, ARRAYSIZE(szTemplate));
        }
        else
        {
            if (1 == dwMinutes)
                LoadString(MLGetHinst(), IDS_TIMEEST_HOURSMIN, szTemplate, ARRAYSIZE(szTemplate));
            else
                LoadString(MLGetHinst(), IDS_TIMEEST_HOURSMINS, szTemplate, ARRAYSIZE(szTemplate));
        }

        _FormatMessageWrapper(szTemplate, dwHours, dwMinutes, pszOut, cchSize);
    }
}


// This sets the "Seconds Left" text in the progress dialog
void CProgressDialog::_SetProgressTimeEst(DWORD dwSecondsLeft)
{
    TCHAR szFmt[CCH_TIMET_TEMPLATE_SIZE];
    TCHAR szOut[CCH_TIME_SIZE];
    DWORD dwTime;
    DWORD dwTickCount = GetTickCount();

    // Since the progress time has either a 1 minute or 5 second granularity (depending on whether the total time
    // remaining is greater or less than 1 minute), we only update it every 20 seconds if the total time is > 1 minute,
    // and ever 4 seconds if the time is < 1 minute. This keeps the time from flashing back and forth between 
    // boundaries (eg 45 secondsand 40 seconds remaining).
    if (dwTickCount - _dwLastUpdatedTimeRemaining < (DWORD)((dwSecondsLeft > 60) ? 20000 : 4000))
        return;

    if (_fNoTime)
    {
        szOut[0] = TEXT('\0');
    }
    else
    {
        // Is it more than an hour?
        if (dwSecondsLeft > (TIME_SECONDS_IN_MINUTE * TIME_MINUTES_IN_HOUR))
            _SetProgressLargeTimeEst(dwSecondsLeft, szOut, ARRAYSIZE(szOut));
        else
        {
            // No.
            if (dwSecondsLeft > TIME_SECONDS_IN_MINUTE)
            {
                // Note that dwTime is at least 2, so we only need a plural form
                LoadString(MLGetHinst(), IDS_TIMEEST_MINUTES, szFmt, ARRAYSIZE(szFmt));
                dwTime = (dwSecondsLeft / TIME_SECONDS_IN_MINUTE) + 1;
            }
            else
            {
                LoadString(MLGetHinst(), IDS_TIMEEST_SECONDS, szFmt, ARRAYSIZE(szFmt));
                // Round up to 5 seconds so it doesn't look so random
                dwTime = ((dwSecondsLeft + 4) / 5) * 5;
            }

            wnsprintf(szOut, ARRAYSIZE(szOut), szFmt, dwTime);
        }
    }

    // we are updating now, so set the _dwLastUpdatedTimeRemaining to now
    _dwLastUpdatedTimeRemaining = dwTickCount;

    // update the Time remaining field
    SetDlgItemText(_hwndProgress, IDD_PROGDLG_LINE3, szOut);
}

#define MAX(x, y)    ((x) > (y) ? (x) : (y))
//
// This function updates the ProgressTime field (aka Line3)
//
HRESULT CProgressDialog::_SetProgressTime(void)
{
    DWORD dwSecondsLeft;
    DWORD dwTotal;
    DWORD dwCompleted;
    DWORD dwCurrentRate;
    DWORD dwTickDelta;
    DWORD dwLeft;
    DWORD dwCurrentTickCount;

    _iNumTimesSetProgressCalled++;

    // grab these in the crit sec (because they can change, and we need a matched set)
    ENTERCRITICAL;
    dwTotal = _dwTotal;
    dwCompleted = _dwCompleted;
    dwCurrentTickCount = _dwLastUpdatedTickCount;
    LEAVECRITICAL;

    dwLeft = dwTotal - dwCompleted;

    dwTickDelta = dwCurrentTickCount - _dwPrevTickCount;

    if (!dwTotal || !dwCompleted)
        return dwTotal ? S_FALSE : E_FAIL;

    // we divide the TickDelta by 100 to give tenths of seconds, so if we have recieved an
    // update faster than that, just skip it
    if (dwTickDelta < 100)
    {
        return S_FALSE;
    }
    
    TraceMsg(TF_PROGRESS, "Current tick count = %lu", dwCurrentTickCount);
    TraceMsg(TF_PROGRESS, "Total work     = %lu", dwTotal);
    TraceMsg(TF_PROGRESS, "Completed work = %lu", dwCompleted);
    TraceMsg(TF_PROGRESS, "Prev. comp work= %lu", _dwPrevCompleted);
    TraceMsg(TF_PROGRESS, "Work left      = %lu", dwLeft);
    TraceMsg(TF_PROGRESS, "Tick delta         = %lu", dwTickDelta);

    if (dwTotal < dwCompleted)
    {
        // we can get into this case if we are applying attributes to sparse files
        // on a volume. As we add up the file sizes, we end up with a number that is bigger
        // than the drive size. We get rid of the time so that we wont show the user something
        // completely bogus
        _fNoTime = TRUE;
        dwTotal = dwCompleted + (dwCompleted >> 3);  // fudge dwTotal forward a bit
        TraceMsg(TF_PROGRESS, "!! (Total < Completed), fudging Total work to = %lu", dwTotal);
    }

    if(dwCompleted <= _dwPrevCompleted)
    {
        // woah, we are going backwards, we dont deal w/ negative or zero rates so...
        dwCurrentRate = (_dwPrevRate ? _dwPrevRate : 2);
    }
    else
    {
        // calculate the current rate in points per tenth of a second
        dwTickDelta /= 100;
        if (0 == dwTickDelta)
            dwTickDelta = 1; // Protect from divide by zero

        dwCurrentRate = (dwCompleted - _dwPrevCompleted) / dwTickDelta;
    }

    TraceMsg(TF_PROGRESS, "Current rate = %lu", dwCurrentRate);
    TraceMsg(TF_PROGRESS, "Prev.   rate = %lu", _dwPrevRate);

    // time remaining in seconds (we take a REAL average to smooth out random fluxuations)
    DWORD dwAverageRate = (DWORD)((dwCurrentRate + (_int64)_dwPrevRate * _iNumTimesSetProgressCalled) / (_iNumTimesSetProgressCalled + 1));
    TraceMsg(TF_PROGRESS, "Average rate= %lu", dwAverageRate);

    dwAverageRate = MAX(dwAverageRate, 1); // Protect from divide by zero

    dwSecondsLeft = (dwLeft / dwAverageRate) / 10;
    TraceMsg(TF_PROGRESS, "Seconds left = %lu", dwSecondsLeft);
    TraceMsg(TF_PROGRESS, "");

    // It would be odd to show "1 second left" and then immediately clear it, and to avoid showing 
    // rediculous early estimates, we dont show anything until we have at least 5 data points
    if ((dwSecondsLeft >= MIN_MINTIME4FEEDBACK) && (_iNumTimesSetProgressCalled >= 5))
    {
        // display new estimate of time left
        _SetProgressTimeEst(dwSecondsLeft);
    }

    // set all the _dwPrev stuff for next time
    _dwPrevRate = dwAverageRate;
    _dwPrevTickCount = dwCurrentTickCount;
    _dwPrevCompleted = dwCompleted;

    return S_OK;
}

INT_PTR CALLBACK CProgressDialog::ProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CProgressDialog * ppd = (CProgressDialog *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        ppd = (CProgressDialog *)lParam;
    }

    if (ppd)
        return ppd->_ProgressDialogProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}

// apithk.c entry
STDAPI_(void) ProgressSetMarqueeMode(HWND hwndProgress, BOOL bOn);

void CProgressDialog::_ShowProgressBar(HWND hwnd)
{
    if (hwnd)
    {
        HWND hwndPrgress = GetDlgItem(hwnd, IDD_PROGDLG_PROGRESSBAR);

        ProgressSetMarqueeMode(hwndPrgress, (SPBEGINF_MARQUEEPROGRESS & _spbeginf));

        UINT swp = SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE;

        if (SPBEGINF_NOPROGRESSBAR & _spbeginf)
            swp |= SWP_HIDEWINDOW;
        else
            swp |= SWP_SHOWWINDOW;

        SetWindowPos(hwndPrgress, NULL, 0, 0, 0, 0, swp);
    }
}

BOOL CProgressDialog::_OnInit(HWND hDlg)
{
    //  dont minimize if the caller requests or is modal
    if ((SPINITF_MODAL | SPINITF_NOMINIMIZE) & _spinitf)
    {
        // The caller wants us to remove the Minimize Box or button in the caption bar.
        SHSetWindowBits(hDlg, GWL_STYLE, WS_MINIMIZEBOX, 0);
    }

    _ShowProgressBar(hDlg);
    
    return FALSE;
}

BOOL CProgressDialog::_ProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = TRUE;   // handled

    switch (wMsg)
    {
    case WM_INITDIALOG:
        return _OnInit(hDlg);

    case WM_SHOWWINDOW:
        if (wParam)
        {
            _SetModeless(FALSE);
            ASSERT(_hwndProgress);
            SetAnimation(_hInstAnimation, _idAnimation);

            // set the initial text values
            if (_pwzTitle)  
                SetTitle(_pwzTitle);
            if (_pwzLine1)  
                SetLine(1, _pwzLine1, FALSE, NULL);
            if (_pwzLine2)  
                SetLine(2, _pwzLine2, FALSE, NULL);
            if (_pwzLine3)  
                SetLine(3, _pwzLine3, FALSE, NULL);
        }
        break;

    case WM_DESTROY:
        _SetModeless(TRUE);
        if (_hwndDlgParent)
        {
            if (SHIsChildOrSelf(_hwndProgress, GetFocus()))
                SetForegroundWindow(_hwndDlgParent);
        }
        break;

    case WM_ENABLE:
        if (wParam)
        {
            // we assume that we were previously disabled and thus restart our tick counter
            // because we also naively assume that no work was being done while we were disabled
            _dwPrevTickCount = GetTickCount();
        }

        _PauseAnimation(wParam == 0);
        break;

    case WM_TIMER:
        if (wParam == ID_SHOWTIMER)
        {
            KillTimer(hDlg, ID_SHOWTIMER);

            _DisplayDialog();
 
            _dwFirstShowTime = GetTickCount();
        }
        break;

    case WM_COMMAND:
        if (IDCANCEL == GET_WM_COMMAND_ID(wParam, lParam))
            _UserCancelled();
        break;

    case PDM_SHUTDOWN:
        // Make sure this window is shown before telling the user there
        // is a problem.  Ignore FOF_NOERRORUI here because of the 
        // nature of the situation
        MLShellMessageBox(hDlg, MAKEINTRESOURCE(IDS_CANTSHUTDOWN), NULL, (MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND));
        break;


    case PDM_TERMTHREAD:
        // a dummy id that we can take so that folks can post to us and make
        // us go through the main loop
        break;

    case WM_SYSCOMMAND:
        switch(wParam)
        {
        case SC_MINIMIZE:
            _fMinimized = TRUE;
            break;
        case SC_RESTORE:
            SetTitle(_pwzTitle);    // Restore title to original text.
            _fMinimized = FALSE;
            break;
        }
        fHandled = FALSE;
        break;

    case PDM_UPDATE:
        if (!_fCancel && IsWindowEnabled(hDlg))
        {
            _SetProgressTime();
            _UpdateProgressDialog();
        }
        // we are done processing the update
        _fChangePosted = FALSE;
        break;

    case WM_QUERYENDSESSION:
        // Post a message telling the dialog to show the "We can't shutdown now"
        // dialog and return to USER right away, so we don't have to worry about
        // the user not clicking the OK button before USER puts up its "this
        // app didn't respond" dialog
        PostMessage(hDlg, PDM_SHUTDOWN, 0, 0);

        // Make sure the dialog box procedure returns FALSE
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
        return(TRUE);

    default:
        fHandled = FALSE;   // Not handled
    }

    return fHandled;
}


// This is used to asyncronously update the progess dialog.
void CProgressDialog::_AsyncUpdate(void)
{
    if (!_fChangePosted && _hwndProgress)   // Prevent from posting too many messages.
    {
        // set the flag first because with async threads
        // the progress window could handle it and clear the
        // bit before we set it.. then we'd lose further messages
        // thinking that one was still pending
        _fChangePosted = TRUE;
        if (!PostMessage(_hwndProgress, PDM_UPDATE, 0, 0))
        {
            _fChangePosted = FALSE;
        }
    }
}

void CProgressDialog::_UpdateProgressDialog(void)
{
    if (_fTotalChanged)
    {
        _fTotalChanged = FALSE;
        if (0x80000000 & _dwTotal)
            _fScaleBug = TRUE;
            
        SendMessage(GetDlgItem(_hwndProgress, IDD_PROGDLG_PROGRESSBAR), PBM_SETRANGE32, 0, (_fScaleBug ? (_dwTotal >> 1) : _dwTotal));
    }

    if (_fCompletedChanged)
    {
        _fCompletedChanged = FALSE;
        SendMessage(GetDlgItem(_hwndProgress, IDD_PROGDLG_PROGRESSBAR), PBM_SETPOS, (WPARAM) (_fScaleBug ? (_dwCompleted >> 1) : _dwCompleted), 0);
    }
}

void CProgressDialog::_PauseAnimation(BOOL bStop)
{
    // only called from within the hwndProgress wndproc so assum it's there
    if (_hwndProgress)
    {
        if (bStop)
        {
            Animate_Stop(GetDlgItem(_hwndProgress, IDD_PROGDLG_ANIMATION));
        }
        else
        {
            Animate_Play(GetDlgItem(_hwndProgress, IDD_PROGDLG_ANIMATION), -1, -1, -1);
        }
    }
}

void CProgressDialog::_UserCancelled(void)
{
    // Don't hide the dialog because the caller may not pole
    // ::HasUserCancelled() for quite a while.
    // ShowWindow(hDlg, SW_HIDE);
    _fCancel = TRUE;

    // give minimal feedback that the cancel click was accepted
    EnableWindow(GetDlgItem(_hwndProgress, IDCANCEL), FALSE);

    // If the user cancels, Line 1 & 2 will be cleared and Line 3 will get this msg.
    if (!_pwzCancelMsg)
    {
        WCHAR wzDefaultMsg[MAX_PATH];

        LoadStringW(MLGetHinst(), IDS_DEFAULT_CANCELPROG, wzDefaultMsg, ARRAYSIZE(wzDefaultMsg));
        Str_SetPtr(&_pwzCancelMsg, wzDefaultMsg);
    }

    SetLine(1, L"", FALSE, NULL);
    SetLine(2, L"", FALSE, NULL);
    SetLine(3, _pwzCancelMsg, FALSE, NULL);
}

HRESULT CProgressDialog::Initialize(SPINITF flags, LPCWSTR pszTitle, LPCWSTR pszCancel)
{
    if (!_fInitialized)
    {
        _spinitf = flags;
        if (pszTitle)
            SetTitle(pszTitle);
        if (pszCancel)
            SetCancelMsg(pszCancel, NULL);

        _fInitialized = TRUE;

        return S_OK;
    }
    
    return E_UNEXPECTED;
}

void CProgressDialog::_SetModeless(BOOL fModeless)
{
    // if the user is requesting a modal window, disable the parent now.
    if (_spinitf & SPINITF_MODAL)
    {
        if (FAILED(IUnknown_EnableModless(_punkSite, fModeless))
        && _hwndDlgParent)
        {
            EnableWindow(_hwndDlgParent, fModeless);
        }
    }
}

HRESULT CProgressDialog::_BeginAction(SPBEGINF flags)
{
    _spbeginf = flags;

    _fTermThread = FALSE;
    _fTotalChanged = TRUE;

    if (!_fThreadRunning)
    {
        SHCreateThread(CProgressDialog::ThreadProc, this, CTF_FREELIBANDEXIT, CProgressDialog::SyncThreadProc);
        //  _fThreadRunning is set in _SyncThreadProc()
    }

    if (_fThreadRunning)
    {
        _fInAction = TRUE;
        _ShowProgressBar(_hwndProgress);

        // initialize the _dwPrev counters
        _dwPrevRate = 0;
        _dwPrevCompleted = 0;
        _dwPrevTickCount = GetTickCount();

        TraceMsg(TF_PROGRESS, "Initial tick count = %lu", _dwPrevTickCount);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

#define ACTIONENTRY(a, dll, id)     {a, dll, id}

#define c_szShell32 "shell32.dll"
#define c_szShdocvw "shdocvw.dll"
const static struct
{
    SPACTION action;
    LPCSTR pszDll;
    UINT id;
}
c_spActions[] =
{
    ACTIONENTRY(SPACTION_MOVING, c_szShell32,   160),           // IDA_FILEMOVE
    ACTIONENTRY(SPACTION_COPYING, c_szShell32,   161),          // IDA_FILECOPY
    ACTIONENTRY(SPACTION_RECYCLING, c_szShell32,   162),        // IDA_FILEDEL
    ACTIONENTRY(SPACTION_APPLYINGATTRIBS, c_szShell32,   165),  // IDA_APPLYATTRIBS
    ACTIONENTRY(SPACTION_DOWNLOADING, c_szShdocvw, 0x100),
    ACTIONENTRY(SPACTION_SEARCHING_INTERNET, c_szShell32, 166), // IDA_ISEARCH
    ACTIONENTRY(SPACTION_SEARCHING_FILES, c_szShell32, 150)     // IDA_SEARCH
};

HRESULT CProgressDialog::Begin(SPACTION action, SPBEGINF flags)
{
    if (_fInAction || !_fInitialized)
        return E_FAIL;

    HRESULT hr = S_OK;

    for (int i = 0; i < ARRAYSIZE(c_spActions); i++)
    {
        if (c_spActions[i].action == action)
        {
            HINSTANCE hinst = LoadLibraryA(c_spActions[i].pszDll);
            if (hinst)
            {
                hr = SetAnimation(hinst, c_spActions[i].id);

                if (_hinstFree)
                    FreeLibrary(_hinstFree);

                _hinstFree = hinst;
            }
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!_hwndDlgParent)
            IUnknown_GetWindow(_punkSite, &_hwndDlgParent);
            
        hr = _BeginAction(flags);
    }

    return hr;
}

#define SPINIT_MASK         (SPINITF_MODAL | SPINITF_NOMINIMIZE)
#define SPBEGIN_MASK        0x1F

// IProgressDialog

HRESULT CProgressDialog::StartProgressDialog(HWND hwndParent, IUnknown * punkNotUsed, DWORD dwFlags, LPCVOID pvResevered)
{
    if (_fInAction)
        return S_OK;

    HRESULT hr = Initialize(dwFlags & SPINIT_MASK, NULL, NULL);

    if (SUCCEEDED(hr))
    {
        _fNoTime = dwFlags & PROGDLG_NOTIME;

        // we dont Save punkNotUsed 
        _hwndDlgParent = hwndParent;
        hr = _BeginAction(dwFlags & SPBEGIN_MASK);
    }    

    return hr;
}

HRESULT CProgressDialog::End()
{
    ASSERT(_fInitialized && _fInAction);
    //  possibly need to pop stack or change state
    _fInAction = FALSE;
    _spbeginf = 0;

    return S_OK;
}

HRESULT CProgressDialog::Stop()
{
    ASSERT(!_fInAction);
    BOOL fFocusParent = FALSE; 
    
    // shut down the progress dialog
    if (_fThreadRunning)
    {
        ASSERT(_hwndProgress);

        _fTermThread = TRUE;
        PostMessage(_hwndProgress, PDM_TERMTHREAD, 0, 0);
    }
    return S_OK;
}

HRESULT CProgressDialog::StopProgressDialog(void)
{
    //  callers can call this over and over
    if (_fInAction)
        End();
    return Stop();
}

HRESULT CProgressDialog::SetTitle(LPCWSTR pwzTitle)
{
    HRESULT hr = S_OK;

    // Does the dialog exist?
    if (_hwndProgress)
    {
        // Yes, so put the value directly into the dialog.
        if (!SetWindowTextW(_hwndProgress, (pwzTitle ? pwzTitle : L"")))
            hr = E_FAIL;
    }
    else
        Str_SetPtrW(&_pwzTitle, pwzTitle);

    return hr;
}

HRESULT CProgressDialog::SetAnimation(HINSTANCE hInstAnimation, UINT idAnimation)
{
    HRESULT hr = S_OK;

    _hInstAnimation = hInstAnimation;
    _idAnimation = idAnimation;

    // Does the dialog exist?
    if (_hwndProgress)
    {
        if (!Animate_OpenEx(GetDlgItem(_hwndProgress, IDD_PROGDLG_ANIMATION), _hInstAnimation, IntToPtr(_idAnimation)))
            hr = E_FAIL;
    }

    return hr;
}

    
HRESULT CProgressDialog::UpdateText(SPTEXT sptext, LPCWSTR pszText, BOOL fMayCompact)
{
    if (_fInitialized)
        return SetLine((DWORD)sptext, pszText, fMayCompact, NULL);
    else
        return E_UNEXPECTED;
}
    
HRESULT CProgressDialog::SetLine(DWORD dwLineNum, LPCWSTR pwzString, BOOL fCompactPath, LPCVOID pvResevered)
{
    HRESULT hr = E_INVALIDARG;

    switch (dwLineNum)
    {
    case 1:
        hr = _SetLineHelper(pwzString, &_pwzLine1, IDD_PROGDLG_LINE1, fCompactPath);
        break;
    case 2:
        hr = _SetLineHelper(pwzString, &_pwzLine2, IDD_PROGDLG_LINE2, fCompactPath);
        break;
    case 3:
        if (_spbeginf & SPBEGINF_AUTOTIME)
        {
            // you cant change line3 directly if you want PROGDLG_AUTOTIME, because
            // this is updated by the progress dialog automatically
            // unless we're cancelling
            ASSERT(_fCancel);
            hr = _fCancel ? S_OK : E_INVALIDARG;
            break;
        }
        hr = _SetLineHelper(pwzString, &_pwzLine3, IDD_PROGDLG_LINE3, fCompactPath);
        break;

    default:
        ASSERT(0);
    }

    return hr;
}

HRESULT CProgressDialog::SetCancelMsg(LPCWSTR pwzCancelMsg, LPCVOID pvResevered)
{
    Str_SetPtr(&_pwzCancelMsg, pwzCancelMsg);              // If the user cancels, Line 1 & 2 will be cleared and Line 3 will get this msg.
    return S_OK;
}


HRESULT CProgressDialog::Timer(DWORD dwAction, LPCVOID pvResevered)
{
    HRESULT hr = E_NOTIMPL;

    switch (dwAction)
    {
    case PDTIMER_RESET:
        _dwPrevTickCount = GetTickCount();
        hr = S_OK;
        break;
    }

    return hr;
}

HRESULT CProgressDialog::SetProgress(DWORD dwCompleted, DWORD dwTotal)
{
    DWORD dwTickCount = GetTickCount(); // get the tick count before taking the critical section

    // we grab the crit section in case the UI thread is trying to access
    // _dwCompleted, _dwTotal or _dwLastUpdatedTickCount to do its time update.
    ENTERCRITICAL;
    if (_dwCompleted != dwCompleted)
    {
        _dwCompleted = dwCompleted;
        _fCompletedChanged = TRUE;
    }

    if (_dwTotal != dwTotal)
    {
        _dwTotal = dwTotal;
        _fTotalChanged = TRUE;
    }
 
    if (_fCompletedChanged || _fTotalChanged)
    {
        _dwLastUpdatedTickCount = dwTickCount;
    }

    LEAVECRITICAL;

#ifdef DEBUG
    if (_dwCompleted > _dwTotal)
    {
        TraceMsg(TF_WARNING, "CProgressDialog::SetProgress(_dwCompleted > _dwTotal ?!?!)");
    }
#endif

    if (_fCompletedChanged || _fTotalChanged)
    {
        // something changed, so update the progress dlg
        _AsyncUpdate();
    }

    TraceMsg(TF_PROGRESS, "CProgressDialog::SetProgress(Complete=%#08lx, Total=%#08lx)", dwCompleted, dwTotal);
    if (_fMinimized)
    {
        _SetTitleBarProgress(dwCompleted, dwTotal);
    }

    return S_OK;
}

HRESULT CProgressDialog::UpdateProgress(ULONGLONG ulCompleted, ULONGLONG ulTotal)
{
    if (_fInitialized && _fInAction)
        return SetProgress64(ulCompleted, ulTotal);
    else
        return E_UNEXPECTED;
}


HRESULT CProgressDialog::SetProgress64(ULONGLONG ullCompleted, ULONGLONG ullTotal)
{
    ULARGE_INTEGER uliCompleted, uliTotal;
    uliCompleted.QuadPart = ullCompleted;
    uliTotal.QuadPart = ullTotal;

    // If we are using the top 32 bits, scale both numbers down.
    // Note that I'm using the attribute that dwTotalHi is always
    // larger than dwCompletedHi
    ASSERT(uliTotal.HighPart >= uliCompleted.HighPart);
    while (uliTotal.HighPart)
    {
        uliCompleted.QuadPart >>= 1;
        uliTotal.QuadPart >>= 1;
    }

    ASSERT((0 == uliCompleted.HighPart) && (0 == uliTotal.HighPart));       // Make sure we finished scaling down.
    return SetProgress(uliCompleted.LowPart, uliTotal.LowPart);
}

HRESULT CProgressDialog::_SetTitleBarProgress(DWORD dwCompleted, DWORD dwTotal)
{
    TCHAR szTemplate[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    int nPercent = 0;

    if (dwTotal)    // Disallow divide by zero.
    {
        // Will scaling it up cause a wrap?
        if ((100 * 100) <= dwTotal)
        {
            // Yes, so scale down.
            nPercent = (dwCompleted / (dwTotal / 100));
        }
        else
        {
            // No, so scale up.
            nPercent = ((100 * dwCompleted) / dwTotal);
        }
    }

    LoadString(MLGetHinst(), IDS_TITLEBAR_PROGRESS, szTemplate, ARRAYSIZE(szTemplate));
    wnsprintf(szTitle, ARRAYSIZE(szTitle), szTemplate, nPercent);
    SetWindowText(_hwndProgress, szTitle);

    return S_OK;
}

HRESULT CProgressDialog::ResetCancel()
{
    _fCancel = FALSE;
    if (_pwzLine1)  
        SetLine(1, _pwzLine1, FALSE, NULL);
    if (_pwzLine2)  
        SetLine(2, _pwzLine2, FALSE, NULL);
    if (_pwzLine3)  
        SetLine(3, _pwzLine3, FALSE, NULL);

    return S_OK;
}

HRESULT CProgressDialog::QueryCancel(BOOL * pfCancelled)
{
    *pfCancelled = HasUserCancelled();
    return S_OK;
}

/****************************************************\
    DESCRIPTION:
    This queries the progress dialog for a cancel and yields.
    it also will show the progress dialog if a certain amount of time has passed
    
     returns:
        TRUE      cacnel was pressed, abort the operation
        FALSE     continue
\****************************************************/
BOOL CProgressDialog::HasUserCancelled(void)
{
    if (!_fCancel && _hwndProgress)
    {
        MSG msg;

        // win95 handled messages in here.
        // we need to do the same in order to flush the input queue as well as
        // for backwards compatability.

        // we need to flush the input queue now because hwndProgress is
        // on a different thread... which means it has attached thread inputs
        // inorder to unlock the attached threads, we need to remove some
        // sort of message until there's none left... any type of message..
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (!IsDialogMessage(_hwndProgress, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        if (_fTotalChanged || _fCompletedChanged)
            _AsyncUpdate();
    }

    return _fCancel;
}

// IOleWindow
HRESULT CProgressDialog::GetWindow(HWND * phwnd)
{
    HRESULT hr = E_FAIL;

    *phwnd = _hwndProgress;
    if (_hwndProgress)
        hr = S_OK;

    return hr;
}

HRESULT CProgressDialog::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CProgressDialog, IProgressDialog),
        QITABENT(CProgressDialog, IActionProgressDialog),
        QITABENT(CProgressDialog, IActionProgress),
        QITABENT(CProgressDialog, IObjectWithSite),
        QITABENT(CProgressDialog, IOleWindow),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CProgressDialog::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CProgressDialog::Release(void)
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    if (_fThreadRunning)
    {
        //  need to keep this thread's ref around
        //  for a while longer to avoid the race 
        //  to destroy this object on the dialog thread
        AddRef();
        ENTERCRITICAL;
        if (_fThreadRunning)
        {
            //  we call addref
            AddRef();
            _fReleaseSelf = TRUE;
        }
        LEAVECRITICAL;
        Stop();
        Release();
    }
    else
        delete this;
        
    return 0;
}

CProgressDialog::CProgressDialog() : _cRef(1)
{
    DllAddRef();

    // ASSERT zero initialized because we can only be created in the heap. (Private destructor)
    ASSERT(!_pwzLine1);
    ASSERT(!_pwzLine2);
    ASSERT(!_pwzLine3);
    ASSERT(!_fCancel);
    ASSERT(!_fTermThread);
    ASSERT(!_fInAction);
    ASSERT(!_hwndProgress);
    ASSERT(!_hwndDlgParent);
    ASSERT(!_fChangePosted);
    ASSERT(!_dwLastUpdatedTimeRemaining);
    ASSERT(!_dwCompleted);
    ASSERT(!_fCompletedChanged);
    ASSERT(!_fTotalChanged);
    ASSERT(!_fMinimized);

    _dwTotal = 1;     // Init to Completed=0, Total=1 so we are at 0%.
}

CProgressDialog::~CProgressDialog()
{
    ASSERT(!_fInAction);
    ASSERT(!_fThreadRunning);

    Str_SetPtrW(&_pwzTitle, NULL);
    Str_SetPtrW(&_pwzLine1, NULL);
    Str_SetPtrW(&_pwzLine2, NULL);
    Str_SetPtrW(&_pwzLine3, NULL);

    if (_hinstFree)
        FreeLibrary(_hinstFree);

    DllRelease();
}

STDAPI CProgressDialog_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    *ppunk = NULL;
    CProgressDialog * pProgDialog = new CProgressDialog();
    if (pProgDialog) 
    {
        *ppunk = SAFECAST(pProgDialog, IProgressDialog *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\rgtreeop.cpp ===
#include "priv.h"
#include "resource.h"
#include "tmschema.h"
#include "uxtheme.h"
#include "uxthemep.h"
#include "mluisupp.h"
#include <oleacc.h>
#include <cowsite.h>
#include <apithk.h>

const struct
{
    TREE_TYPE   type;
    LPCTSTR     name;
} c_aTreeTypes[] =
{
    {TREE_CHECKBOX, TEXT("checkbox")},
    {TREE_RADIO, TEXT("radio")},
    {TREE_GROUP, TEXT("group")}
};

const TCHAR c_szType[]              = TEXT("Type");
const TCHAR c_szText[]              = TEXT("Text");
const TCHAR c_szPlugUIText[]        = TEXT("PlugUIText");
const TCHAR c_szDefaultBitmap[]     = TEXT("Bitmap");
const TCHAR c_szHKeyRoot[]          = TEXT("HKeyRoot");
const TCHAR c_szValueName[]         = TEXT("ValueName");
const TCHAR c_szCheckedValue[]      = TEXT("CheckedValue");
const TCHAR c_szUncheckedValue[]    = TEXT("UncheckedValue");
const TCHAR c_szDefaultValue[]      = TEXT("DefaultValue");
const TCHAR c_szSPIActionGet[]      = TEXT("SPIActionGet");
const TCHAR c_szSPIActionSet[]      = TEXT("SPIActionSet");
const TCHAR c_szCLSID[]             = TEXT("CLSID");
const TCHAR c_szCheckedValueNT[]    = TEXT("CheckedValueNT");
const TCHAR c_szCheckedValueW95[]   = TEXT("CheckedValueW95");
const TCHAR c_szMask[]              = TEXT("Mask");
const TCHAR c_szOffset[]            = TEXT("Offset");
const TCHAR c_szHelpID[]            = TEXT("HelpID");
const TCHAR c_szWarning[]           = TEXT("WarningIfNotDefault");


#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define NUM_BITMAPS     5
#define MAX_KEY_NAME    64

DWORD RegTreeType(LPCTSTR pszType);
BOOL AppendStatus(LPTSTR pszText, UINT cbText, BOOL fOn);
BOOL IsScreenReaderEnabled();

class CRegTreeOptions : public IRegTreeOptions, public CObjectWithSite
{
public:
    CRegTreeOptions();
    IUnknown *GetUnknown() { return SAFECAST(this, IRegTreeOptions*); }

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
   
    // IRegTreeOptions Methods
    STDMETHODIMP InitTree(HWND hwndTree, HKEY hkeyRoot, LPCSTR pszRegKey, LPCSTR pszParam);
    STDMETHODIMP WalkTree(WALK_TREE_CMD cmd);
    STDMETHODIMP ShowHelp(HTREEITEM hti, DWORD dwFlags);
    STDMETHODIMP ToggleItem(HTREEITEM hti);

protected:
    ~CRegTreeOptions();

    void    _RegEnumTree(HUSKEY huskey, HTREEITEM htviparent, HTREEITEM htvins);
    int     _DefaultIconImage(HUSKEY huskey, int iImage);
    DWORD   _GetCheckStatus(HUSKEY huskey, BOOL *pbChecked, BOOL bUseDefault);
    DWORD   _GetSetByCLSID(REFCLSID clsid, BOOL *pbData, BOOL fGet);
    DWORD   _GetSetByRegKey(HUSKEY husKey, DWORD *pType, LPBYTE pData, DWORD *pcbData, REG_CMD cmd);
    DWORD   _RegGetSetSetting(HUSKEY husKey, DWORD *pType, LPBYTE pData, DWORD *pcbData, REG_CMD cmd);
    BOOL    _WalkTreeRecursive(HTREEITEM htvi,WALK_TREE_CMD cmd);
    DWORD   _SaveCheckStatus(HUSKEY huskey, BOOL bChecked);
    BOOL    _RegIsRestricted(HUSKEY hussubkey);
    UINT        _cRef;
    HWND        _hwndTree;
    LPTSTR      _pszParam;
    HIMAGELIST  _hIml;
};

//////////////////////////////////////////////////////////////////////////////
//
// CRegTreeOptions Object
//
//////////////////////////////////////////////////////////////////////////////

STDAPI CRegTreeOptions_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    TraceMsg(DM_TRACE, "rto - CreateInstance(...) called");
    
    CRegTreeOptions *pTO = new CRegTreeOptions();
    if (pTO)
    {
        *ppunk = pTO->GetUnknown();
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

CRegTreeOptions::CRegTreeOptions() 
{
    TraceMsg(DM_TRACE, "rto - CRegTreeOptions() called.");
    _cRef = 1;
    DllAddRef();
}       

CRegTreeOptions::~CRegTreeOptions()
{
    ASSERT(_cRef == 0);                 // should always have zero
    TraceMsg(DM_TRACE, "rto - ~CRegTreeOptions() called.");

    Str_SetPtr(&_pszParam, NULL);
                
    DllRelease();
}    

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CRegTreeOptions::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CRegTreeOptions, IRegTreeOptions),        // IID_IRegTreeOptions
        QITABENT(CRegTreeOptions, IObjectWithSite),        // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CRegTreeOptions::AddRef()
{
    TraceMsg(DM_TRACE, "rto - AddRef() called.");
    
    return ++_cRef;
}

ULONG CRegTreeOptions::Release()
{

    TraceMsg(DM_TRACE, "rto - Release() called.");
    
    if (--_cRef)
        return _cRef;

    // destroy the imagelist
    if (_hwndTree)
    {
        ImageList_Destroy(TreeView_SetImageList(_hwndTree, NULL, TVSIL_NORMAL));

        // Clean up the accessibility stuff
        RemoveProp(_hwndTree, TEXT("MSAAStateImageMapCount"));
        RemoveProp(_hwndTree, TEXT("MSAAStateImageMapAddr"));
    }

    delete this;
    return 0;   
}


//////////////////////////////////
//
// IRegTreeOptions Methods...
//

//
//  Accessibility structure so it knows how to convert treeview state images
//  into accessibility roles and states.
//
struct MSAASTATEIMAGEMAPENT
{
    DWORD dwRole;
    DWORD dwState;
};

const struct MSAASTATEIMAGEMAPENT c_rgimeTree[] =
{
  { ROLE_SYSTEM_CHECKBUTTON, STATE_SYSTEM_CHECKED }, // IDCHECKED
  { ROLE_SYSTEM_CHECKBUTTON, 0 },                    // IDUNCHECKED
  { ROLE_SYSTEM_RADIOBUTTON, STATE_SYSTEM_CHECKED }, // IDRADIOON
  { ROLE_SYSTEM_RADIOBUTTON, 0 },                    // IDRADIOOFF
  { ROLE_SYSTEM_OUTLINE, 0 },                        // IDUNKNOWN
};

HBITMAP CreateDIB(HDC h, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}

HRESULT CRegTreeOptions::InitTree(HWND hwndTree, HKEY hkeyRoot, LPCSTR pszRegKey, LPCSTR pszParam)
{
    // all callers pass HKEY_LOCAL_MACHINE, yay what a cool interface
    // assert that this is so, since the HUSKEY code now relies on being able to switch between
    // HKCU and HKLM.
    ASSERT(hkeyRoot == HKEY_LOCAL_MACHINE);
    
    TCHAR szParam[MAX_URL_STRING];
    TraceMsg(DM_TRACE, "rto - InitTree called().");
    UINT flags = ILC_MASK | (IsOS(OS_WHISTLERORGREATER)?ILC_COLOR32:ILC_COLOR);

    if (!hkeyRoot || !pszRegKey)
        return E_INVALIDARG;

    if (pszParam)
    {
        SHAnsiToTChar(pszParam, szParam, ARRAYSIZE(szParam));
        Str_SetPtr(&_pszParam, szParam);      // be sure to free in destructor
    }
    
    _hwndTree = hwndTree;
    if(IS_WINDOW_RTL_MIRRORED(_hwndTree))
    {
        flags |= ILC_MIRROR;
    }
    _hIml = ImageList_Create(BITMAP_WIDTH, BITMAP_HEIGHT, flags, NUM_BITMAPS, 4);

    // Initialize the tree view window.
    SHSetWindowBits(_hwndTree, GWL_STYLE, TVS_CHECKBOXES, 0);

    HBITMAP hBitmap = 0;

#ifdef UNIX
    // IEUNIX (Varma): an ugly hack to workaround _AddMasked api problems while
    // creating masked bitmaps.  Need to create DIBSection from 
    // CreateMappedBitmap.  This is to fix buttons visibility on mono when black
    if (SHGetCurColorRes() < 2) 
    {
        hBitmap = CreateMappedBitmap(g_hinst, IDB_BUTTONS, CMB_MASKED, NULL, 0);
        if (hBitmap)
        {
            ImageList_Add(_hIml, hBitmap, NULL);
            // Delete hBitmap in common further down this codepath
        }
    }
    else 
#endif
    {
        HTHEME hTheme = OpenThemeData(NULL, L"Button");
        if (hTheme)
        {
            HDC hdc = CreateCompatibleDC(NULL);
            if (hdc)
            {
                HBITMAP hbmp = CreateDIB(hdc, BITMAP_WIDTH, BITMAP_HEIGHT, NULL);
                if (hbmp)
                {
                    RECT rc = {0, 0, BITMAP_WIDTH, BITMAP_HEIGHT};
                    static const s_rgParts[] = {BP_CHECKBOX,BP_CHECKBOX,BP_RADIOBUTTON,BP_RADIOBUTTON};
                    static const s_rgStates[] = {CBS_CHECKEDNORMAL, CBS_UNCHECKEDNORMAL, RBS_CHECKEDNORMAL, RBS_UNCHECKEDNORMAL};
                    for (int i = 0; i < ARRAYSIZE(s_rgParts); i++)
                    {
                        HBITMAP hOld = (HBITMAP)SelectObject(hdc, hbmp);
                        SHFillRectClr(hdc, &rc, RGB(0,0,0));
                        DTBGOPTS dtbg = {sizeof(DTBGOPTS), DTBG_DRAWSOLID, 0,};   // tell drawthemebackground to preserve the alpha channel

                        DrawThemeBackgroundEx(hTheme, hdc, s_rgParts[i], s_rgStates[i], &rc, &dtbg);
                        SelectObject(hdc, hOld);

                        ImageList_Add(_hIml, hbmp, NULL);
                    }

                    DeleteObject(hbmp);

                    // Hate this. Maybe get an authored icon?
                    hBitmap = CreateMappedBitmap(g_hinst, IDB_GROUPBUTTON, 0, NULL, 0);
                    if (hBitmap)
                    {
                        ImageList_AddMasked(_hIml, hBitmap, CLR_DEFAULT);
                        // Delete hBitmap in common further down the codepath
                    }

                }
                DeleteDC(hdc);
            }
            CloseThemeData(hTheme);
        }
        else
        {
            hBitmap = CreateMappedBitmap(g_hinst, IDB_BUTTONS, 0, NULL, 0);
            if (hBitmap)
            {
                ImageList_AddMasked(_hIml, hBitmap, CLR_DEFAULT);
                // Delete hBitmap in common further down the codepath
            }
        }
    }

    if (hBitmap)
        DeleteObject(hBitmap);

    // Associate the image list with the tree.
    HIMAGELIST himl = TreeView_SetImageList(_hwndTree, _hIml, TVSIL_NORMAL);
    if (himl)
        ImageList_Destroy(himl);

    // Let accessibility know about our state images
    SetProp(_hwndTree, TEXT("MSAAStateImageMapCount"), LongToPtr(ARRAYSIZE(c_rgimeTree)));
    SetProp(_hwndTree, TEXT("MSAAStateImageMapAddr"), (HANDLE)c_rgimeTree);

    HUSKEY huskey;
    if (ERROR_SUCCESS == SHRegOpenUSKeyA(pszRegKey, KEY_READ, NULL, &huskey, FALSE))
    {
        _RegEnumTree(huskey, NULL, TVI_ROOT);
        SHRegCloseUSKey(huskey);
    }

    return S_OK;
}

HRESULT CRegTreeOptions::WalkTree(WALK_TREE_CMD cmd)
{
    HTREEITEM htvi = TreeView_GetRoot(_hwndTree);
    
    // and walk the list of other roots
    while (htvi)
    {
        // recurse through its children
        _WalkTreeRecursive(htvi, cmd);

        // get the next root
        htvi = TreeView_GetNextSibling(_hwndTree, htvi);
    }
    
    return S_OK;    // success?
}

HRESULT _LoadUSRegUIString(HUSKEY huskey, PCTSTR pszValue, PTSTR psz, UINT cch)
{
    psz[0] = 0;

    HRESULT hr = E_FAIL;
    TCHAR szIndirect[MAX_PATH];
    DWORD cb = sizeof(szIndirect);
    if (ERROR_SUCCESS == SHRegQueryUSValue(huskey, pszValue, NULL, szIndirect, &cb, FALSE, NULL, 0))
    {
        hr = SHLoadIndirectString(szIndirect, psz, cch, NULL);
    }
    return hr;
}

HRESULT CRegTreeOptions::ToggleItem(HTREEITEM hti)
{
    TV_ITEM tvi;
    TCHAR szText[MAX_PATH];
    
    tvi.hItem = hti;
    tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_PARAM;
    tvi.pszText = szText;
    tvi.cchTextMax = ARRAYSIZE(szText);
    
    if (hti && TreeView_GetItem(_hwndTree, &tvi))
    {
        BOOL bScreenReaderEnabled = IsScreenReaderEnabled();
        HUSKEY huskey = (HUSKEY)tvi.lParam;

        TCHAR szMsg[512];
        if (SUCCEEDED(_LoadUSRegUIString(huskey, c_szWarning, szMsg, ARRAYSIZE(szMsg))))
        {
            BOOL bDefaultState, bCurrentState = (tvi.iImage == IDCHECKED) || (tvi.iImage == IDRADIOON);

            if (ERROR_SUCCESS == _GetCheckStatus(huskey, &bDefaultState, TRUE))
            {
                // trying to change the current state to the non recomended state?
                if (bDefaultState == bCurrentState)
                {
                    if (MLShellMessageBox(_hwndTree, szMsg, MAKEINTRESOURCE(IDS_WARNING), (MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION)) != IDYES)
                    {
                        return S_FALSE;
                    }
                }
            }
        }

        if (tvi.iImage == IDUNCHECKED)
        {
            tvi.iImage         = IDCHECKED;
            tvi.iSelectedImage = IDCHECKED;
            //See if we need to add status text
            if (bScreenReaderEnabled)
            {
                AppendStatus(szText, ARRAYSIZE(szText), TRUE);
            }
            TraceMsg(TF_GENERAL, "rto::ToggleItem() - Checked!");
        }
        else if (tvi.iImage == IDCHECKED)
        {
            tvi.iImage         = IDUNCHECKED;
            tvi.iSelectedImage = IDUNCHECKED;
            //See if we need to add status text
            if (bScreenReaderEnabled)
            {
                AppendStatus(szText, ARRAYSIZE(szText), FALSE);
            }
            TraceMsg(TF_GENERAL, "rto::ToggleItem() - Unchecked!");
        }
        else if ((tvi.iImage == IDRADIOON) || (tvi.iImage == IDRADIOOFF))
        {
            HTREEITEM htvi;
            TV_ITEM   otvi; // other tvi-s
            TCHAR     szOtext[MAX_PATH];
        
            // change all the "on" radios to "off"
            htvi = TreeView_GetParent(_hwndTree, tvi.hItem);
            htvi = TreeView_GetChild(_hwndTree, htvi);
        
            // hunt for the "on"s
            while (htvi)
            {
                // get info about item
                otvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
                otvi.hItem = htvi;
                otvi.pszText = szOtext;
                otvi.cchTextMax = ARRAYSIZE(szOtext);
                if (TreeView_GetItem(_hwndTree, &otvi))
                {
                    // is it a radio button that is on?
                    if (otvi.iImage == IDRADIOON)
                    {   // yes.. turn it off
                        otvi.iImage         = IDRADIOOFF;
                        otvi.iSelectedImage = IDRADIOOFF;
                        //See if we need to add status text
                        if (bScreenReaderEnabled)
                        {
                            AppendStatus(szOtext,ARRAYSIZE(szOtext), FALSE);
                        }
                
                        TreeView_SetItem(_hwndTree, &otvi);
                    }
                }
            
                // find the next child
                htvi = TreeView_GetNextSibling(_hwndTree, htvi);
            }  
        
            // turn on the item that was hit
            tvi.iImage         = IDRADIOON;
            tvi.iSelectedImage = IDRADIOON;
        
            //See if we need to add status text
            if (bScreenReaderEnabled)
            {
                AppendStatus(szText,ARRAYSIZE(szText), TRUE);
            }
        
        } 
    
        // change only if it is a checkbox or radio item
        if (tvi.iImage <= IDUNKNOWN)
        {
            TreeView_SetItem(_hwndTree, &tvi);
        }
    }
    return S_OK;
}

HRESULT CRegTreeOptions::ShowHelp(HTREEITEM hti, DWORD dwFlags)
{
    TV_ITEM tvi;

    tvi.mask  = TVIF_HANDLE | TVIF_PARAM;
    tvi.hItem = hti;

    if (hti && TreeView_GetItem(_hwndTree, &tvi))
    {
        HUSKEY huskey = (HUSKEY)tvi.lParam;

        TCHAR szHelpID[MAX_PATH+10]; // max path for helpfile + 10 for the help id
        DWORD cbHelpID = sizeof(szHelpID);
    
        if (SHRegQueryUSValue(huskey, c_szHelpID, NULL, szHelpID, &cbHelpID, FALSE, NULL, 0) == ERROR_SUCCESS)
        {
            LPTSTR psz = StrChr(szHelpID, TEXT('#'));
            if (psz)
            {
                DWORD mapIDCToIDH[4];

                *psz++ = 0; // NULL the '#'
        
                mapIDCToIDH[0] = GetDlgCtrlID(_hwndTree);
                mapIDCToIDH[1] = StrToInt(psz);
                mapIDCToIDH[2] = 0;
                mapIDCToIDH[3] = 0;
            
                SHWinHelpOnDemandWrap(_hwndTree, szHelpID, dwFlags, (DWORD_PTR)mapIDCToIDH);
                return S_OK;
            }
        }
    }
    return E_FAIL;
}


int CRegTreeOptions::_DefaultIconImage(HUSKEY huskey, int iImage)
{
    TCHAR szIcon[MAX_PATH + 10];   // 10 = ",XXXX" plus some more
    DWORD cb = sizeof(szIcon);

    if (ERROR_SUCCESS == SHRegQueryUSValue(huskey, c_szDefaultBitmap, NULL, szIcon, &cb, FALSE, NULL, 0))
    {
        LPTSTR psz = StrRChr(szIcon, szIcon + lstrlen(szIcon), TEXT(','));
        ASSERT(psz);   // shouldn't be zero
        if (!psz)
            return iImage;

        *psz++ = 0; // terminate and move over
        int image = StrToInt(psz); // get ID

        HICON hicon = NULL;
        if (!*szIcon)
        {
            hicon = (HICON)LoadIcon(g_hinst, (LPCTSTR)(INT_PTR)image);
        }
        else
        {
            // get the bitmap from the library
            ExtractIconEx(szIcon, (UINT)(-1*image), NULL, &hicon, 1);
            if (!hicon)
                ExtractIconEx(szIcon, (UINT)(-1*image), &hicon, NULL, 1);
                
        }
        
        if (hicon)
        {
            iImage = ImageList_AddIcon(_hIml, (HICON)hicon);

            // NOTE: The docs say you don't need to do a delete object on icons loaded by LoadIcon, but
            // you do for CreateIcon.  It doesn't say what to do for ExtractIcon, so we'll just call it anyway.
            DestroyIcon(hicon);
        }
    }

    return iImage;
}

//
//  The CLSID can either be a service ID (which we will QS for) or a CLSID
//  that we CoCreateInstance.
//
DWORD CRegTreeOptions::_GetSetByCLSID(REFCLSID clsid, BOOL* pbData, BOOL fGet)
{
    IRegTreeItem *pti;
    HRESULT hr;

    if (SUCCEEDED(hr = IUnknown_QueryService(_punkSite, clsid, IID_PPV_ARG(IRegTreeItem, &pti))) ||
        SUCCEEDED(hr = CoCreateInstance(clsid, NULL, CLSCTX_ALL, IID_PPV_ARG(IRegTreeItem, &pti))))
    {
        hr = fGet ? pti->GetCheckState(pbData) : pti->SetCheckState(*pbData);
        pti->Release();
    }
    return SUCCEEDED(hr) ? ERROR_SUCCESS : ERROR_BAD_FORMAT;
}

DWORD CRegTreeOptions::_GetSetByRegKey(HUSKEY husKey, DWORD *pType, LPBYTE pData, DWORD *pcbData, REG_CMD cmd)
{
    // support for masks 
    DWORD dwMask;
    DWORD cb = sizeof(dwMask);
    dwMask = 0xFFFFFFFF;        // Default value
    BOOL fMask = (SHRegQueryUSValue(husKey, c_szMask, NULL, &dwMask, &cb, FALSE, NULL, 0) == ERROR_SUCCESS);
    
    // support for structures
    DWORD dwOffset;
    cb = sizeof(dwOffset);
    dwOffset = 0;               // Default value
    BOOL fOffset = (SHRegQueryUSValue(husKey, c_szOffset, NULL, &dwOffset, &cb, FALSE, NULL, 0) == ERROR_SUCCESS);
    
    HKEY hkRoot = HKEY_CURRENT_USER; // Preinitialize to keep Win64 happy    
    cb = sizeof(DWORD); // DWORD, not sizeof(HKEY) or Win64 will get mad
    DWORD dwError = SHRegQueryUSValue(husKey, c_szHKeyRoot, NULL, &hkRoot, &cb, FALSE, NULL, 0);
    hkRoot = (HKEY) LongToHandle(HandleToLong(hkRoot));
    if (dwError != ERROR_SUCCESS)
    {
        // use default
        hkRoot = HKEY_CURRENT_USER;
    }
    
    // allow "RegPath9x" to override "RegPath" when running on Win9x
    TCHAR szPath[MAX_PATH];
    cb = sizeof(szPath);
    if (!g_fRunningOnNT)
    {
        dwError = SHRegQueryUSValue(husKey, TEXT("RegPath9x"), NULL, szPath, &cb, FALSE, NULL, 0);
        if (ERROR_SUCCESS != dwError)
        {
            cb = sizeof(szPath);
            dwError = SHRegQueryUSValue(husKey, TEXT("RegPath"), NULL, szPath, &cb, FALSE, NULL, 0);
        }
    }
    else
    {
        dwError = SHRegQueryUSValue(husKey, TEXT("RegPath"), NULL, szPath, &cb, FALSE, NULL, 0);
    }

    TCHAR szBuf[MAX_PATH];
    LPTSTR pszPath;
    if (ERROR_SUCCESS == dwError)
    {
        if (_pszParam)
        {
            wnsprintf(szBuf, ARRAYSIZE(szBuf), szPath, _pszParam);
            pszPath = szBuf;
        }
        else
        {
            pszPath = szPath;
        }
    }
    else
    {
        if (cmd == REG_GET)
            return SHRegQueryUSValue(husKey, c_szDefaultValue, pType, pData, pcbData, FALSE, NULL, 0);
        else
            return dwError;
    }
    
    TCHAR szName[MAX_PATH];
    cb = sizeof(szName);
    dwError = SHRegQueryUSValue(husKey, c_szValueName, NULL, szName, &cb, FALSE, NULL, 0);
    if (dwError == ERROR_SUCCESS)
    {
        HKEY hKeyReal;
        DWORD dw;
        
        dwError = RegCreateKeyEx(hkRoot, pszPath, 0, NULL, 0, KEY_READ | KEY_WRITE, NULL, &hKeyReal, &dw);
        if (dwError == ERROR_SUCCESS)
        {
            switch (cmd)
            {
            case REG_SET:
                if (fOffset || fMask)
                {
                    DWORD cbData;
                    
                    // Note: It so happens that the Valuename maynot be in the registry so we
                    // to make sure  that we have the valuename already in the registry.
                    
                    //Try to do a SHRegQueryValue 
                    dwError = SHQueryValueEx(hKeyReal, szName, NULL, NULL, NULL, &cbData);
                    
                    //Does the Value exists ?
                    if (dwError == ERROR_FILE_NOT_FOUND)                   
                    {                        
                        //We dont have the Valuename in the registry so create it.
                        DWORD dwTypeDefault, dwDefault, cbDefault = sizeof(dwDefault);
                        dwError = SHRegQueryUSValue(husKey, c_szDefaultValue, &dwTypeDefault, &dwDefault, &cbDefault, FALSE, NULL, 0);
                        
                        //This should succeed . if not then someone messed up the registry setting
                        if (dwError == ERROR_SUCCESS)
                        {
                            dwError = SHSetValue(hKeyReal, NULL, szName, dwTypeDefault, &dwDefault, cbDefault);
                            
                            //By setting this value we dont have to do the failed (see above) Query again
                            cbData = cbDefault;
                        }
                    }
                    
                    // Now we know for sure  that the value exists in the registry.
                    // Do the usual stuff.
                    
                    // grab the size of the entry
                    if (dwError == ERROR_SUCCESS)
                    {
                        // alloc enough space for it
                        DWORD *pdwData = (DWORD *)LocalAlloc(LPTR, cbData);
                        if (pdwData)
                        {
                            // get the data
                            dwError = SHQueryValueEx(hKeyReal, szName, NULL, pType, pdwData, &cbData);
                            if (dwError == ERROR_SUCCESS && dwOffset < cbData / sizeof(DWORD))
                            {
                                // NOTE: offset defaults to 0 and mask defaults to 0xffffffff, so if there's only
                                // a mask or only an offset, we'll do the right thing
                            
                                *(pdwData + dwOffset) &= ~dwMask;             // clear the bits
                                *(pdwData + dwOffset) |= *((DWORD *)pData);  // set the bits

                                dwError = SHSetValue(hKeyReal, NULL, szName, *pType, pdwData, cbData);
                            }
                            LocalFree(pdwData);
                        }
                        else
                            return ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else
                {
                    dwError = SHSetValue(hKeyReal, NULL, szName, *pType, pData, *pcbData);
                }
                
                break;
                
            case REG_GET:
                // grab the value that we have
                if (fOffset)
                {
                    DWORD cbData;
                    
                    if (SHQueryValueEx(hKeyReal, szName, NULL, NULL, NULL, &cbData) == ERROR_SUCCESS)
                    {
                        DWORD *pdwData = (DWORD*)LocalAlloc(LPTR, cbData);
                        if (pdwData)
                        {
                            dwError = SHQueryValueEx(hKeyReal, szName, NULL, pType, pdwData, &cbData);
                            if (dwOffset < cbData / sizeof(DWORD))
                                *((DWORD *)pData) = *(pdwData + dwOffset);
                            else
                                *((DWORD *)pData) = 0;  // Invalid offset, return something vague
                            *pcbData = sizeof(DWORD);
                            LocalFree(pdwData);
                        }
                        else
                            return ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                else
                {                    
                    dwError = SHQueryValueEx(hKeyReal, szName, NULL, pType, pData, pcbData);
                }
                
                if ((dwError == ERROR_SUCCESS) && fMask)
                {
                    *((DWORD *)pData) &= dwMask;
                }
                break;
            }
            
            RegCloseKey(hKeyReal);
        }
    }
    
    if ((cmd == REG_GET) && (dwError != ERROR_SUCCESS))
    {
        // get the default setting
        dwError = SHRegQueryUSValue(husKey, c_szDefaultValue, pType, pData, pcbData, FALSE, NULL, 0);
    }
    
    return dwError;
}

DWORD CRegTreeOptions::_RegGetSetSetting(HUSKEY husKey, DWORD *pType, LPBYTE pData, DWORD *pcbData, REG_CMD cmd)
{
    UINT uiAction;
    DWORD cbAction = sizeof(uiAction);
    TCHAR szCLSID[80];
    DWORD cbCLSID = sizeof(szCLSID);

    if (cmd == REG_GETDEFAULT)
    {
        return SHRegQueryUSValue(husKey, c_szDefaultValue, pType, pData, pcbData, FALSE, NULL, 0);
    }
    else if (SHRegQueryUSValue(husKey, (cmd == REG_GET) ? c_szSPIActionGet : c_szSPIActionSet,
                NULL, &uiAction, &cbAction, FALSE, NULL, 0) == ERROR_SUCCESS)
    {
        *pcbData = sizeof(DWORD);
        *pType = REG_DWORD;
        SHBoolSystemParametersInfo(uiAction, (DWORD*)pData);
        return ERROR_SUCCESS;
    }
    else if (SHRegQueryUSValue(husKey, c_szCLSID, NULL, &szCLSID, &cbCLSID, FALSE, NULL, 0) == ERROR_SUCCESS)
    {
        *pcbData = sizeof(DWORD);
        *pType = REG_DWORD;

        CLSID clsid;
        GUIDFromString(szCLSID, &clsid);

        return _GetSetByCLSID(clsid, (BOOL*)pData, (cmd == REG_GET));
    }
    else
    {
        return _GetSetByRegKey(husKey, pType, pData, pcbData, cmd);
    }
}

DWORD CRegTreeOptions::_GetCheckStatus(HUSKEY huskey, BOOL *pbChecked, BOOL bUseDefault)
{
    DWORD dwError, cbData, dwType;
    BYTE rgData[32];
    DWORD cbDataCHK, dwTypeCHK;
    BYTE rgDataCHK[32];
    BOOL bCompCHK = TRUE;

    // first, get the setting from the specified location.    
    cbData = sizeof(rgData);
    
    dwError = _RegGetSetSetting(huskey, &dwType, rgData, &cbData, bUseDefault ? REG_GETDEFAULT : REG_GET);
    if (dwError == ERROR_SUCCESS)
    {
        // second, get the value for the "checked" state and compare.
        cbDataCHK = sizeof(rgDataCHK);
        dwError = SHRegQueryUSValue(huskey, c_szCheckedValue, &dwTypeCHK, rgDataCHK, &cbDataCHK, FALSE, NULL, 0);
        if (dwError != ERROR_SUCCESS)
        {
            // ok, we couldn't find the "checked" value, is it because
            // it's platform dependent?
            cbDataCHK = sizeof(rgDataCHK);
            dwError = SHRegQueryUSValue(huskey,
                g_fRunningOnNT ? c_szCheckedValueNT : c_szCheckedValueW95,
                &dwTypeCHK, rgDataCHK, &cbDataCHK, FALSE, NULL, 0);
        }
        
        if (dwError == ERROR_SUCCESS)
        {
            // make sure two value types match.
            if ((dwType != dwTypeCHK) &&
                    (((dwType == REG_BINARY) && (dwTypeCHK == REG_DWORD) && (cbData != 4))
                    || ((dwType == REG_DWORD) && (dwTypeCHK == REG_BINARY) && (cbDataCHK != 4))))
                return ERROR_BAD_FORMAT;
                
            switch (dwType) {
            case REG_DWORD:
                *pbChecked = (*((DWORD*)rgData) == *((DWORD*)rgDataCHK));
                break;
                
            case REG_SZ:
                if (cbData == cbDataCHK)
                    *pbChecked = !lstrcmp((LPTSTR)rgData, (LPTSTR)rgDataCHK);
                else
                    *pbChecked = FALSE;
                    
                break;
                
            case REG_BINARY:
                if (cbData == cbDataCHK)
                    *pbChecked = !memcmp(rgData, rgDataCHK, cbData);
                else
                    *pbChecked = FALSE;
                    
                break;
                
            default:
                return ERROR_BAD_FORMAT;
            }
        }
    }
    
    return dwError;
}

DWORD CRegTreeOptions::_SaveCheckStatus(HUSKEY huskey, BOOL bChecked)
{
    DWORD dwError, cbData, dwType;
    BYTE rgData[32];

    cbData = sizeof(rgData);
    dwError = SHRegQueryUSValue(huskey, bChecked ? c_szCheckedValue : c_szUncheckedValue, &dwType, rgData, &cbData, FALSE, NULL, 0);
    if (dwError != ERROR_SUCCESS)   // was it because of a platform specific value?
    {
        cbData = sizeof(rgData);
        dwError = SHRegQueryUSValue(huskey, bChecked ? (g_fRunningOnNT ? c_szCheckedValueNT : c_szCheckedValueW95) : c_szUncheckedValue,
                                    &dwType, rgData, &cbData, FALSE, NULL, 0);
    }
    if (dwError == ERROR_SUCCESS)
    {
        dwError = _RegGetSetSetting(huskey, &dwType, rgData, &cbData, REG_SET);
    }
    
    return dwError;
}


HTREEITEM Tree_AddItem(HTREEITEM hParent, LPTSTR pszText, HTREEITEM hInsAfter, 
                       int iImage, HWND hwndTree, HUSKEY huskey, BOOL *pbExisted)
{
    HTREEITEM hItem;
    TV_ITEM tvI;
    TV_INSERTSTRUCT tvIns;
    TCHAR szText[MAX_URL_STRING];

    ASSERT(pszText != NULL);
    StrCpyN(szText, pszText, ARRAYSIZE(szText));

    // NOTE:
    //  This code segment is disabled because we only enum explorer
    //  tree in HKCU, so there won't be any duplicates.
    //  Re-able this code if we start to also enum HKLM that could potentially
    //  result in duplicates.
    
    // We only want to add an item if it is not already there.
    // We do this to handle reading out of HKCU and HKLM.
    //
    TCHAR szKeyName[MAX_KEY_NAME];
    
    tvI.mask        = TVIF_HANDLE | TVIF_TEXT;
    tvI.pszText     = szKeyName;
    tvI.cchTextMax  = ARRAYSIZE(szKeyName);
    
    for (hItem = TreeView_GetChild(hwndTree, hParent);
        hItem != NULL;
        hItem = TreeView_GetNextSibling(hwndTree, hItem)
       )
    {
        tvI.hItem = hItem;
        if (TreeView_GetItem(hwndTree, &tvI))
        {
            if (!StrCmp(tvI.pszText, szText))
            {
                // We found a match!
                //
                *pbExisted = TRUE;
                return hItem;
            }
        }
    }

    // Create the item
    tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvI.iImage         = iImage;
    tvI.iSelectedImage = iImage;
    tvI.pszText        = szText;
    tvI.cchTextMax     = lstrlen(szText);

    // lParam contains the HUSKEY for this item:
    tvI.lParam = (LPARAM)huskey;

    // Create insert item
    tvIns.item         = tvI;
    tvIns.hInsertAfter = hInsAfter;
    tvIns.hParent      = hParent;

    // Insert the item into the tree.
    hItem = (HTREEITEM) SendMessage(hwndTree, TVM_INSERTITEM, 0, 
                                    (LPARAM)(LPTV_INSERTSTRUCT)&tvIns);

    *pbExisted = FALSE;
    return (hItem);
}

BOOL _IsValidKey(HKEY hkeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValue)
{
    TCHAR szPath[MAX_PATH];
    DWORD dwType, cbSize = sizeof(szPath);

    if (ERROR_SUCCESS == SHGetValue(hkeyRoot, pszSubKey, pszValue, &dwType, szPath, &cbSize))
    {
        // Zero in the DWORD case or NULL in the string case
        // indicates that this item is not available.
        if (dwType == REG_DWORD)
            return *((DWORD *)szPath) != 0;
        else
            return szPath[0] != 0;
    }

    return FALSE;
}

#define REGSTR_POLICIES_EXPLORER TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")

BOOL CRegTreeOptions::_RegIsRestricted(HUSKEY hussubkey)
{
    HUSKEY huskey;
    BOOL fRet = FALSE;
    // Does a "Policy" Sub key exist?
    if (SHRegOpenUSKey(TEXT("Policy"), KEY_READ, hussubkey, &huskey, FALSE) == ERROR_SUCCESS)
    {
        // Yes; Enumerate this key. The Values are Policy keys or 
        // Full reg paths.
        DWORD cb;
        TCHAR szKeyName[MAX_KEY_NAME];

        for (int i=0; 
            cb = ARRAYSIZE(szKeyName),
            ERROR_SUCCESS == SHRegEnumUSKey(huskey, i, szKeyName, &cb, SHREGENUM_HKLM)
            && !fRet; i++)
        {
            TCHAR szPath[MAXIMUM_SUB_KEY_LENGTH];
            DWORD dwType, cbSize = sizeof(szPath);

            HUSKEY huskeyTemp;
            if (ERROR_SUCCESS == SHRegOpenUSKey(szKeyName, KEY_READ, huskey, &huskeyTemp, FALSE))
            {
                if (ERROR_SUCCESS == SHRegQueryUSValue(huskeyTemp, TEXT("RegKey"), &dwType, szPath, &cbSize, FALSE, NULL, 0))
                {
                    if (_IsValidKey(HKEY_LOCAL_MACHINE, szPath, szKeyName))
                    {
                        fRet = TRUE;
                        break;
                    }
                }
                SHRegCloseUSKey(huskeyTemp);
            }

            // It's not a full Key, try off of policies
            if (_IsValidKey(HKEY_LOCAL_MACHINE, REGSTR_POLICIES_EXPLORER, szKeyName) ||
                _IsValidKey(HKEY_CURRENT_USER, REGSTR_POLICIES_EXPLORER, szKeyName))
            {
                fRet = TRUE;
                break;
            }
        }
        SHRegCloseUSKey(huskey);
    }

    return fRet;
}

void CRegTreeOptions::_RegEnumTree(HUSKEY huskey, HTREEITEM htviparent, HTREEITEM htvins)
{
    TCHAR szKeyName[MAX_KEY_NAME];    
    DWORD cb;
    BOOL bScreenReaderEnabled = IsScreenReaderEnabled();

    // we must search all the sub-keys
    for (int i=0;                    // always start with 0
        cb=ARRAYSIZE(szKeyName),   // string size
        ERROR_SUCCESS == SHRegEnumUSKey(huskey, i, szKeyName, &cb, SHREGENUM_HKLM);
        i++)                    // get next entry
    {
        HUSKEY hussubkey;
        // get more info on the entry
        if (ERROR_SUCCESS == SHRegOpenUSKey(szKeyName, KEY_READ, huskey, &hussubkey, FALSE))
        {
            HUSKEY huskeySave = NULL;

            if (!_RegIsRestricted(hussubkey))
            {
                TCHAR szTemp[MAX_PATH];
                // Get the type of items under this root
                cb = ARRAYSIZE(szTemp);
                if (ERROR_SUCCESS == SHRegQueryUSValue(hussubkey, c_szType, NULL, szTemp, &cb, FALSE, NULL, 0))
                {
                    int     iImage;
                    BOOL    bChecked;
                    DWORD   dwError = ERROR_SUCCESS;

                    // get the type of node
                    DWORD dwTreeType = RegTreeType(szTemp);
                    
                    // get some more info about the this item
                    switch (dwTreeType)
                    {
                        case TREE_GROUP:
                            iImage = _DefaultIconImage(hussubkey, IDUNKNOWN);
                            huskeySave = hussubkey;
                            break;
                    
                        case TREE_CHECKBOX:
                            dwError = _GetCheckStatus(hussubkey, &bChecked, FALSE);
                            if (dwError == ERROR_SUCCESS)
                            {
                                iImage = bChecked ? IDCHECKED : IDUNCHECKED;
                                huskeySave = hussubkey;
                            }
                            break;

                        case TREE_RADIO:
                            dwError = _GetCheckStatus(hussubkey, &bChecked, FALSE);
                            if (dwError == ERROR_SUCCESS)
                            {
                                iImage = bChecked ? IDRADIOON : IDRADIOOFF;
                                huskeySave = hussubkey;
                            }
                            break;

                        default:
                            dwError = ERROR_INVALID_PARAMETER;
                    }

                    if (dwError == ERROR_SUCCESS)
                    {
                        BOOL bItemExisted = FALSE;
                        LPTSTR pszText;

                        // try to get the plugUI enabled text
                        // otherwise we want the old data from a
                        // different value

                        int cch = ARRAYSIZE(szTemp);
                        HRESULT hr = _LoadUSRegUIString(hussubkey, c_szPlugUIText, szTemp, cch);
                        if (SUCCEEDED(hr) && szTemp[0] != TEXT('@'))
                        {
                            pszText = szTemp;
                        }
                        else 
                        {
                            // try to get the old non-plugUI enabled text
                            hr = _LoadUSRegUIString(hussubkey, c_szText, szTemp, cch);
                            if (SUCCEEDED(hr))
                            {
                                pszText = szTemp;
                            }
                            else
                            {
                                // if all else fails, the key name itself
                                // is a little more useful than garbage

                                pszText = szKeyName;
                                cch = ARRAYSIZE(szKeyName);
                            }
                        }

                        //See if we need to add status text
                        if (bScreenReaderEnabled && (dwTreeType != TREE_GROUP))
                        {
                            AppendStatus(pszText, cch, bChecked);
                        }

                        // add root node
                        HTREEITEM htviroot = Tree_AddItem(htviparent, pszText, htvins, iImage, _hwndTree, huskeySave, &bItemExisted);

                        if (bItemExisted)
                            huskeySave = NULL;

                        if (dwTreeType == TREE_GROUP)
                        {
                            HUSKEY huskeySubTree;
                            if (ERROR_SUCCESS == SHRegOpenUSKey(szKeyName, KEY_READ, huskey, &huskeySubTree, FALSE))
                            {
                                _RegEnumTree(huskeySubTree, htviroot, TVI_FIRST);
                                SHRegCloseUSKey(huskeySubTree);
                            }
                        
                            TreeView_Expand(_hwndTree, htviroot, TVE_EXPAND);
                        }
                    } // if (dwError == ERROR_SUCCESS
                }
            }   // if (!_RegIsRestricted(hsubkey))

            if (huskeySave != hussubkey)
                SHRegCloseUSKey(hussubkey);
        }
    }

    // Sort all keys under htviparent
    SendMessage(_hwndTree, TVM_SORTCHILDREN, 0, (LPARAM)htviparent);
}


BOOL CRegTreeOptions::_WalkTreeRecursive(HTREEITEM htvi, WALK_TREE_CMD cmd)
{
    // step through the children
    HTREEITEM hctvi = TreeView_GetChild(_hwndTree, htvi);
    while (hctvi)
    {
        _WalkTreeRecursive(hctvi, cmd);
        hctvi = TreeView_GetNextSibling(_hwndTree, hctvi);
    }

    TV_ITEM tvi = {0};
    // get ourselves
    tvi.mask  = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvi.hItem = htvi;
    TreeView_GetItem(_hwndTree, &tvi);

    HUSKEY huskey;
    switch (cmd)
    {
    case WALK_TREE_DELETE:
        // if we are destroying the tree...
        // do we have something to clean up?
        if (tvi.lParam)
        {
            // close the reg key
            SHRegCloseUSKey((HUSKEY)tvi.lParam);
        }
        break;
    
    case WALK_TREE_SAVE:
        huskey = (HUSKEY)tvi.lParam;
        
        // now save ourselves (if needed)
        // what are we?
        if (tvi.iImage == IDCHECKED || tvi.iImage == IDRADIOON)
        {   
            // checkbox or radio that is checked
            _SaveCheckStatus(huskey, TRUE);
        }
        else if (tvi.iImage == IDUNCHECKED)
        {   
            // checkbox that is unchecked
            _SaveCheckStatus(huskey, FALSE);
        }
        // else radio that is "off" is ignored
        // else icons are ignored
        
        break;
        
    case WALK_TREE_RESTORE:
    case WALK_TREE_REFRESH:
        huskey = (HUSKEY)tvi.lParam;
        if ((tvi.iImage == IDCHECKED)   ||
            (tvi.iImage == IDUNCHECKED) ||
            (tvi.iImage == IDRADIOON)   ||
            (tvi.iImage == IDRADIOOFF))
        {
            BOOL bChecked = FALSE;
            _GetCheckStatus(huskey, &bChecked, cmd == WALK_TREE_RESTORE ? TRUE : FALSE);
            tvi.iImage = (tvi.iImage == IDCHECKED) || (tvi.iImage == IDUNCHECKED) ?
                         (bChecked ? IDCHECKED : IDUNCHECKED) :
                         (bChecked ? IDRADIOON : IDRADIOOFF);
            tvi.iSelectedImage = tvi.iImage;
            TreeView_SetItem(_hwndTree, &tvi);
        }        
        break;
    }

    return TRUE;    // success?
}


DWORD RegTreeType(LPCTSTR pszType)
{
    for (int i = 0; i < ARRAYSIZE(c_aTreeTypes); i++)
    {
        if (!lstrcmpi(pszType, c_aTreeTypes[i].name))
            return c_aTreeTypes[i].type;
    }
    
    return TREE_UNKNOWN;
}

BOOL AppendStatus(LPTSTR pszText,UINT cbText, BOOL fOn)
{
    LPTSTR pszTemp;
    UINT cbStrLen , cbStatusLen;
    
    //if there's no string specified then return
    if (!pszText)
        return FALSE;
    
    //Calculate the string lengths
    cbStrLen = lstrlen(pszText);
    cbStatusLen = fOn ? lstrlen(TEXT("-ON")) : lstrlen(TEXT("-OFF"));
   

    //Remove the old status appended
    pszTemp = StrRStrI(pszText,pszText + cbStrLen, TEXT("-ON"));

    if(pszTemp)
    {
        *pszTemp = (TCHAR)0;
        cbStrLen = lstrlen(pszText);
    }

    pszTemp = StrRStrI(pszText,pszText + cbStrLen, TEXT("-OFF"));

    if(pszTemp)
    {
        *pszTemp = (TCHAR)0;
        cbStrLen = lstrlen(pszText);
    }

    //check if we append status text, we'll explode or not
    if (cbStrLen + cbStatusLen > cbText)    
    {
        //We'll explode 
        return FALSE;
    }

    if (fOn)
    {
        StrCat(pszText, TEXT("-ON"));
    }
    else
    {
        StrCat(pszText, TEXT("-OFF"));
    }
    return TRUE;
}

BOOL IsScreenReaderEnabled()
{
    BOOL bRet = FALSE;
    SystemParametersInfoA(SPI_GETSCREENREADER, 0, &bRet, 0);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\runonnt.c ===
#include "priv.h"

// no wrappers are needed on non-x86 since this is only for win9x interop
#ifdef _X86_

//============================================================================
// This file contains a bunch of Unicode/Ansi thunks to handle calling
// some internal functions that on Windows 95 the strings are Ansi,
// whereas the string on NT are unicode
//============================================================================

// First undefine everything that we are intercepting as to not forward back to us...
#undef ILCreateFromPath
#undef PathCleanupSpec
#undef PathQualify
#undef PathProcessCommand
#undef SHCLSIDFromString
#undef SHGetSpecialFolderPath
#undef SHILCreateFromPath
#undef SHSimpleIDListFromPath
#undef GetFileNameFromBrowse
#undef Win32DeleteFile
#undef PathYetAnotherMakeUniqueName
#undef PathResolve
#undef IsLFNDrive
#undef Shell_GetCachedImageIndex
#undef SHRunControlPanel
#undef PickIconDlg
#undef ILCreateFromPathW
#undef SHCreateDirectory

#if 0
#define TF_THUNK    TF_CUSTOM1
#else
#define TF_THUNK    0
#endif

#define THUNKMSG(psz)   TraceMsg(TF_THUNK, "shdv THUNK::%s", psz)

#ifndef ANSI_SHELL32_ON_UNIX

#ifdef DEBUG
#define UseUnicodeShell32() (g_fRunningOnNT && !(g_dwPrototype & PF_FORCEANSI))
#else
#define UseUnicodeShell32() g_fRunningOnNT
#endif

#else

#define UseUnicodeShell32() (FALSE)

#endif

int _AorW_SHRunControlPanel(LPCTSTR pszOrig_cmdline, HWND errwnd)
{
    if (g_fRunningOnNT)
    {
        WCHAR wzPath[MAX_PATH];

        SHTCharToUnicode(pszOrig_cmdline, wzPath, ARRAYSIZE(wzPath));
        return SHRunControlPanel((LPCTSTR)wzPath, errwnd);
    }
    else
    {
        CHAR szPath[MAX_PATH];

        SHTCharToAnsi(pszOrig_cmdline, szPath, ARRAYSIZE(szPath));
        return SHRunControlPanel((LPCTSTR)szPath, errwnd);
    }
}

int _AorW_Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    if (UseUnicodeShell32())
    {
        WCHAR wzPath[MAX_PATH];

        SHTCharToUnicode(pszIconPath, wzPath, ARRAYSIZE(wzPath));
        return Shell_GetCachedImageIndex((LPCTSTR)wzPath, iIconIndex, uIconFlags);
    }
    else
    {
        CHAR szPath[MAX_PATH];

        SHTCharToAnsi(pszIconPath, szPath, ARRAYSIZE(szPath));
        return Shell_GetCachedImageIndex((LPCTSTR)szPath, iIconIndex, uIconFlags);
    }
}

// the reverse, do it for wide strings also..
int _WorA_Shell_GetCachedImageIndex(LPCWSTR pwzIconPath, int iIconIndex, UINT uIconFlags)
{
    CHAR szPath[MAX_PATH];

    if (!g_fRunningOnNT)
    {
        SHUnicodeToAnsi(pwzIconPath, szPath, ARRAYSIZE(szPath));
        pwzIconPath = (LPCWSTR)szPath;  // overload the pointer to pass through...
    }

    return Shell_GetCachedImageIndex((LPCTSTR)pwzIconPath, iIconIndex, uIconFlags);
}

// Explicit prototype because only the A/W prototypes exist in the headers
STDAPI_(LPITEMIDLIST) ILCreateFromPath(LPCTSTR pszPath);

LPITEMIDLIST _AorW_ILCreateFromPath(LPCTSTR pszPath)
{
    WCHAR wzPath[MAX_PATH];
    CHAR szPath[MAX_PATH];

    THUNKMSG(TEXT("ILCreateFromPath"));

    if (g_fRunningOnNT)
    {
        SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
        pszPath = (LPCTSTR)wzPath;  // overload the pointer to pass through...
    }
    else
    {
        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }

    return ILCreateFromPath(pszPath);
}

int _AorW_PathCleanupSpec(/*IN OPTIONAL*/ LPCTSTR pszDir, /*IN OUT*/ LPTSTR pszSpec)
{
    THUNKMSG(TEXT("PathCleanupSpec"));

    if (g_fRunningOnNT)
    {
        WCHAR wzDir[MAX_PATH];
        WCHAR wzSpec[MAX_PATH];
        LPWSTR pwszDir = wzDir;
        int iRet;

        if (pszDir)
            SHTCharToUnicode(pszDir, wzDir, ARRAYSIZE(wzDir));
        else
            pwszDir = NULL;

        SHTCharToUnicode(pszSpec, wzSpec, ARRAYSIZE(wzSpec));
        iRet = PathCleanupSpec((LPTSTR)pwszDir, (LPTSTR)wzSpec);

        SHUnicodeToTChar(wzSpec, pszSpec, MAX_PATH);
        return iRet;
    }
    else
    {
        CHAR szDir[MAX_PATH];
        CHAR szSpec[MAX_PATH];
        LPSTR pszDir2 = szDir;
        int iRet;

        if (pszDir)
            SHTCharToAnsi(pszDir, szDir, ARRAYSIZE(szDir));
        else
            pszDir2 = NULL;

        SHTCharToAnsi(pszSpec, szSpec, ARRAYSIZE(szSpec));
        iRet = PathCleanupSpec((LPTSTR)pszDir2, (LPTSTR)szSpec);

        SHAnsiToTChar(szSpec, pszSpec, MAX_PATH);
        return iRet;
    }
}

void _AorW_PathQualify(/*IN OUT*/ LPTSTR pszDir)
{
    THUNKMSG(TEXT("PathQualify"));
    if (g_fRunningOnNT)
    {
        WCHAR wszDir[MAX_PATH];

        SHTCharToUnicode(pszDir, wszDir, ARRAYSIZE(wszDir));
        PathQualify((LPTSTR)wszDir);
        SHUnicodeToTChar(wszDir, pszDir, MAX_PATH);
    }
    else
    {
        CHAR szDir[MAX_PATH];

        SHTCharToAnsi(pszDir, szDir, ARRAYSIZE(szDir));
        PathQualify((LPTSTR)szDir);
        SHAnsiToTChar(szDir, pszDir, MAX_PATH);
    }
}

LONG WINAPI _AorW_PathProcessCommand(/*IN*/ LPCTSTR pszSrc, /*OUT*/LPTSTR pszDest, int iDestMax, DWORD dwFlags)
{
    LONG    lReturnValue;

    THUNKMSG(TEXT("PathProcessCommand"));
    if (g_fRunningOnNT)
    {
        WCHAR wszSrc[MAX_PATH];
        WCHAR wszDest[MAX_PATH];

        SHTCharToUnicode(pszSrc, wszSrc, ARRAYSIZE(wszSrc));
        lReturnValue = PathProcessCommand((LPTSTR)wszSrc, (LPTSTR)wszDest, ARRAYSIZE(wszDest), dwFlags);
        SHUnicodeToTChar(wszDest, pszDest, iDestMax);
    }
    else
    {
        CHAR szSrc[MAX_PATH];
        CHAR szDest[MAX_PATH];

        SHTCharToAnsi(pszSrc, szSrc, ARRAYSIZE(szSrc));
        lReturnValue = PathProcessCommand((LPTSTR)szSrc, (LPTSTR)szDest, ARRAYSIZE(szDest), dwFlags);
        SHAnsiToTChar(szDest, pszDest, iDestMax);
    }

    return(lReturnValue);
}

#ifndef UNIX

// Explicit prototype because only the A/W prototypes exist in the headers
STDAPI_(BOOL) SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);

#else

#ifdef UNICODE
#define SHGetSpecialFolderPath SHGetSpecialFolderPathW
#else
#define SHGetSpecialFolderPath SHGetSpecialFolderPathA
#endif

#endif

BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, /*OUT*/ LPTSTR pszPath, int nFolder, BOOL fCreate)
{
    THUNKMSG(TEXT("SHGetSpecialFolderPath"));

    if (g_fRunningOnNT)
    {
        WCHAR wzPath[MAX_PATH];

        BOOL fRet = SHGetSpecialFolderPath(hwndOwner, (LPTSTR)wzPath, nFolder, fCreate);
        if (fRet)
            SHUnicodeToTChar(wzPath, pszPath, MAX_PATH);

        return fRet;
    }
    else
    {
        CHAR szPath[MAX_PATH];

        BOOL fRet = SHGetSpecialFolderPath(hwndOwner, (LPTSTR)szPath, nFolder, fCreate);
        if (fRet)
            SHAnsiToTChar(szPath, pszPath, MAX_PATH);

        return fRet;
    }
}

HRESULT _AorW_SHILCreateFromPath(/*IN OPTIONAL*/LPCTSTR pszPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut)
{
    WCHAR wzPath[MAX_PATH];
    CHAR szPath[MAX_PATH];

    THUNKMSG(TEXT("SHILCreateFromPath"));

    if (pszPath)
    {
        if (g_fRunningOnNT)
        {
            SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
            pszPath = (LPCTSTR)wzPath;  // overload the pointer to pass through...
        }
        else
        {
            SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
            pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
        }
    }

    return SHILCreateFromPath(pszPath, ppidl, rgfInOut);
}

LPITEMIDLIST _AorW_SHSimpleIDListFromPath(/*IN OPTIONAL*/ LPCTSTR pszPath)
{
    WCHAR wzPath[MAX_PATH];
    CHAR szPath[MAX_PATH];

    THUNKMSG(TEXT("SHSimpleIDListFromPath"));

    if (pszPath)
    {
        if (g_fRunningOnNT)
        {
            SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
            pszPath = (LPCTSTR)wzPath;  // overload the pointer to pass through...
        }
        else
        {
            SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
            pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...
        }
    }

    return SHSimpleIDListFromPath(pszPath);
}

#define ISNOT_RESOURCE(pItem)      ((pItem) && HIWORD((pItem)) && LOWORD((pItem)))

int FindDoubleTerminator(LPCTSTR pszStr)
{
    int nIndex = 1;

    // Find the double terminator
    while (pszStr[nIndex] || pszStr[nIndex-1])
        nIndex++;

    return nIndex;
}

#define TEMP_SMALL_BUF_SZ  256

BOOL WINAPI _AorW_GetFileNameFromBrowse(HWND hwnd, /*IN OUT*/ LPTSTR pszFilePath, UINT cchFilePath,
        /*IN OPTIONAL*/ LPCTSTR pszWorkingDir, /*IN OPTIONAL*/ LPCTSTR pszDefExt, 
        /*IN OPTIONAL*/ LPCTSTR pszFilters, /*IN OPTIONAL*/ LPCTSTR pszTitle)
{
    WCHAR wszPath[MAX_PATH];
    WCHAR wszDir[MAX_PATH];
    WCHAR wszExt[TEMP_SMALL_BUF_SZ];
    WCHAR wszTitle[TEMP_SMALL_BUF_SZ];

#ifndef UNICODE
    WCHAR wszFilters[TEMP_SMALL_BUF_SZ*2];
#else // UNICODE
    CHAR szFilters[TEMP_SMALL_BUF_SZ*2];
#endif // UNICODE

    CHAR szPath[MAX_PATH];
    CHAR szDir[MAX_PATH];
    CHAR szExt[TEMP_SMALL_BUF_SZ];
    CHAR szTitle[TEMP_SMALL_BUF_SZ];
    BOOL    bResult;
    THUNKMSG(TEXT("GetFileNameFromBrowse"));

    // thunk strings to unicode 
    if (g_fRunningOnNT)
    {
        // always move pszFilePath stuff to wszPath buffer. Should never be a resourceid.
        SHTCharToUnicode(pszFilePath, wszPath, ARRAYSIZE(wszPath));
        pszFilePath = (LPTSTR)wszPath;

        if (ISNOT_RESOURCE(pszWorkingDir)) //not a resource
        {
            SHTCharToUnicode(pszWorkingDir, wszDir, ARRAYSIZE(wszDir));
            pszWorkingDir = (LPCTSTR)wszDir;
        }
        if (ISNOT_RESOURCE(pszDefExt)) //not a resource
        {
            SHTCharToUnicode(pszDefExt, wszExt, ARRAYSIZE(wszExt));
            pszDefExt = (LPCTSTR)wszExt;
        }
        if (ISNOT_RESOURCE(pszFilters)) //not a resource
        {
#ifndef UNICODE
            int nIndex = FindDoubleTerminator(pszFilters);

            // nIndex+1 looks like bunk unless it goes past the terminator
            MultiByteToWideChar(CP_ACP, 0, (LPCTSTR)pszFilters, nIndex+1, wszFilters, ARRAYSIZE(wszFilters));
            pszFilters = (LPCTSTR)wszFilters;
#endif // UNICODE
        }
        if (ISNOT_RESOURCE(pszTitle)) //not a resource
        {
            SHTCharToUnicode(pszTitle, wszTitle, ARRAYSIZE(wszTitle));
            pszTitle = (LPCTSTR)wszTitle;
        }
    }
    else
    {
        // always move pszFilePath stuff to wszPath buffer. Should never be a resourceid.
        SHTCharToAnsi(pszFilePath, szPath, ARRAYSIZE(szPath));
        pszFilePath = (LPTSTR)szPath;

        if (ISNOT_RESOURCE(pszWorkingDir)) //not a resource
        {
            SHTCharToAnsi(pszWorkingDir, szDir, ARRAYSIZE(szDir));
            pszWorkingDir = (LPCTSTR)szDir;
        }
        if (ISNOT_RESOURCE(pszDefExt)) //not a resource
        {
            SHTCharToAnsi(pszDefExt, szExt, ARRAYSIZE(szExt));
            pszDefExt = (LPCTSTR)szExt;
        }
        if (ISNOT_RESOURCE(pszFilters)) //not a resource
        {
#ifdef UNICODE
            int nIndex = FindDoubleTerminator(pszFilters);

            // nIndex+1 looks like bunk unless it goes past the terminator
            WideCharToMultiByte(CP_ACP, 0, (LPCTSTR)pszFilters, nIndex+1, szFilters, ARRAYSIZE(szFilters), NULL, NULL);
            pszFilters = (LPCTSTR)szFilters;
#endif // UNICODE
        }
        if (ISNOT_RESOURCE(pszTitle)) //not a resource
        {
            SHTCharToAnsi(pszTitle, szTitle, ARRAYSIZE(szTitle));
            pszTitle = (LPCTSTR)szTitle;
        }
    }

    bResult = GetFileNameFromBrowse(hwnd, pszFilePath, cchFilePath, pszWorkingDir, pszDefExt, pszFilters, pszTitle);

    // thunk string back to multibyte
    if (g_fRunningOnNT)
        SHUnicodeToTChar(wszPath, pszFilePath, cchFilePath);
    else
        SHAnsiToTChar(szPath, pszFilePath, cchFilePath);

    return bResult;
}

BOOL _AorW_Win32DeleteFile(/*IN*/ LPCTSTR pszFileName)
{
    WCHAR wzPath[MAX_PATH];
    CHAR szPath[MAX_PATH];

    THUNKMSG(TEXT("Win32DeleteFile"));
    if (g_fRunningOnNT)
    {
        SHTCharToUnicode(pszFileName, wzPath, ARRAYSIZE(wzPath));
        pszFileName = (LPCTSTR)wzPath;  // overload the pointer to pass through...
    }
    else
    {
        SHTCharToAnsi(pszFileName, szPath, ARRAYSIZE(szPath));
        pszFileName = (LPCTSTR)szPath;  // overload the pointer to pass through...
    }

    return Win32DeleteFile(pszFileName);
}

BOOL _AorW_PathYetAnotherMakeUniqueName(LPTSTR pszUniqueName,
                                        LPCTSTR pszPath,
                                        LPCTSTR pszShort,
                                        LPCTSTR pszFileSpec)
{
    THUNKMSG(TEXT("PathYetAnotherMakeUniqueName"));
    if (UseUnicodeShell32())
    {
        WCHAR wszUniqueName[MAX_PATH];
        WCHAR wszPath[MAX_PATH];
        WCHAR wszShort[32];
        WCHAR wszFileSpec[MAX_PATH];
        BOOL fRet;

        SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
        pszPath = (LPCTSTR)wszPath;  // overload the pointer to pass through...

        if (pszShort)
        {
            SHTCharToUnicode(pszShort, wszShort, ARRAYSIZE(wszShort));
            pszShort = (LPCTSTR)wszShort;  // overload the pointer to pass through...
        }

        if (pszFileSpec)
        {
            SHTCharToUnicode(pszFileSpec, wszFileSpec, ARRAYSIZE(wszFileSpec));
            pszFileSpec = (LPCTSTR)wszFileSpec;  // overload the pointer to pass through...
        }

        fRet = PathYetAnotherMakeUniqueName((LPTSTR)wszUniqueName, pszPath, pszShort, pszFileSpec);
        if (fRet)
            SHUnicodeToTChar(wszUniqueName, pszUniqueName, MAX_PATH);

        return fRet;
    }
    else
    {
        CHAR szUniqueName[MAX_PATH];
        CHAR szPath[MAX_PATH];
        CHAR szShort[32];
        CHAR szFileSpec[MAX_PATH];
        BOOL fRet;

        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...

        if (pszShort)
        {
            SHTCharToAnsi(pszShort, szShort, ARRAYSIZE(szShort));
            pszShort = (LPCTSTR)szShort;  // overload the pointer to pass through...
        }

        if (pszFileSpec)
        {
            SHTCharToAnsi(pszFileSpec, szFileSpec, ARRAYSIZE(szFileSpec));
            pszFileSpec = (LPCTSTR)szFileSpec;  // overload the pointer to pass through...
        }

        fRet = PathYetAnotherMakeUniqueName((LPTSTR)szUniqueName, pszPath, pszShort, pszFileSpec);
        if (fRet)
            SHAnsiToTChar(szUniqueName, pszUniqueName, MAX_PATH);

        return fRet;
    }
}

BOOL _AorW_PathResolve(/*IN OUT*/ LPTSTR pszPath, /*IN OPTIONAL*/ LPCTSTR rgpszDirs[], UINT fFlags)
{
    THUNKMSG(TEXT("PathResolve"));
    if (g_fRunningOnNT)
    {
        WCHAR wzPath[MAX_PATH];
        WCHAR wzDir[MAX_PATH];
        BOOL fRet;

        SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));

        if (rgpszDirs && rgpszDirs[0])
        {
            SHTCharToUnicode(rgpszDirs[0], wzDir, ARRAYSIZE(wzDir));
            rgpszDirs[0] = (LPCTSTR)wzDir;  // overload the pointer to pass through...

            if (rgpszDirs[1])
            {
                // Super Hack, we assume dirs has only one element since it's the only case
                // this is called in SHDOCVW.
                AssertMsg(0, TEXT("PathResolve thunk needs to be fixed to handle more than one dirs."));
                rgpszDirs[1] = NULL;
            }
        }

        fRet = PathResolve((LPTSTR)wzPath, rgpszDirs, fFlags);
        if (fRet)
            SHUnicodeToTChar(wzPath, pszPath, MAX_PATH);

        return fRet;
    }
    else
    {
        CHAR szPath[MAX_PATH];
        CHAR szDir[MAX_PATH];
        BOOL fRet;

        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));

        if (rgpszDirs && rgpszDirs[0])
        {
            SHTCharToAnsi(rgpszDirs[0], szDir, ARRAYSIZE(szDir));
            rgpszDirs[0] = (LPCTSTR)szDir;  // overload the pointer to pass through...

            if (rgpszDirs[1])
            {
                // Super Hack, we assume dirs has only one element since it's the only case
                // this is called in SHDOCVW.
                AssertMsg(0, TEXT("PathResolve thunk needs to be fixed to handle more than one dirs."));
                rgpszDirs[1] = NULL;
            }
        }

        fRet = PathResolve((LPTSTR)szPath, rgpszDirs, fFlags);
        if (fRet)
            SHAnsiToTChar(szPath, pszPath, MAX_PATH);

        return fRet;
    }
}


#ifndef UNIX

// Explicit prototype because only the A/W prototypes exist in the headers
BOOL IsLFNDrive(LPCTSTR pszPath);

#else

#ifdef UNICODE
#define IsLFNDrive IsLFNDriveW
#else
#define IsLFNDrive IsLFNDriveA
#endif

#endif


BOOL _AorW_IsLFNDrive(/*IN*/ LPTSTR pszPath)
{
    THUNKMSG(TEXT("IsLFNDrive"));

    if (g_fRunningOnNT)
    {
        WCHAR wszPath[MAX_PATH];

        SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
        return IsLFNDrive((LPTSTR)wszPath);
    }
    else
    {
        CHAR szPath[MAX_PATH];

        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        return IsLFNDrive((LPTSTR)szPath);
    }
}


int _AorW_PickIconDlg(
    IN     HWND  hwnd, 
    IN OUT LPTSTR pszIconPath, 
    IN     UINT  cchIconPath, 
    IN OUT int * piIconIndex)
{
    int nRet;
    WCHAR wszPath[MAX_PATH];
    CHAR szPath[MAX_PATH];
    LPTSTR psz = pszIconPath;
    UINT cch = cchIconPath;
    
    if (g_fRunningOnNT)
    {
        SHTCharToUnicode(pszIconPath, wszPath, ARRAYSIZE(wszPath));
        psz = (LPTSTR)wszPath;  // overload the pointer to pass through...
        cch = SIZECHARS(wszPath);
    }
    else
    {
        SHTCharToAnsi(pszIconPath, szPath, ARRAYSIZE(wszPath));
        psz = (LPTSTR)szPath;  // overload the pointer to pass through...
        cch = SIZECHARS(szPath);
    }

    nRet = PickIconDlg(hwnd, psz, cch, piIconIndex);

    if (g_fRunningOnNT)
        SHUnicodeToTChar(wszPath, pszIconPath, cchIconPath);
    else
        SHAnsiToTChar(szPath, pszIconPath, cchIconPath);

    return nRet;
}

//
//  Now the thunks that allow us to run on Windows 95.
//
//

//
//  This thunks a unicode string to ANSI, but if it's an ordinal, then
//  we just leave it alone.
//
LPSTR Thunk_UnicodeToAnsiOrOrdinal(LPCWSTR pwsz, LPSTR pszBuf, UINT cchBuf)
{
    if (HIWORD64(pwsz)) {
        SHUnicodeToAnsi(pwsz, pszBuf, cchBuf);
        return pszBuf;
    } else {
        return (LPSTR)pwsz;
    }
}

#define THUNKSTRING(pwsz, sz) Thunk_UnicodeToAnsiOrOrdinal(pwsz, sz, ARRAYSIZE(sz))


//
//  This function is new for IE4, so on IE3,
//  we emulate (poorly) with ExtractIcon.
//

//
//  Win95 exported ILCreateFromPathA under the name ILCreateFromPath.
//  Fortunately, NT kept the same ordinal.
//
//
//  If linking with Win95 header files, then call it ILCreateFromPath.
//

#ifdef UNICODE
STDAPI_(LPITEMIDLIST) _ILCreateFromPathA(LPCSTR pszPath)
{
    if (g_fRunningOnNT) {
        WCHAR wszPath[MAX_PATH];
        SHAnsiToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
        return ILCreateFromPath((LPVOID)wszPath);
    } else {
        return ILCreateFromPath((LPVOID)pszPath);
    }
}
#else
STDAPI_(LPITEMIDLIST) _ILCreateFromPathW(LPCWSTR pszPath)
{
    if (g_fRunningOnNT) {
        return ILCreateFromPath((LPVOID)pszPath);
    } else {
        CHAR szPath[MAX_PATH];
        SHUnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        return ILCreateFromPath((LPVOID)szPath);
    }
}
#endif

        
STDAPI_(int) _AorW_SHCreateDirectory(HWND hwnd, LPCTSTR pszPath)
{
    if (g_fRunningOnNT)
    {
        WCHAR wsz[MAX_PATH];

        SHTCharToUnicode(pszPath, wsz, ARRAYSIZE(wsz));
        return SHCreateDirectory(hwnd, (LPCTSTR)wsz);
    }
    else
    {
        CHAR  sz[MAX_PATH];

        SHTCharToAnsi(pszPath, sz, ARRAYSIZE(sz));
        return SHCreateDirectory(hwnd, (LPCTSTR)sz);
    }
}

#ifdef UNICODE

//
//  Either ptsz1 or ptsz2 can be NULL, so be careful when thunking.
//
STDAPI_(int) _AorW_ShellAbout(HWND hWnd, LPCTSTR ptsz1, LPCTSTR ptsz2, HICON hIcon)
{
    if (g_fRunningOnNT)
    {
        return ShellAboutW(hWnd, ptsz1, ptsz2, hIcon);
    }
    else
    {
        CHAR  sz1[MAX_PATH], sz2[MAX_PATH];
        LPSTR psz1, psz2;

        if (ptsz1) {
            psz1 = sz1;
            SHTCharToAnsi(ptsz1, sz1, ARRAYSIZE(sz1));
        } else {
            psz1 = NULL;
        }

        if (ptsz2) {
            psz2 = sz2;
            SHTCharToAnsi(ptsz2, sz2, ARRAYSIZE(sz2));
        } else {
            psz2 = NULL;
        }

        return ShellAboutA(hWnd, psz1, psz2, hIcon);
    }
}

#endif

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\resource.h ===
//------------------------------------------------------------
// M E N U  I D E N T I F I E R S
//------------------------------------------------------------
#include "legacy/mnbandid.h"

#define MENU_BANDSITE1          0x100
#define MENU_BANDSITE2          0x101
// in legacy/mnbandid.h #define MENU_ISFBAND            0x102
#define MENU_WEBBAR             0x103
// (unused)                     0x104
#define MENU_BROWBAND           0x105  // was MENU_IWBBAND
#define MENU_MAILNEWS           0x106
#define MENU_FULL               0x107
#define MENU_ITOOLBAR           0x108
#define MENU_SYSPOPUP           0x109
#define MENU_TEMPLATE           0x10A
#define MENU_PREMERGED          0x10B
#define MENU_DESKBARAPP         0x10C
// in legacy/mnbandid.h #define MENU_MNFOLDERCONTEXT    0x10D
#define MENU_TBMENU             0x10E
#define MENU_SM_CONTEXTMENU     0x10F

#define MENU_AC_CONTEXTMENU     0x112
#define MENU_SCRDEBUG           0x121

#define  RSVIDM_FIRST           0x1
#define  RSVIDM_OPEN            RSVIDM_FIRST+0
#define  RSVIDM_NEWFOLDER       RSVIDM_FIRST+1
#define  RSVIDM_LAST            RSVIDM_NEWFOLDER /* Adjust me if you add new RSVIDM_s. */

#define IDSYSPOPUP_CLOSE        0x1
#define IDSYSPOPUP_FIRST        0x2
#define IDSYSPOPUP_LAST         0x7fff

//--------------------------------------------------------------
// S T R I N G   I D E N T I F I E R S
//--------------------------------------------------------------
#define IDS_CONFIRMCLOSEBAND    0x3000
#define IDS_CONFIRMCLOSEBAR     0x3001
#define IDS_CONFIRMCLOSETITLE   0x3002
#define IDS_CONFIRMCLOSETEXT    0x3003
#define IDS_ALREADYAUTOHIDEBAR  0x3004
#define IDS_WEBBARTITLE         0x3005      // singular
#define IDS_EXPLORING           0x3006

#define IDS_DISCONNECTERROR     0x3007
#define IDS_NETERROR            0x3008
#define IDS_CABINET             0x3009
#define IDS_NOTADIR             0x300A
#define IDS_FWLINK_HELPISLEGAL  0x300B
#define IDS_CANTISFBAND         0x300C

#define IDS_SMALLICONS          0x300D
#define IDS_LARGEICONS          0x300E

#define IDS_TEXTLABELS          0x300F
#define IDS_NOTEXTLABELS        0x3010
#define IDS_PARTIALTEXT         0x3011
#define IDS_WEBBARSTITLE        0x3012      // plural

#define IDS_SHURL_ERR_TITLE                 0x3040
#define IDS_SHURL_ERR_PARSE_FAILED          0x3041
#define IDS_SHURL_ERR_PARSE_NOTALLOWED      0x3042

#ifdef UNIX
#define IDS_SHURL_ERR_NOASSOC               0x3044
#endif

#define IDS_SETHOME_TITLE                   0x3050
#define IDS_SETHOME_TEXT                    0x3051
#define IDS_SETSEARCH_TITLE                 0x3052
#define IDS_SETSEARCH_TEXT                  0x3053

// in legacy/mnbandid.h #define IDS_QLINKS                          0x3061
#define IDS_QLAUNCHAPPDATAPATH              0x3062
#define IDS_NEWFSBANDTITLE                  0x3063
#define IDS_NEWFSBANDCAPTION                0x3064


//// address band strings
#define IDS_ADDRBAND_ACCELLERATOR        0x3100
#define IDS_ADDRBAND_DEVICE_NOTAVAILABLE 0x3101

#define IDS_DESKTOP             0x3140
#define IDS_WINDOWSNT           0x3141

#define IDS_ABOUTWINDOWS        0x3143

#define IDS_TITLE               0x3145
#define IDS_ABOUTWINDOWS9X      0x3146
#define IDS_ABOUTWINDOWSNT      0x3147


/// itbar strings
#define IDS_IE_TB_LABELS        0x3150

#define IDS_WEB_TB_TEXTROWS      0x3161
#define IDS_SHELL_TB_TEXTROWS    0x3162
#define IDS_TB_WIDTH_EXTRA_HIRES 0x3163
#define IDS_TB_WIDTH_EXTRA_LORES 0x3164

#define IDS_SEARCH_BAR_LABELS   0x3166
#define IDS_SHELL_TB_LABELS     0x3167
#define IDS_CACHE_BAR_LABELS    0x3168 // FEATURE: This may not be used any longer

#define IDS_ADDRESS_TB_LABELS   0x3170
#define IDS_GO_TOOLTIP          0x3171
#define IDS_BANDSITE_CLOSE_LABELS 0x3172

#define IDS_EDITPAGE            0x3173
#define IDS_EDITWITH            0x3174

#define IDS_EXCEPTIONMSGSH      0x3175
#define IDS_EXCEPTIONMSG        0x3176
#define IDS_EXCEPTIONNOMEMORY   0x3177
#define IDS_EDITVERB            0x3178



#define IDS_DEF_HOME    998  //// WARNING!!! DO NOT CHANGE THESE VALUES
#define IDS_DEF_SEARCH  999 //// WARNING!!!  INETCPL RELIES ON THEM

#define IDS_QLURL1      0x3200     // URLs for Quicklinks
#define IDS_QLURL2      0x3201     // Important: Assumes all IDs for
#define IDS_QLURL3      0x3202     // QLURLs, QLTEXT, and TBBUTTONS
#define IDS_QLURL4      0x3203     // are consecutive
#define IDS_QLURL5      0x3204

#define IDS_QLTEXT1     0x3210
#define IDS_QLTEXT2     0x3211
#define IDS_QLTEXT3     0x3212
#define IDS_QLTEXT4     0x3213
#define IDS_QLTEXT5     0x3214

#define IDS_ACC_OPEN            0x3232
#define IDS_ACC_CLOSE           0x3233
#define IDS_ACC_EXEC            0x3234
#define IDS_ACC_APP             0x3235
#define IDS_ACC_APPMB           0x3236
#define IDS_ACC_SEP             0x3237
#define IDS_ACC_CHEVRON         0x3238
#define IDS_ACC_ALT             0x3239
#define IDS_CHEVRONTIP          0x3240
#define IDS_CHEVRONTIPTITLE     0x3241


#define IDS_URL_LOGO            0x3250
// in legacy\mnbandid.h #define IDS_EMPTY                0x3251

#define IDS_BAND_ADDRESS         0x3260
#define IDS_BAND_SEARCH          0x3261


#ifdef UNIX
#define IDS_BAND_MESSAGE         0x3265
#endif
#define IDS_BAND_ADDRESS2        0x3266


#define IDS_WORKINGOFFLINETIP   0x3269
#define IDS_WORKINGOFFLINE      0x3270

//unused                        0x3271
#define IDS_ERROR_GOTOA         0x3272
#define IDS_INTERNETOPTIONS     0x3273
#define IDS_MIXEDZONE           0x3274
#define IDS_UNKNOWNZONE         0x3275
#define IDS_CLOSEANYWAY         0x3276
#define IDS_TREETITLE           0x3277
#define IDS_ERROR_GOTOW         0x3278
#define IDS_FOLDEROPTIONS       0x3279

#define IDS_CLOSE               0x3280
#define IDS_MINIMIZE            0x3281
#define IDS_RESTORE             0x3282

#define IDS_CANCELFILEDOWNLOAD      0x3283
#define IDS_FILEDOWNLOADCAPTION     0x3284

#define IDS_CHANNEL                 0x3285
#define IDS_CHANBAR_SHORTCUT_MSG    0x3286
#define IDS_CHANBAR_SHORTCUT_TITLE  0x3287

#define IDS_QUICKCOMPLETE      0x3288

#define IDS_IE_INFOTIP         0x3289
#define IDS_IE_DISPLAYNAME     0x328a

#define IDS_FAVORITEBROWSE     0x3290
#define IDS_FAVORITES          0x3291

#define IDS_FAVS_FOLDER        0x3292
#define IDS_FAVS_BROWSETEXT    0x3293
#define IDS_FAVS_NEWFOLDERBUTTON 0x3294
#define IDS_FAVS_NAME          0x3295
#define IDS_FAVS_ADVANCED      0x3296
// in legacy\mnbandid.h #define IDS_FAVS_ADDTOFAVORITES 0x3297
#define IDS_FAVS_SAVE           0x3298
#define IDS_FAVS_TITLE          0x3299
#define IDS_FAVS_SUBSCRIBE_TEXT 0x329A
#define IDS_FAVS_SUBSCRIBE      0x329B
// in legacy\mnbandid.h #define IDS_FAVS_INVALIDFN      0x329C
#define IDS_FAVS_FNTOOLONG      0x329D
#define IDS_FAVS_MORE           0x329E
#define IDS_FAVS_FILEEXISTS     0x329F

#define IDS_FAV_UNABLETOCREATE  0x33A0
#define IDS_NEED_CHANNEL_PASSWORD     0x33A1

#define IDS_SUBS_UNKNOWN        0x32A2
#define IDS_CHANNELS_FILEEXISTS 0x32A3

#define MH_POPUPS                       700
#define MH_ITEMS                        (800-FCIDM_FIRST)
#define MH_TTBASE                       (MH_ITEMS - (FCIDM_LAST - FCIDM_FIRST))
#define IDS_TT_PREVIOUSFOLDER           (MH_TTBASE+FCIDM_PREVIOUSFOLDER)
#define IDS_TT_NAVIGATEBACK             (MH_TTBASE + FCIDM_NAVIGATEBACK)
#define IDS_TT_NAVIGATEFORWARD          (MH_TTBASE + FCIDM_NAVIGATEFORWARD)
#define IDS_TT_FAVORITES                (MH_TTBASE + FCIDM_ORGANIZEFAVORITES)
#define IDS_TT_ADDTOFAVORITES           (MH_TTBASE + FCIDM_ADDTOFAVORITES)
#define IDS_TT_DRIVES                   0x3215
#define IDS_TT_VIEWTREE                 (MH_TTBASE + FCIDM_VIEWTREE)

#define IDS_SM_SEARCHASSIST         0x32B0  // search menu hard coded search assistant
#define IDS_SM_SEARCHASSIST_HELP    0x32B1
#define IDS_SM_SEARCHCFG            0x32B2  // search menu hard coded configuration
#define IDS_SM_SEARCHCFG_HELP       0x32B3

#define IDS_WARNING                 0x3301
#define IDS_ALLUSER_WARNING         0x3302
#define IDS_ALLUSER_WARNING_TITLE   0x3303

#define IDS_INETFIND_TEXT           0x3304
#define IDS_INETFIND_HELP           0x3305

#define IDS_FORTEZZA_MENU           0x3308
#define IDS_FORTEZZA_LOGIN          0x3309
#define IDS_FORTEZZA_LOGOUT         0x330a
#define IDS_FORTEZZA_CHANGE         0x330b

#define IDS_ELLIPSES                0x3340
#define IDS_SEARCHFOR               0x3341
#define IDS_SEARCHFORCMD            0x3342

#define IDS_NEW_WINDOW              0x3350

#define IDS_ADDRESSBANDTEXT         0x3351
// in legacy\mnbandid.h #define IDS_LINKSBANDTEXT           0x3352
#define IDS_MEDIABANDTEXT           0x3353
#define IDS_MEDIABANDSEARCH         0x3354

#define IDS_MI_BACK_HISTORY         0x3371

// descriptive text to CATIDs, see also shdocvw!
#define IDS_CATDESKBAND             0x3400
#define IDS_CATINFOBAND             0x3401
#define IDS_CATCOMMBAND             0x3402

// media bar

#define FCIDM_MEDIABAND_MUTE            0x3502
#define FCIDM_MEDIABAND_VOLUME          0x3503

#define FCIDM_MEDIABAND_PLAY            0x3505
#define FCIDM_MEDIABAND_STOP            0x3506
#define FCIDM_MEDIABAND_NEXT            0x3508
#define FCIDM_MEDIABAND_PREVIOUS        0x3509
#define FCIDM_MEDIABAND_SEEK            0x350a
#define FCIDM_MEDIABAND_PLAYINFO        0x350b
#define FCIDM_MEDIABAND_POPOUT          0x350c

#define IDM_MEDIA_RADIO_GOTO            0x3524
#define IDM_MEDIA_BROADBAND_GUIDE       0x3529
#define IDM_MEDIA_INTERNET              0x3531
#define IDM_MEDIA_GENERIC               0x3532
#define IDM_MEDIA_FAVORITES             0x3533
#define IDM_MEDIA_FAVORITES_PLACEHOLDER 0x3534

#define IDM_MEDIA_MUSIC_MRU             0x3540

#define IDB_MEDIABAND_BG_BASE           0x351f
#define IDB_MEDIABAND_BG_BC             0x3520
#define IDB_MEDIABAND_BG_BL             0x3521
#define IDB_MEDIABAND_BG_BR             0x3522
#define IDB_MEDIABAND_BG_MC             0x3523
#define IDB_MEDIABAND_BG_ML             0x3524
#define IDB_MEDIABAND_BG_MR             0x3525
#define IDB_MEDIABAND_BG_TC             0x3526
#define IDB_MEDIABAND_BG_TL             0x3527
#define IDB_MEDIABAND_BG_TR             0x3528

#define IDB_MEDIABAND_PLAY              0x3529
#define IDB_MEDIABAND_PAUSE                0x352a
#define IDB_MEDIABAND_BACK               0x352b
#define IDB_MEDIABAND_NEXT               0x352c
#define IDB_MEDIABAND_STOP               0x352d
#define IDB_MEDIABAND_MUTE               0x352e
#define IDB_MEDIABAND_POPOUT               0x3530
#define IDB_MEDIABAND_POPIN             0x3531

#define IDB_MEDIABAND_SEEKFILL          0x3533
#define IDB_MEDIABAND_SEEKBACK         0x3534
#define IDB_MEDIABAND_SEEKGRIPPER      0x3535
#define IDB_MEDIABAND_VOLTAB            0x3536
#define IDB_MEDIABAND_VOLBKGND          0x3537
#define IDB_MEDIABAND_VOLFILL           0x3538


#define IDB_MEDIABAND_PLAY16              0x3539
#define IDB_MEDIABAND_PAUSE16                0x353a
#define IDB_MEDIABAND_BACK16               0x353b
#define IDB_MEDIABAND_NEXT16               0x353c
#define IDB_MEDIABAND_STOP16               0x353d
#define IDB_MEDIABAND_MUTE16               0x353e
#define IDB_MEDIABAND_POPOUT16               0x3540
#define IDB_MEDIABAND_POPIN16             0x3541

#define IDB_MEDIABAND_SEEKFILL16          0x3543
#define IDB_MEDIABAND_SEEKBACK16         0x3544
#define IDB_MEDIABAND_SEEKGRIPPER16      0x3545
#define IDB_MEDIABAND_VOLTAB16            0x3542
#define IDB_MEDIABAND_VOLBKGND16          0x3549
#define IDB_MEDIABAND_VOLFILL16           0x3548


#define IDB_TB_MEDIA_DEFAULT            0x3546 // You should prop any change to selfreg.inx !!!
#define IDB_TB_MEDIA_HOT                0x3547 // You should prop any change to selfreg.inx !!!

#define MENU_MEDIA_GENERIC              0x3551

#define IDD_MEDIA_RESETMIMEPROMPT       0x3558
#define IDD_MEDIA_TAKEOVERMIMEPROMPT    0x3559

#define IDM_MEDIA_ADDTOFAVORITES        0x3561
#define IDM_MEDIA_PLAYINBAR             0x3562
#define IDM_MEDIA_ASKTYPES              0x3563
#define IDM_MEDIA_RESETTYPES            0x3564
#define IDM_MEDIA_TAKEOVERTYPES         0x3565
#define IDM_MEDIA_SETTINGS              0x3568
#define IDM_MEDIA_PLAYINDEFAULT         0x3569
#define IDM_MEDIA_PLAY                  0x356D

#define FCIDM_PLAYITEM_START            0x3570
#define FCIDM_PLAYITEM_END              0x4000

#define FCIDM_MEDIABAND_PLAYALL         0x4001
#define IDS_PLAYALL                     0x4002
#define IDS_MEDIABAND_MYMUSIC           0x4003
#define IDS_MEDIABAND_CHANGEMYMUSIC     0x4004
#define IDS_MEDIABAND_DURATION          0x4005
#define IDS_MEDIABAND_SRC_LABELS        0x4006
#define IDS_MEDIABAND_DOCK                0x4007
#define IDS_MEDIABAND_UNDOCK             0x4008
#define IDS_MEDIABAND_TRACKNUMBER       0x4009
#define IDS_MEDIABAND_PLAY              0x400A
#define IDS_MEDIABAND_PAUSE             0x400B
#define IDS_MEDIABAND_MUTE              0x400C
#define IDS_MEDIABAND_UNMUTE            0x400D
#define IDS_MEDIABAND_NOWDOWNLOADING    0x400E
#define IDS_MEDIABAND_NAVTIMEOUT        0x400F
#define IDS_MEDIABAND_INVALIDFILE       0x401A
#define IDS_MEDIABAND_STOP               0x401d
#define IDS_MEDIABAND_BACK               0x401e
#define IDS_MEDIABAND_NEXT               0x401f
#define IDS_MEDIABAND_NOWMP7TITLE       0x4020
#define IDS_MEDIABAND_NOWMP7            0x4021
#define IDS_MEDIABAND_PLAYING           0x4022

#define IDC_MEDIA_MOREINFO               0x8001

//--------------------------------------------------------------
// B I T M A P    I D E N T I F I E R S
//--------------------------------------------------------------
#define DELTA_HICOLOR           4

#define IDB_IETOOLBAR           0x105
#define IDB_IETOOLBARHOT        0x106
#define IDB_IETOOLBAR16         0x107   // 16 means small (18x16 vs 22x20)
#define IDB_IETOOLBARHOT16      0x108

#define IDB_IETOOLBARHICOLOR    0x109   // hicolors are locolor + 4
#define IDB_IETOOLBARHOTHICOLOR 0x10A
#define IDB_IETOOLBARHICOLOR16  0x10B
#define IDB_IETOOLBARHOTHICOLOR16 0x10C

#define IDB_SHSTD               0x110
#define IDB_SHSTDHOT            0x111
#define IDB_SHSTD16             0x112
#define IDB_SHSTDHOT16          0x113

#define IDB_SHSTDHICOLOR        0x114
#define IDB_SHSTDHOTHICOLOR     0x115
#define IDB_SHSTDHICOLOR16      0x116
#define IDB_SHSTDHOTHICOLOR16   0x117


#define IDB_GO                  0x122
#define IDB_GOHOT               0x123

// Note: shdocvw loads IDB_IEBRAND from browseui when running in design mode.
// Do not change this value without changing the constant in shdocvw\resource.h!!!

#define IDB_IEBRAND             0x130
#define IDB_IESMBRAND           0x131
#define IDB_IEMICROBRAND        0x132

///end bitmaps for itbar

//Bitmap ID for advanced tree options
#define IDB_BUTTONS             0x210
#define IDB_GROUPBUTTON         0x211

#define IDB_THEATERCLOSE        0x220
#define IDB_BROWSERTOOLBAR      0x221

#ifdef UNIX
#define IDB_WHITEBROWSERTOOLBAR  0x232
#endif

#define IDB_SEARCHBANDDEF       0x233
#define IDB_SEARCHBANDHOT       0x234

//---------------------------------------------------------------------
// A C C E L E R A T O R     I D E N T I F I E R S
//---------------------------------------------------------------------
#define ACCEL_MERGE             0x100
#define ACCEL_MERGEEXPLORER     0x101


//---------------------------------------------------------------------
// C O M M A N D    I D E N T I F I E R S
//---------------------------------------------------------------------

#define BSIDM_CLOSEBAND         0x0001
#define BSIDM_SHOWTITLEBAND     0x0002
#define BSIDM_IEAK_DISABLE_DDCLOSE   0x0003 // Disable Both Drag & Drop, and Closing
#define BSIDM_IEAK_DISABLE_MOVE 0x0004      // Disable Moving within a Bar.

#define ISFBIDM_LARGE           0x0001
#define ISFBIDM_SMALL           0x0002
#define ISFBIDM_LOGOS           0x0003
#define ISFBIDM_SHOWTEXT        0x0004
#define ISFBIDM_REFRESH         0x0005
#define ISFBIDM_OPEN            0x0006


#define DBIDM_NEWFOLDERBAND     0x0001
#define DBIDM_DESKTOPBAND       0x0003
#define DBIDM_LAUNCHBAND        0x0004
#define DBIDM_NEWBANDFIXEDLAST  0x0010

// mnfolder context menu commands
// in legacy\mnbandid.h #define MNIDM_RESORT            0x0001
// in legacy\mnbandid.h #define MNIDM_LAST              0x0001

/// appbar (dockbar) specific messages
#define IDM_AB_FIRST        0x1

#define IDM_AB_LEFT         (IDM_AB_FIRST + ABE_LEFT)
#define IDM_AB_TOP          (IDM_AB_FIRST + ABE_TOP)
#define IDM_AB_RIGHT        (IDM_AB_FIRST + ABE_RIGHT)
#define IDM_AB_BOTTOM       (IDM_AB_FIRST + ABE_BOTTOM)

#define IDM_AB_BOTTOMMOST   (IDM_AB_FIRST + 0x4)
#define IDM_AB_TOPMOST      (IDM_AB_FIRST + 0x5)
#define IDM_AB_REGULAR      (IDM_AB_FIRST + 0x6)
#define IDM_AB_AUTOHIDE     (IDM_AB_FIRST + 0x7)

#define IDM_AB_CLOSE        (IDM_AB_FIRST + 0x10)

#define IDM_AB_ENABLEMODELESS   (IDM_AB_FIRST + 0x11)
#define IDM_AB_DISABLEMODELESS  (IDM_AB_FIRST + 0x12)
#define IDM_AB_ACTIVATE     (IDM_AB_FIRST + 0x13)

#define IDM_AB_LAST         (IDM_AB_FIRST + 0x1f)




// normal toolbar commands
#define FCIDM_DROPDRIVELIST     0x100


//---------------------------------------------------------------------------
// Defines for the rc file.
//---------------------------------------------------------------------------

// Commmand ID
#define FCIDM_FIRST             FCIDM_GLOBALFIRST
#define FCIDM_LAST              FCIDM_BROWSERLAST

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_FILE      (FCIDM_BROWSERFIRST+0x0020)
#define FCIDM_FILECLOSE         (FCIDM_BROWSER_FILE+0x0001)
#define FCIDM_PREVIOUSFOLDER    (FCIDM_BROWSER_FILE+0x0002) // shbrowse::EXEC (cannot change)
#define FCIDM_DELETE            (FCIDM_BROWSER_FILE+0x0003)
#define FCIDM_RENAME            (FCIDM_BROWSER_FILE+0x0004)
#define FCIDM_PROPERTIES        (FCIDM_BROWSER_FILE+0x0005)
#define FCIDM_VIEWOFFLINE       (FCIDM_BROWSER_FILE+0x0006)
#define FCIDM_FILENSCBANDSEP    (FCIDM_BROWSER_FILE+0x0007)
#define FCIDM_FILENSCBANDPOPUP  (FCIDM_BROWSER_FILE+0x0008)

// these aren't real menu commands, but they map to accelerators or other things
// IE4 shipped with FCIDM_NEXTCTL as 0xA030 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_NEXTCTL           (FCIDM_BROWSER_FILE+0x0010) // explorer browseui shell32
//                              (FCIDM_BROWSER_FILE+0x0011)  // unused, reclaim
#define FCIDM_BACKSPACE         (FCIDM_BROWSER_FILE+0x0012)

#ifdef TEST_AMBIENTS
#define FCIDM_VIEWLOCALOFFLINE  (FCIDM_BROWSER_FILE+0x0013)
#define FCIDM_VIEWLOCALSILENT   (FCIDM_BROWSER_FILE+0x0014)
#endif // TEST_AMBIENTS

#define FCIDM_FORTEZZA_MENU     (FCIDM_BROWSER_FILE+0x0018)
#define FCIDM_FORTEZZA_LOGIN    (FCIDM_BROWSER_FILE+0x0019)
#define FCIDM_FORTEZZA_LOGOUT   (FCIDM_BROWSER_FILE+0x001a)
#define FCIDM_FORTEZZA_CHANGE   (FCIDM_BROWSER_FILE+0x001b)


//---------------------------------------------------------------------------
#define FCIDM_BROWSER_EDIT      (FCIDM_BROWSERFIRST+0x0040)
#define FCIDM_MOVE              (FCIDM_BROWSER_EDIT+0x0001)
#define FCIDM_COPY              (FCIDM_BROWSER_EDIT+0x0002)
#define FCIDM_PASTE             (FCIDM_BROWSER_EDIT+0x0003)
#define FCIDM_SELECTALL         (FCIDM_BROWSER_EDIT+0x0004)
#define FCIDM_LINK              (FCIDM_BROWSER_EDIT+0x0005)     // create shortcut
#define FCIDM_EDITPAGE          (FCIDM_BROWSER_EDIT+0x0006)

// APPCOMPAT:: IOmega relies on FCIDM_REFRESH was WM_COMMAND of A065
// APPCOMPAT:: shell32 also relies on it - Cabinet_RefreshAll
#define FCIDM_W95REFRESH        (FCIDM_BROWSERFIRST+0x0065) // browseui win95shell32



//---------------------------------------------------------------------------
#define FCIDM_BROWSER_TOOLS     (FCIDM_BROWSERFIRST+0x0080)
#define FCIDM_CONNECT           (FCIDM_BROWSER_TOOLS+0x0001) // shbrowse::EXEC (cannot change)
#define FCIDM_DISCONNECT        (FCIDM_BROWSER_TOOLS+0x0002) // shbrowse::EXEC (cannot change)
#define FCIDM_CONNECT_SEP       (FCIDM_BROWSER_TOOLS+0x0003)
#define FCIDM_GETSTATUSBAR      (FCIDM_BROWSER_TOOLS+0x0004) // shbrowse::EXEC (cannot change)
// IE4 shipped with FCIDM_FINDFILES as 0xA0085 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_FINDFILES         (FCIDM_BROWSER_TOOLS+0x0005) // explorer shdocvw shell32
// IE4 shipped with FCIDM_FINDFILES as 0xA0086 and we can not change it
// because we need to support IE5 browser only on top of IE4 integrated.
#define FCIDM_FINDCOMPUTER      (FCIDM_BROWSER_TOOLS+0x0006) // explorer shdocvw
//                              (FCIDM_BROWSER_TOOLS+0x0008) // unused, reclaim
#define FCIDM_SETSTATUSBAR      (FCIDM_BROWSER_TOOLS+0x0009) // shbrowse::EXEC (cannot change)
#define FCIDM_PERSISTTOOLBAR    (FCIDM_BROWSER_TOOLS+0x0010) // shbrowse::EXEC (cannot change)
//                              (FCIDM_BROWSER_TOOLS+0x0011) // unused, reclaim
#define FCIDM_MAILANDNEWS       (FCIDM_BROWSER_TOOLS+0x0012)
#define FCIDM_OPENWEBFOLDER     (FCIDM_BROWSER_TOOLS+0x0013)

// APPCOMPAT: these overlap the above and below, but it's sort of okay since
// it's a context menu? not really.
#define FCIDM_MENU_TOOLS_FINDFIRST (FCIDM_BROWSER_TOOLS+0x0007)
#define FCIDM_MENU_TOOLS_FINDLAST  (FCIDM_BROWSER_TOOLS+0x0040)

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_HELP      (FCIDM_BROWSERFIRST+0x0100)

#define FCIDM_HELPSEARCH        (FCIDM_BROWSER_HELP+0x0001)
#define FCIDM_HELPABOUT         (FCIDM_BROWSER_HELP+0x0002)
#define FCIDM_HELPTIPOFTHEDAY   (FCIDM_BROWSER_HELP+0x0003)
#define FCIDM_HELPISLEGAL       (FCIDM_BROWSER_HELP+0x0004)
#define FCIDM_HELPNETSCAPEUSERS (DVIDM_HELPMSWEB+11)
#define FCIDM_HELPONLINESUPPORT (DVIDM_HELPMSWEB+4)
#define FCIDM_HELPSENDFEEDBACK  (DVIDM_HELPMSWEB+5)
#define FCIDM_PRODUCTUPDATES    (DVIDM_HELPMSWEB+2)

//----------------------------------------------------------------
#define FCIDM_BROWSER_EXPLORE   (FCIDM_BROWSERFIRST + 0x0120)
#define FCIDM_NAVIGATEBACK      (FCIDM_BROWSER_EXPLORE+0x0001)
#define FCIDM_NAVIGATEFORWARD   (FCIDM_BROWSER_EXPLORE+0x0002)
#define FCIDM_BROWSEROPTIONS    (FCIDM_BROWSER_EXPLORE+0x0003)
#define FCIDM_LINKSSEPARATOR    (FCIDM_BROWSER_EXPLORE+0x0004)
#define FCIDM_STARTPAGE         (FCIDM_BROWSER_EXPLORE+0x0005)
#define FCIDM_UPDATEPAGE        (FCIDM_STARTPAGE+IDP_UPDATE)
#define FCIDM_CHANNELGUIDE      (FCIDM_STARTPAGE+IDP_CHANNELGUIDE)
#define FCIDM_SEARCHPAGE        (FCIDM_STARTPAGE+IDP_SEARCH)
#define FCIDM_RESETWEBSETTINGS  (FCIDM_BROWSER_EXPLORE+0x0009)
#define FCIDM_MAIL              (FCIDM_BROWSER_EXPLORE+0x000a)
#define FCIDM_NEWS              (FCIDM_BROWSER_EXPLORE+0x000b)
#define FCIDM_MAILNEWSSEPARATOR (FCIDM_BROWSER_EXPLORE+0x000c)
#define FCIDM_NEWMESSAGE        (FCIDM_BROWSER_EXPLORE+0x000d)
#define FCIDM_SENDLINK          (FCIDM_BROWSER_EXPLORE+0x000e)
#define FCIDM_SENDDOCUMENT      (FCIDM_BROWSER_EXPLORE+0x000f)
#define FCIDM_SEARCHSIMILAR     (FCIDM_BROWSER_EXPLORE+0x0010)
#define FCIDM_TOOLSSEPARATOR    (FCIDM_BROWSER_EXPLORE+0x0011)
#define FCIDM_MYCOMPUTER        (FCIDM_BROWSER_EXPLORE+0x0012)
#define FCIDM_SEARCHMENU        (FCIDM_BROWSER_EXPLORE+0x0013)

#define FCIDM_SHOWSCRIPTERRDLG  (FCIDM_BROWSER_EXPLORE+0x0014)

#define FCIDM_RECENTMENU        (FCIDM_BROWSER_EXPLORE+0x0021)
#define FCIDM_RECENTFIRST       (FCIDM_BROWSER_EXPLORE+0x0022)
#define FCIDM_RECENTLAST        (FCIDM_BROWSER_EXPLORE+0x0050)
#define FCIDM_FTPOPTIONS        (FCIDM_BROWSER_EXPLORE+0x0051)

#define FCIDM_FAVS_FIRST        (FCIDM_BROWSER_EXPLORE  +0x0052)
#define FCIDM_ORGANIZEFAVORITES (FCIDM_FAVS_FIRST       +0x0000)
#define FCIDM_ADDTOFAVORITES    (FCIDM_FAVS_FIRST       +0x0001)
#define FCIDM_FAVS_MORE         (FCIDM_FAVS_FIRST       +0x0002)
#define FCIDM_FAVORITEFIRST     (FCIDM_FAVS_FIRST       +0x0003)
#define FCIDM_UPDATESUBSCRIPTIONS (FCIDM_FAVS_FIRST       +0x0004)
#define FCIDM_SORTBY            (FCIDM_FAVS_FIRST       +0x0005)
#define FCIDM_SORTBYNAME        (FCIDM_FAVS_FIRST       +0x0006)
#define FCIDM_SORTBYVISIT       (FCIDM_FAVS_FIRST       +0x0007)
#define FCIDM_SORTBYDATE        (FCIDM_FAVS_FIRST       +0x0008)
#define FCIDM_FAVAUTOARRANGE    (FCIDM_FAVS_FIRST       +0x0009)
#define FCIDM_SUBSCRIPTIONS     (FCIDM_FAVS_FIRST       +0x000A)
#define FCIDM_SUBSCRIBE         (FCIDM_FAVS_FIRST       +0x000B)
#define FCIDM_FAVPLACEHOLDER    (FCIDM_FAVS_FIRST       +0x000C)

#define FCIDM_FAVORITELAST      (FCIDM_FAVORITEFIRST    +0x0050)
#define FCIDM_FAVORITE_ITEM     (FCIDM_FAVORITEFIRST + 0)
#define FCIDM_FAVORITECMDFIRST  (FCIDM_FAVS_FIRST)
#define FCIDM_FAVORITECMDLAST   (FCIDM_FAVORITELAST)
#define FCIDM_FAVS_LAST         (FCIDM_FAVORITELAST)

// (see histBand.cpp for more info...)
//shdocvw
//#define FCIDM_HISTBAND_FIRST      (FCIDM_BROWSERFIRST   + 0x0180)
//#define FCIDM_HISTBAND_VIEW       (FCIDM_HISTBAND_FIRST + 0x0000)

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_VIEW      (FCIDM_BROWSERFIRST + 0x0200)
#define FCIDM_VIEWTOOLBAR       (FCIDM_BROWSER_VIEW + 0x0001)
#define FCIDM_VIEWSTATUSBAR     (FCIDM_BROWSER_VIEW + 0x0002)
#define FCIDM_VIEWOPTIONS       (FCIDM_BROWSER_VIEW + 0x0003)
#define FCIDM_VIEWTOOLS         (FCIDM_BROWSER_VIEW + 0x0004)
#define FCIDM_VIEWADDRESS       (FCIDM_BROWSER_VIEW + 0x0005)
#define FCIDM_VIEWLINKS         (FCIDM_BROWSER_VIEW + 0x0006)
#define FCIDM_VIEWTEXTLABELS    (FCIDM_BROWSER_VIEW + 0x0007)
#define FCIDM_VIEWCONTEXTMENUSEP (FCIDM_BROWSER_VIEW + 0x0008)
#define FCIDM_VIEWAUTOHIDE      (FCIDM_BROWSER_VIEW + 0x0009)
#define FCIDM_VIEWMENU          (FCIDM_BROWSER_VIEW + 0x000A)
#define FCIDM_VIEWGOBUTTON      (FCIDM_BROWSER_VIEW + 0x000B)
#define FCIDM_VIEWLOCKTOOLBAR   (FCIDM_BROWSER_VIEW + 0x000C)

#define FCIDM_STOP              (FCIDM_BROWSER_VIEW + 0x001a)
#define FCIDM_VIEWTREE          (FCIDM_BROWSER_VIEW + 0x0016)
#define FCIDM_VIEWSEARCH        (FCIDM_BROWSER_VIEW + 0x0017)
#define FCIDM_CUSTOMIZEFOLDER   (FCIDM_BROWSER_VIEW + 0x0018)
#define FCIDM_VIEWFONTS         (FCIDM_BROWSER_VIEW + 0x0019)
// 1a is FCIDM_STOP
#define FCIDM_THEATER           (FCIDM_BROWSER_VIEW + 0x001b)
#define FCIDM_JAVACONSOLE       (FCIDM_BROWSER_VIEW + 0x001c)
#define FCIDM_VIEWTOOLBARCUSTOMIZE (FCIDM_BROWSER_VIEW + 0x001d)
#define FCIDM_ENCODING          (FCIDM_BROWSER_VIEW + 0x001e)
#define FCIDM_REFRESH           (FCIDM_BROWSER_VIEW + 0x0020) // ie4 shell32: must be A220 (cannot change)
#define FCIDM_ADDTOFAVNOUI      (FCIDM_BROWSER_VIEW + 0x0021)
#define FCIDM_VIEWITBAR         (FCIDM_BROWSER_VIEW + 0x0022)
#define FCIDM_VIEW_PRIVACY_POLICIES (FCIDM_BROWSER_VIEW + 0x0023)

#define FCIDM_VIEWBROWSERBARS   (FCIDM_BROWSER_VIEW + 0x0030)

// static guys
#define FCIDM_VBBSEARCHBAND         (FCIDM_VIEWBROWSERBARS + 0x0001)
#define FCIDM_VBBFAVORITESBAND      (FCIDM_VIEWBROWSERBARS + 0x0002)
#define FCIDM_VBBHISTORYBAND        (FCIDM_VIEWBROWSERBARS + 0x0003)
#define FCIDM_VBBEXPLORERBAND       (FCIDM_VIEWBROWSERBARS + 0x0005)
#ifdef UNIX
// UNIX only : MsgBand
#define FCIDM_VBBMSGBAND            (FCIDM_VIEWBROWSERBARS + 0x0006)
#endif
#define FCIDM_VBBMEDIABAND          (FCIDM_VIEWBROWSERBARS + 0x0007)

#define FCIDM_VBBPLACEHOLDER        (FCIDM_VIEWBROWSERBARS + 0x000b)
#define FCIDM_VBBFIXFIRST           (FCIDM_VIEWBROWSERBARS + 0x0001)
#define FCIDM_VBBFIXLAST            (FCIDM_VIEWBROWSERBARS + 0x000f)
#define FCIDM_VBBNOHORIZONTALBAR    0
#define FCIDM_VBBNOVERTICALBAR      0

// dynamic guys
#define FCIDM_VBBDYNFIRST           (FCIDM_VIEWBROWSERBARS + 0x10)
#define VBBDYN_MAXBAND              14
#define VBBDYN_MAXBAR               2
#define FCIDM_VBBDYNLAST            (FCIDM_VBBDYNFIRST + VBBDYN_MAXBAND * VBBDYN_MAXBAR)

#define FCIDM_SEARCHIDS         (FCIDM_BROWSER_VIEW + 0x0070)
#define FCIDM_SEARCHSEP         (FCIDM_SEARCHIDS    + 0x0001)
#define FCIDM_SEARCHALL         (FCIDM_SEARCHIDS    + 0x0002)
#define FCIDM_SEARCHFIRST       (FCIDM_SEARCHIDS    + 0x0003)
#define FCIDM_SEARCHLAST        (FCIDM_SEARCHFIRST  + 0x0020)

#define IDM_AC_FIRST            (FCIDM_BROWSER_EXPLORE+0x200)
#define AC_MENUITEMS            20  //  reserved space for auto complete items
#define IDM_AC_UNDO             (IDM_AC_FIRST+0x01)
#define IDM_AC_CUT              (IDM_AC_FIRST+0x02)
#define IDM_AC_COPY             (IDM_AC_FIRST+0x03)
#define IDM_AC_PASTE            (IDM_AC_FIRST+0x04)
#define IDM_AC_DELETE           (IDM_AC_FIRST+0x05)
#define IDM_AC_SELECTALL        (IDM_AC_FIRST+0x06)
#define IDM_AC_COMPLETIONS      (IDM_AC_FIRST+0x07)
#define IDM_AC_FIRSTCOMPITEM    (IDM_AC_FIRST+0x08)
#define IDM_AC_LASTCOMPITEM     (IDM_AC_FIRSTCOMPITEM+AC_MENUITEMS)

#define FCIDM_APPS_FIRST        (FCIDM_BROWSER_EXPLORE+0x220)
#define FCIDM_CONTACTS          (FCIDM_APPS_FIRST + 0x001)
#define FCIDM_CALENDAR          (FCIDM_APPS_FIRST + 0x002)
#define FCIDM_TASKS             (FCIDM_APPS_FIRST + 0x003)
#define FCIDM_JOURNAL           (FCIDM_APPS_FIRST + 0x004)
#define FCIDM_NOTES             (FCIDM_APPS_FIRST + 0x005)
#define FCIDM_CALL              (FCIDM_APPS_FIRST + 0x006)
#define FCIDM_APPS_LAST         (FCIDM_APPS_FIRST + 0x020)



#define FSIDM_NEWFOLDER         (FCIDM_FILECTX_LAST+0x21)
#define FSIDM_NEWLINK           (FCIDM_FILECTX_LAST+0x22)
#define FSIDM_NEWOTHER          (FCIDM_FILECTX_LAST+0x23)

#define FCIDM_EXTERNALBANDS_FIRST (FCIDM_BROWSERFIRST + 0x450)
#define FCIDM_EXTERNALBANDS_LAST  (FCIDM_BROWSERFIRST + 0x464)

#define FCIDM_FILECTX_FIRST     (FCIDM_BROWSERFIRST+0x470)
#define FCIDM_FILECTX_LAST      (FCIDM_BROWSERFIRST+0x570)

// start menu's augmisf context menu ids
#define SMIDM_OPEN               0x0001
#define SMIDM_EXPLORE            0x0002
#define SMIDM_OPENCOMMON         0x0003
#define SMIDM_EXPLORECOMMON      0x0004
#define SMIDM_DELETE             0x0005
#define SMIDM_RENAME             0x0006
#define SMIDM_PROPERTIES         0x0007

#define IDS_COMPLETIONS         507

#define IDS_MH_DRIVELIST        (MH_ITEMS+FCIDM_DRIVELIST)
#define IDS_MH_MENU_FILE        (MH_ITEMS+FCIDM_MENU_FILE)
#define IDS_MH_MENU_EXPLORE     (MH_ITEMS+FCIDM_MENU_EXPLORE)
#define IDS_MH_MENU_HELP        (MH_ITEMS+FCIDM_MENU_HELP)
#define IDS_MH_FILECLOSE        (MH_ITEMS+FCIDM_FILECLOSE)
#define IDS_MH_LINK             (MH_ITEMS+FCIDM_LINK)
#define IDS_MH_DELETE           (MH_ITEMS+FCIDM_DELETE)
#define IDS_MH_RENAME           (MH_ITEMS+FCIDM_RENAME)
#define IDS_MH_PROPERTIES       (MH_ITEMS+FCIDM_PROPERTIES)
#define IDS_MH_VIEWOFFLINE      (MH_ITEMS+FCIDM_VIEWOFFLINE)

#define IDS_MH_PREVIOUSFOLDER   (MH_ITEMS+FCIDM_PREVIOUSFOLDER)
#define IDS_MH_HELPSEARCH       (MH_ITEMS+FCIDM_HELPSEARCH)
#define IDS_MH_HELPABOUT        (MH_ITEMS+FCIDM_HELPABOUT)
#define IDS_MH_HELPTIPOFTHEDAY  (MH_ITEMS+FCIDM_HELPTIPOFTHEDAY)
#define IDS_MH_HELPISLEGAL      (MH_ITEMS+FCIDM_HELPISLEGAL)
#define IDS_MH_NAVIGATEBACK     (MH_ITEMS+FCIDM_NAVIGATEBACK)
#define IDS_MH_NAVIGATEFORWARD  (MH_ITEMS+FCIDM_NAVIGATEFORWARD)
#define IDS_MH_PREVIOUSFOLDER   (MH_ITEMS+FCIDM_PREVIOUSFOLDER)
#define IDS_MH_VIEWTOOLBAR      (MH_ITEMS+FCIDM_VIEWTOOLBAR)
#define IDS_MH_VIEWTOOLS        (MH_ITEMS+FCIDM_VIEWTOOLS)
#define IDS_MH_VIEWADDRESS      (MH_ITEMS+FCIDM_VIEWADDRESS)
#define IDS_MH_VIEWLINKS        (MH_ITEMS+FCIDM_VIEWLINKS)
#define IDS_MH_VIEWAUTOHIDE     (MH_ITEMS+FCIDM_VIEWAUTOHIDE)
#define IDS_MH_VIEWMENU         (MH_ITEMS+FCIDM_VIEWMENU)
#define IDS_MH_VIEWTEXTLABELS   (MH_ITEMS+FCIDM_VIEWTEXTLABELS)
#define IDS_MH_VIEWSTATUSBAR    (MH_ITEMS+FCIDM_VIEWSTATUSBAR)
#define IDS_MH_VIEWLOCKTOOLBAR  (MH_ITEMS+FCIDM_VIEWLOCKTOOLBAR)
#define IDS_MH_VIEWBROWSERBARS  (MH_ITEMS+FCIDM_VIEWBROWSERBARS)
#define IDS_MH_VIEWPRIVACY      (MH_ITEMS+FCIDM_VIEW_PRIVACY_POLICIES) 
#define IDS_MH_VBBSEARCHBAND    (MH_ITEMS+FCIDM_VBBSEARCHBAND)
#define IDS_MH_VBBFAVORITESBAND (MH_ITEMS+FCIDM_VBBFAVORITESBAND)
#define IDS_MH_VBBHISTORYBAND   (MH_ITEMS+FCIDM_VBBHISTORYBAND)
#define IDS_MH_VBBEXPLORERBAND  (MH_ITEMS+FCIDM_VBBEXPLORERBAND)
#define IDS_MH_VBBMEDIABAND     (MH_ITEMS+FCIDM_VBBMEDIABAND)

#define IDS_MH_BROWSEROPTIONS   (MH_ITEMS+FCIDM_BROWSEROPTIONS)
#define IDS_MH_STARTPAGE        (MH_ITEMS+FCIDM_STARTPAGE )
#define IDS_MH_SEARCHPAGE       (MH_ITEMS+FCIDM_SEARCHPAGE)
#define IDS_MH_UPDATEPAGE       (MH_ITEMS+FCIDM_UPDATEPAGE )
#define IDS_MH_CHANNELGUIDE     (MH_ITEMS+FCIDM_CHANNELGUIDE )
#define IDS_MH_UPDATESUBSCRIPTIONS  (MH_ITEMS+FCIDM_UPDATESUBSCRIPTIONS)
#define IDS_MH_WINDOWSUPDATE    (MH_ITEMS+FCIDM_WINDOWSUPDATE)
#define IDS_MH_RECENTFIRST      (MH_ITEMS+FCIDM_RECENTFIRST)
#define IDS_MH_MENU_FAVORITES   (MH_ITEMS+FCIDM_MENU_FAVORITES)
#define IDS_MH_FAVORITES        (MH_ITEMS+FCIDM_ORGANIZEFAVORITES)
#define IDS_MH_ADDTOFAVORITES   (MH_ITEMS+FCIDM_ADDTOFAVORITES)
#define IDS_MH_FAVS_MORE        (MH_ITEMS+FCIDM_FAVS_MORE)
#define IDS_MH_FAVORITE_ITEM    (MH_ITEMS+FCIDM_FAVORITE_ITEM)
#define IDS_MH_MAILANDNEWS      (MH_ITEMS+FCIDM_MAILANDNEWS)
#define IDS_MH_MAIL             (MH_ITEMS+FCIDM_MAIL)
#define IDS_MH_NEWS             (MH_ITEMS+FCIDM_NEWS)
#define IDS_MH_NEWMESSAGE       (MH_ITEMS+FCIDM_NEWMESSAGE)
#define IDS_MH_SENDLINK         (MH_ITEMS+FCIDM_SENDLINK)
#define IDS_MH_EXPLORE          (MH_ITEMS+FCIDM_MENU_EXPLORE)
#define IDS_MH_VIEW             (MH_ITEMS+FCIDM_MENU_VIEW)
#define IDS_MH_EDIT             (MH_ITEMS+FCIDM_MENU_EDIT)
#define IDS_MH_TOOLS            (MH_ITEMS+FCIDM_MENU_TOOLS) // for Win9x compat
#define IDS_MH_SENDDOCUMENT     (MH_ITEMS+FCIDM_SENDDOCUMENT)
#define IDS_MH_EDITPAGE         (MH_ITEMS+FCIDM_EDITPAGE)
#define IDS_MH_THEATER          (MH_ITEMS+FCIDM_THEATER)
#define IDS_MH_VIEWTOOLBARCUSTOMIZE (MH_ITEMS+FCIDM_VIEWTOOLBARCUSTOMIZE)
#define IDS_MH_ENCODING         (MH_ITEMS+FCIDM_ENCODING)
#define IDS_MH_VIEWFONTS        (MH_ITEMS+FCIDM_VIEWFONTS)
#define IDS_MH_MYCOMPUTER       (MH_ITEMS+FCIDM_MYCOMPUTER)
//#define IDS_MH_PRODUCTUPDATES   (MH_ITEMS+FCIDM_PRODUCTUPDATES)

#define IDS_MH_CONTACTS          (MH_ITEMS+FCIDM_CONTACTS)
#define IDS_MH_CALENDAR          (MH_ITEMS+FCIDM_CALENDAR)
#define IDS_MH_TASKS             (MH_ITEMS+FCIDM_TASKS   )
#define IDS_MH_JOURNAL           (MH_ITEMS+FCIDM_JOURNAL )
#define IDS_MH_NOTES             (MH_ITEMS+FCIDM_NOTES   )
#define IDS_MH_CALL              (MH_ITEMS+FCIDM_CALL    )

#define IDS_MH_CONNECT           (MH_ITEMS+FCIDM_CONNECT   )
#define IDS_MH_DISCONNECT        (MH_ITEMS+FCIDM_DISCONNECT)

#define IDS_MH_RESETWEBSETTINGS  (MH_ITEMS+FCIDM_RESETWEBSETTINGS)

#define IDM_BROWBAND_REFRESH         0x0001  // IWBBIDM_REFRESH
#define IDM_BROWBAND_OPENNEW         0x0002

// mediabar ids
#define TBIDM_PLAY              0x135
#define TBIDM_PAUSE           	0x136
#define TBIDM_STOP	            0x137
#define TBIDM_REWIND            0x138  
#define TBIDM_FASTFORWARD       0x139
#define TBIDM_VOLUME            0x140
#define TBIDM_MYMUSIC           0x141
#define TBIDM_SEEK	            0x142
#define TBIDM_PLAYINFO          0x143

// global ids
#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif

#define DLG_TEXTICONOPTIONS     0x100
#define IDC_SHOWTEXT            0x1000
#define IDC_SMALLICONS          0x1001

#define DLG_NEWFOLDER           0x101
#define IDD_NEW                 0x110
#define IDD_CREATEIN            0x111
#define IDD_NAMESTATIC          0x112
#define IDD_CREATEINSTATIC      0x113
#define IDD_SUBSCRIBE           0x114
#define IDD_SUBSCRIBE_TEXT      0x115

// in legacy\mnbandid.h #define DLG_ISFBANDRENAME       0x102

#define IDD_ADDTOFAVORITES_TEMPLATE     0x120
#define IDD_ADDTOCHANNELS_TEMPLATE      0x121
#define IDD_ACTIVATE_PLATINUM_CHANNEL   0x122
#define IDD_SUBSCRIBE_FAV_CHANNEL       0x123
#define IDD_SUBSCRIBE_FAVORITE          0x124
#define IDD_ADDTOSOFTDISTCHANNELS_TEMPLATE  0x125

#define IDC_SUBSCRIBE_POSSIBLE          0x130
#define IDC_SUBSCRIBE_NONE              0x131
#define IDC_SUBSCRIBE_NOTIFY            0x132
#define IDC_SUBSCRIBE_DOWNLOAD          0x133
#define IDC_SUBSCRIBE_CUSTOMIZE         0x134

#define IDC_FAVORITE_NAME               0x135
#define IDC_FAVORITE_CREATEIN           0x136
#define IDC_FAVORITE_NEWFOLDER          0x137
#define IDC_FAVORITE_ICON               0x138

#define IDC_CHANNEL_NAME                0x139
#define IDC_CHANNEL_URL                 0x13A
#define IDC_FOLDERLISTSTATIC            0x13B
#define IDC_NAMESTATIC                  0x13C


#define IDD_NAME                0x140
#define IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER 0x141
#define IDD_PROMPT              0x142

// Progress Dialog
#define DLG_PROGRESSDIALOG      0x103
#define IDD_PROGDLG_ANIMATION   0x150
#define IDD_PROGDLG_LINE1       0x151
#define IDD_PROGDLG_LINE2       0x152
#define IDD_PROGDLG_LINE3       0x153
#define IDD_PROGDLG_PROGRESSBAR 0x154

#define IDS_TIMEEST_MINUTES     0x3030
#define IDS_TIMEEST_SECONDS     0x3031
#define IDS_CANTSHUTDOWN        0x3032
#define IDS_DEFAULT_CANCELPROG  0x3033
#define IDS_TIMEEST_DAYSHOURS  0x3034
#define IDS_TIMEEST_DAYHOURS   0x3035
#define IDS_TIMEEST_DAYSHOUR   0x3036
#define IDS_TIMEEST_DAYHOUR    0x3037
#define IDS_TIMEEST_HOURSMINS  0x3038
#define IDS_TIMEEST_HOURSMIN   0x3039
#define IDS_TIMEEST_HOURMINS   0x303A
#define IDS_TIMEEST_HOURMIN    0x303B
#define IDS_TITLEBAR_PROGRESS  0x303C

#define IDC_WEBFOLDEREDIT       0x1002

//--------------------------------------------------------------
// I C O N S
//--------------------------------------------------------------
#define IDI_NEW_FOLDER          0x1
#define IDI_FRAME               0x2

// UNIX only
#define IDI_MONOFRAME           0x4020

//--------------------------------------------------------------
// HTML dialog resources
//--------------------------------------------------------------
#define RT_FILE                         2110

#define FCIDM_TOOLS_EXT_PLACEHOLDER         0x9000
#define FCIDM_HELP_EXT_PLACEHOLDER          0x9002

//--------------------------------------------------------------
// HTML File Resources
//--------------------------------------------------------------

#define IDH_PLAYER          0x7300
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\sccls.h ===
// Create Instance functions

#ifndef _SCCLS_H_
#define _SCCLS_H_



#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0
#define COCREATEONLY NULL,NULL,VERSION_0,0,0 // piid,piidEvents,lVersion,dwOleMiscFlags,dwClassFactFlags
#define COCREATEONLY_NOFLAGS NULL,NULL,VERSION_0,0 // piid,piidEvents,lVersion,dwOleMiscFlags



STDAPI  CMediaBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi); // mediaband.cpp
STDAPI  CDocObjectFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CInternetToolbar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CQuickLinks_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CAddressBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);   // address.cpp
STDAPI  CAddressEditBox_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);   // aeditbox.cpp
STDAPI  CBandProxy_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);     // bandprxy.cpp
STDAPI  CBrandBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDeskBarApp_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBrowserBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CSearchBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CCommBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CISFBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
#ifdef ENABLE_CHANNELS
STDAPI  CChannelBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
#endif
STDAPI  CExplorerBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBandSiteMenu_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CComCatCacheTask_CreateInstance( IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi );
STDAPI  CComCatConditionalCacheTask_CreateInstance( IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi );
STDAPI  CAutoComplete_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLHistory_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLIShellFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLMRU_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLCustomMRU_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CACLMulti_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CCmdFileIcon_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CTrackShellMenu_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CMenuBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  ChannelOC_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CShellTaskScheduler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CSharedTaskScheduler_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CDesktopTask_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CWinListShellProc_CreateInstance (IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CAugmentedISF_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CAugmentedISF2_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CIESplashScreen_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  COrderList_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  CMenuSite_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi);
STDAPI  CCDFCopyHook_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CRegTreeOptions_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  TaskbarList_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CInternetCacheCleaner_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CThumbnail_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CImgCtxThumb_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CImageListCache_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDocFileInfoTip_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
STDAPI  CacheFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI  HistFolder_CreateInstance(IUnknown* pUnkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
STDAPI  CCommonBrowser_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CDockingBarPropertyBag_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBitmapPreload_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CBrowseuiIdentity_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CUserAssist_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI  CGlobalFolderSettings_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

STDAPI CShellSearchExt_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CWebSearchExt_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CProgressDialog_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CAccessible_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CTrackPopupBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CShellUrl_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

STDAPI CBaseBrowser_Validate(HWND hwnd, LPVOID* ppsb);
STDAPI CShellBrowser_CreateInstance(HWND hwnd, LPVOID* ppsb);
STDAPI CExplorerBrowser_CreateInstance(HWND hwnd, LPVOID* ppsb);
STDAPI CSDWindows_CreateInstance(IShellWindows **ppunk);

STDAPI CIEFrameAuto_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk);

// to save some typing:
#define CLSIDOFOBJECT(p)          (*((p)->_pObjectInfo->pclsid))
#define VERSIONOFOBJECT(p)          ((p)->_pObjectInfo->lVersion)
#define EVENTIIDOFCONTROL(p)      (*((p)->_pObjectInfo->piidEvents))
#define OLEMISCFLAGSOFCONTROL(p)    ((p)->_pObjectInfo->dwOleMiscFlags)

extern char g_szLibName[]; // shocx.c
extern CRITICAL_SECTION  g_csDll;

#endif // _SCCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\sccls.cpp ===
//#define  DONT_USE_ATL
#include "priv.h"
#define ATL_ENABLED
#include "atl.h"

#include "sccls.h"
#include <ntverp.h>

#include <shlobj.h>                 // for CLSID_ACLMRU
#include <schedule.h>

#include "shbrows2.h"               // CWinInetNotify_szWindowClass
#include "desktop.h"                // DESKTOPPROXYCLASS

#include "mluisupp.h"
#define DECL_CRTFREE
#include <crtfree.h>
#include "shfusion.h"

STDAPI_(void) InitURLIDs(UINT uPlatform);       // from shdocfl.cpp
STDAPI SHIsThereASystemScheduler(void);         // from schedule.cpp
STDAPI SHFreeSystemScheduler(void);

//
// Downlevel delay load support (we forward to shlwapi)
//
#include <delayimp.h>

PfnDliHook __pfnDliFailureHook;
HANDLE BaseDllHandle;


LONG                g_cRefThisDll = 0;      // per-instance
CRITICAL_SECTION    g_csDll = {0};          // per-instance
HINSTANCE           g_hinst = NULL;
HANDLE              g_hMutexHistory = NULL;


BOOL g_fNashInNewProcess = FALSE;           // Are we running in a separate process
BOOL g_fRunningOnNT = FALSE;
BOOL g_bRunOnNT5 = FALSE;
BOOL g_fRunOnWhistler = FALSE;
BOOL g_bRunOnMemphis = FALSE;
BOOL g_fRunOnFE = FALSE;
DWORD g_dwStopWatchMode = 0;                // Shell perf automation
HANDLE g_hCabStateChange = NULL;
BOOL g_fIE = FALSE;

// Is Mirroring enabled
BOOL g_bMirroredOS = FALSE;

HPALETTE g_hpalHalftone = NULL;

void DestroyZoneIconNameCache(void);

//
// This array holds information needed for ClassFacory.
// OLEMISC_ flags are used by shembed and shocx.
//
// PERF: this table should be ordered in most-to-least used order
//
CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY(&CLSID_InternetToolbar,         CInternetToolbar_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_BrandBand,               CBrandBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_MenuBandSite,            CMenuBandSite_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_MenuDeskBar,                CMenuDeskBar_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_AugmentedShellFolder,    CAugmentedISF_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_AugmentedShellFolder2,   CAugmentedISF2_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_AddressBand,             CAddressBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_AddressEditBox,          CAddressEditBox_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_BandProxy,               CBandProxy_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_RebarBandSite,           CBandSite_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_ALLOWAGGREGATION),

    CF_TABLE_ENTRY(&CLSID_DeskBarApp,              CDeskBarApp_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_DeskBar,                 CDeskBar_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_AutoComplete,            CAutoComplete_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ACLHistory,              CACLHistory_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ACListISF,               CACLIShellFolder_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ACLMRU,                  CACLMRU_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ACLMulti,                CACLMulti_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_CCommonBrowser,           CCommonBrowser_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_ALLOWAGGREGATION),

    CF_TABLE_ENTRY(&CLSID_CDockingBarPropertyBag,   CDockingBarPropertyBag_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_CRegTreeOptions,          CRegTreeOptions_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_BrowserBand,             CBrowserBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_SearchBand,             CSearchBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_MediaBand,               CMediaBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_CommBand,                CCommBand_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_BandSiteMenu,            CBandSiteMenu_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ComCatCacheTask,           CComCatCacheTask_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ComCatConditionalCacheTask,CComCatConditionalCacheTask_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ImgCtxThumbnailExtractor,  CImgCtxThumb_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ImageListCache,            CImageListCache_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ShellTaskScheduler,        CShellTaskScheduler_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_SharedTaskScheduler,       CSharedTaskScheduler_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_BrowseuiPreloader,         CBitmapPreload_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ShellSearchExt,            CShellSearchExt_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_WebSearchExt,              CWebSearchExt_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_OrderListExport,           COrderList_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_UserAssist,                CUserAssist_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_GlobalFolderSettings,      CGlobalFolderSettings_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ProgressDialog,            CProgressDialog_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY(&CLSID_ACLCustomMRU,              CACLCustomMRU_CreateInstance,
        COCREATEONLY),
        
    CF_TABLE_ENTRY(&CLSID_AddressBarParser,          CShellUrl_CreateInstance,
        COCREATEONLY),

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_MenuBand,        CMenuBand_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_DONTIECREATE), // legacy component, dont default to browseui's impl

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_QuickLinks,      CQuickLinks_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_DONTIECREATE), // legacy component, dont default to browseui's impl

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_ISFBand,         CISFBand_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_DONTIECREATE), // legacy component, dont default to browseui's impl

    CF_TABLE_ENTRY_NOFLAGS( &CLSID_Thumbnail,       CThumbnail_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_DONTIECREATE),  // legacy component, dont default to browseui's impl

    CF_TABLE_ENTRY_NOFLAGS(&CLSID_TrackShellMenu,            CTrackShellMenu_CreateInstance,
        COCREATEONLY_NOFLAGS, OIF_DONTIECREATE),  // legacy component, dont default to browseui's impl

CF_TABLE_END(g_ObjectInfo)

// constructor for CObjectInfo.

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn,
                         DWORD dwClassFactFlagsIn)
{
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}


// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hres = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hres))
        {
            hres = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        ASSERT(FAILED(hres) ? *ppv == NULL : TRUE);
        return hres;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    TraceMsg(DM_TRACE, "sccls: LockServer(%s) to %d", fLock ? TEXT("LOCK") : TEXT("UNLOCK"), g_cRefThisDll);
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    TraceMsg(TF_SHDLIFE, "DllGetClassObject called with riid=%x (%x)", riid, &riid);

    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                DllAddRef();        // class factory holds DLL ref count
                return NOERROR;
            }
        }

#ifdef ATL_ENABLED
        // Try the ATL class factory
        if (SUCCEEDED(AtlGetClassObject(rclsid, riid, ppv)))
            return NOERROR;
#endif
    }

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI DllCanUnloadNow(void)
{
#ifndef UNIX
    // special case for the system scheduler we hang onto
    if ( g_cRefThisDll == 1 && SHIsThereASystemScheduler() == S_OK )
    {
        // this will drop the ref count by one to zero....
        SHFreeSystemScheduler();
    }

#ifdef ATL_ENABLED
    if (0 != g_cRefThisDll || 0 != AtlGetLockCount())
        return S_FALSE;
#else
    if (0 != g_cRefThisDll)
        return S_FALSE;
#endif

#else
    if (g_cRefThisDll)
        return S_FALSE;
#endif

    TraceMsg(DM_TRACE, "DllCanUnloadNow returning S_OK (bye, bye...)");
    return S_OK;
}

// DllGetVersion
//
// All we have to do is declare this puppy and CCDllGetVersion does the rest
//
DLLVER_SINGLEBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);

UINT g_msgMSWheel;
#ifdef DEBUG
EXTERN_C DWORD g_TlsMem = 0xffffffff;
#endif

// imports from isfband.cpp
STDAPI_(void) CLogoBase_Initialize( void );
STDAPI_(void) CLogoBase_Cleanup( void );

//
//  Table of all window classes we register so we can unregister them
//  at DLL unload.
//

const LPCTSTR c_rgszClasses[] = {
    TEXT("BaseBar"),                // basebar.cpp
    TEXT("MenuSite"),               // menusite.cpp
    DESKTOPPROXYCLASS,              // proxy.cpp
    c_szExploreClass,               // shbrows2.cpp
    c_szIExploreClass,              // shbrows2.cpp
    c_szCabinetClass,               // shbrows2.cpp
    c_szAutoSuggestClass,           // autocomp.cpp
    TEXT("MediaPane"),              //Mediaband.cpp
    TEXT("MediaPopupPane"),         //Mediaband.cpp
    TEXT("MediaLayoutPane")         //Mediaband.cpp 
};

//
//  Since we are single-binary, we have to play it safe and do
//  this cleanup (needed only on NT, but harmless on Win95).
//
#define UnregisterWindowClasses() \
    SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses))

void InitNFCtl()
{

    INITCOMMONCONTROLSEX icc;

    icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icc.dwICC = ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icc);
}
const LPCTSTR s_aryExplorerFileName[] =
{
    TEXT("iexplore.exe"),
};

BOOL IsRootExeExplorer(void)
{
    TCHAR szApp[MAX_PATH];
    LPCTSTR pszApp;
    GetModuleFileName(NULL, szApp, ARRAYSIZE(szApp));
    pszApp = PathFindFileName(szApp);
    if (pszApp)
    {
        for (int i = 0; i < ARRAYSIZE(s_aryExplorerFileName); i++)
        {
            if (!lstrcmpi(pszApp, s_aryExplorerFileName[i]))
                return TRUE;
        }
    }
    return FALSE;
}

//
// we use shlwapi as our delayload error handler.
// NOTE: this only works if we are statically linked to shlwapi!
//
void SetupDelayloadErrorHandler()
{
    BaseDllHandle = GetModuleHandleA("shlwapi.dll");
    ASSERTMSG(BaseDllHandle != NULL, "BROWSEUI must be statically linked to shlwapi.dll for delayload failure handling to work!");
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress((HMODULE)BaseDllHandle, "DelayLoadFailureHook");
}

STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, void *fProcessUnload)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        SHFusionInitializeFromModule(hDll);

        SetupDelayloadErrorHandler();

#ifdef ATL_ENABLED
        AtlInit(hDll);
#endif
        DisableThreadLibraryCalls(hDll);    // perf

        g_hinst = hDll;
        InitializeCriticalSection(&g_csDll);
        g_msgMSWheel = RegisterWindowMessage(TEXT("MSWHEEL_ROLLMSG"));

        MLLoadResources(g_hinst, TEXT("browselc.dll"));
        g_fIE = IsRootExeExplorer();
        if (g_fIE)
            InitMUILanguage(MLGetUILanguage());
        
        // Don't put it under #ifdef DEBUG
        CcshellGetDebugFlags();

#ifdef DEBUG
        g_TlsMem = TlsAlloc();
        if (IsFlagSet(g_dwBreakFlags, BF_ONLOADED))
        {
            TraceMsg(TF_ALWAYS, "DllMain() - SHDOCVW.DLL has just loaded");
            DEBUG_BREAK;
        }
#endif
        g_fRunningOnNT = IsOS(OS_NT);

        if (g_fRunningOnNT)
        {
            g_bRunOnNT5 = IsOS(OS_WIN2000ORGREATER);
            g_fRunOnWhistler = IsOS(OS_WHISTLERORGREATER);
        }
        else
            g_bRunOnMemphis = IsOS(OS_WIN98ORGREATER);

        g_fRunOnFE = GetSystemMetrics(SM_DBCSENABLED);

        g_bMirroredOS = IS_MIRRORING_ENABLED();

        InitNFCtl();

        // See if perfmode is enabled
        g_dwStopWatchMode = StopWatchMode();

        // Cache a palette handle for use throughout shdocvw
        g_hpalHalftone = SHCreateShellPalette( NULL );
        CLogoBase_Initialize( );
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
#ifdef ATL_ENABLED
        AtlTerm();
#endif
        CBrandBand_CleanUp();
        CInternetToolbar_CleanUp();
        CUserAssist_CleanUp(dwReason, fProcessUnload);

        CLogoBase_Cleanup();

        // let go of the resource DLL...
        MLFreeResources(g_hinst);

        ENTERCRITICAL;

        DESTROY_OBJ_WITH_HANDLE(g_hpalHalftone, DeletePalette);
        DESTROY_OBJ_WITH_HANDLE(g_hCabStateChange, SHGlobalCounterDestroy);
        DESTROY_OBJ_WITH_HANDLE(g_hMutexHistory, CloseHandle);

        DestroyZoneIconNameCache();

        UnregisterWindowClasses();

        LEAVECRITICAL;

        DeleteCriticalSection(&g_csDll);

        SHFusionUninitialize();
    }

    return TRUE;
}

STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cRefThisDll);
}

STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cRefThisDll);

    ASSERT(g_cRefThisDll >= 0);      // don't underflow
}

// IEUNIX
// CoCreateInstance is #defined as IECreateInstance #ifdef __cplusplus,
// so I #undef it  here to prevent the recursive call.
// On Windows it works, because this file is C file.

#ifdef CoCreateInstance
#undef CoCreateInstance
#endif

HRESULT IECreateInstance(REFCLSID rclsid, IUnknown *pUnkOuter,
                    DWORD dwClsContext, REFIID riid, void **ppv)
{
#ifndef NO_MARSHALLING
    if (dwClsContext == CLSCTX_INPROC_SERVER)
#else
    if (dwClsContext & CLSCTX_INPROC_SERVER)
#endif
    {
        LPCOBJECTINFO pcls;
        for (pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            // Note that we do pointer comparison (instead of IsEuqalGUID)
            if ((&rclsid == pcls->pclsid) && !(pcls->dwClassFactFlags & OIF_DONTIECREATE))
            {
                // const -> non-const expclit casting (this is OK)
                IClassFactory* pcf = GET_ICLASSFACTORY(pcls);
                return pcf->CreateInstance(pUnkOuter, riid, ppv);
            }
        }
    }
    // Use SHCoCreateInstanceAC to go through the app compat layer
    return SHCoCreateInstanceAC(rclsid, pUnkOuter, dwClsContext, riid, ppv);
}

#ifdef DEBUG

//
//  In DEBUG, make sure every class we register lives in the c_rgszClasses
//  table so we can clean up properly at DLL unload.  NT does not automatically
//  unregister classes when a DLL unloads, so we have to do it manually.
//
STDAPI_(BOOL) SHRegisterClassD(CONST WNDCLASS *pwc)
{
    for (int i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (lstrcmpi(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealSHRegisterClass(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

STDAPI_(ATOM) RegisterClassD(CONST WNDCLASS *pwc)
{
    for (int i = 0; i < ARRAYSIZE(c_rgszClasses); i++) 
    {
        if (lstrcmpi(c_rgszClasses[i], pwc->lpszClassName) == 0) 
        {
            return RealRegisterClass(pwc);
        }
    }
    AssertMsg(0, TEXT("Class %s needs to be added to the c_rgszClasses list"), pwc->lpszClassName);
    return 0;
}

//
//  In DEBUG, send FindWindow through a wrapper that ensures that the
//  critical section is not taken.  FindWindow'ing for a window title
//  sends inter-thread WM_GETTEXT messages, which is not obvious.
//
STDAPI_(HWND) FindWindowD(LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    return FindWindowExD(NULL, NULL, lpClassName, lpWindowName);
}

STDAPI_(HWND) FindWindowExD(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpClassName, LPCTSTR lpWindowName)
{
    if (lpWindowName) 
    {
        ASSERTNONCRITICAL;
    }
    return RealFindWindowEx(hwndParent, hwndChildAfter, lpClassName, lpWindowName);
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\schedule.cpp ===
#include "priv.h"
#include "schedule.h"

// debug stuff for tracking critical section owners.....
#ifdef DEBUG
#define DECLARE_CRITICAL_SECTION(x)         CRITICAL_SECTION x;                              \
                                            DWORD dwThread##x;

#define STATIC_DECLARE_CRITICAL_SECTION(x)  static CRITICAL_SECTION x;                      \
                                            static DWORD dwThread##x;

#define STATIC_INIT_CRITICAL_SECTION(c,x)   CRITICAL_SECTION c::x = {0};             \
                                            DWORD c::dwThread##x;

#define ASSERT_CRITICAL_SECTION(x)          ASSERT( dwThread##x == GetCurrentThreadId() );

#define OBJECT_ASSERT_CRITICAL_SECTION(o,x) ASSERT( o->dwThread##x == GetCurrentThreadId() );

#define ENTER_CRITICAL_SECTION(x)           EnterCriticalSection(&x);                        \
                                            dwThread##x = GetCurrentThreadId();

#define OBJECT_ENTER_CRITICAL_SECTION(o,x)  EnterCriticalSection(&o->x);                        \
                                            o->dwThread##x = GetCurrentThreadId();

#define LEAVE_CRITICAL_SECTION(x)           ASSERT_CRITICAL_SECTION(x);    \
                                            LeaveCriticalSection(&x);

#define OBJECT_LEAVE_CRITICAL_SECTION(o,x)  OBJECT_ASSERT_CRITICAL_SECTION(o,x);    \
                                            LeaveCriticalSection(&o->x);
#else
#define DECLARE_CRITICAL_SECTION(x)         CRITICAL_SECTION x;

#define STATIC_DECLARE_CRITICAL_SECTION(x)  static CRITICAL_SECTION x;

#define STATIC_INIT_CRITICAL_SECTION(c,x)   CRITICAL_SECTION c::x = {0};

#define ASSERT_CRITICAL_SECTION(x)

#define OBJECT_ASSERT_CRITICAL_SECTION(o,x)

#define ENTER_CRITICAL_SECTION(x)           EnterCriticalSection(&x);

#define OBJECT_ENTER_CRITICAL_SECTION(o,x)  EnterCriticalSection(&o->x);

#define LEAVE_CRITICAL_SECTION(x)           LeaveCriticalSection(&x);

#define OBJECT_LEAVE_CRITICAL_SECTION(o,x)  LeaveCriticalSection(&o->x);
#endif

#define TF_SCHEDULER     0x20

// struct to hold the details for each task that is to be executed....
struct TaskNode
{
    LPRUNNABLETASK pTask;
    TASKOWNERID toid;
    DWORD dwPriority;
    DWORD_PTR dwLParam;
    BOOL fSuspended;
};


class CShellTaskScheduler : public IShellTaskScheduler2
{
    public:
        CShellTaskScheduler( HRESULT * pHr );
        ~CShellTaskScheduler();

        STDMETHOD (QueryInterface) (REFIID riid, LPVOID * ppvObj );
        STDMETHOD_(ULONG, AddRef)( void );
        STDMETHOD_(ULONG,Release)( void );

        STDMETHOD (AddTask)(IRunnableTask * pTask,
                   REFTASKOWNERID rtoid,
                   DWORD_PTR lParam,
                   DWORD dwPriority );
        STDMETHOD (RemoveTasks)( REFTASKOWNERID rtoid,
                   DWORD_PTR dwLParam,
                   BOOL fWaitIfRunning );
        STDMETHOD (Status)( DWORD dwStatus, DWORD dwThreadTimeout );
        STDMETHOD_(UINT, CountTasks)(REFTASKOWNERID rtoid);

        STDMETHOD (AddTask2)(IRunnableTask * pTask,
                   REFTASKOWNERID rtoid,
                   DWORD_PTR lParam,
                   DWORD dwPriority,
                   DWORD grfFlags);
        STDMETHOD (MoveTask)(REFTASKOWNERID rtoid,
                   DWORD_PTR dwLParam,
                   DWORD dwPriority,
                   DWORD grfFlags );

    protected:

        // data held by a task scheduler to refer to the current worker that it has....
        struct WorkerData
        {
            BOOL Init(CShellTaskScheduler *pts);

            // this (pThis) is used to pass the controlling
            // object back and forth to the thread, so that threads can be moved
            // back and forth from objects as they need them.
            CShellTaskScheduler *   pThis;

#ifdef DEBUG
            DWORD                   dwThreadID;
#endif
        };

        friend UINT CShellTaskScheduler_ThreadProc( LPVOID pParam );
        friend int CALLBACK ListDestroyCallback( LPVOID p, LPVOID pData );

        VOID _KillScheduler( BOOL bKillCurTask );
        BOOL _WakeScheduler( void );

        BOOL _RemoveTasksFromList( REFTASKOWNERID rtoid, DWORD_PTR dwLParam );


        // create a worker thread data block that can be associated with a task scheduler....
        WorkerData * FetchWorker( void );

        // from a worker thread, let go of the scheduler it is associated...
        static BOOL ReleaseWorker( WorkerData * pThread );


        /***********PERINSTANCE DATA ************/
        DECLARE_CRITICAL_SECTION( m_csListLock )
        HDPA m_hTaskList;

        WorkerData * m_pWorkerThread;

        // the currently running task...
        TaskNode * m_pRunning;

        // a semaphore that counts, so that all waiters canbe released...
        HANDLE m_hCurTaskEnded;

        DWORD m_dwStatus;

        int m_iSignalCurTask;                // - tell the thread to signal when the
                                             //   current task is finished if non-zero
                                             //   the other thread will signal the 
                                             //   handle as many times as this variable
                                             //   holds.
        BOOL m_fEmptyQueueAndSleep;          // - tell the thread to empty itself and
                                             //   go to sleep (usually it is dying....

        int m_iGoToSleep;                    // - tell the tread to go to sleep without emptying the queue

        long m_cRef;

#ifdef DEBUG
        void AssertForNoOneWaiting( void )
        {
            // no one should be queued for waiting
            ASSERT( m_iSignalCurTask == 0 );

            // release the semaphore by zero to get the current count....
            LONG lPrevCount = 0;
            ReleaseSemaphore( m_hCurTaskEnded, 0, &lPrevCount );
            ASSERT( lPrevCount == 0 );
        };
#endif
        
        void IWantToKnowWhenCurTaskDone( void )
        {
            m_iSignalCurTask ++;
        };
};

// private messages sent to the scheduler thread...
#define WM_SCH_WAKEUP       WM_USER + 0x600
#define WM_SCH_TERMINATE    WM_USER + 0x601

STDAPI CShellTaskScheduler_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    if ( pUnkOuter )
    {
        return CLASS_E_NOAGGREGATION;
    }

    HRESULT hr = NOERROR;
    CShellTaskScheduler * pScheduler = new CShellTaskScheduler( & hr );
    if ( !pScheduler )
    {
        return E_OUTOFMEMORY;
    }
    if ( FAILED( hr ))
    {
        delete pScheduler;
        return hr;
    }

    *ppunk = SAFECAST(pScheduler, IShellTaskScheduler *);
    return NOERROR;
}

// Global ExplorerTaskScheduler object that is used by multiple components.
IShellTaskScheduler * g_pTaskScheduler = NULL;


// This is the class factory routine for creating the one and only ExplorerTaskScheduler object.
// We have a static object (g_pTaskScheduler) that everyone who wants to use it shares.
STDAPI CSharedTaskScheduler_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr = NOERROR;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    ENTERCRITICAL;
    if (g_pTaskScheduler)
    {
        g_pTaskScheduler->AddRef();
    }
    else
    {
        hr = CShellTaskScheduler_CreateInstance(NULL, (LPUNKNOWN*)&g_pTaskScheduler, NULL);
        if (SUCCEEDED(hr))
        {
            // set timeout to be 1 minute.....
            g_pTaskScheduler->Status( ITSSFLAG_KILL_ON_DESTROY, 1 * 60 * 1000 );

            // keep an additional ref for us..
            g_pTaskScheduler->AddRef();
        }
    }

    *ppunk = SAFECAST(g_pTaskScheduler, IShellTaskScheduler*);
    LEAVECRITICAL;

    return hr;
}

STDAPI SHIsThereASystemScheduler( void )
{
    return ( g_pTaskScheduler ? S_OK : S_FALSE );
}

// use CoCreateInstance - thread pool removes need for global scheduler
STDAPI SHGetSystemScheduler( LPSHELLTASKSCHEDULER * ppScheduler )
{
    if ( !ppScheduler )
    {
        return E_INVALIDARG;
    }

    return CSharedTaskScheduler_CreateInstance(NULL, (IUnknown **)ppScheduler, NULL );
}

// use CoCreateInstance - thread pool removes need for global scheduler
STDAPI SHFreeSystemScheduler( void )
{
    TraceMsg(TF_SCHEDULER, "SHfss: g_pTaskSched=%x", g_pTaskScheduler);

    IShellTaskScheduler * pSched;

    ENTERCRITICAL;
    pSched = g_pTaskScheduler;
    g_pTaskScheduler = NULL;
    LEAVECRITICAL;
    if ( pSched )
    {
        // assume the scheduler is empty....
        pSched->RemoveTasks( TOID_NULL, ITSAT_DEFAULT_LPARAM, FALSE );

        pSched->Release();
    }
    return NOERROR;
}

#ifdef DEBUG
STDAPI_(void) SHValidateEmptySystemScheduler()
{
    if ( g_pTaskScheduler )
    {
        ASSERT( g_pTaskScheduler->CountTasks( TOID_NULL ) == 0 );
    }
}
#endif

int InsertInPriorityOrder( HDPA hTaskList, TaskNode * pNewNode, BOOL fBefore );
int CALLBACK ListDestroyCallback( LPVOID p, LPVOID pData )
{
    ASSERT( p != NULL );
    if ( ! p )
    {
        TraceMsg( TF_ERROR, "ListDestroyCallback() - p is NULL!" );
        return TRUE;
    }

    CShellTaskScheduler * pThis = (CShellTaskScheduler *) pData;
    ASSERT( pThis );
    if ( ! pThis )
    {
        TraceMsg( TF_ERROR, "ListDestroyCallback() - pThis is NULL!" );
        return TRUE;
    }

    TaskNode * pNode = (TaskNode *) p;
    ASSERT( pNode != NULL );
    ASSERT( pNode->pTask != NULL );

#ifdef DEBUG
    if ( pThis->m_pWorkerThread )
    {
        // notify the thread that we are emptying the list from here, so remove these
        // items from its mem track list
    }
#endif

    // if it is suspended, kill it. If it is not suspended, then it has
    // probably never been started..
    if ( pNode->fSuspended )
    {
        pNode->pTask->Kill( pThis->m_dwStatus == ITSSFLAG_COMPLETE_ON_DESTROY );
    }
    pNode->pTask->Release();
    delete pNode;

    return TRUE;
}

STDMETHODIMP CShellTaskScheduler::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    static const QITAB qit[] = {
        QITABENT(CShellTaskScheduler, IShellTaskScheduler),
        QITABENT(CShellTaskScheduler, IShellTaskScheduler2),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_ (ULONG) CShellTaskScheduler::AddRef()
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;
}
STDMETHODIMP_ (ULONG) CShellTaskScheduler::Release()
{
    if (0 == m_cRef)
    {
        AssertMsg(0, TEXT("CShellTaskScheduler::Release called too many times!"));
        return 0;
    }

    if (InterlockedDecrement( &m_cRef ) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

CShellTaskScheduler::CShellTaskScheduler( HRESULT * pHr) : m_cRef(1)
{
    InitializeCriticalSection( &m_csListLock );

    ASSERT(m_pWorkerThread == NULL);
    ASSERT(m_pRunning == NULL);

    m_dwStatus = ITSSFLAG_COMPLETE_ON_DESTROY;

    // grow queue by five each time...
    m_hTaskList = DPA_Create( 5 );
    if ( !m_hTaskList )
    {
        *pHr = E_OUTOFMEMORY;
    }

    m_hCurTaskEnded = CreateSemaphoreWrap( NULL, 0, 0xffff, NULL );
    if ( !m_hCurTaskEnded )
    {
        *pHr = E_FAIL;
    }

    DllAddRef();

}

CShellTaskScheduler::~CShellTaskScheduler()
{
    // if we don't have a tasklist and semaphore (constructor failure), we can't have a workerthread
    ASSERT((m_hTaskList && m_hCurTaskEnded) || !m_pWorkerThread);

    // but if we have a task list...
    if ( m_hTaskList )
    {
        EnterCriticalSection( &m_csListLock );

        // if we have a background worker thread, then it MUST be doing something as we
        // are now in the crit section so it can't go away
        if ( m_pWorkerThread )
        {
            // we tell the object we need to know when it has done with its stuff....
            // we reuse the event we already have...
            m_fEmptyQueueAndSleep = TRUE;

#ifdef DEBUG
            AssertForNoOneWaiting();
#endif

            IWantToKnowWhenCurTaskDone();
            
            // tell the cur task to go away.....
            TraceMsg(TF_SCHEDULER, "(%x)csts.dtor: call _KillScheduler", GetCurrentThreadId());
            _KillScheduler( m_dwStatus == ITSSFLAG_KILL_ON_DESTROY );

            // free the thread. At this point there is always
            LeaveCriticalSection( &m_csListLock );

            TraceMsg(TF_SCHEDULER, "csts.dtor: call u.WFSMT(m_hCurTaskEnded=%x)", m_hCurTaskEnded);

            DWORD dwRes = SHWaitForSendMessageThread(m_hCurTaskEnded, INFINITE);
            ASSERT(dwRes == WAIT_OBJECT_0);
            TraceMsg(TF_SCHEDULER, "csts.dtor: u.WFSMT() done");

            ASSERT( !m_pWorkerThread );
        }
        else
        {
            LeaveCriticalSection( &m_csListLock );
        }

        // empty the list incase it is not empty (it should be)
        DPA_EnumCallback( m_hTaskList, ListDestroyCallback, this );
        DPA_DeleteAllPtrs( m_hTaskList );

        DPA_Destroy( m_hTaskList );
        m_hTaskList = NULL;
    }

    if ( m_hCurTaskEnded )
        CloseHandle( m_hCurTaskEnded );

    DeleteCriticalSection( &m_csListLock );

    DllRelease();

}

STDMETHODIMP CShellTaskScheduler::AddTask( IRunnableTask * pTask,
                                      REFTASKOWNERID rtoid,
                                      DWORD_PTR dwLParam,
                                      DWORD dwPriority )
{
    return AddTask2(pTask, rtoid, dwLParam, dwPriority, ITSSFLAG_TASK_PLACEINBACK);
}

STDMETHODIMP CShellTaskScheduler::AddTask2( IRunnableTask * pTask,
                                      REFTASKOWNERID rtoid,
                                      DWORD_PTR dwLParam,
                                      DWORD dwPriority,
                                      DWORD grfFlags )
{                                      
    if ( !pTask )
        return E_INVALIDARG;

    HRESULT hr = E_OUTOFMEMORY;   // assume failure

    TaskNode * pNewNode = new TaskNode;
    if ( pNewNode )
    {
        pNewNode->pTask = pTask;
        pTask->AddRef();
        pNewNode->toid = rtoid;
        pNewNode->dwPriority = dwPriority;
        pNewNode->dwLParam = dwLParam;
        pNewNode->fSuspended = FALSE;

        EnterCriticalSection( &m_csListLock );

        int iPos = -1;

        if (grfFlags & ITSSFLAG_TASK_PLACEINFRONT)
        {
            iPos = InsertInPriorityOrder( m_hTaskList, pNewNode, TRUE );
        }
        else if (grfFlags & ITSSFLAG_TASK_PLACEINBACK)
        {
            iPos = InsertInPriorityOrder( m_hTaskList, pNewNode, FALSE );
        }

        if ( iPos != -1 && m_pRunning )
        {
            if ( m_pRunning->dwPriority < dwPriority )
            {
                // try to suspend the current task. If this works, the task will
                // return to the scheduler with E_PENDING. It will then be added
                // suspended in the queue to be Resumed later....
                m_pRunning->pTask->Suspend();
            }
        }

        BOOL bRes = FALSE;

        if ( iPos != -1 )
        {
            // get a worker thread and awaken it...
            // we do this in the crit section because we need to test m_pWorkerThread and
            // to save us from releasing and grabbing it again...
            bRes = _WakeScheduler();

#ifdef DEBUG
            if ( bRes && m_pWorkerThread )
            {
                //
                // We are putting this memory block in a linked list and it will most likely be freed
                // from the background thread. Remove it from the per-thread memory list to avoid
                // detecting it as a memory leak.
                //
                // WARNING - WARNING - WARNING:
                // We cannot...
                // assume that when pTask is Released it will be deleted, so move it
                // to the other thread's memory list.
                // 
                // This will be incorrect some of the time and we don't want to investigate
                // fake leaks. -BryanSt
                //transfer_to_thread_memlist( m_pWorkerThread->dwThreadID, pNewNode->pTask );
            }
#endif
        }
        LeaveCriticalSection( &m_csListLock );

        // we failed to add it to the list
        if ( iPos == -1 )
        {
            // we failed to add it to the list, must have been a memory failure...
            pTask->Release();       // for the AddRef above
            delete pNewNode;
            goto Leave;
        }

        hr = bRes ? NOERROR : E_FAIL;
    }
Leave:
    return hr;
}

STDMETHODIMP CShellTaskScheduler::RemoveTasks( REFTASKOWNERID rtoid,
                                               DWORD_PTR dwLParam,
                                               BOOL fWaitIfRunning )
{
    BOOL fRemoveAll = IsEqualGUID( TOID_NULL, rtoid );
    BOOL fAllItems = (dwLParam == ITSAT_DEFAULT_LPARAM );
    BOOL fWaitOnHandle = FALSE;

    // note, this ignores the current
    EnterCriticalSection( &m_csListLock );

    _RemoveTasksFromList( rtoid, dwLParam );

    if ( m_pRunning && ( fWaitIfRunning || m_dwStatus == ITSSFLAG_KILL_ON_DESTROY ))
    {
        // kill the current task ...
        if (( fRemoveAll || IsEqualGUID( rtoid, m_pRunning->toid )) &&
            ( fAllItems || dwLParam == m_pRunning->dwLParam ))
        {
            ASSERT( m_pRunning->pTask );
            if ( m_dwStatus == ITSSFLAG_KILL_ON_DESTROY )
            {
                m_pRunning->pTask->Kill( fWaitIfRunning );
            }

            // definitive support for waiting until they are done...
            // (note, only do it is there is a task running, otherwise we'll sit
            // on a handle that will never fire)
            if ( fWaitIfRunning )
            {
                IWantToKnowWhenCurTaskDone();

                // don't use this directly outside of the cirtical section because it can change...
                ASSERT ( m_iSignalCurTask );

                fWaitOnHandle = TRUE;
                m_iGoToSleep++;
            }
        }
    }

    LeaveCriticalSection( &m_csListLock );

    // now wait if we need to......
    if ( fWaitOnHandle )
    {
        DWORD dwRes = SHWaitForSendMessageThread(m_hCurTaskEnded, INFINITE);
        ASSERT(dwRes == WAIT_OBJECT_0);

        EnterCriticalSection( &m_csListLock );

        // Remove tasks that might have been added while the last task was finishing
        _RemoveTasksFromList( rtoid, dwLParam );

        m_iGoToSleep--;
        // See if we need to wake the thread now.
        if ( m_iGoToSleep == 0 && DPA_GetPtrCount( m_hTaskList ) > 0 )
            _WakeScheduler();

        LeaveCriticalSection( &m_csListLock );
    }

    return NOERROR;
}

BOOL CShellTaskScheduler::_RemoveTasksFromList( REFTASKOWNERID rtoid, DWORD_PTR dwLParam )
{
    // assumes that we are already holding the critical section
    
    BOOL fRemoveAll = IsEqualGUID( TOID_NULL, rtoid );
    BOOL fAllItems = (dwLParam == ITSAT_DEFAULT_LPARAM );
    int iIndex = 0;

    do
    {
        TaskNode * pNode = (TaskNode *) DPA_GetPtr( m_hTaskList, iIndex );
        if ( !pNode )
        {
            break;
        }

        ASSERT( pNode );
        ASSERT( pNode->pTask );

        if (( fRemoveAll || IsEqualGUID( pNode->toid, rtoid )) && ( fAllItems || dwLParam == pNode->dwLParam ))
        {
            // remove it
            DPA_DeletePtr( m_hTaskList, iIndex );

            if ( pNode->fSuspended )
            {
                // kill it just incase....
                pNode->pTask->Kill( FALSE );
            }
            pNode->pTask->Release();
            delete pNode;
        }
        else
        {
            iIndex ++;
        }
    }
    while ( TRUE );
    return TRUE;
}

//
// CShellTaskScheduler::MoveTask
//
STDMETHODIMP CShellTaskScheduler::MoveTask( REFTASKOWNERID rtoid,
                                            DWORD_PTR dwLParam,
                                            DWORD dwPriority,
                                            DWORD grfFlags )
{
    int  iInsert;
    int  iIndex;
    BOOL fMoveAll  = IsEqualGUID( TOID_NULL, rtoid );
    BOOL fAllItems = (dwLParam == ITSAT_DEFAULT_LPARAM );
    BOOL bMatch    = FALSE ;
    int  iIndexStart;
    int  iIndexInc;

    EnterCriticalSection( &m_csListLock );

    // Init direction of search
    if (grfFlags & ITSSFLAG_TASK_PLACEINFRONT)
    {
        iIndexStart = 0;
        iInsert = DPA_GetPtrCount( m_hTaskList );
        iIndexInc = 1;
    }
    else if (grfFlags & ITSSFLAG_TASK_PLACEINBACK)
    {
        iIndexStart = iInsert = DPA_GetPtrCount( m_hTaskList );
        iIndexInc = -1;
    }

    // Find insert point (based on priority)
    iIndex = 0;
    do
    {
        TaskNode * pNode = (TaskNode *) DPA_GetPtr( m_hTaskList, iIndex );
        if ( !pNode )
        {
            break;
        }

        if (grfFlags & ITSSFLAG_TASK_PLACEINFRONT)
        {
            if (pNode->dwPriority <= dwPriority)
            {
                iInsert = iIndex;
                break;
            }
        }
        else if (grfFlags & ITSSFLAG_TASK_PLACEINBACK)
        {
            if (pNode->dwPriority > dwPriority)
            {
                iInsert = iIndex;
            }
            else
            {
                break;
            }
        }

        iIndex++;
    }
    while (TRUE);

    // Now try and locate any items.
    iIndex = iIndexStart;
    do
    {
        TaskNode * pNode = (TaskNode *) DPA_GetPtr( m_hTaskList, iIndex );
        if ( !pNode )
        {
            break;
        }

        if (( fMoveAll || IsEqualGUID( pNode->toid, rtoid )) && 
            ( fAllItems || dwLParam == pNode->dwLParam ))
        {
            bMatch = TRUE;

            // Can we move this node?
            if ( iIndex != iInsert )
            {
                int iPos = DPA_InsertPtr( m_hTaskList, iInsert, pNode );
                if (iPos != -1)
                {
                    if ( iIndex > iInsert )
                    {
                        DPA_DeletePtr( m_hTaskList, iIndex + 1);  // Will have shifted one
                    }
                    else
                    {
                        DPA_DeletePtr( m_hTaskList, iIndex);
                    }
                }
            }
        }
        iIndex += iIndexInc;
    }
    while ( !bMatch );
    
    LeaveCriticalSection( &m_csListLock );

    return (bMatch ? S_OK : S_FALSE);
}

BOOL CShellTaskScheduler::_WakeScheduler( )
{
    // assume we are in the object's critsection.....

    if ( NULL == m_pWorkerThread )
    {
        // we need a worker quick ....
        m_pWorkerThread = FetchWorker();
    }

    return ( NULL != m_pWorkerThread );
}

VOID CShellTaskScheduler::_KillScheduler( BOOL bKillCurTask )
{
    // assumes that we are already holding the critical section
    if ( m_pRunning != NULL && bKillCurTask )
    {
        ASSERT( m_pRunning->pTask );

        // tell the currently running task that it should die
        // quickly, because we are a separate thread than the
        // one that is running the task, it can be notified
        m_pRunning->pTask->Kill( FALSE );
    }
}

UINT CShellTaskScheduler_ThreadProc( LPVOID pParam )
{
    // make sure we have a message QUEUE // BOGUS - why do we need this?
    MSG msg;
    PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE );

    ASSERT( pParam );

    HRESULT hrInit = SHCoInitialize();

    CShellTaskScheduler::WorkerData * pWorker = (CShellTaskScheduler::WorkerData *) pParam;
    DWORD dwRes = 0;

    TraceMsg(TF_SCHEDULER, "(?%x)ShellTaskScheduler::Thread Started", GetCurrentThreadId());

#ifdef DEBUG
    pWorker->dwThreadID = GetCurrentThreadId();
#endif

    // figure out who we are attatched to (where the queue is we get tasks from)
    CShellTaskScheduler * pThis = pWorker->pThis;

    // we must always have a valid parent object at this point....
    ASSERT( pThis && IS_VALID_WRITE_PTR( pThis, CShellTaskScheduler ));

    do
    {
        MSG msg;
        HRESULT hr = NOERROR;
        TaskNode * pTask = NULL;

        OBJECT_ENTER_CRITICAL_SECTION( pThis, m_csListLock );

        // this means we are being told to quit...
        if ( pThis->m_fEmptyQueueAndSleep )
        {
            // we are being told to empty the queue .....
            DPA_EnumCallback( pThis->m_hTaskList, ListDestroyCallback, pThis );
            DPA_DeleteAllPtrs( pThis->m_hTaskList );
        }
        else if ( !pThis->m_iGoToSleep )
        {
            // get the first item...
            pTask = (TaskNode *) DPA_GetPtr( pThis->m_hTaskList, 0 );
        }

        if ( pTask )
        {
            // remove from the list...
            DPA_DeletePtr( pThis->m_hTaskList, 0 );
        }
        pThis->m_pRunning = pTask;

        OBJECT_LEAVE_CRITICAL_SECTION( pThis, m_csListLock );

        if ( pTask == NULL )
        {
            // cache the scheduler pointer, as we need it to leave the crit section
            CShellTaskScheduler * pScheduler = pThis;

            // queue is empty, go back on the thread pool.....
            // we are about to enter a deep deep sleep/coma, so remove us from the object....
            OBJECT_ENTER_CRITICAL_SECTION( pScheduler, m_csListLock );

            HANDLE hSleep = pThis->m_fEmptyQueueAndSleep ? pThis->m_hCurTaskEnded : NULL;
            BOOL fEmptyAndLeave = pThis->m_fEmptyQueueAndSleep;

            // make sure they didn't just add something to the queue, or have we been asked to go to sleep
            if ( pThis->m_iGoToSleep || DPA_GetPtrCount( pThis->m_hTaskList ) == 0)
            {
                if ( CShellTaskScheduler::ReleaseWorker( pWorker ))
                {
                    pThis = NULL;
                }
            }
            OBJECT_LEAVE_CRITICAL_SECTION( pScheduler, m_csListLock );

            if ( pThis && !fEmptyAndLeave )
            {
                // they must have added something at the last moment...
                continue;
            }

            // we are being emptied, tell them we are no longer attatched....
            if ( hSleep )
            {
                ReleaseSemaphore( hSleep, 1, NULL);
            }

            break;
        }
        else
        {
#ifndef DEBUG
            //__try
            {
#endif
                if ( pTask->fSuspended )
                {
                    pTask->fSuspended = FALSE;
                    hr = pTask->pTask->Resume();
                }
                else
                {
                    // run the task...
                    hr = pTask->pTask->Run( );
                }
#ifndef DEBUG
            }
            //__except( EXCEPTION_EXECUTE_HANDLER )
           // {
                // ignore it.... and pray we are fine...
            //}
           // __endexcept
#endif

            BOOL fEmptyQueue;
            OBJECT_ENTER_CRITICAL_SECTION( pThis, m_csListLock );
            {
                pThis->m_pRunning = NULL;

                // check to see if we have been asked to notify them
                // on completion....
                // NOTE: the NOT clause is needed so that we release ourselves
                // NOTE: and signal them at the right point, if we do it here,
                // NOTE: they leave us stranded, delete the crit section and
                // NOTE: we fault.
                if ( pThis->m_iSignalCurTask && !pThis->m_fEmptyQueueAndSleep )
                {
                    LONG lPrevCount = 0;

                    // release all those that are waiting. (we are using a semaphore
                    // because we are a free threaded object and God knows how many
                    // threads are waiting, and he passed on the information in the
                    // iSignalCurTask variable
                    ReleaseSemaphore( pThis->m_hCurTaskEnded, pThis->m_iSignalCurTask, &lPrevCount );

                    // reset the count.
                    pThis->m_iSignalCurTask = 0;
                }
                fEmptyQueue = pThis->m_fEmptyQueueAndSleep;
            }
            OBJECT_LEAVE_CRITICAL_SECTION( pThis, m_csListLock );

            if ( hr != E_PENDING || fEmptyQueue )
            {
                ULONG cRef = pTask->pTask->Release();
                delete pTask;
                pTask = NULL;
            }

            // empty the message queue...
            while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ))
            {
                {
#ifdef DEBUG
                    if (msg.message == WM_ENDSESSION)
                        TraceMsg(TF_SCHEDULER, "(?%x)csts.tp: peek #2 got WM_ENDESSION", GetCurrentThreadId());
#endif
                    TranslateMessage( &msg );
                    DispatchMessage( &msg );
                }
            }

            ASSERT( pThis && IS_VALID_WRITE_PTR( pThis, CShellTaskScheduler ));

            // the task must have been suspended because a higher priority
            // task has been added to the queue..... (this only works if the
            // task supports the Suspend() method).
            if ( hr == E_PENDING && pTask && !fEmptyQueue )
            {
                // put the task on the Suspended Queue ....
                pTask->fSuspended = TRUE;
                OBJECT_ENTER_CRITICAL_SECTION( pThis, m_csListLock );
                int iIndex = InsertInPriorityOrder( pThis->m_hTaskList, pTask, TRUE );
                OBJECT_LEAVE_CRITICAL_SECTION( pThis, m_csListLock );

                if ( iIndex == -1 )
                {
                    // we are so low on memory, kill it...
                    pTask->pTask->Kill( FALSE );
                    pTask->pTask->Release();
                    delete pTask;
                }
                pTask = NULL;
           }
       }
    }
    while ( TRUE );

    TraceMsg(TF_SCHEDULER, "(?%x)ShellTaskScheduler::Thread Ended", GetCurrentThreadId());
    SHCoUninitialize(hrInit);

    return 0;
}


STDMETHODIMP CShellTaskScheduler::Status( DWORD dwStatus, DWORD dwThreadTimeout )
{
    m_dwStatus = dwStatus & ITSSFLAG_FLAGS_MASK;
    if ( dwThreadTimeout != ITSS_THREAD_TIMEOUT_NO_CHANGE )
    {
/*
 * We don't support thread termination or pool timeout any more

        if ( dwStatus & ITSSFLAG_THREAD_TERMINATE_TIMEOUT )
        {
            m_dwThreadRlsKillTimeout = dwThreadTimeout;
        }
        else if ( dwStatus & ITSSFLAG_THREAD_POOL_TIMEOUT )
        {
            CShellTaskScheduler::s_dwComaTimeout = dwThreadTimeout;
        }
*/
    }
    return NOERROR;
}

STDMETHODIMP_(UINT) CShellTaskScheduler::CountTasks(REFTASKOWNERID rtoid)
{
    UINT iMatch = 0;
    BOOL fMatchAll = IsEqualGUID( TOID_NULL, rtoid );

    ENTER_CRITICAL_SECTION( m_csListLock );
    if ( fMatchAll )
    {
        iMatch = DPA_GetPtrCount( m_hTaskList );
    }
    else
    {
        int iIndex = 0;
        do
        {
            TaskNode * pNode = (TaskNode * )DPA_GetPtr( m_hTaskList, iIndex ++ );
            if ( !pNode )
            {
                break;
            }

            if ( IsEqualGUID( pNode->toid, rtoid ))
            {
                iMatch ++;
            }
        }
        while ( TRUE );
    }

    if ( m_pRunning )
    {
        if ( fMatchAll || IsEqualGUID( rtoid, m_pRunning->toid ))
        {
            iMatch ++;
        }
    }

    LEAVE_CRITICAL_SECTION( m_csListLock );

    return iMatch;

}


////////////////////////////////////////////////////////////////////////////////////
int InsertInPriorityOrder( HDPA hTaskList, TaskNode * pNewNode, BOOL fStart )
{
    // routine assumes that we are thread safe, therfore grab the crit-section
    // prior to calling this function

    int iPos = -1;
    int iIndex = 0;
    do
    {
        TaskNode * pNode = (TaskNode *) DPA_GetPtr( hTaskList, iIndex );
        if ( !pNode )
        {
            break;
        }

        // the fStart allows us to either add it before other tasks of the same
        // priority or after.
        if ((( pNode->dwPriority < pNewNode->dwPriority ) && !fStart ) || (( pNode->dwPriority <= pNewNode->dwPriority ) && fStart ))
        {
            iPos = DPA_InsertPtr( hTaskList, iIndex, pNewNode );
            break;
        }
        iIndex ++;
    }
    while ( TRUE );

    if ( iPos == -1 )
    {
        // add item to end of list...
        iPos = DPA_AppendPtr( hTaskList, pNewNode );
    }

    return iPos;
}


CShellTaskScheduler::WorkerData * CShellTaskScheduler::FetchWorker()
{
    WorkerData * pWorker = new WorkerData;

    if ( pWorker )
    {
        // call to Shlwapi thread pool
        if ( pWorker->Init(this) && SHQueueUserWorkItem( (LPTHREAD_START_ROUTINE)CShellTaskScheduler_ThreadProc,
                                                     pWorker,
                                                     0,
                                                     (DWORD_PTR)NULL,
                                                     (DWORD_PTR *)NULL,
                                                     "browseui.dll",
                                                     TPS_LONGEXECTIME | TPS_DEMANDTHREAD
                                                     ) )
        {
            return pWorker;
        }
        else
            delete pWorker;
    }

    return NULL;
}


// used by main thread proc to release its link the the task scheduler because it
// has run out of things to do....
BOOL CShellTaskScheduler::ReleaseWorker( WorkerData * pWorker )
{
    ASSERT( pWorker && IS_VALID_WRITE_PTR( pWorker, WorkerData ));

    CShellTaskScheduler * pThis = pWorker->pThis;

    OBJECT_ASSERT_CRITICAL_SECTION( pThis, m_csListLock );

    ASSERT( pWorker && IS_VALID_WRITE_PTR( pWorker, CShellTaskScheduler::WorkerData ));

    if ( DPA_GetPtrCount( pThis->m_hTaskList ) > 0 )
    {
        // something was added to the queue at the last minute....
        return FALSE;
    }

    // we assume we have entered the critsection of pThis
    pThis->m_pWorkerThread = NULL;
    pWorker->pThis = NULL;

    delete pWorker;

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CShellTaskScheduler::WorkerData::Init(CShellTaskScheduler *pts)
{
    pThis = pts;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\schedule.h ===
#ifndef _SCHEDULE_H
#define _SCHEDULE_H

#ifdef __cplusplus
extern "C" {
#endif

// global function for allocating a task scheduler.
// any object that uses it must make sure that its tasks are removed from the queue
// before it exits.
// NOTE: use CoCreateInstance - thread pool removes need for global scheduler
HRESULT SHGetSystemScheduler( LPSHELLTASKSCHEDULER * ppScheduler );


#ifdef DEBUG
VOID SHValidateEmptySystemScheduler(void);
#else
#define SHValidateEmptySystemScheduler()
#endif

#ifdef __cplusplus
};
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\runonnt.h ===
// no wrappers are needed on non-x86 since this is only for win9x interop
#ifdef _X86_

#define _SHELL32_

#define PathCleanupSpec         _AorW_PathCleanupSpec
#define SHCLSIDFromString       _use_GUIDFromString_instead
#define SHCLSIDFromStringA      _use_GUIDFromStringA_instead
#define SHILCreateFromPath      _AorW_SHILCreateFromPath
#define SHSimpleIDListFromPath  _AorW_SHSimpleIDListFromPath
#define GetFileNameFromBrowse   _AorW_GetFileNameFromBrowse
#define PathQualify             _AorW_PathQualify
#define PathProcessCommand      _AorW_PathProcessCommand
#define Win32DeleteFile         _AorW_Win32DeleteFile
#define PathYetAnotherMakeUniqueName    _AorW_PathYetAnotherMakeUniqueName
#define PathResolve             _AorW_PathResolve
#define Shell_GetCachedImageIndex _AorW_Shell_GetCachedImageIndex
#define SHRunControlPanel       _AorW_SHRunControlPanel
#define PickIconDlg             _AorW_PickIconDlg
#define SHCreateDirectory       _AorW_SHCreateDirectory

// The following functions were originally only TCHAR versions
// in Win95, but now have A/W versions.  Since we still need to
// run on Win95, we need to treat them as TCHAR versions and
// undo the A/W #define
#ifdef ILCreateFromPath
#undef ILCreateFromPath
#endif
#define ILCreateFromPath        _AorW_ILCreateFromPath

#ifdef SHGetSpecialFolderPath
#undef SHGetSpecialFolderPath
#endif
#define SHGetSpecialFolderPath  _AorW_SHGetSpecialFolderPath

#ifdef IsLFNDrive
#undef IsLFNDrive
#endif
#define IsLFNDrive              _AorW_IsLFNDrive

#ifdef UNICODE                  // Wrapper needed only on UNICODE build
#undef ShellAbout
#define ShellAbout              _AorW_ShellAbout
#endif

// Define the prototypes for each of these forwarders...

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */
extern int _WorA_Shell_GetCachedImageIndex(LPCWSTR pszIconPath, int iIconIndex, UINT uIconFlags);
extern int _AorW_Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags);
extern int _AorW_SHRunControlPanel(LPCTSTR pszOrig_cmdline, HWND errwnd);
extern LPITEMIDLIST _AorW_ILCreateFromPath(LPCTSTR pszPath);
extern int _AorW_PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec);
extern void _AorW_PathQualify(LPTSTR pszDir);
extern LONG WINAPI _AorW_PathProcessCommand(LPCTSTR lpSrc, LPTSTR lpDest, int iDestMax, DWORD dwFlags);
extern BOOL _AorW_SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR pszPath, int nFolder, BOOL fCreate);
extern HRESULT _AorW_SHILCreateFromPath(LPCTSTR pszPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut);
extern LPITEMIDLIST _AorW_SHSimpleIDListFromPath(LPCTSTR pszPath);
extern BOOL WINAPI _AorW_GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cchFilePath,
        LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle);

extern BOOL _AorW_Win32DeleteFile(LPCTSTR lpszFileName);

extern BOOL _AorW_PathYetAnotherMakeUniqueName(LPTSTR  pszUniqueName,
                                         LPCTSTR pszPath,
                                         LPCTSTR pszShort,
                                         LPCTSTR pszFileSpec);

extern BOOL _AorW_PathResolve(LPTSTR lpszPath, LPCTSTR dirs[], UINT fFlags);

extern BOOL _AorW_IsLFNDrive(LPTSTR lpszPath);
extern int  _AorW_PickIconDlg(HWND hwnd, LPTSTR pszIconPath, UINT cchIconPath, int * piIconIndex);
extern int  _AorW_SHCreateDirectory(HWND hwnd, LPCTSTR pszPath);
extern int  _AorW_ShellAbout(HWND hWnd, LPCTSTR szApp, LPCTSTR szOtherStuff, HICON hIcon);


//
//  This is the "RunOn95" section, which thunks UNICODE functions
//  back down to ANSI so we can run on Win95 in browser-only mode.
//

#ifdef UNICODE
#define ILCreateFromPathA       _ILCreateFromPathA
#define ILCreateFromPathW        ILCreateFromPath
extern LPITEMIDLIST _ILCreateFromPathA(LPCSTR pszPath);
#else
#define ILCreateFromPathA        ILCreateFromPath
#define ILCreateFromPathW       _ILCreateFromPathW
extern LPITEMIDLIST _ILCreateFromPathW(LPCWSTR pszPath);
#endif


#define OpenRegStream       SHOpenRegStream     // shlwapi.dll

//
//  Miracle of miracles - We don't need to wrap SHStartNetConnectionDialogW
//  because Win9x/IE4 actually implements the thunk!
//

//
//  You cannot send these messages because Win95 doesn't understand them.
//
#undef BFFM_SETSELECTIONW
#undef BFFM_SETSTATUSTEXTW


#ifdef __cplusplus
}

#endif  /* __cplusplus */

#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\searchext.cpp ===
#include "priv.h"
#include "varutil.h"

// static context menu for the start.search menu. note, this gets invoked directly
// by a number of clients (in shell32 for example)

class CShellSearchExt : public IContextMenu, public IObjectWithSite
{
public:
    CShellSearchExt();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT wFlags, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *pUnkSite);        
    STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

protected:
    virtual ~CShellSearchExt(); // for a derived class

private:    
    virtual BOOL _GetSearchUrls(GUID *pguid, LPTSTR psz, DWORD cch, 
                                LPTSTR pszUrlNavNew, DWORD cchNavNew, BOOL *pfRunInProcess);
    HRESULT _IsShellSearchBand(REFGUID guidSearch);
    HRESULT _ShowShellSearchResults(IWebBrowser2* pwb2, BOOL fNewFrame, REFGUID guidSearch);

    LONG _cRef;
    IUnknown *_pSite;
};

STDAPI CShellSearchExt_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CShellSearchExt* psse = new CShellSearchExt(); 
    if (psse)
    {
        *ppunk = SAFECAST(psse, IContextMenu*);
        return S_OK;
    }
    else
    {
        *ppunk = NULL;
        return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CShellSearchExt::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellSearchExt, IContextMenu),         
        QITABENT(CShellSearchExt, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CShellSearchExt::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CShellSearchExt::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CShellSearchExt::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    return E_NOTIMPL;
}

#define SZ_SHELL_SEARCH TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FindExtensions\\Static\\ShellSearch")

BOOL CShellSearchExt::_GetSearchUrls(GUID *pguidSearch, LPTSTR pszUrl, DWORD cch, 
                                     LPTSTR pszUrlNavNew, DWORD cchNavNew, BOOL *pfRunInProcess)
{
    BOOL bRet = FALSE;

    *pfRunInProcess = FALSE;        // Assume that we are not forcing it to run in process.
    if (pszUrl == NULL || IsEqualGUID(*pguidSearch, GUID_NULL) || pszUrlNavNew == NULL)
        return bRet;

    *pszUrlNavNew = 0;

    HKEY hkey;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_SHELL_SEARCH, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szSubKey[32];
        HKEY  hkeySub;

        for (int i = 0; wnsprintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%d"), i), 
                    RegOpenKey(hkey, szSubKey, &hkeySub) == ERROR_SUCCESS;
             i++)
        {
            TCHAR szSearchGuid[MAX_PATH];
            DWORD dwType, cb = sizeof(szSearchGuid);
            if (SHGetValue(hkeySub, TEXT("SearchGUID"), NULL, &dwType, (BYTE*)szSearchGuid, &cb) == ERROR_SUCCESS)
            {
                GUID guid;
                
                if (GUIDFromString(szSearchGuid, &guid) &&
                    IsEqualGUID(guid, *pguidSearch))
                {
                    cb = cch * sizeof(TCHAR);
                    bRet = (SHGetValue(hkeySub, TEXT("SearchGUID\\Url"), NULL, &dwType, (BYTE*)pszUrl, &cb) == ERROR_SUCCESS);
                    if (bRet || IsEqualGUID(*pguidSearch, SRCID_SFileSearch))
                    {
                        if (!bRet)
                        {
                            *pszUrl = 0;
                            // in file search case we don't need url but we still succeed
                            bRet = TRUE;
                        }
                        // See if there is a URL that we should navigate to if we
                        // are navigating to a new 
                        cb = cchNavNew * sizeof(TCHAR);
                        SHGetValue(hkeySub, TEXT("SearchGUID\\UrlNavNew"), NULL, &dwType, (BYTE*)pszUrlNavNew, &cb);

                        // likewise try to grab the RunInProcess flag, if not there or zero then off, else on
                        // reuse szSearchGuid for now...
                        *pfRunInProcess = (BOOL)SHRegGetIntW(hkeySub, L"RunInProcess", 0);
                    }
                    RegCloseKey(hkeySub);
                    break;
                }
            }
            RegCloseKey(hkeySub);
        }
        RegCloseKey(hkey);
    }
    if (!bRet)
        pszUrl[0] = 0;
    
    return bRet;
}

STDMETHODIMP CShellSearchExt::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    TCHAR szUrl[MAX_URL_STRING], szUrlNavNew[MAX_URL_STRING];
    BOOL bNewFrame = FALSE;

    // First get the Urls such that we can see which class we should create...
    GUID guidSearch = GUID_NULL;
    BOOL fRunInProcess = FALSE;
    CLSID clsidBand; // deskband object for search

    // Retrieve search ID from invoke params
    if (pici->lpParameters)
        GUIDFromStringA(pici->lpParameters, &guidSearch);

    HRESULT hr = S_OK;
    BOOL fShellSearchBand = (S_OK == _IsShellSearchBand(guidSearch));
    if (fShellSearchBand)
    {
        clsidBand = CLSID_FileSearchBand;
        if (SHRestricted(REST_NOFIND) && IsEqualGUID(guidSearch, SRCID_SFileSearch))
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // user saw the error        
    }
    else
    {
        clsidBand = CLSID_SearchBand;
        //  retrieve search URLs from registry
        if (!_GetSearchUrls(&guidSearch, szUrl, ARRAYSIZE(szUrl), szUrlNavNew, ARRAYSIZE(szUrlNavNew), &fRunInProcess))
            hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        // if invoked from within a browser reuse it, else open a new browser
        IWebBrowser2 *pwb2;
        hr = IUnknown_QueryServiceForWebBrowserApp(_pSite, IID_PPV_ARG(IWebBrowser2, &pwb2));

        if (FAILED(hr))
        {
            //  Note: we want the frame to display shell characteristics (CLSID_ShellBrowserWindow),
            //  including persistence behavior, if we're loading shell search (CLSID_FileSearchBand).
            if (fRunInProcess || IsEqualGUID(clsidBand, CLSID_FileSearchBand))
                hr = CoCreateInstance(CLSID_ShellBrowserWindow, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb2));
            else
                hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb2));
            bNewFrame = TRUE;
        }

        if (SUCCEEDED(hr))
        {
            // show html-hosting band
            VARIANT var, varEmpty = {0};
            hr = InitBSTRVariantFromGUID(&var, clsidBand);
            if (SUCCEEDED(hr))
            {
                hr = pwb2->ShowBrowserBar(&var, &varEmpty, &varEmpty);
                VariantClear(&var);
            }

            if (SUCCEEDED(hr))
            {
                if (fShellSearchBand)
                {
                    hr = _ShowShellSearchResults(pwb2, bNewFrame, guidSearch);
                }
                else
                {
                    LBSTR::CString          strUrl;
                    VARIANT varFlags;
                    varFlags.vt = VT_I4;
                    varFlags.lVal = navBrowserBar;

                    LPTSTR          pstrUrl = strUrl.GetBuffer( MAX_URL_STRING );

                    if ( strUrl.GetAllocLength() < MAX_URL_STRING )
                    {
                        TraceMsg( TF_WARNING, "CShellSearchExt::InvokeCommand() - strUrl Allocation Failed!" );

                        strUrl.Empty();
                    }
                    else
                    {
                        SHTCharToUnicode( szUrl, pstrUrl, MAX_URL_STRING );

                        // Let CString class own the buffer again.
                        strUrl.ReleaseBuffer();
                    }

                    var.vt = VT_BSTR;
                    var.bstrVal = strUrl;

                    // if we opened a new window, navigate the right side to about.blank
                    if (bNewFrame)
                    {
                        LBSTR::CString          strNavNew;

                        if ( szUrlNavNew[0] )
                        {
                            LPTSTR          pstrNavNew = strNavNew.GetBuffer( MAX_URL_STRING );

                            if ( strNavNew.GetAllocLength() < MAX_URL_STRING )
                            {
                                TraceMsg( TF_WARNING, "CShellSearchExt::InvokeCommand() - strNavNew Allocation Failed!" );

                                strNavNew.Empty();
                            }
                            else
                            {
                                SHTCharToUnicode( szUrlNavNew, pstrNavNew, MAX_URL_STRING );

                                // Let CString class own the buffer again.
                                strNavNew.ReleaseBuffer();
                            }
                        }
                        else
                        {
                            strNavNew = L"about:blank";
                        }

                        // we don't care about the error here
                        pwb2->Navigate( strNavNew, &varEmpty, &varEmpty, &varEmpty, &varEmpty );
                    }

                    // navigate the search bar to the correct url
                    hr = pwb2->Navigate2( &var, &varFlags, &varEmpty, &varEmpty, &varEmpty );
                }
            }

            if (SUCCEEDED(hr) && bNewFrame)
                hr = pwb2->put_Visible(TRUE);

            pwb2->Release();
        }
    }
    return hr;
}

HRESULT CShellSearchExt::_IsShellSearchBand(REFGUID guidSearch)
{
    if (IsEqualGUID(guidSearch, SRCID_SFileSearch) ||
        IsEqualGUID(guidSearch, SRCID_SFindComputer) || 
        IsEqualGUID(guidSearch, SRCID_SFindPrinter))
        return S_OK;
    return S_FALSE;
}

HRESULT CShellSearchExt::_ShowShellSearchResults(IWebBrowser2* pwb2, BOOL bNewFrame, REFGUID guidSearch)
{
    VARIANT varBand;
    HRESULT hr = InitBSTRVariantFromGUID(&varBand, CLSID_FileSearchBand);
    if (SUCCEEDED(hr))
    {
        // Retrieve the FileSearchBand's unknown from the browser frame as a VT_UNKNOWN property;
        // (FileSearchBand initialized and this when he was created and hosted.)
        VARIANT varFsb;
        hr = pwb2->GetProperty(varBand.bstrVal, &varFsb);
        if (SUCCEEDED(hr))
        {
            IFileSearchBand* pfsb;
            if (SUCCEEDED(QueryInterfaceVariant(varFsb, IID_PPV_ARG(IFileSearchBand, &pfsb))))
            {
                // Assign the correct search type to the band
                VARIANT varSearchID;
                if (SUCCEEDED(InitBSTRVariantFromGUID(&varSearchID, guidSearch)))
                {
                    VARIANT varNil = {0};
                    VARIANT_BOOL bNavToResults = bNewFrame ? VARIANT_TRUE : VARIANT_FALSE ;
                    pfsb->SetSearchParameters(&varSearchID.bstrVal, bNavToResults, &varNil, &varNil);
                    VariantClear(&varSearchID);
                }
                pfsb->Release();
            }
            VariantClear(&varFsb);
        }
        VariantClear(&varBand);
    }
    return hr;
}

STDMETHODIMP CShellSearchExt::GetCommandString(UINT_PTR idCmd, UINT wFlags, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    return E_NOTIMPL;
}

STDMETHODIMP CShellSearchExt::SetSite(IUnknown *pUnkSite)
{
    IUnknown_Set(&_pSite, pUnkSite);
    return S_OK;
}
    
STDMETHODIMP CShellSearchExt::GetSite(REFIID riid, void **ppvSite)
{
    if (_pSite)
        return _pSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_NOINTERFACE;
}

CShellSearchExt::CShellSearchExt() : _cRef(1), _pSite(NULL)
{
}

CShellSearchExt::~CShellSearchExt()
{
    ATOMICRELEASE(_pSite);
}

class CWebSearchExt : public CShellSearchExt
{
public:
    CWebSearchExt();

private:
    virtual BOOL _GetSearchUrls(GUID *pguidSearch, LPTSTR pszUrl, DWORD cch, 
                                LPTSTR pszUrlNavNew, DWORD cchNavNew, BOOL *pfRunInProcess);
};

STDAPI CWebSearchExt_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CWebSearchExt* pwse;

    pwse = new CWebSearchExt();
    if (pwse)
    {
        *ppunk = SAFECAST(pwse, IContextMenu*);
        return S_OK;
    }
    else
    {
        *ppunk = NULL;
        return E_OUTOFMEMORY;
    }
}

CWebSearchExt::CWebSearchExt() : CShellSearchExt()
{
}

BOOL CWebSearchExt::_GetSearchUrls(GUID *pguidSearch, LPTSTR pszUrl, DWORD cch, 
                                   LPTSTR pszUrlNavNew, DWORD cchNavNew, BOOL *pfRunInProcess)
{
    // Currently does not support NavNew, can be extended later if desired, likewise for RunInProcess...
    *pfRunInProcess = FALSE;
    if (pszUrlNavNew && cchNavNew)
        *pszUrlNavNew = 0;

    return GetDefaultInternetSearchUrl(pszUrl, cch, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\shbrows2.h ===
#ifndef _SHBROWS2_H
#define _SHBROWS2_H

#include "iface.h"
#include "commonsb.h"
#include "browmenu.h"
#include "bsmenu.h"
#include "fldset.h"
#include <iethread.h>

#define MAX_SB_TEXT_LEN 256

class CIEFrameAuto;


// Define structure to be used at head of state stream that is
// not dependent on 16 or 32 bits...
typedef struct _CABSHOLD       // Cabinet Stream header
{
    DWORD   dwSize;       // Offset to where the View streamed additional info

    // First stuff from the window placement
    DWORD  flags;
    DWORD  showCmd;
    POINTL ptMinPosition;
    POINTL ptMaxPosition;
    RECTL  rcNormalPosition;

    // Stuff from Folder Settings;
    DWORD   ViewMode;       // View mode (FOLDERVIEWMODE values)
    DWORD   fFlags;         // View options (FOLDERFLAGS bits)
    DWORD   TreeSplit;      // Position of split in pixels 

    // Hot Key
    DWORD   dwHotkey;        // Hotkey

    WINVIEW wv;
} CABSHOLD;

typedef struct _CABSH       // Cabinet Stream header
{
    DWORD   dwSize;       // Offset to where the View streamed additional info

    // First stuff from the window placement
    DWORD  flags;
    DWORD  showCmd;
    POINTL ptMinPosition;
    POINTL ptMaxPosition;
    RECTL  rcNormalPosition;

    // Stuff from Folder Settings;
    DWORD   ViewMode;       // View mode (FOLDERVIEWMODE values)
    DWORD   fFlags;         // View options (FOLDERFLAGS bits)
    DWORD   TreeSplit;      // Position of split in pixels 

    // Hot Key
    DWORD   dwHotkey;        // Hotkey

    WINVIEW wv;

    DWORD   fMask;          // Flags specifying which fields are valid
    SHELLVIEWID vid;        // extended view id
    DWORD   dwVersionId;    // CABSH_VER below
    DWORD   dwRevCount;     // rev count of default settings when the folder was saved to the stream
} CABSH;

#define CABSHM_VIEWID  0x00000001
#define CABSHM_VERSION 0x00000002
#define CABSHM_REVCOUNT 0x00000004

#define CABSH_VER 1 // change this version whenever we want to change defaults
#define CABSH_WIN95_VER 0 // this was the pre-ie4 version number

class CTheater;

#define CSBSUPERCLASS CCommonBrowser

#define CSHELLBROWSER CShellBrowser2
class CShellBrowser2 :
    public CSBSUPERCLASS
{
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CSBSUPERCLASS::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CSBSUPERCLASS::Release(); };

    // IShellBrowser (same as IOleInPlaceFrame)
    virtual STDMETHODIMP InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    virtual STDMETHODIMP SetMenuSB(HMENU hmenuShared, HOLEMENU holemenuReserved, HWND hwnd);
    virtual STDMETHODIMP RemoveMenusSB(HMENU hmenuShared);
    virtual STDMETHODIMP EnableModelessSB(BOOL fEnable);
    virtual STDMETHODIMP GetViewStateStream(DWORD grfMode, IStream **ppstm);
    virtual STDMETHODIMP GetControlWindow(UINT id, HWND * lphwnd);
    virtual STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, LRESULT *pret);
    virtual STDMETHODIMP SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);
    virtual STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    virtual STDMETHODIMP OnViewWindowActive(IShellView * psv);

    // IServiceProvider
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IBrowserService
    virtual STDMETHODIMP ShowControlWindow(UINT id, BOOL fShow);
    virtual STDMETHODIMP IsControlWindowShown(UINT id, BOOL *pfShown);
    virtual STDMETHODIMP SetTitle(IShellView* psv, LPCWSTR pszName);
    virtual STDMETHODIMP UpdateWindowList(void);
    virtual STDMETHODIMP SetFlags(DWORD dwFlags, DWORD dwFlagMask);
    virtual STDMETHODIMP GetFlags(DWORD *pdwFlags);
    virtual STDMETHODIMP RegisterWindow(BOOL fUnregister, int swc);
    virtual STDMETHODIMP Offline(int iCmd);
    virtual STDMETHODIMP SetReferrer ( LPITEMIDLIST pidl) ;
    virtual STDMETHODIMP_(LRESULT) WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP OnCreate(LPCREATESTRUCT pcs);
    virtual STDMETHODIMP_(LRESULT) OnCommand(WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP OnDestroy();
    virtual STDMETHODIMP_(LRESULT) OnNotify(NMHDR * pnm);
    virtual STDMETHODIMP OnSetFocus();
    virtual STDMETHODIMP ReleaseShellView();
    virtual STDMETHODIMP ActivatePendingView();
    virtual STDMETHODIMP CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd);
    virtual STDMETHODIMP UpdateBackForwardState () ;
    virtual STDMETHODIMP CreateBrowserPropSheetExt(REFIID, LPVOID *);
    virtual STDMETHODIMP SetAsDefFolderSettings();

    virtual STDMETHODIMP _TryShell2Rename( IShellView* psv, LPCITEMIDLIST pidlNew);
    virtual STDMETHODIMP _NavigateToPidl( LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags);
    virtual STDMETHODIMP v_MayTranslateAccelerator( MSG* pmsg);
    virtual STDMETHODIMP _SwitchActivationNow( );
    virtual STDMETHODIMP _Initialize(HWND hwnd, IUnknown *pauto);
    virtual STDMETHODIMP _GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon);

    virtual STDMETHODIMP_(LPSTREAM) v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName); 
    
    // IDockingWindowSite
    virtual STDMETHODIMP SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths);

    // IInputSite
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus);
    virtual STDMETHODIMP ShowToolbar(IUnknown* punkSrc, BOOL fShow);

        //IShellBrowserService
    virtual STDMETHODIMP GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv);


    BOOL IsCShellBrowser2() { return !_fSubclassed; };

protected:
    CShellBrowser2();
    virtual ~CShellBrowser2();

    friend HRESULT CShellBrowser2_CreateInstance(HWND hwnd, void ** ppsb);

    // topmost CBaseBrowser2 in a frameset (IE3/AOL/CIS/VB)
    virtual STDMETHODIMP v_CheckZoneCrossing(LPCITEMIDLIST pidl){return _CheckZoneCrossing(pidl);};
    virtual HRESULT     _CheckZoneCrossing(LPCITEMIDLIST pidl);

    // CShellBrowser2 virtuals
    virtual LRESULT     v_ForwardMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual DWORD       v_ShowControl(UINT iControl, int iCmd);
    virtual STDMETHODIMP        v_ShowHideChildWindows(BOOL fChildOnly = FALSE);
    virtual void        v_InitMembers();
    virtual void        v_SetIcon();
    virtual void        v_GetAppTitleTemplate(LPTSTR pszBuffer, LPTSTR pszTitle);
    virtual LRESULT     v_OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu);
    virtual void        v_HandleFileSysChange(LONG lEvent, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2);
    virtual DWORD       v_RestartFlags();
    virtual void        v_FillCabStateHeader(CABSH* pcabsh, FOLDERSETTINGS *pfs);
    virtual void        v_ParentFolder();
    virtual BOOL        v_OnContextMenu(WPARAM wParam, LPARAM lParam);
    virtual BOOL        v_IsIEModeBrowser();    
    virtual BOOL        _CreateToolbar();
    virtual STDMETHODIMP _PositionViewWindow(HWND hwnd, LPRECT prc);
    virtual IStream *   _GetITBarStream(BOOL fWebBrowser, DWORD grfMode);

    //ViewStateStream related
    virtual void        v_GetDefaultSettings(IETHREADPARAM *pcv);

    void         _FillIEThreadParam(LPCITEMIDLIST pidl, IETHREADPARAM *piei);
    virtual void _UpdateFolderSettings(LPCITEMIDLIST pidl);

    BOOL        _ShouldAllowNavigateParent();
    BOOL        _ShouldSaveWindowPlacement();
    HRESULT     _GetBSForBar(LPCWSTR pwszItem, IBandSite **ppbs);
    void        _UpdateBackForwardStateNow();
    void        _ExecAllBands(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    void        _HideToolbar(IUnknown *punk);
    void        _BandClosed(IUnknown *punk, DWORD dwBandID);
    void        _ShowHideProgress();
    void        _CloseAllParents();
    void        _OnConfirmedClose();
    void        _OnClose(BOOL fPushed);
    void        _AfterWindowCreated(IETHREADPARAM *piei);
    BOOL        _ValidTargetPidl(LPCITEMIDLIST pidl, BOOL *pfTranslateRoot);
    LPITEMIDLIST _TranslateRoot(LPCITEMIDLIST pidl);
    BOOL        _GetVID(SHELLVIEWID *pvid);
    void         _UpdateRegFlags();

    void        _SaveState();
    void        _PropertyBagSaveState();
    void        _OldSaveState();
    HRESULT     _FillCabinetStateHeader(IStream *pstm, CABSH *cabsh);
    BOOL        _ReadSettingsFromStream(IStream *pstm, IETHREADPARAM *piei);
    BOOL        _ReadSettingsFromPropertyBag(IPropertyBag* ppb, IETHREADPARAM *piei);
    BOOL        _FillIEThreadParamFromCabsh(CABSH* pcabsh, IETHREADPARAM *piei);
    HRESULT     _CreateFakeNilPidl(LPITEMIDLIST *ppidl);
    BOOL        _IsPageInternet(LPCITEMIDLIST pidl);
    HRESULT     _GetPropertyBag(LPCITEMIDLIST pidl, DWORD dwFlags, REFIID riid, void** ppv);
    LPCITEMIDLIST _GetPidl();
    BOOL        _DoesPidlRoam(LPCITEMIDLIST pidl);
    void        _LoadBrowserWindowSettings(IETHREADPARAM *piei, LPCITEMIDLIST pidl);
    IDockingWindow* _GetITBar() { return _GetToolbarItem(ITB_ITBAR)->ptbar; }
    HMENU       _GetMenuFromID(UINT uID);
    void        _UpdateChildWindowSize(void);
    void        _GetAppTitle(LPTSTR pszBuffer, DWORD dwSize);
    IMenuBand*  _GetMenuBand(BOOL bDestroy);
    BOOL        _TranslateMenuMessage(HWND hwnd, UINT uMsg, WPARAM * pwParam, LPARAM * plParam, LRESULT * plRet);
    void        _ReloadTitle();
    void        _ReloadStatusbarIcon();

    BOOL        _OnTimer(UINT_PTR idTimer);
    LRESULT     _ToolbarOnNotify(LPNMHDR pnm);
    LRESULT     _OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu);
    BOOL        _OnSysMenuClick(BOOL bLeftButton, WPARAM wParam, LPARAM lParam);
    LRESULT     _OnMenuSelect(WPARAM wParam, LPARAM lParam, UINT uHelpFlags);
    void        _SetMenuHelp(HMENU hmenu, UINT wID, LPCTSTR pszHelp);
    void        _SetBrowserBarMenuHelp(HMENU hmenu, UINT wID);
    void        _SetExternalBandMenuHelp(HMENU hmenu, UINT wID);
    void        _PruneMailNewsItems(HMENU hmenu);
    void        _SetTitle( LPCWSTR pwszName);
    HRESULT     _CreateFrameServices(void);

    void        _FavoriteOnCommand(HMENU hmenu, UINT idCmd);

    void        _CommonHandleFileSysChange(LONG lEvent, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2);
    void        _FSChangeCheckClose(LPCITEMIDLIST pidl, BOOL fDisconnect);
    void        _OnFSNotify(WPARAM, LPARAM);
//    replaced by CBaseBrowser2::NavigateToTLItem()
//    void        _RecentOnCommand(UINT idCmd);
    LRESULT     _FwdTBNotify(LPTBNOTIFY ptbn);
    void        _ToolTipFromCmd(LPTOOLTIPTEXT pnm);
    void        _AddFolderOptionsPage(PROPSHEETHEADER *ppsh);
    void        _AddAdvancedOptionsPage(PROPSHEETHEADER *ppsh);
    
    void        _IncrNetSessionCount();
    void        _DecrNetSessionCount();

    friend LRESULT CALLBACK IEFrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend void CALLBACK BrowserThreadProc(IETHREADPARAM* piei);
    
    void        _ExecFileContext(UINT idCmd);
    void        _EnableFileContext(HMENU hmenuPopup);
    LPITEMIDLIST _GetSubscriptionPidl();
    HRESULT     _GetBrowserBar(int idBar, BOOL fShow, IBandSite** ppbs, const CLSID* pclsid);

    BANDCLASSINFO* _BandClassInfoFromCmdID(UINT idCmd);

    void        _AddBrowserBarMenuItems(HMENU hmenu);
    HMENU       _GetBrowserBarMenu();
    int         _IdBarFromCmdID(UINT idCmd);
    int         _eOnOffNotMunge(int eOnOffNot, UINT idCmd, UINT idBar);
    void        _SetBrowserBarState(UINT idCmd, const CLSID *pclsid, int eOnOffNot, LPCITEMIDLIST pidl = NULL);
    const CLSID * _ShowHideBrowserBar(int idBar, const CLSID *pclsid, int eOnOff, LPCITEMIDLIST pidl);
    HRESULT     _GetBandSite(int idBar, IBandSite** ppbsSite, const CLSID *pclsid, int eOnOff);
    HRESULT     _EnsureAndNavigateBand(IBandSite* pbsSite, const CLSID* pclsid, LPCITEMIDLIST pidl = NULL);
    const CLSID * _InfoShowClsid(int idBar, const CLSID *pclsid, int eOnOff, LPCITEMIDLIST pidl = NULL);
    const CLSID * _InfoIdmToCLSID(UINT idCmd);
    const CATID * _InfoIdmToCATID(UINT idCmd);
    UINT        _InfoCLSIDToIdm(const CLSID *pguid);
    BOOL        _IsSameToolbar(LPWSTR wszBarName, IUnknown *punkBar);
    HRESULT     _AddInfoBands(IBandSite *punkBandSite);
    HRESULT     _AddSearchBand(IBandSite *punkBandSite);
    HRESULT     DoCopyData(COPYDATASTRUCT *pCDS);
    HRESULT     DoRemoteNavigate();
    void        _OrganizeFavorites();    
    BOOL        _ShouldForwardMenu(UINT uMsg, WPARAM wParam, LPARAM lParam);
    void        _TheaterMode(BOOL fShow, BOOL fRestorePrevious);
#ifdef DEBUG
    void        _DumpMenus(LPCTSTR pszMsg, BOOL bMsg);
#endif
    BOOL        _LoadBrowserHelperObjects(void);

    void        _CreateBrowserBarClose(HWND hwndParent);
    void        _SetTheaterBrowserBar();
    void        _SetMenu(HMENU hmenu);
    HWND        _GetCaptionWindow();
    LRESULT     _ThunkTTNotify(LPTOOLTIPTEXTA pnmTTTA);
    BOOL        _PrepareInternetToolbar(IETHREADPARAM* piei);
    HRESULT     _SaveITbarLayout(void);
    static LRESULT CALLBACK DummyTBWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    DWORD       _GetTempZone();
    void        _UpdateZonesPane(VARIANT *pvar);
    void        _DisplayFavoriteStatus(LPCITEMIDLIST pidl);
    void        _SendCurrentPage(DWORD dwSendAs);
    void        _OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam); 
    HRESULT     _FreshenComponentCategoriesCache( BOOL bForceUpdate ) ;
    void        _QueryHKCRChanged() ;    

    void        _PruneGoSubmenu(HMENU hmenu);
    HMENU       _MenuTemplate(int id, BOOL fShell);

    void        _MungeGoMyComputer(HMENU hmenuPopup);
    void        _OnGoMenuPopup(HMENU hmenuPopup);
    void        _OnViewMenuPopup(HMENU hmenuPopup);
    void        _OnToolsMenuPopup(HMENU hmenuPopup);
    void        _OnFileMenuPopup(HMENU hmenuPopup);
    void        _OnSearchMenuPopup(HMENU hmenuPopup);
    void        _OnHelpMenuPopup(HMENU hmenuPopup);
    void        _OnMailMenuPopup(HMENU hmenuPopup);
    void        _OnEditMenuPopup(HMENU hmenuPopup);
    void        _OnFindMenuPopup(HMENU hmenuPopup);
    void        _OnExplorerBarMenuPopup(HMENU hmenuPopup);
    void        _InsertTravelLogItems(HMENU hmenu, int nPos);

    // methods and members for monitoring the current status bar code page and font
    HRESULT _GetCodePage(UINT * puiCodePage, DWORD dwCharSet);

    int         _GetIconIndex(void);
    HRESULT     _QIExplorerBand(REFIID riid, void ** ppvObj);
    virtual BOOL _CanHandleAcceleratorNow(void) {return _fActivated;}

    bool        _IsExplorerBandVisible (void);

#ifdef UNIX
    BOOL        _HandleActivation( WPARAM wParam );
#endif

    void        _GetDefaultWindowPlacement(HWND hwnd, HMONITOR hmon, WINDOWPLACEMENT* pwp);

    // NT5 specific message handling:
    BOOL        _OnAppCommand(WPARAM wParam, LPARAM lParam);
    LPARAM      _WndProcBSNT5(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    

    // Menus: see dochost.h for an explanation from the dochost perspective.
    //        REARCHITECT (scotth): difference b/t _hmenuTemplate and _hmenuFull?
    //        

    HMENU       _hmenuTemplate;
    HMENU       _hmenuFull;
    HMENU       _hmenuBrowser;          // Provided from dochost, used for _menulist
    HMENU       _hmenuCur;              // Used to keep track.  Needed when in Kiosk mode...
    HMENU       _hmenuPreMerged;
#ifdef DEBUG    
    HMENU       _hmenuHelp;             // Our help menu
#endif

    HICON       _hZoneIcon;
    HANDLE      _hEventComCat;

    CMenuList   _menulist;              // Menu list for dispatching

    IContextMenu2 *_pcmNsc;             // iff we've popped up File Menu w/ NSC context item
    IOleCommandTarget *_poctNsc;       // iff we have visible name space control band
    int         _idMenuBand;
    HWND        _hwndStatus;
    HWND        _hwndProgress;
    int         _iTBOffset[3];
    
    CBandSiteMenu *_pbsmInfo;
    UINT        _idmInfo;               // selected View.BrowserBar submenu

    IMenuBand* _pmb;                   // Use _GetMenuBand to access this

    LPITEMIDLIST _pidlReferrer;

    WINDOWPLACEMENT _wndpl;             // Used to go into and out of full screen mode.
    CLSID           _clsidThis;         // browser class ID
    
    BITBOOL     _fStatusBar : 1;
    BITBOOL     _fAutomation : 1;       // was it launched from automation?
    BITBOOL     _fShowMenu : 1;         // should we show menus?
    BITBOOL     _fForwardMenu : 1;      // should we be forwarding menu messages?
    BITBOOL     _fNoLocalFileWarning: 1; // Do we directly execute local files without warning?
    BITBOOL     _fDispatchMenuMsgs:1;   // TRUE: forward menu messages as appropriate
    BITBOOL     _fUISetByAutomation: 1; // has ui (things that go in view options) been set by automation?
    BITBOOL     _fDontSaveViewOptions:1;   // Set if we should not save the view options on exit
    BITBOOL     _fSBWSaved :1;          // single browser window saved yet?
    BITBOOL     _fInternetStart :1;     // did we start on a net site?
    BITBOOL     _fWin95ViewState:1;
    BITBOOL     _fSubclassed :1;        // are we subclassed?
    BITBOOL     _fVisitedNet :1;        // did we ever hit the net in this session?
    BITBOOL     _fUnicode :1;           // is our view window unicode?
    BITBOOL     _fKioskMode : 1;        // Are we in full screen kiosk mode?  (not the same as fullscreen/theater mode)
    BITBOOL     _fTitleSet :1;          // has our content changed our title?
    BITBOOL     _fMarshalledDispatch:1; // have we marshalled dispatch?
    BITBOOL     _fMinimized :1;         // Minimized or not. 
    BITBOOL     _fReceivedDestroy: 1;   // Received WM_DESTROY message
    BITBOOL     _fDisallowSizing: 1;
    BITBOOL     _fShowNetworkButtons:1; // Based off the registry, we display the network connect button 
    BITBOOL     _fIgnoreNextMenuDeselect:1; // TRUE: Ignore the next deselection WM_MENUSELECT (hack)
    
    BITBOOL     _fActivated:1; // TRUE: the frame is set active, FALSE: the frame is inactive
    BITBOOL     _fClosingWindow:1; // TRUE: while closing, to avoid double-save and fault

    BITBOOL     _fDidRegisterWindow:1;  // called RegisterWindow() which registers the window with the winlist
#ifdef UNIX
    BITBOOL     _fSetAddressBarFocus:1;   
#endif
#ifdef NO_MARSHALLING
    BITBOOL     _fDelayedClose:1;  // Used to mark windows for delay close.
    BITBOOL     _fOnIEThread:1;    // used to flag if we are not running on the main thread
#endif
    BITBOOL     _fUpdateBackForwardPosted:1; // have we posted to update the back/forward state?
    BITBOOL     _fValidComCatCache ;         // Have we ensured that the component cache is valid

    BITBOOL     _fShowFortezza : 1;          // status of the Fortezza menu
    BITBOOL     _fRunningInIexploreExe:1;    // are we running in iexplore.exe
    BITBOOL     _fShowSynchronize : 1;       // should we show Tools|Synchronize?
    BITBOOL     _fNilViewStream : 1;         // CabView settings were loaded for unknown pidl.

    BITBOOL     _fAppendIEToCaptionBar : 1;  // Does the NSE want Append " - IE" to the captionbar display name?  See IBrowserFrameOptions
    BITBOOL     _fAddDialUpRef : 1;          // Does the NSE want a ref on the modem connection while browsed to this folder?  See IBrowserFrameOptions
    BITBOOL     _fUseIEToolbar : 1;          // Does the NSE want to use the IE style toolbar?  See IBrowserFrameOptions
    BITBOOL     _fEnableOfflineFeature : 1;  // Does the NSE want to enable the IE Offline feature?  See IBrowserFrameOptions
    BITBOOL     _fUseIEPersistence : 1;      // Does the NSE want to use IE type persistence?  Window pos, size, icon layout. See IBrowserFrameOptions
    BITBOOL     _fInRefresh : 1;             // Ignore refresh messages (FCIDM_REFRESH) if we are currently processing a refresh. (Prevents recursion death)

    UINT        _idmComm;               // selected View.BrowserBar submenu
    UINT        _iCommOffset;           // Start position in dynamically loaded comp categories

    ULONG _uFSNotify;

    int     _iSynchronizePos;
    TCHAR   *_pszSynchronizeText;       // What is Tools|Synchronize in your language?

    // Window list related (also _fMarshalledDispatch above)
    IShellWindows*   _psw;
    int         _swcRegistered;         // the SWC_* that this window is in the winlist as
    
    // Item ContextMenu 
    IContextMenu3 * _pcm;
    long  _dwRegisterWinList;  // Have we registered with the windows list

    HWND            _hwndDummyTB;
    IExplorerToolbar* _pxtb;
    int             _nTBTextRows; 

    // For the two members below, see notes above CShellBrowser2::_SwitchActivationNow
    TBBUTTON *  _lpButtons;
    int         _nButtons;

    TBBUTTON *  _lpPendingButtons;
    int         _nButtonsPending;

    IContextMenu3*   _pcmSearch;// new style
    IContextMenu*    _pcmFind;  // old style find context menu
        
    CTheater *_ptheater;

    LPITEMIDLIST    _pidlLastHist;
    LPITEMIDLIST    _pidlMenuSelect;

    UINT            _uiZonePane;
    IInternetSecurityManager * _pism;
    HMENU                      _hfm;

    DWORD       _dwRevCount;     // rev count of the global window settings
    UINT  _nMBIgnoreNextDeselect;
    IUnknown *_punkMsgLoop;

#ifdef NO_MARSHALLING
    BOOL  _fReallyClosed;
#endif

    // _PositionViewWindow
    HWND _hwndDelayedSize;
    RECT _rcDelayedSize;
    BOOL _fHaveDelayedSize;

private:
    HRESULT _SetBrowserFrameOptions(LPCITEMIDLIST pidl);
    HRESULT _ReplaceCmdLine(LPTSTR pszCmdLine, DWORD cchSize);
};

BOOL FindBrowserWindow(void);

//
// Useful functions.
//

STDAPI_(BOOL) AddToRestartList(UINT flags, LPCITEMIDLIST pidl);
STDAPI_(BOOL) OpenFolderWindow(IETHREADPARAM* pieiIn);
HMENU _MenuTemplate(int id, BOOL bNukeTools);

#define INFOBAR_TBNAME  L"BrowserBar"
#ifndef UNIX
#define INFOBAR_WIDTH   204
#else
#define INFOBAR_WIDTH   277
#endif
#define COMMBAR_TBNAME  L"CommBar"
#define COMMBAR_HEIGHT  100

// Constants for different Browser/Info BARs
#define IDBAR_INFO         1
#define IDBAR_COMM         2
#define IDBAR_VERTICAL     IDBAR_INFO
#define IDBAR_HORIZONTAL   IDBAR_COMM
#define IDBAR_INVALID      42

#endif  // _SHBROWS2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\shbrowse.h ===
#ifndef _SHBROWSE_H
#define _SHBROWSE_H

#include "iface.h"




#endif  // _SHBROWSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\shellurl.cpp ===
/**************************************************************\
    FILE: shellurl.cpp

    DESCRIPTION:
        Implements CShellUrl.
\**************************************************************/

#include "priv.h"
#include "resource.h"
#include "util.h"
#include "shellurl.h"

#include "bandprxy.h"

#include "mluisupp.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

// We need to reroute radio urls
#define WZ_RADIO_PROTOCOL   L"vnd.ms.radio:"


//#define FEATURE_WILDCARD_SUPPORT

#define CH_DOT                TEXT('.')
#define CH_SPACE              TEXT(' ')
#define CH_SEPARATOR          TEXT('/')
#define CH_FRAGMENT           TEXT('#')

#ifdef FEATURE_WILDCARD_SUPPORT
#define CH_ASTRISK            TEXT('*')
#define CH_QUESTIONMARK       TEXT('?')
#endif // FEATURE_WILDCARD_SUPPORT

#define SZ_SPACE              TEXT(" ")
#define SZ_SEPARATOR          TEXT("/")
#define SZ_UNC                TEXT("\\\\")

#ifndef UNIX
#define CH_FILESEPARATOR      TEXT('\\')
#define SZ_FILESEPARATOR      TEXT("\\")
#else
#define CH_FILESEPARATOR      TEXT('/')
#define SZ_FILESEPARATOR      TEXT("/")
#endif

#define CE_PATHGROW 1

#define IS_SHELL_SEPARATOR(ch) ((CH_SEPARATOR == ch) || (CH_FILESEPARATOR == ch))

// Private Functions
BOOL _FixDriveDisplayName(LPCTSTR pszStart, LPCTSTR pszCurrent, LPCITEMIDLIST pidl);

#define TF_CHECKITEM 0 // TF_BAND|TF_GENERAL


/****************************************************\
    CShellUrl Constructor
\****************************************************/
CShellUrl::CShellUrl()
{
    TraceMsg(TF_SHDLIFE, "ctor CShellUrl %x", this);

    // Don't want this object to be on the stack
    ASSERT(!m_pszURL);
    ASSERT(!m_pszArgs);
    ASSERT(!m_pstrRoot);
    ASSERT(!m_pidl);
    ASSERT(!m_pidlWorkingDir);
    ASSERT(!m_hdpaPath);
    ASSERT(!m_dwGenType);
    ASSERT(!m_hwnd);
}


/****************************************************\
    CShellUrl destructor
\****************************************************/
CShellUrl::~CShellUrl()
{
    Reset();
    if (m_pstrRoot)
    {
        LocalFree(m_pstrRoot);
        m_pstrRoot = NULL;
    }

    if (m_pidlWorkingDir)
        ILFree(m_pidlWorkingDir);

    _DeletePidlDPA(m_hdpaPath);
    TraceMsg(TF_SHDLIFE, "dtor CShellUrl %x", this);
}


//***   CShellUrl::IUnknown::* {

ULONG CShellUrl::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CShellUrl::Release()
{
    ASSERT(_cRef > 0);

    // n.b. returns <0,=0,>0 (not actual dec result)
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CShellUrl::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CShellUrl, IAddressBarParser),         // IID_IUserAssist
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

//+-------------------------------------------------------------------------
// Creates and instance of CShellUrl
//--------------------------------------------------------------------------
STDAPI CShellUrl_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // Note - Aggregation checking is handled in class factory

    *ppunk = NULL;
    CShellUrl* pShellUrl = new CShellUrl();
    if (pShellUrl)
    {
        *ppunk = SAFECAST(pShellUrl, IAddressBarParser *);
        (*ppunk)->AddRef();
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


/****************************************************\
    FUNCTION: Clone

    PARAMETERS
         pShellUrl - This is the pointer to object that
               we want to clone

    DESCRIPTION:
        This function will make a deep copy of the passed
        object into 'this'
\****************************************************/
HRESULT CShellUrl::Clone(CShellUrl * pShellUrl)
{
    HRESULT hr = S_OK;
    if (!pShellUrl)
    {
        hr = E_POINTER;
        goto exit;
    }

    Str_SetPtr(&m_pszURL, pShellUrl->m_pszURL);
    Str_SetPtr(&m_pszDisplayName, pShellUrl->m_pszDisplayName);
    Str_SetPtr(&m_pszArgs, pShellUrl->m_pszArgs);
    Str_SetPtr(&m_pstrRoot, pShellUrl->m_pstrRoot);
    
    m_dwGenType = pShellUrl->m_dwGenType;
    m_dwFlags = pShellUrl->m_dwFlags;
    m_hwnd = pShellUrl->m_hwnd;

    if (m_pidl)
    {
        ILFree(m_pidl);
        m_pidl = NULL;
    }

    if (pShellUrl->m_pidl)
    {
        m_pidl = ILClone(pShellUrl->m_pidl);
        if (!m_pidl)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    if (m_pidlWorkingDir)
    {
        ILFree(m_pidlWorkingDir);
        m_pidlWorkingDir = NULL;
    }

    if (pShellUrl->m_pidlWorkingDir)
    {
        m_pidlWorkingDir = ILClone(pShellUrl->m_pidlWorkingDir);
        if (!m_pidlWorkingDir)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

    _DeletePidlDPA(m_hdpaPath);
    m_hdpaPath = NULL;
    if (pShellUrl->m_hdpaPath)
    {
        m_hdpaPath = DPA_Create(CE_PATHGROW);
        for(int nPathIndex = 0; nPathIndex < DPA_GetPtrCount(pShellUrl->m_hdpaPath); nPathIndex++)
        {
            LPITEMIDLIST pidlCurrPath = (LPITEMIDLIST) DPA_GetPtr(pShellUrl->m_hdpaPath, nPathIndex);
            LPITEMIDLIST pidlNew = ILClone(pidlCurrPath);
            if (pidlNew)
                DPA_AppendPtr(m_hdpaPath, pidlNew);
            else
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
    }

exit:
    return hr;
}



/****************************************************\
    FUNCTION: Execute

    PARAMETERS
         pbp - This is the pointer to the interface
               which is needed to find a new topmost
               window or the associated browser window.
         pfDidShellExec (Out Optional) - This parameter
               can be NULL.  If not NULL, it will be set
               to TRUE if this Execute() called ShellExec.
               This is needed by callers that wait for
               DISPID_NAVIGATECOMPLETE which will never happen
               in this case.

    DESCRIPTION:
        This command will determine if the current
    shell url needs to be shell executed or navigated
    to.  If it needs to be navigated to, it will try
    to navigate to the PIDL, otherwise, it will navigate
    to the string version.
\****************************************************/
HRESULT CShellUrl::Execute(IBandProxy * pbp, BOOL * pfDidShellExec, DWORD dwExecFlags)
{
    HRESULT hr = S_FALSE;       // S_FALSE until navigation occurs.
    ULONG ulShellExecFMask = (IsFlagSet(dwExecFlags, SHURL_EXECFLAGS_SEPVDM)) ? SEE_MASK_FLAG_SEPVDM : 0;

    ASSERT(IS_VALID_CODE_PTR(pbp, IBandProxy *));
    ASSERT(!pfDidShellExec || IS_VALID_WRITE_PTR(pfDidShellExec, BOOL));

    if (!EVAL(pbp))
        return E_INVALIDARG;

#ifdef UNIX

    // When trying to execute a shellurl we will first check if it is a local file
    // url. If so check if there is a proper file association with it. If not give
    // error and bail out.
    TCHAR szTmpPath[MAX_URL_STRING];
    BOOL  bCheckForAssoc = FALSE;
    if (m_pidl)
    {
        // Get Path from pidl
        IEGetNameAndFlags(m_pidl, SHGDN_FORPARSING, szTmpPath, SIZECHARS(szTmpPath), NULL);
        //SHTCharToAnsi( szTmpPath, szTmpPathAnsi, ARRAYSIZE(szTmpPathAnsi) );
        // Path is file path only in Ansi ??
        if (PathIsFilePath(szTmpPath) && PathFileExists(szTmpPath) )
             bCheckForAssoc = TRUE;
    }
    else
    if (GetUrlScheme(m_pszURL) == URL_SCHEME_FILE )
    {
         HRESULT hr = S_FALSE;
         TCHAR szQualifiedUrl[MAX_URL_STRING];
         DWORD cchSize = ARRAYSIZE(szQualifiedUrl);
         hr = (ParseURLFromOutsideSource(m_pszURL, szQualifiedUrl, &cchSize, NULL) ? S_OK : E_FAIL);
         if (EVAL(SUCCEEDED(hr)))
         {
             cchSize = ARRAYSIZE(szTmpPath);

             hr = PathCreateFromUrl(szQualifiedUrl, szTmpPath, &cchSize, 0);
             if (EVAL(SUCCEEDED(hr)) && PathFileExists(szTmpPath))
                 bCheckForAssoc = TRUE;
         }
    }

    if (bCheckForAssoc)
    {
        // FileHasProperAssociation returns true for all known
        // file types ( even directories )
        DWORD cch;
        if (!PathIsExe( szTmpPath )
           && !FileHasProperAssociation(szTmpPath))
        {
            MLShellMessageBox(m_hwnd,
               MAKEINTRESOURCE(IDS_SHURL_ERR_NOASSOC),
               MAKEINTRESOURCE(IDS_SHURL_ERR_TITLE),
               (MB_OK | MB_ICONERROR));
            return E_FAIL;
        }
    }

#endif

    // Is the following true: 1) The caller wants other browsers to be able to handle the URLs,
    // 2) The ShellUrl is a Web Url, and 3) IE doesn't own HTML files.
    // If all of these are true, then we will just ShellExec() the URL String so the
    // default handler can handle it.
    // Also if the user wants us to browse in a new process and we are currently in the shell process,
    // we will launch IE to handle the url.

    if ((IsFlagSet(dwExecFlags, SHURL_EXECFLAGS_DONTFORCEIE) && IsWebUrl() && !IsIEDefaultBrowser())
#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
    ||  (IsWebUrl() && IsBrowseNewProcessAndExplorer())
#endif
       )
    {
        hr = _UrlShellExec();
        ASSERT(S_OK == hr);
    }

    if ((S_OK != hr) && m_pidl && _CanUseAdvParsing())
    {
        // We will only Shell Exec it if:
        // 1. We want to Force IE (over other web browsers) and it's not browsable, even by non-default owners.
        // 2. It's not browsable by default owners.
        if (!ILIsBrowsable(m_pidl, NULL))
        {
            if (pfDidShellExec)
                *pfDidShellExec = TRUE;

            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
            TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: Execute() Going to _PidlShellExec(>%s<)", Dbg_PidlStr(m_pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
            // If NULL == m_pidl, then the String will be used.
            hr = _PidlShellExec(m_pidl, ulShellExecFMask);
        }
    }

    if (S_OK != hr)
    {
        VARIANT vFlags = {0};

        vFlags.vt = VT_I4;
        vFlags.lVal = navAllowAutosearch;

        if (pfDidShellExec)
            *pfDidShellExec = FALSE;

        // We prefer pidls, thank you
        if (m_pidl)
        {
            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
            TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: Execute() Going to pbp->NavigateToPIDL(>%s<)", Dbg_PidlStr(m_pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
            hr = pbp->NavigateToPIDL(m_pidl);
        }
        else
        {
            ASSERT(m_pszURL);
            TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: Execute() Going to pbp->NavigateToURL(%s)", m_pszURL);
#ifdef UNICODE
            hr = pbp->NavigateToURL(m_pszURL, &vFlags);
#else
            WCHAR wszURL[MAX_URL_STRING];
            SHTCharToUnicode(m_pszURL, wszURL, ARRAYSIZE(wszURL));
            hr = pbp->NavigateToURL(wszURL, &vFlags);
#endif
        }

        VariantClearLazy(&vFlags);
    }

#ifdef UNIX
    // PidlExec failed or not done at all.
    // Before passing it for navigation check if it is a shell url
    // if so, execute it.
    // The above comment is nolonger true.  This code is moved here
    // from before the navigate to fix attempt to createprocess problem
    if (S_OK != hr && m_pszURL && IsShellUrl( m_pszURL, TRUE ) )
    {
        if (pfDidShellExec)
            *pfDidShellExec = TRUE;

        hr = _UrlShellExec();
        ASSERT(S_OK == hr);
    }
#endif

    return hr;
}


/****************************************************\
    FUNCTION: _PidlShellExec

    PARAMETERS
        pidl - The Pidl to execute.

    DESCRIPTION:
        This function will call ShellExecEx() on the
    pidl specified.  It will also fill in the Current
    Working Directory and Command Line Arguments if there
    are any.
\****************************************************/
HRESULT CShellUrl::_PidlShellExec(LPCITEMIDLIST pidl, ULONG ulShellExecFMask)
{
    HRESULT hr = E_FAIL;
    SHELLEXECUTEINFO sei = {0};

    ASSERT(IS_VALID_PIDL(pidl));

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _PidlShellExec() Going to execute pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

    if (m_pidlWorkingDir)
    {
        // note, this must be MAX_URL_STRING since IEGetDisplayName can return a URL.
        WCHAR szCWD[MAX_URL_STRING];

        IEGetDisplayName(m_pidlWorkingDir, szCWD, SHGDN_FORPARSING);
        if (PathIsFilePath(szCWD))
        {
            sei.lpDirectory = szCWD;
        }
    }
    /**** TODO: Get the Current Working Directory of top most window
    if (!sei.lpDirectory || !sei.lpDirectory[0])
    {
        GetCurrentDirectory(SIZECHARS(szCurrWorkDir), szCurrWorkDir);
        sei.lpDirectory = szCurrWorkDir;
    }
    *****/

    sei.cbSize          = sizeof(SHELLEXECUTEINFO);
    sei.lpIDList        = (LPVOID) pidl;
    sei.lpParameters    = m_pszArgs;
    sei.nShow           = SW_SHOWNORMAL;
    sei.fMask           = SEE_MASK_FLAG_NO_UI | (pidl ? SEE_MASK_INVOKEIDLIST : 0) | ulShellExecFMask;
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _PidlShellExec() Cmd=>%s<, Args=>%s<, WorkDir=>%s<",
                GEN_DEBUGSTR(sei.lpFile), GEN_DEBUGSTR(sei.lpParameters), GEN_DEBUGSTR(sei.lpDirectory));

    if (ShellExecuteEx(&sei))
        hr = S_OK;
    else
    {
#ifdef DEBUG
        DWORD dwGetLastError = GetLastError();
        TraceMsg(TF_ERROR, "ShellUrl: _PidlShellExec() ShellExecuteEx() failed for this item. Cmd=>%s<; dwGetLastError=%lx", GEN_DEBUGSTR(sei.lpParameters), dwGetLastError);
#endif // DEBUG
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************\
    FUNCTION: _UrlShellExec

    DESCRIPTION:
        This function will call ShellExecEx() on the
    URL.  This is so other popular browsers can handle
    the URL if they own HTML and other web files.
\****************************************************/
HRESULT CShellUrl::_UrlShellExec(void)
{
    HRESULT hr = E_FAIL;
    SHELLEXECUTEINFO sei = {0};

    ASSERT(m_pszURL);
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _UrlShellExec() Going to execute URL=>%s<", m_pszURL);

    sei.cbSize          = sizeof(sei);
    sei.lpFile          = m_pszURL;
    sei.nShow           = SW_SHOWNORMAL;
    sei.fMask           = SEE_MASK_FLAG_NO_UI;

    if (m_pszURL && ShellExecuteEx(&sei))
        hr = S_OK;
    else
        hr = E_FAIL;

    return hr;
}

// The following function is identical to ParseURLFromOutsideSource except that it
// enables autocorrect and sets pbWasCorrected to TRUE if the string was corrected
BOOL CShellUrl::_ParseURLFromOutsideSource
(
    LPCWSTR psz,
    LPWSTR pszOut,
    LPDWORD pcchOut,
    LPBOOL pbWasSearchURL,  // if converted to a search string
    LPBOOL pbWasCorrected   // if url was autocorrected
    )
{
    // This is our hardest case.  Users and outside applications might
    // type fully-escaped, partially-escaped, or unescaped URLs at us.
    // We need to handle all these correctly.  This API will attempt to
    // determine what sort of URL we've got, and provide us a returned URL
    // that is guaranteed to be FULLY escaped.

    IURLQualify(psz, UQF_DEFAULT | UQF_AUTOCORRECT, pszOut, pbWasSearchURL, pbWasCorrected);

    //
    //  Go ahead and canonicalize this appropriately
    //
    if (FAILED(UrlCanonicalize(pszOut, pszOut, pcchOut, URL_ESCAPE_SPACES_ONLY)))
    {
        //
        //  we cant resize from here.
        //  NOTE UrlCan will return E_POINTER if it is an insufficient buffer
        //
        return FALSE;
    }

    return TRUE;
}
#ifdef UNICODE
HRESULT CShellUrl::ParseFromOutsideSource(LPCSTR pcszUrlIn, DWORD dwParseFlags, PBOOL pfWasCorrected)
{
    WCHAR wzUrl[MAX_URL_STRING];

    SHAnsiToUnicode(pcszUrlIn, wzUrl, ARRAYSIZE(wzUrl));
    return ParseFromOutsideSource(wzUrl, dwParseFlags, pfWasCorrected);
}
#endif // UNICODE


/****************************************************\
    FUNCTION: _TryQuickParse

    PARAMETERS
        pcszUrlIn - String to parse.
        dwParseFlags - Flags to modify parsing. (Defined in iedev\inc\shlobj.w)

    DESCRIPTION:
        We prefer to call g_psfDesktop->ParseDisplayName()
    and have it do the parse really quickly and without
    enumerating the name space.  We need this for things
    that are parsed but not enumerated, which includes:
    a) hidden files, b) other.

    However, we need to not parse URLs if the caller
    doesn't want to accept them.
\****************************************************/
HRESULT CShellUrl::_TryQuickParse(LPCTSTR pszUrl, DWORD dwParseFlags)
{
    HRESULT hr = E_FAIL;  // E_FAIL means we don't know yet.
    int nScheme = GetUrlScheme(pszUrl);

    // Don't parse unknown schemes because we may
    // want to "AutoCorrect" them later.
    if (URL_SCHEME_UNKNOWN != nScheme)
    {
        if ((dwParseFlags & SHURL_FLAGS_NOWEB) &&
            (URL_SCHEME_INVALID != nScheme) &&
            (URL_SCHEME_UNKNOWN != nScheme) &&
            (URL_SCHEME_MK != nScheme) &&
            (URL_SCHEME_SHELL != nScheme) &&
            (URL_SCHEME_LOCAL != nScheme) &&
            (URL_SCHEME_RES != nScheme) &&
            (URL_SCHEME_ABOUT != nScheme))
        {
            // Skip parsing this because it's a web item, and
            // the caller wants to filter those out.
        }
        else
        {
            hr = IEParseDisplayNameWithBCW(CP_ACP, pszUrl, NULL, &m_pidl);
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: ParseFromOutsideSource

    PARAMETERS
        pcszUrlIn - String to parse.
        dwParseFlags - Flags to modify parsing. (Defined in iedev\inc\shlobj.w)
        pfWasCorrected - [out] if url was autocorrected (can be null)

    DESCRIPTION:
        Convert a string to a fully qualified shell url.  Parsing
    falls into one of the following categories:

    1. If the URL starts with "\\", check if it's a UNC Path.
    2. If the URL starts something that appears to indicate that it starts
       from the root of the shell name space (Desktop), then check if it
       is an absolute ShellUrl.
    (Only do #3 and #4 if #2 was false)
    3. Check if the string is relative to the Current Working Directory.
    4. Check if the string is relative to one of the items in the
       "Shell Path".
    5. Check if the string is in the system's AppPath or DOS Path.
    6. Check if this is a URL to Navigate to.  This call will pretty much
        always succeeded, because it will accept anything as an AutoSearch
        URL.
\****************************************************/
HRESULT CShellUrl::ParseFromOutsideSource(LPCTSTR pcszUrlIn, DWORD dwParseFlags, PBOOL pfWasCorrected)
{
    HRESULT hr = E_FAIL;  // E_FAIL means we don't know yet.
    TCHAR szUrlExpanded[MAX_URL_STRING];
    LPTSTR pszUrlInMod = (LPTSTR) szUrlExpanded; // For iteration only
    LPTSTR pszErrorURL = NULL;
    BOOL fPossibleWebUrl = FALSE;
    int nScheme;
    BOOL fDisable = SHRestricted(REST_NORUN);
    m_dwFlags = dwParseFlags;

    if (pfWasCorrected)
        *pfWasCorrected = FALSE;

    if (!pcszUrlIn[0])
        return E_FAIL;

    if (!StrCmpNIW(WZ_RADIO_PROTOCOL, pcszUrlIn, ARRAYSIZE(WZ_RADIO_PROTOCOL)-1))
    {
        // We need to reroute vnd.ms.radio: urls to the regular player, since we don't support the radio bar anymore.
        // (Media bar or the external player)
        StrCpyN(szUrlExpanded, pcszUrlIn+ARRAYSIZE(WZ_RADIO_PROTOCOL)-1, SIZECHARS(szUrlExpanded));
    }
    else
    {
        SHExpandEnvironmentStrings(pcszUrlIn, szUrlExpanded, SIZECHARS(szUrlExpanded));
    }

    PathRemoveBlanks(pszUrlInMod);

    Reset(); // Empty info because we will fill it in if successful or leave empty if we fail.
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: ParseFromOutsideSource() Begin. pszUrlInMod=%s", pszUrlInMod);
    // The display Name will be exactly what the user entered.
    Str_SetPtr(&m_pszDisplayName, pszUrlInMod);

    nScheme = GetUrlScheme(pszUrlInMod);
    if ((URL_SCHEME_FILE != nScheme) || !fDisable)  // Don't parse FILE: URLs if Start->Run is disabled.
    {
        // For HTTP and FTP we can make a few minor corrections
        if (IsFlagSet(dwParseFlags, SHURL_FLAGS_AUTOCORRECT) &&
            (URL_SCHEME_HTTP == nScheme || URL_SCHEME_FTP == nScheme || URL_SCHEME_HTTPS == nScheme))
        {
            if (S_OK == UrlFixupW(szUrlExpanded, szUrlExpanded, ARRAYSIZE(szUrlExpanded)) &&
                pfWasCorrected)
            {
                *pfWasCorrected = TRUE;
            }
        }

        hr = _TryQuickParse(szUrlExpanded, dwParseFlags);
        if (FAILED(hr))
        {
            // Does this string refer to something in the shell namespace that is
            // not a standard URL AND can we do shell namespace parsing AND
            // can we use advanced parsing on it?
            if (((URL_SCHEME_UNKNOWN == nScheme) ||
                 (URL_SCHEME_SHELL == nScheme) ||
                 (URL_SCHEME_INVALID == nScheme)) &&
                !(SHURL_FLAGS_NOSNS & dwParseFlags) && _CanUseAdvParsing())
            {
                fPossibleWebUrl = TRUE;

                // Yes; is this URL absolute (e.g., "\foo" or "Desktop\foo")?
                if (IS_SHELL_SEPARATOR(pszUrlInMod[0]) ||
                    (S_OK == StrCmpIWithRoot(pszUrlInMod, FALSE, &m_pstrRoot)))
                {
                    // Yes

                    // CASE #1.
                    // It starts with "\\", so it's probably a UNC,
                    // so _ParseUNC() will call _ParseRelativePidl() with the Network
                    // Neighborhood PIDL as the relative location.  This is needed
                    // because commands like this "\\bryanst2\public\program.exe Arg1 Arg2"
                    // that need to be shell executed.
                    if (PathIsUNC(pszUrlInMod))
                    {
                        hr = _ParseUNC(pszUrlInMod, &fPossibleWebUrl, dwParseFlags, FALSE);
                        // If we got this far, don't pass off to Navigation if _ParseUNC() failed.
                        fPossibleWebUrl = FALSE;
                    }

                    if (FAILED(hr))
                    {
                        if (IS_SHELL_SEPARATOR(pszUrlInMod[0]))
                        {
                            pszErrorURL = pszUrlInMod;  // We want to keep the '\' for the error message.
                            pszUrlInMod++;    // Skip past '\'.
                        }

                        // See if we need to advance past a "Desktop".
                        if (S_OK == StrCmpIWithRoot(pszUrlInMod, FALSE, &m_pstrRoot))
                        {
                            pszUrlInMod += lstrlen(m_pstrRoot);
                            if (IS_SHELL_SEPARATOR(pszUrlInMod[0]))
                                pszUrlInMod++;
                            if (!pszUrlInMod[0])
                            {
                                // The only thing the user entered was [...]"desktop"[\]
                                // so just clone the Root pidl.
                                return _SetPidl(&s_idlNULL);
                            }
                        }

                        // CASE #2.  Passing NULL indicates that it should test relative
                        //           to the root.
                        hr = _ParseRelativePidl(pszUrlInMod, &fPossibleWebUrl, dwParseFlags, NULL, FALSE, FALSE);
                    }
                }
                else
                {
                    // No; it is relative
                    int nPathCount = 0;
                    int nPathIndex;

                    if (m_hdpaPath)
                        nPathCount = DPA_GetPtrCount(m_hdpaPath);

                    // CASE #3.  Parse relative to the Current Working Directory.
                    //           Only valid if this object's ::SetCurrentWorkingDir()
                    //           method was called.
                    if (m_pidlWorkingDir)
                    {
                        hr = _ParseRelativePidl(pszUrlInMod, &fPossibleWebUrl, dwParseFlags, m_pidlWorkingDir, TRUE, TRUE);
    #ifdef FEATURE_WILDCARD_SUPPORT
                        if (FAILED(hr) && m_pidlWorkingDir &&
                            !StrChr(pszUrlInMod, CH_SEPARATOR) && !StrChr(pszUrlInMod, CH_FILESEPARATOR))
                        {
                            LPTSTR pszWildCard = StrChr(pszUrlInMod, CH_ASTRISK);
                            if (!pszWildCard)
                                pszWildCard = StrChr(pszUrlInMod, CH_QUESTIONMARK);

                            if (pszWildCard)
                            {
                                IOleWindow * pow;
                                m_pidlWorkingDir
                            }
                        }
    #endif // FEATURE_WILDCARD_SUPPORT

                        if (FAILED(hr))
                        {
                            //
                            // Check if the place we are navigating to is the same as the current
                            // working directory.  If so then there is a good chance that the user just
                            // pressed the enter key / go button in the addressbar and we should simply
                            // refresh the current directory.
                            //
                            WCHAR szCurrentDir[MAX_URL_STRING];
                            HRESULT hr2 = IEGetNameAndFlags(m_pidlWorkingDir, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szCurrentDir, ARRAYSIZE(szCurrentDir), NULL);
                            if (FAILED(hr2))
                            {
                                // Sometimes SHGDN_FORPARSING fails and the addressbar then tries SHGDN_NORMAL
                                hr2 = IEGetNameAndFlags(m_pidlWorkingDir, SHGDN_NORMAL | SHGDN_FORADDRESSBAR, szCurrentDir, ARRAYSIZE(szCurrentDir), NULL);
                            }
    
                            if (SUCCEEDED(hr2))
                            {
                                if (0 == StrCmpI(pszUrlInMod, szCurrentDir))
                                {
                                    // It matches so stay in the current working directory
                                    _SetPidl(m_pidlWorkingDir);
                                    hr = S_OK;
                                }
                            }

                        }
                    }
                    else
                    {
                        // TODO: Get the Current Working Directory of the top most window.
                        // hr = _ParseRelativePidl(pszUrlInMod, &fPossibleWebUrl, dwParseFlags, pshurlCWD, TRUE, TRUE);
                    }

                    // CASE #4.  Parse relative to the entries in the "Shell Path".
                    //           Only valid if this object's ::AddPath() method was
                    //           called at least once.
                    for (nPathIndex = 0; FAILED(hr) && nPathIndex < nPathCount; nPathIndex++)
                    {
                        LPITEMIDLIST pidlCurrPath = (LPITEMIDLIST) DPA_GetPtr(m_hdpaPath, nPathIndex);

                        if (EVAL(pidlCurrPath))
                        {
                            ASSERT(IS_VALID_PIDL(pidlCurrPath));
                            hr = _ParseRelativePidl(pszUrlInMod, &fPossibleWebUrl, dwParseFlags, pidlCurrPath, FALSE, FALSE);
                        }
                    }


                    // CASE #5.  We need to see if the beginning of the string matches
                    //           the entry in the AppPaths or DOS Path

                    if (FAILED(hr) && IsFlagClear(dwParseFlags, SHURL_FLAGS_NOPATHSEARCH))
                        hr = _QualifyFromPath(pszUrlInMod, dwParseFlags);
                }
            }
            else
            {
                if (URL_SCHEME_FILE != nScheme)
                    fPossibleWebUrl = TRUE;
            }
        }
    }

    if (FAILED(hr) && !fPossibleWebUrl && !fDisable)
    {
        // Did the caller want to suppress UI (Error Messages)
        if (IsFlagClear(dwParseFlags, SHURL_FLAGS_NOUI))
        {
            if (!pszErrorURL)
                pszErrorURL = pszUrlInMod;
            ASSERT(pszErrorURL);

            // We were able to parse part of it, but failed parsing the second or
            // later segment.  This means we need to inform the user of their
            // misspelling.  They can force AutoSearch with "go xxx" or "? xxx"
            // if they are trying to AutoSearch something that appears in their
            // Shell Name Space.
            MLShellMessageBox(m_hwnd, MAKEINTRESOURCE(IDS_SHURL_ERR_PARSE_FAILED),
                MAKEINTRESOURCE(IDS_SHURL_ERR_TITLE),
                (MB_OK | MB_ICONERROR), pszErrorURL);
        }
    }
    else if (S_OK != hr)
    {
        if (!(dwParseFlags & SHURL_FLAGS_NOWEB))
        {
            TCHAR szQualifiedUrl[MAX_URL_STRING];
            DWORD cchSize = SIZECHARS(szQualifiedUrl);

            SHExpandEnvironmentStrings(pcszUrlIn, szUrlExpanded, SIZECHARS(szUrlExpanded));
            PathRemoveBlanks(szUrlExpanded);

            // Unintialized szQualifiedUrl causes junk characters to appear on
            // addressbar and causes registry corruption on UNIX.
            szQualifiedUrl[0] = TEXT('\0');

            // CASE #6. Just check if this is a URL to Navigate to.  This call will
            //          pretty much always succeeded, because it will accept
            //          anything as a search URL.
            if (IsFlagSet(dwParseFlags, SHURL_FLAGS_AUTOCORRECT))
            {
                hr = (_ParseURLFromOutsideSource(szUrlExpanded, szQualifiedUrl, &cchSize, NULL, pfWasCorrected) ? S_OK : E_FAIL);
            }
            else
            {
                hr = (ParseURLFromOutsideSource(szUrlExpanded, szQualifiedUrl, &cchSize, NULL) ? S_OK : E_FAIL);
            }
            if (SUCCEEDED(hr))
            {
                SetUrl(szQualifiedUrl, GENTYPE_FROMURL);
                Str_SetPtr(&m_pszDisplayName, szQualifiedUrl);    // The display Name will be exactly what the user entered.
            }

            ASSERT(!m_pidl);
            if (fDisable && SUCCEEDED(hr))
            {
                nScheme = GetUrlScheme(szQualifiedUrl);
                // We will allow all but the following schemes:
                if ((URL_SCHEME_SHELL != nScheme) &&
                    (URL_SCHEME_FILE != nScheme) &&
                    (URL_SCHEME_UNKNOWN != nScheme) &&
                    (URL_SCHEME_INVALID != nScheme))
                {
                    fDisable = FALSE;
                }
            }
        }
    }

    if (fDisable && ((URL_SCHEME_FILE == nScheme) || (URL_SCHEME_INVALID == nScheme) || (URL_SCHEME_UNKNOWN == nScheme))) 
    {
        if (IsFlagClear(dwParseFlags, SHURL_FLAGS_NOUI))
        {
            MLShellMessageBox(m_hwnd, MAKEINTRESOURCE(IDS_SHURL_ERR_PARSE_NOTALLOWED),
                MAKEINTRESOURCE(IDS_SHURL_ERR_TITLE),
                (MB_OK | MB_ICONERROR), pszUrlInMod);
        }
        hr = E_ACCESSDENIED;
        Reset(); // Just in case the caller ignores the return value.
    }

    return hr;
}


/****************************************************\
    FUNCTION: _QualifyFromPath

    PARAMETERS:
        pcszFilePathIn - String that may be in the Path.
        dwFlags - Parse Flags, not currently used.

    DESCRIPTION:
        This function will call _QualifyFromAppPath()
    to see if the item exists in the AppPaths.  If not,
    it will check in the DOS Path Env. variable with a
    call to _QualifyFromDOSPath().
\****************************************************/
HRESULT CShellUrl::_QualifyFromPath(LPCTSTR pcszFilePathIn, DWORD dwFlags)
{
    HRESULT hr = _QualifyFromAppPath(pcszFilePathIn, dwFlags);

    if (FAILED(hr))
        hr = _QualifyFromDOSPath(pcszFilePathIn, dwFlags);

    return hr;
}


/****************************************************\
    FUNCTION: _QualifyFromDOSPath

    PARAMETERS:
        pcszFilePathIn - String that may be in the Path.
        dwFlags - Parse Flags, not currently used.

    DESCRIPTION:
        See if pcszFilePathIn exists in the DOS Path Env
    variable.  If so, set the ShellUrl to that location.
\****************************************************/
HRESULT CShellUrl::_QualifyFromDOSPath(LPCTSTR pcszFilePathIn, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szPath[MAX_PATH];
    LPTSTR pszEnd = (LPTSTR) pcszFilePathIn;
    BOOL fContinue = TRUE;

    do
    {
        hr = _GetNextPossibleFullPath(pcszFilePathIn, &pszEnd, szPath, SIZECHARS(szPath), &fContinue);
        if (SUCCEEDED(hr))
        {
            if (PathFindOnPathEx(szPath, NULL, (PFOPEX_OPTIONAL | PFOPEX_COM | PFOPEX_BAT | PFOPEX_PIF | PFOPEX_EXE)))
            {
                _GeneratePidl(szPath, GENTYPE_FROMPATH);
                if (!ILIsFileSysFolder(m_pidl))
                {
                    Str_SetPtr(&m_pszArgs, pszEnd);        // Set aside Args
                    break;
                }
            }
            if (fContinue)
                pszEnd = CharNext(pszEnd);
            hr = E_FAIL;
        }
    }
    while (FAILED(hr) && fContinue);

    return hr;
}


/****************************************************\
    FUNCTION: _QualifyFromAppPath

    PARAMETERS:
        pcszFilePathIn - String that may be in the Path.
        dwFlags - Parse Flags, not currently used.

    DESCRIPTION:
        See if pcszFilePathIn exists in the AppPaths
    Registry Section.  If so, set the ShellUrl to that location.
\****************************************************/
HRESULT CShellUrl::_QualifyFromAppPath(LPCTSTR pcszFilePathIn, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szFileName[MAX_PATH];
    TCHAR szRegKey[MAX_PATH];
    DWORD dwType;
    DWORD cbData = sizeof(szFileName);
    DWORD cchNewPathSize;

    StrCpyN(szFileName, pcszFilePathIn, SIZECHARS(szFileName));
    PathRemoveArgs(szFileName);     // Get Rid of Args (Will be added later)
    cchNewPathSize = lstrlen(szFileName);   // Get size so we known where to find args in pcszFilePathIn
    PathAddExtension(szFileName, TEXT(".exe")); // Add extension if needed.

    wnsprintf(szRegKey, ARRAYSIZE(szRegKey), TEXT("%s\\%s"), STR_REGKEY_APPPATH, szFileName);
    if (NOERROR == SHGetValue(HKEY_LOCAL_MACHINE, szRegKey, TEXT(""), &dwType, (LPVOID) szFileName, &cbData))
    {
        // 1. Create Pidl from String.
        hr = _GeneratePidl(szFileName, GENTYPE_FROMPATH);

        // 2. Set aside Args
        ASSERT((DWORD)lstrlen(pcszFilePathIn) >= cchNewPathSize);
        Str_SetPtr(&m_pszArgs, &(pcszFilePathIn[cchNewPathSize]));
    }

    return hr;
}


/****************************************************\
    FUNCTION: _ParseUNC

    PARAMETERS:
        pcszUrlIn - URL, which can be a UNC path.
        pfPossibleWebUrl - Set to FALSE if we find that the user has attempted
                           to enter a Shell Url or File url but misspelled one
                           of the segments.
        dwFlags - Parse Flags
        fQualifyDispName - If TRUE when we known that we need to force the
                           URL to be fully qualified if we bind to the destination.
                           This is needed because we are using state information to
                           find the destination URL and that state information won't
                           be available later.

    DESCRIPTION:
        See if the URL passed in is a valid path
    relative to "SHELL:Desktop/Network Neighborhood".
\****************************************************/
HRESULT CShellUrl::_ParseUNC(LPCTSTR pcszUrlIn, BOOL * pfPossibleWebUrl, DWORD dwFlags, BOOL fQualifyDispName)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlNN = NULL;

    SHGetSpecialFolderLocation(NULL, CSIDL_NETWORK, &pidlNN);  // Get Pidl for "Network Neighborhood"
    if (pidlNN)
    {
        hr = _ParseRelativePidl(pcszUrlIn, pfPossibleWebUrl, dwFlags, pidlNN, FALSE, fQualifyDispName);
        ILFree(pidlNN);
    }

    return hr;
}


/****************************************************\
    FUNCTION: _ParseSeparator

    PARAMETERS:
        pidl - PIDL to ISF that has been parsed so far.
        pcszSeg - Str of rest of Url to parse.
        pfPossibleWebUrl - Set to FALSE if we know that the user attempted
                           but failed to enter a correct Shell Url.
        fQualifyDispName - If TRUE when we known that we need to force the
                           URL to be fully qualified if we bind to the
                           destination. This is needed because we are using
                           state information to find the destination URL and
                           that state information won't be available later.

    DESCRIPTION:
        This function is called after at least one
    segment in the SHELL URL has bound to a valid
    Shell Item/Folder (i.e., ITEMID).  It is called
    each time a segment in the Shell Url binds to a PIDL.
    It will then evaluate the rest of the string and
    determine if:
        1. The URL has been completely parsed
            and is valid.  This will include getting
            the command line arguments if appropriate.
        2. More segments in the URL exist and ::_ParseNextSegment()
           needs to be called to continue the recursive parsing
           of the URL.
        3. The rest of the URL indicates that it's an invalid url.

   This function is always called by ::_ParseNextSegment() and basically
   decides if it wants to continue the recursion by calling back into
   ::_ParseNextSegment() or not.  Recursion is used because it's necessary
   to back out of parsing something and go down a path if we received
   a false positive.
\****************************************************/
HRESULT CShellUrl::_ParseSeparator(LPCITEMIDLIST pidl, LPCTSTR pcszSeg, BOOL * pfPossibleWebUrl, BOOL fAllowRelative, BOOL fQualifyDispName)
{
    HRESULT hr = S_OK;
    BOOL fIgnoreArgs = FALSE;

    ASSERT(pidl && IS_VALID_PIDL(pidl));

    // Does anything follow this separator?
    if ((CH_FRAGMENT == pcszSeg[0]) || (IS_SHELL_SEPARATOR(pcszSeg[0]) && pcszSeg[1]))
    {
        // Yes, continue parsing recursively.

        // Do we need to skip the '/' or '\' separator?
        if (CH_FRAGMENT != pcszSeg[0])
            pcszSeg++;      // Skip separator

        hr = _ParseNextSegment(pidl, pcszSeg, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);
        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _ParseSeparator() Current Level pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

        if (FAILED(hr) && pfPossibleWebUrl)
        {
            *pfPossibleWebUrl = FALSE;
            // We bound to at least one level when parsing, so don't do a web search because
            // of a failure.
        }
    }
    else
    {
        // No, we will see if we have reached a valid Shell Item.

        // Is the remaining string args?
        if (CH_SPACE == pcszSeg[0])
        {
            // If there are still chars left in the string, we need to
            // verify the first one is a space to indicate Command line args.
            // Also, we need to make sure the PIDL isn't browsable because browsable
            // Shell folders/items don't take Cmd Line Args.

            if (ILIsBrowsable(pidl, NULL))
            {
                // No
                //
                // The remaining chars cannot be Command Line Args if the PIDL
                // doesn't point to something that is shell executable.  This
                // case actually happens often.
                // Example: (\\bryanst\... and \\bryanst2\.. both exist and
                //          user enters \\bryanst2\... but parsing attempts
                //          to use \\bryanst because it was found first.  This
                //          will cause recursion to crawl back up the stack and try \\bryanst2.
                hr = E_FAIL;
            }
        }
        else if (pcszSeg[0])
        {
            // No
            // The only time we allow a char after a folder segment is if it is a Shell Separator
            // Example: "E:\dir1\"

            if (IS_SHELL_SEPARATOR(*pcszSeg) && 0 == pcszSeg[1])
                fIgnoreArgs = TRUE;
            else
                hr = E_FAIL;    // Invalid because there is more to be parsed.
        }

        if (SUCCEEDED(hr))
        {
            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
            TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _ParseSeparator() Parsing Finished.  pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
            _SetPidl(pidl);

            if (!fIgnoreArgs && pcszSeg[0])
                Str_SetPtr(&m_pszArgs, pcszSeg);

            if (fQualifyDispName)
                _GenDispNameFromPidl(pidl, pcszSeg);
        }
    }

    return hr;
}


//
// Returns TRUE is the pidl is a network server
//
BOOL _IsNetworkServer(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;

    // First see if this is a network pidl
    if (IsSpecialFolderChild(pidl, CSIDL_NETWORK, FALSE))
    {
        // See if it ends in a share name
        WCHAR szUrl[MAX_URL_STRING];
        HRESULT hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szUrl, ARRAYSIZE(szUrl), NULL);
        if (FAILED(hr))
        {
            // On non-integrated browsers SHGDN_FORPARSING may fail so try
            // again without this flag.  The preceeding back slashes will be
            // missing so we add them ourselves
            szUrl[0] = CH_FILESEPARATOR;
            szUrl[1] = CH_FILESEPARATOR;
            hr = IEGetNameAndFlags(pidl, SHGDN_NORMAL | SHGDN_FORADDRESSBAR, szUrl+2, ARRAYSIZE(szUrl)-2, NULL);
        }

        fRet = SUCCEEDED(hr) && PathIsUNCServer(szUrl);
    }
    return fRet;
}


/****************************************************\
    FUNCTION: _ParseNextSegment

    PARAMETERS:
        pidlParent - Fully Qualified PIDL to ISF to find next ITEMID in pcszStrToParse.
        pcszStrToParse - pcszStrToParse will begin with either
                      a valid display name of a child ITEMID of pidlParent
                      or the Shell URL is invalid relative to pidlParent.
        fAllowRelative - Should relative moves be allowed?
        fQualifyDispName - If TRUE when we known that we need to force the
                           URL to be fully qualified if we bind to the destination.
                           This is needed because we are using state information to
                           find the destination URL and that state information won't
                           be available later.

    DESCRIPTION/PERF:
        This function exists to take the string (pcszStrToParse)
    passed in and attempt to bind to a ITEMID which
    has a DisplayName that matches the beginning of
    pcszStrToParse.  This function will check all the
    ITEMIDs under the pidlParent section of the Shell
    Name Space.

      The only two exceptions to the above method is if
    1) the string begins with "..", in which case, we
       bind to the pidlParent's Parent ITEMID. - or -
    2) The pidlParent passes the ::_IsFilePidl()
       test and we are guaranteed the item is in the
       File System or a UNC item.  This will allow us
       to call IShellFolder::ParseDisplayName() to
       find the child ITEMID of pidlParent.

    This function will iterate through the items under
    pidlParent instead of call IShellFolder::ParseDisplayName
    for two reasons: 1) The ::ParseDisplayName for "The Internet"
    will accept any string because of AutoSearch, and
    2) We never know the location of the end of one segment and
    the beginning of the next segment in pcszStrToParse.  This is
    because DisplayNames for ISFs can contain almost any character.

    If this function has successfully bind to a child ITEMID
    of pidlParent, it will call ::_ParseSeparator() with the
    rest of pcszStrToParse to parse.  _ParseSeparator() will determine
    if the end of the URL has been parsed or call back into this function
    recursively to continue parsing segments.  In the former case,
    _ParseSeparator() will set this object's PIDL and arguments which
    can be used later.  In the latter case, the recursion stack will
    unwind and my take a different path (Cases exists that require this).
\****************************************************/
HRESULT CShellUrl::_ParseNextSegment(LPCITEMIDLIST pidlParent,
            LPCTSTR pcszStrToParse, BOOL * pfPossibleWebUrl,
            BOOL fAllowRelative, BOOL fQualifyDispName)
{
    HRESULT hr = E_FAIL;

    if (!pidlParent || !pcszStrToParse)
        return E_INVALIDARG;

    // Is this ".."?
    if (fAllowRelative && CH_DOT == pcszStrToParse[0] && CH_DOT == pcszStrToParse[1])
    {
        // Yes
        LPITEMIDLIST pidl = ILClone(pidlParent);
        if (pidl && !ILIsEmpty(pidl))
        {
            ILRemoveLastID(pidl);  // pidl/psfFolder now point to the new shell item, which is the parent in this case.
            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
            TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _ParseNextSegment() Nav '..'. PIDL=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

            // Parse the next segment or finish up if we reached the end
            // (we're skipping the ".." here)
            hr = _ParseSeparator(pidl, &(pcszStrToParse[2]), pfPossibleWebUrl, fAllowRelative, fQualifyDispName);
            ILFree(pidl);
        }
    }
    else
    {
        // No
        LPTSTR pszNext = NULL; // Remove const because we will iterate only.
        long i = 0;

        // Can we parse this display name quickly?
        if (!ILIsRooted(pidlParent) && _IsFilePidl(pidlParent) &&
            
            // Quick way fails for shares right off of the network server
            !_IsNetworkServer(pidlParent))
        {       
            // Yes
            TCHAR szParseChunk[MAX_PATH+1];

            do
            {
                ++i;

                hr = _GetNextPossibleSegment(pcszStrToParse, &pszNext, szParseChunk, SIZECHARS(szParseChunk), TRUE);
                if (S_OK == hr)
                {
                    hr = _QuickParse(pidlParent, szParseChunk, pszNext, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);

                    //
                    // Certain network shares like \\foo\Printers and "\\foo\Scheduled Tasks" will fail the if we
                    // combine the server and share in a segment.  So we try parsing the server separately.
                    //
                    if ((S_OK != hr) && (i == 1) && PathIsUNCServerShare(szParseChunk))
                    {
                        pszNext = NULL;
                        hr = _GetNextPossibleSegment(pcszStrToParse, &pszNext, szParseChunk, SIZECHARS(szParseChunk), FALSE);
                        if (S_OK == hr)
                        {
                            hr = _QuickParse(pidlParent, szParseChunk, pszNext, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);
                        }
                    }

#ifdef FEATURE_SUPPORT_FRAGS_INFILEURLS
                    // Did we fail to parse the traditional way and the first char of this
                    // next chunk indicates it's probably a URL Fragment?
                    if (FAILED(hr) && (CH_FRAGMENT == pcszStrToParse[0]))
                    {
                        TCHAR szUrl[MAX_URL_STRING];
                        // Yes, so try parsing in another way that will work
                        // with URL fragments.

                        hr = ::IEGetDisplayName(pidlParent, szUrl, SHGDN_FORPARSING);
                        if (EVAL(SUCCEEDED(hr)))
                        {
                            TCHAR szFullUrl[MAX_URL_STRING];
                            DWORD cchFullUrlSize = ARRAYSIZE(szFullUrl);

                            hr = UrlCombine(szUrl, szParseChunk, szFullUrl, &cchFullUrlSize, 0);
                            if (EVAL(SUCCEEDED(hr)))
                            {
                                LPITEMIDLIST pidl = NULL;

                                hr = IEParseDisplayName(CP_ACP, szFullUrl, &pidl);
                                if (SUCCEEDED(hr))
                                {
                                    _SetPidl(pidl);

                                    if (fQualifyDispName)
                                        _GenDispNameFromPidl(pidl, szFullUrl);

                                    ILFree(pidl);
                                }
                                else
                                    ASSERT(!pidl);  // Verify IEParseDisplayName() didn't fail but return a pidl.
                            }
                        }
                    }
#endif // FEATURE_SUPPORT_FRAGS_INFILEURLS
                }
            }
            while (FAILED(hr));

            if (S_OK != hr)
                hr = E_FAIL;    // Not Found
        }
        else if (FAILED(hr))
        {
            // No; use the slow method
            IShellFolder * psfFolder = NULL;

            DWORD dwAttrib = SFGAO_FOLDER;
            IEGetAttributesOf(pidlParent, &dwAttrib);

            if (IsFlagSet(dwAttrib, SFGAO_FOLDER))
            {
                IEBindToObject(pidlParent, &psfFolder);
                ASSERT(psfFolder);
            }

            if (psfFolder)
            {
                LPENUMIDLIST penumIDList = NULL;
                HWND hwnd = _GetWindow();

                // Is this an FTP Pidl?
                if (IsFTPFolder(psfFolder))
                {
                    // NT #274795: Yes so, we need to NULL out the hwnd to prevent
                    // displaying UI because enumerator of that folder may need to display
                    // UI (to collect passwords, etc.).  This is not valid because pcszStrToParse
                    // may be an absolute path and psfFolder points to the current location which
                    // isn't valid.  This should probaby be done for all IShellFolder::EnumObjects()
                    // calls, but it's too risky right before ship.
                    hwnd = NULL;
                }

                // Warning Docfind returns S_FALSE to indicate no enumerator and returns NULL..
                if (S_OK == IShellFolder_EnumObjects(psfFolder, hwnd, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN, &penumIDList))
                {
                    LPITEMIDLIST pidlRelative;   // NOT a FULLY Qualified Pidl
                    LPITEMIDLIST pidlResult; // PIDL after it has been made Fully Qualified
                    ULONG cFetched;
                    LPTSTR pszRemaining = NULL;

                    while (FAILED(hr) && NOERROR == penumIDList->Next(1, &pidlRelative, &cFetched) && cFetched)
                    {
                        // The user will have entered the name in one of the three formats and they need to be
                        // checked from the longest string to the smallest.  This is necessary because the
                        // parser will check to see if the item's DisplayName is the first part of the user
                        // string.
                        //
                        // #1. (FORPARSING): This will be the full name.
                        //     Example: razzle.lnk on desktop = D:\nt\public\tools\razzle.lnk.
                        // #2. (FORPARSING | SHGDN_INFOLDER): This will be only the full name w/Extension.
                        //     Example: razzle.lnk on desktop = razzle.lnk
                        // #3. (SHGDN_INFOLDER): This will be the full name w/o extension if "Hide File Extensions for Known File Types" is on.
                        //     Example: razzle.lnk on desktop = D:\nt\public\tools\razzle.lnk.
                        // The user may have entered the "SHGDN_FORPARSING" Display Name or the "SHGDN_INFOLDER", so we need
                        // to check both.
                        hr = _CheckItem(psfFolder, pidlParent, pidlRelative, &pidlResult, pcszStrToParse, &pszRemaining, SHGDN_FORPARSING);
                        if (FAILED(hr))     // Used for file items w/extensions. (Like razzle.lnk on the Desktop)
                            hr = _CheckItem(psfFolder, pidlParent, pidlRelative, &pidlResult, pcszStrToParse, &pszRemaining, SHGDN_FORPARSING | SHGDN_INFOLDER);
                        if (FAILED(hr))
                            hr = _CheckItem(psfFolder, pidlParent, pidlRelative, &pidlResult, pcszStrToParse, &pszRemaining, SHGDN_INFOLDER);

                        if (SUCCEEDED(hr))
                        {
                            // See if the Display Name for a Drive ate the separator for the next segment.
                            if (_FixDriveDisplayName(pcszStrToParse, pszRemaining, pidlResult))
                            {
                                // FIX: "E:\dir1\dir2".  We expent display names to not claim the '\' separator between
                                //                       names.  The problem is that drive letters claim to be "E:\" instead
                                //                       of "E:".  So, we need to back up so we use the '\' as a separator.
                                pszRemaining--;
                            }
#ifndef UNIX
                            // Our root is equal to a separator, so it's N/A on UNIX.
                            ASSERT(pcszStrToParse != pszRemaining);
#endif
                            // Parse the next segment or finish up if we reached the end.
                            hr = _ParseSeparator(pidlResult, pszRemaining, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);

                            if (pidlResult)
                                ILFree(pidlResult);
                        }

                        ILFree(pidlRelative);
                    }
                    penumIDList->Release();
                }
                psfFolder->Release();
            }
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: _GetNextPossibleSegment

    PARAMETERS:
        pcszFullPath - Full Path
        ppszSegIterator - Pointer to iterator to maintain state.
                          WARNING: This needs to be NULL on first call.
        pszSegOut - Of S_OK is returned, this will contain the next possible segment
        cchSegOutSize - char Size of pszSegOut buffer

    DESCRIPTION:
        Generate the next possible segment that can
    be parsed.  If "one two three/four five" is passed
    in, this function will return S_OK three times
    with these values in pszSegOut:
    1) "one two three",
    2) "one two", and
    3) "one".

    In this example, S_OK will be returned for the first
    three calls, and S_FALSE will be returned for the
    fourth to indicate that no more possible segments can be obtained
    from that string.
\****************************************************/
HRESULT CShellUrl::_GetNextPossibleSegment(LPCTSTR pcszFullPath,
        LPTSTR * ppszSegIterator, LPTSTR pszSegOut, DWORD cchSegOutSize, BOOL fSkipShare)
{
    HRESULT hr = S_OK;
    LPTSTR szStart = (LPTSTR) pcszFullPath;

    // We need to treat UNCs Specially.
    if (PathIsUNC(szStart))
    {
        LPTSTR szUNCShare;
        // This is a UNC so we need to make the "Segment" include
        // the "\\server\share" because Network Neighborhood's
        // IShellFolder::ParseDisplayName() is increadibly slow
        // and makes mistakes when it parses "server" and then "share"
        // separately.

        // This if clause will advance szStart past the Server
        // section of the UNC path so the rest of the algorithm will
        // naturally continue working on the share section of the UNC.
        szStart += 2;   // Skip past the "\\" UNC header.

        // Is there a share?
        if (fSkipShare && (szUNCShare = StrChr(szStart, CH_FILESEPARATOR)))
        {
            // Yes, so advanced to the first char in the share
            // name so the algorithm below works correctly.
            szStart = szUNCShare + 1;
        }
    }

    // Do we need to initialize the iterator?  If so, set it to the
    // largest possible segment in the string because we will be
    // working backwards.
    ASSERT(ppszSegIterator);
    if (*ppszSegIterator)
    {
        *ppszSegIterator = StrRChr(szStart, *ppszSegIterator, CH_SPACE);
        if (!*ppszSegIterator)
        {
            pszSegOut[0] = TEXT('\0');  // Make sure caller doesn't ignore return and recurse infinitely.
            return S_FALSE;
        }
    }
    else
    {
        // We have not yet started the iteration, so set the ppszSegIterator to the end of the possible
        // segment.  This will be a segment separator character ('\' || '/') or the end of the string
        // if either of those don't exist.  This will be the first segment to try.
#ifndef UNIX
        *ppszSegIterator = StrChr(szStart, CH_FILESEPARATOR);
        if (!*ppszSegIterator)
            *ppszSegIterator = StrChr(szStart, CH_SEPARATOR);
#else
    // On UNIX, we always skip the 1st "/" and go to the 2nd.
    if (szStart[0] == CH_FILESEPARATOR)
            *ppszSegIterator = StrChr(szStart+1, CH_FILESEPARATOR);
#endif

        LPTSTR pszFrag = StrChr(szStart, CH_FRAGMENT);
        // Is the next separator a fragment?
        if (pszFrag && (!*ppszSegIterator || (pszFrag < *ppszSegIterator)))
        {
            TCHAR szFile[MAX_URL_STRING];

            StrCpyN(szFile, szStart, (int)(pszFrag - szStart + 1));
            if (PathIsHTMLFile(szFile))
                *ppszSegIterator = pszFrag;
        }

        if (!*ppszSegIterator)
        {
            // Go to end of the string because this is the last seg.
            *ppszSegIterator = (LPTSTR) &((szStart)[lstrlen(szStart)]);
        }
    }

    // Fill the pszSegOut parameter.
    ASSERT(*ppszSegIterator);

    // This is weird but correct.  pszEnd - pszBeginning results count of chars, not
    // count of bytes.
    if (cchSegOutSize >= (DWORD)((*ppszSegIterator - pcszFullPath) + 1))
        StrCpyN(pszSegOut, pcszFullPath, (int)(*ppszSegIterator - pcszFullPath + 1));
    else
        StrCpyN(pszSegOut, pcszFullPath, cchSegOutSize-1);

    return hr;
}


/****************************************************\
    FUNCTION: _GetNextPossibleFullPath

    DESCRIPTION:
        This function will attempt to see if strParseChunk
    is a Parsible DisplayName under pidlParent.
\****************************************************/
HRESULT CShellUrl::_GetNextPossibleFullPath(LPCTSTR pcszFullPath,
    LPTSTR * ppszSegIterator, LPTSTR pszSegOut, DWORD cchSegOutSize,
    BOOL * pfContinue)
{
    HRESULT hr = S_OK;
    LPTSTR pszNext = StrChr(*ppszSegIterator, CH_SPACE);
    DWORD cchAmountToCopy = cchSegOutSize;

    if (TEXT('\0') == (*ppszSegIterator)[0])
    {
        if (pfContinue)
            *pfContinue = FALSE;
        return E_FAIL;  // Nothing Left.
    }

    if (!pszNext)
        pszNext = &((*ppszSegIterator)[lstrlen(*ppszSegIterator)]);   // Go to end of the string because this is the last seg.

    // Copy as much of the string as we have room for.
    // The compiler will take care of adding '/ sizeof(TCHAR)'.
    if ((cchAmountToCopy-1) > (DWORD)(pszNext - pcszFullPath + 1))
        cchAmountToCopy = (int)(pszNext - pcszFullPath + 1);

    StrCpyN(pszSegOut, pcszFullPath, cchAmountToCopy);

    if (CH_SPACE == pszNext[0])
    {
        *pfContinue = TRUE;
    }
    else
        *pfContinue = FALSE;

    *ppszSegIterator = pszNext;
    return hr;
}


/****************************************************\
    FUNCTION: _QuickParse

    PARAMETERS:
        pidlParent - Pidl to ISF to parse from.
        pszParseChunk - Display Name of item in pidlParent.
        pszNext - Rest of string to parse if we succeed at parsing pszParseChunk.
        pfPossibleWebUrl - Set to FALSE if we find that the user has attempted to enter
                           a Shell Url or File url but misspelled one of the segments.
        fAllowRelative - Allow relative parsing. ("..")
        fQualifyDispName - If TRUE when we known that we need to force the
                           URL to be fully qualified if we bind to the destination.
                           This is needed because we are using state information to
                           find the destination URL and that state information won't
                           be available later.

    DESCRIPTION:
        This function will attempt to see if strParseChunk
    is a Parsible DisplayName under pidlParent.
\****************************************************/
HRESULT CShellUrl::_QuickParse(LPCITEMIDLIST pidlParent, LPTSTR pszParseChunk,
    LPTSTR pszNext, BOOL * pfPossibleWebUrl, BOOL fAllowRelative,
    BOOL fQualifyDispName)
{
    HRESULT hr;
    IShellFolder * psfFolder;

    hr = IEBindToObject(pidlParent, &psfFolder);
    if (SUCCEEDED(hr))
    {
        ULONG ulEatten; // Not used.
        SHSTRW strParseChunkThunked;

        hr = strParseChunkThunked.SetStr(pszParseChunk);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl = NULL;

            // TODO: In the future, we may want to cycle through commonly used extensions in case the
            //       user doesn't add them.
            hr = psfFolder->ParseDisplayName(_GetWindow(), NULL, strParseChunkThunked.GetInplaceStr(), &ulEatten, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                // IShellFolder::ParseDisplayName() only generates PIDLs that are relative to the ISF.  We need
                // to make them Absolute.
                LPITEMIDLIST pidlFull = ILCombine(pidlParent, pidl);

                if (pidlFull)
                {
                    // Parse the next segment or finish up if we reached the end.
                    hr = _ParseSeparator(pidlFull, pszNext, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);
                    ILFree(pidlFull);
                }
                ILFree(pidl);
            }
        }
        psfFolder->Release();
    }

    return hr;
}


/****************************************************\
    FUNCTION: _CheckItem

    DESCRIPTION:
        This function will obtain the Display Name
    of the ITEMID (pidlRelative) which is a child of
    psfFolder.  If it's Display Name matches the first
    part of pcszStrToParse, we will return successful
    and set ppszRemaining to the section of pcszStrToParse
    after the segment just parsed.

    This function will also see if the Display Name ends
    in something that would indicate it's executable.
    (.EXE, .BAT, .COM, ...).  If so, we will match if
    pcszStrToParse matches the Display Name without the
    Extension.
\****************************************************/
HRESULT CShellUrl::_CheckItem(IShellFolder * psfFolder,
    LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlRelative,
    LPITEMIDLIST * ppidlChild, LPCTSTR pcszStrToParse,
    LPTSTR * ppszRemaining, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;

    *ppidlChild = NULL;

    TCHAR szISFName[MAX_URL_STRING];
    if (SUCCEEDED(DisplayNameOf(psfFolder, pidlRelative, dwFlags, szISFName, SIZECHARS(szISFName))))
    {
        DWORD  cchISFLen     = lstrlen(szISFName);
        DWORD  cchStrToParse = lstrlen(pcszStrToParse);
        BOOL   fEqual = FALSE;

        // Either the item needs to match exactly, or it needs to do a partial match
        // if the Shell Object is an executable file.  For Example: "msdev" should match the
        // "msdev.exe" file object.
        if (cchISFLen > 0)
        {
            // We want to see if pcszStrToParse is a match to the first part of szISFName.

            // First we will try to see if it's a direct match.
            // Example: User="file.exe" Shell Item="file.exe"
            // But we DON'T want to match if the StrToParse is longer than
            // ISFName, unless the next char in StrToParse is a separator.
            // If StrToParse is shorter than ISFName, then it can't be an exact match.
            if (cchStrToParse >= cchISFLen &&
                0 == StrCmpNI(szISFName, pcszStrToParse, cchISFLen) &&
                (cchStrToParse == cchISFLen || IS_SHELL_SEPARATOR(pcszStrToParse[cchISFLen])))
            {
                fEqual = TRUE;
            }
            else
            {
                int cchRoot = (int)((PathFindExtension(szISFName)-szISFName));
                // If that failed, we try to see if the Shell Item is
                // executable (.EXE, .COM, .BAT, .CMD, ...) and if so,
                // we will see if pcszStrToParse matches Shell Item w/o the file
                // extension.

                // REARCHITECT this will match if there happens to be a space in the user's
                //  filename that doesn't denote commandline arguments.
                //  Example: User="foo file.doc" Shell Item="foo.exe"

                if (PathIsExe(szISFName) &&                         // shell object is executable
                    (!((dwFlags & SHGDN_INFOLDER) && !(dwFlags & SHGDN_FORPARSING))) && // we didn't strip extension
                    ((lstrlen(pcszStrToParse) >= cchRoot) &&        // and user entered at least root chars
                     ((pcszStrToParse[cchRoot] == TEXT('\0')) ||    // and user entered exact root
                      (pcszStrToParse[cchRoot] == TEXT(' ')))) &&   //     or possible commandline args
                    (0 == StrCmpNI(szISFName, pcszStrToParse, cchRoot)))    // and the root matches
                {
                    // This wasn't a direct match, but we found that the segment entered
                    // by the user (pcszStrToParse) matched

                    // We found that the ISF item is an executable object and the
                    // string matched w/o the extension.
                    fEqual = TRUE;
                    cchISFLen = cchRoot;        // So that we generate *ppszRemaining correctly
                }
            }
        }

        if (fEqual)
        {
            hr = S_OK;    // We were able to navigate to this shell item token.
            *ppszRemaining = (LPTSTR) &(pcszStrToParse[cchISFLen]); // We will only iterate over the string, so it's ok that we loose the const.
            *ppidlChild = ILCombine(pidlParent, pidlRelative);
            TraceMsg(TF_CHECKITEM, "ShellUrl: _CheckItem() PIDL=>%s< IS EQUAL TO StrIn=>%s<", pcszStrToParse, szISFName);
        }
        else
            TraceMsg(TF_CHECKITEM, "ShellUrl: _CheckItem() PIDL=>%s< not equal to StrIn=>%s<", pcszStrToParse, szISFName);
    }

    return hr;
}


/****************************************************\
    FUNCTION: _IsFilePidl

    PARAMETERS:
        pidl (IN) - Pidl to check if it is a File Pidl

    DESCRIPTION:
        The PIDL is a file pidl if:
    1. The pidl equals "Network Neighborhood" or descendent
    2. The pidl's grandparent or farther removed from "My Computer".

    This algorithm only allows "Network Neighborhood" because
    that ISF contains a huge number of PIDLs and takes for ever
    to enumerate.  The second clause will work in any part of the
    file system except for the root drive (A:\, C:\).  This is
    because we need to allow other direct children of "My Computer"
    to use the other parsing.
\****************************************************/
BOOL CShellUrl::_IsFilePidl(LPCITEMIDLIST pidl)
{
    BOOL fResult = FALSE;
    BOOL fNeedToSkip = FALSE;

    if (!pidl || ILIsEmpty(pidl))
        return fResult;

    // Test for Network Neighborhood because it will take forever to enum.
    fResult = IsSpecialFolderChild(pidl, CSIDL_NETWORK, FALSE);

    if (!fResult)
    {
        // We only want to do this if we are not the immediate
        // child.
        if (IsSpecialFolderChild(pidl, CSIDL_DRIVES, FALSE))
        {
            TCHAR szActualPath[MAX_URL_STRING];        // IEGetDisplayName() needs the buffer to be this large.
            IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szActualPath, SIZECHARS(szActualPath), NULL);

            DWORD dwOutSize = MAX_URL_STRING;
            if (SUCCEEDED(PathCreateFromUrl(szActualPath, szActualPath, &dwOutSize, 0)))
            {
                PathStripToRoot(szActualPath);
                fResult = PathIsRoot(szActualPath);
            }
#ifdef UNIX
            else
            {
                fResult = (szActualPath[0]==TEXT('/'));
            }
#endif
        }
    }

    return fResult;
}



/****************************************************\
    FUNCTION: IsWebUrl

    PARAMETERS
         none.

    DESCRIPTION:
         Return TRUE if the URL is a Web Url (http,
    ftp, other, ...).  Return FALSE if it's a Shell Url
    or File Url.
\****************************************************/
BOOL CShellUrl::IsWebUrl(void)
{
    if (m_pidl)
    {
        if (!IsURLChild(m_pidl, TRUE))
            return FALSE;
    }
    else
    {
        ASSERT(m_pszURL);   // This CShellUrl hasn't been set.
        if (m_pszURL && IsShellUrl(m_pszURL, TRUE))
            return FALSE;
    }

    return TRUE;
}


/****************************************************\
    FUNCTION: SetCurrentWorkingDir

    PARAMETERS
         pShellUrlNew - Pointer to a CShellUrl that will
                        be the "Current Working Directory"

    DESCRIPTION:
         This Shell Url will have a new current working
    directory, which will be the CShellUrl passed in.

    MEMORY ALLOCATION:
         The caller needs to Allocate pShellUrlNew and
    this object will take care of freeing it.  WARNING:
    this means it cannot be on the stack.
\****************************************************/
HRESULT CShellUrl::SetCurrentWorkingDir(LPCITEMIDLIST pidlCWD)
{
    Pidl_Set(&m_pidlWorkingDir, pidlCWD);

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: SetCurrentWorkingDir() pidl=>%s<", Dbg_PidlStr(m_pidlWorkingDir, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    return S_OK;
}


/****************************************************\
    PARAMETERS
         pvPidl1 - First pidl to compare
         pvPidl2 - Second pidl to compare

    DESCRIPTION:
         Return if the pidl matches.  This doesn't work
    for sorted lists (because we can't determine less
    than or greater than).
\****************************************************/
int DPAPidlCompare(LPVOID pvPidl1, LPVOID pvPidl2, LPARAM lParam)
{
    // return < 0 for pvPidl1 before pvPidl2.
    // return == 0 for pvPidl1 equals pvPidl2.
    // return > 0 for pvPidl1 after pvPidl2.
    return (ILIsEqual((LPCITEMIDLIST)pvPidl1, (LPCITEMIDLIST)pvPidl2) ? 0 : 1);
}


/****************************************************\
    PARAMETERS
         pShellUrlNew - Pointer to a CShellUrl that will
                        be added to the "Shell Path"

    DESCRIPTION:
         This Shell Url will have the ShellUrl that's
    passed in added to the "Shell Path", which will be
    searched when trying to qualify the Shell Url during
    parsing.

    MEMORY ALLOCATION:
         The caller needs to Allocate pShellUrlNew and
    this object will take care of freeing it.  WARNING:
    this means it cannot be on the stack.
\****************************************************/
HRESULT CShellUrl::AddPath(LPCITEMIDLIST pidl)
{
    ASSERT(IS_VALID_PIDL(pidl));

    //  we dont want to add any paths that arent derived from
    //  our root.
    if (ILIsRooted(m_pidlWorkingDir) && !ILIsParent(m_pidlWorkingDir, pidl, FALSE))
        return S_FALSE;

    if (!m_hdpaPath)
    {
        m_hdpaPath = DPA_Create(CE_PATHGROW);
        if (!m_hdpaPath)
            return E_OUTOFMEMORY;
    }

    // Does the path already exist in our list?
    if (-1 == DPA_Search(m_hdpaPath, (void *)pidl, 0, DPAPidlCompare, NULL, 0))
    {
        // No, so let's add it.
        LPITEMIDLIST pidlNew = ILClone(pidl);
        if (pidlNew)
            DPA_AppendPtr(m_hdpaPath, pidlNew);
    }

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: AddPath() pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    return S_OK;
}


/****************************************************\
    FUNCTION: Reset

    PARAMETERS:
        none.

    DESCRIPTION:
        This function will "Clean" out the object and
    reset it.  Normally called when the caller is about
    to set new values.
\****************************************************/
HRESULT CShellUrl::Reset(void)
{
    Pidl_Set(&m_pidl, NULL);
    Str_SetPtr(&m_pszURL, NULL);
    Str_SetPtr(&m_pszArgs, NULL);
    Str_SetPtr(&m_pszDisplayName, NULL);
    m_dwGenType = 0;

    return S_OK;
}


/****************************************************\
    FUNCTION: _CanUseAdvParsing

    PARAMETERS:
        none.

    DESCRIPTION:
        This function will return TRUE if Advanced
    Parsing (Shell URLs) should be supported.  This
    function will keep track of whether the user
    has turn off Shell Parsing from the Control Panel.
\****************************************************/
#define REGSTR_USEADVPARSING_PATH  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Band\\Address")
#define REGSTR_USEADVPARSING_VALUE TEXT("UseShellParsing")

BOOL CShellUrl::_CanUseAdvParsing(void)
{
    // WARNING: Since this is static, changes to the registry entry won't be
    //          read in until the time the process is launched.  This is okay,
    //          because this feature will probably be removed from the released
    //          product and can be added back in as power toy.
    static TRI_STATE fCanUseAdvParsing = TRI_UNKNOWN;

    if (TRI_UNKNOWN == fCanUseAdvParsing)
        fCanUseAdvParsing = (TRI_STATE) SHRegGetBoolUSValue(REGSTR_USEADVPARSING_PATH, REGSTR_USEADVPARSING_VALUE, FALSE, TRUE);

    return fCanUseAdvParsing;
}


/****************************************************\
    FUNCTION: _FixDriveDisplayName

    PARAMETERS:
        pszStart - Pointer to the beginning of the URL string.
        pszCurrent - Pointer into current location in the URL string.
        pidl - PIDL pointing to location of Shell Name space that
               has been parsed so far.

    DESCRIPTION:
        This function exists to check if we are parsing
    a drive letter.  This is necessary because the Display
    Name of drive letters end in '\', which will is needed
    later to determine the start of the next segment.
\****************************************************/
#ifndef UNIX
#define DRIVE_STRENDING     TEXT(":\\")
#define DRIVE_STRSIZE       3 // "C:\"
#else
#define DRIVE_STRSIZE       1 // "/"
#endif

BOOL _FixDriveDisplayName(LPCTSTR pszStart, LPCTSTR pszCurrent, LPCITEMIDLIST pidl)
{
    BOOL fResult = FALSE;

    ASSERT(pszCurrent >= pszStart);

#ifndef UNIX
    // The compiler will take care of adding '/ sizeof(TCHAR)'.
    if (((pszCurrent - pszStart) == DRIVE_STRSIZE) &&
        (0 == StrCmpN(&(pszStart[1]), DRIVE_STRENDING, SIZECHARS(DRIVE_STRENDING)-1)))
#else
    if ((((pszCurrent - pszStart)/sizeof(TCHAR)) == DRIVE_STRSIZE))
#endif
    {
        if (IsSpecialFolderChild(pidl, CSIDL_DRIVES, TRUE))
            fResult = TRUE;
    }

    return fResult;
}



/****************************************************\
    FUNCTION: _ParseRelativePidl

    PARAMETERS:
        pcszUrlIn - Pointer to URL to Parse.
        dwFlags - Flags to modify the way the string is parsed.
        pidl - This function will see if pcszUrlIn is a list of display names
               relative to this pidl.
        fAllowRelative - Do we allow relative parsing, which
                         means strings containing "..".
        fQualifyDispName - If TRUE when we known that we need to force the
                           URL to be fully qualified if we bind to the destination.
                           This is needed because we are using state information to
                           find the destination URL and that state information won't
                           be available later.

    DESCRIPTION:
        Start the parsing by getting the pidl of ShellUrlRelative
    and call _ParseNextSegment().  _ParseNextSegment() will
    recursively parse each segment of the PIDL until either
    it fails to fully parse of it finishes.
\****************************************************/
HRESULT CShellUrl::_ParseRelativePidl(LPCTSTR pcszUrlIn,
    BOOL * pfPossibleWebUrl, DWORD dwFlags, LPCITEMIDLIST pidl,
    BOOL fAllowRelative, BOOL fQualifyDispName)
{
    HRESULT hr;
    BOOL fFreePidl = FALSE;

    if (!pcszUrlIn)
        return E_INVALIDARG;

    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _ParseRelativePidl() Begin. pcszUrlIn=%s", pcszUrlIn);

    hr = _ParseNextSegment(pidl, pcszUrlIn, pfPossibleWebUrl, fAllowRelative, fQualifyDispName);

    if (pidl && fFreePidl)
        ILFree((LPITEMIDLIST)pidl);

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _ParseRelativePidl() m_pidl=>%s<", Dbg_PidlStr(m_pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    return hr;
}



/****************************************************\
    FUNCTION: IsShellUrl

    PARAMETERS:
        LPCTSTR szUrl - URL from Outside Source.
        return - Whether the URL is an Internet URL.

    DESCRIPTION:
        This function will determine if the URL is
    a shell URL which includes the following:
    1. File Urls (E;\dir1\dir2)
    2. Shell Urls (shell:desktop)
\****************************************************/
BOOL IsShellUrl(LPCTSTR pcszUrl, BOOL fIncludeFileUrls)
{
    int nSchemeBefore, nSchemeAfter;
    TCHAR szParsedUrl[MAX_URL_STRING];

    nSchemeBefore = GetUrlScheme(pcszUrl);
    IURLQualifyT(pcszUrl, UQF_GUESS_PROTOCOL, szParsedUrl, NULL, NULL);
    nSchemeAfter = GetUrlScheme(szParsedUrl);

    // This is a "shell url" if it is a file: (and fIncludeFileUrls is
    // set), or it is a shell:, or it is an invalid scheme (which
    // occurs for things like "My Computer" and "Control Panel").

    return ((fIncludeFileUrls && URL_SCHEME_FILE == nSchemeAfter) ||
            URL_SCHEME_SHELL == nSchemeAfter ||
            URL_SCHEME_INVALID == nSchemeBefore);
}


/****************************************************\
    FUNCTION: IsSpecialFolderChild

    PARAMETERS:
        pidlToTest (In) - Is this PIDL to test and see if it's
                     a child of SpecialFolder(nFolder).
        psfParent (In Optional)- The psf passed to
                     SHGetSpecialFolderLocation() if needed.
        nFolder (In) - Special Folder Number (CSIDL_INTERNET, CSIDL_DRIVES, ...).
        pdwLevels (In Optional) - Pointer to DWORD to receive levels between
                    pidlToTest and it's parent (nFolder) if S_OK is returned.

    DESCRIPTION:
        This function will see if pidlToTest is a child
    of the Special Folder nFolder.
\****************************************************/
BOOL IsSpecialFolderChild(LPCITEMIDLIST pidlToTest, int nFolder, BOOL fImmediate)
{
    LPITEMIDLIST pidlThePidl = NULL;
    BOOL fResult = FALSE;

    if (!pidlToTest)
        return FALSE;

    ASSERT(IS_VALID_PIDL(pidlToTest));
    if (NOERROR == SHGetSpecialFolderLocation(NULL, nFolder, &pidlThePidl))
    {
        fResult = ILIsParent(pidlThePidl, pidlToTest, fImmediate);
        ILFree(pidlThePidl);
    }
    return fResult;        // Shell Items (My Computer, Control Panel)
}


/****************************************************\
    FUNCTION: GetPidl

    PARAMETERS
         ppidl - Pointer that will receive the current PIDL.

    DESCRIPTION:
         This function will retrieve the pidl that the
    Shell Url is set to.

    MEMORY ALLOCATION:
         This function will allocate the PIDL that ppidl
    points to, and the caller needs to free the PIDL when
    done with it.
\****************************************************/
HRESULT CShellUrl::GetPidl(LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;

    if (ppidl)
        *ppidl = NULL;
    if (!m_pidl)
        hr = _GeneratePidl(m_pszURL, m_dwGenType);

    if (ppidl)
    {
        if (m_pidl)
        {
            *ppidl = ILClone(m_pidl);
            if (!*ppidl)
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;
    }

    // Callers only free *ppidl if SUCCEDED(hr), so assert we act this way.
    ASSERT((*ppidl && SUCCEEDED(hr)) || (!*ppidl && FAILED(hr)));

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: GetPidl() *ppidl=>%s<", Dbg_PidlStr(*ppidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    return hr;
}

//
// This is a wacky class!  If GetPidl member of this class is called and
// a m_pidl is generated from and url and then Execute() assumes we have
// a valid location in our namespace and  calls code that will not autoscan.
// This hacky function is used to return a pidl only if we have one to
// avoid the above problem.
//
HRESULT CShellUrl::GetPidlNoGenerate(LPITEMIDLIST * ppidl)
{
    HRESULT hr = E_FAIL;
    if (m_pidl && ppidl)
    {
        *ppidl = ILClone(m_pidl);
        if (*ppidl)
        {
            hr = S_OK;
        }
    }

    return hr;
}

/****************************************************\
    FUNCTION: _GeneratePidl

    PARAMETERS
         pcszUrl - This URL will be used to generate the m_pidl.
         dwGenType - This is needed to know how to parse pcszUrl
                     to generate the PIDL.

    DESCRIPTION:
        This CShellUrl maintains a pointer to the object
    in the Shell Name Space by using either the string URL
    or the PIDL.  When this CShellUrl is set to one, we
    delay generating the other one for PERF reasons.
    This function generates the PIDL from the string URL
    when we do need the string.
\****************************************************/

HRESULT CShellUrl::_GeneratePidl(LPCTSTR pcszUrl, DWORD dwGenType)
{
    HRESULT hr;

    if (!pcszUrl && m_pidl)
        return S_OK;      // The caller only wants the PIDL to be created if it doesn't exist.

    if (pcszUrl && m_pidl)
    {
        ILFree(m_pidl);
        m_pidl = NULL;
    }

    switch (dwGenType)
    {
        case GENTYPE_FROMURL:
            if (ILIsRooted(m_pidlWorkingDir))
                hr = E_FAIL;    // MSN Displays error dialogs on IShellFolder::ParseDisplayName()
            // fall through
        case GENTYPE_FROMPATH:
            hr = IECreateFromPath(pcszUrl, &m_pidl);
            // This may fail if it's something like "ftp:/" and not yet valid".
            break;

        default:
            hr = E_INVALIDARG;
            break;
    }

    if (!m_pidl && SUCCEEDED(hr))
        hr = E_FAIL;

    return hr;
}


/****************************************************\
    FUNCTION: SetPidl

    PARAMETERS
         pidl - New pidl to use.

    DESCRIPTION:
         The shell url will now consist of the new pidl
    passed in.

    MEMORY ALLOCATION:
         The caller is responsible for Allocating and Freeing
    the PIDL parameter.
\****************************************************/
HRESULT CShellUrl::SetPidl(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    ASSERT(!pidl || IS_VALID_PIDL(pidl));

    Reset();        // External Calls to this will reset the entire CShellUrl.
    return _SetPidl(pidl);
}


/****************************************************\
    FUNCTION: _SetPidl

    PARAMETERS
         pidl - New pidl to use.

    DESCRIPTION:
         This function will reset the m_pidl member
    variable without modifying m_szURL.  This is only used
    internally, and callers that want to reset the entire
    CShellUrl to a PIDL should call the public method
    SetPidl().

    MEMORY ALLOCATION:
         The caller is responsible for Allocating and Freeing
    the PIDL parameter.
\****************************************************/
HRESULT CShellUrl::_SetPidl(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: _SetPidl() pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

    Pidl_Set(&m_pidl, pidl);
    if (!m_pidl)
        hr = E_FAIL;

    return hr;
}


/****************************************************\
    FUNCTION: GetUrl

    PARAMETERS
         pszUrlOut (Out Optional) - If the caller wants the string.
         cchUrlOutSize (In) - Size of String Buffer Passed in.

    DESCRIPTION:
         This function will retrieve the string value of
    the shell url.  This will not include the command line
    arguments or other information needed for correct navigation
    (AutoSearch=On/Off, ...).  Note that this may be of the
    form "Shell:/desktop/My Computer/...".
\****************************************************/
HRESULT CShellUrl::GetUrl(LPTSTR pszUrlOut, DWORD cchUrlOutSize)
{
    HRESULT hr = S_OK;

    if (!m_pszURL)
    {
        if (m_pidl)
            hr = _GenerateUrl(m_pidl);
        else
            hr = E_FAIL;  // User never set the CShellUrl.
    }

    if (SUCCEEDED(hr) && pszUrlOut)
        StrCpyN(pszUrlOut, m_pszURL, cchUrlOutSize);

    return hr;
}

/****************************************************\
!!! WARNING - extremely specific to the ShellUrl/AddressBar - ZekeL - 18-NOV-98
!!!           it depends on the bizarre pathology of the ShellUrl in order
!!!           to be reparsed into a pidl later.  cannot be used for anything else

    PARAMETERS:
        pidlIn - Pointer to PIDL to generate Display Names.
        pszUrlOut - String Buffer to store list of Display Names for ITEMIDs
                    in pidlIn.
        cchUrlOutSize - Size of Buffer in characters.

    DESCRIPTION:
        This function will take the PIDL passed in and
    generate a string containing the ILGDN_ITEMONLY Display names
    of each ITEMID in the pidl separated by '\'.
\****************************************************/
#define SZ_SEPARATOR TEXT("/")

HRESULT MutantGDNForShellUrl(LPCITEMIDLIST pidlIn, LPTSTR pszUrlOut, int cchUrlOutSize)
{
    HRESULT hr = S_OK;
    LPCITEMIDLIST pidlCur;
    IShellFolder *psfCur = NULL;

    if (ILIsRooted(pidlIn))
    {
        //  need to start off with our virtual root
        LPITEMIDLIST pidlFirst = ILCloneFirst(pidlIn);
        if (pidlFirst)
        {
            IEBindToObject(pidlFirst, &psfCur);
            ILFree(pidlFirst);
        }

        pidlCur = _ILNext(pidlIn);
    }
    else
    {
        SHGetDesktopFolder(&psfCur);
        pidlCur = pidlIn;
    }

    ASSERT(pidlCur && IS_VALID_PIDL(pidlCur));
    while (psfCur && SUCCEEDED(hr) && !ILIsEmpty(pidlCur) && (cchUrlOutSize > 0))
    {
        LPITEMIDLIST pidlCopy = ILCloneFirst(pidlCur);
        if (pidlCopy)
        {
            StrCpyN(pszUrlOut, SZ_SEPARATOR, cchUrlOutSize);
            cchUrlOutSize -= SIZECHARS(SZ_SEPARATOR);

            TCHAR szCurrDispName[MAX_PATH];
            hr = DisplayNameOf(psfCur, pidlCopy, SHGDN_NORMAL, szCurrDispName, SIZECHARS(szCurrDispName));

            if (SUCCEEDED(hr))
            {
                if (TBOOL((int)cchUrlOutSize > lstrlen(szCurrDispName)))
                {
                    StrCatBuff(pszUrlOut, szCurrDispName, cchUrlOutSize);
                    cchUrlOutSize -= lstrlen(szCurrDispName);
                }

                // may fail, in that case we terminate the loop
                IShellFolder *psfCurNew = NULL; // for buggy BindToObject impls
                hr = psfCur->BindToObject(pidlCopy, NULL, IID_IShellFolder, (void **)&psfCurNew);

                psfCur->Release();
                psfCur = psfCurNew;
            }
            pidlCur = _ILNext(pidlCur);
            ILFree(pidlCopy);
        }
        else
            hr = E_FAIL;
    }
    if (psfCur)
        psfCur->Release();

    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: MutantGDNForShellUrl() End. pszUrlOut=%s", pszUrlOut);
    return hr;
}


/****************************************************\
    FUNCTION: _GenerateUrl

    PARAMETERS
         pidl - This PIDL will be used to generate the m_pszURL, string URL.

    DESCRIPTION:
        This CShellUrl maintains a pointer to the object
    in the Shell Name Space by using either the string URL
    or the PIDL.  When this CShellUrl is set to one, we
    delay generating the other one for PERF reasons.
    This function generates the string URL from the PIDL
    when we do need the string.
\****************************************************/
#define SZ_THEINTERNET_PARSENAME         TEXT("::{")

HRESULT CShellUrl::_GenerateUrl(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    TCHAR szUrl[MAX_URL_STRING];

    ASSERT(IS_VALID_PIDL(pidl));
    if (IsURLChild(pidl, TRUE) || _IsFilePidl(pidl))
    {
        hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szUrl, SIZECHARS(szUrl), NULL);
        if (SUCCEEDED(hr))
        {
            // Was the pidl pointing to "The Internet"?
            if (0 == StrCmpN(szUrl, SZ_THEINTERNET_PARSENAME, (ARRAYSIZE(SZ_THEINTERNET_PARSENAME) - 1)))
            {
                // Yes, so we don't want the SHGDN_FORPARSING name
                // because the user doesn't know what the heck it is.  Since we
                // navigate to the home page, let's display that.
                hr = IEGetNameAndFlags(pidl, SHGDN_NORMAL, szUrl, SIZECHARS(szUrl), NULL);
            }
        }
    }
    else
    {
//        hr = MutantGDNForShellUrl(pidl, szUrl, SIZECHARS(szUrl));
        hr = IEGetNameAndFlags(pidl, SHGDN_NORMAL, szUrl, SIZECHARS(szUrl), NULL);
    }

    if (SUCCEEDED(hr))
        Str_SetPtr(&m_pszURL, szUrl);

    if (!m_pszURL)
        hr = E_OUTOFMEMORY;

    if (FAILED(hr))
        Str_SetPtr(&m_pszURL, NULL);        // Clear it

    return hr;
}


/****************************************************\
    FUNCTION: SetUrl

    PARAMETERS
         szUrlOut (Out) - Url

    DESCRIPTION:
         Set the ShellUrl from a string that is parsible from
    the root (desktop) ISF.  This is normally used for
    File Paths.
\****************************************************/
HRESULT CShellUrl::SetUrl(LPCTSTR pcszUrlIn, DWORD dwGenType)
{
    Reset();        // External Calls to this will reset the entire CShellUrl.
    return _SetUrl(pcszUrlIn, dwGenType);
}


/****************************************************\
    FUNCTION: _SetUrl

    PARAMETERS
         pcszUrlIn (In) - The string URL for this CShellUrl
         dwGenType (In) - Method to use when generating the PIDL
                          from pcszUrlIn.

    DESCRIPTION:
         This function will reset the m_pszURL member
    variable without modifying m_pidl.  This is only used
    internally, and callers that want to reset the entire
    CShellUrl to an URL should call the public method
    SetUrl().
\****************************************************/
HRESULT CShellUrl::_SetUrl(LPCTSTR pcszUrlIn, DWORD dwGenType)
{
    m_dwGenType = dwGenType;

    return Str_SetPtr(&m_pszURL, pcszUrlIn) ? S_OK : E_OUTOFMEMORY;
}


/****************************************************\
    FUNCTION: GetDisplayName

    PARAMETERS
         pszUrlOut (Out) - Get the Shell Url in String Form.
         cchUrlOutSize (In) - Size of String Buffer Passed in.

    DESCRIPTION:
         This function will Fill in pszUrlOut with nice
    versions of the Shell Url that can be displayed in
    the AddressBar or in the Titles of windows.
\****************************************************/
HRESULT CShellUrl::GetDisplayName(LPTSTR pszUrlOut, DWORD cchUrlOutSize)
{
    HRESULT hr = S_OK;

    if (!m_pszDisplayName)
    {
        if (m_pidl)
        {
            LPITEMIDLIST pidl = NULL;

            hr = GetPidl(&pidl);
            if (SUCCEEDED(hr))
            {
                hr = _GenDispNameFromPidl(pidl, NULL);
                ILFree(pidl);
            }
        }
        else if (m_pszURL)
        {
            // In this case, we will just give back the URL.
            Str_SetPtr(&m_pszDisplayName, m_pszURL);

            if (NULL == m_pszDisplayName)
                hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr) && pszUrlOut && m_pszDisplayName)
        StrCpyN(pszUrlOut, m_pszDisplayName, cchUrlOutSize);

    return hr;
}


/****************************************************\
    FUNCTION: _GenDispNameFromPidl

    PARAMETERS
         pidl (In) - This will be used to generate the Display Name.
         pcszArgs (In) - These will be added to the end of the Display Name

    DESCRIPTION:
        This function will generate the Display Name
    from the pidl and pcszArgs parameters.  This is
    normally not needed when this CShellUrl was parsed
    from an outside source, because the Display Name
    was generated at that time.
\****************************************************/
HRESULT CShellUrl::_GenDispNameFromPidl(LPCITEMIDLIST pidl, LPCTSTR pcszArgs)
{
    HRESULT hr;
    TCHAR szDispName[MAX_URL_STRING];

    hr = GetUrl(szDispName, SIZECHARS(szDispName));
    if (SUCCEEDED(hr))
    {
        if (pcszArgs)
            StrCatBuff(szDispName, pcszArgs, ARRAYSIZE(szDispName));
        PathMakePretty(szDispName);

        hr = Str_SetPtr(&m_pszDisplayName, szDispName) ? S_OK : E_OUTOFMEMORY;
    }

    return hr;
}


/****************************************************\
    FUNCTION: GetArgs

    PARAMETERS
         pszArgsOut - The arguments to the Shell Url. (Only
                     for ShellExec().
         cchArgsOutSize - Size of pszArgsOut in chars.

    DESCRIPTION:
         Get the arguments that will be passed to
    ShellExec() if 1) the Pidl is navigated to, 2) it's
    a File URL, and 3) it's not navigatable.
\****************************************************/
HRESULT CShellUrl::GetArgs(LPTSTR pszArgsOut, DWORD cchArgsOutSize)
{
    ASSERT(pszArgsOut);

    if (m_pszArgs)
        StrCpyN(pszArgsOut, m_pszArgs, cchArgsOutSize);
    else
        *pszArgsOut = 0;

    TraceMsg(TF_BAND|TF_GENERAL, "ShellUrl: GetArgs() pszArgsOut=%s", pszArgsOut);
    return S_OK;
}


/****************************************************\
    FUNCTION: SetDefaultShellPath

    PARAMETERS
         psu - CShellUrl to set path.

    DESCRIPTION:
         "Desktop";"Desktop/My Computer" is the
    most frequently used Shell Path for parsing.  This
    function will add those two items to the CShellUrl
    passed in the paramter.
\****************************************************/
HRESULT SetDefaultShellPath(CShellUrl * psu)
{
    ASSERT(psu);
    LPITEMIDLIST pidl;

    // We need to set the "Shell Path" which will allow
    // the user to enter Display Names of items in Shell
    // Folders that are frequently used.  We add "Desktop"
    // and "Desktop/My Computer" to the Shell Path because
    // that is what users use most often.

    // _pshuUrl will free pshuPath, so we can't.
    psu->AddPath(&s_idlNULL);

    SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidl);  // Get Pidl for "My Computer"
    if (pidl)
    {
        // psu will free pshuPath, so we can't.
        psu->AddPath(pidl);
        ILFree(pidl);
    }

    // Add favorites folder too
    SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidl);
    if (pidl)
    {
        // psu will free pshuPath, so we can't.
        psu->AddPath(pidl);
        ILFree(pidl);
    }

    return S_OK;
}

void CShellUrl::SetMessageBoxParent(HWND hwnd)
{
    // Find the topmost window so that the messagebox disables
    // the entire frame
    HWND hwndTopmost = NULL;
    while (hwnd)
    {
        hwndTopmost = hwnd;
        hwnd = GetParent(hwnd);
    }

    m_hwnd = hwndTopmost;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\shellurl.h ===
/**************************************************************\
    FILE: shellurl.h

    DESCRIPTION:
    Handle dealing with Shell Urls.  Include: Generating from PIDL, 
    Generating from preparsed Url String, and parsing from a user
    entered Url String.
\**************************************************************/

#ifndef _SHELLURL_H
#define _SHELLURL_H

#define STR_REGKEY_APPPATH   TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths")


// Parameters for ::SetUrl()'s dwGenType parameter
#define GENTYPE_FROMPATH    0x00000001
#define GENTYPE_FROMURL     0x00000002

class CShellUrl;

BOOL IsShellUrl(LPCTSTR pcszUrl, BOOL fIncludeFileUrls);
BOOL IsSpecialFolderChild(LPCITEMIDLIST pidlToTest, int nFolder, BOOL fImmediate);
HRESULT SetDefaultShellPath(CShellUrl * psu);


/**************************************************************\
    CLASS: CShellUrl

    DESCRIPTION:
        This object was created to keep track of a FULL SHELL URL.
    This includes any object in the shell name space and how
    to interact with that object.  Objects can be specified as
    PIDLs and then will be handled appropriately when executed,
    which means it will Navigate to the object if the object
    supports navigation or "browse in place" (registered DocHost, 
    Shell Folder, Internet URL)
    otherwise the Shell Url will be executed (files, shell items).

         If a string is inputed by the user, the ::ParseFromOutsideSource()
    method should be called.  This will take all of the environment
    information into consideration (CurrWorkDir & Path) and parse
    the URL.  If the string needs to be shell executed, it will
    generate the command line arguments and current working directory
    string.  If the object is to be navigated to, it will determine
    the navigation flags (for AutoSearch and similar things).

    PERF:
        This object was build so that if you specify a PIDL or String,
    it should be able to hold that information without a perf hit.
    If you want to take advantage of ::ParseFromOutsideSource() or
    ::Execute(), it will require a little more CPU time to do the
    full functionality.

    GOAL:
        The goal of the parsing is to make it into a normal internet
    URL unless the algorithm can with certainty assume that the string
    entered is specifying a Shell Name Space item or action.  This means
    that CShellUrl will only assume the entered text is a Shell Item to be
    Navigated to if it can successfully bind to the destination pidl.
    It will assume it's an item to be executed and use the end of the
    string as Command Line Arguments if: 1) It can bind to the end PIDL,
    and 2) The end pidl is not "Browsable" or "Navigatible", and 3)
    the char after the string specifying the PIDL is a Space.
\**************************************************************/
class CShellUrl : public IAddressBarParser
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IAddressBarParser
    STDMETHODIMP ParseFromOutsideSource(LPCTSTR pcszUrlIn, DWORD dwParseFlags, PBOOL pfWasCorrected = NULL);
    STDMETHODIMP GetUrl(LPTSTR pszUrlOut, DWORD cchUrlOutSize);
    STDMETHODIMP SetUrl(LPCTSTR pcszUrlIn, DWORD dwGenType);       // Reset CShellUrl to this URL
    STDMETHODIMP GetDisplayName(LPTSTR pszUrlOut, DWORD cchUrlOutSize);
    STDMETHODIMP GetPidl(LPITEMIDLIST * ppidl);
    STDMETHODIMP SetPidl(LPCITEMIDLIST pidl);       // Reset CShellUrl to this PIDL
    STDMETHODIMP GetArgs(LPTSTR pszArgsOut, DWORD cchArgsOutSize);
    STDMETHODIMP AddPath(LPCITEMIDLIST pidl);

    // Constructor / Destructor
    CShellUrl();
    ~CShellUrl(void);  

    HRESULT Clone(CShellUrl * pShellUrl);

    HRESULT Execute(IBandProxy * pbp, BOOL * pfDidShellExec, DWORD dwExecFlags);

    BOOL IsWebUrl(void);

    HRESULT SetCurrentWorkingDir(LPCITEMIDLIST pidlCWD);
    HRESULT Reset(void);
    void SetMessageBoxParent(HWND hwnd);

#ifdef UNICODE
    HRESULT ParseFromOutsideSource(LPCSTR pcszUrlIn, DWORD dwParseFlags, PBOOL pfWasCorrected);
#endif // UNICODE

    HRESULT GetPidlNoGenerate(LPITEMIDLIST * ppidl);

private:
    // Parsing Methods
    HRESULT _ParseRelativePidl(LPCTSTR pcszUrlIn, BOOL * pfPossibleWebUrl, DWORD dwFlags, LPCITEMIDLIST pidl, BOOL fAllowRelative, BOOL fQualifyDispName);
    HRESULT _ParseUNC(LPCTSTR pcszUrlIn, BOOL * pfPossibleWebUrl, DWORD dwFlags, BOOL fQualifyDispName);
    HRESULT _ParseSeparator(LPCITEMIDLIST pidlParent, LPCTSTR pcszSeg, BOOL * pfPossibleWebUrl, BOOL fAllowRelative, BOOL fQualifyDispName);
    HRESULT _ParseNextSegment(LPCITEMIDLIST pidlParent, LPCTSTR pcszStrToParse, BOOL * pfPossibleWebUrl, BOOL fAllowRelative, BOOL fQualifyDispName);
    HRESULT _CheckItem(IShellFolder * psfFolder, LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlRelative, 
                       LPITEMIDLIST * ppidlChild, LPCTSTR pcszStrToParse, LPTSTR * ppszRemaining, DWORD dwFlags);
    HRESULT _GetNextPossibleSegment(LPCTSTR pcszFullPath, LPTSTR * ppszSegIterator, LPTSTR pszSegOut, DWORD cchSegOutSize, BOOL fSkipShare);
    HRESULT _GetNextPossibleFullPath(LPCTSTR pcszFullPath, LPTSTR * ppszSegIterator, LPTSTR pszSegOut, DWORD cchSegOutSize, BOOL * pfContinue);
    HRESULT _QualifyFromPath(LPCTSTR pcszFilePathIn, DWORD dwFlags);
    HRESULT _QualifyFromDOSPath(LPCTSTR pcszFilePathIn, DWORD dwFlags);
    HRESULT _QualifyFromAppPath(LPCTSTR pcszFilePathIn, DWORD dwFlags);
    HRESULT _QuickParse(LPCITEMIDLIST pidlParent, LPTSTR pszParseChunk, LPTSTR pszNext, BOOL * pfPossibleWebUrl, BOOL fAllowRelative, BOOL fQualifyDispName);
    BOOL _CanUseAdvParsing(void);
    BOOL _ParseURLFromOutsideSource(LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL, LPBOOL pbWasCorrected);
    HRESULT _TryQuickParse(LPCTSTR pszUrl, DWORD dwParseFlags);

    // Accessor Methods
    HRESULT _SetPidl(LPCITEMIDLIST pidl);       // Set PIDL w/o modifying URL
    HRESULT _GeneratePidl(LPCTSTR pcszUrl, DWORD dwGenType);
    HRESULT _SetUrl(LPCTSTR pcszUrlIn, DWORD dwGenType);       // Set URL w/o modifying PIDL
    HRESULT _GenerateUrl(LPCITEMIDLIST pidl);
    HRESULT _GenDispNameFromPidl(LPCITEMIDLIST pidl, LPCTSTR pcszArgs);

    // Other Methods
    HRESULT _PidlShellExec(LPCITEMIDLIST pidl, ULONG ulShellExecFMask);
    HRESULT _UrlShellExec(void);
    BOOL _IsFilePidl(LPCITEMIDLIST pidl);

    HWND _GetWindow(void) { return (IsFlagSet(m_dwFlags, SHURL_FLAGS_NOUI) ? NULL : GetDesktopWindow()); }


    //////////////////////////////////////////////////////
    //  Private Member Variables 
    //////////////////////////////////////////////////////

    LPTSTR          m_pszURL;
    LPTSTR          m_pszDisplayName;       // The nice display name of the entity.
    LPTSTR          m_pszArgs;
    LPTSTR          m_pstrRoot;
    LPITEMIDLIST    m_pidl;
    DWORD           m_dwGenType;
    DWORD           m_dwFlags;

    LPITEMIDLIST    m_pidlWorkingDir;
    HDPA            m_hdpaPath;             // DPA of PIDLs
    HWND            m_hwnd;                 // parent window for message boxes
    LONG            _cRef;
};


#endif /* _SHELLURL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\snslist.cpp ===
/**************************************************************\
    FILE: snslist.cpp

    DESCRIPTION:
        SNSList implements the Shell Name Space List or DriveList.
    This will store a pidl and be able to populate the AddressBand
    combobox with the shell name space that includes that PIDL.
\**************************************************************/

#include "priv.h"

#ifndef UNIX

#include "addrlist.h"
#include "itbar.h"
#include "itbdrop.h"
#include "util.h"
#include "autocomp.h"
#include <urlhist.h>
#include <winbase.h>
#include <wininet.h>



///////////////////////////////////////////////////////////////////
// Data Structures
typedef struct {
    LPITEMIDLIST pidl;          // the pidl
    TCHAR szName[MAX_URL_STRING];     // pidl's display name
    int iImage;                 // pidl's icon
    int iSelectedImage;         // pidl's selected icon
} PIDLCACHE, *PPIDLCACHE;


/**************************************************************\
    CLASS: CSNSList

    DESCRIPTION:
        This object supports IAddressList and can populate
    the Address Band/Bar with the Shell Name Space (DriveList)
    heirarchy.
\**************************************************************/
class CSNSList  : public CAddressList
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IAddressList methods ***
    virtual STDMETHODIMP Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac);
    virtual STDMETHODIMP NavigationComplete(LPVOID pvCShellUrl);
    virtual STDMETHODIMP Refresh(DWORD dwType);
    virtual STDMETHODIMP SetToListIndex(int nIndex, LPVOID pvShelLUrl);
    virtual STDMETHODIMP FileSysChangeAL(DWORD dw, LPCITEMIDLIST* ppidl);

protected:
    //////////////////////////////////////////////////////
    // Private Member Functions
    //////////////////////////////////////////////////////

    // Constructor / Destructor
    CSNSList();
    ~CSNSList(void);        // This is now an OLE Object and cannot be used as a normal Class.


    // Address Band Specific Functions
    LRESULT _OnNotify(LPNMHDR pnm);
    LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);

    // Address List Modification Functions
    void _AddItem(LPITEMIDLIST pidl, int iInsert, int iIndent);
    LPITEMIDLIST _GetFullIDList(int iItem);
    int _GetIndent(int iItem);
    void _FillOneLevel(int iItem, int iIndent, int iDepth);
    void _ExpandMyComputer(int iDepth);
    LPITEMIDLIST _GetSelectedPidl(void);
    int _FindItem(LPITEMIDLIST pidl);
    BOOL _SetCachedPidl(LPCITEMIDLIST pidl);
    BOOL _GetPidlUI(LPCITEMIDLIST pidl, LPTSTR pszName, int cchName, int *piImage, int *piSelectedImage, DWORD dwFlags, BOOL fIgnoreCache);
    BOOL _GetPidlImage(LPCITEMIDLIST pidl, int *piImage, int *piSelectedImage);
    LRESULT _OnGetDispInfoA(PNMCOMBOBOXEXA pnmce);
    LRESULT _OnGetDispInfoW(PNMCOMBOBOXEXW pnmce);
    void _PurgeComboBox();
    void _PurgeAndResetComboBox();

    LPITEMIDLIST CSNSList::_GetDragDropPidl(LPNMCBEDRAGBEGINW pnmcbe);
    HRESULT _GetURLToolTip(LPTSTR pszUrl, DWORD dwStrSize);        
    HRESULT _GetPIDL(LPITEMIDLIST* ppidl);
    BOOL _IsSelectionValid(void);
    HRESULT _PopulateOneItem(BOOL fIgnoreCache = FALSE);
    HRESULT _Populate(void);
    void _InitCombobox(void);
    // Friend Functions
    friend IAddressList * CSNSList_Create(void);

    //////////////////////////////////////////////////////
    //  Private Member Variables 
    //////////////////////////////////////////////////////
    PIDLCACHE           _cache;             // cache of pidl UI information

    BOOL                _fFullListValid:1;  // TRUE when the full combo is correctly populated
    BOOL                _fPurgePending:1;   // TRUE if we should purge when the combo closes up
    BOOL                _fInPopulate;       // TRUE when we're currently doing a _PopulateOneItem
};



//================================================================= 
// Implementation of CSNSList
//=================================================================


/****************************************************\
    FUNCTION: CSNSList_Create
  
    DESCRIPTION:
        This function will create an instance of the
    CSNSList COM object.
\****************************************************/
IAddressList * CSNSList_Create(void)
{
    CSNSList * p = new CSNSList();
    return p;
}


/****************************************************\
  
    Address Band Constructor
  
\****************************************************/
CSNSList::CSNSList()
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!_cache.pidl);
}


/****************************************************\
  
    Address Band destructor
  
\****************************************************/
CSNSList::~CSNSList()
{
    if (_cache.pidl)
        ILFree(_cache.pidl);

    _PurgeComboBox();

    TraceMsg(TF_SHDLIFE, "dtor CSNSList %x", this);
}


//================================
// *** IAddressList Interface ***


void CSNSList::_PurgeComboBox()
{
    if (_hwnd)
    {
        // Deleting items from the combobox trashes the edit button if something was
        // previously selected from the combobox.  So we want to restore the editbox
        // when we are done
        WCHAR szBuf[MAX_URL_STRING];
        *szBuf = NULL;
        GetWindowText(_hwnd, szBuf, ARRAYSIZE(szBuf));
        SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);

        // Delete the PIDL of every item and then free the item
        INT iMax = (int)SendMessage(_hwnd, CB_GETCOUNT, 0, 0);
        
        while(iMax > 0)
        {
            // Each call to DeleteItem results in a callback
            // which frees the corresponding PIDL
            // if you simply use CB_RESETCONTENT - you don't get the callback
            iMax = (int)SendMessage(_hwnd, CBEM_DELETEITEM, (WPARAM)0, (LPARAM)0);
        }

        // Restore the contents of the editbox
        SetWindowText(_hwnd, szBuf);
        SendMessage(_hwnd, WM_SETREDRAW, TRUE, 0);
        InvalidateRect(_hwnd, NULL, FALSE);
    }
    _fFullListValid = FALSE;
}

void CSNSList::_PurgeAndResetComboBox()
{
    _PurgeComboBox();
    if (_hwnd)
    {
        SendMessage(_hwnd, CB_RESETCONTENT, 0, 0L);
    }
}

/****************************************************\
    DESCRIPTION:
        We are either becoming the selected list for
    the AddressBand's combobox, or lossing this status.
    We need to populate or unpopulate the combobox
    as appropriate.
\****************************************************/
HRESULT CSNSList::Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac)
{
    _PurgeComboBox();

    HRESULT hr = CAddressList::Connect(fConnect, hwnd, pbs, pbp, pac);
    
    if (fConnect)
    {
        _PopulateOneItem();
    }
    else
    {
        // Get the pidl of the currently displayed item and destroy it
        COMBOBOXEXITEM cbexItem = {0};
        cbexItem.iItem = -1;
        cbexItem.mask = CBEIF_LPARAM;
        SendMessage(_hwnd, CBEM_GETITEM, 0, (LPARAM)&cbexItem);
        LPITEMIDLIST pidlPrev = (LPITEMIDLIST)cbexItem.lParam;
        if (pidlPrev)
        {
            ILFree(pidlPrev);
            cbexItem.lParam = NULL;
            SendMessage(_hwnd, CBEM_SETITEM, 0, (LPARAM)&cbexItem);
        }
    }

    return hr;
}



/****************************************************\
    FUNCTION: _InitCombobox
    
    DESCRIPTION:
        Prepare the combo box for this list.  This normally
    means that the indenting and icon are either turned
    on or off.
\****************************************************/
void CSNSList::_InitCombobox()
{
    HIMAGELIST himlSysSmall;
    Shell_GetImageLists(NULL, &himlSysSmall);

    SendMessage(_hwnd, CBEM_SETIMAGELIST, 0, (LPARAM)himlSysSmall);
    SendMessage(_hwnd, CBEM_SETEXSTYLE, 0, 0);
    CAddressList::_InitCombobox();    
}


/****************************************************\
  
    FUNCTION: _IsSelectionValid
  
    DESCRIPTION:
        Is the current selection valid?
\****************************************************/
BOOL CSNSList::_IsSelectionValid(void)
{
    LPITEMIDLIST pidlCur, pidlSel;
    BOOL fValid = S_OK;

    _GetPIDL(&pidlCur);
    pidlSel = _GetSelectedPidl();

    if (pidlCur == pidlSel)
    {
        fValid = TRUE;
    }
    else if ((pidlCur == NULL) || (pidlSel == NULL))
    {
        fValid = FALSE;
    }
    else
    {
        //
        // ILIsEqual faults on NULL pidls, sigh
        //
        fValid = ILIsEqual(pidlCur, pidlSel);
    }
    ILFree(pidlCur);

    return fValid;
}


/****************************************************\
    FUNCTION: NavigationComplete
  
    DESCRIPTION:
        Update the URL in the Top of the list.
\****************************************************/
HRESULT CSNSList::NavigationComplete(LPVOID pvCShellUrl)
{
    CShellUrl * psu = (CShellUrl *) pvCShellUrl;
    ASSERT(pvCShellUrl);
    LPITEMIDLIST pidl;
    HRESULT hr = psu->GetPidl(&pidl);
    if (SUCCEEDED(hr))
    {
        // Update current PIDL.
        if (_SetCachedPidl(pidl))
            hr = _PopulateOneItem();

        ILFree(pidl);
    }

    return hr;
}


/****************************************************\
    FUNCTION: Refresh
  
    DESCRIPTION:
        This call will invalidate the contents of the
    contents of the drop down as well as refresh the
    Top Most icon and URL.
\****************************************************/
HRESULT CSNSList::Refresh(DWORD dwType)
{
    if (!_hwnd)
        return S_OK;    // Don't need to do any work.

    // Full refresh (ignore the cache) because the full path
    // style bit may have changed
    return _PopulateOneItem(TRUE);
}


/****************************************************\
  
    DESCRIPTION:
        Puts the current pidl into the combobox.
    This is a sneaky perf win.  Since most of the time users
    don't drop down the combo, we only fill it in with the
    (visible) current selection.
    We need to destroy the PIDL of the currently displayed item
    first though
  
\****************************************************/
HRESULT CSNSList::_PopulateOneItem(BOOL fIgnoreCache)
{
    HRESULT hr = S_OK;

    _fFullListValid = FALSE;

    // we can get reentered here when we do our sendmessages, which lets other notifies come in
    // and we get called between "LPITEMIDLIST pidlPrev = (LPITEMIDLIST)cbexItem.lParam" and
    // "ILFree(pidlPrev)".  since we dont have a refcounted pidl this causes a double-free.
    // since its not trivial to change the refcounting, block out all reentrant callers.  this
    // is okay since multiple calls are redundant anyway.
    if (!_fInPopulate)
    {
        _fInPopulate = TRUE;
        // First easy out - if there is no current pidl,
        // do nothing.
        LPITEMIDLIST pidlCur;
        if (SUCCEEDED(_GetPIDL(&pidlCur)) && pidlCur)
        {
            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
            TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _PopulateOneItem(), and Pidl not in ComboBox. PIDL=>%s<", Dbg_PidlStr(pidlCur, szDbgBuffer, SIZECHARS(szDbgBuffer)));
            ASSERT(_hwnd);
            TCHAR szURL[MAX_URL_STRING];

            COMBOBOXEXITEM cbexItem = {0};
            // Get the pidl of the currently displayed item and destroy it
            cbexItem.iItem = -1;
            cbexItem.mask = CBEIF_LPARAM;
            SendMessage(_hwnd, CBEM_GETITEM, 0, (LPARAM)&cbexItem);
            // we only free pidlPrev if we can sucessfully set the new item in...
            LPITEMIDLIST pidlPrev = (LPITEMIDLIST)cbexItem.lParam;
        
            // Done - so go insert the new item
            cbexItem.iItem = -1;
            cbexItem.pszText = szURL;
            cbexItem.cchTextMax = ARRAYSIZE(szURL);
            cbexItem.iIndent = 0;
            cbexItem.lParam = (LPARAM)ILClone(pidlCur);
            cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_INDENT | CBEIF_LPARAM;

            _GetPidlUI(pidlCur, szURL, cbexItem.cchTextMax, &cbexItem.iImage,
                       &cbexItem.iSelectedImage, SHGDN_FORPARSING, fIgnoreCache);
            if (!*szURL)
            {
                // Navigating to a net unc in browser-only doesn't work so try again without cache and FORPARSING
                _GetPidlUI(pidlCur, szURL, cbexItem.cchTextMax, &cbexItem.iImage,
                       &cbexItem.iSelectedImage, SHGDN_NORMAL, TRUE);
            }

            TraceMsg(TF_BAND|TF_GENERAL, "CSNSList::_PopulateOneItem(), Name=>%s<", cbexItem.pszText);

            // We need to set the current selection to -1 or the icon of the current selection
            // will be displayed instead of this new one
            SendMessage(_hwnd, CB_SETCURSEL, (WPARAM)-1, 0L);
            LRESULT lRes = SendMessage(_hwnd, CBEM_SETITEM, 0, (LPARAM)&cbexItem);
            if ((CB_ERR == lRes) || (0 == lRes))
            {
                if (cbexItem.lParam)
                {
                    // Since we didn't insert the item, free the cloned pidl
                    ILFree((LPITEMIDLIST) cbexItem.lParam);
                }
            }
            else
            {
                // since we inserted the item, free the previous one
                if (pidlPrev)
                {
                    ILFree(pidlPrev);
                }
            }

            ILFree(pidlCur);
        }
        _fInPopulate = FALSE;
    }
    return hr;
}

/****************************************************\
  
    DESCRIPTION:
        fills in the entire combo.
  
    WARNING!!!!!!!!:
    *** This is expensive, don't do it unless absolutely necessary! ***
  
\****************************************************/
HRESULT CSNSList::_Populate(void)
{
    LPITEMIDLIST pidl = NULL;
    int iIndent, iDepth;
    HRESULT hr = S_OK;

    if (_fFullListValid)
        return S_OK;  // Not needed, the drop down is already up todate.

    ASSERT(_hwnd);
    _PurgeAndResetComboBox();

    //
    // Fill in the current pidl and all it's parents.
    //
    hr = _GetPIDL(&pidl);

    iDepth = 0;
    iIndent = 0;

    if (pidl)
    {
        //
        // Compute the relative depth of pidl from the root.
        //
        LPITEMIDLIST pidlChild = pidl;
        if (ILIsRooted(pidl))
            pidlChild = ILGetNext(pidl);

        ASSERT(pidlChild);

        if (pidlChild)
        {
            //
            // Compute the maximum indentation level.
            //
            while (!ILIsEmpty(pidlChild))
            {
                pidlChild = _ILNext(pidlChild);
                iIndent++;
            }

            //
            // Save the maximum level.
            //
            iDepth = iIndent;
            
            //
            // Insert all those pidls.
            //
            LPITEMIDLIST pidlTemp = ILClone(pidl);

            do
            {
                _AddItem(pidlTemp, 0, iIndent);

                ILRemoveLastID(pidlTemp);
                iIndent--;
            } while (iIndent >= 0);
            ILFree(pidlTemp);
        }
        
        // Expand the root item.
        _FillOneLevel(0, 1, iDepth);

        // If this is not a rooted explorer, we expand MyComputer as well.
        // This is where we get our name "the drives dropdown".
        if (!ILIsRooted(pidl))
            _ExpandMyComputer(iDepth);
    }

    ILFree(pidl);
    _fFullListValid = TRUE;
    return hr;
} 


//================================
// *** Internal/Private Methods ***

//=================================================================
// General Band Functions
//=================================================================


/****************************************************\
    FUNCTION: _OnNotify
  
    DESCRIPTION:
        This function will handle WM_NOTIFY messages.
\****************************************************/
LRESULT CSNSList::_OnNotify(LPNMHDR pnm)
{
    LRESULT lReturn = 0;
    // HACKHACK: combobox (comctl32\comboex.c) will pass a LPNMHDR, but it's really
    // a PNMCOMBOBOXEX (which has a first element of LPNMHDR).  This function
    // can use this type cast iff it's guaranteed that this will only come from
    // a function that behaves in this perverse way.
    PNMCOMBOBOXEX pnmce = (PNMCOMBOBOXEX)pnm;

    ASSERT(pnm);
    switch (pnm->code)
    {
        case TTN_NEEDTEXT:
        {
            LPTOOLTIPTEXT pnmTT = (LPTOOLTIPTEXT)pnm;
            _GetURLToolTip(pnmTT->szText, ARRAYSIZE(pnmTT->szText));
            break;
        }

        case CBEN_DRAGBEGINA:
        {
            LPNMCBEDRAGBEGINA pnmbd = (LPNMCBEDRAGBEGINA)pnm;
            _OnDragBeginA(pnmbd);
            break;
        }

        case CBEN_DRAGBEGINW:

        {
            LPNMCBEDRAGBEGINW pnmbd = (LPNMCBEDRAGBEGINW)pnm;
            _OnDragBeginW(pnmbd);
            break;
        }

        case CBEN_GETDISPINFOW:
            _OnGetDispInfoW((PNMCOMBOBOXEXW)pnmce);
            break;

        case CBEN_GETDISPINFOA:
            _OnGetDispInfoA((PNMCOMBOBOXEXA) pnmce);
            break;

        case CBEN_DELETEITEM:
            if (pnmce->ceItem.lParam)
                ILFree((LPITEMIDLIST)pnmce->ceItem.lParam);
            break;

        default:
            lReturn = CAddressList::_OnNotify(pnm);
            break;
    }

    return lReturn;
}

/****************************************************\
    FUNCTION: _OnCommand
  
    DESCRIPTION:
        This function will handle WM_COMMAND messages.
\****************************************************/
LRESULT CSNSList::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch (GET_WM_COMMAND_CMD(wParam, lParam))
    {
    case CBN_CLOSEUP:
        if (_fPurgePending)
        {
            _fPurgePending = FALSE;
            _PurgeAndResetComboBox();
        }
        break;
    }

    return CAddressList::_OnCommand(wParam, lParam);
}

/****************************************************\
    PARAMETERS:
        LPSTR pszUrl - String Buffer that will contain the
                      URL as output.
        DWORD dwStrSize - Size of String buffer in characters.
  
    DESCRIPTION:
        Get the current URL.
\****************************************************/
HRESULT CSNSList::_GetURLToolTip(LPTSTR pszUrl, DWORD dwStrSize)
{
    ASSERT(pszUrl);
    if (!pszUrl)
        return E_INVALIDARG;

    LPITEMIDLIST pidlCur;
    HRESULT hr = _GetPIDL(&pidlCur); 
    if (S_OK == hr)
    {
        TCHAR szPidlName[MAX_URL_STRING];
        _GetPidlUI(pidlCur, szPidlName, ARRAYSIZE(szPidlName), NULL, NULL, SHGDN_FORPARSING, FALSE);
        lstrcpyn(pszUrl, szPidlName, dwStrSize);
        ILFree(pidlCur);
    }
    else
        pszUrl[0] = 0;

    return hr; 
}


/****************************************************\
    FUNCTION: _GetPIDL
  
    DESCRIPTION:
        This function returns a pointer to the current
    PIDL.  The caller will need to free the PIDL when
    it's no longer needed.  S_FALSE will be returned
    if there isn't a current PIDL.
\****************************************************/
HRESULT CSNSList::_GetPIDL(LPITEMIDLIST * ppidl)
{
    TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _GetPIDL() Begin");
    ASSERT(ppidl);
    if (!ppidl)
        return E_INVALIDARG;

    *ppidl = NULL;

    if (!_pbs)
    {
        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _GetPIDL(), _cache.pidl=>%s<", Dbg_PidlStr(_cache.pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
        if (_cache.pidl)
            *ppidl = ILClone(_cache.pidl);
    }
    else
    {
        _pbs->GetPidl(ppidl);

        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _GetPIDL(), Current Pidl in TravelLog. PIDL=>%s<", Dbg_PidlStr(*ppidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    }

    if (*ppidl)
        return S_OK;

    TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _GetPIDL() End");
    return S_FALSE;
}




/****************************************************\
  
    _AddItem - Adds one pidl to the address window
  
    Input:
        pidl - the pidl to add
        iInsert - where to insert
        iIndent - indentation level of pidl
  
\****************************************************/
void CSNSList::_AddItem(LPITEMIDLIST pidl, int iInsert, int iIndent)
{
    COMBOBOXEXITEM cei;
    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _AddItem(). PIDL=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

    cei.pszText = LPSTR_TEXTCALLBACK;
    cei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_INDENT | CBEIF_LPARAM;
    cei.lParam = (LPARAM)ILClone(pidl);
    cei.iIndent = iIndent;
    cei.iItem = iInsert;
    cei.iImage = I_IMAGECALLBACK;
    cei.iSelectedImage = I_IMAGECALLBACK;
    ASSERT(_hwnd);
    SendMessage(_hwnd, CBEM_INSERTITEM, 0, (LPARAM)&cei);
}


/****************************************************\
  
    _GetFullIDList - Get the pidl associated with a combo index
  
    Input:
        iItem - the item to retrieve
  
    Return:
        The pidl at that index.
        NULL on error.
  
\****************************************************/
LPITEMIDLIST CSNSList::_GetFullIDList(int iItem)
{
    LPITEMIDLIST pidl;
    
    ASSERT(_hwnd);
    pidl = (LPITEMIDLIST)SendMessage(_hwnd, CB_GETITEMDATA, iItem, 0);
    if (pidl == (LPITEMIDLIST)CB_ERR)
    {
        pidl = NULL;
    }
    
    return pidl;
}


/****************************************************\
  
    _GetIndent - Get the indentation level of a combo index
  
    Input:
        iItem - the item to retrieve
  
    Return:
        The indentation level.
        -1 on error.
  
\****************************************************/
int CSNSList::_GetIndent(int iItem)
{
    int iIndent;
    COMBOBOXEXITEM cbexItem;

    cbexItem.mask = CBEIF_INDENT;
    cbexItem.iItem = iItem;
    ASSERT(_hwnd);
    if (SendMessage(_hwnd, CBEM_GETITEM, 0, (LPARAM)&cbexItem))
    {
        iIndent = cbexItem.iIndent;
    }
    else
    {
        iIndent = -1;
    }
    
    return iIndent;
}


/****************************************************\
    FUNCTION: _ExpandMyComputer
  
    DESCRIPTION:
        Find the "My Computer" entry in the drop down
    list and expand it.
\****************************************************/
void CSNSList::_ExpandMyComputer(int iDepth)
{
    LPITEMIDLIST pidlMyComputer = NULL;
    
    SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer);
    if (pidlMyComputer)
    {
        LPITEMIDLIST pidl = NULL;
        BOOL fFound = FALSE;
        int nIndex = 0;

        while (pidl = _GetFullIDList(nIndex))
        {
            if (ILIsEqual(pidl, pidlMyComputer))
            {
                fFound = TRUE;
                break;
            }
            nIndex++;
        }
    
        if (fFound)
        {
            _FillOneLevel(nIndex, 2, iDepth);
        }

        ILFree(pidlMyComputer);
    }
}

/****************************************************\
  
    _FillOneLevel - find and add all of the children of one combo item
  
    Input:
        iItem - the item to expand
        iIndent - the indentation level of the children to add
        iDepth - the deepest indented item currently in the list
  
\****************************************************/
void CSNSList::_FillOneLevel(int iItem, int iIndent, int iDepth)
{
    LPITEMIDLIST pidl;
    
    pidl = _GetFullIDList(iItem);
    
    if (pidl)
    {
        HDPA hdpa;

        //
        // Fill hdps with all the children of this pidl.
        //
        hdpa = GetSortedIDList(pidl);
        if (hdpa)
        {
            int iCount, iInsert, i;
            LPITEMIDLIST pidlAlreadyThere;

            iCount = DPA_GetPtrCount(hdpa);

            //
            // The insert point starts right after parent.
            //
            iInsert = iItem + 1;

            //
            // Examine the next item.  If it is at the same level as
            // our soon-to-be-added children, remember it so we don't add
            // it twice.
            //
            pidlAlreadyThere = _GetFullIDList(iInsert);
            if (pidlAlreadyThere && (_GetIndent(iInsert) != iIndent))
            {
                pidlAlreadyThere = NULL;
            }

            //
            // Loop through each child.
            //
            for (i=0; i<iCount; i++, iInsert++)
            {
                LPITEMIDLIST pidlChild = (LPITEMIDLIST)DPA_GetPtr(hdpa, i);
                LPITEMIDLIST pidlInsert = ILClone(pidl);

                if (pidlInsert)
                {
                    ASSERT((LPVOID)pidlChild == (LPVOID)&pidlChild->mkid);
                    pidlInsert = ILAppendID(pidlInsert, &pidlChild->mkid, TRUE);
                    
                    //
                    // If this item was already added, we need to skip over it
                    // and all of its children that have been inserted.
                    // Because we know how this list was constructed,
                    // we know the number of items is iDepth-iIndent.
                    //
                    if (pidlAlreadyThere && ILIsEqual(pidlInsert, pidlAlreadyThere))
                    {
                        //
                        // Skip over this item (it's already been added) and
                        // its children.
                        //
                        iInsert += iDepth - iIndent;
                    }
                    else
                    {
                        _AddItem(pidlInsert, iInsert, iIndent);
                    }

                    ILFree(pidlInsert);
                }
            }
            
            FreeSortedIDList(hdpa);
        }
    }
}


/****************************************************\
  
    _GetSelectedPidl - return the pidl of the combo selection
  
    Return:
        The selected pidl.
        NULL on error.
  
\****************************************************/
LPITEMIDLIST CSNSList::_GetSelectedPidl(void)
{
    LPITEMIDLIST pidl = NULL;
    int iSel;
    
    ASSERT(_hwnd);
    iSel = ComboBox_GetCurSel(_hwnd);
    if (iSel >= 0)
    {
        pidl = _GetFullIDList(iSel);
    }

    DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
    TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _GetSelectedPidl(). PIDL=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    return pidl;
}


/****************************************************\
    _FindItem - return the combo index associated with a pidl.
    Input:
        pidl - the pidl to find.
  
    Return:
        The combo index.
        -1 on error.
\****************************************************/
int CSNSList::_FindItem(LPITEMIDLIST pidl)
{
    LPITEMIDLIST pidlCombo;
    int i = 0;
    int iRet = -1;
    int iMax;

    if (!pidl)
        return iRet;    // Return -1 to show that nothing is selected.

    ASSERT(_hwnd);
    iMax = (int)SendMessage(_hwnd, CB_GETCOUNT, 0, 0);

    for (i=0; i<iMax; i++)
    {
        pidlCombo = (LPITEMIDLIST)SendMessage(_hwnd, CB_GETITEMDATA, i, 0);

        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(TF_BAND|TF_GENERAL, "CSNSList: _FindItem(), ENUM ComboBox Pidls. PIDL=>%s<", Dbg_PidlStr(pidlCombo, szDbgBuffer, SIZECHARS(szDbgBuffer)));

        if (pidlCombo && IEILIsEqual(pidl, pidlCombo, TRUE))
        {
            iRet = i;
            break;
        }
    }

    return iRet;
}


/****************************************************\
    FUNCTION: _GetPidlImage
  
    PARAMETERS:
        pidl - the pidl to get the icon index.
        piImage - Pointer to location to store result. (OPTIONAL)
        piSelectedImage - Pointer to location to store result. (OPTIONAL)
  
    DESCRIPTION:
        This function will retrieve information about the
    icon index for the pidl.
\****************************************************/
BOOL CSNSList::_GetPidlImage(LPCITEMIDLIST pidl, int *piImage, int *piSelectedImage)
{
    int * piImagePriv = piImage;
    int * piSelectedImagePriv = piSelectedImage;
    int iNotUsed;
    BOOL fFound = FALSE;

    if (!piImagePriv)
        piImagePriv = &iNotUsed;

    if (!piSelectedImagePriv)
        piSelectedImagePriv = &iNotUsed;

    *piImagePriv = -1;
    *piSelectedImagePriv = -1;

    // PERF OPTIMIZATION: We will call directly to the browser window
    // which is a performance savings.  We can only do this in the
    // following situation:
    // 1. We are connected to a browser window.  (Bar only).
    // 2. The current pidl in the browser window is equal to the pidlParent.
    
    if (_pbp && (_pbp->IsConnected() == S_OK) && _cache.pidl)
    {
        if (ILIsEqual(pidl, _cache.pidl))
        {
            IOleCommandTarget * pcmdt;

            if (SUCCEEDED(_pbs->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pcmdt)))
            {
                VARIANT var = {0};
                HRESULT hresT = pcmdt->Exec(&CGID_ShellDocView, SHDVID_GETSYSIMAGEINDEX, 0, NULL, &var);
                if (SUCCEEDED(hresT)) 
                {
                    if (var.vt==VT_I4) 
                    {
                        *piImagePriv = var.lVal;
                        *piSelectedImagePriv = var.lVal;
                    } 
                    else 
                    {
                        ASSERT(0);
                        VariantClearLazy(&var);
                    }
                }
                pcmdt->Release();
            }
        }
    }

    if (-1 == *piImagePriv || -1 == *piSelectedImagePriv)
    {
        _GetPidlIcon(pidl, piImagePriv, piSelectedImagePriv) ;
    }
    return TRUE;
}

// NOTE: show full file system path if we're running with IE4's shell32
// (the Win95/NT4 shell and the Win2000 shell don't show the
//  full file system path in the address bar by default)

HRESULT _GetAddressBarText(LPCITEMIDLIST pidl, DWORD dwFlags, LPTSTR pszName, UINT cchName)
{
    HRESULT hr;
    *pszName = 0;

    if ((GetUIVersion() >= 5) &&
        ((dwFlags & (SHGDN_INFOLDER | SHGDN_FORPARSING)) == SHGDN_FORPARSING))
    {
        // NOTE: we are under GetUIVersion() >= 5 so we can use the "SH" versions of these API
        DWORD dwAttrib = SFGAO_FOLDER | SFGAO_LINK;
        SHGetAttributesOf(pidl, &dwAttrib);
        if (dwAttrib & SFGAO_FOLDER)
        {
            // folder objects respect the FullPathAddress flag, files (.htm) do not
            BOOL bFullTitle = TRUE; // As of WinXP, we default to true for Show Full Path In Address Bar
            DWORD cbData = SIZEOF(bFullTitle);
            SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT( "\\CabinetState"), TEXT("FullPathAddress"), NULL, &bFullTitle, &cbData);
            if (!bFullTitle)
                dwFlags = SHGDN_INFOLDER;       // convert parsing name into normal name

            if ((dwFlags & SHGDN_FORPARSING) && (dwAttrib & SFGAO_LINK))
            {
                // folder shortcut special case
                IShellLinkA *psl;  // Use A version for W95.
                if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IShellLinkA, &psl))))
                {
                    LPITEMIDLIST pidlTarget;
                    if (SUCCEEDED(psl->GetIDList(&pidlTarget)) && pidlTarget)
                    {
                        hr = SHGetNameAndFlags(pidlTarget, dwFlags | SHGDN_FORADDRESSBAR, pszName, cchName, NULL);
                        ILFree(pidlTarget);
                    }
                    psl->Release();
                }
            }
        }
    }

    if (0 == *pszName)
    {
        if (!ILIsRooted(pidl))
            dwFlags |= SHGDN_FORADDRESSBAR;
    
        hr = IEGetNameAndFlags(pidl, dwFlags, pszName, cchName, NULL);
        if (SUCCEEDED(hr))
        {
            SHRemoveURLTurd(pszName);
            SHCleanupUrlForDisplay(pszName);
        }
    }
    return hr;
}

// This function will retrieve information about the
// pidl so the ComboBox item can be displayed.
//        pidl - the pidl to examine.
//        pszName - gets the name. (OPTIONAL)
//        cchName - size of pszName buffer. (OPTIONAL)
//        piImage - gets the icon index. (OPTIONAL)
//        dwFlags - SHGDN_ flags
//        piSelectedImage - gets selected icon index. (OPTIONAL)

BOOL CSNSList::_GetPidlUI(LPCITEMIDLIST pidl, LPTSTR pszName, int cchName, int *piImage, int *piSelectedImage, DWORD dwFlags, BOOL fIgnoreCache)
{
    ASSERT(pidl);
    if (pszName && cchName)
        *pszName = 0;

    if (!fIgnoreCache && _cache.pidl && (pidl == _cache.pidl || ILIsEqual(pidl, _cache.pidl)))
    {
        lstrcpyn(pszName, _cache.szName, cchName);
        if (piImage)
            *piImage = _cache.iImage;
        if (piSelectedImage)
            *piSelectedImage = _cache.iSelectedImage;
    }
    else 
    {
        if (pszName && cchName)
             _GetAddressBarText(pidl, dwFlags, pszName, cchName);

        if (piImage || piSelectedImage)
        {
            _GetPidlImage(pidl, piImage, piSelectedImage);
        }
    }
    return TRUE;
}

/****************************************************\
    PARAMETERS:
        pidl - the pidl to examine.

    RETURN:
        TRUE if cached pidl is changed, FALSE o/w.
  
    DESCRIPTION:
        This function will set the cache to the pidl
    that was passed in.  The cached pidl will be freeded.
    The caller still needs to free the pidl that was passed
    in because it will be cloned.
\****************************************************/
BOOL CSNSList::_SetCachedPidl(LPCITEMIDLIST pidl)
{
    BOOL fCacheChanged = FALSE;
    
    if ((_cache.pidl == NULL) || !ILIsEqual(_cache.pidl, pidl))
    {
        fCacheChanged = TRUE;

        _GetPidlUI(pidl, _cache.szName, ARRAYSIZE(_cache.szName), 
            &_cache.iImage, &_cache.iSelectedImage, SHGDN_FORPARSING, FALSE);

        if (_cache.pidl)
            ILFree(_cache.pidl);

        _cache.pidl = ILClone(pidl);
    }

    return fCacheChanged;
}


/****************************************************\
    PARAMETER:
        pnmce - PNMCOMBOBOXEXA which will come from the ComboBoxEx
                when in AddressBand mode.  The AddressBar uses
                the ANSI version of this data structure.

    DESCRIPTION:
        Handle the WM_NOTIFY/CBEN_GETDISPINFO message.
    We will call into _OnGetDispInfoW() to handle the
    call and then thunk the Text back into ANSI on
    the way out.
  
    Return:
        Standard WM_NOTIFY result.
\****************************************************/
LRESULT CSNSList::_OnGetDispInfoA(PNMCOMBOBOXEXA pnmce)
{
    LRESULT lResult = 0;
    LPWSTR  pszUniTemp;
    LPSTR pszAnsiDest;

    if (pnmce->ceItem.mask & (CBEIF_TEXT))
    {
        pszUniTemp = (LPWSTR)LocalAlloc(LPTR, pnmce->ceItem.cchTextMax * SIZEOF(WCHAR));
        if (pszUniTemp)
        {
            pszAnsiDest = pnmce->ceItem.pszText;
            ((PNMCOMBOBOXEXW)pnmce)->ceItem.pszText = pszUniTemp;

            lResult = _OnGetDispInfoW((PNMCOMBOBOXEXW)pnmce);
            SHUnicodeToAnsi(pszUniTemp, pszAnsiDest, pnmce->ceItem.cchTextMax);
            pnmce->ceItem.pszText = pszAnsiDest;
            LocalFree((VOID*)pszUniTemp);
        }
    }

    return lResult;
}


/****************************************************\
    Handle the WM_NOTIFY/CBEN_GETDISPINFO message.
  
    Input:
        pnmce - the notify message.
  
    Return:
        Standard WM_NOTIFY result.
\****************************************************/
LRESULT CSNSList::_OnGetDispInfoW(PNMCOMBOBOXEXW pnmce)
{
    if (pnmce->ceItem.lParam &&
        pnmce->ceItem.mask & (CBEIF_SELECTEDIMAGE | CBEIF_IMAGE | CBEIF_TEXT))
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)pnmce->ceItem.lParam;

        // Normal case - ask shell to give us icon and text of a pidl.
        if (_GetPidlUI(pidl, pnmce->ceItem.pszText, pnmce->ceItem.cchTextMax,
                             &pnmce->ceItem.iImage, &pnmce->ceItem.iSelectedImage, 
                             SHGDN_INFOLDER, TRUE))
        {
            pnmce->ceItem.mask = CBEIF_DI_SETITEM | CBEIF_SELECTEDIMAGE |
                                 CBEIF_IMAGE | CBEIF_TEXT;
        }
    }

    return 0;
}


/*******************************************************************
    DESCRIPTION:
        This function will set the CShellUrl parameter to the item
    in the Drop Down list that is indexed by nIndex.
********************************************************************/
HRESULT CSNSList::SetToListIndex(int nIndex, LPVOID pvShelLUrl)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl = _GetFullIDList(nIndex);
    CShellUrl * psuURL = (CShellUrl *) pvShelLUrl;

    if (pidl)
        hr = psuURL->SetPidl(pidl);
    ASSERT(SUCCEEDED(hr));  // Should Always Succeed.

    return hr;
}


LPITEMIDLIST CSNSList::_GetDragDropPidl(LPNMCBEDRAGBEGINW pnmcbe)
{
    LPITEMIDLIST pidl;
    
    if (pnmcbe->iItemid == -1) 
    {
        pidl = ILClone(_cache.pidl);
    }
    else 
    {
        pidl = ILClone(_GetFullIDList(pnmcbe->iItemid));
    }
    return pidl;
}

HRESULT CSNSList::FileSysChangeAL(DWORD dw, LPCITEMIDLIST *ppidl)
{
    switch (dw)
    {
    case SHCNE_UPDATEIMAGE:
    case SHCNE_UPDATEITEM:
        _PopulateOneItem(TRUE);
        break;
    
    default:

        // Don't purge the combo box if it is dropped; that confuses
        // too many people.  For example, addrlist.cpp caches the
        // *index* of the current item, and purging causes all the indexes
        // to change...

        if (SendMessage(_hwnd, CB_GETDROPPEDSTATE, 0, 0)) {
            _fPurgePending = TRUE;
        } else {
            _PurgeAndResetComboBox();
        }
        break;
    }
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

# Build a browseuip.lib
BUILD_PRIVLIB   = 1

SELFREGNAME     = $(O)\selfreg_browseui.inf
MISCFILES       = $(MISCFILES) $(SELFREGNAME)

NO_BROWSER_FILE = 1
SYNCHRONIZE_DRAIN=1
TARGET_BOTH     = 1

!include $(CCSHELL_DIR)\browseui\browseui.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\browseui\browseui.inc

# For RC to find exdisp.TLB and brdispp.tlb
INCLUDES        = $(INCLUDES);$(SDK_LIB_PATH);$(O);$(CCSHELL_DIR)\lib\$(O)

TARGETNAME      = browseui
TARGETPATH      = obj
TARGETTYPE      = DYNLINK

#VERIFY_LC       = 1
LC_PATH         = $(PROJECT_ROOT)\lcinf

DLLDEF          = $(O)\browseui.def
DLLBASE         = 0x71500000

# NOTE!! We deliberately link to an NT4 compatible shell32.lib
#        so browseui can be loaded in the browser-only installations.
#        We use the NT version because it contains lego info.
#        The debug version of browseui links to the Win95 version
#        of shell32.lib simply so we can verify that we load in the
#        browser-only installations on Win95.
#
# Note:  Do *not* link to ntdll.  Win95 has an extremely minimal
#        implementation of ntdll.
#
# Note:  Do not link to uxtheme here. It needs to be in apithk.c. This file needs
#        to run downlevel where themes don't exist
#
# For DOJ compliance, don't link to private shell libs (e.g. shell32p.lib, comctlp.lib, uxthemep.lib)
#
TARGETLIBS      = $(SDK_LIB_PATH)\kernel32.lib      \
                  $(SHELL_LIB_PATH)\shlwapip.lib    \
                  $(PROJECT_ROOT)\lib\$(O)\shdocvwp.lib \
                  $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SDK_LIB_PATH)\user32.lib        \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SDK_LIB_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(SDK_LIB_PATH)\htmlhelp.lib      \
                  $(CCSHELL_DIR)\lib\$(O)\ieguidp.lib \
                  $(CCSHELL_DIR)\lib\$(O)\shguid.lib  \
                  $(CCSHELL_DIR)\lib\$(O)\shfusion4.lib \
                  $(SDK_LIB_PATH)\mpr.lib           \
!if $(386)
                  $(CCSHELL_DIR)\lib\$(O)\downlevel_shell32.lib \
!endif
                  $(SDK_LIB_PATH)\shell32.lib    \
                  $(SDK_LIB_PATH)\wininet.lib       \
                  $(SDK_LIB_PATH)\uxtheme.lib       \
                  $(INETCORE_LIB_PATH)\urlmonp.lib  \
                  $(PROJECT_ROOT)\lib\$(O)\shdocvwp.lib \
                  $(SDK_LIB_PATH)\msimg32.lib       \
                  $(SDK_LIB_PATH)\imm32.lib

DLLENTRY        = _DllMainCRTStartup

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

LINKLIBS        = ..\srcc\$(O)\srcc.lib         \
                  ..\srccpp\$(O)\srccpp.lib     \
                  ..\nt5api\$(O)\apithk.lib     \
                  ..\emclient\$(O)\emclient.lib \
                  ..\legacy\$O\legacy.lib       \
                  $(CCSHELL_DIR)\lib\$(O)\stock4.lib

# we want to force dlcheck.exe to run on browseui even though we don't use kernel32
# as our delayload handler
DLOAD_FORCE_ERROR_CHECK = 1

PRIVDEF         = $(O)\browseuip.def
PRIVDEFSRC      = ..\browseui.src
PRIVLIB         = browseuip.lib

# Maintain the sources list in the alphabetical order
SOURCES         = ..\browseui.rc

# Generate the selfreg file before compiling the RC file
NTTARGETFILE0  = $(SELFREGNAME)

NTTARGETFILES= $(CCSHELL_DIR)\lib\$(O)\browseui.lib \
               $(CCSHELL_DIR)\lib\$(O)\browseuip.lib

# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.BrowseUI
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information


#include "priv.h"

#ifndef FAVORITESTOSHDOCVW

#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif

#include "stdafx.h"

// HACKHACK (scotth): windowsx.h #define SubclassWindow.  ATL 2.1 headers
//  (namely atlwin.h and atlwin.cpp) have a member function with the
//  same name.
#ifdef SubclassWindow
#undef SubclassWindow
#endif

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#undef ATL_DEBUG_QI 
#include <atlimpl.cpp>

//HACK!!!!
#ifndef ATL_ENABLED
#define OleCreatePropertyFrame(a, b, c, d, e, f, g, h, i, j, k) S_OK
#endif


#include <atlctl.cpp>
#include <atlwin.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_)
#define AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif


#define _ATL_APARTMENT_THREADED

#define _ATL_NO_DEBUG_CRT           // use the shell debug facilities

#ifdef ATL_ENABLED
#define _ATL_NO_UUIDOF

extern "C"
inline HRESULT __stdcall OleCreatePropertyFrame(
  HWND hwndOwner,    //Parent window of property sheet dialog box
  UINT x,            //Horizontal position for dialog box
  UINT y,            //Vertical position for dialog box
  LPCOLESTR lpszCaption,
                     //Pointer to the dialog box caption
  ULONG cObjects,    //Number of object pointers in lplpUnk
  LPUNKNOWN FAR* lplpUnk,
                     //Pointer to the objects for property sheet
  ULONG cPages,      //Number of property pages in lpPageClsID
  LPCLSID lpPageClsID,
                     //Array of CLSIDs for each property page
  LCID lcid,         //Locale identifier for property sheet locale
  DWORD dwReserved,  //Reserved
  LPVOID lpvReserved //Reserved
)
{
    return S_OK;
}
#endif

#include <debug.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\shbrows2.cpp ===
#include "priv.h"

#include "apithk.h"
#include "sccls.h"
#include "shbrows2.h"
#include "commonsb.h"
#include "resource.h"
#include "bindcb.h"
#include "explore2.h"
#include <isguids.h>
#include "desktop.h"
#include <ntverp.h>
#include "bands.h"
#include "browbar.h"
#include "itbdrop.h"
#include "theater.h"
#include "itbar.h"
#include "idispids.h"
#include "bsmenu.h"
#include "legacy.h"
#include "mshtmcid.h"
#include <desktray.h>   // IDeskTray
#include "commonsb.h"
#include "onetree.h"
#include "cnctnpt.h"
#include "comcatex.h"
#include "util.h"
#include "uemapp.h"
#include <shobjidlp.h>
#include <subsmgr.h>
#include "trayp.h"
#include "oleacc.h"
// (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include <htmlhelp.h>
#include <varutil.h>
#include "idhidden.h"
#include "mediautil.h"

#ifdef UNIX
#include <mainwin.h>
#include "unixstuff.h"
EXTERN_C void unixGetWininetCacheLockStatus(BOOL *pBool, char **ppsz);
EXTERN_C const GUID CLSID_MsgBand;
#endif /* UNIX */

#include "mluisupp.h"

#define CWM_THEATERMODE                 (WM_USER + 400)
#define CWM_UPDATEBACKFORWARDSTATE      (WM_USER + 401)

#define SUPERCLASS CCommonBrowser

#define PERF_LOGGING 1

HRESULT IUnknown_GetClientDB(IUnknown *punk, IUnknown **ppdbc);

// Timer IDs
#define SHBTIMER_MENUSELECT     100

#define MENUSELECT_TIME         500     // .5 seconds for the menuselect delay

// Command group for private communication with CITBar
// 67077B95-4F9D-11D0-B884-00AA00B60104
const GUID CGID_PrivCITCommands = { 0x67077B95L, 0x4F9D, 0x11D0, 0xB8, 0x84, 0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 };
// Guid of Office's discussion band
// {BDEADE7F-C265-11d0-BCED-00A0C90AB50F}
EXTERN_C const GUID CLSID_DiscussionBand = { 0xbdeade7fL, 0xc265, 0x11d0, 0xbc, 0xed, 0x00, 0xa0, 0xc9, 0x0a, 0xb5, 0x0f };
// Guid of the Tip of the Day
//{4D5C8C25-D075-11d0-B416-00C04FB90376}
const GUID CLSID_TipOfTheDay =    { 0x4d5c8c25L, 0xd075, 0x11d0, 0xb4, 0x16, 0x00, 0xc0, 0x4f, 0xb9, 0x03, 0x76 };

// Used to see if the discussion band is registered for the CATID_CommBand
const LPCTSTR c_szDiscussionBandReg = TEXT("CLSID\\{BDEADE7F-C265-11d0-BCED-00A0C90AB50F}\\Implemented Categories\\{00021494-0000-0000-C000-000000000046}");

// FEATURE: Way back from 1997, ralphw thinks we should remove >iedefault from the following string
const TCHAR c_szHtmlHelpFile[]  = TEXT("%SYSTEMROOT%\\Help\\iexplore.chm>iedefault");

// Increment this when the saved structure changes
const WORD c_wVersion = 0x8002;

// This value will be initialized to 0 only when we are under IExplorer.exe
UINT g_tidParking = 0;

#define MAX_NUM_ZONES_ICONS         12
#define MAX_ZONE_DISPLAYNAME        260
UINT_PTR g_sysmenuTimer = 0;

void ITBar_ShowDW(IDockingWindow * pdw, BOOL fTools, BOOL fAddress, BOOL fLinks);
void RestrictItbarViewMenu(HMENU hmenu, IUnknown *punkBar);
BOOL IsExplorerWindow(HWND hwnd);
void _SetWindowIcon(HWND hwnd, HICON hIcon, BOOL bLarge);

//
// A named mutex is being used to determine if a critical operation exist, such as a file download.
// When we detect this we can prevent things like going offline while a download is in progress.
// To start the operation Create the named mutex. When the op is complete, close the handle.
// To see if any pending operations are in progress, Open the named mutex. Success/fail will indicate
// if any pending operations exist.  This mechanism is being used to determine if a file download is
// in progress when the user attempts to go offline.  If so, we prompt them to let them know that going 
// offline will cancel the download(s).
HANDLE g_hCritOpMutex = NULL;
const LPCSTR c_szCritOpMutexName = "CritOpMutex";
#define StartCriticalOperation()     ((g_hCritOpMutex = CreateMutexA(NULL, TRUE, c_szCritOpMutexName)) != (HANDLE)NULL)
#define EndCriticalOperation()       (CloseHandle(g_hCritOpMutex))
#define IsCriticalOperationPending() (((g_hCritOpMutex = OpenMutexA(MUTEX_ALL_ACCESS, TRUE, c_szCritOpMutexName)) != (HANDLE)NULL) && CloseHandle(g_hCritOpMutex))


#define MAX_FILECONTEXT_STRING (40)

#define VALIDATEPENDINGSTATE() ASSERT((_pbbd->_psvPending && _pbbd->_psfPending) || (!_pbbd->_psvPending && !_pbbd->_psfPending))

#define DM_NAV              TF_SHDNAVIGATE
#define DM_ZONE             TF_SHDNAVIGATE
#define DM_IEDDE            TF_SHDAUTO
#define DM_CANCELMODE       0
#define DM_UIWINDOW         0
#define DM_ENABLEMODELESS   0
#define DM_EXPLORERMENU     0
#define DM_BACKFORWARD      0
#define DM_PROTOCOL         0
#define DM_ITBAR            0
#define DM_STARTUP          0
#define DM_AUTOLIFE         0
#define DM_PALETTE          0
#define DM_SESSIONCOUNT     0
#define DM_FOCUS            0
#define DM_PREMERGEDMENU    DM_TRACE
#define DM_ONSIZE           DM_TRACE
#define DM_SSL              0
#define DM_SHUTDOWN         DM_TRACE
#define DM_MISC             0    // misc/tmp

extern IDeskTray * g_pdtray;
#define ISRECT_EQUAL(rc1, rc2) (((rc1).top == (rc2).top) && ((rc1).bottom == (rc2).bottom) && ((rc1).left == (rc2).left) && ((rc1).right == (rc2).right))

BOOL ViewIDFromViewMode(UINT uViewMode, SHELLVIEWID *pvid);

typedef struct _NAVREQUEST
{
    int cbNavData;
    BYTE *lpNavData;
    struct _NAVREQUEST *pnext;
} NAVREQUEST;

// copied from explore/cabwnd.h
#define MH_POPUP        0x0010
#define MH_TOOLBAR      0x0020

#define TBOFFSET_NONE   50
#define TBOFFSET_STD    0
#define TBOFFSET_HIST   1
#define TBOFFSET_VIEW   2

extern DWORD g_dwStopWatchMode;  // Shell performance mode


// Suite Apps Registry keys duplicated from dochost.cpp
#define NEW_MAIL_DEF_KEY            TEXT("Mail")
#define NEW_NEWS_DEF_KEY            TEXT("News")
#define NEW_CONTACTS_DEF_KEY        TEXT("Contacts")
#define NEW_CALL_DEF_KEY            TEXT("Internet Call")
#define NEW_APPOINTMENT_DEF_KEY     TEXT("Appointment")
#define NEW_MEETING_DEF_KEY         TEXT("Meeting")
#define NEW_TASK_DEF_KEY            TEXT("Task")
#define NEW_TASKREQUEST_DEF_KEY     TEXT("Task Request")
#define NEW_JOURNAL_DEF_KEY         TEXT("Journal")
#define NEW_NOTE_DEF_KEY            TEXT("Note")


#define SHELLBROWSER_FSNOTIFY_FLAGS (SHCNE_DRIVEADDGUI | SHCNE_SERVERDISCONNECT |     \
                                     SHCNE_MEDIAREMOVED | SHCNE_RMDIR | SHCNE_DELETE | \
                                     SHCNE_UPDATEDIR | SHCNE_NETUNSHARE |             \
                                     SHCNE_DRIVEREMOVED | SHCNE_UPDATEITEM |          \
                                     SHCNE_RENAMEFOLDER | SHCNE_UPDATEIMAGE |         \
                                     SHCNE_MEDIAINSERTED | SHCNE_DRIVEADD)

#define FAV_FSNOTIFY_FLAGS          (SHCNE_DISKEVENTS | SHCNE_UPDATEIMAGE)

#define GOMENU_RECENT_ITEMS         15
//
// Prototypes for "reset web settings" code
//
extern "C" HRESULT ResetWebSettings(HWND hwnd, BOOL *pfHomePageChanged);
extern "C" BOOL IsResetWebSettingsRequired(void);

const TCHAR c_szMenuItemCust[]      = TEXT("Software\\Policies\\Microsoft\\Internet Explorer");
const TCHAR c_szWindowUpdateName[]  = TEXT("Windows Update Menu Text");

#pragma warning(disable:4355)  // using 'this' in constructor

void CShellBrowser2::_PruneGoSubmenu(HMENU hmenu)
{
    // get by position since SHGetMenuFromID does a DFS and we are interested
    // in the one that is a direct child of hmenu and not some random menu
    // elsewhere in the hierarchy who might happen to have the same ID.

    int iPos = SHMenuIndexFromID(hmenu, FCIDM_MENU_EXPLORE);
    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;

    if (iPos >= 0 && GetMenuItemInfo(hmenu, iPos, TRUE, &mii) && mii.hSubMenu) {
        HMENU hmenuGo = mii.hSubMenu;

        // Remove everything after the first separator

        MENUITEMINFO mii;
        int iItem = 0;

        while (TRUE) {

            TCHAR szTmp[100];
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE;
            mii.dwTypeData = szTmp;
            mii.cch = ARRAYSIZE(szTmp);
        
            if (!GetMenuItemInfoWrap(hmenuGo, iItem++, TRUE, &mii))
                break;
        
            if (mii.fType == MFT_SEPARATOR) {
                // we must have hit the first seperator, delete the rest of the menu...
                for (int iDel = GetMenuItemCount(hmenuGo) - 1; iDel >= iItem; iDel--)
                    RemoveMenu(hmenuGo, iDel, MF_BYPOSITION);

                break;
            }
        }
    }
}

//
//  Okay, menus are weird because of the fifteen bazillion scenarios we
//  need to support.
//
//  There are several functions involved in menu editing.  _MenuTemplate,
//  and all the _OnXxxMenuPopup functions.
//
//  The job of _MenuTemplate is to do global menu munging.  These munges
//  once performed are permanent, so don't munge anything that changes
//  based on some random ambient condition.  The job of the _OnXxxMenuPopup
//  functions is to do per-instance last-minute munging.
//
//  Also, _MenuTemplate is the only place you can add or remove top-level
//  menu items.
//
//  fShell = TRUE means that this menu will be used for shell objects.
//  fShell = FALSE means that this menu will be used for web objects.
//
//  Now the rules...
//
//  NT5:
//      Tools present.
//      Shell: "Folder Options" on Tools (not View).
//      Web: "Internet Options" on Tools (not View).
//      FTP: "Internet Options" & "Folder Options" on Tools (not View).
//      Go under View (not top-level).
//
//  Non-NT5, fShell = TRUE, IsCShellBrowser() = TRUE (Single-pane)
//      Tools removed.
//      Shell: "Folder Options" on View (not Tools).
//      Web: "Internet Options" on View (not Tools).
//      FTP: "Internet Options" & "Folder Options" on View (not Tools).
//      Go on top-level (not under View).
//
//  Non-NT5, fShell = TRUE, IsCShellBrowser() = FALSE (Dual-pane)
//      Tools present.
//      Shell: "Folder Options" on View (not Tools).
//      Web: "Internet Options" on View (not Tools).
//      FTP: "Internet Options" & "Folder Options" on View (not Tools).
//      Go on top-level (not under View).
//
//  Non-NT5, fShell = FALSE, viewing web page:
//      Tools present.
//      Shell: "Folder Options" on Tools (not View).
//      Web: "Internet Options" on Tools (not View).
//      FTP: "Internet Options" & "Folder Options" on Tools (not View).
//      Go under View (not top-level).
//
//  Bonus details:
//      Restrictions.
//      Shell Options disabled if browser-only.
//

HMENU CShellBrowser2::_MenuTemplate(int id, BOOL fShell)
{
    HMENU hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(id));
    if (hmenu)
    {
        //
        //  According to the chart, there is only one scenario where
        //  we need to nuke the Tools menu:  Non-NT5 shell single-pane
        //
        if (IsCShellBrowser2() && fShell && GetUIVersion() < 5)
            DeleteMenu(hmenu, FCIDM_MENU_TOOLS, MF_BYCOMMAND);

        //
        //  According to the chart, Go vanishes from top-level on NT5
        //  and on non-shell scenarios.  It also vanishes if restricted.
        //
        if (GetUIVersion() >= 5 || !fShell || SHRestricted(REST_CLASSICSHELL)) {
            // get by position since DeleteMenu does a DFS & there are dup FCIDM_MENU_EXPLORE's
            int iPos = SHMenuIndexFromID(hmenu, FCIDM_MENU_EXPLORE);

            if (iPos >= 0)
                DeleteMenu(hmenu, iPos, MF_BYPOSITION);

        }

        // Nuke file menu if restricted
        if (SHRestricted(REST_NOFILEMENU))
            DeleteMenu(hmenu, FCIDM_MENU_FILE, MF_BYCOMMAND);

        // Nuke favorites menu if a rooted explorer or shell menu and classic shell is set
        // or if restricted
        if ((fShell && SHRestricted(REST_CLASSICSHELL)) 
            || SHRestricted2(REST_NoFavorites, NULL, 0))
            DeleteMenu(hmenu, FCIDM_MENU_FAVORITES, MF_BYCOMMAND);

        HMENU hmenuView = SHGetMenuFromID(hmenu, FCIDM_MENU_VIEW);
        if (hmenuView) {
            // Go appears in only one place, so this test is just
            // the reverse of the one that decided if Go stays
            // at top-level.
            if (fShell && GetUIVersion() < 5) {
                DeleteMenu(hmenuView, FCIDM_MENU_EXPLORE, MF_BYCOMMAND);
            }
        }

        // Folder Options requires integrated shell
        if (fShell && WhichPlatform() != PLATFORM_INTEGRATED)
        {
            if (hmenuView)
            {
                _EnableMenuItem(hmenuView, FCIDM_BROWSEROPTIONS, FALSE);
            }
            HMENU hmenuTools = SHGetMenuFromID(hmenu, FCIDM_MENU_TOOLS);
            if (hmenuTools)
            {
                _EnableMenuItem(hmenuTools, FCIDM_BROWSEROPTIONS, FALSE);
            }
        }
    }

    return hmenu;
}

// Determine if we need to add the Fortezza menu
// For perf reasons, do not call this function unless user is 
// browsing outside the local machine--- it will load WININET
bool NeedFortezzaMenu()
{
    static bool fChecked = false,
                fNeed = false;
    
    // Never show the Fortezza option when offline
    if (SHIsGlobalOffline())
        return false;
    else if (fChecked)
        return fNeed;
    else
    {
        fChecked = true;
        DWORD  fStatus  = 0;
        BOOL   fQuery   = InternetQueryFortezzaStatus(&fStatus, 0);
        return (fNeed = fQuery && (fStatus&FORTSTAT_INSTALLED));
    }
}

// Create and return the Fortezza menu
HMENU FortezzaMenu()
{
    HMENU hfm = NULL;

    static TCHAR  szLogInItem[32]   = TEXT(""), // Initialize to empty strings
                  szLogOutItem[32]  = TEXT(""), 
                  szChangeItem[32]  = TEXT("");
    static bool   fInit = false;

    if (!fInit)             // Load the strings only once
    {
        MLLoadString(IDS_FORTEZZA_LOGIN, szLogInItem, ARRAYSIZE(szLogInItem)-1);
        MLLoadString(IDS_FORTEZZA_LOGOUT, szLogOutItem, ARRAYSIZE(szLogOutItem)-1);
        MLLoadString(IDS_FORTEZZA_CHANGE, szChangeItem, ARRAYSIZE(szChangeItem)-1);
        fInit = true;
    }
    
    if (hfm = CreatePopupMenu())
    {
        AppendMenu(hfm, MF_STRING, FCIDM_FORTEZZA_LOGIN, szLogInItem);
        AppendMenu(hfm, MF_STRING, FCIDM_FORTEZZA_LOGOUT, szLogOutItem);
        AppendMenu(hfm, MF_STRING, FCIDM_FORTEZZA_CHANGE, szChangeItem);
    }
    return hfm;
}

// Configure the menu depending on card state
// This function is called only if Fortezza has been detected
void SetFortezzaMenu(HMENU hfm)
{
    if (hfm==NULL)
        return;

    DWORD fStatus = 0;
    if (InternetQueryFortezzaStatus(&fStatus, 0))
    {
        // If the query succeeds, the items are enabled depending
        // on whether the user is logged in to Fortezza.
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_CHANGE, (fStatus&FORTSTAT_LOGGEDON) ? TRUE  : FALSE);
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_LOGIN,  (fStatus&FORTSTAT_LOGGEDON) ? FALSE : TRUE);
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_LOGOUT, (fStatus&FORTSTAT_LOGGEDON) ? TRUE  : FALSE);
    }
    else
    {
        // If the query fails, all items are grayed out.
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_CHANGE, FALSE);
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_LOGIN, FALSE);
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_LOGOUT, FALSE);
    }
    return;
}

DWORD DoNetConnect(HWND hwnd)
{
    return (DWORD)SHStartNetConnectionDialog(NULL, NULL, RESOURCETYPE_DISK);
}

DWORD DoNetDisconnect(HWND hwnd)
{
    DWORD ret = WNetDisconnectDialog(NULL, RESOURCETYPE_DISK);

    SHChangeNotifyHandleEvents();       // flush any drive notifications

    TraceMsg(DM_TRACE, "shell:CNet - TRACE: DisconnectDialog returned (%lx)", ret);
    if (ret == WN_EXTENDED_ERROR)
    {
        // FEATURE: is this still needed
        // There has been a bug with this returning this but then still
        // doing the disconnect.  For now lets bring up a message and then
        // still do the notify to have the shell attempt to cleanup.
        TCHAR szErrorMsg[MAX_PATH];  // should be big enough
        TCHAR szName[80];            // The name better not be any bigger.
        DWORD dwError;
        WNetGetLastError(&dwError, szErrorMsg, ARRAYSIZE(szErrorMsg),
                szName, ARRAYSIZE(szName));

        MLShellMessageBox(NULL,
               MAKEINTRESOURCE(IDS_NETERROR), MAKEINTRESOURCE(IDS_DISCONNECTERROR),
               MB_ICONHAND | MB_OK, dwError, szName, szErrorMsg);
    }

    // FEATURE: deal with error, perhaps open a window on this drive
    return ret;
}



CShellBrowser2::CShellBrowser2() :
#ifdef NO_MARSHALLING
        _fDelayedClose(FALSE),
        _fOnIEThread(TRUE),
#endif
        _fStatusBar(TRUE),
        _fShowMenu(TRUE),
        _fValidComCatCache(FALSE),
        _fShowSynchronize(TRUE),
        _iSynchronizePos(-1),
        CSBSUPERCLASS(NULL)
{
    // warning: can't call SUPERCLASS until _Initialize has been called
    // (since that's what does the aggregation)

    ASSERT(IsEqualCLSID(_clsidThis, CLSID_NULL));
    ASSERT(_hwndDummyTB == NULL);
}
#pragma warning(default:4355)  // using 'this' in constructor

HRESULT CShellBrowser2::_Initialize(HWND hwnd, IUnknown *pauto)
{
    HRESULT hr;
    SHELLSTATE ss = {0};

    hr = SUPERCLASS::_Initialize(hwnd, pauto);
    if (SUCCEEDED(hr)) {
        SetTopBrowser();
        int i = _AllocToolbarItem();
        ASSERT(i == ITB_ITBAR);
        _GetToolbarItem(ITB_ITBAR)->fShow = TRUE;
        _put_itbLastFocus(ITB_VIEW);
        InitializeDownloadManager();
        _nTBTextRows = -1;
        
        SHGetSetSettings(&ss, SSF_MAPNETDRVBUTTON, FALSE);
        _fShowNetworkButtons = ss.fMapNetDrvBtn;

        // Initialize the base class transition site pointer.
        InitializeTransitionSite();

        // Invalidate icon cache in case non-IE browser took over .htm icons.
        IEInvalidateImageList();
        _UpdateRegFlags();
        
        _nMBIgnoreNextDeselect = RegisterWindowMessage(TEXT("CMBIgnoreNextDeselect"));

        _fShowFortezza = FALSE;
        _hfm = NULL;
    }

    return hr;
}

HRESULT CShellBrowser2_CreateInstance(HWND hwnd, void **ppsb)
{
    CShellBrowser2 *psb = new CShellBrowser2();
    if (psb)
    {
        HRESULT hr = psb->_Initialize(hwnd, NULL);      // aggregation, etc.
        if (FAILED(hr)) {
            ASSERT(0);    // shouldn't happen
            ATOMICRELEASE(psb);
        }
        *ppsb = (void *)psb;
        return hr;
    }
    return E_OUTOFMEMORY;
}

CShellBrowser2::~CShellBrowser2()
{
    _TheaterMode(FALSE, FALSE);

    if (IsWindow(_hwndDummyTB))
        DestroyWindow(_hwndDummyTB);
    
    // If automation was enabled, kill it now
    ATOMICRELEASE(_pbsmInfo);
    ATOMICRELEASE(_poctNsc);
    ATOMICRELEASE(_pcmNsc);
    ATOMICRELEASE(_pism);
    ATOMICRELEASE(_pizm);
    ATOMICRELEASE(_pcmSearch);
    ASSERT(0 == _punkMsgLoop);
    
    ILFree(_pidlLastHist);

    if (_hmenuPreMerged)
        DestroyMenu(_hmenuPreMerged);

    if (_hmenuTemplate)
        DestroyMenu(_hmenuTemplate);

    if (_hmenuFull)
        DestroyMenu(_hmenuFull);

    if (_hfm)
        DestroyMenu(_hfm);

    if (_lpPendingButtons)
        LocalFree(_lpPendingButtons);

    if (_lpButtons)
        LocalFree(_lpButtons);

    if (_hZoneIcon)
        DestroyIcon(_hZoneIcon);

    Str_SetPtr(&_pszSynchronizeText, NULL);

    if (_hEventComCat)
        CloseHandle(_hEventComCat);

    TraceMsg(TF_SHDLIFE, "dtor CShellBrowser2 %x", this);
}

void CShellBrowser2::v_FillCabStateHeader(CABSH* pcabsh, FOLDERSETTINGS* pfs)
{
    WINDOWPLACEMENT wp;
    OLECMD rgCmds[3] = {0};

    LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
    if (ptbi)
    {
        rgCmds[0].cmdID = CITIDM_VIEWTOOLS;
        rgCmds[1].cmdID = CITIDM_VIEWADDRESS;
        rgCmds[2].cmdID = CITIDM_VIEWLINKS;

        IUnknown_QueryStatus(ptbi->ptbar, &CGID_PrivCITCommands, ARRAYSIZE(rgCmds), rgCmds, NULL);
    }

    pcabsh->wv.bStdButtons = BOOLIFY(rgCmds[0].cmdf);
    pcabsh->wv.bAddress = BOOLIFY(rgCmds[1].cmdf);
    pcabsh->wv.bLinks = BOOLIFY(rgCmds[2].cmdf);    
    pcabsh->wv.bStatusBar = _fStatusBar;

    wp.length = sizeof(WINDOWPLACEMENT);
    GetWindowPlacement(_pbbd->_hwnd, &wp);

    pcabsh->dwHotkey = (UINT)SendMessage(_pbbd->_hwnd, WM_GETHOTKEY, 0, 0);

    //
    // Now Lets convert all of this common stuff into a
    // non 16/32 bit dependant data structure, such that both
    // can us it.
    //
    pcabsh->dwSize = sizeof(*pcabsh);
    pcabsh->flags = wp.flags;

    // 99/05/26 #345915 vtan: Don't mess with this. It's BY DESIGN.
    // #169839 caused #345915. When a window is minimized and closed
    // it should NEVER be opened minimized. The code that was here
    // has now caused a one month period where persistence of window
    // placement can be with SW_SHOWMINIMIZED which will cause the
    // window to restore minimized. This will go away when the window
    // is next closed.

    if ((wp.showCmd == SW_SHOWMINIMIZED) || (wp.showCmd == SW_MINIMIZE))
        pcabsh->showCmd = SW_SHOWNORMAL;
    else
        pcabsh->showCmd = wp.showCmd;

    pcabsh->ptMinPosition.x = wp.ptMinPosition.x;
    pcabsh->ptMinPosition.y = wp.ptMinPosition.y;
    pcabsh->ptMaxPosition.x = wp.ptMaxPosition.x;
    pcabsh->ptMaxPosition.y = wp.ptMaxPosition.y;

    pcabsh->rcNormalPosition = *((RECTL*)&wp.rcNormalPosition);

    // Now the folder settings
    pcabsh->ViewMode = pfs->ViewMode;
    // NB Don't ever preserve the best-fit flag or the nosubfolders flag.
    pcabsh->fFlags = pfs->fFlags & ~FWF_NOSUBFOLDERS & ~FWF_BESTFITWINDOW;

    pcabsh->fMask = CABSHM_VERSION;
    pcabsh->dwVersionId = CABSH_VER;

}

BOOL CShellBrowser2::_GetVID(SHELLVIEWID *pvid)
{
    BOOL bGotVID = FALSE;

    if (_pbbd->_psv && pvid) 
    {
        IShellView2 *psv2;
        
        if (SUCCEEDED(_pbbd->_psv->QueryInterface(IID_PPV_ARG(IShellView2, &psv2))))
        {
            if (S_OK == psv2->GetView(pvid, SV2GV_CURRENTVIEW))
            {
                bGotVID = TRUE;
            }
        
           psv2->Release();
        }
    }
    return bGotVID;
}

HRESULT CShellBrowser2::SetAsDefFolderSettings()
{
    HRESULT hres;

    if (_pbbd->_psv) 
    {
        SHELLVIEWID  vid;
        BOOL bGotVID = _GetVID(&vid);
        FOLDERSETTINGS fs;

        _pbbd->_psv->GetCurrentInfo(&fs);

        CABINETSTATE cs;
        GetCabState(&cs);

        if (cs.fNewWindowMode)
            g_dfs.bDefToolBarMulti = FALSE;
        else
            g_dfs.bDefToolBarSingle = FALSE;
        
        g_dfs.fFlags = fs.fFlags & (FWF_AUTOARRANGE); // choose the ones we case about
        g_dfs.uDefViewMode = fs.ViewMode;
        g_dfs.bDefStatusBar = _fStatusBar;
        
        g_dfs.bUseVID = bGotVID;
        if (bGotVID)
        {
            g_dfs.vid = vid;
        }
        else
        {
            ViewIDFromViewMode(g_dfs.uDefViewMode, &g_dfs.vid);
        }
        g_dfs.dwViewPriority = VIEW_PRIORITY_USEASDEFAULT;

        SaveDefaultFolderSettings(GFSS_SETASDEFAULT);

//  99/02/10 #226140 vtan: Get DefView to set default view

        IUnknown_Exec(_pbbd->_psv, &CGID_DefView, DVID_SETASDEFAULT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);

        hres = S_OK;
    } else {
        hres = E_FAIL;
    }

    return hres;
}

//---------------------------------------------------------------------------
// Closing a cabinet window.
//
// save it's local view info in the directory it is looking at
//
// NOTE: this will fail on read only media like net or cdrom
//
// REVIEW: we may not want to save this info on removable media
// (but if we don't allow a switch to force this!)
//
void CShellBrowser2::_SaveState()
{
    CABINETSTATE cs;
    GetCabState(&cs);

    // Don't save any state info if restrictions are in place.

    // We are trying to give a way for automation scripts to run that do not
    // update the view state.  To handle this we say if the window is not visible
    // (the script can set or unset visibility) than do not save the state (unless
    // falways add...)
    // Notwithstanding the above comments, suppress updating view state if UI
    // was set by automation
    if (_fUISetByAutomation ||
        !cs.fSaveLocalView ||
        SHRestricted(REST_NOSAVESET) || !IsWindowVisible(_pbbd->_hwnd) || _ptheater)
        return;

    if (_pbbd->_psv)
    {
        // Only save state if we close the browser in the same mode (either IE or Explorer)
        // that we started in.
        if (BOOLIFY(_IsPageInternet(_GetPidl())) == BOOLIFY(_fInternetStart))
        {
            if (IsOS(OS_WHISTLERORGREATER))
            {
                _PropertyBagSaveState();
            }
            else
            {
                _OldSaveState();
            }
        }
    }
}

void CShellBrowser2::_PropertyBagSaveState()
{
    FOLDERSETTINGS fs;
    _pbbd->_psv->GetCurrentInfo(&fs);

    CABSH cabsh;
    v_FillCabStateHeader(&cabsh, &fs);

    IPropertyBag* ppb;
    if (SUCCEEDED(GetPropertyBag(SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        SHPropertyBag_WritePOINTLScreenRes(ppb, VS_PROPSTR_MINPOS, &cabsh.ptMinPosition);
        SHPropertyBag_WritePOINTLScreenRes(ppb, VS_PROPSTR_MAXPOS, &cabsh.ptMaxPosition);
        SHPropertyBag_WriteRECTLScreenRes(ppb, VS_PROPSTR_POS, &cabsh.rcNormalPosition);

        SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_REV, _dwRevCount);
        SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_WPFLAGS, cabsh.flags);
        SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_SHOW, cabsh.showCmd);
        SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_FFLAGS, cabsh.fFlags);
        SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_HOTKEY, cabsh.dwHotkey);
        SHPropertyBag_WriteBOOL(ppb, VS_PROPSTR_BUTTONS, cabsh.wv.bStdButtons);
        SHPropertyBag_WriteBOOL(ppb, VS_PROPSTR_STATUS, cabsh.wv.bStatusBar);
        SHPropertyBag_WriteBOOL(ppb, VS_PROPSTR_LINKS, cabsh.wv.bLinks);
        SHPropertyBag_WriteBOOL(ppb, VS_PROPSTR_ADDRESS, cabsh.wv.bAddress);

        SHELLVIEWID  vid;
        if (_GetVID(&vid))
        {
            SHPropertyBag_WriteGUID(ppb, VS_PROPSTR_VID, &vid);
        }
        else
        {
            SHPropertyBag_Delete(ppb, VS_PROPSTR_VID);
        }

        ppb->Release();
    }
}

void CShellBrowser2::_OldSaveState()
{
    WINDOWPLACEMENT     currentWindowPlacement;
    WINVIEW             winView;

    currentWindowPlacement.length = 0;

    // if these keys are down, save the current states
    if (IsCShellBrowser2()  &&
        GetAsyncKeyState(VK_CONTROL) < 0) 
    {
       SetAsDefFolderSettings();
    }

    // Now get the view information
    FOLDERSETTINGS fs;
    _pbbd->_psv->GetCurrentInfo(&fs);


    IStream* pstm = NULL;

    // 99/05/07 #291358 vtan: Temporary solution to a problem dating back to IE4 days.

    // Here's where the window frame state if saved. This also saves the FOLDERSETTINGS
    // view information. Ideally it's best to separate the two but it seems reasonable
    // to only save frame state if this is the initial navigation. Once navigated away
    // only save view information and preserve the current frame state by reading what's
    // there and copying it. If there's no frame state then use what the current frame
    // state is. It could be possible to write out an empty frame state but if this
    // state is roamed to a down-level platform it may cause unexpected results.

    if (_fSBWSaved)
    {
        IStream     *pIStream;
        CABSH       cabinetStateHeader;

        pIStream = v_GetViewStream(_pbbd->_pidlCur, STGM_READ, L"CabView");
        if (pIStream != NULL)
        {
            if (SUCCEEDED(_FillCabinetStateHeader(pIStream, &cabinetStateHeader)))
            {

                // If an old frame state exists then save it and mark it as valid.

                currentWindowPlacement.length = sizeof(currentWindowPlacement);
                currentWindowPlacement.flags = cabinetStateHeader.flags;
                currentWindowPlacement.showCmd = cabinetStateHeader.showCmd;
                currentWindowPlacement.ptMinPosition = *(reinterpret_cast<POINT*>(&cabinetStateHeader.ptMinPosition));
                currentWindowPlacement.ptMaxPosition = *(reinterpret_cast<POINT*>(&cabinetStateHeader.ptMaxPosition));
                currentWindowPlacement.rcNormalPosition = *(reinterpret_cast<RECT*>(&cabinetStateHeader.rcNormalPosition));
                winView = cabinetStateHeader.wv;
            }
            pIStream->Release();
        }
    }

    if (!(_fSBWSaved && _fWin95ViewState))
    {
        pstm = v_GetViewStream(_pbbd->_pidlCur, STGM_CREATE | STGM_WRITE, L"CabView");
        _fSBWSaved = TRUE;
    }
    if (pstm)
    {
        CABSH cabsh;
        SHELLVIEWID  vid;
        BOOL bGotVID = _GetVID(&vid);

        v_FillCabStateHeader(&cabsh, &fs);

        if (currentWindowPlacement.length == sizeof(currentWindowPlacement))
        {

            // If an old frame state exists then put it back over the current frame state.

            cabsh.flags = currentWindowPlacement.flags;
            cabsh.showCmd = currentWindowPlacement.showCmd;
            cabsh.ptMinPosition = *(reinterpret_cast<POINTL*>(&currentWindowPlacement.ptMinPosition));
            cabsh.ptMaxPosition = *(reinterpret_cast<POINTL*>(&currentWindowPlacement.ptMaxPosition));
            cabsh.rcNormalPosition = *(reinterpret_cast<RECTL*>(&currentWindowPlacement.rcNormalPosition));
            cabsh.wv = winView;
        }

        if (bGotVID)
        {
            cabsh.vid = vid;
            cabsh.fMask |= CABSHM_VIEWID;
        }

        cabsh.fMask |= CABSHM_REVCOUNT;
        cabsh.dwRevCount = _dwRevCount;     // save out the rev count of when we were opened
    
        //
        // First output the common non view specific information
        //
        pstm->Write(&cabsh, sizeof(cabsh), NULL);

        // And release it, which will commit it to disk..
        pstm->Release();

        // NOTE (toddb): The DefView view state is saved by the base class so we don't need
        // to explicitly save it here.  If you do it gets called twice which is wasted time.
        // Do not call _pbbd->_psv->SaveViewState(); from this function.
    }

#ifdef DEBUG
    if (g_dwPrototype & 0x00000010) {
        //
        // Save toolbars
        //
        pstm = v_GetViewStream(_pbbd->_pidlCur, STGM_CREATE | STGM_WRITE, L"Toolbars");
        if (pstm) {
            _SaveToolbars(pstm);
            pstm->Release();
        }
    }
#endif
}

STDAPI_(LPITEMIDLIST) IEGetInternetRootID(void);

IStream *CShellBrowser2::v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName)
{
    IStream *pstm = NULL;
    LPITEMIDLIST pidlToFree = NULL;
    BOOL    bCabView = (0 == StrCmpIW(pwszName, L"CabView"));
    
    if (((NULL == pidl) && IsEqualCLSID(_clsidThis, CLSID_InternetExplorer)) ||
        IsBrowserFrameOptionsPidlSet(pidl, BFO_BROWSER_PERSIST_SETTINGS))
    {
        //  If this is a child of the URL or we're looking at an unititialized IE frame,
        //  then save all in the IE stream
        pidlToFree = IEGetInternetRootID();
        pidl = pidlToFree;
    }
    else if (bCabView && _fNilViewStream)
    {
        // if we loaded cabview settings from the 'unknown pidl' view stream,
        // we've got to stick with it, whether or not we now have a pidl.
        pidl = NULL; 
    }
   
    if (pidl)
    {
        pstm = SHGetViewStream(pidl, grfMode, pwszName, REGSTR_KEY_STREAMMRU, REGVALUE_STREAMS);
    }
    else if (bCabView)
    {
        //  So we don't have a pidl for which to grab a stream, so we'll just
        //  make up a stream to cover the situation.   A hack no doubt, but before we 
        //  were handling this case by always loading from the IE stream. (doh!)
        
        //  Actually, the whole thing is busted because we're
        //  creating the window (and trying to restore the windowpos) as part of
        //  CoCreateInstance(), before the client can navigate the browser.
        pstm = OpenRegStream(HKEY_CURRENT_USER, 
                              REGSTR_PATH_EXPLORER TEXT("\\Streams\\<nil>"), 
                              TEXT("CabView"), 
                              grfMode);
        _fNilViewStream = TRUE; // cabview settings initialized from the 'unknown pidl' view stream.
    }
    ILFree(pidlToFree);
    return pstm;
}
 
HRESULT CShellBrowser2::_FillCabinetStateHeader (IStream *pIStream, CABSH *cabsh)

{
    HRESULT hResult;

    // Now read in the state from the stream file.
    // read the old header first.

    hResult = IStream_Read(pIStream, cabsh, sizeof(CABSHOLD));

    // Sanity test to make the structure is sane

    if (FAILED(hResult) || (cabsh->dwSize < sizeof(CABSHOLD)))
        hResult = E_OUTOFMEMORY;        // bogus but good enough

    // Read the remainder of the structure if we can.  If not, then
    // set the mask equal to zero so we don't get confused later.

    if (cabsh->dwSize < sizeof(CABSH) ||
        FAILED(IStream_Read(pIStream, ((LPBYTE)cabsh) + sizeof(CABSHOLD), sizeof(CABSH) - sizeof(CABSHOLD))))
    {
        cabsh->fMask = 0;
    }
    return(hResult);
}

BOOL CShellBrowser2::_ReadSettingsFromPropertyBag(IPropertyBag* ppb, IETHREADPARAM *piei)
{
    BOOL fRet;

    CABSH cabsh = {0};
    cabsh.dwSize = sizeof(cabsh);
    cabsh.fMask = CABSHM_VERSION;
    cabsh.dwVersionId = CABSH_VER;

    if (SUCCEEDED(SHPropertyBag_ReadDWORD(ppb, VS_PROPSTR_WPFLAGS, &cabsh.flags)))
    {
        if (FAILED(SHPropertyBag_ReadPOINTLScreenRes(ppb, VS_PROPSTR_MINPOS, &cabsh.ptMinPosition)))
        {
            cabsh.ptMinPosition.x = cabsh.ptMinPosition.y = -1;
        }

        if (FAILED(SHPropertyBag_ReadPOINTLScreenRes(ppb, VS_PROPSTR_MAXPOS, &cabsh.ptMaxPosition)))
        {
            cabsh.ptMaxPosition.x = cabsh.ptMaxPosition.y = -1;
        }

        if (FAILED(SHPropertyBag_ReadRECTLScreenRes(ppb, VS_PROPSTR_POS, &cabsh.rcNormalPosition)))
        {
            cabsh.rcNormalPosition.left = cabsh.rcNormalPosition.top = cabsh.rcNormalPosition.right = cabsh.rcNormalPosition.bottom = CW_USEDEFAULT;
        }

        SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_MODE, &cabsh.ViewMode, FVM_TILE);
        SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_SHOW, &cabsh.showCmd, 0);
        SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_FFLAGS, &cabsh.fFlags, FWF_BESTFITWINDOW | g_dfs.fFlags);
        SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_HOTKEY, &cabsh.dwHotkey, 0);

        cabsh.wv.bStdButtons = SHPropertyBag_ReadBOOLDefRet(ppb, VS_PROPSTR_BUTTONS, TRUE);
        cabsh.wv.bStatusBar = SHPropertyBag_ReadBOOLDefRet(ppb, VS_PROPSTR_STATUS, TRUE);
        cabsh.wv.bLinks = SHPropertyBag_ReadBOOLDefRet(ppb, VS_PROPSTR_LINKS, TRUE);
        cabsh.wv.bAddress = SHPropertyBag_ReadBOOLDefRet(ppb, VS_PROPSTR_ADDRESS, TRUE);

        cabsh.fMask |= CABSHM_REVCOUNT;
        SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_REV, &cabsh.dwRevCount, g_dfs.dwDefRevCount);

        if (SUCCEEDED(SHPropertyBag_ReadGUID(ppb, VS_PROPSTR_VID, &cabsh.vid)))
        {
            cabsh.fMask |= CABSHM_VIEWID;
        }

        fRet = _FillIEThreadParamFromCabsh(&cabsh, piei);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

BOOL CShellBrowser2::_FillIEThreadParamFromCabsh(CABSH* pcabsh, IETHREADPARAM *piei)
{
    BOOL fUpgradeToWebView = FALSE;
    bool bInvalidWindowPlacement;

    // Now extract the data and put it into appropriate structures

    // first the window placement info
    piei->wp.length = sizeof(piei->wp);
    piei->wp.flags = (UINT)pcabsh->flags;
    piei->wp.showCmd = (UINT)pcabsh->showCmd;
    
    ASSERT(sizeof(piei->wp.ptMinPosition) == sizeof(pcabsh->ptMinPosition));
    piei->wp.ptMinPosition = *((LPPOINT)&pcabsh->ptMinPosition);
    piei->wp.ptMaxPosition = *((LPPOINT)&pcabsh->ptMaxPosition);

    ASSERT(sizeof(piei->wp.rcNormalPosition) == sizeof(pcabsh->rcNormalPosition));
    piei->wp.rcNormalPosition = *((RECT*)&pcabsh->rcNormalPosition);

    // Do some simple sanity checks to make sure that the returned
    // information appears to be reasonable and not random garbage
    // We want the Show command to be normal or minimize or maximize.
    // Only need one test as they are consectutive and start at zero
    // DON'T try to validate too much of the WINDOWPLACEMENT--
    // SetWindowPlacement does a much better job, especially in
    // multiple-monitor scenarios...

    // 99/03/09 #303300 vtan: Sanity check for zero/negative width or
    // height. SetWindowPlacement doesn't sanity check for this -
    // only for whether the rectangle left and top are in the visible
    // screen area. If this condition is detected then reset to default
    // and force DefView to best fit the window.

    {
        LONG    lWidth, lHeight;

        lWidth = piei->wp.rcNormalPosition.right - piei->wp.rcNormalPosition.left;
        lHeight = piei->wp.rcNormalPosition.bottom - piei->wp.rcNormalPosition.top;
        bInvalidWindowPlacement = ((lWidth <= 0) || (lHeight <= 0));
        if (bInvalidWindowPlacement)
            piei->wp.length = 0;
    }

    if (piei->wp.showCmd > SW_MAX)
        return FALSE;

    piei->fs.ViewMode = (UINT)pcabsh->ViewMode;
    piei->fs.fFlags = (UINT)pcabsh->fFlags;
    if (pcabsh->fMask & CABSHM_VIEWID)
    {
        // There was code here to revert to large icon mode if fWin95Classic
        // mode was turned on. This is completely busted because fWin95Classic
        // just affects the DEFAULT view, not any PERSISTED view.
        piei->m_vidRestore = pcabsh->vid;
        piei->m_dwViewPriority = VIEW_PRIORITY_CACHEHIT; // we have a cache hit!
    }

    // If there was a revcount, check if we've been overridden by
    // a subsequent "use these settings as the default for all future
    // windows".
    if (pcabsh->fMask & CABSHM_REVCOUNT)
    {
        if (g_dfs.dwDefRevCount != pcabsh->dwRevCount)
        {
            if (g_dfs.bUseVID)
            {
                piei->m_vidRestore = g_dfs.vid;
            }
            else
            {
                ViewIDFromViewMode(g_dfs.uDefViewMode, &(piei->m_vidRestore));
            }
            
            piei->fs.ViewMode  = g_dfs.uDefViewMode;
            piei->fs.fFlags    = g_dfs.fFlags;
            piei->m_dwViewPriority = g_dfs.dwViewPriority;
        }
    }

    _dwRevCount = g_dfs.dwDefRevCount;      // save this with the browser so we can save it out later

    if (!(pcabsh->fMask & CABSHM_VERSION) || (pcabsh->dwVersionId < CABSH_VER))
    {
        SHELLSTATE ss = {0};

        // old version of stream....

        SHGetSetSettings(&ss, SSF_WIN95CLASSIC, FALSE);

        // we have either a cache miss (or an older dwVersionId), or we are restricting to win95 mode,
        // so set the priority accordingly.
        piei->m_dwViewPriority = ss.fWin95Classic ? VIEW_PRIORITY_RESTRICTED : VIEW_PRIORITY_CACHEMISS; 
        
        if (ss.fWin95Classic)
        {
            // Hey, it's a Win95 CABSH structure and we're in Win95 mode,
            // so don't change the defaults!
            ViewIDFromViewMode(pcabsh->ViewMode, &(piei->m_vidRestore));
        }
        else
        {
            // Upgrade scenario:
            //   My Computer in List should wind up in Web View/List
            //   C:\ in List should wind up in List
            // If this fails (C:\ winds up in Large Icon), we can try
            // to comment out this code altogether. Hopefully defview's
            // default view stuff will realize Web View should be
            // selected and My Computer will go to Web View instead
            // of staying in List.
            //
            piei->m_vidRestore = DFS_VID_Default;

            // Note: if we upgrade to web view, we better let the
            // view recalc window space or the window will be TOO SMALL
            fUpgradeToWebView = TRUE;
        }

        if (pcabsh->wv.bStdButtons) // win95 called this bToolbar
        {
            // Win95 called bStdButtons bToolbar. IE4 separates this
            // into bAddress and bStdButtons. Set bAddress for upgrade.
            pcabsh->wv.bAddress = TRUE;

#define RECT_YADJUST    18
            // bump up the rect slightly to account for new toolbar size....
            // 18 is an approximately random number which assumes that the default
            // configuration is a single height toolbar which is approx twice as high as the
            // old toobar....
            //
            // NOTE: old browser streams are always for the primary monitor, so we just
            //       check to see if we are going to fit on the screen. If not, then don't bother.
            //
            // NOTE: when we rev the version number, we'll want to do this
            //       rect adjustment for the CABSH_WIN95_VER version...
            //
            int iMaxYSize = GetSystemMetrics(SM_CYFULLSCREEN);
            if (piei->wp.rcNormalPosition.bottom + piei->wp.rcNormalPosition.top + RECT_YADJUST < iMaxYSize)
            {
                piei->wp.rcNormalPosition.bottom += RECT_YADJUST;
            }
#undef RECT_YADJUST
        }
    }

    // After all that upgrade work, check the classic shell restriction
    if (SHRestricted(REST_CLASSICSHELL))
    {
        // It doesn't matter what vid was specified, use the ViewMode
        ViewIDFromViewMode(pcabsh->ViewMode, &(piei->m_vidRestore));
        piei->m_dwViewPriority = VIEW_PRIORITY_RESTRICTED; // use highest priority because of the restriction.

        // Oops, we can't upgrade...
        fUpgradeToWebView = FALSE;
    }

    // And the Hotkey
    piei->wHotkey = (UINT)pcabsh->dwHotkey;

    piei->wv = pcabsh->wv;

    // if we upgraded to web view, then any persisted window sizes will
    // probably be too small -- let them get resized by the view...
    if (fUpgradeToWebView || bInvalidWindowPlacement)
        piei->fs.fFlags |= FWF_BESTFITWINDOW;
    else
        piei->fs.fFlags &= ~FWF_BESTFITWINDOW;

    return TRUE;
}

BOOL CShellBrowser2::_ReadSettingsFromStream(IStream *pstm, IETHREADPARAM *piei)
{
    BOOL fRet;

    CABSH cabsh;

    if (SUCCEEDED(_FillCabinetStateHeader(pstm, &cabsh)))
    {
        fRet = _FillIEThreadParamFromCabsh(&cabsh, piei);
    }
    else
    {
        fRet = FALSE;
    }
     
    return fRet;
}

void CShellBrowser2::_FillIEThreadParam(LPCITEMIDLIST pidl, IETHREADPARAM *piei)
{
    BOOL fSettingsLoaded = FALSE;

    if (0 == GetSystemMetrics(SM_CLEANBOOT))
    {
        if (IsOS(OS_WHISTLERORGREATER))
        {
            IPropertyBag* ppb;
            if (SUCCEEDED(_GetPropertyBag(pidl, SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
            {
                fSettingsLoaded = _ReadSettingsFromPropertyBag(ppb, piei);
                ppb->Release();
            }
        }
        else
        {
            IStream* pstm = v_GetViewStream(pidl, STGM_READ, L"CabView");
            if (pstm)
            {
                fSettingsLoaded = _ReadSettingsFromStream(pstm, piei);
                pstm->Release();
            }
        }
    }

    if (!fSettingsLoaded)
        v_GetDefaultSettings(piei);
}

void CShellBrowser2::_UpdateFolderSettings(LPCITEMIDLIST pidl)
{
    if (!_fWin95ViewState)
    {
        IETHREADPARAM iei;

        ZeroMemory(&iei, sizeof(iei));
    
        _FillIEThreadParam(pidl, &iei);
    
        _fsd._vidRestore = iei.m_vidRestore;
        _fsd._dwViewPriority = iei.m_dwViewPriority;
        _fsd._fs = iei.fs;
    }
    else if (_pbbd->_psv)
    {
        IShellView2     *pISV2;

        // 99/04/16 #323726 vtan: Make sure that both the FOLDERSETTINGS (in _fsd._fs)
        // and the VID (in _fsd.vidRestore) is set up properly for shdocvw to make a
        // decision. This fixes Win95 browse in single window mode inheriting the view
        // from the source of navigation.

        _pbbd->_psv->GetCurrentInfo(&_fsd._fs);
        if (SUCCEEDED(_pbbd->_psv->QueryInterface(IID_PPV_ARG(IShellView2, &pISV2))))
        {
            if (SUCCEEDED(pISV2->GetView(&_fsd._vidRestore, SV2GV_CURRENTVIEW)))
                _fsd._dwViewPriority = VIEW_PRIORITY_INHERIT;
            else
                _fsd._dwViewPriority = VIEW_PRIORITY_DESPERATE;
            pISV2->Release();
        }
    }
}

void CShellBrowser2::_LoadBrowserWindowSettings(IETHREADPARAM *piei, LPCITEMIDLIST pidl)
{
    _FillIEThreadParam(pidl, piei);

    //Copy the two restore settings from piei to ShellBrowser.
    _fsd._vidRestore = piei->m_vidRestore;
    _fsd._dwViewPriority = piei->m_dwViewPriority;
    _fsd._fs = piei->fs;

    // Now that the ITBar has the menu on it, it must always be shown. We turn
    // on/off bands individually now...
    LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
    ptbi->fShow = TRUE;
        
    _fStatusBar = piei->wv.bStatusBar;

    // never allow VK_MENU to be our hot key
    if (piei->wHotkey != VK_MENU)
        SendMessage(_pbbd->_hwnd, WM_SETHOTKEY, piei->wHotkey, 0);

#ifdef DEBUG
    if (g_dwPrototype & 0x00000010) {
        //
        // Load toolbars
        //
        IStream* pstm = v_GetViewStream(pidl, STGM_READ, L"Toolbars");
        if (pstm) {
            _LoadToolbars(pstm);
            pstm->Release();
        }
    }
#endif
}

void CShellBrowser2::_UpdateChildWindowSize(void)
{
    if (!_fKioskMode) {
        if (_hwndStatus && _fStatusBar) {
            SendMessage(_hwndStatus, WM_SIZE, 0, 0L);
        }
    }
}


/*----------------------------------------------------------
Purpose: Helper function to do ShowDW on the internet toolbar.

         We can show all the bands in the toolbar, but we must
         never accidentally hide the menuband.  CShellBrowser2
         should call this function rather than IDockingWindow::ShowDW 
         directly if there is any chance fShow would be FALSE.

*/
void ITBar_ShowDW(IDockingWindow * pdw, BOOL fTools, BOOL fAddress, BOOL fLinks)
{
    IUnknown_Exec(pdw, &CGID_PrivCITCommands, CITIDM_SHOWTOOLS, fTools, NULL, NULL);
    IUnknown_Exec(pdw, &CGID_PrivCITCommands, CITIDM_SHOWADDRESS, fAddress, NULL, NULL);
    IUnknown_Exec(pdw, &CGID_PrivCITCommands, CITIDM_SHOWLINKS, fLinks, NULL, NULL);
}   

void CShellBrowser2::_HideToolbar(LPUNKNOWN punk)
{
    for (UINT itb=0; itb < (UINT)_GetToolbarCount(); itb++) {
        LPTOOLBARITEM ptbi = _GetToolbarItem(itb);

        if (ptbi->ptbar && SHIsSameObject(ptbi->ptbar, punk)) 
        {
            if (ITB_ITBAR == itb)
                ITBar_ShowDW(ptbi->ptbar, FALSE, FALSE, FALSE);
            else
                ptbi->ptbar->ShowDW(FALSE);
        }
    }
}

HRESULT CShellBrowser2::v_ShowHideChildWindows(BOOL fChildOnly)
{
    // (scotth): _hwndStatus is bogus when closing a window
    if (_hwndStatus && IS_VALID_HANDLE(_hwndStatus, WND))
        ShowWindow(_hwndStatus, (!_fKioskMode && _fStatusBar) ? SW_SHOW : SW_HIDE);

    Exec(NULL, OLECMDID_UPDATECOMMANDS, 0, NULL, NULL);
    _UpdateChildWindowSize();

    SUPERCLASS::v_ShowHideChildWindows(fChildOnly);

    // We should call _UpdateBackForwardState after the parent show/hide
    // toolbars. 
    UpdateBackForwardState();

    return S_OK;
}

#define MAX_BROWSER_WINDOW_TEMPLATE  (MAX_BROWSER_WINDOW_TITLE - 20)

void CShellBrowser2::v_GetAppTitleTemplate(LPTSTR pszBuffer, LPTSTR pszTitle)
{
    if (_fAppendIEToCaptionBar) 
    {
        TCHAR szBuffer[MAX_BROWSER_WINDOW_TEMPLATE];
        _GetAppTitle(szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pszBuffer, 80/* Supid params*/, TEXT("%%s - %s"), szBuffer);
    } 
    else 
    {
        // don't tack on "intenet explorer" if we didn't start there
        StrCpy(pszBuffer, TEXT("%s"));
    }
}


/*----------------------------------------------------------
Purpose: Intercept messages for menuband.

         Menuband messages must be intercepted at two points:

         1) the main message pump (IsMenuMessage method)
         2) the wndproc of a window that has a menuband 
            (TranslateMenuMessage method)

         The reason is sometimes a message will be received
         by the wndproc which did not pass thru the apps main
         message pump, but must be dealt with.  There are other
         messages which must be handled in the main message 
         pump, before TranslateMessage or DispatchMessage.

Returns: TRUE if the message was handled

*/
HRESULT CShellBrowser2::v_MayTranslateAccelerator(MSG* pmsg)
{
    HRESULT hres = S_FALSE;
    
    // (scotth): for some unknown reason (aka ActiveX init), we are 
    // receiving a null hwnd with WM_DESTROY when the user scrolls a page
    // that causes the ticker control to appear.  Check the pmsg->hwnd here
    // so we don't mistake a rogue WM_DESTROY msg for the real thing.
    
    IMenuBand* pmb = _GetMenuBand(_pbbd->_hwnd == pmsg->hwnd && WM_DESTROY == pmsg->message);

    if (pmb && _fActivated)
    {
        hres = pmb->IsMenuMessage(pmsg);

        // don't need to release pmb
    }
    
    if (hres != S_OK)
    {
        // REARCHITECT cleanup -- move menuband stuff & this check to v_MayTranslateAccelerator's caller
        if (WM_KEYFIRST <= pmsg->message && pmsg->message <= WM_KEYLAST)
        {
            hres = SUPERCLASS::v_MayTranslateAccelerator(pmsg);

            if (hres != S_OK)
            {
                //
                // Our SUPERCLASS didn't handle it.
                //
                if (_ShouldTranslateAccelerator(pmsg))
                {
                    //
                    // Okay, it's one of ours.  Let the toolbars have a crack at
                    // translating it.
                    //
                    for (UINT itb=0; (itb < (UINT)_GetToolbarCount()) && (hres != S_OK); itb++)
                    {
                        LPTOOLBARITEM ptbi = _GetToolbarItem(itb);

                        if (ptbi->fShow && (NULL != ptbi->ptbar))
                        {
                            IUnknown *pUnk;
                            
                            if (SUCCEEDED(IUnknown_GetClientDB(ptbi->ptbar, &pUnk)))
                            {
                                ASSERT(NULL != pUnk);
                                
                                hres = IUnknown_TranslateAcceleratorIO(pUnk, pmsg);

                                pUnk->Release();
                            }
                        }
                    }
                }
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Take a whack at translating any messages.

         CShellBrowser2 uses this to translate messages needed
         for menu bands.

Returns: TRUE if we handled it

*/
BOOL CShellBrowser2::_TranslateMenuMessage(HWND hwnd, UINT uMsg, 
    WPARAM * pwParam, LPARAM * plParam, LRESULT * plRet)
{
    BOOL bRet = FALSE;
    IMenuBand* pmb = _GetMenuBand(WM_DESTROY == uMsg);

    if (pmb)
    {
        MSG msg;

        msg.hwnd = hwnd;
        msg.message = uMsg;
        msg.wParam = *pwParam;
        msg.lParam = *plParam;
        
        bRet = (S_OK == pmb->TranslateMenuMessage(&msg, plRet));

        *pwParam = msg.wParam;
        *plParam = msg.lParam;

        // don't need to release pmb
    }

    return bRet;
}    

static TCHAR g_szWorkingOffline[MAX_BROWSER_WINDOW_TEMPLATE]=TEXT("");
static TCHAR g_szWorkingOfflineTip[MAX_BROWSER_WINDOW_TEMPLATE]=TEXT("");
static TCHAR g_szAppName[MAX_BROWSER_WINDOW_TEMPLATE]=TEXT("");

void InitTitleStrings()
{
    if (!g_szWorkingOffline[0])
    {
        DWORD dwAppNameSize = sizeof(g_szAppName);
        
        // Load this stuff only once per process for perf.
        if (SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, TEXT("Window Title"), NULL,
                            g_szAppName, &dwAppNameSize) != ERROR_SUCCESS)
            MLLoadString(IDS_TITLE, g_szAppName, ARRAYSIZE(g_szAppName));

        MLLoadString(IDS_WORKINGOFFLINETIP, g_szWorkingOfflineTip, ARRAYSIZE(g_szWorkingOfflineTip));
        MLLoadString(IDS_WORKINGOFFLINE, g_szWorkingOffline, ARRAYSIZE(g_szWorkingOffline));
        SHTruncateString(g_szWorkingOffline, ARRAYSIZE(g_szWorkingOffline) - (lstrlen(g_szAppName) + 4)); // give room for separator & EOL
    }
}

void CShellBrowser2::_ReloadTitle()
{
    g_szWorkingOffline[0] = 0;
    _fTitleSet = FALSE;
    _SetTitle(NULL);
}


HICON OfflineIcon()
{
    static HICON s_hiconOffline = NULL;
    if (!s_hiconOffline) 
    {
        s_hiconOffline = (HICON)LoadImage(HinstShdocvw(), MAKEINTRESOURCE(IDI_OFFLINE), IMAGE_ICON,
                             GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
        
    }
    return s_hiconOffline;
}


void CShellBrowser2::_ReloadStatusbarIcon()
{
    BOOL fIsOffline;
    VARIANTARG var = {0};
    var.vt = VT_I4;
    
    if (_pbbd && SUCCEEDED(IUnknown_Exec(_pbbd->_psv, &CGID_Explorer, SBCMDID_GETPANE, PANE_OFFLINE, NULL, &var)) &&
        (var.lVal != PANE_NONE))
    {    
        if (_pbbd->_pidlCur && IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_USE_IE_OFFLINE_SUPPORT))
            fIsOffline = SHIsGlobalOffline();
        else
            fIsOffline = FALSE;
    
        SendControlMsg(FCW_STATUS, SB_SETICON, var.lVal, fIsOffline ? (LPARAM) OfflineIcon() : NULL, NULL);
        if (fIsOffline) 
        {
            InitTitleStrings();
            SendControlMsg(FCW_STATUS, SB_SETTIPTEXT, var.lVal, (LPARAM)g_szWorkingOfflineTip, NULL);
        }
    }
}

void CShellBrowser2::_GetAppTitle(LPTSTR pszBuffer, DWORD cchSize)
{
    BOOL fOffline = SHIsGlobalOffline();
    
    pszBuffer[0] = 0;

    InitTitleStrings();

    if (fOffline)
    {
        wnsprintf(pszBuffer, cchSize, TEXT("%s - %s"), g_szAppName, g_szWorkingOffline); 
    }
    else
    {
#ifdef DEBUG

#ifdef UNICODE
#define DLLNAME TEXT("(BrowseUI UNI)")
#else
#define DLLNAME TEXT("(BrowseUI)")
#endif

#ifndef UNIX
        wnsprintf(pszBuffer, cchSize, TEXT("%s - %s"), g_szAppName, DLLNAME); 
#else
        wnsprintf(pszBuffer, cchSize, TEXT("%s%s - %s"), g_szAppName, UNIX_TITLE_SUFFIX, DLLNAME); 
#endif

#else

#ifndef UNIX
        lstrcpyn(pszBuffer, g_szAppName, cchSize);
#else
        wnsprintf(pszBuffer, cchSize, TEXT("%s%s"), g_szAppName, UNIX_TITLE_SUFFIX); 
#endif

#endif
    }

}

HWND CShellBrowser2::_GetCaptionWindow()
{
    return _pbbd->_hwnd;
}


/*----------------------------------------------------------
Purpose: Gets the cached menu band.  If the menu band hasn't
         been acquired yet, attempt to get it.  If bDestroy
         is TRUE, the menu band will be released.

         This does not AddRef because an AddRef/Release for each
         message is not necessary -- as long as callers beware!
*/
IMenuBand* CShellBrowser2::_GetMenuBand(BOOL bDestroy)
{
    // Don't bother to create it if we're about to go away.
    if (_fReceivedDestroy)
    {
        ASSERT(NULL == _pmb);
    }
    else if (bDestroy)
    {
        ATOMICRELEASE(_pmb);

        // Make it so we don't re-create the _pmb after the WM_DESTROY
        _fReceivedDestroy = TRUE;
    }

    // The menuband is created sometime after WM_CREATE is sent.  Keep
    // trying to get the menuband interface until we get it.

    else if (!_pmb)
    {
        IBandSite *pbs;
        if (SUCCEEDED(IUnknown_QueryService(_GetITBar(), IID_IBandSite, IID_PPV_ARG(IBandSite, &pbs))))
        {
            IDeskBand *pdbMenu;

            pbs->QueryBand(CBIDX_MENU, &pdbMenu, NULL, NULL, 0);
            if (pdbMenu)
            {
                pdbMenu->QueryInterface(IID_PPV_ARG(IMenuBand, &_pmb));
                // Cache _pmb, so don't release it here

                pdbMenu->Release();
            }
            pbs->Release();
        }
    }

    return _pmb;
}    


void CShellBrowser2::_SetMenu(HMENU hmenu)
{
    // Create a top-level menuband given this hmenu.  Add it to 
    // the bandsite.

    if (!_pmb) 
    {
        _GetMenuBand(FALSE);      // this does not AddRef

        if (!_pmb)
            return;
    }

    IShellMenu* psm;

    if (SUCCEEDED(_pmb->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
    {
        HMENU hCurMenu = NULL;
        psm->GetMenu(&hCurMenu, NULL, NULL);

        // only call setmenu if we know it is not the menu we have currently or it is not one of our precached standards...
        if ((hmenu != hCurMenu) || 
            (hmenu != _hmenuFull && hmenu != _hmenuTemplate  && hmenu != _hmenuPreMerged))
        {
            psm->SetMenu(hmenu, NULL, SMSET_DONTOWN | SMSET_MERGE);
        }
        psm->Release();
    }
}

STDAPI SHFlushClipboard(void);

HRESULT CShellBrowser2::OnDestroy()
{
    SUPERCLASS::OnDestroy();
    
    SHFlushClipboard();

    if (_uFSNotify)
        SHChangeNotifyDeregister(_uFSNotify);

    if (_fAutomation)
        IECleanUpAutomationObject();

    _DecrNetSessionCount();

    return S_OK;
}

BOOL CShellBrowser2::_CreateToolbar()
{
    return TRUE;
}

void CShellBrowser2::v_InitMembers()
{
    _hmenuTemplate =  _MenuTemplate(MENU_TEMPLATE, TRUE);
    _hmenuFull =      _MenuTemplate(MENU_FULL, TRUE);
    _hmenuPreMerged = _MenuTemplate(MENU_PREMERGED, FALSE);

    if (_fRunningInIexploreExe)
        _hmenuCur = _hmenuPreMerged;
    else
        _hmenuCur = _hmenuTemplate;
}


// REVIEW UNDONE - Stuff in programs defaults to save positions ???
void CShellBrowser2::v_GetDefaultSettings(IETHREADPARAM *piei)
{
    // set the flags

    // Best fit window means get the window to size according to the
    // contents of the view so that windows without existing settings
    // come up looking OK.
    piei->fs.fFlags = FWF_BESTFITWINDOW | g_dfs.fFlags;
    if (!_fRunningInIexploreExe)
    {
        piei->wv.bStatusBar = g_dfs.bDefStatusBar;
    }
    else
    {
        piei->wv.bStatusBar = TRUE;  //status bar is on by default in IE.
    }

    CABINETSTATE cs;
    GetCabState(&cs);
    if (cs.fSimpleDefault && cs.fNewWindowMode)
    {
        piei->wv.bStdButtons = piei->wv.bAddress = g_dfs.bDefToolBarMulti;
    }
    else
    {
        piei->wv.bStdButtons = piei->wv.bAddress = g_dfs.bDefToolBarSingle;
    }

    // For Win95 classic view, ITBar should be hidden by default.
    SHELLSTATE ss = {0};
    SHGetSetSettings(&ss, SSF_WIN95CLASSIC, FALSE);

    //  SHGetSetSettings checks SHRestricted(REST_CLASSICSHELL) for us
    if (ss.fWin95Classic)
    {
        piei->fs.ViewMode = FVM_ICON;
        piei->m_vidRestore = VID_LargeIcons;
        piei->m_dwViewPriority = VIEW_PRIORITY_RESTRICTED; // use highest priority because of the restriction.
    }
    else
    {
        piei->fs.ViewMode = g_dfs.uDefViewMode;
        piei->m_vidRestore = g_dfs.vid;
        piei->m_dwViewPriority = g_dfs.dwViewPriority;
    }

    _dwRevCount = g_dfs.dwDefRevCount;      // save this with the browser so we can save it out later

    ASSERT(piei->wp.length == 0);
}

void CShellBrowser2::_DecrNetSessionCount()
{
    TraceMsg(DM_SESSIONCOUNT, "_DecrNetSessionCount");

    if (_fVisitedNet) {
        SetQueryNetSessionCount(SESSION_DECREMENT);
        _fVisitedNet = FALSE;
    }
}

void CShellBrowser2::_IncrNetSessionCount()
{
    TraceMsg(DM_SESSIONCOUNT, "_IncrNetSessionCount");

    if (!_fVisitedNet) {
        BOOL fDontDoDefaultCheck = (BOOLIFY(_fAutomation) || (!(BOOLIFY(_fAddDialUpRef))));
        if (!SetQueryNetSessionCount(fDontDoDefaultCheck ? SESSION_INCREMENT_NODEFAULTBROWSERCHECK : SESSION_INCREMENT)) {
            g_szWorkingOffline[0] = 0;
#ifdef NO_MARSHALLING
            if (!_fOnIEThread)
                SetQueryNetSessionCount(fDontDoDefaultCheck ? SESSION_INCREMENT_NODEFAULTBROWSERCHECK : SESSION_INCREMENT);
#endif
      }
        _fVisitedNet = TRUE;
    }
}


// Initialize the Internet Toolbar. Create a dummy class to trap all the Messages that
// are sent to the old toolbar
BOOL CShellBrowser2::_PrepareInternetToolbar(IETHREADPARAM* piei)
{
    HRESULT hr = S_OK;

    if (!_GetITBar())
    {
        DWORD dwServerType = CLSCTX_INPROC_SERVER;
#ifdef FULL_DEBUG
        if (!(g_dwPrototype & PF_NOBROWSEUI))
            /// this will cause us to use OLE's co-create intance and not short circuit it.
            dwServerType = CLSCTX_INPROC;
#endif
        hr = CoCreateInstance(CLSID_InternetToolbar, NULL,
                              dwServerType,
                              IID_PPV_ARG(IDockingWindow, &_GetToolbarItem(ITB_ITBAR)->ptbar));

        TraceMsg(DM_ITBAR|DM_STARTUP, "CSB::_PrepareInternetToolbar CoCreate(CLS_ITBAR) returned %x", hr);

        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(_GetITBar(), SAFECAST(this, IShellBrowser*));
            // Look at the type of folder using "pidlInitial" and 
            // see if we have a stream for this type.
            // If so, open it and call IPersistStreamInit::Load(pstm);
            // else, call IPersistStreamInit::InitNew(void);

            IPersistStreamInit  *pITbarPSI;

            //Get the pointer to 
            if (SUCCEEDED(_GetITBar()->QueryInterface(IID_PPV_ARG(IPersistStreamInit, &pITbarPSI))))
            {
                // The initial toolbar needs to be the Web toolbar
                IUnknown_Exec(pITbarPSI, &CGID_PrivCITCommands, CITIDM_ONINTERNET, (_fUseIEToolbar ? CITE_INTERNET : CITE_SHELL), NULL, NULL);

                IStream *pstm = _GetITBarStream(_fUseIEToolbar, STGM_READ);
                if (pstm)
                {
                    //Stream exists. Let's load it from there.
                    hr = pITbarPSI->Load(pstm);
                    pstm->Release();
                }
                else
                {
                    //No stream already exists. Initialize from the old location!
                    pITbarPSI->InitNew();
                }

                pITbarPSI->Release();
            }

            SUPERCLASS::v_ShowHideChildWindows(TRUE);
        
            if (!_hwndDummyTB)
            {
                _hwndDummyTB = SHCreateWorkerWindow(DummyTBWndProc, _pbbd->_hwnd, 0, WS_CHILD, (HMENU)9999, this);
            }
        }
    }

    if (SUCCEEDED(hr) && !_pxtb)
        hr = QueryService(SID_SExplorerToolbar, IID_PPV_ARG(IExplorerToolbar, &_pxtb));

    return SUCCEEDED(hr);
}

BOOL LoadWindowPlacement(WINDOWPLACEMENT * pwndpl)
{
    BOOL fRetVal = FALSE;

    if (pwndpl)
    {
        DWORD dwSize = sizeof(WINDOWPLACEMENT);
        if (SHGetValueGoodBoot(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                TEXT("Window_Placement"), NULL, (PBYTE)pwndpl, &dwSize) == ERROR_SUCCESS)
        {
           fRetVal = TRUE;
            // Is the default value invalid?
            if ((pwndpl->rcNormalPosition.left >= pwndpl->rcNormalPosition.right) ||
                (pwndpl->rcNormalPosition.top >= pwndpl->rcNormalPosition.bottom))
            {
                // Yes, so fix it.  We worry about the normal size being zero or negative.
                // This fixes the munged case. 
                ASSERT(0); //  the stream is corrupted.
                fRetVal = FALSE;
            }
        }
    }
    return fRetVal;
}


BOOL StoreWindowPlacement(WINDOWPLACEMENT *pwndpl)
{
    if (pwndpl)
    {
        // Don't store us as minimized - that isn't what the user intended.
        // I.E. right click on minimized IE 3.0 in tray, pick close.  Since
        // we are minmized in that scenario we want to force normal
        // instead so we at least show up.
    
        if (pwndpl->showCmd == SW_SHOWMINIMIZED ||
            pwndpl->showCmd == SW_MINIMIZE)
            pwndpl->showCmd = SW_SHOWNORMAL;

        // Are about to save a corrupted window size?
        if ((pwndpl->rcNormalPosition.left >= pwndpl->rcNormalPosition.right) ||
            (pwndpl->rcNormalPosition.top >= pwndpl->rcNormalPosition.bottom))
        {
            // Yes, so fix it.
            ASSERT(0); // the size is invalid or corrupted.
        }
        else
        {
            return SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                TEXT("Window_Placement"), REG_BINARY, (const BYTE *)pwndpl, sizeof(WINDOWPLACEMENT)) == ERROR_SUCCESS;
        }
    }
    return FALSE;
}



BOOL StorePlacementOfWindow(HWND hwnd)
{
    WINDOWPLACEMENT wndpl;
    wndpl.length = sizeof(WINDOWPLACEMENT);
    
    if (GetWindowPlacement(hwnd, &wndpl)) 
    {
        return StoreWindowPlacement(&wndpl);
    }
    return FALSE;
}



// forward declaration
void EnsureWindowIsCompletelyOnScreen (RECT *prc);



// The rect will be offset slightly below and to the right of its current position.
// If this would cause it to move partly off the nearest monitor, then it is 
// instead placed at the top left of the same monitor.

void CascadeWindowRect(RECT *pRect)
{
    int delta = GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYSIZEFRAME) - 1;

    OffsetRect(pRect, delta, delta);
    
    // test if the new rect will end up getting moved later on
    RECT rc = *pRect;
    EnsureWindowIsCompletelyOnScreen(&rc);

    if (!EqualRect(pRect, &rc))
    {
        // rc had to be moved, so we'll restart the cascade using the best monitor
        MONITORINFO minfo;
        minfo.cbSize = sizeof(minfo);
        if (GetMonitorInfo(MonitorFromRect(&rc, MONITOR_DEFAULTTONEAREST), &minfo))
        {
            // And we do mean rcMonitor, not rcWork.  For example, if the taskbar is
            // at the top, then using rcMonitor with top-left = (0,0) will place it on
            // the edge of the taskbar.  Using rcWork with top-left = (0,y) will put
            // it y pixels below the taskbar's bottom edge, which is wrong.

            if (rc.bottom < pRect->bottom && rc.left == pRect->left)
            {
                // Too tall to cascade further down, but we can keep the X and just
                // reset the Y.  This fixes the bug of having a tall windows piling up
                // on the top left corner -- instead they will be offset to the right
                OffsetRect(pRect, 0, minfo.rcMonitor.top - pRect->top);   
            }
            else
            {
                // we've really run out of room, so restart cascade at top left
                OffsetRect(pRect, 
                    minfo.rcMonitor.left - pRect->left,
                    minfo.rcMonitor.top - pRect->top);
            }
        }
    }
}




void CalcWindowPlacement(BOOL fInternetStart, HWND hwnd, IETHREADPARAM *piei, WINDOWPLACEMENT *pwndpl)
{
    static RECT s_rcExplorer = {-1, -1, -1, -1};

    // We don't load the window placement for shell windows

    if (!fInternetStart || LoadWindowPlacement(pwndpl)) 
    {
        // If the show command specifies a normal show or default (i.e., our initial
        // display setting is not being overridden by the command line or
        // CreateProcess setting) then use the saved window state show command.
        // Otherwise, use the show command passed in to us.
        if (fInternetStart && ((piei->nCmdShow == SW_SHOWNORMAL) || (piei->nCmdShow == SW_SHOWDEFAULT)))
            piei->nCmdShow = pwndpl->showCmd;
        
        // Cascade if there is window of the same kind directly under us.

        HWND hwndT = NULL;
        ATOM atomClass = (ATOM) GetClassWord(hwnd, GCW_ATOM);

        while (hwndT = FindWindowEx(NULL, hwndT, (LPCTSTR) atomClass, NULL))
        {
            // Don't use GetWindowRect here because we load window placements
            // from the registry and they use the workspace coordinate system

            WINDOWPLACEMENT wp;
            wp.length = sizeof(wp);
            GetWindowPlacement(hwndT, &wp);        

            if (wp.rcNormalPosition.left == pwndpl->rcNormalPosition.left &&
                wp.rcNormalPosition.top == pwndpl->rcNormalPosition.top)
            {
                if ((piei->uFlags & COF_EXPLORE) &&
                    (s_rcExplorer.left != -1) && (s_rcExplorer.top != -1))
                {
                    // An explorer window is trying to appear on top of
                    // another one.  We'll use our stored rect's top-left 
                    // to make it cascade like IE windows.

                    OffsetRect(&pwndpl->rcNormalPosition,
                       s_rcExplorer.left - pwndpl->rcNormalPosition.left,
                       s_rcExplorer.top - pwndpl->rcNormalPosition.top);                    
                }

                // do the cascade for all windows
                CascadeWindowRect(&pwndpl->rcNormalPosition);
            }
        }

        // for IE and explorer, save the current location
        if (piei->uFlags & COF_EXPLORE)
            s_rcExplorer = pwndpl->rcNormalPosition;
        else if (fInternetStart)
            StoreWindowPlacement(pwndpl);
    } 
    else 
    {
        pwndpl->length = 0;
    }
}

class   CRGN
{
    public:
                CRGN (void)                     {   mRgn = CreateRectRgn(0, 0, 0, 0);                               }
                CRGN (const RECT& rc)           {   mRgn = CreateRectRgnIndirect(&rc);                              }
                ~CRGN (void)                    {   if (mRgn) TBOOL(DeleteObject(mRgn));                                      }

                operator HRGN (void)    const   {   return(mRgn);                                                   }
        void    SetRegion (const RECT& rc)      {   TBOOL(SetRectRgn(mRgn, rc.left, rc.top, rc.right, rc.bottom));  }
    private:
        HRGN    mRgn;
};

BOOL    CALLBACK    GetDesktopRegionEnumProc (HMONITOR hMonitor, HDC hdcMonitor, RECT* prc, LPARAM lpUserData)

{
    MONITORINFO     monitorInfo;

    monitorInfo.cbSize = sizeof(monitorInfo);
    if (GetMonitorInfo(hMonitor, &monitorInfo) != 0)
    {
        HRGN    hRgnDesktop;
        CRGN    rgnMonitorWork(monitorInfo.rcWork);

        hRgnDesktop = *reinterpret_cast<CRGN*>(lpUserData);
        if ((HRGN)rgnMonitorWork)
            TINT(CombineRgn(hRgnDesktop, hRgnDesktop, rgnMonitorWork, RGN_OR));
    }
    return(TRUE);
}

void    EnsureWindowIsCompletelyOnScreen (RECT *prc)

//  99/04/13 #321962 vtan: This function exists because user32 only determines
//  whether ANY part of the window is visible on the screen. It's possible to
//  place a window without an accessible title. Pretty useless when using the
//  mouse and forces the user to use the VERY un-intuitive alt-space.

{
    HMONITOR        hMonitor;
    MONITORINFO     monitorInfo;

    // First find the monitor that the window resides on using GDI.

    hMonitor = MonitorFromRect(prc, MONITOR_DEFAULTTONEAREST);
    ASSERT(hMonitor);           // get vtan - GDI should always return a result
    monitorInfo.cbSize = sizeof(monitorInfo);
    if (GetMonitorInfo(hMonitor, &monitorInfo) != 0)
    {
        LONG    lOffsetX, lOffsetY;
        RECT    *prcWorkArea, rcIntersect;
        CRGN    rgnDesktop, rgnIntersect, rgnWindow;

        // Because the WINDOWPLACEMENT rcNormalPosition field is in WORKAREA
        // co-ordinates this causes a displacement problem. If the taskbar is
        // at the left or top of the primary monitor the RECT passed even though
        // at (0, 0) may be at (100, 0) on the primary monitor in GDI co-ordinates
        // and GetMonitorInfo() will return a MONITORINFO in GDI co-ordinates.
        // The safest generic algorithm is to offset the WORKAREA RECT into GDI
        // co-ordinates and apply the algorithm in that system. Then offset the
        // WORKAREA RECT back into WORKAREA co-ordinates.

        prcWorkArea = &monitorInfo.rcWork;
        if (EqualRect(&monitorInfo.rcMonitor, &monitorInfo.rcWork) == 0)
        {

            // Taskbar is on this monitor - offset required.

            lOffsetX = prcWorkArea->left - monitorInfo.rcMonitor.left;
            lOffsetY = prcWorkArea->top - monitorInfo.rcMonitor.top;
        }
        else
        {

            // Taskbar is NOT on this monitor - no offset required.

            lOffsetX = lOffsetY = 0;
        }
        TBOOL(OffsetRect(prc, lOffsetX, lOffsetY));

        // WORKAREA RECT is in GDI co-ordinates. Apply the algorithm.

        // Check to see if this window already fits the current visible screen
        // area. This is a direct region comparison.

        // This enumeration may cause a performance problem. In the event that
        // a cheap and simple solution is required it would be best to do a
        // RECT intersection with the monitor and the window before resorting
        // to the more expensive region comparison. Get vtan if necessary.

        TBOOL(EnumDisplayMonitors(NULL, NULL, GetDesktopRegionEnumProc, reinterpret_cast<LPARAM>(&rgnDesktop)));
        rgnWindow.SetRegion(*prc);
        TINT(CombineRgn(rgnIntersect, rgnDesktop, rgnWindow, RGN_AND));
        if (EqualRgn(rgnIntersect, rgnWindow) == 0)
        {
            LONG    lDeltaX, lDeltaY;

            // Some part of the window is not within the visible desktop region
            // Move it until it all fits. Size it if it's too big.

            lDeltaX = lDeltaY = 0;
            if (prc->left < prcWorkArea->left)
                lDeltaX = prcWorkArea->left - prc->left;
            if (prc->top < prcWorkArea->top)
                lDeltaY = prcWorkArea->top - prc->top;
            if (prc->right > prcWorkArea->right)
                lDeltaX = prcWorkArea->right - prc->right;
            if (prc->bottom > prcWorkArea->bottom)
                lDeltaY = prcWorkArea->bottom - prc->bottom;
            TBOOL(OffsetRect(prc, lDeltaX, lDeltaY));
            TBOOL(IntersectRect(&rcIntersect, prc, prcWorkArea));
            TBOOL(CopyRect(prc, &rcIntersect));
        }

        // Put WORKAREA RECT back into WORKAREA co-ordinates.

        TBOOL(OffsetRect(prc, -lOffsetX, -lOffsetY));
    }
}

LPITEMIDLIST MyDocsIDList(void);

#define FRAME_OPTIONS_TO_TEST      (BFO_ADD_IE_TOCAPTIONBAR | BFO_USE_DIALUP_REF | BFO_USE_IE_TOOLBAR | \
                                    BFO_BROWSER_PERSIST_SETTINGS | BFO_USE_IE_OFFLINE_SUPPORT)
HRESULT CShellBrowser2::_SetBrowserFrameOptions(LPCITEMIDLIST pidl)
{
    BROWSERFRAMEOPTIONS dwOptions = FRAME_OPTIONS_TO_TEST;
    if (FAILED(GetBrowserFrameOptionsPidl(pidl, dwOptions, &dwOptions)))
    {
        // GetBrowserFrameOptionsPidl() will fail if pidl is NULL.
        // in that case we want to use _fInternetStart to determine
        // if we want these bits set or not.
        if (_fInternetStart)
            dwOptions = FRAME_OPTIONS_TO_TEST;   // Assume None.
        else
            dwOptions = BFO_NONE;   // Assume None.
    }
        
    _fAppendIEToCaptionBar = BOOLIFY(dwOptions & BFO_ADD_IE_TOCAPTIONBAR);
    _fAddDialUpRef = BOOLIFY(dwOptions & BFO_USE_DIALUP_REF);
    _fUseIEToolbar = BOOLIFY(dwOptions & BFO_USE_IE_TOOLBAR);
    _fEnableOfflineFeature = BOOLIFY(dwOptions & BFO_USE_IE_OFFLINE_SUPPORT);
    _fUseIEPersistence = BOOLIFY(dwOptions & BFO_BROWSER_PERSIST_SETTINGS);


    return S_OK;
}


HRESULT CShellBrowser2::_ReplaceCmdLine(LPTSTR pszCmdLine, DWORD cchCmdLine)
{
    TCHAR szVeryFirstPage[MAX_URL_STRING];

    HRESULT hr = _GetStdLocation(szVeryFirstPage, ARRAYSIZE(szVeryFirstPage), DVIDM_GOFIRSTHOME);
    TraceMsg(DM_NAV, "CSB::_ReplaceCmdLine _GetStdLocation(DVIDM_GOFIRSTHOME) returned %x", hr);

    if (SUCCEEDED(hr)) 
    {
        StrCpyN(pszCmdLine, szVeryFirstPage, cchCmdLine);
        TraceMsg(DM_NAV, "CSB::_ReplaceCmdLine _GetStdLocation(DVIDM_GOFIRSTHOME) returned %s", pszCmdLine);
    }

    return hr;
}
   

HRESULT CShellBrowser2::OnCreate(LPCREATESTRUCT pcs)
{
    HRESULT hres = S_OK;
    IETHREADPARAM* piei = (IETHREADPARAM*)pcs->lpCreateParams;
    BOOL    fUseHomePage = (piei->piehs ? FALSE : TRUE); // intentionally reversered
    DWORD dwExStyle = IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;

    _clsidThis = (piei->uFlags & COF_IEXPLORE) ? 
                 CLSID_InternetExplorer : CLSID_ShellBrowserWindow;

#ifdef NO_MARSHALLING
    if (!piei->fOnIEThread) 
        _fOnIEThread = FALSE;
#endif

    //
    //  Make this thread foreground here so that any UI from
    // USERCLASS::OnCreate will be on the top of other windows.
    // We used to call this in _AfterWindowCreate, but it is
    // too late for dialog boxes we popup while processing WM_CREATE
    // message.
    //
    // Note that we do call SetForegroundWindow even if this window
    // is not created as a result of CoCreateInstance. The automation
    // client is supposed to make it visible and bring it to the
    // foreground if it needs to. 
    //
    if (!piei->piehs) 
    {
        // On UNIX it is not common to force the window to the top of Z-order.
#ifndef UNIX
        SetForegroundWindow(_pbbd->_hwnd);  
#endif
    }

    SUPERCLASS::OnCreate(pcs);
    
    EnsureWebViewRegSettings();

    ASSERT(piei);
    _fRunningInIexploreExe = BOOLIFY(piei->uFlags & COF_IEXPLORE);
    v_InitMembers();

    CString             strCmdLine;

    if (piei->pszCmdLine)
    {
        strCmdLine = piei->pszCmdLine;
    }
    else
    {
        strCmdLine.Empty();
    }
    
    if (piei->fCheckFirstOpen) 
    {
        ASSERT(!ILIsRooted(piei->pidl));
        //
        // We don't want to go to the very first page, if this window
        // is created as the result of CoCreateInstnace.
        //
        if (!piei->piehs && (piei->uFlags & COF_IEXPLORE))
        {
            LPTSTR      pstrCmdLine = strCmdLine.GetBuffer( MAX_URL_STRING );

            if ( strCmdLine.GetAllocLength() < MAX_URL_STRING )
            {
                TraceMsg( TF_WARNING, "CShellBrowser2::OnCreate() - strCmdLine Allocation Failed!" );
                hres = E_OUTOFMEMORY;
            }
            else
            {
                if (SUCCEEDED(_ReplaceCmdLine( pstrCmdLine, MAX_URL_STRING ))) 
                {
                    _fInternetStart = TRUE;
                }

                // Let CString class own the buffer again.
                strCmdLine.ReleaseBuffer();
            }
        }

        piei->fCheckFirstOpen = FALSE;
    }

    // NOTE: These flags and corresponding ones in IETHREADPARAM are set to FALSE at creation, 
    // ParseCommandLine() is the only place where they are set.  -- dli
    _fNoLocalFileWarning = piei->fNoLocalFileWarning;
    _fKioskMode = piei->fFullScreen;
    if (piei->fNoDragDrop)
        SetFlags(0, BSF_REGISTERASDROPTARGET);
    _fAutomation = piei->fAutomation;
    
    // If someone deliberately tell us not to use home page. 
    if (piei->fDontUseHomePage) 
    {
        fUseHomePage = 0;
        
        // only the IE path sets this flag.
        // this is used by iexplorer.exe -nohome
        // and by ie dde to start out blank then navigate next
        _fInternetStart = TRUE;
    }

    if (piei->ptl)
        InitializeTravelLog(piei->ptl, piei->dwBrowserIndex);

    LPITEMIDLIST pidl = NULL;
    BOOL fCloning = FALSE;

    if ((( ! strCmdLine.IsEmpty() ) || piei->pidl)  && !_fAutomation)
    {
        if (piei->pidl) 
        {
            pidl = ILClone(piei->pidl);
        } 
        else 
        {
            int             cchCmdLine = strCmdLine.GetLength();
            LPTSTR          pstrCmdLine = strCmdLine.GetBuffer( MAX_URL_STRING );
            HRESULT         hresWrap;
            if ( strCmdLine.GetAllocLength() < MAX_URL_STRING )
            {
                TraceMsg( TF_WARNING, "CShellBrowser2::OnCreate() - strCmdLine Allocation Failed!" );
                hresWrap = E_OUTOFMEMORY;
            }
            else
            {
                hresWrap = WrapSpecialUrlFlat( pstrCmdLine, cchCmdLine + 1 );

                // Let CString class own the buffer again.
                strCmdLine.ReleaseBuffer();
            }

            if ( SUCCEEDED( hresWrap ) )
            {
                HRESULT hresT = _ConvertPathToPidl(this, _pbbd->_hwnd, strCmdLine, &pidl);

                TraceMsg(DM_STARTUP, "CSB::OnCreate ConvertPathToPidl(strCmdLine) returns %x", hresT);
            }
        }
    }
    

    if (pidl) 
    {
         fUseHomePage = FALSE;
    } 
    else if (_pbbd->_ptl && SUCCEEDED(_pbbd->_ptl->GetTravelEntry((IShellBrowser *)this, 0, NULL))) 
    {
        pidl = ILClone(&s_idlNULL);
        fCloning = TRUE;
        fUseHomePage = FALSE;
        // NOTE: if we ever hit this code when opening a window at non-web address
        // we'll need to be more selective about setting this flag
        _fInternetStart = TRUE;
    } 
    else if (fUseHomePage) 
    {
        // if we're not top level, assume we're going to be told
        // where to browse
        CString     strPath;

        LPTSTR      pstrPath = strPath.GetBuffer( MAX_URL_STRING );

        if ( strPath.GetAllocLength() < MAX_URL_STRING )
        {
            TraceMsg( TF_WARNING, "CShellBrowser2::OnCreate() - strPath Allocation Failed!" );
            hres = E_OUTOFMEMORY;
        }
        else
        {
            if (piei->uFlags & COF_IEXPLORE)
            {
                hres = _GetStdLocation( pstrPath, MAX_URL_STRING, DVIDM_GOHOME );
            }
            else
            {
                //  we need to get the default location for an explorer window
                //  which classically has been the root drive of the windows install
                GetModuleFileName( GetModuleHandle(NULL), pstrPath, MAX_URL_STRING );

                PathStripToRoot(pstrPath);
            }

            // Let CString class own the buffer again.
            strPath.ReleaseBuffer();
        }

        if (SUCCEEDED(hres)) 
        {
            IECreateFromPath( strPath, &pidl );
        }
    }

    // do this here after we've found what pidl we're looking at
    // but do it before the CalcWindowPlacement because
    // it might need to override
    _LoadBrowserWindowSettings(piei, pidl);

    // call this before PrepareInternetToolbar because it needs to know
    // _fInternetStart to know which toolbar config to use
    if (!_fInternetStart) 
    {
        if (pidl) 
        {
            if (fUseHomePage || IsURLChild(pidl, TRUE)) 
            {
                _fInternetStart = TRUE;
            } 
            else 
            {
                DWORD dwAttrib = SFGAO_FOLDER | SFGAO_BROWSABLE;

                // if it's on the file system, we'll still consider it to be an
                // internet folder if it's a docobj (including .htm file)
                IEGetAttributesOf(pidl, &dwAttrib);

                if ((dwAttrib & (SFGAO_FOLDER | SFGAO_BROWSABLE)) == SFGAO_BROWSABLE)
                    _fInternetStart = TRUE;
            }
        } 
        else if (!(piei->uFlags & COF_SHELLFOLDERWINDOW))
        {
            _fInternetStart = TRUE;
        }
    }

    _SetBrowserFrameOptions(pidl);
    CalcWindowPlacement(_fUseIEPersistence, _pbbd->_hwnd, piei, &piei->wp);
    
    if (!_PrepareInternetToolbar(piei))
        return E_FAIL;

    _CreateToolbar();

    // We must create _hwndStatus before navigating, because the
    // first navigate will go synchronous and the shell sends
    // status messages during that time. If the status window hasn't
    // been created, they drop on the floor.
    //
    _hwndStatus = CreateWindowEx(dwExStyle, STATUSCLASSNAME, NULL,
                                 WS_CHILD | SBARS_SIZEGRIP | WS_CLIPSIBLINGS | WS_VISIBLE | SBT_TOOLTIPS
                                 & ~(WS_BORDER | CCS_NODIVIDER),
                                -100, -100, 10, 10, _pbbd->_hwnd, (HMENU)FCIDM_STATUS, HINST_THISDLL, NULL);
#ifdef DEBUG
    if (g_dwPrototype & 0x00000004) 
    {
        HRESULT hres = E_FAIL;
        if (_SaveToolbars(NULL) == S_OK) 
        {
            // _LoadBrowserWindowSettings did a v_GetViewStream/ _LoadToolbars
            // if it succeeded (i.e. if we have > 0 toolbars), we're done
            // actually, even 0 toolbars could mean success, oh well...
            hres = S_OK;
        }
        ASSERT(SUCCEEDED(hres));
    }
#endif
    
    // REARCHITECT: do this early to let these objects see the first
    // navigate. but this causes a deadlock if the objects require
    // marshalling back to the main thread.
    _LoadBrowserHelperObjects();

#ifdef UNIX
    {
        BOOL bReadOnly = FALSE;
        static s_bMsgShown = FALSE;
        if (!s_bMsgShown) 
        {
            s_bMsgShown = TRUE;
            unixGetWininetCacheLockStatus (&bReadOnly, NULL);

            if (bReadOnly) 
            {
                _SetBrowserBarState(-1, &CLSID_MsgBand, 1);
            }
        }
    }

#endif
    BOOL fDontIncrementSessionCounter = FALSE;
    if (pidl)    // paranoia
    {
        if (fCloning)
        {
            ASSERT(_pbbd->_ptl);
            hres = _pbbd->_ptl->Travel((IShellBrowser*)this, 0);
        } 
        else
#ifndef UNIX
        {
            if (!_fAddDialUpRef)
                fDontIncrementSessionCounter = TRUE;
                
            hres = _NavigateToPidl(pidl, 0, 0);
            if (FAILED(hres)) 
            {
                fDontIncrementSessionCounter = TRUE; // We're going to windows\blank.htm or fail ...
                if (_fAddDialUpRef) 
                {
                    // if we failed, but this was a URL child, 
                    // we should still activate and go to blank.htm
                    hres = S_FALSE;
                }
                else if (piei->uFlags & COF_EXPLORE)
                {
                    // If an explorer browser, fall back to the desktop.
                    //
                    // The reason is that we want Start->Windows Explorer to
                    // bring up a browser even if MyDocs is inaccessible;
                    // however we don't want Start->Run "<path>" to bring up
                    // a browser if <path> is inaccessible.
                    //
                    
                    BOOL fNavDesktop = (hres != HRESULT_FROM_WIN32(ERROR_CANCELLED));

                    if (!fNavDesktop)
                    {
                        LPITEMIDLIST pidlDocs = MyDocsIDList();
                        if (pidlDocs)
                        {
                            fNavDesktop = ILIsEqual(pidl, pidlDocs);
                            ILFree(pidlDocs);
                        }
                    }
                    if (fNavDesktop)
                        hres = _NavigateToPidl(&s_idlNULL, 0, 0);
                }
            }
        }
#else
        {
            hres = S_FALSE;
            if (pidl)
            {
                LPITEMIDLIST pidlCopy = ILClone(pidl);
                PostMessage(_pbbd->_hwnd, WM_COMMAND, FCIDM_STARTPAGE, (LPARAM)pidlCopy);
            }
        }
#endif     
        ILFree(pidl);
    }

    if (_fAddDialUpRef && !fDontIncrementSessionCounter)
        _IncrNetSessionCount();

    if (IsOS(OS_WHISTLERORGREATER))
    {
        if (piei->wp.length == 0)
        {
            HMONITOR hmon = (piei->uFlags & COF_HASHMONITOR) ? reinterpret_cast<HMONITOR>(piei->pidlRoot) : NULL;
            _GetDefaultWindowPlacement(_pbbd->_hwnd, hmon, &piei->wp);
        }
    }
    else
    {

        // 99/04/07 #141049 vtan: If hMonitor was given then use this as the basis
        // for placement of a new window. Move the window position from the primary
        // monitor (where user32 placed it) to the specified HMONITOR. If this
        // results in a placement off screen then SetWindowPlacement() will fix
        // this up for us.

        if ((piei->wp.length == 0) && ((piei->uFlags & COF_HASHMONITOR) != 0) && (piei->pidlRoot != NULL))
        {
            MONITORINFO     monitorInfo;

            piei->wp.length = sizeof(piei->wp);
            TBOOL(GetWindowPlacement(_pbbd->_hwnd, &piei->wp));
            monitorInfo.cbSize = sizeof(monitorInfo);
            TBOOL(GetMonitorInfo(reinterpret_cast<HMONITOR>(piei->pidlRoot), &monitorInfo));
            TBOOL(OffsetRect(&piei->wp.rcNormalPosition, monitorInfo.rcMonitor.left, monitorInfo.rcMonitor.top));
        }
    }

    if (piei->wp.length == sizeof(piei->wp)) 
    {
        BOOL fSetWindowPosition = TRUE;

        // we do a SetWindowPlacement first with SW_HIDE
        // to get the size right firsth
        // then we really show it.
        if ((piei->nCmdShow == SW_SHOWNORMAL) || 
            (piei->nCmdShow == SW_SHOWDEFAULT)) 
            piei->nCmdShow = piei->wp.showCmd;
        piei->wp.showCmd = SW_HIDE;

        HWND hwndTray = GetTrayWindow();
        if (hwndTray)
        {
            RECT rc;
            if (GetWindowRect(hwndTray, &rc) && ISRECT_EQUAL(rc, piei->wp.rcNormalPosition))
            {
                // In this case, we want to ignore the position because
                // it's equal to the tray. (Came from Win95/OSR2 days)
                fSetWindowPosition = FALSE;
            }
        }

        if (fSetWindowPosition)
        {
            EnsureWindowIsCompletelyOnScreen(&piei->wp.rcNormalPosition);
            SetWindowPlacement(_pbbd->_hwnd, &piei->wp);
        }
    }

    v_ShowHideChildWindows(TRUE);

    if (piei->piehs)
    {
        // this thread was created to be the browser automation object

        // turn this on to prove CoCreateInstance does not cause a dead lock.
#ifdef MAX_DEBUG
        SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0, 0);
        Sleep(5);
        SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0, 0);
#endif
        //
        // WARNING: Note that we must SetEvent even though we can't return
        //  the marshalled automation object for some reason. Not signaling
        //  the event will block the caller thread for a long time.
        //
        if (SUCCEEDED(hres)) 
        {
            hres = CoMarshalInterface(piei->piehs->GetStream(), IID_IUnknown, _pbbd->_pautoWB2,
                                                 MSHCTX_INPROC, 0, MSHLFLAGS_NORMAL);
        }
        piei->piehs->PutHresult(hres);
        SetEvent(piei->piehs->GetHevent());
    }

    if (g_tidParking == GetCurrentThreadId()) 
    {
        IEOnFirstBrowserCreation(_fAutomation ? _pbbd->_pautoWB2 : NULL);
    }

    SHGetThreadRef(&_punkMsgLoop);  // pick up the ref to this thread

    TraceMsg(DM_STARTUP, "CSB::OnCreate returning hres=%x", hres);
    if (FAILED(hres))
    {
        _SetMenu(NULL);
        return E_FAIL;
    }
    return S_OK;
}

void CShellBrowser2::_GetDefaultWindowPlacement(HWND hwnd, HMONITOR hmon, WINDOWPLACEMENT* pwp)
{
    ASSERT(IsOS(OS_WHISTLERORGREATER));  // don't use on legacy systems.

    // We tailor our Web View content for 800x600
    int cxView = 800;
    int cyView = 600;

    int x;
    int y;

    // Make sure we fit on the monitor...
    //
    if (NULL == hmon)
        hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);

    if (hmon)
    {
        MONITORINFO monInfo = {sizeof(monInfo), 0};
        if (GetMonitorInfo(hmon, &monInfo))
        {
            pwp->length = sizeof(WINDOWPLACEMENT);
            if (GetWindowPlacement(hwnd, pwp))
            {
                // Move the window to the specified monitor.
                OffsetRect(&pwp->rcNormalPosition, monInfo.rcMonitor.left, monInfo.rcMonitor.top);

                // Reposition this window to fit on this monitor
                x = pwp->rcNormalPosition.left;
                y = pwp->rcNormalPosition.top;
                if (monInfo.rcWork.left <= pwp->rcNormalPosition.left &&
                    pwp->rcNormalPosition.left <= monInfo.rcWork.right &&
                    pwp->rcNormalPosition.left + cxView > monInfo.rcWork.right)
                {
                    x = max(monInfo.rcWork.left, monInfo.rcWork.right - cxView);
                }
                if (monInfo.rcWork.top <= pwp->rcNormalPosition.top &&
                    pwp->rcNormalPosition.top <= monInfo.rcWork.bottom &&
                    pwp->rcNormalPosition.top + cyView > monInfo.rcWork.bottom)
                {
                    y = max(monInfo.rcWork.top, monInfo.rcWork.bottom - cyView);
                }

                // Even with the above positioning, we don't want to be bigger than the monitor
                cxView = min(cxView, RECTWIDTH(monInfo.rcWork));
                cyView = min(cyView, RECTHEIGHT(monInfo.rcWork));

                // We're not using the whole screen so use the calculated position, else maximize.
                if (cxView != RECTWIDTH(monInfo.rcWork) || cyView != RECTHEIGHT(monInfo.rcWork))
                {
                    pwp->rcNormalPosition.left   = x;
                    pwp->rcNormalPosition.top    = y;
                    pwp->rcNormalPosition.right  = x + cxView;
                    pwp->rcNormalPosition.bottom = y + cyView;
                }
                else
                {
                    pwp->showCmd = SW_MAXIMIZE;
                }

            }
            else
            {
                pwp->length = 0;
            }
        }
    }
}



//***    InfoIdmToTBIdm -- convert btwn browserbar IDM and TBIDM
//
int InfoIdmToTBIdm(int val, BOOL fToTB)
{
    static const int menutab[] = {
        FCIDM_VBBSEARCHBAND, 
        FCIDM_VBBFAVORITESBAND, 
        FCIDM_VBBHISTORYBAND, 
        FCIDM_VBBEXPLORERBAND,
    };

    static const int tbtab[] = {
        TBIDM_SEARCH, 
        TBIDM_FAVORITES,
        TBIDM_HISTORY,
        TBIDM_ALLFOLDERS,
    };

    return SHSearchMapInt(fToTB ? menutab : tbtab, fToTB ? tbtab : menutab,
        ARRAYSIZE(menutab), val);
}

void _CheckSearch(UINT idmInfo, BOOL fCheck, IExplorerToolbar* _pxtb)
{
    idmInfo = InfoIdmToTBIdm(idmInfo, TRUE);
    if (idmInfo == -1)
        return;

    if (_pxtb)
    {
        UINT uiState;
        if (SUCCEEDED(_pxtb->GetState(&CLSID_CommonButtons, idmInfo, &uiState)))
        {
            if (fCheck)
                uiState |= TBSTATE_CHECKED;
            else
                uiState &= ~TBSTATE_CHECKED;
            _pxtb->SetState(&CLSID_CommonButtons, idmInfo, uiState);
        }
    }
}


//
// Implementation of CShellBrowser2::ShowToolbar
//
// Make toolbar visible or not and update our conception of whether it
// should be shown.  The toolbar by definition is strictly the toolbar.
// The caller has no idea that part of our internet toolbar also has
// the menu.  We must make sure we don't hide the menuband -- only the
// other bands on the internet toolbar.
//
// Returns: S_OK, if successfully done.
//          E_INVALIDARG, duh.
//
HRESULT CShellBrowser2::ShowToolbar(IUnknown* punkSrc, BOOL fShow)
{
    HRESULT hres;
    UINT itb = _FindTBar(punkSrc);

    if (ITB_ITBAR == itb)
    {
        LPTOOLBARITEM ptbi = _GetToolbarItem(itb);

        ITBar_ShowDW(ptbi->ptbar, fShow, fShow, fShow); 
        ptbi->fShow = fShow;

        hres = S_OK;
    }
    else
        hres = SUPERCLASS::ShowToolbar(punkSrc, fShow);

    return S_OK;
}


extern IDeskBand * _GetInfoBandBS(IBandSite *pbs, REFCLSID clsid);

#ifdef DEBUG // {
//***
// NOTES
//  WARNING: dtor frees up CBandSiteMenu on exit!
//  should we make sure some minimum set is created?
HRESULT CShellBrowser2::_AddInfoBands(IBandSite *pbs)
{
    if (!_pbsmInfo)
        return E_FAIL;

    BANDCLASSINFO *pbci;
    for (int i = 0; (pbci = _pbsmInfo->GetBandClassDataStruct(i)) != NULL; i++) 
    {
        IDeskBand *pband = _GetInfoBandBS(pbs, pbci->clsid);
        if (pband != NULL)
            pband->Release();
    }

    {
        // Exec -> Select or SetBandState ??? What do this mean ???
        // REARCHITECT chrisfra 5/23/97 - ever heard of variants?  this should set
        // vt = VT_I4 and lVal = 1.  this is horrible, I assume this is being ripped
        // out when Select funcs added, if not, it should be recoded.
        VARIANTARG vaIn = { 0 };
        //VariantInit();
        vaIn.vt = VT_UNKNOWN;
        vaIn.punkVal = (IUnknown *)1;   // show all
        IUnknown_Exec(pbs, &CGID_DeskBand, DBID_SHOWONLY, OLECMDEXECOPT_PROMPTUSER, &vaIn, NULL);
        //VariantClear();
    }

    return S_OK;
}
#endif // }

// REARCHITECT: [justmann 2000-01-27 this seems so ancient that it can be ignored]
// this is for ie4 shell compat - the ie4 shell menus have a Explorer bar popup
// need to make a pass through & fix all _GetBrowserBarMenu ref's,
// since we're back to having view->explorer bars-> on all platforms
HMENU CShellBrowser2::_GetBrowserBarMenu()
{
    HMENU hmenu = _GetMenuFromID(FCIDM_VIEWBROWSERBARS);

    if (hmenu == NULL)
    {
        hmenu = _GetMenuFromID(FCIDM_MENU_VIEW);
        if (hmenu == NULL)
        {
            //if we're here, someone has taken our view menu (docobj)
            hmenu = SHGetMenuFromID(_hmenuPreMerged, FCIDM_VIEWBROWSERBARS);
            ASSERT(hmenu);
        }
    }
    ASSERT(IsMenu(hmenu));
    return hmenu;
}


void CShellBrowser2::_AddBrowserBarMenuItems(HMENU hmenu)
{
    // Find the placeholder item, so we can add items before it
    int iPos = SHMenuIndexFromID(hmenu, FCIDM_VBBPLACEHOLDER);
    if (iPos < 0)
    {
        // we've already had our way with this menu
        ASSERT(_pbsmInfo);
        return;
    }

    //_pbsmInfo is shared across all views in the view menu
    BOOL fCreatedNewBSMenu = FALSE;

    if (!_pbsmInfo) 
    {
        IUnknown *punk;
        if (SUCCEEDED(CBandSiteMenu_CreateInstance(NULL, &punk, NULL))) 
        {
            punk->QueryInterface(CLSID_BandSiteMenu, (void **)&_pbsmInfo);
            punk->Release();
            fCreatedNewBSMenu = TRUE;
        }
    }

    if (!_pbsmInfo)
        return;

    int idCmdNext;
    UINT cBands = 0;

    if (fCreatedNewBSMenu) 
    {
        //  Load up infobands
        cBands = _pbsmInfo->LoadFromComCat(&CATID_InfoBand);

        // nuke any infoband entries that are already in the fixed list
        for (int i = FCIDM_VBBFIXFIRST; i < FCIDM_VBBFIXLAST; i++) 
        {
            const CLSID *pclsid = _InfoIdmToCLSID(i);
            if (pclsid)
            {
                if (_pbsmInfo->DeleteBandClass(*pclsid))
                    cBands--;
            }
        }

        // merge the additional infobands contiguously
        idCmdNext = _pbsmInfo->CreateMergeMenu(hmenu, VBBDYN_MAXBAND, iPos - 1, FCIDM_VBBDYNFIRST,0);

        //  Load up commbands
        _iCommOffset = cBands;
        cBands = _pbsmInfo->LoadFromComCat(&CATID_CommBand);
    }
    else
    {
        // Add the additional infobands contiguously
        int cMergedInfoBands = _pbsmInfo->GetBandClassCount(&CATID_InfoBand, TRUE /*merged*/); 
        idCmdNext = _pbsmInfo->CreateMergeMenu(hmenu, cMergedInfoBands, iPos - 1, FCIDM_VBBDYNFIRST,0);
        cBands = _pbsmInfo->LoadFromComCat(NULL);
    }

    // placeholder position may have changed at this point
    iPos = SHMenuIndexFromID(hmenu, FCIDM_VBBPLACEHOLDER);

    // Add comm bands.
    if (_iCommOffset != cBands)
    {
        //  Insert a separator if there are comm bands
        InsertMenu(hmenu, iPos + _iCommOffset + 1, MF_BYPOSITION | MF_SEPARATOR, -1, NULL);

        // Now merge the comm bands
        _pbsmInfo->CreateMergeMenu(hmenu, VBBDYN_MAXBAND, iPos + _iCommOffset + 2, idCmdNext, _iCommOffset);
    }
    DeleteMenu(hmenu, FCIDM_VBBPLACEHOLDER, MF_BYCOMMAND);

    if (!CMediaBarUtil::IsWMP7OrGreaterCapable())
    {
        DeleteMenu(hmenu, FCIDM_VBBMEDIABAND, MF_BYCOMMAND);
    }
}

int CShellBrowser2::_IdBarFromCmdID(UINT idCmd)
{
    const CATID* pcatid = _InfoIdmToCATID(idCmd);

    if (pcatid)
    {
        if (IsEqualCATID(*pcatid, CATID_InfoBand))
        {
            // It's a vertical bar
            return IDBAR_VERTICAL;
        }
        else
        {
            // It's a horizontal bar
            ASSERT(IsEqualCATID(*pcatid, CATID_CommBand));
            return IDBAR_HORIZONTAL;
        }
    }

    // Command doesn't correspond to any bar
    return IDBAR_INVALID;
}

int CShellBrowser2::_eOnOffNotMunge(int eOnOffNot, UINT idCmd, UINT idBar)
{
    // FEATURE: todo -- drive an ashen stake through the foul heart of this function

    if (eOnOffNot == -1) 
    {
        // toggle
        // 'special' guys are set; 'real' guys are toggled
        ASSERT(idCmd != FCIDM_VBBNOVERTICALBAR && idCmd != FCIDM_VBBNOHORIZONTALBAR);

        if (idCmd == FCIDM_VBBNOVERTICALBAR || idCmd == FCIDM_VBBNOHORIZONTALBAR)
            eOnOffNot = 0;
        else if ((idCmd >= FCIDM_VBBDYNFIRST) && (idCmd <= FCIDM_VBBDYNLAST))
            eOnOffNot = (idBar == IDBAR_VERTICAL) ? (idCmd != _idmInfo) : (idCmd != _idmComm);
        else
            eOnOffNot = (idCmd != _idmInfo);
    }

    return eOnOffNot;
}

#define MIIM_FTYPE       0x00000100

//***   csb::_SetBrowserBarState -- handle menu/toolbar/exec command, *and* update UI
// ENTRY/EXIT
//  idCmd           FCIDM_VBB* or -1 (if want to use pclsid instead)
//  pclsid          clsid or NULL (if want to use idCmd instead)
//  eOnOffToggle    1=on, 0=off, -1=not (off/not only for fixed bands for now)
// NOTES
//  menu code calls w/ idCmd, Exec code calls w/ pclsid
//
void CShellBrowser2::_SetBrowserBarState(UINT idCmd, const CLSID *pclsid, int eOnOffNot, LPCITEMIDLIST pidl)
{
    if (idCmd == -1)
        idCmd = _InfoCLSIDToIdm(pclsid);

    if (pclsid == NULL)
        pclsid = _InfoIdmToCLSID(idCmd);

    ASSERT(_InfoCLSIDToIdm(pclsid) == idCmd);

    int idBar = _IdBarFromCmdID(idCmd);
    if (idBar == IDBAR_INVALID)
    {
        // We don't recognize this bubby, bail
        return;
    }
    ASSERT(IDBAR_VERTICAL == idBar || IDBAR_HORIZONTAL == idBar);

    // Munge the unholy eOnOffNot
    eOnOffNot = _eOnOffNotMunge(eOnOffNot, idCmd, idBar);
    if (eOnOffNot == 0 && (idCmd != _idmInfo) && (idCmd != _idmComm)) 
    {
        // already off
        return;
    }

    // _ShowHideBrowserBar can affect the size of the view window, but the on/off state of
    // the bar isn't actually updated until we update _idmInfo below.  But we want the
    // view to be able to query the accurate on/off state of the bar during the resize.
    // So postpone resize of the actual hwnd until after the on/off state is set correctly.
    //
    _fHaveDelayedSize = FALSE;
    _hwndDelayedSize = _pbbd->_hwndView;

    // Reduce flicker: turn off window painting while we resize several windows
    BOOL fLock = LockWindowUpdate(_pbbd->_hwnd);

    ASSERT(0 == eOnOffNot || 1 == eOnOffNot);
    pclsid = _ShowHideBrowserBar(idBar, pclsid, eOnOffNot, pidl);

    if (IDBAR_VERTICAL == idBar)
        v_SetIcon();

    if (IDBAR_VERTICAL == idBar)
    {
        // Vertical bar

        // since we support multiple searches in the same band
        // it is possible to have search band open when we clicked on
        // a different search so to avoid flicker we don't "unpress" the button
        if (_idmInfo != idCmd)
            _CheckSearch(_idmInfo, FALSE, _pxtb);

        _idmInfo = eOnOffNot ? idCmd : FCIDM_VBBNOVERTICALBAR;
        _CheckSearch(_idmInfo, TRUE, _pxtb);
    }
    else 
    {
        // Horizontal bar
        _idmComm = eOnOffNot ? idCmd : FCIDM_VBBNOHORIZONTALBAR;
    }

    // Make sure that the toolbar is updated
    Exec(NULL, OLECMDID_UPDATECOMMANDS, 0, NULL, NULL);

    //set the dirty bit on itbar and save
    Exec(&CGID_PrivCITCommands, CITIDM_SET_DIRTYBIT, TRUE, NULL, NULL);
    Exec(&CGID_ShellBrowser, FCIDM_PERSISTTOOLBAR, 0, NULL, NULL);

    // If we delayed a resize of the view window, update it now
    if (_fHaveDelayedSize)
    {
        HWND hwnd = _hwndDelayedSize;
        _hwndDelayedSize = NULL;
        _PositionViewWindow(hwnd, &_rcDelayedSize);
    }
    else
    {
        _hwndDelayedSize = NULL;
    }

    if (fLock)
        LockWindowUpdate(NULL);
}

//***   do the op, but do *not* update the UI
// ENTRY/EXIT
//  return      guy who's now visible (pclsid, 0 [VBBNONE], or 1 [VBBALL])
// NOTES
//  don't call this directly, it's just a helper.
//  don't reference UI stuff (_idmInfo etc.) (except for ASSERTs).
const CLSID * CShellBrowser2::_ShowHideBrowserBar(int idBar, const CLSID *pclsid, int eOnOff, LPCITEMIDLIST pidl /*= NULL*/)
{
    ASSERT(IDBAR_VERTICAL == idBar || IDBAR_HORIZONTAL == idBar);

    IBandSite* pbsSite = NULL;
    HRESULT    hr = E_FAIL;

    if (_fUISetByAutomation)
    {
        if (0 == eOnOff || NULL == pclsid)
        {
            // if pclsid -- hide that bar, else -- hide everyone
            ASSERT(NULL == pclsid || _InfoCLSIDToIdm(pclsid) == ((IDBAR_VERTICAL == idBar) ? _idmInfo : _idmComm));

            _GetBrowserBar(idBar, FALSE, NULL, NULL);
            return NULL;
        }
    }

    if (0 == eOnOff || NULL == pclsid)
    {
        // if pclsid -- hide that bar, else -- hide everyone
        ASSERT(NULL == pclsid || _InfoCLSIDToIdm(pclsid) == ((IDBAR_VERTICAL == idBar) ? _idmInfo : _idmComm));

        _GetBrowserBar(idBar, FALSE, NULL, NULL);
        return NULL;
    }

    hr = _GetBandSite(idBar, &pbsSite, pclsid, eOnOff);
    if (SUCCEEDED(hr))
    {
        hr = _EnsureAndNavigateBand(pbsSite, pclsid, pidl);
        ASSERT(pbsSite);  // _GetBandSite() or _GetBrowserBand() flunked with its return code ?
        pbsSite->Release();
    }

    return SUCCEEDED(hr) ? pclsid : NULL;
}

HRESULT CShellBrowser2::_GetBandSite(int idBar, IBandSite** ppbsSite, const CLSID *pclsid, int eOnOff)
{
    *ppbsSite = NULL;

    LPCWSTR pwszItem = (IDBAR_VERTICAL == idBar) ? INFOBAR_TBNAME : COMMBAR_TBNAME;

    //----- Persist current DeskBar (if it exists) -----
    IDeskBar* pdbBar;
    HRESULT hr = FindToolbar(pwszItem, IID_PPV_ARG(IDeskBar, &pdbBar));
    if (S_OK == hr) 
    {
        VARIANT varClsid;

        // if a bar is being shown, tell CBrowserBar which clsid it is
        SA_BSTRGUID strClsid;
        InitFakeBSTR(&strClsid, *pclsid);

        varClsid.vt      = VT_BSTR;
        varClsid.bstrVal = strClsid.wsz;

        IUnknown_Exec(pdbBar, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, eOnOff, &varClsid, NULL);
    }
    ATOMICRELEASE(pdbBar);

    // get bar (create/cache or retrieve from cache)
    return _GetBrowserBar(idBar, TRUE, ppbsSite, pclsid);
}

HRESULT CShellBrowser2::_EnsureAndNavigateBand(IBandSite* pbsSite, const CLSID* pclsid, LPCITEMIDLIST pidl /*= NULL*/)
{
    ASSERT(NULL != pbsSite);
    ASSERT(NULL != pclsid);

    IDeskBand* pdbBand = NULL;
    HRESULT    hr = E_FAIL;

    if (NULL != _pbbd->_pautoWB2)
    {
        // check if this band can be found through automation
        SA_BSTRGUID strClsid;
        InitFakeBSTR(&strClsid, *pclsid);

        VARIANT varProp;
        hr = _pbbd->_pautoWB2->GetProperty(strClsid.wsz, &varProp);
        if (SUCCEEDED(hr))
        {
            if (VT_UNKNOWN == varProp.vt && NULL != varProp.punkVal)
            {
                hr = varProp.punkVal->QueryInterface(IID_PPV_ARG(IDeskBand, &pdbBand));
            }
            else
            {
                hr = E_FAIL;
            }

            VariantClear(&varProp);
        }

        // this property doesn't exist yet, so create a new band
        if (FAILED(hr))
        {                
            pdbBand = _GetInfoBandBS(pbsSite, *pclsid);
            if (pdbBand)
            {
                // add to the property so that it can be found later
                VARIANT var;
                var.vt      = VT_UNKNOWN;
                var.punkVal = pdbBand;

                _pbbd->_pautoWB2->PutProperty(strClsid.wsz, var);
            }
        }
    }

    // automation object is not there, try to succeed anyway
    if (NULL == pdbBand)
    {
        ASSERTMSG(FALSE, "IWebBrowser2 is not available");
        pdbBand = _GetInfoBandBS(pbsSite, *pclsid);
    }

    if (pdbBand)
    {
        IBandNavigate* pbn;

        if (pidl && SUCCEEDED(pdbBand->QueryInterface(IID_PPV_ARG(IBandNavigate, &pbn))))
        {
            pbn->Select(pidl);
            pbn->Release();
        }

        // show me, hide everyone else
        VARIANT var;
        var.vt      = VT_UNKNOWN;
        var.punkVal = pdbBand;

        // Exec -> Select or SetBandState
        IUnknown_Exec(pbsSite, &CGID_DeskBand, DBID_SHOWONLY, OLECMDEXECOPT_PROMPTUSER, &var, NULL);

        pdbBand->Release();
        hr = S_OK;
    }

    return hr;
}

BANDCLASSINFO* CShellBrowser2::_BandClassInfoFromCmdID(UINT idCmd)
{
    if (IsInRange(idCmd, FCIDM_VBBDYNFIRST, FCIDM_VBBDYNLAST))
    {
        if (_pbsmInfo)
        {
            int i, cnt = _pbsmInfo->GetBandClassCount(NULL, FALSE);
            for (i = 0; i < cnt; i++)
            {
                BANDCLASSINFO *pbci = _pbsmInfo->GetBandClassDataStruct(i);
                if (pbci && idCmd == pbci->idCmd)
                    return pbci;
            }
        }
    }

    return NULL;
}

// map menu ID valued (FCIDM_VBB*'s) to corresponding CLSID
// handles both 'fixed' and dynamic guys

const CLSID *CShellBrowser2::_InfoIdmToCLSID(UINT idCmd)
{
    const CLSID *pclsid = NULL;

    if (IsInRange(idCmd, FCIDM_VBBFIXFIRST, FCIDM_VBBFIXLAST))
    {
        switch (idCmd) {
        case FCIDM_VBBSEARCHBAND:       pclsid = &CLSID_SearchBand; break;
        case FCIDM_VBBFAVORITESBAND:    pclsid = &CLSID_FavBand; break;
        case FCIDM_VBBHISTORYBAND:      pclsid = &CLSID_HistBand; break;
        case FCIDM_VBBEXPLORERBAND:     pclsid = &CLSID_ExplorerBand; break;
        case FCIDM_VBBMEDIABAND:        pclsid = &CLSID_MediaBand; break;
        }
    }
    else
    {
        BANDCLASSINFO* pbci = _BandClassInfoFromCmdID(idCmd);
        if (pbci)
            pclsid = &pbci->clsid;
    }

    return pclsid;
}

const CATID *CShellBrowser2::_InfoIdmToCATID(UINT idCmd)
{
    const CATID* pcatid = NULL;

    if (IsInRange(idCmd, FCIDM_VBBFIXFIRST, FCIDM_VBBFIXLAST))
    {
        // The fixed bars are all in the vertical comcat
        pcatid = &CATID_InfoBand;
    }
    else
    {
        // Dynamic bar, have to look up the catid
        BANDCLASSINFO* pbci = _BandClassInfoFromCmdID(idCmd);
        if (pbci)
            pcatid = &pbci->catid;
    }

    return pcatid;
}

UINT CShellBrowser2::_InfoCLSIDToIdm(const CLSID *pguid)
{
    if (pguid == NULL)
        return 0;
    else if (IsEqualIID(*pguid, CLSID_ExplorerBand))
        return FCIDM_VBBEXPLORERBAND;
    else if (IsEqualIID(*pguid, CLSID_SearchBand))
        return FCIDM_VBBSEARCHBAND;
    else if (IsEqualIID(*pguid, CLSID_FileSearchBand))
        return FCIDM_VBBSEARCHBAND;
    else if (IsEqualIID(*pguid, CLSID_FavBand))
        return FCIDM_VBBFAVORITESBAND;
    else if (IsEqualIID(*pguid, CLSID_HistBand)) 
        return FCIDM_VBBHISTORYBAND;
    else if (IsEqualIID(*pguid, CLSID_MediaBand)) 
        return FCIDM_VBBMEDIABAND;
#ifdef UNIX
    else if (IsEqualIID(*pguid, CLSID_MsgBand))
        return FCIDM_VBBMSGBAND;
#endif
    else 
    {
        if (!_pbsmInfo)
        {
            // Load the Browser Bar Menu to load the class ids of all Component Categories dynamic Browser bars
            _AddBrowserBarMenuItems(_GetBrowserBarMenu());

            // Unable to load the clsids from dynamic bars.
            if (!_pbsmInfo)
                return -1;
        }

        BANDCLASSINFO *pbci;
        for (int i = 0; NULL != (pbci = _pbsmInfo->GetBandClassDataStruct(i)); i++)
            if (IsEqualIID(*pguid, pbci->clsid))
                return (pbci->idCmd);

        // FEATURE: look up in _pbsmInfo->LoadFromComCat's HDPA
        // ASSERT(0);
    }
    return -1;
}

HBITMAP CreateColorBitmap(int cx, int cy)
{
    HBITMAP hbm = NULL;

    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        hbm = CreateCompatibleBitmap(hdc, cx, cy);
        ReleaseDC(NULL, hdc);
    }

    return hbm;
}

HRESULT CShellBrowser2::_GetBSForBar(LPCWSTR pwszItem, IBandSite **ppbs)
{
    *ppbs = NULL;
    IDeskBar *pdbBar;
    HRESULT hr = FindToolbar(pwszItem, IID_PPV_ARG(IDeskBar, &pdbBar));
    if (hr == S_OK) 
    {
        IUnknown *punkBS;
        hr = pdbBar->GetClient(&punkBS);
        if (SUCCEEDED(hr)) 
        {
            hr = punkBS->QueryInterface(IID_PPV_ARG(IBandSite, ppbs));
            ASSERT(SUCCEEDED(hr));
            punkBS->Release();
        }
        pdbBar->Release();
    }
    return hr;
}

void CShellBrowser2::_ExecAllBands(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, 
                            VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    IBandSite *pbsBS;

    HRESULT hres = _GetBSForBar(INFOBAR_TBNAME, &pbsBS);
    if (hres == S_OK) 
    {
        DWORD dwBandID;
        for (int i = 0; SUCCEEDED(pbsBS->EnumBands(i, &dwBandID)); i++) 
        {
            IDeskBand *pstb;
            hres = pbsBS->QueryBand(dwBandID, &pstb, NULL, NULL, 0);
            if (SUCCEEDED(hres)) 
            {
                IUnknown_Exec(pstb, pguidCmdGroup, nCmdID, nCmdexecopt, 
                                pvarargIn, pvarargOut);
                pstb->Release();
            }
        }
        pbsBS->Release();
    }
 }

HRESULT CShellBrowser2::_GetBrowserBar(int idBar, BOOL fShow, IBandSite** ppbs, const CLSID* pclsid)
{
    HRESULT hres;
    IUnknown *punkBar;
    IDeskBar *pdbBar = NULL;
    IUnknown *punkBS = NULL;

    if (ppbs) 
        *ppbs = NULL;
    
    if (IDBAR_VERTICAL == idBar)
    {
        hres = FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdbBar));
    }
    else
    {
        ASSERT(IDBAR_HORIZONTAL == idBar);  // No other bars right now.
        hres = FindToolbar(COMMBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdbBar));
    }

    TraceMsg(DM_MISC, "CSB::_GetBrowserBar FindToolbar returned %x", hres);

    BOOL fTurnOffAutoHide = FALSE;
    if (hres == S_OK)
    {
        // already have one
        hres = pdbBar->GetClient((IUnknown**) &punkBS);
        ASSERT(SUCCEEDED(hres));
        punkBar = pdbBar;
        // punkBar->Release() down below        
    }
    else 
    {
        //if there's not a bar, don't bother creating one so it can be hidden
        if (!fShow)
            return S_OK;

        // 1st time, create a new one
        CBrowserBar* pdb = new CBrowserBar();
        if (NULL == pdb)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            // add it
            pdb->QueryInterface(IID_PPV_ARG(IUnknown, &punkBar));

            //if a bar is being shown, tell CBrowserBar which clsid it is
            SA_BSTRGUID strClsid;
            InitFakeBSTR(&strClsid, *pclsid);

            VARIANT varClsid;
            varClsid.vt = VT_BSTR;
            varClsid.bstrVal = strClsid.wsz;
        
            IUnknown_Exec(punkBar, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, fShow, &varClsid, NULL);

            UINT uiWidthOrHeight = pdb->_PersistState(NULL, FALSE);

            //don't let anyone be 0 width
            if (uiWidthOrHeight == 0)
                uiWidthOrHeight = (IDBAR_VERTICAL == idBar) ? INFOBAR_WIDTH : COMMBAR_HEIGHT;

            fTurnOffAutoHide = !(GetSystemMetrics(SM_CXSCREEN) <= 800);

            CBrowserBarPropertyBag* ppb;

            //  FEATURE - this needs to be persisted and restored
            //  when % widths are implemented, should use that
            ppb = new CBrowserBarPropertyBag();
            if (ppb)
            {
                if (IDBAR_VERTICAL == idBar)
                {
                    ppb->SetDataDWORD(PROPDATA_SIDE, ABE_LEFT);     // LEFT
                    ppb->SetDataDWORD(PROPDATA_LEFT, uiWidthOrHeight);
                    ppb->SetDataDWORD(PROPDATA_RIGHT, uiWidthOrHeight);
                }
                else
                {
                    ppb->SetDataDWORD(PROPDATA_SIDE, ABE_BOTTOM);     // BOTTOM
                    ppb->SetDataDWORD(PROPDATA_TOP, uiWidthOrHeight);
                    ppb->SetDataDWORD(PROPDATA_BOTTOM, uiWidthOrHeight);
                }

                ppb->SetDataDWORD(PROPDATA_MODE, WBM_BBOTTOMMOST);

                SHLoadFromPropertyBag(punkBar, ppb);
                ppb->Release();
            }

            hres = AddToolbar(punkBar, (IDBAR_VERTICAL == idBar) ? INFOBAR_TBNAME : COMMBAR_TBNAME, DWFAF_HIDDEN);

            if (SUCCEEDED(hres))
            {
                hres = BrowserBar_Init(pdb, &punkBS, idBar);
            }

            pdb->Release();
        }
    }
    // need to set band info here each time since deskbar/bandsite get reused
    if (fShow && punkBS)
    {
        BANDSITEINFO bsinfo;
        bsinfo.dwMask = BSIM_STYLE;
        bsinfo.dwStyle = BSIS_NOGRIPPER | BSIS_LEFTALIGN;
        
        IBandSite* pSite;
        HRESULT hr = punkBS->QueryInterface(IID_PPV_ARG(IBandSite, &pSite));
        if (SUCCEEDED(hr)) 
        {
            pSite->SetBandSiteInfo(&bsinfo);
            pSite->Release();
        }
    }

    // note: must call _SetTheaterBrowserBar BEFORE ShowToolbar when showing bar
    if (IDBAR_VERTICAL == idBar && fShow)
        _SetTheaterBrowserBar();    
    ShowToolbar(punkBar, fShow);      
    // note: must call _SetTheaterBrowserBar AFTER ShowToolbar when hiding bar
    if (IDBAR_VERTICAL == idBar && !fShow)
        _SetTheaterBrowserBar();

    //tell CBrowserBar about the new bar, must be AFTER it is shown (to get the size right)
    if (SUCCEEDED(hres) && fShow)
    {
        //if a bar is being shown, tell CBrowserBar which clsid it is
        SA_BSTRGUID strClsid;
        InitFakeBSTR(&strClsid, *pclsid);

        VARIANT varClsid;
        varClsid.vt = VT_BSTR;
        varClsid.bstrVal = strClsid.wsz;
    
        IUnknown_Exec(punkBar, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, fShow, &varClsid, NULL);
    }
    else
    {
        IUnknown_Exec(punkBar, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, 0, NULL, NULL);
    }

    // note: must have called ShowToolbar BEFORE setting pin button state
    if (fTurnOffAutoHide)
    {
        VARIANT v = { VT_I4 };
        v.lVal = FALSE;
        IUnknown_Exec(punkBar, &CGID_Theater, THID_SETBROWSERBARAUTOHIDE, 0, &v, &v);
    }

    punkBar->Release();

    //FEATURE: What should we do for CommBar in Theatre Mode?

    if (punkBS)
    {
        HRESULT hr = S_OK;
        if (ppbs)
        {
            hr = punkBS->QueryInterface(IID_PPV_ARG(IBandSite, ppbs));
        }
        punkBS->Release();
        
        return hr;  // there are callers to _GetBrowserBar which need to know if QI for IBandSite succeeded
    }
    
    return E_FAIL;
}


#ifdef DEBUG
//***   DBCheckCLSID -- make sure class tells truth about its CLSID
//
BOOL DBCheckCLSID(IUnknown *punk, const CLSID *pclsid)
{
    CLSID clsid;

    HRESULT hr = IUnknown_GetClassID(punk, &clsid);
    if (SUCCEEDED(hr) && IsEqualGUID(*pclsid, clsid))
        return TRUE;

    TraceMsg(DM_ERROR, "dbcc: CLSID mismatch! &exp=%x &act=%x", pclsid, clsid);
    return FALSE;
}
#endif

IDeskBand * _GetInfoBandBS(IBandSite *pbs, REFCLSID clsid)
{
    IDeskBand *pstb = FindBandByClsidBS(pbs, clsid);
    if (pstb == NULL) 
    {
        TraceMsg(DM_MISC, "_gib: create band");

        if (SUCCEEDED(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDeskBand, &pstb))))
        {
            // hide all bands before adding new band
            VARIANTARG vaIn = { 0 };
            vaIn.vt = VT_UNKNOWN;
            vaIn.punkVal = 0;
            IUnknown_Exec(pbs, &CGID_DeskBand, DBID_SHOWONLY, OLECMDEXECOPT_PROMPTUSER, &vaIn, NULL);

            pbs->AddBand(pstb);
        }
    }

    return pstb;
}

void CShellBrowser2::_OrganizeFavorites()
{
    TCHAR szPath[MAX_PATH];

    if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE))
    {
#ifndef UNIX
        if (GetKeyState(VK_SHIFT) < 0)
        {
            OpenFolderPath(szPath);
        }
        else
#endif
            DoOrganizeFavDlgW(_pbbd->_hwnd, NULL);
    }
}

/*----------------------------------------------------------
Purpose: Handle WM_COMMAND for favorites menu

*/
void CShellBrowser2::_FavoriteOnCommand(HMENU hmenu, UINT idCmd)
{
    switch (idCmd) 
    {
    case FCIDM_ORGANIZEFAVORITES:
        _OrganizeFavorites();
        break;

    case FCIDM_ADDTOFAVORITES:
        Exec(&CGID_Explorer, SBCMDID_ADDTOFAVORITES, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
        // Instrument add to favorites from menu
        UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_ADDTOFAV, UIBL_MENU);        
        break;

    case FCIDM_UPDATESUBSCRIPTIONS:
        UpdateSubscriptions();
        break;
    }
}

HRESULT CShellBrowser2::CreateBrowserPropSheetExt(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    IUnknown *punk;
    HRESULT hr = CoCreateInstance(CLSID_ShellFldSetExt, NULL, CLSCTX_INPROC_SERVER, riid, (void **)&punk);
    if (SUCCEEDED(hr)) 
    {
        IShellExtInit *psxi;
        hr = punk->QueryInterface(IID_PPV_ARG(IShellExtInit, &psxi));
        if (SUCCEEDED(hr)) 
        {
            hr = psxi->Initialize(NULL, NULL, 0);
            if (SUCCEEDED(hr)) 
            {
                IUnknown_SetSite(punk, SAFECAST(this, IShellBrowser*));
                IUnknown_Set((IUnknown **)ppvObj, punk);
                hr = S_OK;            // All happy
            }
            psxi->Release();
        }
        punk->Release();
    }
    return hr;
}

LPITEMIDLIST CShellBrowser2::_GetSubscriptionPidl()
{
    LPITEMIDLIST        pidlSubscribe = NULL;
    IDispatch *         pDispatch = NULL;
    IHTMLDocument2 *    pHTMLDocument = NULL;

    // Search HTML for <LINK REL="Subscription" HREF="{URL}">
    if  (
        SUCCEEDED(_pbbd->_pautoWB2->get_Document(&pDispatch))
        &&
        SUCCEEDED(pDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pHTMLDocument)))
       )
    {
        IHTMLElementCollection * pLinksCollection;

        if (SUCCEEDED(GetDocumentTags(pHTMLDocument, OLESTR("LINK"), &pLinksCollection)))
        {
            long lItemCnt;

            // Step through each of the LINKs in the
            // collection looking for REL="Subscription".
            EVAL(SUCCEEDED(pLinksCollection->get_length(&lItemCnt)));
            for (long lItem = 0; lItem < lItemCnt; lItem++)
            {
                IDispatch *         pDispItem = NULL;
                IHTMLLinkElement *  pLinkElement = NULL;

                VARIANT vEmpty = { 0 };
                VARIANT vIndex; V_VT(&vIndex) = VT_I4; V_I4(&vIndex) = lItem;

                if  (
                    SUCCEEDED(pLinksCollection->item(vIndex, vEmpty, &pDispItem))
                    &&
                    SUCCEEDED(pDispItem->QueryInterface(IID_IHTMLLinkElement,
                                                        (void **)&pLinkElement))
                   )
                {
                    BSTR bstrREL = NULL;
                    BSTR bstrHREF = NULL;

                    // Finally! We have a LINK element, check its REL type.
                    if  (
                        SUCCEEDED(pLinkElement->get_rel(&bstrREL))
                        &&
                        (bstrREL != NULL)
                        &&
                        SUCCEEDED(pLinkElement->get_href(&bstrHREF))
                        &&
                        (bstrHREF != NULL)
                       )
                    {
                        // Check for REL="Subscription"
                        if (StrCmpIW(bstrREL, OLESTR("Subscription")) == 0)
                        {
                            TCHAR szName[MAX_URL_STRING];

                            SHUnicodeToTChar(bstrHREF, szName, ARRAYSIZE(szName));
                            EVAL(SUCCEEDED(IECreateFromPath(szName, &pidlSubscribe)));
                        }
                    }

                    if (bstrHREF != NULL)
                        SysFreeString(bstrHREF);

                    if (bstrREL != NULL)
                        SysFreeString(bstrREL);
                }

                VariantClear(&vIndex);
                VariantClear(&vEmpty);

                SAFERELEASE(pLinkElement);
                SAFERELEASE(pDispItem);

                // If we found a correctl REL type, quit searching.
                if (pidlSubscribe != NULL)
                    break;
            }

            pLinksCollection->Release();
        }
    }

    SAFERELEASE(pHTMLDocument);
    SAFERELEASE(pDispatch);

    return pidlSubscribe;
}

LPITEMIDLIST CShellBrowser2::_TranslateRoot(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlChild = ILFindChild(ILRootedFindIDList(_pbbd->_pidlCur), pidl);

    ASSERT(pidlChild);

    LPITEMIDLIST pidlRoot = ILCloneFirst(_pbbd->_pidlCur);

    if (pidlRoot)
    {
        LPITEMIDLIST pidlRet = ILCombine(pidlRoot, pidlChild);
        ILFree(pidlRoot);
        return pidlRet;
    }

    return NULL;
}

BOOL CShellBrowser2::_ValidTargetPidl(LPCITEMIDLIST pidl, BOOL *pfTranslateRoot)
{
    // validate that this is an allowable target to browse to.
    // check that it is a child of our root.
    if (pfTranslateRoot)
        *pfTranslateRoot = FALSE;
        
    if (ILIsRooted(_pbbd->_pidlCur)) 
    {
        BOOL fRet = ILIsEqualRoot(_pbbd->_pidlCur, pidl);

        if (!fRet && pfTranslateRoot 
        && ILIsParent(ILRootedFindIDList(_pbbd->_pidlCur), pidl, FALSE))
        {
            fRet = TRUE;
            *pfTranslateRoot = TRUE;
        }
                
        return fRet;
    }
    
    return TRUE;
}

IStream* CShellBrowser2::_GetITBarStream(BOOL fWebBrowser, DWORD grfMode)
{
    return GetITBarStream(fWebBrowser ? ITBS_WEB : ITBS_SHELL, grfMode);
}

HRESULT CShellBrowser2::_SaveITbarLayout(void)
{
    HRESULT hres = E_FAIL;

#ifdef NO_MARSHALLING
    if (!_fOnIEThread)
      return S_OK;
#endif

    if (_fUISetByAutomation || _ptheater)
    {
        return S_OK;
    }
    if (_GetITBar())
    {
        IPersistStreamInit  *pITbarPSI;

        //Yes! It's a different type. We may need to save the stream
        if (SUCCEEDED(_GetITBar()->QueryInterface(IID_PPV_ARG(IPersistStreamInit, &pITbarPSI))))
        {
            //Do we need to save the stream?
            if (pITbarPSI->IsDirty() == S_OK)
            {
                BOOL fInternet = (CITE_INTERNET == 
                    GetScode(IUnknown_Exec(pITbarPSI, &CGID_PrivCITCommands, CITIDM_ONINTERNET, CITE_QUERY, NULL, NULL)));
                IStream *pstm = _GetITBarStream(fInternet, STGM_WRITE);
                if (pstm)
                {
                    //Stream exists. Save it there!.
                    hres = pITbarPSI->Save(pstm, TRUE);
                    pstm->Release();
                }
                else
                {
                    //Stream creation failed! Why?
                    TraceMsg(DM_ITBAR, "CSB::_SaveITbarLayout ITBar Stream creation failed");
                    ASSERT(0);
                }
            }
            else
                hres = S_OK; // No need to save. Return success!

            pITbarPSI->Release();
        }
        else
        {
            //ITBar doesn't support IPersistStreamInit?
            AssertMsg(0, TEXT("CSB::_NavigateToPidl ITBar doesn't support IPersistStreamInit"));
        }
    }

    return hres;
}

// Returns TRUE if we are supposed to fail the navigate, FALSE otherwise
BOOL MaybeRunICW(LPCITEMIDLIST pidl, IShellBrowser *psb, HWND hwndUI)
{
    TCHAR szURL[MAX_URL_STRING];

    EVAL(SUCCEEDED(IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szURL, SIZECHARS(szURL), NULL)));
    if (UrlHitsNetW(szURL) && !UrlIsInstalledEntry(szURL)) 
    {
        if ((CheckRunICW(szURL)) || CheckSoftwareUpdateUI(hwndUI, psb)) // see if ICW needs to run
            return TRUE;
    }

    return FALSE;
}

HRESULT CShellBrowser2::_NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags)
{
    if (pidl) 
    {
        ASSERT(_ValidTargetPidl(pidl, NULL)); 

        if (!g_fICWCheckComplete && IsBrowserFrameOptionsPidlSet(pidl, BFO_USE_DIALUP_REF))
        {
            if (MaybeRunICW(pidl, SAFECAST(this, IShellBrowser *), _pbbd->_hwnd))
            {
                // ICW ran and this was first navigate, shut down now.
                // Or the user wants a software update, so we're launching a new browser
                // to the update page
                _pbbd->_pautoWB2->put_Visible(FALSE);
                _pbbd->_pautoWB2->Quit();
                return E_FAIL;
            }                 
        }

        if (!_fVisitedNet && IsBrowserFrameOptionsPidlSet(pidl, BFO_USE_DIALUP_REF))
            _IncrNetSessionCount();
    }

    // See if we are about to navigate to a pidl of a different type. If so, 
    // open the stream and call the ITBar's IPersistStreamInit::save to save.
    // If we don't have a _pidlCur, then we're opening for the first time, so don't need to save
    if (_pbbd->_pidlCur && _GetITBar())
    {
        //Check if we are about to navigate to a different "type" of folder
        if (((INT_PTR)_pbbd->_pidlCur && !IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_BROWSER_PERSIST_SETTINGS)) != 
           ((INT_PTR)pidl && !IsBrowserFrameOptionsPidlSet(pidl, BFO_BROWSER_PERSIST_SETTINGS)))
        {
            _SaveITbarLayout();
        }
    }
    
    return SUPERCLASS::_NavigateToPidl(pidl, grfHLNF, dwFlags);
}

HRESULT CShellBrowser2::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    HRESULT hr;
    LPITEMIDLIST pidlFree = NULL;

    // if we're about to go to a new browser, save the layout so that they'll pick it up
    if (wFlags & SBSP_NEWBROWSER) 
        _SaveITbarLayout();

    // 99/03/30 vtan: part of #254171 addition
    // explore with explorer band     visible = same window
    // explore with explorer band NOT visible =  new window
    if (wFlags & SBSP_EXPLOREMODE)
    {
        BOOL fExplorerBandVisible;
        if (SUCCEEDED(IsControlWindowShown(FCW_TREE, &fExplorerBandVisible)) && fExplorerBandVisible)
        {
            wFlags &= ~SBSP_NEWBROWSER;
            wFlags |= SBSP_SAMEBROWSER;
        }
        else
        {
            wFlags &= ~SBSP_SAMEBROWSER;
            wFlags |= SBSP_NEWBROWSER;
        }
    }
    
    // if the caller did not specify explictly "new window" or "same window"
    // we compute that here for them. note, CBaseBrowser assumes SBSP_SAMEBROWSER
    // if SBSP_NEWBROWSER is not specified

    if ((wFlags & (SBSP_NEWBROWSER | SBSP_SAMEBROWSER)) == 0)
    {
        CABINETSTATE cs;
        GetCabState(&cs);
        if (GetAsyncKeyState(VK_CONTROL) < 0)
            cs.fNewWindowMode = !cs.fNewWindowMode;
        if (cs.fNewWindowMode)
            wFlags |= SBSP_NEWBROWSER | SBSP_NOTRANSFERHIST;
    }

    BOOL fTranslate = FALSE;

    // REVIEW: do this only if NEWBROWSER is not set?
    if (pidl && pidl != (LPCITEMIDLIST)-1 && !_ValidTargetPidl(pidl, &fTranslate))
    {
        OpenFolderPidl(pidl);   // we can't navigate to it...  create a new top level dude
        return E_FAIL;
    }

    if (fTranslate)
    {
        pidl = pidlFree = _TranslateRoot(pidl);
    }

    if ((wFlags & SBSP_PARENT) && !_ShouldAllowNavigateParent())
    {
        hr =  E_FAIL;
        goto exit;
    }

#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
    // If we want to be strict about BrowseNewProcess (apparently not,
    // given recent email discussions), we'd have to try this one in
    // a new process.  However, don't do that if the window would wind up
    // completely blank.
    //
    if ((_pbbd->_pidlCur || _pbbd->_pidlPending) && TryNewProcessIfNeeded(pidl))
    {
        hr = S_OK;
        goto exit;
    }
#endif

    hr = SUPERCLASS::BrowseObject(pidl, wFlags);

exit:
    ILFree(pidlFree);
    return hr;
}


void CShellBrowser2::_ToolTipFromCmd(LPTOOLTIPTEXT pnm)
{
    UINT idCommand = (UINT)pnm->hdr.idFrom;
    LPTSTR pszText = pnm->szText;
    int cchText = ARRAYSIZE(pnm->szText);
    DWORD dwStyle;

    ITravelLog *ptl;

    if (pnm->hdr.hwndFrom)
        dwStyle = GetWindowLong(pnm->hdr.hwndFrom, GWL_STYLE);

    switch (idCommand) {
    case FCIDM_NAVIGATEBACK:
    case FCIDM_NAVIGATEFORWARD:
        if (SUCCEEDED(GetTravelLog(&ptl)))
        {
            WCHAR wzText[MAX_PATH];

            ASSERT(ptl);
            if (S_OK == ptl->GetToolTipText(SAFECAST(this, IShellBrowser *), idCommand == FCIDM_NAVIGATEBACK ? TLOG_BACK : TLOG_FORE, 0, wzText, ARRAYSIZE(wzText)))
            {
                SHUnicodeToTChar(wzText, pszText, cchText);
                if (pnm->hdr.hwndFrom)
                    SetWindowLong(pnm->hdr.hwndFrom, GWL_STYLE, dwStyle | TTS_NOPREFIX);
            }
            ptl->Release();
            return;
        }
        break;
    }

    if (pnm->hdr.hwndFrom)
        SetWindowLong(pnm->hdr.hwndFrom, GWL_STYLE, dwStyle & ~(TTS_NOPREFIX));
    if (!MLLoadString(idCommand + MH_TTBASE, pszText, cchText))
        *pszText = 0;
}

void CShellBrowser2::v_ParentFolder()
{
    if (_ShouldAllowNavigateParent()) 
    {
        IETHREADPARAM* piei = SHCreateIETHREADPARAM(NULL, 0, NULL, NULL);
        if (piei) 
        {
            piei->hwndCaller = _pbbd->_hwnd;
            piei->pidl = ILClone(_pbbd->_pidlCur);
            if (!ILRemoveHiddenID(piei->pidl, IDLHID_NAVIGATEMARKER))
            {
                ILRemoveLastID(piei->pidl);
            }
            piei->uFlags = COF_NORMAL;
            piei->nCmdShow = SW_SHOW;
            piei->psbCaller = this;
            AddRef();
            SHOpenFolderWindow(piei);
        }
    }
}

LRESULT CShellBrowser2::v_ForwardMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return ForwardViewMsg(uMsg, wParam, lParam);
}

HRESULT CShellBrowser2::_GetCodePage(UINT *puiCodePage, DWORD dwCharSet)
{
    HRESULT hres = E_FAIL;
    VARIANT varIn = { 0 };
    VARIANT varResult = { 0 };
    VARIANT *pvarIn;
    
    if (_pbbd->_pctView)
    {
        if (dwCharSet == SHDVID_DOCFAMILYCHARSET)
        {
            // need varIn
            varIn.vt = VT_I4;
            // varIn.lVal is already inited to zero which is what we want
            pvarIn = &varIn;
        }
        else
        {
            pvarIn = NULL;
        }

        _pbbd->_pctView->Exec(&CGID_ShellDocView, dwCharSet, 0, pvarIn, &varResult);
        *puiCodePage = (UINT)varResult.lVal;
    }
    
    return hres;
}


#if defined(UNIX)
HRESULT _UnixSendDocToOE(LPCITEMIDLIST, UINT, DWORD);
#endif

void CShellBrowser2::_SendCurrentPage(DWORD dwSendAs)
{
    if (_pbbd->_pidlCur && !ILIsEmpty(_pbbd->_pidlCur))
    {
        UINT uiCodePage;
        _GetCodePage(&uiCodePage, SHDVID_DOCCHARSET);
#ifdef UNIX
        if (OEHandlesMail())
            _UnixSendDocToOE(_pbbd->_pidlCur, uiCodePage, dwSendAs);
        else
#endif
        {
           IOleCommandTarget *pcmdt = NULL;
           if (_pbbd->_pautoWB2)
           {
               (_pbbd->_pautoWB2)->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
               ASSERT(pcmdt);
           }
           SendDocToMailRecipient(_pbbd->_pidlCur, uiCodePage, dwSendAs, pcmdt);
           if (pcmdt)
               pcmdt->Release();
        }
    }
}


typedef void (* PFNSHOWJAVACONSOLE)(void);

// We need a LoadLibrary/GetProcAddress stub here since msjava.lib improperly
// exports ShowJavaConsole as undecorated (ShowJavaConsole vs. _ShowJavaConsole@0).
STDAPI_(void) DL_ShowJavaConsole()
{
    static PFNSHOWJAVACONSOLE s_pfn = (PFNSHOWJAVACONSOLE)-1;

    if (s_pfn == (PFNSHOWJAVACONSOLE)-1)
    {
        HMODULE hmodMSJAVA = LoadLibraryA("MSJAVA.DLL");
        if (hmodMSJAVA)
        {
            s_pfn = (PFNSHOWJAVACONSOLE)GetProcAddress(hmodMSJAVA, "ShowJavaConsole");
        }
        else
        {
            s_pfn = NULL;
        }
    }

    if (s_pfn)
    {
        s_pfn();
    }
}


LRESULT CShellBrowser2::OnCommand(WPARAM wParam, LPARAM lParam)
{
    int id;
    DWORD dwError;

    if (_ShouldForwardMenu(WM_COMMAND, wParam, lParam)) {
        ForwardViewMsg(WM_COMMAND, wParam, lParam);
        return S_OK;
    }
    
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    
    switch(idCmd)
    {
    case FCIDM_MOVE:
    case FCIDM_COPY:
    case FCIDM_PASTE:
    case FCIDM_SELECTALL:
        {
            IOleCommandTarget* pcmdt;
            HRESULT hres = _FindActiveTarget(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
            if (SUCCEEDED(hres)) {
                const static UINT c_mapEdit[] = {
                    OLECMDID_CUT, OLECMDID_COPY, OLECMDID_PASTE, OLECMDID_SELECTALL };
    
                pcmdt->Exec(NULL, c_mapEdit[idCmd-FCIDM_MOVE], OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
                pcmdt->Release();
            }
        }
        return S_OK;

    case FCIDM_DELETE:
    case FCIDM_PROPERTIES:
    case FCIDM_RENAME:
        if (_HasToolbarFocus())
        {
            static const int tbtab[] = {
                FCIDM_DELETE,       FCIDM_PROPERTIES,       FCIDM_RENAME    };
            static const int cttab[] = {
                SBCMDID_FILEDELETE, SBCMDID_FILEPROPERTIES, SBCMDID_FILERENAME };

            DWORD nCmdID = SHSearchMapInt(tbtab, cttab, ARRAYSIZE(tbtab), idCmd);

            IDockingWindow* ptbar = _GetToolbarItem(_itbLastFocus)->ptbar;
            if (SUCCEEDED(IUnknown_Exec(ptbar, &CGID_Explorer, nCmdID, 0, NULL, NULL)))
                return S_OK;
        }

        SUPERCLASS::OnCommand(wParam, lParam);
        break;

    case FCIDM_VIEWAUTOHIDE:
        IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_VIEWAUTOHIDE, 0, NULL, NULL);
        break;

    case FCIDM_VIEWTOOLBARCUSTOMIZE:
        IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_VIEWTOOLBARCUSTOMIZE, 0, NULL, NULL);
        break;
        
    case FCIDM_VIEWLOCKTOOLBAR:
        IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_VIEWLOCKTOOLBAR, 0, NULL, NULL);
        break;

    case FCIDM_VIEWTEXTLABELS:
        if (!SHIsRestricted2W(_pbbd->_hwnd, REST_NoToolbarOptions, NULL, 0))
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_TEXTLABELS, 0, NULL, NULL);
        break;
        
    case FCIDM_EDITPAGE:
        IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_EDITPAGE, 0, NULL, NULL);
        break;

    case FCIDM_FINDFILES:
        // Call Exec on ourselfes -- it's handled there
        if (!SHIsRestricted2W(_pbbd->_hwnd, REST_NoFindFiles, NULL, 0))
        {
            IDockingWindow* ptbar = _GetToolbarItem(ITB_ITBAR)->ptbar;
            VARIANT  var = {0};
            VARIANT *pvar = NULL;

            if (ptbar)
            {
                pvar = &var;
                var.vt = VT_UNKNOWN;
                var.punkVal = ptbar;
                ptbar->AddRef();
            }
            Exec(NULL, OLECMDID_FIND, OLECMDEXECOPT_PROMPTUSER, pvar, NULL);
            if (ptbar)
                ptbar->Release();
        }
        break;

    case FCIDM_CONNECT:
        DoNetConnect(_pbbd->_hwnd);
        break;

    case FCIDM_DISCONNECT:
        DoNetDisconnect(_pbbd->_hwnd);
        break;

    case FCIDM_FORTEZZA_LOGIN:
        dwError = InternetFortezzaCommand(FORTCMD_LOGON, _pbbd->_hwnd, 0);
        break;

    case FCIDM_FORTEZZA_LOGOUT:
        dwError = InternetFortezzaCommand(FORTCMD_LOGOFF, _pbbd->_hwnd, 0);
        break;

    case FCIDM_FORTEZZA_CHANGE:
        dwError = InternetFortezzaCommand(FORTCMD_CHG_PERSONALITY, _pbbd->_hwnd, 0);
        break;

    case FCIDM_BACKSPACE:
        // NT #216896: We want to use FCIDM_PREVIOUSFOLDER even for URL PIDLs if they
        //             have the folder attribute set because they could be using delegate
        //             pidls thru DefView. (FTP & Web Folders) -BryanSt
        if (_pbbd->_pidlCur && IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_NO_PARENT_FOLDER_SUPPORT))
        {
            ITravelLog *ptl;
            if (SUCCEEDED(GetTravelLog(&ptl)))
            {
                ASSERT(ptl);
                if (S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_FORE, NULL))
                {
                    OnCommand(GET_WM_COMMAND_MPS(FCIDM_NAVIGATEBACK,
                                                  GET_WM_COMMAND_HWND(wParam, lParam),
                                                  GET_WM_COMMAND_CMD(wParam, lParam)));
                }
                ptl->Release();
            }
        } else {
            OnCommand(GET_WM_COMMAND_MPS(FCIDM_PREVIOUSFOLDER,
                                          GET_WM_COMMAND_HWND(wParam, lParam),
                                          GET_WM_COMMAND_CMD(wParam, lParam)));
        }
        break;
        
    case FCIDM_PREVIOUSFOLDER:
        // missnamed...  is really parent folder
        v_ParentFolder();
        break;

    case FCIDM_FILECLOSE:
        PostMessage(_pbbd->_hwnd, WM_CLOSE, 0, 0);
        break;

    case FCIDM_FTPOPTIONS:
        {
            VARIANT varArgs = {0};

            varArgs.vt = VT_I4;
            varArgs.lVal = SBO_NOBROWSERPAGES;
            Exec(&CGID_Explorer, SBCMDID_OPTIONS, 0, &varArgs, NULL);
        }
        break;

    case FCIDM_BROWSEROPTIONS:
        if (!IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_RENAME_FOLDER_OPTIONS_TOINTERNET) ||
            !SHIsRestricted2W(_pbbd->_hwnd, REST_NoBrowserOptions, NULL, 0))
            Exec(&CGID_Explorer, SBCMDID_OPTIONS, 0, NULL, NULL);
        break;

    case FCIDM_RESETWEBSETTINGS:
        ResetWebSettings(_pbbd->_hwnd, NULL);
        break;

    case FCIDM_MAIL:
#ifdef UNIX
        if (!OEHandlesMail())
        {
             SendDocToMailRecipient(NULL, 0, MAIL_ACTION_READ, NULL);
        }
        else
#endif
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, MAIL_DEF_KEY);
        break;

    case FCIDM_MYCOMPUTER:
        {
            LPITEMIDLIST pidlMyComputer;

            SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer);
            if (pidlMyComputer)
            {
                BrowseObject(pidlMyComputer, SBSP_SAMEBROWSER);
                ILFree(pidlMyComputer);
            }
        }
        break;

    case FCIDM_CONTACTS:    
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, CONTACTS_DEF_KEY);
        break;

    case FCIDM_NEWS:
#ifdef UNIX
        if (!CheckAndExecNewsScript(_pbbd->_hwnd))
#endif
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, NEWS_DEF_KEY);
        break;

    case FCIDM_CALENDAR:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, CALENDAR_DEF_KEY);
        break;
    
    case FCIDM_TASKS:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, TASKS_DEF_KEY);
        break;
    
    case FCIDM_JOURNAL:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, JOURNAL_DEF_KEY);
        break;
    
    case FCIDM_NOTES:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, NOTES_DEF_KEY);
        break;
    
    case FCIDM_CALL:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, CALL_DEF_KEY);
        break;

    case FCIDM_NEWMESSAGE:
#ifdef UNIX
        if (OEHandlesMail())
        {
            // PORT QSY should be SendDocToMailRecipient()
            // But the function is now used to invoke native unix
            // mailers such as emacs script
            _UnixSendDocToOE(NULL, 0,  MAIL_ACTION_SEND);
        }
        else
        {
            SendDocToMailRecipient(NULL, 0, MAIL_ACTION_SEND, NULL);
        }
#else
        DropOnMailRecipient(NULL, 0);
#endif
        break;

    case FCIDM_SENDLINK:
    case FCIDM_SENDDOCUMENT:
        _SendCurrentPage(idCmd == FCIDM_SENDDOCUMENT ? FORCE_COPY : FORCE_LINK);
        break;

    case FCIDM_STARTPAGE:
    case FCIDM_UPDATEPAGE:
    case FCIDM_CHANNELGUIDE:
        {
            LPITEMIDLIST pidl = NULL;

#ifdef UNIX
            if (idCmd == FCIDM_STARTPAGE && lParam != 0)
            {
                pidl = (LPITEMIDLIST)lParam;
                BrowseObject(pidl, SBSP_SAMEBROWSER);
                ILFree(pidl);
                break;
            }
#endif

            ASSERT(IDP_START == 0);
            ASSERT(FCIDM_STARTPAGE+IDP_START == FCIDM_STARTPAGE);
            ASSERT(FCIDM_STARTPAGE+IDP_UPDATE == FCIDM_UPDATEPAGE);
            ASSERT(FCIDM_STARTPAGE+IDP_CHANNELGUIDE == FCIDM_CHANNELGUIDE);

            HRESULT hres = SHDGetPageLocation(_pbbd->_hwnd, idCmd-FCIDM_STARTPAGE, NULL, 0, &pidl);
            if (SUCCEEDED(hres)) {
                hres = BrowseObject(pidl, SBSP_SAMEBROWSER);
                ILFree(pidl);
            }
        }
        break;

    case FCIDM_SEARCHPAGE:
        {
            // This command from the Windows Explorer's Go menu used to be handled by navigating to 
            // a search page on MSN.  We now maintain consistency with the shell's handling of
            // Start->Find->On the Internet, by invoking the extension directly.

            ASSERT(FCIDM_STARTPAGE+IDP_SEARCH == FCIDM_SEARCHPAGE);

            IContextMenu *pcm; 

            HRESULT hres = CoCreateInstance(CLSID_WebSearchExt, NULL, 
                CLSCTX_INPROC_SERVER, IID_IContextMenu, (void **) &pcm);
                    
            if (SUCCEEDED(hres))
            {
                CMINVOKECOMMANDINFO ici = {0};            
                ici.cbSize = sizeof(ici);
                ici.nShow  = SW_NORMAL;
                pcm->InvokeCommand(&ici);
                pcm->Release();
            }
        }
        break;


    case FCIDM_HELPABOUT:
#ifdef UNIX
        IEAboutBox(_pbbd->_hwnd);
        break;
#else
    {
        TCHAR szWindows[64];
        MLLoadString(IDS_WINDOWSNT, szWindows, ARRAYSIZE(szWindows));
        ShellAbout(_pbbd->_hwnd, szWindows, NULL, NULL);
        break;
    }
#endif

    case FCIDM_HELPTIPOFTHEDAY:
        _SetBrowserBarState(-1, &CLSID_TipOfTheDay, -1);
        break;

    case FCIDM_HELPISLEGAL:
    {
        TCHAR szFWLinkPathTemplate[MAX_PATH];
        TCHAR szFWLinkPath[MAX_PATH];
        LPITEMIDLIST pidl;

        LoadString(HINST_THISDLL, IDS_FWLINK_HELPISLEGAL, szFWLinkPathTemplate, ARRAYSIZE(szFWLinkPathTemplate));

        if (SUCCEEDED(URLSubstitution(szFWLinkPathTemplate, szFWLinkPath, ARRAYSIZE(szFWLinkPath), URLSUB_CLCID)))
        {
            if (SUCCEEDED(IEParseDisplayName(CP_ACP, szFWLinkPath, &pidl)))
            {
                BrowseObject(pidl, SBSP_SAMEBROWSER);
                ILFree(pidl);
            }
        }
        break;
    }


    case FCIDM_NAVIGATEBACK:
        if (_pbbd->_psvPending)
        {
            _CancelPendingView();
        }
        else 
        {
            if (g_dwStopWatchMode & (SPMODE_BROWSER | SPMODE_JAVA))
            {
                DWORD dwTime = GetPerfTime();

                if (g_dwStopWatchMode & SPMODE_BROWSER)  // Used to get browser total download time
                    StopWatch_StartTimed(SWID_BROWSER_FRAME, TEXT("Browser Frame Back"), SPMODE_BROWSER | SPMODE_DEBUGOUT, dwTime);
                if (g_dwStopWatchMode & SPMODE_JAVA)  // Used to get java applet load time
                    StopWatch_StartTimed(SWID_JAVA_APP, TEXT("Java Applet Back"), SPMODE_JAVA | SPMODE_DEBUGOUT, dwTime);
            }
            NavigateToPidl(NULL, HLNF_NAVIGATINGBACK);
        }
        break;

    case FCIDM_NAVIGATEFORWARD:
        NavigateToPidl(NULL, HLNF_NAVIGATINGFORWARD);
        break;

    case FCIDM_ADDTOFAVNOUI:
        Exec(&CGID_Explorer, SBCMDID_ADDTOFAVORITES, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
        // Instrument this, add to favorites called by keyboard 
        UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_ADDTOFAV, UIBL_KEYBOARD);
        break;

    // Some tools relied on the old Command ID...
    case FCIDM_W95REFRESH:
        idCmd = FCIDM_REFRESH;
        // Fall through...
    case FCIDM_REFRESH:
        if (TRUE == _fInRefresh)
        {
            // We are already doing a refresh.  If we keep doing refreshes,
            // then we can enter into infinite recursion.  If the refresh
            // cause a dialog to be displayed and refresh messages keep coming
            // in, then the messagebox call will be called over and over.
            // Besides multiple dialog boxes, this grows the stack until
            // we run out of space and crash.
            break;
        }

        _fInRefresh = TRUE;

    // fall thru...
    case FCIDM_STOP:
    {
        SHELLSTATE ss = {0};
        SHGetSetSettings(&ss, SSF_MAPNETDRVBUTTON, FALSE);
        if ((!_fShowNetworkButtons && ss.fMapNetDrvBtn) ||
            (_fShowNetworkButtons && !ss.fMapNetDrvBtn))
        {
            UINT uiBtnState = 0;
            _fShowNetworkButtons = ss.fMapNetDrvBtn;
            _pxtb->GetState(&CLSID_CommonButtons, TBIDM_CONNECT, &uiBtnState);
            if (ss.fMapNetDrvBtn)
                uiBtnState &= ~TBSTATE_HIDDEN;
            else    
                uiBtnState |= TBSTATE_HIDDEN;
            _pxtb->SetState(&CLSID_CommonButtons, TBIDM_CONNECT, uiBtnState);
            _pxtb->SetState(&CLSID_CommonButtons, TBIDM_DISCONNECT, uiBtnState);
        }

        if (idCmd == FCIDM_REFRESH)
        {
            VARIANT v = {0};
            v.vt = VT_I4;
            v.lVal = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_PROMPTIFOFFLINE;
            Exec(NULL, OLECMDID_REFRESH, OLECMDEXECOPT_DONTPROMPTUSER, &v, NULL);

            // Refresh the toolbar
            if (_pxtb)
            {
                IServiceProvider* psp;
                if (SUCCEEDED(_pxtb->QueryInterface(IID_PPV_ARG(IServiceProvider, &psp))))
                {
                    IAddressBand *pab = NULL;
                    if (SUCCEEDED(psp->QueryService(IID_IAddressBand, IID_IAddressBand, (void**)&pab)))
                    {
                        VARIANTARG varType = {0};
                        varType.vt = VT_I4;
                        varType.lVal = OLECMD_REFRESH_TOPMOST;
                        pab->Refresh(&varType);
                        pab->Release();
                    }
                    psp->Release();
                }
            }
        }
        else
        {
            if (g_dwStopWatchMode & SPMODE_BROWSER)
                StopWatch_Lap(SWID_BROWSER_FRAME | SWID_MASK_BROWSER_STOPBTN, TEXT("Browser Frame Esc"), SPMODE_BROWSER | SPMODE_DEBUGOUT);

            Exec(NULL, OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
        }

        if (FCIDM_REFRESH == idCmd)
        {
            _fInRefresh = FALSE;
        }
        break;
    }
    

#ifndef DISABLE_FULLSCREEN

    case FCIDM_THEATER:
        if (!SHRestricted2(REST_NoTheaterMode, NULL, 0))
        {
            // Toggle theater mode.  Don't allow theater mode if we're in kiosk mode.
            if (_ptheater || _fKioskMode) {
                _TheaterMode(FALSE, TRUE);
            } else {
                _TheaterMode(TRUE, FALSE);
            }
        }
        break;

#endif

    case FCIDM_NEXTCTL:
        _CycleFocus(NULL);
        break;

    case FCIDM_VIEWOFFLINE:
        if ((!SHIsGlobalOffline()) && (IsCriticalOperationPending()))
        {
            if (MLShellMessageBox(_pbbd->_hwnd,
                    MAKEINTRESOURCE(IDS_CANCELFILEDOWNLOAD),
                    MAKEINTRESOURCE(IDS_FILEDOWNLOADCAPTION),
                    MB_YESNO | MB_ICONSTOP) == IDNO)
                break;
        }
    
        Offline(SBSC_TOGGLE);
        if (_pbbd->_pszTitleCur)
            _SetTitle(_pbbd->_pszTitleCur);
            
        break;


#ifdef TEST_AMBIENTS
    case FCIDM_VIEWLOCALOFFLINE:
        _LocalOffline(SBSC_TOGGLE);
        break;

    case FCIDM_VIEWLOCALSILENT:
        _LocalSilent(SBSC_TOGGLE);
        break;
#endif // TEST_AMBIENTS


    case FCIDM_VIEWTOOLBAR:
        v_ShowControl(FCW_INTERNETBAR, SBSC_TOGGLE);
        break;

    case FCIDM_VIEWMENU:
        id = CITIDM_VIEWMENU;
        goto ITBarShowBand;

    case FCIDM_VIEWTOOLS:
        id = CITIDM_VIEWTOOLS;
        goto ITBarShowBand;
        
    case FCIDM_VIEWADDRESS:
        id = CITIDM_VIEWADDRESS;
        goto ITBarShowBand;
        
    case FCIDM_VIEWLINKS:
        id = CITIDM_VIEWLINKS;
        goto ITBarShowBand;
            
ITBarShowBand:
        if (!SHIsRestricted2W(_pbbd->_hwnd, REST_NoToolbarOptions, NULL, 0))
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, id, 0, NULL, NULL);
        break;
                
    case FCIDM_VIEWSTATUSBAR:    
        v_ShowControl(FCW_STATUS, SBSC_TOGGLE);                    
        break;
        
    case FCIDM_VBBSEARCHBAND:
        {
            IDockingWindow* ptbar = _GetToolbarItem(ITB_ITBAR)->ptbar;
            VARIANT  var = {0};

            var.vt = VT_I4;
            var.lVal = -1;
            IUnknown_Exec(ptbar, &CLSID_CommonButtons, TBIDM_SEARCH, 0, NULL, &var);
        }
        break;

    case FCIDM_VIEW_PRIVACY_POLICIES:
        {
            if ( _pbbd != NULL && _pbbd->_pctView != NULL)
            {
                HRESULT hr = _pbbd->_pctView->Exec(&CGID_ShellDocView, 
                    SHDVID_PRIVACYSTATUS, TRUE, NULL, NULL);
            }
        }
        break;
    
    case FCIDM_VBBEXPLORERBAND:
    case FCIDM_VBBFAVORITESBAND:
    case FCIDM_VBBHISTORYBAND:
    case FCIDM_VBBMEDIABAND:
        if (g_dwStopWatchMode)
        {
            StopWatch_Start(SWID_EXPLBAR, TEXT("Shell bar Start"), SPMODE_SHELL | SPMODE_DEBUGOUT);
        }

        switch (idCmd)
        {
        case FCIDM_VBBFAVORITESBAND:
            if (SHIsRestricted2W(_pbbd->_hwnd, REST_NoFavorites, NULL, 0))
                break;

        default:
            _SetBrowserBarState(idCmd, NULL, -1);
            break;
        }
        
        if (g_dwStopWatchMode)
        {
            TCHAR szText[100];
            TCHAR szMenu[32];
            DWORD dwTime = GetPerfTime();
            GetMenuString(_GetMenuFromID(FCIDM_MENU_VIEW), idCmd, szMenu, ARRAYSIZE(szMenu) - 1, MF_BYCOMMAND);
            wnsprintf(szText, ARRAYSIZE(szText) - 1, TEXT("Shell %s bar Stop"), szMenu);
            StopWatch_StopTimed(SWID_EXPLBAR, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT, dwTime);
        }
        break;

    case FCIDM_JAVACONSOLE:
        DL_ShowJavaConsole();
        break;

    case FCIDM_SHOWSCRIPTERRDLG:
        {
            HRESULT hr;

            hr = Exec(&CGID_ShellDocView,
                      SHDVID_DISPLAYSCRIPTERRORS,
                      0,
                      NULL,
                      NULL);

            return hr;
        }
        break;

    default:
        if (IsInRange(idCmd, FCIDM_FAVORITECMDFIRST, FCIDM_FAVORITECMDLAST) 
            && !SHIsRestricted2W(_pbbd->_hwnd, REST_NoFavorites, NULL, 0)) {
            _FavoriteOnCommand(NULL, idCmd);
        } else if (IsInRange(idCmd, FCIDM_RECENTFIRST, FCIDM_RECENTLAST)) {
            ITravelLog *ptl;
            GetTravelLog(&ptl);
            if (ptl)
            {
                ptl->Travel(SAFECAST(this, IShellBrowser *), idCmd - (FCIDM_RECENTFIRST + GOMENU_RECENT_ITEMS) + GOMENU_RECENT_ITEMS / 2);
                ptl->Release();
                UpdateBackForwardState();
            }
        } else if (IsInRange(idCmd, FCIDM_SEARCHFIRST, FCIDM_SEARCHLAST)) {
            if (_pcmSearch)
            {
                CMINVOKECOMMANDINFO ici = {0};
            
                ici.cbSize = sizeof(ici);
                //ici.hwnd = NULL; // no need for hwnd for search cm InvokeCommand
                ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - FCIDM_SEARCHFIRST);
                ici.nShow  = SW_NORMAL;
                _pcmSearch->InvokeCommand(&ici);
            }
            else
            {
                TraceMsg(DM_TRACE, "CSB::OnCommand() - find cmd with NULL pcmFind");
            }
        } else if (IsInRange(idCmd, FCIDM_MENU_TOOLS_FINDFIRST, FCIDM_MENU_TOOLS_FINDLAST)) {
            if (GetUIVersion() < 5 && _pcmFind)
            {
                LPITEMIDLIST pidl = (_pbbd->_pidlPending) ? _pbbd->_pidlPending : _pbbd->_pidlCur;
                TCHAR szPath[MAX_PATH];

                SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, SIZECHARS(szPath), NULL);

                // Handle cases like "desktop" (make it default to My Computer)
                if (!PathIsDirectory(szPath))
                {
                    szPath[0] = TEXT('\0');
                }

                CMINVOKECOMMANDINFO ici = {0};
            
                ici.cbSize = sizeof(ici);
                //ici.hwnd = NULL; // no need for hwnd for search cm InvokeCommand
                ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - FCIDM_MENU_TOOLS_FINDFIRST);
                ici.nShow  = SW_NORMAL;

                // Set the root of the search
                char szAnsiPath[MAX_PATH];
                szAnsiPath[0] = '\0';
                SHTCharToAnsi(szPath, szAnsiPath, ARRAYSIZE(szAnsiPath));                
                ici.lpDirectory = szAnsiPath;

                _pcmFind->InvokeCommand(&ici);
            }
        } else if (IsInRange(idCmd, FCIDM_VBBDYNFIRST, FCIDM_VBBDYNLAST)) {
            _SetBrowserBarState(idCmd, NULL, -1);
        } else if (IsInRange(idCmd, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST)) {
            _ExecFileContext(idCmd);
        } else if (IsInRange(idCmd, FCIDM_EXTERNALBANDS_FIRST, FCIDM_EXTERNALBANDS_LAST)) {
            id = idCmd - FCIDM_EXTERNALBANDS_FIRST + CITIDM_VIEWEXTERNALBAND_FIRST;
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, id, 0, NULL, NULL);
        } else {
            SUPERCLASS::OnCommand(wParam, lParam);
        }
        break;
    }
    return S_OK;
}

HMENU CShellBrowser2::_GetMenuFromID(UINT uID)
{
    return SHGetMenuFromID(_hmenuCur, uID);
}


void CShellBrowser2::_PruneMailNewsItems(HMENU hmenu)
{
    //
    // REARCHITECT: this logic is duplicated in _OnFileMenuPopup,
    // _OnMailMenuPopup, CDocObjectHost::_OnInitMenuPopup
    //

    // Iterate through the mail, news, contacts, etc. menu items,
    // and for each item, remove the item if either
    //
    // (a) REST_GoMenu is set, or
    // (b) the item has no registered client
    //
    // If all items are removed, remember to remove the separator too.
    // 

    static const struct
    {
        DWORD dwCmd;
        LPCTSTR pszClient;
    }
    c_mailnewsitems[] =
    {
        { FCIDM_MAIL,       MAIL_DEF_KEY },
        { FCIDM_NEWS,       NEWS_DEF_KEY },
        { FCIDM_CONTACTS,   CONTACTS_DEF_KEY },
        { FCIDM_CALENDAR,   CALENDAR_DEF_KEY },
        { FCIDM_TASKS,      TASKS_DEF_KEY },
        { FCIDM_JOURNAL,    JOURNAL_DEF_KEY },
        { FCIDM_NOTES,      NOTES_DEF_KEY },
        { FCIDM_CALL,       CALL_DEF_KEY },
    };

    BOOL fGoRestricted = SHRestricted2(REST_GoMenu, NULL, 0);

    for (int i = 0; i < ARRAYSIZE(c_mailnewsitems); i++)
    {
        if (fGoRestricted || !SHIsRegisteredClient(c_mailnewsitems[i].pszClient))
        {
            DeleteMenu(hmenu, c_mailnewsitems[i].dwCmd, MF_BYCOMMAND);
        }
    }

    _SHPrettyMenu(hmenu);   // to ensure separator is removed if necessary
}

void CShellBrowser2::_ExecFileContext(UINT idCmd)
{
    if (_pcmNsc)
    {
        CMINVOKECOMMANDINFO ici = {
            sizeof(CMINVOKECOMMANDINFO),
                0L,
                _pbbd->_hwnd,
                MAKEINTRESOURCEA(idCmd-FCIDM_FILECTX_FIRST),
                NULL, 
                NULL,
                SW_NORMAL,
        };
        _pcmNsc->InvokeCommand(&ici);

        // It's no good after an invoke...
        IUnknown_SetSite(_pcmNsc, NULL);
        ATOMICRELEASE(_pcmNsc);
   }
}

void CShellBrowser2::_EnableFileContext(HMENU hmenuPopup)
{
    IContextMenu2 *pcm = NULL;
    OLECMDTEXTV<MAX_FILECONTEXT_STRING> cmdtv;
    OLECMDTEXT *pcmdText = &cmdtv;

    // First clean up any previous merge we may have done
    DeleteMenu(hmenuPopup, FCIDM_FILENSCBANDSEP, MF_BYCOMMAND);
    DeleteMenu(hmenuPopup, FCIDM_FILENSCBANDPOPUP, MF_BYCOMMAND);
    IUnknown_SetSite(_pcmNsc, NULL);
    ATOMICRELEASE(_pcmNsc);

    // Second, get the name and pcm for the NSC selection, if available
    if (_poctNsc)
    {
        OLECMD rgcmd = { SBCMDID_INITFILECTXMENU, 0 };
        
        pcmdText->cwBuf = MAX_FILECONTEXT_STRING;
        pcmdText->cmdtextf = OLECMDTEXTF_NAME;
        pcmdText->rgwz[0] = 0;
        _poctNsc->QueryStatus(&CGID_Explorer, 1, &rgcmd, pcmdText);
        if (rgcmd.cmdf & OLECMDF_ENABLED)
        {
            VARIANT var = {0};

            HRESULT hr = _poctNsc->Exec(&CGID_Explorer, SBCMDID_INITFILECTXMENU, OLECMDEXECOPT_PROMPTUSER, NULL, &var);
            if (SUCCEEDED(hr) && VT_UNKNOWN == var.vt && NULL != var.punkVal)
            {
                var.punkVal->QueryInterface(IID_PPV_ARG(IContextMenu2, &pcm));
            }
            VariantClearLazy(&var);
        }
    }

    // Third, merge the menu in if we got it
    if (pcm)
    {
        HMENU hmenu = CreatePopupMenu();
        if (hmenu)
        {
            IUnknown_SetSite(pcm, _poctNsc);
            HRESULT hr = pcm->QueryContextMenu(hmenu, 0, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST, CMF_EXPLORE);
            if (SUCCEEDED(hr))
            {
                UINT nInsert = SHMenuIndexFromID(hmenuPopup, FCIDM_VIEWOFFLINE);
                if (-1 == nInsert)
                    nInsert = SHMenuIndexFromID(hmenuPopup, FCIDM_FILECLOSE);
                if (-1 == nInsert)
                    nInsert = GetMenuItemCount(hmenuPopup);

                MENUITEMINFO mii = {0};
                mii.cbSize = sizeof(mii);

                mii.fMask = MIIM_ID | MIIM_TYPE;
                mii.fType = MFT_SEPARATOR;
                mii.wID = FCIDM_FILENSCBANDSEP;
                InsertMenuItem(hmenuPopup, nInsert, MF_BYPOSITION, &mii);

                // BUGBUG: "&" is a legal UI name, we need to map this to "&&" or whatever the menu escape sequence is...
                mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_SUBMENU;
                mii.fType = MFT_STRING;
                mii.hSubMenu = hmenu;
                mii.dwTypeData = pcmdText->rgwz;
                mii.wID = FCIDM_FILENSCBANDPOPUP;
                InsertMenuItem(hmenuPopup, nInsert, MF_BYPOSITION, &mii);
 
                _pcmNsc = pcm;
                _pcmNsc->AddRef();
            }
            else
            {
                IUnknown_SetSite(pcm, NULL);
            }

            if (FAILED(hr))
                DestroyMenu(hmenu);
        }

        pcm->Release();
    }
}

void CShellBrowser2::_MungeGoMyComputer(HMENU hmenuPopup)
{
    //need to have a menu item My Computer but a user might have changed
    //it to something else so go get the new name
    LPITEMIDLIST pidlMyComputer;
    TCHAR szBuffer[MAX_PATH]; //buffer to hold menu item string
    TCHAR szMenuText[MAX_PATH+1+6];

    SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer);
    if (pidlMyComputer)
    {
        if (SUCCEEDED(SHGetNameAndFlags(pidlMyComputer, SHGDN_NORMAL, szMenuText, SIZECHARS(szMenuText), NULL)))
        {   
            MENUITEMINFO mii;

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_TYPE;
            mii.fType = MFT_STRING;
            mii.dwTypeData = szBuffer;
            mii.cch = ARRAYSIZE(szBuffer);
            if (GetMenuItemInfoWrap(hmenuPopup, FCIDM_MYCOMPUTER, FALSE, &mii)) 
            {
                LPTSTR  pszHot;
                LPTSTR pszMenuItem = (LPTSTR) mii.dwTypeData;
                
                //before we get rid of the old name, need to get 
                //the hot key for it
                //check if the old name had a hot key
                //StrChr is defined in shlwapi (strings.c) and accepts word even in ascii version
                if (NULL != (pszHot = StrChr(pszMenuItem, (WORD)TEXT('&'))))
                {   //yes
                    LPTSTR   psz;
                    DWORD   cch;

                    pszHot++; //make it point to the hot key, not &
                    //try to find the key in the new string
                    if (NULL == (psz = StrChr(szMenuText, (WORD)*pszHot)))
                    {   //not found, then we'll insert & at the beginning of the new string
                        psz = szMenuText;
                    }

                    // can't put hotkey to full width characters
                    // and some of japanese specific half width chars.
                    // the comparison 
                    BOOL fFEmnemonic = FALSE;
                    if (g_fRunOnFE)
                    {
                        WORD wCharType[2];
                        // if built Ansi it takes max. 2 bytes to determine if 
                        // the given character is full width.
                        // DEFAULT_SYSTEM_LOCALE has to change when we have a way
                        // to get current UI locale.
                        //
                        GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE3, psz, 
                                        sizeof(WCHAR)/sizeof(TCHAR), wCharType);

                        if ((wCharType[0] & C3_FULLWIDTH)
                           ||(wCharType[0] & C3_KATAKANA) 
                           ||(wCharType[0] & C3_IDEOGRAPH)
                           ||((wCharType[0] & C3_ALPHA) && !(wCharType[0] & C3_HALFWIDTH)))
                        {
                            fFEmnemonic = TRUE;
                        }
                    }

                    if (fFEmnemonic)
                    {
                        // assume we have room for hotkey...
                        ASSERT(lstrlen(szMenuText) < ARRAYSIZE(szMenuText));
                        StrCat(szMenuText, TEXT("(&"));
                        cch = lstrlen(szMenuText);
                        szMenuText[cch] = *pszHot;
                        StrCpy(&szMenuText[cch+1], TEXT(")"));
                    }
                    else
                    {
                        cch = lstrlen(psz) + 1;
                        //make space for & to be inserted
                        memmove(psz+1, psz, cch * sizeof(TCHAR));
                        psz[0] = TEXT('&');
                    }
                }

                mii.dwTypeData = szMenuText;
                SetMenuItemInfo(hmenuPopup, FCIDM_MYCOMPUTER, FALSE, &mii);
            }
        }
        ILFree(pidlMyComputer);
    }
}

inline BOOL IsWebPidl(LPCITEMIDLIST pidl)
{
    return (!pidl || ILIsWeb(pidl));
}

void CShellBrowser2::_InsertTravelLogItems(HMENU hmenu, int nPos)
{
    ITravelLog *ptl;
            
    GetTravelLog(&ptl);
    if (!ptl)
        return;

    //add the back items to the menu
    MENUITEMINFO mii = {0};
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_TYPE;

    //delete all back menu items after the separator

    for (int i=GetMenuItemCount(hmenu); i >=0; i--)
    {
        mii.cch = 0;
        if (GetMenuItemInfoWrap(hmenu, i, TRUE, &mii) &&
            IsInRange(mii.wID, FCIDM_RECENTMENU, FCIDM_RECENTLAST))
        {
            DeleteMenu(hmenu, i, MF_BYPOSITION);
            if (i < nPos)
                nPos--;
        }
    }       

    //add the items
    if (S_OK == ptl->InsertMenuEntries(SAFECAST(this, IShellBrowser*), hmenu, nPos, FCIDM_RECENTFIRST, 
                           FCIDM_RECENTFIRST + GOMENU_RECENT_ITEMS, TLMENUF_CHECKCURRENT | TLMENUF_BACKANDFORTH))
    {
        //if something was added, insert a separator
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask  = MIIM_ID | MIIM_TYPE;
        mii.fType  = MFT_SEPARATOR;
        mii.wID    = FCIDM_RECENTMENU;
        
        InsertMenuItem(hmenu, nPos, TRUE, &mii);
    }
    
    ptl->Release();
}

void CShellBrowser2::_OnGoMenuPopup(HMENU hmenuPopup)
{
    ITravelLog *ptl;

    GetTravelLog(&ptl);
    // if we've got a site or if we're trying to get to a site,
    // enable the back button
    BOOL fBackward = (ptl ? S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_BACK, NULL) : FALSE);
    _EnableMenuItem(hmenuPopup, FCIDM_NAVIGATEBACK, fBackward);

    BOOL fForeward = (ptl ? S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_FORE, NULL) : FALSE);
    _EnableMenuItem(hmenuPopup, FCIDM_NAVIGATEFORWARD, fForeward);

    if (IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_NO_PARENT_FOLDER_SUPPORT) ||
        SHRestricted2W(REST_GoMenu, NULL, 0)) 
    {
        DeleteMenu(hmenuPopup, FCIDM_PREVIOUSFOLDER, MF_BYCOMMAND);
    }
    else
        _EnableMenuItem(hmenuPopup, FCIDM_PREVIOUSFOLDER, _ShouldAllowNavigateParent());

    ATOMICRELEASE(ptl);

    if (SHRestricted2(REST_NoChannelUI, NULL, 0))
        DeleteMenu(hmenuPopup, FCIDM_CHANNELGUIDE, MF_BYCOMMAND);

    _MungeGoMyComputer(hmenuPopup);

    _PruneMailNewsItems(hmenuPopup);
    
    // if in ie4 shell browser we leave travel log in the file menu
    if ((GetUIVersion() >= 5 || !_pbbd->_psf || IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_GO_HOME_PAGE)))
    {
        // The travel log goes after "Home Page".
        int nPos = GetMenuPosFromID(hmenuPopup, FCIDM_STARTPAGE) + 1;

        // If "Home Page" isn't there, then just append to the end.
        if (nPos <= 0)
        {
            nPos = GetMenuItemCount(hmenuPopup);
        }

        _InsertTravelLogItems(hmenuPopup, nPos);
    }
}


HRESULT AssureFtpOptionsMenuItem(HMENU hmenuPopup)
{
    HRESULT hr = S_OK;

    // Append the item if it is missing.  It can be missing because
    // sometimes the menu will be displayed before the shell merges it's
    // menus, so we are modifying the template that will be used for other
    // pages.
    if (GetMenuPosFromID(hmenuPopup, FCIDM_FTPOPTIONS) == 0xFFFFFFFF)
    {
        // Yes, it's missing so we need to add it.
        int nToInsert = GetMenuPosFromID(hmenuPopup, FCIDM_BROWSEROPTIONS);

        if (EVAL(0xFFFFFFFF != nToInsert))
        {
            TCHAR szInternetOptions[64];
            MLLoadString(IDS_INTERNETOPTIONS, szInternetOptions, ARRAYSIZE(szInternetOptions));

            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = (MIIM_TYPE | MIIM_STATE | MIIM_ID);
            mii.fType = MFT_STRING;
            mii.fState = MFS_ENABLED | MFS_UNCHECKED;
            mii.wID = FCIDM_FTPOPTIONS;
            mii.dwTypeData = szInternetOptions;
            mii.cch   = lstrlen(szInternetOptions);

            // We want to go right after "Folder Options" so we found
            // the spot.
            TBOOL(InsertMenuItem(hmenuPopup, (nToInsert + 1), TRUE, &mii));

            // REARCHITECT: The PMs finally decided that
            //         it would be good to always have "Inet Options" & "Folder Options"
            //         in all views. (FTP, Shell, & Web)  However doing it now
            //         is too late so we want to do this later.  When that is done
            //         we can get ride of all this stuff.

            // Now we just want to make sure FCIDM_BROWSEROPTIONS is "Folder Options"
            // because some users over load it to say "Internet Options" which
            // just added above.  So we want to force it back to "Folder Options".
            if (GetMenuItemInfo(hmenuPopup, FCIDM_BROWSEROPTIONS, FALSE, &mii))
            {
                TCHAR szFolderOptions[MAX_PATH];

                MLLoadString(IDS_FOLDEROPTIONS, szFolderOptions, ARRAYSIZE(szFolderOptions));
                mii.dwTypeData = szFolderOptions;
                mii.cch   = lstrlen(szFolderOptions);
                SetMenuItemInfo(hmenuPopup, FCIDM_BROWSEROPTIONS, FALSE, &mii);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


HRESULT UpdateOptionsMenuItem(IShellFolder * psf, HMENU hmenuPopup, BOOL fForNT5)
{
    BOOL fCorrectVersion;

    if (fForNT5)
        fCorrectVersion = (GetUIVersion() >= 5);
    else
        fCorrectVersion = (GetUIVersion() < 5);

    // We want "Internet Options" in addition to "Folder Options" on
    // NT5's Tools menu for FTP Folders.  Is this the case?
    if (fCorrectVersion &&
        IsBrowserFrameOptionsSet(psf, BFO_BOTH_OPTIONS))
    {
        EVAL(SUCCEEDED(AssureFtpOptionsMenuItem(hmenuPopup)));
    }
    else
    {
        // No, so delete the item.
        DeleteMenu(hmenuPopup, FCIDM_FTPOPTIONS, MF_BYCOMMAND);
    }

    return S_OK;
}

void CShellBrowser2::_OnViewMenuPopup(HMENU hmenuPopup)
{
    OLECMD rgcmd[] = {
        { CITIDM_VIEWTOOLS, 0 },
        { CITIDM_VIEWADDRESS, 0 },
        { CITIDM_VIEWLINKS, 0 },
        { CITIDM_VIEWTOOLBARCUSTOMIZE, 0 },
        { CITIDM_VIEWMENU, 0 },
        { CITIDM_VIEWAUTOHIDE, 0 },
        { CITIDM_TEXTLABELS, 0 },
        { CITIDM_VIEWLOCKTOOLBAR, 0 },
    };
    
    UpdateOptionsMenuItem(_pbbd->_psf, hmenuPopup, FALSE);

    //  See _MenuTemplate for the kooky enable/disable scenarios.
    //  Today's kookiness:  The ever-changing "Options" menuitem.
    //  According to the table, we want Options under View on
    //  Non-NT5, in the shell or FTP scenarios.  Therefore, we want
    //  options deleted in the opposite scenario.  And for good measure,
    //  we also delete it if we don't know who we are yet, or if we
    //  are restricted.
    if (SHRestricted(REST_NOFOLDEROPTIONS) ||
        (GetUIVersion() >= 5) || !_pbbd->_pidlCur || 
        IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_RENAME_FOLDER_OPTIONS_TOINTERNET))
    {
        DeleteMenu(hmenuPopup, FCIDM_BROWSEROPTIONS, MF_BYCOMMAND);
    }

    if (SHRestricted2(REST_NoViewSource, NULL, 0))
        _EnableMenuItem(hmenuPopup, DVIDM_MSHTML_FIRST+IDM_VIEWSOURCE, FALSE);

    if (_GetToolbarItem(ITB_ITBAR)->fShow) {
        IUnknown_QueryStatus(_GetITBar(), &CGID_PrivCITCommands, ARRAYSIZE(rgcmd), rgcmd, NULL);
    }

    HMENU hmenuToolbar = LoadMenuPopup(MENU_ITOOLBAR);

    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = hmenuToolbar;
    // why _hmenuCur?  why not hmenuPopup?
    SetMenuItemInfo(_hmenuCur, FCIDM_VIEWTOOLBAR, FALSE, &mii); 

    _CheckMenuItem(hmenuToolbar, FCIDM_VIEWADDRESS, rgcmd[1].cmdf & OLECMDF_ENABLED);
    _CheckMenuItem(hmenuToolbar, FCIDM_VIEWLINKS, rgcmd[2].cmdf & OLECMDF_ENABLED);

    int cItemsBelowSep = 3;
    BOOL fCustomizeAvailable = TRUE;
    if (!(rgcmd[3].cmdf & OLECMDF_ENABLED)) {
        DeleteMenu(hmenuToolbar, FCIDM_VIEWTOOLBARCUSTOMIZE, MF_BYCOMMAND);
        fCustomizeAvailable = FALSE;
        cItemsBelowSep--;
    }

    DeleteMenu(hmenuToolbar, FCIDM_VIEWGOBUTTON, MF_BYCOMMAND);

    if (fCustomizeAvailable || _ptheater || 
        SHRestricted2(REST_LOCKICONSIZE, NULL, 0)) {
        DeleteMenu(hmenuToolbar, FCIDM_VIEWTEXTLABELS, MF_BYCOMMAND);
        cItemsBelowSep--;
    } else {
        _CheckMenuItem (hmenuToolbar, FCIDM_VIEWTEXTLABELS, rgcmd[6].cmdf);
    }
    
    if (_ptheater) {
        _CheckMenuItem (hmenuToolbar, FCIDM_VIEWMENU, rgcmd[4].cmdf);
        _CheckMenuItem (hmenuToolbar, FCIDM_VIEWAUTOHIDE, rgcmd[5].cmdf);
        DeleteMenu(hmenuToolbar, FCIDM_VIEWTOOLS, MF_BYCOMMAND);
    } else {
        _CheckMenuItem(hmenuToolbar, FCIDM_VIEWTOOLS, rgcmd[0].cmdf & OLECMDF_ENABLED);
        DeleteMenu(hmenuToolbar, FCIDM_VIEWMENU, MF_BYCOMMAND);
        DeleteMenu(hmenuToolbar, FCIDM_VIEWAUTOHIDE, MF_BYCOMMAND);
        cItemsBelowSep--;
    }
    
    if (_ptheater || SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0))
    {
        // No lock in theater mode or Windows Explorer
        DeleteMenu(hmenuToolbar, FCIDM_VIEWLOCKTOOLBAR, MF_BYCOMMAND);
    }
    else
    {
        _CheckMenuItem(hmenuToolbar, FCIDM_VIEWLOCKTOOLBAR, rgcmd[7].cmdf & OLECMDF_ENABLED);
    }

    _CheckMenuItem(hmenuPopup, FCIDM_VIEWSTATUSBAR,
                  v_ShowControl(FCW_STATUS, SBSC_QUERY) == SBSC_SHOW);

#ifndef DISABLE_FULLSCREEN
    if (SHRestricted2(REST_NoTheaterMode, NULL, 0))
        _EnableMenuItem(hmenuPopup, FCIDM_THEATER, FALSE);
    else
        _CheckMenuItem(hmenuPopup, FCIDM_THEATER, (_ptheater ? TRUE : FALSE));
#endif

    // if we're on nt5 OR we're not integrated and we're not in explorer
    // add browser bars to the view menu
    if (_GetBrowserBarMenu() == hmenuPopup)
    {
        _AddBrowserBarMenuItems(hmenuPopup);
    }
    // else it gets added only on view/explorer bars

    RestrictItbarViewMenu(hmenuPopup, _GetITBar());
    if (!cItemsBelowSep) 
        DeleteMenu(hmenuToolbar, FCIDM_VIEWCONTEXTMENUSEP, MF_BYCOMMAND);

    DWORD dwValue;
    DWORD dwSize = sizeof(dwValue);
    BOOL  fDefault = FALSE;

    // Check the registry to see if we need to show the "Java Console" menu item.
    //
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Java VM"),
        TEXT("EnableJavaConsole"), NULL, (LPBYTE)&dwValue, &dwSize, FALSE, 
        (void *) &fDefault, sizeof(fDefault));

    // If the value is false or absent, remove the menu item.
    //
    if (!dwValue)
    {
        RemoveMenu(hmenuPopup, FCIDM_JAVACONSOLE, MF_BYCOMMAND);
    }

    //  Component categories cache can be passively (and efficiently) kept consistent through
    //  a registry change notification in integrated platforms on NT and Win=>98.
    //  both of these do an async update as necessary.
    if (g_fRunningOnNT && GetUIVersion() >= 5)
    {
        _QueryHKCRChanged();
    }
    else if (!_fValidComCatCache)
    {
        //  With browser-only, we'll refresh only if we haven't done so already.
        _fValidComCatCache = 
            S_OK == _FreshenComponentCategoriesCache(TRUE /* unconditional update */) ;
    }

    IDispatch *         pDispatch = NULL;
    IHTMLDocument2*     pHTMLDocument = NULL;
    BSTR                bstrUrl = NULL;
    if( SUCCEEDED(_pbbd->_pautoWB2->get_Document(&pDispatch))
        && SUCCEEDED(pDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pHTMLDocument)))
        && pHTMLDocument != NULL
        && SUCCEEDED(pHTMLDocument->get_URL( &bstrUrl)))
    {
        bool fEnableViewPrivacyPolicies = (0 == StrNCmpI( bstrUrl, L"http", ARRAYSIZE(L"http")-1));
        _EnableMenuItem( hmenuPopup, FCIDM_VIEW_PRIVACY_POLICIES, fEnableViewPrivacyPolicies);
//        if( !fEnableViewPrivacyPolicies)
//            DeleteMenu( hmenuPopup, FCIDM_VIEW_PRIVACY_POLICIES, MF_BYCOMMAND);
    }
    SAFERELEASE( pDispatch);
    SAFERELEASE( pHTMLDocument);
    SysFreeString( bstrUrl);
    bstrUrl = NULL;

    // prettify the menu (make sure first and last items aren't
    // separators and that there are no runs of >1 separator)
    _SHPrettyMenu(hmenuPopup);
}


void CShellBrowser2::_OnToolsMenuPopup(HMENU hmenuPopup)
{
    // Party on tools->options
    //
    //  Again _MenuTemplate has the gory details.  We want to lose
    //  "Options" in the non-NT5, shell or FTP scenarios, so we want
    //  to keep it in the opposite case.  (FTP is a freebie since FTP
    //  doesn't have a Tools menu to begin with.)
    //
    //  And don't forget restrictions.
    //  And as a bonus, we have to change the name of the menuitem
    //  in the web scenario to "Internet &Options".
    BOOL fWeb = IsWebPidl(_pbbd->_pidlCur);

    UpdateOptionsMenuItem(_pbbd->_psf, hmenuPopup, TRUE);

    //
    // Figure out whether or not "reset web settings" is needed
    //
    if (!fWeb ||                            // only visible in web mode
        !IsResetWebSettingsEnabled() ||     // only if not disabled by the ieak
        !IsResetWebSettingsRequired())      // and only needed if someone clobbered our reg keys
    {
        DeleteMenu(hmenuPopup, FCIDM_RESETWEBSETTINGS, MF_BYCOMMAND);
    }


    DWORD dwOptions;
    GetBrowserFrameOptions(_pbbd->_psf, (BFO_RENAME_FOLDER_OPTIONS_TOINTERNET | BFO_BOTH_OPTIONS), &dwOptions);   

    DWORD rgfAttrib = SFGAO_FOLDER;
    if (SHRestricted(REST_NOFOLDEROPTIONS) && 
        SUCCEEDED(IEGetAttributesOf(_pbbd->_pidlCur, &rgfAttrib)) && (rgfAttrib & SFGAO_FOLDER))
    {
        DeleteMenu(hmenuPopup, FCIDM_BROWSEROPTIONS, MF_BYCOMMAND);
    }
    else
    {
        // Only do this if the NSE wants it named "Internet Options" but doesn't want "Folder Options"
        // also.
        if (IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_RENAME_FOLDER_OPTIONS_TOINTERNET))
        {
            TCHAR szInternetOptions[64];

            MLLoadString(IDS_INTERNETOPTIONS, szInternetOptions, ARRAYSIZE(szInternetOptions));

            MENUITEMINFO mii;
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
            mii.fType = MFT_STRING;
            mii.fState = MFS_ENABLED | MFS_UNCHECKED;
            mii.dwTypeData = szInternetOptions;
            mii.cch   = lstrlen(szInternetOptions);
            mii.wID   = FCIDM_BROWSEROPTIONS;

            // Append the item if it is missing, else just set it
            if (GetMenuState(hmenuPopup, FCIDM_BROWSEROPTIONS, MF_BYCOMMAND) == 0xFFFFFFFF)
            {
                AppendMenu(hmenuPopup, MF_SEPARATOR, -1, NULL);
                InsertMenuItem(hmenuPopup, 0xFFFFFFFF, TRUE, &mii);
            }
            else
            {
                SetMenuItemInfo(hmenuPopup, FCIDM_BROWSEROPTIONS, FALSE, &mii);
            }
        }
    }

    // Nuke tools->connect through tools->disconnect if restricted or if no net
    if ((!(GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS)) ||
         SHRestricted(REST_NONETCONNECTDISCONNECT))
    {
        for (int i = FCIDM_CONNECT; i <= FCIDM_CONNECT_SEP; i++)
            DeleteMenu(hmenuPopup, i, MF_BYCOMMAND);
    }

    // Nuke tools->find + sep if restricted or if UI version >= 5
    // or if running rooted explorer (since the Find extensions assume
    // unrooted)
    if (SHRestricted(REST_NOFIND) || (GetUIVersion() >= 5)) {
        DeleteMenu(hmenuPopup, FCIDM_TOOLSSEPARATOR, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_MENU_FIND, MF_BYCOMMAND);
    }

    BOOL fAvailable;
    uCLSSPEC ucs;
    QUERYCONTEXT qc = { 0 };
    MENUITEMINFO mii;

    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = CLSID_SubscriptionMgr;

    // see if this option is available
    fAvailable = (SUCCEEDED(FaultInIEFeature(NULL, &ucs, &qc, FIEF_FLAG_PEEK)));

    if (fAvailable && !_fShowSynchronize)
    {
        //  Turn it back on
        
        if (NULL != _pszSynchronizeText)
        {
            _fShowSynchronize = TRUE;


            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE | MIIM_ID;
            mii.fType = MFT_STRING;
            mii.wID = FCIDM_UPDATESUBSCRIPTIONS;
            mii.dwTypeData = _pszSynchronizeText;

            InsertMenuItem(hmenuPopup, _iSynchronizePos, MF_BYPOSITION, &mii);
        }
    }
    else if (!fAvailable && _fShowSynchronize)
    {
        //  Turn it off
        int iSyncPos = GetMenuPosFromID(hmenuPopup, FCIDM_UPDATESUBSCRIPTIONS);

        if (NULL == _pszSynchronizeText)
        {
            _iSynchronizePos = iSyncPos;

            MENUITEMINFO mii;
            TCHAR szBuf[MAX_PATH];
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE | MIIM_ID;
            mii.dwTypeData = szBuf;
            mii.cch = ARRAYSIZE(szBuf);

            if (GetMenuItemInfo(hmenuPopup, FCIDM_UPDATESUBSCRIPTIONS, MF_BYCOMMAND, &mii))
            {
                Str_SetPtr(&_pszSynchronizeText, (LPTSTR)mii.dwTypeData);
            }
        }

        DeleteMenu(hmenuPopup, FCIDM_UPDATESUBSCRIPTIONS, MF_BYCOMMAND);
        
        _fShowSynchronize = FALSE;
    }

    ASSERT((fAvailable && _fShowSynchronize) || (!fAvailable && !_fShowSynchronize));

    if (SHRestricted2(REST_NoWindowsUpdate, NULL, 0))
    {
        DeleteMenu(hmenuPopup, (DVIDM_HELPMSWEB+2), MF_BYCOMMAND);
    }
    else
    {
        DWORD   dwRet;
        DWORD   dwType;
        DWORD   dwSize;
        TCHAR   szNewUpdateName[MAX_PATH];

        // check to see if "Windows Update" should be called
        // something different in the menu

        dwSize = sizeof(szNewUpdateName);

        dwRet = SHRegGetUSValue(c_szMenuItemCust,
                                c_szWindowUpdateName,
                                &dwType,
                                (LPVOID)szNewUpdateName,
                                &dwSize,
                                FALSE,
                                NULL,
                                0);

        if (dwRet == ERROR_SUCCESS)
        {
            ASSERT(dwSize <= sizeof(szNewUpdateName));
            ASSERT(szNewUpdateName[(dwSize/sizeof(TCHAR))-1] == TEXT('\0'));

            // if we got anything, replace the menu item's text, or delete
            // the item if the text was NULL. we can tell if the text was
            // an empty string by seeing whether we got back more
            // bytes than just a null terminator

            if (dwSize > sizeof(TCHAR))
            {
                MENUITEMINFO mii;

                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_TYPE;
                mii.fType = MFT_STRING;
                mii.dwTypeData = szNewUpdateName;

                SetMenuItemInfo(hmenuPopup, FCIDM_PRODUCTUPDATES, FALSE, &mii);
            }
            else
            {
                ASSERT(dwSize == 0);

                DeleteMenu(hmenuPopup, FCIDM_PRODUCTUPDATES, MF_BYCOMMAND);
            }
        }
    }

    // Disable Mail and News submenu if we don't support it
    OLECMD rgcmd[] = {
       { SBCMDID_DOMAILMENU, 0 },
    };

    HRESULT hr = QueryStatus(&CGID_Explorer, ARRAYSIZE(rgcmd), rgcmd, NULL);  
    _EnableMenuItem(hmenuPopup, FCIDM_MAILANDNEWS, SUCCEEDED(hr) && (rgcmd[0].cmdf & OLECMDF_ENABLED));

    // prettify the menu (make sure first and last items aren't
    // separators and that there are no runs of >1 separator)
    _SHPrettyMenu(hmenuPopup);
}

void CShellBrowser2::_OnFileMenuPopup(HMENU hmenuPopup)
{
    // disable create shortcut, rename, delete, and properties
    // we'll enable them bellow if they are available
    _EnableMenuItem(hmenuPopup, FCIDM_DELETE, FALSE);
    _EnableMenuItem(hmenuPopup, FCIDM_PROPERTIES, FALSE);
    _EnableMenuItem(hmenuPopup, FCIDM_RENAME, FALSE);
    _EnableMenuItem(hmenuPopup, FCIDM_LINK, FALSE);
    
    if (SHRestricted2(REST_NoExpandedNewMenu, NULL, 0)
        && (GetMenuState(hmenuPopup, DVIDM_NEW, MF_BYCOMMAND) != 0xFFFFFFFF))
    {
        TCHAR szNewWindow[64];

        MLLoadString(IDS_NEW_WINDOW, szNewWindow, ARRAYSIZE(szNewWindow));

        MENUITEMINFO mii;
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;
        mii.wID = DVIDM_NEWWINDOW;
        mii.dwTypeData = szNewWindow;
        mii.cch = lstrlen(szNewWindow);
        InsertMenuItem(hmenuPopup, DVIDM_NEW, FALSE, &mii);
        DeleteMenu(hmenuPopup, DVIDM_NEW, MF_BYCOMMAND);
    }

    if (_HasToolbarFocus())
    {
        OLECMD rgcmd[] = {
            { SBCMDID_FILEDELETE, 0 },
            { SBCMDID_FILEPROPERTIES, 0 },
            { SBCMDID_FILERENAME, 0},
            { SBCMDID_CREATESHORTCUT, 0},
        };
        IDockingWindow* ptbar = _GetToolbarItem(_itbLastFocus)->ptbar;
        if (SUCCEEDED(IUnknown_QueryStatus(ptbar, &CGID_Explorer, ARRAYSIZE(rgcmd), rgcmd, NULL)))
        {
            _EnableMenuItem(hmenuPopup, FCIDM_DELETE, rgcmd[0].cmdf & OLECMDF_ENABLED);
            _EnableMenuItem(hmenuPopup, FCIDM_PROPERTIES, rgcmd[1].cmdf & OLECMDF_ENABLED);
            _EnableMenuItem(hmenuPopup, FCIDM_RENAME, rgcmd[2].cmdf & OLECMDF_ENABLED);
            _EnableMenuItem(hmenuPopup, FCIDM_LINK, rgcmd[3].cmdf & OLECMDF_ENABLED);
        }
    }
    _EnableMenuItem(hmenuPopup, FCIDM_FILECLOSE, S_FALSE == _DisableModeless());

    _EnableFileContext(hmenuPopup);

    if (_fEnableOfflineFeature || (GetUIVersion() < 5))
    {
        _CheckMenuItem(hmenuPopup, FCIDM_VIEWOFFLINE, (Offline(SBSC_QUERY) == S_OK));
    }
    else
        RemoveMenu(hmenuPopup, FCIDM_VIEWOFFLINE, MF_BYCOMMAND);


    if (_fVisitedNet && NeedFortezzaMenu()) // Do not load WININET.DLL in explorer mode
    {
        // The logic here ensures that the menu is created once per instance
        // and only if there is a need to display a Fortezza menu.
        if (!_fShowFortezza)
        {
            static TCHAR szItemText[16] = TEXT("");
            if (!szItemText[0]) // The string will be loaded only once
                MLLoadString(IDS_FORTEZZA_MENU, szItemText, ARRAYSIZE(szItemText));
            if (_hfm==NULL)
                _hfm = FortezzaMenu();
            InsertMenu(hmenuPopup, FCIDM_FILECLOSE, MF_POPUP, (UINT_PTR) _hfm, szItemText);
            _fShowFortezza = TRUE;
        }
        SetFortezzaMenu(hmenuPopup);
    }
    else if (_fShowFortezza)    // Don't need the menu but already displayed?
    {                           // Remove without destroying the handle
        int cbItems = GetMenuItemCount(hmenuPopup);
        RemoveMenu(hmenuPopup, cbItems-2, MF_BYPOSITION);
        _fShowFortezza = FALSE;
    }


    // See if we can edit the page
    OLECMD rgcmd[] = {
        { CITIDM_EDITPAGE, 0 },
    };
    struct {
        OLECMDTEXT ct;
        wchar_t rgwz[128];
    } cmdText = {0};

    cmdText.ct.cwBuf = ARRAYSIZE(cmdText.rgwz) + ARRAYSIZE(cmdText.ct.rgwz);
    cmdText.ct.cmdtextf = OLECMDTEXTF_NAME;

    IDockingWindow* ptbar = _GetITBar();
    IUnknown_QueryStatus(ptbar, &CGID_PrivCITCommands, ARRAYSIZE(rgcmd), rgcmd, &cmdText.ct);

    _EnableMenuItem(hmenuPopup, FCIDM_EDITPAGE, rgcmd[0].cmdf & OLECMDF_ENABLED);

    // Update the name of the edit menu item
    TCHAR szText[80];
    MENUITEMINFO mii = {0};
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE;
    mii.dwTypeData = szText;
    if (cmdText.ct.cwActual > 1)
    {
        SHUnicodeToTChar(cmdText.ct.rgwz, szText, ARRAYSIZE(szText));
    }
    else
    {
        // Use default edit text
        MLLoadString(IDS_EDITPAGE, szText, ARRAYSIZE(szText));
    }
    SetMenuItemInfo(hmenuPopup, FCIDM_EDITPAGE, FALSE, &mii);



#ifdef TEST_AMBIENTS
   _CheckMenuItem(hmenuPopup, FCIDM_VIEWLOCALOFFLINE,
                  _LocalOffline(SBSC_QUERY) == TRUE);      
   _CheckMenuItem(hmenuPopup, FCIDM_VIEWLOCALSILENT,
                  _LocalSilent(SBSC_QUERY) == TRUE);    
#endif // TEST_AMBIENTS

    // must not change ie4 shell experience
    // so travel log still goes to the file menu   
    if ((GetUIVersion() < 5) && !IsWebPidl(_pbbd->_pidlCur))
    {
        int nPos = GetMenuItemCount(hmenuPopup) - 1; // Start with the last item
        MENUITEMINFO mii = {0};
        BOOL fFound = FALSE;

        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_TYPE;

        // Find the last separator separator
        while (!fFound && nPos > 0)
        {
            mii.cch = 0;
            GetMenuItemInfo(hmenuPopup, nPos, TRUE, &mii);
            if (mii.fType & MFT_SEPARATOR)
                fFound = TRUE;
            else
                nPos --;
        }

        if (fFound)
        {
            _InsertTravelLogItems(hmenuPopup, nPos);
        }
    }

    HMENU hmFileNew = SHGetMenuFromID(hmenuPopup, DVIDM_NEW);

    if (hmFileNew)
    {
        // remove menu items for unregistered components
        // this code is duplicated in shdocvw\dochost.cpp and is necessary here 
        // so that unwanted items are not present before dochost has fully loaded

        const static struct {
            LPCTSTR pszClient;
            UINT idCmd;
        } s_Clients[] = {
            { NEW_MAIL_DEF_KEY, DVIDM_NEWMESSAGE },
            { NEW_CONTACTS_DEF_KEY, DVIDM_NEWCONTACT },
            { NEW_NEWS_DEF_KEY, DVIDM_NEWPOST },
            { NEW_APPOINTMENT_DEF_KEY, DVIDM_NEWAPPOINTMENT },
            { NEW_MEETING_DEF_KEY, DVIDM_NEWMEETING },
            { NEW_TASK_DEF_KEY, DVIDM_NEWTASK },
            { NEW_TASKREQUEST_DEF_KEY, DVIDM_NEWTASKREQUEST },
            { NEW_JOURNAL_DEF_KEY, DVIDM_NEWJOURNAL },
            { NEW_NOTE_DEF_KEY, DVIDM_NEWNOTE },
            { NEW_CALL_DEF_KEY, DVIDM_CALL }
        };

        BOOL bItemRemoved = FALSE;  

        for (int i = 0; i < ARRAYSIZE(s_Clients); i++) 
        {
            if (!SHIsRegisteredClient(s_Clients[i].pszClient)) 
            {
                if (RemoveMenu(hmFileNew, s_Clients[i].idCmd, MF_BYCOMMAND))
                  bItemRemoved = TRUE;
            }
        }

        if (bItemRemoved) // ensure the last item is not a separator
            _SHPrettyMenu(hmFileNew);
    }

    if (!SHIsRegisteredClient(MAIL_DEF_KEY))
    {
        // disable Send Page by Email, Send Link by Email
        HMENU hmFileSend = SHGetMenuFromID(hmenuPopup, DVIDM_SEND);

        if (hmFileSend)
        {
            EnableMenuItem(hmFileSend, DVIDM_SENDPAGE, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hmFileSend, DVIDM_SENDSHORTCUT, MF_BYCOMMAND | MF_GRAYED);
        }
    }
}

void CShellBrowser2::_OnSearchMenuPopup(HMENU hmenuPopup)
{
    if (!_pcmSearch)
        _pxtb->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcmSearch));

    if (_pcmSearch)
        _pcmSearch->QueryContextMenu(hmenuPopup, 0, FCIDM_SEARCHFIRST, FCIDM_SEARCHLAST, 0);
}

void CShellBrowser2::_OnHelpMenuPopup(HMENU hmenuPopup)
{
    RIP(IS_VALID_HANDLE(hmenuPopup, MENU));

    // Do nothing if this is the DocHost version of the Help menu,
    // which always says "About Internet Explorer", and bring up
    // IE about dlg.

    // If we're running in native browser mode,
    // it says "About Windows" and bring up shell about dlg.
    // Change the "About Windows" to "About Windows NT" if running on NT.
    // Not sure what to do for Memphis yet.

    //
    // remove menu items which have been marked for removal
    // via the IEAK restrictions
    //

    if (SHRestricted2(REST_NoHelpItem_TipOfTheDay, NULL, 0))
    {
        DeleteMenu(hmenuPopup, FCIDM_HELPTIPOFTHEDAY, MF_BYCOMMAND);
    }

    if (SHRestricted2(REST_NoHelpItem_NetscapeHelp, NULL, 0))
    {
        DeleteMenu(hmenuPopup, FCIDM_HELPNETSCAPEUSERS, MF_BYCOMMAND);
    }

    if (SHRestricted2(REST_NoHelpItem_Tutorial, NULL, 0))
    {
        DeleteMenu(hmenuPopup, DVIDM_HELPTUTORIAL, MF_BYCOMMAND);
    }

    if (SHRestricted2(REST_NoHelpItem_SendFeedback, NULL, 0))
    {
        DeleteMenu(hmenuPopup, FCIDM_HELPSENDFEEDBACK, MF_BYCOMMAND);
    }

    // "Is this copy of Windows legal?" only supported on Whistler and greater.
    if (!IsOS(OS_WHISTLERORGREATER))
    {
        DeleteMenu(hmenuPopup, FCIDM_HELPISLEGAL, MF_BYCOMMAND);
    }

    UINT ids = IDS_ABOUTWINDOWS;
    if (IsOS(OS_NT4ORGREATER) && !IsOS(OS_WIN2000ORGREATER))
    {
        ids = IDS_ABOUTWINDOWSNT;
    }
    else if (IsOS(OS_WIN98ORGREATER))
    {
        ids = IDS_ABOUTWINDOWS9X;
    }

    if (ids)
    {
        MENUITEMINFO mii;
        TCHAR szName[80];            // The name better not be any bigger.

        memset(&mii, 0, sizeof(MENUITEMINFO));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE;

        // We only try to get FCIDM_HELPABOUT, which will fail if this
        // is the DocHost version of help menu (who has DVIDM_HELPABOUT.)

        if (GetMenuItemInfoWrap(hmenuPopup, FCIDM_HELPABOUT, FALSE, &mii) &&
            MLLoadString(ids, szName, ARRAYSIZE(szName)))
        {
            mii.dwTypeData = szName;
            SetMenuItemInfo(hmenuPopup, FCIDM_HELPABOUT, FALSE, &mii);
        }
    }

    SHCheckMenuItem(hmenuPopup, FCIDM_HELPTIPOFTHEDAY, (_idmComm == _InfoCLSIDToIdm(&CLSID_TipOfTheDay)));
}

void CShellBrowser2::_OnMailMenuPopup(HMENU hmenuPopup)
{
    if (!SHIsRegisteredClient(MAIL_DEF_KEY))
    {
        DeleteMenu(hmenuPopup, FCIDM_MAIL, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_NEWMESSAGE, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_SENDLINK, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_SENDDOCUMENT, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_MAILNEWSSEPARATOR, MF_BYCOMMAND);
    }

    if (!SHIsRegisteredClient(NEWS_DEF_KEY))
    {
        DeleteMenu(hmenuPopup, FCIDM_MAILNEWSSEPARATOR, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_NEWS, MF_BYCOMMAND);
    }
}

void CShellBrowser2::_OnEditMenuPopup(HMENU hmenuPopup)
{
    OLECMD rgcmdEdit[] = {{CITIDM_EDITPAGE, 0 }};

    OLECMD rgcmd[] = {
        { OLECMDID_CUT, 0 },
        { OLECMDID_COPY, 0 },
        { OLECMDID_PASTE, 0 },
        { OLECMDID_SELECTALL, 0 }
    };
    ASSERT(FCIDM_COPY==FCIDM_MOVE+1);
    ASSERT(FCIDM_PASTE==FCIDM_MOVE+2);
    ASSERT(FCIDM_SELECTALL==FCIDM_MOVE+3);

    TraceMsg(DM_PREMERGEDMENU, "CSB::_OnEditMenuPopup got FCIDM_MENU_EDIT");
    IOleCommandTarget* pcmdt;
    HRESULT hres = _FindActiveTarget(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
    if (SUCCEEDED(hres)) {
        pcmdt->QueryStatus(NULL, ARRAYSIZE(rgcmd), rgcmd, NULL);
        pcmdt->Release();
    }

    for (int i=0; i<ARRAYSIZE(rgcmd); i++) {
        _EnableMenuItem(hmenuPopup, FCIDM_MOVE+i, rgcmd[i].cmdf & OLECMDF_ENABLED);
    }

    if (SUCCEEDED(_GetITBar()->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt))))
    {
        pcmdt->QueryStatus(&CGID_PrivCITCommands, ARRAYSIZE(rgcmdEdit), rgcmdEdit, NULL);
        pcmdt->Release();
    }    
    _EnableMenuItem(hmenuPopup, FCIDM_EDITPAGE, rgcmdEdit[0].cmdf & OLECMDF_ENABLED);

    // prettify the menu (make sure first and last items aren't
    // separators and that there are no runs of >1 separator)
    _SHPrettyMenu(hmenuPopup);
}

void CShellBrowser2::_OnFindMenuPopup(HMENU hmenuPopup)
{
    TraceMsg(DM_TRACE, "CSB::_OnFindMenuPopup cabinet InitMenuPopup of Find commands");

    ASSERT(GetUIVersion() < 5); // otherwise the menu is deleted when we load it from resources
    ASSERT(!SHRestricted(REST_NOFIND)); // otherwise the menu is deleted when we load it from resources

    ATOMICRELEASE(_pcmFind);
    _pcmFind = SHFind_InitMenuPopup(hmenuPopup, _pbbd->_hwnd, FCIDM_MENU_TOOLS_FINDFIRST, FCIDM_MENU_TOOLS_FINDLAST);
}

void CShellBrowser2::_OnExplorerBarMenuPopup(HMENU hmenuPopup)
{
    if (_hEventComCat)
    {
        // Wait a bit for the comcat cache enumeration to finish
        WaitForSingleObject(_hEventComCat, 1500);
        CloseHandle(_hEventComCat);
        _hEventComCat = NULL;
    }

    _AddBrowserBarMenuItems(hmenuPopup);

    if (SHRestricted2(REST_NoFavorites, NULL, 0))
        _EnableMenuItem(hmenuPopup, FCIDM_VBBFAVORITESBAND, FALSE);

    if (SHRestricted2(REST_No_LaunchMediaBar, NULL, 0))
        _EnableMenuItem(hmenuPopup, FCIDM_VBBMEDIABAND, FALSE);

    for (int idCmd = FCIDM_VBBFIXFIRST; idCmd <= FCIDM_VBBDYNLAST; idCmd++)
        SHCheckMenuItem(hmenuPopup, idCmd, FALSE);

    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fState = MFS_CHECKED;
    mii.fMask = MIIM_STATE;
    SetMenuItemInfo(hmenuPopup, _idmInfo, FALSE, &mii);
    SetMenuItemInfo(hmenuPopup, _idmComm, FALSE, &mii);

    // if we have pre-ie4 shell32, remove the folders bar option
    if (GetUIVersion() < 4)
        DeleteMenu(hmenuPopup, FCIDM_VBBEXPLORERBAND, MF_BYCOMMAND);
}

LRESULT CShellBrowser2::v_OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu)
{
    if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_EXPLORE)) {
        _OnGoMenuPopup(hmenuPopup);
    } 
    else if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_VIEW)) {
        _OnViewMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_TOOLS)) {
        _OnToolsMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_FILE)) {
        _OnFileMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_SEARCHMENU)) {
        _OnSearchMenuPopup(hmenuPopup);
    }
    else if ((hmenuPopup == _GetMenuFromID(FCIDM_MENU_HELP)) ||
             (hmenuPopup == SHGetMenuFromID(_hmenuFull, FCIDM_MENU_HELP))) {
        // For the help menu we try both the current menu and by chance the FullSB menu
        // as if we get here before the menu merge we will not have set the current menu
        // and that would leave Help about windows95 for all platforms.
        _OnHelpMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_EDIT)) {
        _OnEditMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_FIND)) {
        _OnFindMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_VIEWBROWSERBARS)) {
        _OnExplorerBarMenuPopup(hmenuPopup);
    }
    else {
        UINT wID = GetMenuItemID(hmenuPopup, 0); // assume the first item on the popup identifies the menu
        
        if (wID == FCIDM_MAIL) {
            _OnMailMenuPopup(hmenuPopup);
        }
        else if (_pcmNsc && IsInRange(wID, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST)) {
            _pcmNsc->HandleMenuMsg(WM_INITMENUPOPUP, (WPARAM)hmenuPopup, (LPARAM)MAKELONG(nIndex, fSystemMenu));
        }
        else if (_pcm) {
            _pcm->HandleMenuMsg(WM_INITMENUPOPUP, (WPARAM)hmenuPopup, (LPARAM)MAKELONG(nIndex, fSystemMenu));
        }
    }
    
    return S_OK;
}

#pragma warning (disable:4200)
typedef struct {
    int nItemOffset;
    int nPopupOffset;
    struct {
        UINT uID;
        HMENU hPopup;
#ifndef UNIX
    } sPopupIDs[];
#else
    } sPopupIDs[2];
#endif
} MENUHELPIDS;
#pragma warning (default:4200)


void CShellBrowser2::_SetMenuHelp(HMENU hmenu, UINT wID, LPCTSTR pszHelp)
{
    if (pszHelp && pszHelp[0])
    {
        UINT flags = SBT_NOBORDERS | 255;

        // If the menu text is RTL, then so too will the status text be
        MENUITEMINFO mii = { sizeof(mii) };
        mii.fMask = MIIM_TYPE;
        if (GetMenuItemInfo(hmenu, wID, FALSE, &mii) &&
            (mii.fType & MFT_RIGHTORDER))
            flags |= SBT_RTLREADING;

        SendMessage(_hwndStatus, SB_SETTEXT, flags, (LPARAM)pszHelp);
        SendMessage(_hwndStatus, SB_SIMPLE, 1, 0);
    }
}

void CShellBrowser2::_SetExternalBandMenuHelp(HMENU hmenu, UINT wID)
{
    USES_CONVERSION;
    OLECMD cmd = { CITIDM_VIEWEXTERNALBAND_FIRST + (wID - FCIDM_EXTERNALBANDS_FIRST), 0 };
    OLECMDTEXTV<MAX_PATH> cmdtv;
    cmdtv.cwBuf = MAX_PATH;
    cmdtv.cmdtextf = OLECMDTEXTF_STATUS;
    cmdtv.rgwz[0] = 0;

    IUnknown_QueryStatus(_GetITBar(), &CGID_PrivCITCommands, 1, &cmd, &cmdtv);

    _SetMenuHelp(hmenu, wID, W2CT(cmdtv.rgwz));
}

void CShellBrowser2::_SetBrowserBarMenuHelp(HMENU hmenu, UINT wID)
{
    if (_pbsmInfo)
    {
        BANDCLASSINFO *pbci = _BandClassInfoFromCmdID(wID);
        if (pbci)
        {
            LPCTSTR pszHelp = pbci->pszHelpPUI ? pbci->pszHelpPUI : pbci->pszHelp;
            _SetMenuHelp(hmenu, wID, pszHelp);
        }
    }
}

// Handles WM_MENUSELECT.  Returns FALSE if this menu item isn't handled by
// the frame.
LRESULT CShellBrowser2::_OnMenuSelect(WPARAM wParam, LPARAM lParam, UINT uHelpFlags)
{
    MENUHELPIDS sMenuHelpIDs = {
        MH_ITEMS, MH_POPUPS,
        0, NULL,        // Placeholder for specific menu 
        0, NULL         // This list must be NULL terminated 
    };
    TCHAR szHint[MAX_PATH];     // OK with MAX_PATH
    UINT uMenuFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);
    WORD wID = GET_WM_MENUSELECT_CMD(wParam, lParam);
    HMENU hMenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);

    /* 
       HACKHACK
       USER32 TrackPopup menus send a menu deselect message which clears our
       status text at inopportune times.  We work around this with a private
       MBIgnoreNextDeselect message.
    */

    // Did someone ask us to clear the status text?
    if (!hMenu && LOWORD(uMenuFlags)==0xffff)
    {
        // Yes

        // Should we honour that request?
        if (!_fIgnoreNextMenuDeselect)
            // Yes
            SendMessage(_hwndStatus, SB_SIMPLE, 0, 0L);
        else
            // No
            _fIgnoreNextMenuDeselect = FALSE;

        return 1L;
    }
    
    // Clear this out just in case, but don't update yet
    SendMessage(_hwndStatus, SB_SETTEXT, SBT_NOBORDERS|255, (LPARAM)(LPTSTR)c_szNULL);
    SendMessage(_hwndStatus, SB_SIMPLE, 1, 0L);

    if (uMenuFlags & MF_SYSMENU)
    {
        // We don't put special items on the system menu any more, so go
        // straight to the MenuHelp
        goto DoMenuHelp;
    }

    if (uMenuFlags & MH_POPUP)
    {
        MENUITEMINFO miiSubMenu;

        if (!_hmenuCur)
        {
            return(0L);
        }

        miiSubMenu.cbSize = sizeof(MENUITEMINFO);
        miiSubMenu.fMask = MIIM_SUBMENU|MIIM_ID;
        if (!GetMenuItemInfoWrap(GET_WM_MENUSELECT_HMENU(wParam, lParam), wID, TRUE, &miiSubMenu))
        {
            // Check if this was a top level menu
            return(0L);
        }

        // Change the parameters to simulate a "normal" menu item
        wParam = miiSubMenu.wID;
        wID = (WORD)miiSubMenu.wID;
//
// NOTES: We are eliminating this range check so that we can display
//  help-text on sub-menus. I'm not sure why explorer.exe has this check.
//
#if 0
        if (!IsInRange(wID, FCIDM_GLOBALFIRST, FCIDM_GLOBALLAST))
            return 0L;
#endif
        uMenuFlags = 0;
    }

    // FEATURE: chrisfra 9/2/97
    //  No menu help for context menu stuck in File Menu or menus that aren't ours
    //  in IE 5.0, might want to write code to use context
    //  menu to get help to work

    if (IsInRange(wID, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST) ||
        !IsInRange(wID, FCIDM_FIRST, FCIDM_LAST))
        return 0L;

    if (_pcmSearch && IsInRange(wID, FCIDM_SEARCHFIRST, FCIDM_SEARCHLAST))
    {
        _pcmSearch->HandleMenuMsg(WM_MENUSELECT, wParam, lParam);
       return 0L;
    }

#if 0
    if (IsInRange(wID, FCIDM_RECENTFIRST, FCIDM_RECENTLAST)) {
        wID = FCIDM_RECENTFIRST;
    }
#endif

    // Menu help for plug-in explorer bars.
    if (IsInRange(wID, FCIDM_VBBDYNFIRST, FCIDM_VBBDYNLAST))
    {
        _SetBrowserBarMenuHelp(hMenu, wID);
        return 0L;
    }

    // Menu help for plug-in itbar bands
    if (IsInRange(wID, FCIDM_EXTERNALBANDS_FIRST, FCIDM_EXTERNALBANDS_LAST))
    {
        _SetExternalBandMenuHelp(hMenu, wID);
        return 0L;
    }

    szHint[0] = 0;

    sMenuHelpIDs.sPopupIDs[0].uID = 0;
    sMenuHelpIDs.sPopupIDs[0].hPopup = NULL;

DoMenuHelp:
    MenuHelp(WM_MENUSELECT, wParam, lParam, _hmenuCur, MLGetHinst(),
             _hwndStatus, (UINT *)&sMenuHelpIDs);

    return 1L;
}

void CShellBrowser2::_DisplayFavoriteStatus(LPCITEMIDLIST pidl)
{
    LPTSTR pszURL = NULL;

    IUniformResourceLocator * pURL;
    if (SUCCEEDED(CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
        IID_IUniformResourceLocator, (void **)&pURL)))
    {
        IPersistFile *ppf;
        if (SUCCEEDED(pURL->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
        {
            WCHAR wszPath[MAX_PATH];

            // Get the full path to the .lnk
            SHGetPathFromIDListW(pidl, wszPath);

            // Attempt to connect the storage of the IURL to the pidl
            if (SUCCEEDED(ppf->Load(wszPath, STGM_READ)))
            {
                pURL->GetURL(&pszURL);
            }

            ppf->Release();
        }

        pURL->Release();
    }

    SendMessage(_hwndStatus, SB_SIMPLE, 1, 0L);
    SendMessage(_hwndStatus, SB_SETTEXT, SBT_NOBORDERS|255, (LPARAM)pszURL);

    if (pszURL)
        SHFree(pszURL);
}

LRESULT CShellBrowser2::_ThunkTTNotify(LPTOOLTIPTEXTA pnmTTTA)
{
    TOOLTIPTEXTW tttw = {0};

    tttw.hdr = pnmTTTA->hdr;
    tttw.hdr.code = TTN_NEEDTEXTW;

    tttw.lpszText = tttw.szText;
    tttw.hinst    = pnmTTTA->hinst;
    tttw.uFlags   = pnmTTTA->uFlags;
    tttw.lParam   = pnmTTTA->lParam;

    LRESULT lRes = SUPERCLASS::OnNotify(&tttw.hdr);

    pnmTTTA->hdr = tttw.hdr;
    pnmTTTA->hdr.code = TTN_NEEDTEXTA;

    pnmTTTA->hinst = tttw.hinst;
    pnmTTTA->uFlags = tttw.uFlags;
    pnmTTTA->lParam = tttw.lParam;

    if (tttw.lpszText == LPSTR_TEXTCALLBACKW)
        pnmTTTA->lpszText = LPSTR_TEXTCALLBACKA;
    else if (!tttw.lpszText)
        pnmTTTA->lpszText = NULL;
    else if (!HIWORD(tttw.lpszText))
        pnmTTTA->lpszText = (LPSTR)tttw.lpszText;
    else {
        WideCharToMultiByte(CP_ACP, 0, tttw.lpszText, -1,
                            pnmTTTA->szText, ARRAYSIZE(pnmTTTA->szText), NULL, NULL);
    }
    
    return lRes;
}

UINT GetDDEExecMsg()
{
    static UINT uDDEExec = 0;

    if (!uDDEExec)
        uDDEExec = RegisterWindowMessage(TEXT("DDEEXECUTESHORTCIRCUIT"));

    return uDDEExec;
}

LRESULT CShellBrowser2::OnNotify(LPNMHDR pnm)
{
    switch (pnm->code)
    {
        case NM_DBLCLK:
        {
            int idCmd = -1;
            LPNMCLICK pnmc = (LPNMCLICK)pnm;
            switch(pnmc->dwItemSpec)
            {
                case STATUS_PANE_NAVIGATION:
                    idCmd = SHDVID_NAVIGATIONSTATUS;
                    break;
                        
                case STATUS_PANE_PROGRESS:
                    idCmd = SHDVID_PROGRESSSTATUS;
                    break;
                    
                case STATUS_PANE_OFFLINE:
                    idCmd = SHDVID_ONLINESTATUS;
                    break;

                case STATUS_PANE_PRIVACY:
                    idCmd = SHDVID_PRIVACYSTATUS;
                    break;
                
                //case STATUS_PANE_PRINTER:
                //    idCmd = SHDVID_PRINTSTATUS;
                //    break;
                
                case STATUS_PANE_ZONE:
                    idCmd = SHDVID_ZONESTATUS;
                    break;
                    
                case STATUS_PANE_SSL:
                    idCmd = SHDVID_SSLSTATUS;
                    break;
                    
                default:
                    break;
            }
            if (_pbbd->_pctView && (idCmd != -1))
            {
                HRESULT hr = _pbbd->_pctView->Exec(&CGID_ShellDocView, idCmd, NULL, NULL, NULL);

                // If the parent couldn't handle it, maybe we can.
                if (FAILED(hr)) {
                    if (pnmc->dwItemSpec == _uiZonePane &&
                        _pbbd->_pidlCur)
                    {
                        WCHAR wszUrl[MAX_URL_STRING];
                        if (SUCCEEDED(::IEGetDisplayName(_pbbd->_pidlCur, wszUrl, SHGDN_FORPARSING)))
                        {
                            ULONG_PTR uCookie = 0;
                            SHActivateContext(&uCookie);
                            ZoneConfigureW(_pbbd->_hwnd, wszUrl);
                            if (uCookie)
                            {
                                SHDeactivateContext(uCookie);
                            }
                        }
                    }
                }
            }
            
            break;
        }
        
        case TTN_NEEDTEXTA:
        case TTN_NEEDTEXTW:
            if (IsInRange(pnm->idFrom, FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST)) {
                if (pnm->code == TTN_NEEDTEXTA && _fUnicode) 
                    return _ThunkTTNotify((LPTOOLTIPTEXTA)pnm);
                else
                    return SUPERCLASS::OnNotify(pnm);
            }         
            return 0;

        case SEN_DDEEXECUTE:
            //  381213 - webfolders needs dde shortcircuit in IE to work - ZekeL - 30-APR-2001
            //  on NT4SUR (non-integrated) we have to make sure that webfolders
            //  continues to be able to get folder window reuse for navigation.
            //
            //  this was:
            //      if (pnm->idFrom == 0 && GetUIVersion() >= 4) 
            //  and i am pretty sure some thing will break, since we once again 
            //  allow the shortcircuit code to run on pre-shell integrated.
            //  but maybe not since we no longer use the bogus folder navigation
            //  in order to implement OpenNew window for HTMLFile
           
            if (pnm->idFrom == 0) 
            {
                LPNMVIEWFOLDER pnmPost = DDECreatePostNotify((LPNMVIEWFOLDER)pnm) ;

                if (pnmPost)
                {
                    PostMessage(_pbbd->_hwnd, GetDDEExecMsg(), 0, (LPARAM)pnmPost);
                    return TRUE;
                }

            }
            break;
            
        case SBN_SIMPLEMODECHANGE:
            if ((pnm->idFrom == FCIDM_STATUS) && _hwndProgress) 
                _ShowHideProgress();
            break;
            
        default:
            break;
    }        
    return 0;
}

DWORD CShellBrowser2::_GetTempZone()
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psfParent;
    WCHAR szURL[MAX_URL_STRING];
    
    szURL[0] = 0;   // parse name for zone goes here
    
    if (SUCCEEDED(IEBindToParentFolder(_pbbd->_pidlCur, &psfParent, &pidlChild)))
    {
        // see if this is a folder shortcut, if so we use it's path for the zone
        IShellLink *psl;
        if (SUCCEEDED(psfParent->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&pidlChild, IID_IShellLink, NULL, (void **)&psl)))
        {
            LPITEMIDLIST pidlTarget;
            if (S_OK == psl->GetIDList(&pidlTarget))
            {
                ::IEGetDisplayName(pidlTarget, szURL, SHGDN_FORPARSING);
                ILFree(pidlTarget);
            }
            psl->Release();
        }
        psfParent->Release();
    }
    
    if (NULL == _pism)
        CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IInternetSecurityManager, &_pism));

    DWORD nZone = ZONE_UNKNOWN;
    if (_pism && (szURL[0] || SUCCEEDED(::IEGetDisplayName(_pbbd->_pidlCur, szURL, SHGDN_FORPARSING))))
    {
        _pism->MapUrlToZone(szURL, &nZone, 0);
    }
    return nZone;
}

void Exec_GetZone(IUnknown * punk, VARIANTARG *pvar)
{
    IUnknown_Exec(punk, &CGID_Explorer, SBCMDID_MIXEDZONE, 0, NULL, pvar);

    if (pvar->vt == VT_UI4) // MSHTML was able to figure out what zone we are in
        pvar->ulVal = MAKELONG(STATUS_PANE_ZONE, pvar->ulVal);    
    else if (pvar->vt == VT_NULL)  // MSHTML has figured us to be in a mixed zone
        pvar->ulVal = MAKELONG(STATUS_PANE_ZONE, ZONE_MIXED);    
    else // We don't have zone info
        pvar->ulVal = MAKELONG(STATUS_PANE_ZONE, ZONE_UNKNOWN);    

    pvar->vt = VT_UI4;
}

//
//  in:
//          pvar    if NULL, we query the view for the zone
//                  non NULL, contains a VT_UI4 that encodes the zone pane and the zone value

void CShellBrowser2::_UpdateZonesPane(VARIANT *pvar)
{
    LONG lZone = ZONE_UNKNOWN;
    BOOL fMixed = FALSE;
    TCHAR szDisplayName[MAX_ZONE_DISPLAYNAME];
    VARIANTARG var = {0};

    if (NULL == pvar)
    {
        pvar = &var;
        Exec_GetZone(_pbbd->_pctView, &var);
    }

    // Do we already have the zone and fMixed info?
    if (pvar->vt == VT_UI4)
    {
        lZone = (signed short)HIWORD(pvar->lVal);
        _uiZonePane = (int)(signed short)LOWORD(pvar->lVal);
        if (lZone == ZONE_MIXED)
        {
            lZone = ZONE_UNKNOWN;
            fMixed = TRUE;
        }

        if (lZone < 0 && !IS_SPECIAL_ZONE(lZone))
        {
            // sometimes we're getting back an invalid zone index from urlmon,
            // and if we don't bound the index, we'll crash later
            lZone = ZONE_UNKNOWN;
        }
    }

    var.vt = VT_EMPTY;
    if (_pbbd->_pctView && SUCCEEDED(_pbbd->_pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_ZONE, NULL, &var)))
        _uiZonePane = var.ulVal;
    else
        _uiZonePane = STATUS_PANE_ZONE;

    // Sanity Check the zone
    if (_pbbd->_pidlCur)
    {
        DWORD nTempZone = _GetTempZone();
        if (nTempZone != ZONE_UNKNOWN)
            if (nTempZone > (DWORD)lZone)
                lZone = nTempZone;
    }

    szDisplayName[0] = 0;

    if (ZONE_UNKNOWN == lZone)
        MLLoadStringW(IDS_UNKNOWNZONE, szDisplayName, ARRAYSIZE(szDisplayName));
    else
    {
        if (_hZoneIcon)
        {
            // Before we can delete it, make comctl32's statusbar code stop using it.
            // Or else we rip.
            SendControlMsg(FCW_STATUS, SB_SETICON, _uiZonePane, (LPARAM)NULL, NULL);
            DestroyIcon(_hZoneIcon);
        }

        // This will zero the icon & name on failure
        _GetCachedZoneIconAndName(lZone, &_hZoneIcon, szDisplayName, ARRAYSIZE(szDisplayName));
    }
    
    if (fMixed)
    {
        TCHAR szMixed[32];
        MLLoadString(IDS_MIXEDZONE, szMixed, ARRAYSIZE(szMixed));
        StrCatBuff(szDisplayName, szMixed, ARRAYSIZE(szDisplayName));
    }

    SendControlMsg(FCW_STATUS, SB_SETTEXTW, _uiZonePane, (LPARAM)szDisplayName, NULL);
    SendControlMsg(FCW_STATUS, SB_SETICON, _uiZonePane, (LPARAM)_hZoneIcon, NULL);
}

HRESULT CShellBrowser2::ReleaseShellView()
{
    // Give the current view a chance to save before we navigate away
    if (!_fClosingWindow)
    {
        // only try to save if we actually have a current view (this gets
        // called multiple times in a row on destruction, and it gets called
        // before the first view is created)
        //
        if (_pbbd->_psv)
            _SaveState();
    }

    return SUPERCLASS::ReleaseShellView();
}

bool IsWin95ClassicViewState (void)
{
    DWORD dwValue;
    DWORD cbSize = sizeof(dwValue);
    return ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
            TEXT("ClassicViewState"), NULL, &dwValue, &cbSize) && dwValue;
}

BOOL _PersistOpenBrowsers()
{
    return SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                TEXT("PersistBrowsers"), FALSE, FALSE);
}

// For Folder Advanced Options flags that we check often, it's better
// to cache the values as flags in CBaseBrowser2. Update them here.
void CShellBrowser2::_UpdateRegFlags()
{
    _fWin95ViewState = IsWin95ClassicViewState();
}


HRESULT CShellBrowser2::CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd)
{
    if (_pbbd->_psv)
    {
        // snag the current view's setting so we can pass it along
        _UpdateFolderSettings(_pbbd->_pidlPending);
        
        // this is not a valid flag to pass along after the first one
        _fsd._fs.fFlags &= ~FWF_BESTFITWINDOW;
    }

    return SUPERCLASS::CreateViewWindow(psvNew, psvOld, prcView, phwnd);
}

HRESULT CShellBrowser2::ActivatePendingView(void)
{
    _fTitleSet = FALSE;
 
    // NOTES: (SatoNa)
    //
    //  Notice that we no longer call SetRect(&_rcBorderDoc, 0, 0, 0, 0)
    // here. We call it in CShellBrowser2::ReleaseShellView instead.
    // See my comment over there for detail.
    //
    HRESULT hres = SUPERCLASS::ActivatePendingView();
    if (FAILED(hres))
        return hres;

    _ReloadStatusbarIcon();   
       
    _SetTitle(NULL);
    v_SetIcon();
    VALIDATEPENDINGSTATE();

    if (_pxtb)
        _pxtb->SendToolbarMsg(&CLSID_CommonButtons, TB_ENABLEBUTTON, TBIDM_PREVIOUSFOLDER, _ShouldAllowNavigateParent(), NULL);

    UpdateWindowList();
    
    if (!_HasToolbarFocus()) 
    {
        HWND hwndFocus = GetFocus();
        //
        // Trident may take the input focus when they are being UIActivated.
        // In that case, don't mess with the focus.
        //
        if (_pbbd->_hwndView && (hwndFocus==NULL || !IsChild(_pbbd->_hwndView, hwndFocus))) 
            SetFocus(_pbbd->_hwndView);
    }

    // Let's profile opening time
    if (g_dwProfileCAP & 0x00010000)
        StopCAP();

    // Let's profile opening time
    if (g_dwProfileCAP & 0x00000020)
        StartCAP();

    return S_OK;
}

void CShellBrowser2::_UpdateBackForwardStateNow()
{
    _fUpdateBackForwardPosted = FALSE;
    SUPERCLASS::UpdateBackForwardState();
}

HRESULT CShellBrowser2::UpdateBackForwardState()
{
    if (!_fUpdateBackForwardPosted) 
    {
        PostMessage(_pbbd->_hwnd, CWM_UPDATEBACKFORWARDSTATE, 0, 0);
        _fUpdateBackForwardPosted = TRUE;
    }
    return S_OK;
}

HRESULT CShellBrowser2::_TryShell2Rename(IShellView* psv, LPCITEMIDLIST pidlNew)
{
    HRESULT hres = SUPERCLASS::_TryShell2Rename(psv, pidlNew); 
    if (SUCCEEDED(hres)) 
    {
        _SetTitle(NULL);
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Determines if this message should be forwarded onto
         the dochost frame.

Returns: TRUE if the message needs to be forwarded
*/
BOOL CShellBrowser2::_ShouldForwardMenu(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (!_fDispatchMenuMsgs)
        return FALSE;
    
    switch (uMsg) 
    {
    case WM_MENUSELECT:
    {
        // See CDocObjectHost::_ShouldForwardMenu for more details
        // about how this works.
        HMENU hmenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);
        if (hmenu && (MF_POPUP & GET_WM_MENUSELECT_FLAGS(wParam, lParam)))
        {
            HMENU hmenuSub = GetSubMenu(hmenu, GET_WM_MENUSELECT_CMD(wParam, lParam));
            
            if (hmenu == _hmenuCur)
            {
                // Normal case, where we just look at the topmost popdown menus
                _fForwardMenu = _menulist.IsObjectMenu(hmenuSub);
            }
            else if (_menulist.IsObjectMenu(hmenuSub))
            {
                // This happens if the cascading submenu (micro-merged help menu for
                // example) should be forwarded on, but the parent menu should
                // not.
                _fForwardMenu = TRUE;
            }
        }
        break;
    }

    case WM_COMMAND:
        if (_fForwardMenu) 
        {
            // Stop forwarding menu messages after WM_COMMAND
            _fForwardMenu = FALSE;

            // If it wasn't from an accelerator, forward it
            if (0 == GET_WM_COMMAND_CMD(wParam, lParam))
                return TRUE;
        }
        break;
    }
    return _fForwardMenu;
}


DWORD CShellBrowser2::v_RestartFlags()
{
    return COF_CREATENEWWINDOW;
}

void CShellBrowser2::_CloseAllParents()
{
    LPITEMIDLIST pidl = ILClone(_pbbd->_pidlCur);
    if (pidl) 
    {
        for (ILRemoveLastID(pidl); !ILIsEmpty(pidl); ILRemoveLastID(pidl)) 
        {
            HWND hwnd;
            if (WinList_FindFolderWindow(pidl, NULL, &hwnd, NULL) == S_OK) 
            {
                TraceMsg(DM_SHUTDOWN, "csb.cap: post WM_CLOSE hwnd=%x", hwnd);
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
        }
        ILFree(pidl);
    }
}


BOOL CShellBrowser2::_ShouldSaveWindowPlacement()
{
    // If this is done by automation, maybe we should not update the defaults, so
    // to detect this we say if the window is not visible, don't save away the defaults
    
    // For the internet, save one setting for all, otherwise use the win95
    // view stream mru
    
    return (IsWindowVisible(_pbbd->_hwnd) && _fUseIEPersistence && !_fUISetByAutomation &&
            _pbbd->_pidlCur && IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_BROWSER_PERSIST_SETTINGS));
}


void CShellBrowser2::_OnConfirmedClose()
{
    if (_pbbd->_pidlCur && IsCShellBrowser2() && (GetKeyState(VK_SHIFT) < 0)) {
        _CloseAllParents();
    }
    
    if (_fUseIEPersistence && IsCShellBrowser2())
    {
        // save off whether we should launch in fullscreen or not
        SHRegSetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                        TEXT("FullScreen"), REG_SZ, 
                        _ptheater ? TEXT("yes") : TEXT("no"), 
                        _ptheater ? sizeof(TEXT("yes")) : sizeof(TEXT("no")), 
                        SHREGSET_DEFAULT);
    }

    if (_ptheater)
    {
        ShowWindow(_pbbd->_hwnd, SW_HIDE);
        _TheaterMode(FALSE, FALSE);
        _fDontSaveViewOptions = TRUE;
    } 
    else 
    {
        if (_ShouldSaveWindowPlacement())
        {
            StorePlacementOfWindow(_pbbd->_hwnd);
        }
        else
            _fDontSaveViewOptions = TRUE;
    }

    // for now we use the same 12-hour (SessionTime) rule
    // possibly we should just do it always?
    UEMFireEvent(&UEMIID_BROWSER, UEME_CTLSESSION, UEMF_XEVENT, FALSE, -1);
    if (!g_bRunOnNT5) {
        // for down-level guys (old explorer), fake a shell end session too
        UEMFireEvent(&UEMIID_SHELL, UEME_CTLSESSION, UEMF_XEVENT, FALSE, -1);
    }

    // Save view states before closing all toolbars
    // Remember that we saved so we don't do it again
    // during _ReleaseShellView
    _SaveState();
    _fClosingWindow = TRUE;

    // To prevent flashing, we move the window off the screen, unfortunately
    // we can't hide it as shockwave briefly puts up dialog which causes
    // an ugly blank taskbar icon to appear.
    // do this after _SaveState() because that saves window pos info

    // NTRAID 455003: this won't look too good with multi monitors...
    SetWindowPos(_pbbd->_hwnd, NULL, 10000, 10000, 0, 0, SWP_NOSIZE|SWP_NOZORDER);
    
    // Save the Internet toolbar before we close it!
    if (!_fDontSaveViewOptions)
        _SaveITbarLayout();

    _CloseAndReleaseToolbars(TRUE);
    ATOMICRELEASE(_pxtb);
    
    // If you wait until WM_DESTROY (DestroyWindow below) to do this, under some
    // circumstances (eg an html page with an iframe whose src is an UNC based directory)
    // Ole will not Release the CShellBrowser2 that it addref'ed on RegisterDragDrop
    // (chrisfra 7/22/97)
    SetFlags(0, BSF_REGISTERASDROPTARGET);

    // If you wait until WM_DESTROY to do this, some OCs (like shockwave)
    // will hang (probably posting themselves a message)
    _CancelPendingView();
    ReleaseShellView();

    ATOMICRELEASE(_pmb);
    
    // Destroy the icons we created while we still can
    _SetWindowIcon(_pbbd->_hwnd, NULL, ICON_SMALL);
    _SetWindowIcon(_pbbd->_hwnd, NULL, ICON_BIG);

    // getting a random fault on rooted explorer on shutdown on this Destroy, maybe
    // somehow getting reentered.  So atomic destroy it...
    // NOTE: chrisg removed this at one point - is it dead?
    HWND hwndT = _pbbd->_hwnd;
    PutBaseBrowserData()->_hwnd = NULL;
    DestroyWindow(hwndT);

}


// these three functions, CommonHandleFielSysChange,
// v_HandleFileSysChange and this one
// may seem strange, but the idea is that the notify may come in from
// different sources (OneTree vs, win95 style fsnotify vs nt style)
// _OnFSNotify cracks the input, unifies it and calls CommonHnaldeFileSysChange
//  that calls to v_HandleFIleSysChange.  The Common...() is for stuff both needs
// the v_Handle...() is for overridden ones
void CShellBrowser2::_OnFSNotify(WPARAM wParam, LPARAM lParam)
{
    LPSHChangeNotificationLock  pshcnl = NULL;
    LONG lEvent;
    LPITEMIDLIST *ppidl = NULL; // on error, SHChangeNotification_Lock doesn't zero this out!
    IShellChangeNotify * pIFSN;
    
    if (g_fNewNotify && (wParam || lParam))
    {
        // New style of notifications need to lock and unlock in order to free the memory...
        pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);
    } else {
        lEvent = (LONG)lParam;
        ppidl = (LPITEMIDLIST*)wParam;
    }

    if (ppidl)
    {
        //
        //  If we haven't initialized "this" yet, we should ignore all the
        // notification.
        //
        if (_pbbd->_pidlCur)
        {
            _CommonHandleFileSysChange(lEvent, ppidl[0], ppidl[1]);

            //
            //  Forward to ITBar too...
            //
            if (_GetITBar() && SUCCEEDED(_GetITBar()->QueryInterface(IID_PPV_ARG(IShellChangeNotify, &pIFSN))))
            {
                pIFSN->OnChange(lEvent, ppidl[0], ppidl[1]);
                pIFSN->Release();
            }
        }
    }

    if (pshcnl)
    {
        SHChangeNotification_Unlock(pshcnl);
    }
}

LPITEMIDLIST BurnDrivePidl()
{
    LPITEMIDLIST pidl = NULL;

    ICDBurn *pcdb;
    if (SUCCEEDED(CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICDBurn, &pcdb))))
    {
        WCHAR szDrive[4];
        if (SUCCEEDED(pcdb->GetRecorderDriveLetter(szDrive, ARRAYSIZE(szDrive))))
        {
            pidl = ILCreateFromPath(szDrive);
        }
        pcdb->Release();
    }
    return pidl;
}

BOOL IsCurrentBurnDrive(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;

    LPITEMIDLIST pidlBurn = BurnDrivePidl();
    if (pidlBurn)
    {
        fRet = ILIsEqual(pidlBurn, pidl) || ILIsParent(pidlBurn, pidl, FALSE);
        ILFree(pidlBurn);
    }
    return fRet;
}

// fDisconnectAlways means we shouldn't try to re-open the folder (like when
// someone logs off of a share, reconnecting would ask them for
// a password again when they just specified that they want to log off)
void CShellBrowser2::_FSChangeCheckClose(LPCITEMIDLIST pidl, BOOL fDisconnect)
{
    if (ILIsParent(pidl, _pbbd->_pidlCur, FALSE) ||
        (ILIsRooted(_pbbd->_pidlCur) && (ILIsParent(pidl, ILRootedFindIDList(_pbbd->_pidlCur), FALSE))))
    {
        if (!fDisconnect)
        {
            //  APPCOMPAT: FileNet IDMDS (Panagon)'s shell folder extension
            //  incorrectly reports itself as a file system folder, so sniff the
            //  pidl to see if we should ignore the bit.  (B#359464: tracysh)

            // (tybeam) argh put the burndrive check back in again.
            // this app compat hack brings me no joy, its false positive city and basically all it is is the
            // PathFileExistsAndAttributes check.  if you ever have an issue where you have a namespace
            // extension that reports that it's on the filesystem and could possibly fail a PathFileExists
            // on a parsing name (which happens in the burning folder if theres no cd in the drive and it
            // checks the parsing name of the root) and it closes the window randomly, this is the problem
            // right here.
            TCHAR szPath[MAX_PATH];
            DWORD dwAttrib = SFGAO_FILESYSTEM | SFGAO_BROWSABLE;
            if (SUCCEEDED(SHGetNameAndFlags(_pbbd->_pidlCur, SHGDN_FORPARSING, szPath, SIZECHARS(szPath), &dwAttrib))
            && (dwAttrib & SFGAO_FILESYSTEM)
            && !(dwAttrib & SFGAO_BROWSABLE)
            && IsFlagClear(SHGetObjectCompatFlagsFromIDList(_pbbd->_pidlCur), OBJCOMPATF_NOTAFILESYSTEM)
            && !PathFileExistsAndAttributes(szPath, NULL)
            && !IsCurrentBurnDrive(_pbbd->_pidlCur))
            {
                fDisconnect = TRUE;
            }
        }
        
        if (fDisconnect)
            _pbbd->_pautoWB2->Quit();
    }
}

void CShellBrowser2::v_HandleFileSysChange(LONG lEvent, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2)
{
    BOOL fDisconnectAlways = FALSE;

    //
    //  If we are in the middle of changing folders,
    // ignore this event.
    //
    if (_pbbd->_psvPending) {
        return;
    }

    // README:
    // If you need to add events here, then you must change SHELLBROWSER_FSNOTIFY_FLAGS in
    // order to get the notifications
    switch(lEvent)
    {
    case SHCNE_DRIVEADDGUI:
        if (ILIsParent(pidl1, _pbbd->_pidlCur, FALSE)) {
            PostMessage(_pbbd->_hwnd, WM_COMMAND, FCIDM_REFRESH, 0L);
        }
        break;

    case SHCNE_DELETE:
    case SHCNE_RMDIR:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_SERVERDISCONNECT:
    case SHCNE_DRIVEREMOVED:
        if (g_fRunningOnNT || (lEvent == SHCNE_MEDIAREMOVED) || (lEvent == SHCNE_SERVERDISCONNECT))
            fDisconnectAlways = TRUE;

        // the cd burning case can get a removal event when we lock the
        // drive to commence burning or when the user ejects.
        // since we have an open browser on the drive we could get closed and thats bad,
        // so we prevent that here.
        if ((lEvent == SHCNE_MEDIAREMOVED) && IsCurrentBurnDrive(_pbbd->_pidlCur))
        {
            // jump out, we don't want to close.
            break;
        }
        // fall through

    case SHCNE_UPDATEDIR:
    case SHCNE_NETUNSHARE:
        // preserve old behavior of when the explorer (all folders) bar is up,
        // go to nearest parent folder
        if (_idmInfo == FCIDM_VBBEXPLORERBAND)
            break;
        _FSChangeCheckClose(pidl1, fDisconnectAlways);
        break;
    }

}

// converts a simple pidl to a full pidl

LPITEMIDLIST _SimpleToReal(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlReturn = NULL;
    IShellFolder *psf;
    LPCITEMIDLIST pidlChild;
    if (SUCCEEDED(IEBindToParentFolder(pidl, &psf, &pidlChild)))
    {
        LPITEMIDLIST pidlRealChild;
        if (SUCCEEDED(SHGetRealIDL(psf, pidlChild, &pidlRealChild)))
        {
            LPITEMIDLIST pidlParent = ILCloneParent(pidl);
            if (pidlParent)
            {
                pidlReturn = ILCombine(pidlParent, pidlRealChild);
                
                ILFree(pidlParent);
            }
            
            ILFree(pidlRealChild);
        }
        
        psf->Release();
    }

    return pidlReturn;
}



void CShellBrowser2::_CommonHandleFileSysChange(LONG lEvent, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2)
{
    v_HandleFileSysChange(lEvent, pidl1, pidl2);

    // WARNING: In all cases _pbbd will have NULL contents before first navigate.

    if (_pbbd->_psvPending) {
        return;
    }

    // stuff that needs to be done tree or no tree
    switch (lEvent) {

    // README:
    // If you need to add events here, then you must change SHELLBROWSER_FSNOTIFY_FLAGS in
    // order to get the notifications
        
    case SHCNE_RENAMEFOLDER:
    {
        // the rename might be ourselfs or our parent... if it's
        // our parent, we want to tack on the child idl's from the renamed
        // parent to us onto the new pidl (pidlExtra).
        // then show that result.
        LPCITEMIDLIST pidlChild = ILFindChild(pidl1, _pbbd->_pidlCur);
        if (pidlChild) 
        {
            LPITEMIDLIST pidlTarget = ILCombine(pidl2, pidlChild);
            if (pidlTarget)
            {
                LPITEMIDLIST pidlReal = _SimpleToReal(pidlTarget);
                if (pidlReal) 
                {
                    if (!ILIsEqual(pidlReal, _pbbd->_pidlCur))
                    {
                        BrowseObject(pidlReal, SBSP_REDIRECT | SBSP_SAMEBROWSER);
                    }
                    ILFree(pidlReal);
                }
                ILFree(pidlTarget);
            }
        }
    }
    // fall through
    case SHCNE_UPDATEITEM:
        // the name could have changed
        if (ILIsEqual(_pbbd->_pidlCur, pidl1))
            _SetTitle(NULL);
        break;

    case SHCNE_UPDATEIMAGE:
        IUnknown_CPContainerInvokeParam(_pbbd->_pautoEDS,
                DIID_DWebBrowserEvents2, DISPID_TITLEICONCHANGE, NULL, 0);
#ifdef DEBUG
        if (_pbbd->_pautoEDS)
        {
            // Verify that every IExpDispSupport also supports IConnectionPointContainer
            IConnectionPointContainer *pcpc;
            IExpDispSupport* peds;

            if (SUCCEEDED(_pbbd->_pautoEDS->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpc)))
            {
                pcpc->Release();
            }
            else if (SUCCEEDED(_pbbd->_pautoEDS->QueryInterface(IID_IExpDispSupport, (void **)&peds)))
            {
                peds->Release();
                AssertMsg(0, TEXT("IExpDispSupport without IConnectionPointContainer for %08x"), _pbbd->_pautoEDS);
            }
        }
#endif
        v_SetIcon();
        break;
    }
}

//---------------------------------------------------------------------------
// Helper Function to see if a pidl is on a network drive which is not
// persistent.  This is useful if we are shuting down and saving a list
// of the open windows to restore as we won't be able to restore these.

BOOL FPidlOnNonPersistentDrive(LPCITEMIDLIST pidl)
{
    TCHAR szPath[MAX_PATH];
    HANDLE hEnum;
    BOOL fRet = TRUE;

    TraceMsg(DM_SHUTDOWN, "csb.wp: FPidlOnNonPersistentDrive(pidl=%x)", pidl);
    if (!SHGetPathFromIDList(pidl, szPath) || (szPath[0] == TEXT('\0')))
        return(FALSE);  // not file system pidl assume ok.

    TraceMsg(DM_SHUTDOWN, "csb.wp: FPidlOnNonPersistentDrive - After GetPath=%s)", szPath);
    if (PathIsUNC(szPath) || !IsNetDrive(DRIVEID(szPath)))
    {
        fRet = FALSE;
        goto End;
    }

    // Ok we got here so now we have a network drive ...
    // we will have to enumerate over
    //
    if (WNetOpenEnum(RESOURCE_REMEMBERED, RESOURCETYPE_DISK,
            RESOURCEUSAGE_CONTAINER | RESOURCEUSAGE_ATTACHED,
            NULL, &hEnum) == WN_SUCCESS)
    {
        DWORD dwCount=1;
        union
        {
            NETRESOURCE nr;         // Large stack usage but I
            TCHAR    buf[1024];      // Dont think it is thunk to 16 bits...
        }nrb;

        DWORD   dwBufSize = sizeof(nrb);

        while (WNetEnumResource(hEnum, &dwCount, &nrb.buf,
                &dwBufSize) == WN_SUCCESS)
        {
            // We only want to add items if they do not have a local
            // name.  If they had a local name we would have already
            // added them!
            if ((nrb.nr.lpLocalName != NULL) &&
                    (CharUpperChar(*(nrb.nr.lpLocalName)) == CharUpperChar(szPath[0])))
            {
                fRet = FALSE;
                break;
            }
        }
        WNetCloseEnum(hEnum);
    }

End:
    TraceMsg(DM_TRACE, "c.c_arl: %s, is Persistent? %d", szPath, fRet);
    return(fRet);


}

void HackToPrepareForEndSession(LPCITEMIDLIST pidl)
{
    TCHAR szPath[MAX_PATH];

    TraceMsg(DM_SHUTDOWN, "csb.wp: HackToPrepareForEndSession(pidl=%x)", pidl);
    SHGetPathFromIDList(pidl, szPath);
}

//---------------------------------------------------------------------------
// returns:
//      TRUE if the user wants to abort the startup sequence
//      FALSE keep going
//
// note: this is a switch, once on it will return TRUE to all
// calls so these keys don't need to be pressed the whole time
BOOL AbortStartup()
{
    static BOOL bAborted = FALSE;       // static so it sticks!

    // TraceMsg(DM_TRACE, "Abort Startup?");

    if (bAborted)
        return TRUE;    // don't do funky startup stuff
    else {
        bAborted = (GetSystemMetrics(SM_CLEANBOOT) || ((GetAsyncKeyState(VK_CONTROL) < 0) || (GetAsyncKeyState(VK_SHIFT) < 0)));
        return bAborted;
    }
}

//---------------------------------------------------------------------------
// Restore all of the window that asked to save a command line to be
// restarted when windows was exited.
//
BOOL AddToRestartList(DWORD dwFlags, LPCITEMIDLIST pidl)
{
    int cItems = 0;
    DWORD cbData = sizeof(cItems);
    TCHAR szSubKey[80];
    BOOL fRet = FALSE;
    IStream *pstm;

    // cases that we don't want to save window state for...

    if (SHRestricted(REST_NOSAVESET) || FPidlOnNonPersistentDrive(pidl) || !_PersistOpenBrowsers())
        return FALSE;

    HKEY hkRestart = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, TEXT("RestartCommands"), TRUE);
    if (hkRestart)
    {
        if (ERROR_SUCCESS != (SHGetValueGoodBoot(hkRestart, NULL, TEXT("Count"), NULL, (BYTE *)&cItems, &cbData)))
            cItems = 0;

        // Now Lets Create a registry Stream for this guy...
        wnsprintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%d"), cItems);
        pstm = OpenRegStream(hkRestart, NULL, szSubKey, STGM_WRITE);
        TraceMsg(DM_SHUTDOWN, "csb.wp: AddToRestartList(pstm=%x)", pstm);
        if (pstm)
        {
            WORD wType = (WORD)-1;    // sizeof of cmd line == -1 implies pidl...

            // Now Write a preamble to the start of the line that
            // tells wType that this is an explorer
            pstm->Write(&wType, sizeof(wType), NULL);

            // Now Write out the version number of this stream
            // Make sure to inc the version number if the structure changes
            pstm->Write(&c_wVersion, sizeof(c_wVersion), NULL);

            // Now Write out the dwFlags
            pstm->Write(&dwFlags, sizeof(dwFlags), NULL);
            
            // And the pidl;
            ILSaveToStream(pstm, pidl);

            // And Release the stream;
            pstm->Release();

            cItems++;   // Say that there are twice as many items...

            fRet = (ERROR_SUCCESS == SHSetValue(hkRestart, NULL, TEXT("Count"), REG_BINARY, &cItems, sizeof(cItems)));
        }
        RegCloseKey(hkRestart);
    }

    return fRet;
}

//---------------------------------------------------------------------------
void SHCreateSavedWindows(void)
{
    HKEY hkRestart = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, TEXT("RestartCommands"), FALSE);
    if (_PersistOpenBrowsers() && hkRestart)
    {
        int cItems = 0;
        DWORD cbData = sizeof(cItems);


        SHGetValueGoodBoot(hkRestart, NULL, TEXT("Count"), NULL, (PBYTE)&cItems, &cbData);

        // walk in the reverse order that they were added.
        for (cItems--; cItems >= 0; cItems--)
        {
            TCHAR szName[80];
            IStream *pstm;

            if (AbortStartup())
                break;

            wnsprintf(szName, ARRAYSIZE(szName), TEXT("%d"), cItems);
            pstm = OpenRegStream(hkRestart, NULL, szName, STGM_READ);
            if (pstm)
            {
                WORD wType;
                if (SUCCEEDED(pstm->Read(&wType, sizeof(wType), NULL)))
                {
                    if (wType == (WORD)-1)
                    {
                        WORD wVersion;
                        DWORD dwFlags;
                        LPITEMIDLIST pidl = NULL;       // need to be inited for ILLoadFromStream()

                        // We have a folder serialized so get:
                        //     WORD:wVersion, DWORD:dwFlags, PIDL:pidlRoot, PIDL:pidl

                        if (SUCCEEDED(pstm->Read(&wVersion, sizeof(wVersion), NULL)) &&
                            (wVersion == c_wVersion) &&
                            SUCCEEDED(pstm->Read(&dwFlags, sizeof(dwFlags), NULL)) && 
                            SUCCEEDED(ILLoadFromStream(pstm, &pidl)) && pidl)
                        {
                            // this call does window instance management 
                            IETHREADPARAM* piei = SHCreateIETHREADPARAM(NULL, 0, NULL, NULL);
                            if (piei) 
                            {
                                piei->pidl = pidl;
                                pidl = NULL;     // so this is not freed below
                                piei->uFlags = dwFlags;
                                piei->nCmdShow = SW_SHOWDEFAULT;
                                SHOpenFolderWindow(piei);
                            }
                            ILFree(pidl);
                        }
                    }
                    else if (wType < MAX_PATH)
                    {
                        // I don't think this is ever used.
                        CHAR aszScratch[MAX_PATH];
                        pstm->Read(aszScratch, wType, NULL);
                        WinExec(aszScratch, SW_SHOWNORMAL);      // the show cmd will be ignored
                    }
                }
                pstm->Release();
            }
        }
    }

    if (hkRestart)
    {
        SHDeleteKeyA(hkRestart, NULL);
        RegCloseKey(hkRestart);
    }
}


//
//  This code intercept the WM_CONTEXTMENU message from USER and popups
// up the context menu of the folder itself when the user clicks the icon
// at the left-top corner of the frame (only when it is in the folder mode).
//
BOOL CShellBrowser2::v_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    BOOL fProcessed = FALSE;

    TraceMsg(DM_TRACE, "csb.ocm Got WM_CONTEXTMENU");
    
    if (_pbbd->_pidlCur && !ILIsEmpty(_pbbd->_pidlCur) && SendMessage(_pbbd->_hwnd, WM_NCHITTEST, 0, lParam) == HTSYSMENU)
    {
        IShellFolder *psfParent;
        LPCITEMIDLIST pidlChild;

        if (SUCCEEDED(IEBindToParentFolder(_pbbd->_pidlCur, &psfParent, &pidlChild))) 
        {
            IContextMenu * pcm;
            HRESULT hres = psfParent->GetUIObjectOf(_pbbd->_hwnd, 1, (LPCITEMIDLIST*)&pidlChild, IID_IContextMenu, NULL, (void **)&pcm);
            if (SUCCEEDED(hres))
            {
                HMENU hpopup = LoadMenuPopup(MENU_SYSPOPUP);
                if (hpopup)
                {
                    pcm->QueryContextMenu(hpopup, GetMenuItemCount(hpopup), IDSYSPOPUP_FIRST, IDSYSPOPUP_LAST, 0);

                    // Open doesn't make sense, since you're already looking at the folder
                    ContextMenu_DeleteCommandByName(pcm, hpopup, IDSYSPOPUP_FIRST, L"open");

                    // These are just confusing
                    ContextMenu_DeleteCommandByName(pcm, hpopup, IDSYSPOPUP_FIRST, L"delete");
                    ContextMenu_DeleteCommandByName(pcm, hpopup, IDSYSPOPUP_FIRST, L"link");

                    // The above may have allowed two separators to now be adjascent
                    _SHPrettyMenu(hpopup);

                    // For sendto menu, we go on even if this fails
                    pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm));
                    
                    if (GetMenuItemCount(hpopup) > 1) 
                    {
                        // only do this if the context menu added something...
                        // otherwise we end up with nothing but a "close" menu
                        
                        fProcessed=TRUE;
                        UINT idCmd = TrackPopupMenu(hpopup,
                                               TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                               GET_X_LPARAM(lParam),
                                               GET_Y_LPARAM(lParam),
                                               0, _pbbd->_hwnd, NULL);

                        switch(idCmd)
                        {
                        case 0:
                            break;  // canceled

                        case IDSYSPOPUP_CLOSE:
                            _pbbd->_pautoWB2->Quit();
                            break;

                        default:
                        {
                            TCHAR szPath[MAX_PATH];
                            // unless we KNOW that our target can handle CommandInfoEx, we cannot send it to them
                            CMINVOKECOMMANDINFO ici = {
                                sizeof(ici),
                                0L,
                                _pbbd->_hwnd,
                                (LPSTR)MAKEINTRESOURCE(idCmd - IDSYSPOPUP_FIRST),
                                NULL, NULL,
                                SW_NORMAL
                            };
#ifdef UNICODE
                            CHAR szPathAnsi[MAX_PATH];
                            SHGetPathFromIDListA(_pbbd->_pidlCur, szPathAnsi);
                            SHGetPathFromIDList(_pbbd->_pidlCur, szPath);
                            ici.lpDirectory = szPathAnsi;
//                            ici.lpDirectoryW = szPath;
                            ici.fMask |= CMIC_MASK_UNICODE;
#else
                            SHGetPathFromIDList(_pbbd->_pidlCur, szPath);
                            ici.lpDirectory = szPath;
#endif
                            pcm->InvokeCommand(&ici);
                            break;
                        }
                        }
                    }

                    ATOMICRELEASE(_pcm);
                    DestroyMenu(hpopup);
                }
                pcm->Release();
            }
            psfParent->Release();

        }
    }
    return fProcessed;
}

void CShellBrowser2::_OnClose(BOOL fPushed)
{
    // We can't close if it's nested.
    if (fPushed) 
    {
#ifdef NO_MARSHALLING
        // IEUNIX : Mark this window  for delayed deletion from the main message
        // pump. The problem is , if scripting closes a window and immediately 
        // opens a modal dialog. The WM_CLOSE message  for the browser window is
        // dispatched from the modal loop and we end up being called from the 
        // window proc. This  happens a lot on UNIX because we have multiple 
        // browser windows on the same thread.
        if (!_fDelayedClose)
            _fDelayedClose = TRUE;
        else
#endif
        MessageBeep(0);
        return;
    }

    if (SHIsRestricted2W(_pbbd->_hwnd, REST_NoBrowserClose, NULL, 0))
        return;

    // We are not supposed to process WM_CLOSE if modeless operation is
    // disabled.
    if (S_OK == _DisableModeless()) 
    {
        TraceMsg(DM_ERROR, "CShellBrowser2::_OnClose called when _DisableModeless() is TRUE. Ignored.");
        MessageBeep(0);
        UINT id = MLShellMessageBox(_pbbd->_hwnd,
               MAKEINTRESOURCE(IDS_CLOSEANYWAY),
               MAKEINTRESOURCE(IDS_TITLE),
               MB_OKCANCEL | MB_SETFOREGROUND | MB_ICONSTOP);
        if (id == IDCANCEL) 
        {
#ifdef NO_MARSHALLING
            _fReallyClosed = FALSE;
#endif
            return;
        }
    }

#ifdef NO_MARSHALLING
    _fReallyClosed = TRUE;
#endif

    // we cannot close in the middle of creating view window.  
    // someone dispatched messages and it wasn't us...
    // we WILL fault.
    // FEATURE:  after ie3, we can flag this and close when we're done tryingto create the
    // viewwindow
    if (_pbbd->_fCreatingViewWindow)
        return;

    // The dochost needs to know that we are shutting
    // down so that it do such things send an Exec to 
    // Trident to tell it we are unloading. 
    //
    Exec(&CGID_Explorer, SBCMDID_ONCLOSE, 0, NULL, NULL);

    if (_MaySaveChanges() != S_FALSE) 
    {
        // Close the browse context and release it.
        IHlinkBrowseContext * phlbc = NULL;
        
        if (_pbbd->_phlf)
            _pbbd->_phlf->GetBrowseContext(&phlbc);
        
        if (phlbc) 
        {
            _pbbd->_phlf->SetBrowseContext(NULL);
            phlbc->Close(0);
            phlbc->Release();
        }

        FireEvent_Quit(_pbbd->_pautoEDS);
        
        // this is once we KNOW that we're going to close down
        // give subclasses a chance to clean up
#ifdef NO_MARSHALLING
        RemoveBrowserFromList(this);
#endif
        _OnConfirmedClose();
    }


    //
    // NOTES: Originally, this call was made only for RISC platform.
    //  We, however, got a request from ISVs that their OCs should be
    //  unloaded when the user closes the window.
    //
    //  On risc NT we need to call CoFreeUnusedLibraries in case any x86 dlls
    //  were loaded by Ole32. We call this after calling _OnClose so that
    //  we can even unload the OC on the current page. (SatoNa)
    //
    CoFreeUnusedLibraries();
}

//
// stolen from comctl32
//
// in:
//      hwnd    to do check on
//      x, y    in client coordinates
//
// returns:
//      TRUE    the user began to drag (moved mouse outside double click rect)
//      FALSE   mouse came up inside click rect
//
// FEATURE, should support VK_ESCAPE to cancel

BOOL CheckForDragBegin(HWND hwnd, int x, int y)
{
    RECT rc;
    int dxClickRect = GetSystemMetrics(SM_CXDRAG);
    int dyClickRect = GetSystemMetrics(SM_CYDRAG);

    ASSERT((dxClickRect > 1) && (dyClickRect > 1));

    // See if the user moves a certain number of pixels in any direction

    SetRect(&rc, x - dxClickRect, y - dyClickRect, x + dxClickRect, y + dyClickRect);

    MapWindowRect(hwnd, NULL, &rc);

    SetCapture(hwnd);

    do 
    {
        MSG msg;

        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            // See if the application wants to process the message...
            if (CallMsgFilter(&msg, MSGF_COMMCTRL_BEGINDRAG) != 0)
                continue;

            switch (msg.message) {
            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                ReleaseCapture();
                return FALSE;

            case WM_MOUSEMOVE:
                if (!PtInRect(&rc, msg.pt)) 
                {
                    ReleaseCapture();
                    return TRUE;
                }
                break;

            default:
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                break;
            }
        }

        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
    } while (GetCapture() == hwnd);

    return FALSE;
}

void CShellBrowser2::_SetTheaterBrowserBar()
{
#ifndef DISABLE_FULLSCREEN
    if (_ptheater) {
        IDeskBar *pdbBar = NULL;
        
        FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdbBar));
        
        _ptheater->SetBrowserBar(pdbBar, 120, 200);
        
        if (pdbBar)
            pdbBar->Release();
    }
#endif
}

void CShellBrowser2::_TheaterMode(BOOL fShow, BOOL fRestorePrevious)
{
#ifndef DISABLE_FULLSCREEN
    if (BOOLIFY(fShow) == BOOLIFY(_ptheater))
        return;
    
    WINDOWPLACEMENT wp;
    RECT rc;
    if (fRestorePrevious && !fShow) {
        _ptheater->GetPreviousWindowPlacement(&wp, &rc);
    } else 
        fRestorePrevious = FALSE;
        
    HRESULT hresResize = _pbsInner->AllowViewResize(FALSE);
    
    if (!fShow) 
    {    
        if (_ptheater) {            
            if (fRestorePrevious) {
                PutBaseBrowserData()->_hwnd = _ptheater->GetMasterWindow();
#ifndef UNIX
                SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_DLGFRAME | WS_THICKFRAME | WS_BORDER, WS_DLGFRAME | WS_THICKFRAME | WS_BORDER);
#else
                SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_DLGFRAME | WS_THICKFRAME | WS_BORDER, 0);
#endif
                SetWindowPos(_pbbd->_hwnd, NULL, 0, 0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_FRAMECHANGED);
            }
            delete _ptheater;
            _ptheater = NULL;
        }
    } 
    else 
    {
        _SaveITbarLayout();
        _SaveState();
        SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_DLGFRAME | WS_THICKFRAME, 0);
        // if we're going to theater mode, don't allow best fit stuff
        _fsd._fs.fFlags &= ~FWF_BESTFITWINDOW;
        
        HWND hwndToolbar = NULL;
        
        if (_GetITBar())
            _GetITBar()->GetWindow(&hwndToolbar);

        _ptheater = new CTheater(_pbbd->_hwnd, hwndToolbar, (IOleCommandTarget*)this);
        if (_ptheater) 
        {
            _SetTheaterBrowserBar();

            // the progress control is a bit special in this mode.  we pull this out and make it topmost.
            _ShowHideProgress();
        }
    }
    
    // the itbar is special in that it stays with the auto-hide window.
    // it needs to know about theater mode specially
    // Also, set _ptheater->_fAutoHideToolbar to _pitbar->_fAutoHide
    VARIANT vOut = { VT_I4 };
    vOut.lVal = FALSE;  // default: no auto hide explorer toolbar
    IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_THEATER, fShow ? THF_ON : THF_OFF, &vOut, &vOut);

    if (_ptheater)
    {
        _ptheater->SetAutoHideToolbar(vOut.lVal);
    }

    _pbsInner->AllowViewResize(hresResize == S_OK);
    SUPERCLASS::OnSize(SIZE_RESTORED);

    if (_ptheater)
        _ptheater->Begin();     // kick start!

    // notify trident that it's ambients are invalid to force
    // it to re-query us for the flat property
    if (_pbbd->_pctView) 
    {
        VARIANTARG vaIn;
        vaIn.vt = VT_I4;
        vaIn.lVal = DISPID_UNKNOWN;

        _pbbd->_pctView->Exec(&CGID_ShellDocView, SHDVID_AMBIENTPROPCHANGE, NULL, &vaIn, NULL);
    }

    if (_pxtb) 
    {
        UINT uiState;
        if (SUCCEEDED(_pxtb->GetState(&CLSID_CommonButtons, TBIDM_THEATER, &uiState))) 
        {
            if (_ptheater)
                uiState |= TBSTATE_CHECKED;
            else
                uiState &= ~TBSTATE_CHECKED;
            
            _pxtb->SetState(&CLSID_CommonButtons, TBIDM_THEATER, uiState);
        }
    }

    if (!_ptheater && !_fShowMenu)
        IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_SHOWMENU, FALSE, NULL, NULL);

    if (fRestorePrevious) 
    {
        SetWindowPos(_pbbd->_hwnd, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), 0);
        if (IsWindowVisible(_pbbd->_hwnd)) 
        {
            ShowWindow(_pbbd->_hwnd, wp.showCmd);
            SetWindowPlacement(_pbbd->_hwnd, &wp);
        }
    }
#endif /* !DISABLE_FULLSCREEN */
}

BOOL CShellBrowser2::_OnSysMenuClick(BOOL bLeftClick, WPARAM wParam, LPARAM lParam)
{
    POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
    DWORD dwStart = GetTickCount();

    MapWindowPoints(NULL, _pbbd->_hwnd, &pt, 1);

    if (!CheckForDragBegin(_pbbd->_hwnd, pt.x, pt.y))
    {
        if (bLeftClick)
        {
            DWORD dwDelta = (GetTickCount() - dwStart);
            DWORD dwDblClick = GetDoubleClickTime();

            if (dwDelta < dwDblClick)
            {
                // HACK: use the lParam (coords) as the timer ID to communicate
                // that to the WM_TIMER handler
                //
                // HACK: store the timer id in a global. Since there's only one
                // double-click on a sysmenu at a time, this should be fine.
                if (g_sysmenuTimer)
                    KillTimer(_GetCaptionWindow(), g_sysmenuTimer);

                // We are special casing 0 as meaning there is no timer, so if the coords come in at
                // 0 then cheat them to 1.
                if (lParam == 0)
                    lParam++;

                g_sysmenuTimer = SetTimer(_GetCaptionWindow(), lParam, dwDblClick - dwDelta, NULL);
            }
            else
                DefWindowProcWrap(_pbbd->_hwnd, WM_CONTEXTMENU, (WPARAM)_pbbd->_hwnd, lParam);
        }
        else
            SendMessage(_pbbd->_hwnd, WM_CONTEXTMENU, (WPARAM)_pbbd->_hwnd, lParam);
        return FALSE;
    }
    IOleCommandTarget *pcmdt = NULL;
    if (_pbbd->_pautoWB2)
    {
        (_pbbd->_pautoWB2)->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
        ASSERT(pcmdt);
    }
    
    BOOL fRet = DoDragDropWithInternetShortcut(pcmdt, _pbbd->_pidlCur, _pbbd->_hwnd);
    
    if (pcmdt)
        pcmdt->Release();

    return fRet;
}

void _SetWindowsListMarshalled(IWebBrowser2 *pautoWB2)
{
    IEFrameAuto* pief;
    if (SUCCEEDED(pautoWB2->QueryInterface(IID_IEFrameAuto, (void **)&pief))) 
    {
        pief->OnWindowsListMarshalled();
        pief->Release();
    }
}

BOOL CShellBrowser2::_OnTimer(UINT_PTR idTimer)
{
    BOOL fResult = FALSE;

    // HACK: _OnSysMenuClick uses the cursor coords as the timer ID.
    // So first check if g_sysmenuTimer is set before checking for
    // standard timer IDs.
    
    if (g_sysmenuTimer == idTimer)
    {
        KillTimer(_GetCaptionWindow(), g_sysmenuTimer);
        g_sysmenuTimer = 0;

        // the timer ID is the lParam from the left click!
        SendMessage(_GetCaptionWindow(), WM_SYSMENU, 0, idTimer);
        fResult = TRUE;
    }
    else
    {
        switch (idTimer)
        {
        case SHBTIMER_MENUSELECT:
            KillTimer(_pbbd->_hwnd, SHBTIMER_MENUSELECT);
            fResult = TRUE;

            if (_pidlMenuSelect)
            {
                _DisplayFavoriteStatus(_pidlMenuSelect);
                Pidl_Set(&_pidlMenuSelect, NULL);
            }
            break;
        }
    }
    return fResult;
}


void CShellBrowser2::_OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (LOWORD(wParam) == WA_INACTIVE)
        _fActivated = FALSE;
    else
        _fActivated = TRUE;

    if (_pbbd->_hwndView)
        SendMessage(_pbbd->_hwndView, uMsg, wParam, lParam);

    if (LOWORD(wParam) != WA_INACTIVE)
    {
        // remember who had focus last, since trident will
        // grab focus on an OnFrameWindowActivate(TRUE)
        int itbLast = _pbsOuter->_get_itbLastFocus();

        _pbsOuter->OnFrameWindowActivateBS(TRUE);

        if (itbLast != ITB_VIEW)
        {
            // restore focus to its rightful owner
            LPTOOLBARITEM ptbi = _GetToolbarItem(itbLast);
            if (ptbi)
                IUnknown_UIActivateIO(ptbi->ptbar, TRUE, NULL);
        }
    }
    else
    {
#ifdef KEYBOARDCUES
        if (_pbbd->_hwnd)
        {
            SendMessage(_pbbd->_hwnd, WM_CHANGEUISTATE,
                MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
        }
#endif
        _pbsOuter->OnFrameWindowActivateBS(FALSE);
    }
}


// Main window proc for CShellBrowser2

LRESULT CShellBrowser2::WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;

    if (_TranslateMenuMessage(hwnd, uMsg, &wParam, &lParam, &lRet))
        return lRet;

    switch(uMsg)
    {
    case WMC_DISPATCH:
        BSTR Url;
        {

            HRESULT hres;
            switch(wParam) {
            case DSID_NOACTION:
                return S_OK;
           
            case DSID_NAVIGATEIEBROWSER:
//
//  APPCOMPAT: To be fully compatible with IE 2.0, we don't want to use
// the window that has a navigation in progress. Enabling this code,
// however, causes some problem with the very first DDE. I need to
// investigate more, IF we need that level of compatibility. (SatoNa)
//
                
                // this is only used for IE Browser.
                // if this is not in iemode, then fail.
                // this prevents us from reusing C:\ to navigate to www
                if  (!v_IsIEModeBrowser())
                    return E_FAIL;

                ASSERT(lParam);
                if (!lParam)
                    break;
                Url = ((DDENAVIGATESTRUCT*)lParam)->wszUrl;
                hres = _pbbd->_pautoWB2->Navigate(Url, NULL, NULL, NULL, NULL);
                return hres;
                break;

            case DSID_GETLOCATIONURL:
                return _pbbd->_pautoWB2->get_LocationURL((BSTR*)lParam);

            case DSID_GETLOCATIONTITLE:
                return _pbbd->_pautoWB2->get_LocationName((BSTR*)lParam);
            
            case DSID_GETHWND:
                *(HWND*)lParam = hwnd;
                return S_OK;
#if 0
            case DSID_CANCEL:
                return _pbbd->_pautoWB2->Stop();
#endif
            case DSID_EXIT:
                return _pbbd->_pautoWB2->Quit();
            }
        }
        return (LRESULT)HRESULT_FROM_WIN32(ERROR_BUSY);
        
    case CWM_CLONEPIDL:
        if (_pbbd->_pidlCur)
        {
            return (LRESULT)SHAllocShared(_pbbd->_pidlCur, ILGetSize(_pbbd->_pidlCur), (DWORD)wParam);
        }
        break;
        
    case CWM_SELECTITEM:
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)SHLockShared((HANDLE)lParam, GetCurrentProcessId());
        if (pidl)
        {
            if (_pbbd->_psv) 
                _pbbd->_psv->SelectItem(pidl, (UINT)wParam);
            SHUnlockShared(pidl);
        }
        SHFreeShared((HANDLE)lParam, GetCurrentProcessId());   // Receiver responsible for freeing
        break;
    }
    
    case CWM_THEATERMODE:
        _TheaterMode(BOOLFROMPTR(wParam), !wParam);
        break;
        
    case CWM_GLOBALSTATECHANGE:
        // need to update the title
        if (wParam == CWMF_GLOBALSTATE)
            _SetTitle(NULL);
        else if (wParam == CWMF_SECURITY)
        {
            _UpdateZonesPane(NULL);
        }
        break;

        
    case CWM_FSNOTIFY:
        _OnFSNotify(wParam, lParam);
        break;
        
    case CWM_UPDATEBACKFORWARDSTATE:
        _UpdateBackForwardStateNow();
        break;

    case CWM_SHOWDRAGIMAGE:
        return DAD_ShowDragImage((BOOL)lParam);

    case WM_ENDSESSION:
        TraceMsg(DM_SHUTDOWN, "csb.wp: WM_ENDSESSION wP=%d lP=%d", wParam, lParam);
        if (wParam && IsWindowVisible(_pbbd->_hwnd) && _pbbd->_pidlCur && !_fUISetByAutomation) 
        {
            TraceMsg(DM_SHUTDOWN, "csb.wp: call AddToRestartList");
            if (!IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_NO_REOPEN_NEXT_RESTART))
                AddToRestartList(v_RestartFlags(), _pbbd->_pidlCur);

            // for now we use the same 12-hour (SessionTime) rule
            // possibly we should just do it always?
            UEMFireEvent(&UEMIID_BROWSER, UEME_CTLSESSION, UEMF_XEVENT, FALSE, -1);
            if (!g_bRunOnNT5) {
                // for down-level guys (old explorer), fake a shell end session too
                UEMFireEvent(&UEMIID_SHELL, UEME_CTLSESSION, UEMF_XEVENT, FALSE, -1);
            }
            // And make sure we have saved it's state out
            TraceMsg(DM_SHUTDOWN, "csb.wp: call _SaveState");
            _SaveState();
        }
        TraceMsg(DM_SHUTDOWN, "csb.wp: WM_ENDSESSION return 0");
        break;

    case WM_TIMER:
        if (!_OnTimer(wParam))
            goto DoDefault;
        break;

    case WM_NCLBUTTONDOWN:
    case WM_NCRBUTTONDOWN:
        if (wParam != HTSYSMENU)
            goto DoDefault;

        _OnSysMenuClick(uMsg == WM_NCLBUTTONDOWN, wParam, lParam);
        break;

    case WM_NCLBUTTONDBLCLK:
        // We fault while shutting down the window if the timing is bad.
        // We're not sure why, but USER get's mightily confused. The only
        // difference between this scheme and a normal double-click-on-sysmenu
        // is the timer we have hanging around. Kill the timer before
        // processing this message. Hopefully that will work [mikesh/cheechew]
        //
        // HACK: remember this timer id is stored in a global variable
        //
        if (g_sysmenuTimer)
        {
            KillTimer(_GetCaptionWindow(), g_sysmenuTimer);
            g_sysmenuTimer = 0;
        }

        // We still want to process this DBLCLK
        goto DoDefault;
        
    case WM_CONTEXTMENU:
        if (!v_OnContextMenu(wParam, lParam))
            goto DoDefault;
        break;

    case WM_WININICHANGE:
        {
            DWORD dwSection = SHIsExplorerIniChange(wParam, lParam);

            // Hack for NT4 and Win95, where there is no SPI_GETMENUSHOWDELAY
            // Don't need to check wParam == SPI_SETMENUSHOWDELAY since we
            // always query afresh on NT5/Win98.
            if (dwSection & EICH_SWINDOWS)
                g_lMenuPopupTimeout = -1; /* in case MenuShowDelay changed */

            // Transitioning to/from "Working Offline" just broadcasts (0,0)
            // so that's all we listen for
            if (dwSection == EICH_UNKNOWN)
            {
                _ReloadTitle();
                _ReloadStatusbarIcon();
            }
        }
        goto DoDefault;

    case WM_INITMENUPOPUP:
        v_OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam));
        v_ForwardMenuMsg(uMsg, wParam, lParam);
        break;

    case WM_MENUSELECT:
#ifdef UNIX
        /* IEUNIX:  Avoid getting delayed timer messages, which screws up 
           statusbar. */
        if (_pidlMenuSelect) {
            KillTimer(_pbbd->_hwnd, SHBTIMER_MENUSELECT);
            Pidl_Set(&_pidlMenuSelect, NULL);
        }
#endif

        if (_ShouldForwardMenu(uMsg, wParam, lParam)) 
        {
            ForwardViewMsg(uMsg, wParam, lParam);
        } 
        else
        {
            BOOL fIsPopup = GET_WM_MENUSELECT_FLAGS(wParam, lParam) & MF_POPUP;

            if ((!_OnMenuSelect(wParam, lParam, 0) &&
                 (fIsPopup || IsInRange(LOWORD(wParam), FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST)))

                || (_fDispatchMenuMsgs && fIsPopup))
            {
                ForwardViewMsg(uMsg, wParam, lParam);
            }

        }
        
        break;
        
    case WM_EXITSIZEMOVE:
        _fDisallowSizing = FALSE;
        break;

    case WM_WINDOWPOSCHANGING:
        if (_fDisallowSizing) 
        {
            LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;
            pwp->flags |= SWP_NOMOVE | SWP_NOSIZE;
        }
        break;
        
    case WM_ENTERSIZEMOVE:
        if (_ptheater)
            _fDisallowSizing = TRUE;
        break;

    case WM_EXITMENULOOP:
    case WM_ENTERMENULOOP:
        ForwardViewMsg(uMsg, wParam, lParam);
        break;

    case WM_DRAWITEM:
    case WM_MEASUREITEM:
        if (_ShouldForwardMenu(uMsg, wParam, lParam))
            ForwardViewMsg(uMsg, wParam, lParam);
        else
        {
            UINT  idCmd;
        
            switch (uMsg)
            {
                case WM_MEASUREITEM:
                    idCmd = GET_WM_COMMAND_ID(((MEASUREITEMSTRUCT *)lParam)->itemID, 0);
                    break;
                case WM_DRAWITEM:
                    idCmd = GET_WM_COMMAND_ID(((LPDRAWITEMSTRUCT)lParam)->itemID, 0);
                    break;
            }
        
            if (InRange(idCmd, FCIDM_SEARCHFIRST, FCIDM_SEARCHLAST) && _pcmSearch)
                _pcmSearch->HandleMenuMsg(uMsg, wParam, lParam);
            else if (_pcmNsc && IsInRange(idCmd, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST))
                _pcmNsc->HandleMenuMsg(uMsg, wParam, lParam);
            else if (_pcm && (_pcm->HandleMenuMsg(uMsg, wParam, lParam) == S_OK))
            {
                // the context menu ate it
            }
            else
            {                
                v_ForwardMenuMsg(uMsg, wParam, lParam);
            }
        }            
        break;

    case WM_QUERYENDSESSION:
        TraceMsg(DM_SHUTDOWN, "csb.wp: WM_QUERYENDSESSION");
#ifdef DEBUG
        if (S_OK == _DisableModeless())
        {
            TraceMsg(DM_WARNING, "CSB::WndProc got WM_QUERYENDSESSION when disabled");
            MessageBeep(0);
            UINT id = MLShellMessageBox(_pbbd->_hwnd,
                   MAKEINTRESOURCE(IDS_CLOSEANYWAY),
                   MAKEINTRESOURCE(IDS_TITLE),
                   MB_OKCANCEL | MB_SETFOREGROUND | MB_ICONSTOP);
            if (id==IDCANCEL) {
                return FALSE;
            }
        }
#endif
        // Try calling something that will call SHGetPathFromIDList to make sure we won't
        // call GetProcAddress while processing the WM_ENDSESSION...
        if (_pbbd->_pidlCur)
            HackToPrepareForEndSession(_pbbd->_pidlCur);

        return TRUE;    // OK to close

    case WM_CLOSE:
#ifdef NO_MARSHALLING
        _OnClose(_fOnIEThread);
#else
        _OnClose(TRUE);
#endif
        break;      

    case PUI_OFFICE_COMMAND:
    {
        switch (wParam)
        {
        case PLUGUI_CMD_SHUTDOWN:
        {
            HRESULT hr;
            VARIANT v;

            // first, kill the internet options modal
            // property sheet if it exists
            // it might be open because that's one of
            // out UI lang change scenarios

            V_VT(&v) = VT_BYREF;
            v.byref = NULL;

            if (_pbbd != NULL && _pbbd->_pctView != NULL)
            {
                hr = _pbbd->_pctView->Exec(&CGID_ShellDocView, SHDVID_GETOPTIONSHWND, 0, NULL, &v);
                if (SUCCEEDED(hr))
                {
                    ASSERT(V_VT(&v) == VT_BYREF);

                    if (v.byref != NULL)
                    {
                        // close the lang change modal property sheet
                        SendMessage((HWND)v.byref, WM_CLOSE, NULL, NULL);
                    }
                }
            }

            // now try to close the browser in general
            if (_pbbd != NULL && _pbbd->_pautoWB2 != NULL)
                _pbbd->_pautoWB2->Quit();

            break;
        }

        case PLUGUI_CMD_QUERY:
        {
            HMODULE hMod;

            // answer if we're an iexplore.exe process because
            // that means we're not sharing any dlls with the shell

            hMod = GetModuleHandle(TEXT("IEXPLORE.EXE"));

            if (hMod != NULL && !g_bRunOnNT5)
            {
                PLUGUI_QUERY    puiQuery;

                ASSERT(!g_bRunOnNT5);

                // we indicate that we participate in plugUI shutdown by
                // returning the version number for Office 9

                puiQuery.uQueryVal = 0;
                puiQuery.PlugUIInfo.uMajorVersion = OFFICE_VERSION_9;
                puiQuery.PlugUIInfo.uOleServer = FALSE;
                return puiQuery.uQueryVal;
            }
            break;
        }
        } // switch (wParam)

        break; // PUI_OFFICE_COMMAND
    }

    case WM_SYSCOMMAND:
        //
        // WARNING: User uses low four bits for some undocumented feature
        //  (only for SC_*). We need to mask those bits to make this case
        //  statement work.
        //
        switch (wParam & 0xfff0) {
        case SC_MAXIMIZE:                        
            if (GetKeyState(VK_CONTROL) < 0)
            {
                LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
                if (ptbi->fShow)    
                    PostMessage(_pbbd->_hwnd, CWM_THEATERMODE, TRUE, 0);
                else
                    goto DoDefault;
            }
            else
                goto DoDefault;
            break;
            
        case SC_CLOSE:
            // Make it posted so that we can detect if it's nested.
            PostMessage(_pbbd->_hwnd, WM_CLOSE, 0, 0);
            break;
            
        case SC_MINIMIZE:
            goto DoDefault;

        case SC_RESTORE:
            if (_ptheater && !_fMinimized)
            {
                PostMessage(_pbbd->_hwnd, CWM_THEATERMODE, FALSE, 0);
                return 0;
            }                         
            goto DoDefault;        

        default:
            goto DoDefault;
        }
        break;

    case WM_SIZE:
        // WARNING: Remember that we won't get WM_SIZE if we directly process
        // WM_WINDOWPOSCHANGED.
        {
            BOOL fMinimized = (wParam == SIZE_MINIMIZED);

            if (BOOLIFY(_fMinimized) != fMinimized)
            {
                TraceMsg(DM_ONSIZE, "SB::_WndProc WM_SIZE _fMinimized %d -> %d",
                         _fMinimized, fMinimized);
    
                _fMinimized = fMinimized;

                // Pause/Resume toolbars (intentionally ignores _pbbd->_psvPending). 
                VARIANT var = { 0 };
                var.vt = VT_I4;
                var.lVal = !_fMinimized;
                _ExecChildren(NULL, TRUE, NULL, OLECMDID_ENABLE_INTERACTION, OLECMDEXECOPT_DONTPROMPTUSER, &var, NULL);

                // Pause/Resule the view (refrelcts _pbbd->_psvPending too). 
                _PauseOrResumeView(_fMinimized);
            }
        }
#ifndef DISABLE_FULLSCREEN
        if (_ptheater && !_fMinimized)
            _ptheater->RecalcSizing();
#endif
        goto DoDefault;

    case WM_ACTIVATE:
#ifdef UNIX
        if (_HandleActivation(wParam) == TRUE)
        {
            _OnActivate(uMsg, wParam, lParam);
            break;
        }
#endif
        _OnActivate(uMsg, wParam, lParam);
        break;

    case WM_SETFOCUS:
        goto DoDefault;

    case WM_MENUCHAR:
        {
            LRESULT lres = 0;

            // Forwarding for IContextMenu3. 
            UINT idCmd = GetMenuItemID((HMENU)lParam, 0); // approximately correct: assume the first item on the menu identifies the range

            if (_pcm && _pcm->HandleMenuMsg2(uMsg, wParam, lParam, &lres) == S_OK)
                ; // do nothing
            else if (_pcmSearch && _pcmSearch->HandleMenuMsg2(uMsg, wParam, lParam, &lres) == S_OK)
                ; // do nothing
            else if (_pcmNsc && InRange(idCmd, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST))
                SHForwardContextMenuMsg(_pcmNsc, uMsg, wParam, lParam, &lres, FALSE);
            else
                lres = v_ForwardMenuMsg(uMsg, wParam, lParam);
            return lres;
        }
        break;

    case WM_CREATE:
#ifdef KEYBOARDCUES
        SendMessage(hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
#endif
        lRet = SUPERCLASS::WndProcBS(hwnd, uMsg, wParam, lParam);
        if (lRet)
        {
            _OnClose(FALSE);
            _GetMenuBand(TRUE);
        }
        return lRet;

    case WMC_MARSHALIDISPATCHSLOW:
        {
#ifndef NO_MARSHALLING
            IStream *pIStream;
            HRESULT hres = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);
            if (SUCCEEDED(hres)) 
            {
                HANDLE hShared = NULL;
                _fMarshalledDispatch = TRUE;
                hres = CoMarshalInterface(pIStream, IID_IDispatch,
                    _pbbd->_pautoWB2, MSHCTX_NOSHAREDMEM, NULL, MSHLFLAGS_NORMAL);
                if (SUCCEEDED(hres))
                {
                    _SetWindowsListMarshalled(_pbbd->_pautoWB2);

                    ULARGE_INTEGER uliPos;
                    const LARGE_INTEGER li = {0,0};
                    pIStream->Seek(li, STREAM_SEEK_CUR, &uliPos);

                    // And point back to the beginning...
                    pIStream->Seek(li, STREAM_SEEK_SET, NULL);
    
                    hShared = SHAllocShared(NULL, uliPos.LowPart + sizeof(DWORD), (DWORD)lParam);
                    if (hShared)
                    {
                        LPBYTE pv = (LPBYTE)SHLockShared(hShared, (DWORD)lParam);
                        if (pv)
                        {
                            *((DWORD*)pv) = uliPos.LowPart;
                            pIStream->Read(pv + sizeof(DWORD), uliPos.LowPart, NULL);
                            SHUnlockShared(pv);
                        }
                        else
                        {
                            SHFreeShared(hShared, (DWORD)lParam);
                            hShared = NULL;
                        }
                    }
                }
                pIStream->Release();
                return (LRESULT)hShared;
            }
#else
            IDispatch **idispTemp = (IDispatch**)lParam;
            *idispTemp = _pbbd->_pautoWB2;
            return S_OK;
#endif
        }

    case WM_GETOBJECT:
        if (OBJID_MENU == lParam)
        {
            IAccessible* pacc;
            IMenuBand* pmb = _GetMenuBand(FALSE);

            if (pmb && SUCCEEDED(IUnknown_QueryService(pmb, SID_SMenuBandChild, 
                IID_PPV_ARG(IAccessible, &pacc))))
            {
                lRet = LresultFromObject(IID_IAccessible, wParam, pacc);
                pacc->Release();

                return lRet;
            }
        }
        break;

    default:
        lRet = _WndProcBSNT5(hwnd, uMsg, wParam, lParam);
        if (lRet)
            return lRet;

        if (_nMBIgnoreNextDeselect == uMsg)
        {
            _fIgnoreNextMenuDeselect = TRUE;
            TraceMsg(TF_MENUBAND, "MenuBand: Shbrowse.cpp received our private MBIgnoreNextDeselect");
            break;
        }
        else if (GetDDEExecMsg() == uMsg)
        {
            ASSERT(lParam && 0 == ((LPNMHDR)lParam)->idFrom);
            DDEHandleViewFolderNotify(this, _pbbd->_hwnd, (LPNMVIEWFOLDER)lParam);
            LocalFree((LPNMVIEWFOLDER)lParam);
            return TRUE;
        }
        else if (g_msgMSWheel == uMsg)
        {
            // Frame doesn't have scrollbar, let the view have a crack at it (309709)
            return SendMessage(_pbbd->_hwndView, uMsg, wParam, lParam);
        }

DoDefault:
        lRet = SUPERCLASS::WndProcBS(hwnd, uMsg, wParam, lParam);
        if (WM_COMMAND == uMsg)
        {
            IUnknown_SetSite(_pcmNsc, NULL);
            ATOMICRELEASE(_pcmNsc);
        }

        return lRet;
    }

    return 0;
}

HRESULT CShellBrowser2::OnSetFocus()
{
    TraceMsg(DM_FOCUS, "csb.osf: hf()=%d itbLast=%d", _HasToolbarFocus(), _get_itbLastFocus());
    // forward to whoever had focus last (view or toolbar).  i think this
    // was added for ie4:55511 to fix pblm w/ tabbing away from IE and
    // then back.  note the check of _get_itbLastFocus w/o the usual
    // _HasToolbarFocus/_FixToolbarFocus magic...
    //
    // this used to be in CCB::OSF but that's bogus since in the desktop
    // case, this means once a deskbar (e.g. address) has focus, we can
    // never get focus back on the desktop (nt5:167864).
    if (_get_itbLastFocus() == ITB_VIEW) {
        // forward it on to view (in basesb)
        _pbsInner->OnSetFocus();
    } else {
        LPTOOLBARITEM ptbi = _GetToolbarItem(_get_itbLastFocus());
        if (ptbi)
            IUnknown_UIActivateIO(ptbi->ptbar, TRUE, NULL);
    }
    return 0;
}


LRESULT CALLBACK IEFrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    CShellBrowser2* psb = (CShellBrowser2*)GetWindowPtr0(hwnd);

    switch(uMsg)
    {
    case WM_NCCREATE:
    {
        IETHREADPARAM* piei = (IETHREADPARAM*)((LPCREATESTRUCT)lParam)->lpCreateParams;

        ASSERT(psb == NULL);
#ifndef UNIX
        if (piei->uFlags & COF_EXPLORE) 
        {
            CExplorerBrowser_CreateInstance(hwnd, (void **)&psb);
        } 
        else
#endif
        {
            CShellBrowser2_CreateInstance(hwnd, (void **)&psb);
        }

        if (psb)
        {
            SetWindowLongPtr(hwnd, 0, (LONG_PTR)psb);

            _InitAppGlobals();
            // Hack: Let's try only registering dde on iexplorer windows for
            // shell speed.  (ie ignore shell folders)
            DWORD dwAttr = SFGAO_FOLDER;

            if ((!(piei->pidl &&
                   SUCCEEDED(IEGetAttributesOf(piei->pidl, &dwAttr)) &&
                   (dwAttr & SFGAO_FOLDER))) ||
                (piei->uFlags & COF_FIREEVENTONDDEREG))
            {
                //
                // Tell IEDDE that a new browser window is available.
                //
                IEDDE_NewWindow(hwnd);

                //
                // Fire the DdeRegistered event if necessary.
                //
                if (piei->uFlags & COF_FIREEVENTONDDEREG)
                {
                    ASSERT(piei->szDdeRegEvent[0]);
                    FireEventSzW(piei->szDdeRegEvent);
                }
            }
            return psb->WndProcBS(hwnd, uMsg, wParam, lParam);
        }
        else
        {
            return 0;
        }
    }

    case WM_CREATE:
    {
        lResult = psb ? psb->WndProcBS(hwnd, uMsg, wParam, lParam) : DefWindowProc(hwnd, uMsg, wParam, lParam);
 
        // if we have a psb and WndProc() failed (!lResult), then fall through
        // and process the WM_NCDESTROY.
        if (!psb || !lResult)
            break;

        if (psb)
            psb->_OnClose(FALSE);
        // Fall Thru because we need to clean up since the create failed.
        // fall through
    }

    case WM_NCDESTROY:

        //
        // Tell IEDDE that a browser window is no longer available.
        //
        IEDDE_WindowDestroyed(hwnd);

        // WM_NCDESTROY is supposed to be the last message we ever
        // receive, but let's be paranoid just in case...
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)0);
        
        // psb may be NULL if we failed to create the window.  An
        // Example includes using Start->Run to open a window to
        // a UNC share that the user doesn't have permissions to see.
        if (psb) 
        {
            psb->PutBaseBrowserData()->_hwnd = NULL;
            if (psb->_dwRegisterWinList)
            {
                if (psb->_fMarshalledDispatch)
                {
                    IShellWindows* psw = WinList_GetShellWindows(TRUE);
                    if (psw)
                    {
                        psw->Revoke(psb->_dwRegisterWinList);
                        psw->Release();
                    }
                }
                else
                {
                    if (psb->_psw)
                        psb->_psw->Revoke(psb->_dwRegisterWinList);
                } 
            }
            ATOMICRELEASE(psb->_psw);
            psb->_fMarshalledDispatch = 0;
            psb->_dwRegisterWinList = 0;
            ATOMICRELEASE(psb->_punkMsgLoop); // Release the message loop if the browser is going away
            psb->Release();
        }
        
        break;

#ifdef UNIX
    case WM_COPYDATA: 
        return psb ? HandleCopyDataUnix(psb, hwnd, uMsg, wParam, lParam) : DefWindowProc(hwnd, uMsg, wParam, lParam); 
#endif
        break;

    default:
        return psb ? psb->WndProcBS(hwnd, uMsg, wParam, lParam) : DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lResult;
}


// *** IShellBrowser methods *** (same as IOleInPlaceFrame)

/*----------------------------------------------------------
Purpose: IShellBrowser::InsertMenusSB method

*/
HRESULT CShellBrowser2::InsertMenusSB(HMENU hmenu, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    RIP(IS_VALID_HANDLE(hmenu, MENU));

    if (_hmenuTemplate) 
    {
        HMENU hmenuSrc;
        if (_get_itbLastFocus() == ITB_VIEW && 
            _pbbd->_uActivateState == SVUIA_ACTIVATE_FOCUS) 
        {
            hmenuSrc = _hmenuTemplate;
        }
        else
        {
            hmenuSrc = _hmenuFull;
        }

        Shell_MergeMenus(hmenu, hmenuSrc, 0, 0, FCIDM_BROWSERLAST, MM_SUBMENUSHAVEIDS);
        lpMenuWidths->width[0] = 1;     // File
        lpMenuWidths->width[2] = 2;     // Edit, View
        lpMenuWidths->width[4] = 1;     // Help
    }

    // Save this away so we can correctly build the menu list object
    _hmenuBrowser = hmenu;

    DEBUG_CODE(_DumpMenus(TEXT("InsertMenusSB"), TRUE);)

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IShellBrowser::SetMenuSB method

*/
HRESULT CShellBrowser2::SetMenuSB(HMENU hmenu, HOLEMENU hmenuRes, HWND hwnd)
{
    RIP(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    // A NULL hmenu means to reinstate the container's original menu
    if (hmenu) {
        _hmenuCur = hmenu;
    } else {
        if (_fRunningInIexploreExe)
            _hmenuCur = _hmenuPreMerged;
        else
            _hmenuCur = _hmenuTemplate;
    }

    _fDispatchMenuMsgs = FALSE;
    _fForwardMenu = FALSE;

    // Normally _hmenuBrowser is set by the caller of InsertMenusSB.
    // However, with the actual web browser, InsertMenusSB is never called.
    // That means _hmenuBrowse is either NULL or non-NULL but invalid.
    // So in that case assume hmenu is equivalent.  This essentially makes
    // all messages get sent to the frame, which is what we want.

    HMENU hmenuBrowser;

    if (!IsMenu(_hmenuBrowser)) // We're calling IsMenu on purpose
        _hmenuBrowser = NULL;

    if (NULL != _hmenuBrowser)
        hmenuBrowser = _hmenuBrowser;
    else
        hmenuBrowser = hmenu;

    _menulist.Set(hmenu, hmenuBrowser);

    // Was the help menu merged?
    HMENU hmenuHelp = NULL;
    
    if (_pbbd->_pctView)
    {
        VARIANTARG vaOut = {0};

        if (S_OK == _pbbd->_pctView->Exec(&CGID_ShellDocView, SHDVID_QUERYMERGEDHELPMENU, 0, NULL, &vaOut))
        {
            // Yes; remove it from the list so it isn't accidentally
            // forwarded on.

            if (VT_INT_PTR == vaOut.vt)
            {
                hmenuHelp = (HMENU)vaOut.byref;

                ASSERT(IS_VALID_HANDLE(hmenuHelp, MENU));
                _menulist.RemoveMenu(hmenuHelp);
            }
            VariantClearLazy(&vaOut);
            
            vaOut.vt = VT_EMPTY;
            vaOut.byref = NULL;
            
            if (S_OK == _pbbd->_pctView->Exec(&CGID_ShellDocView, SHDVID_QUERYOBJECTSHELPMENU, 0, NULL, &vaOut))
            {
                if (VT_INT_PTR == vaOut.vt)
                {
                    // Add the object's help submenu to the list so it gets forwarded
                    HMENU hmenuObjHelp = (HMENU)vaOut.byref;

                    ASSERT(IS_VALID_HANDLE(hmenuObjHelp, MENU));
                    _menulist.AddMenu(hmenuObjHelp);
                }
                VariantClearLazy(&vaOut);
            }
            
        }
    }
    
    // 80734: Was the Go To menu taken from the View menu and grafted onto the
    // main menu by DocHost?  The menulist won't detect this graft, so we have
    // to check ourselves and make sure it's not marked as belonging to the 
    // docobject.
    //
    // This test is duplicated in CDocObjectHost::_SetMenu

    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;

    if (hmenu && _hmenuBrowser && 
        GetMenuItemInfo(hmenu, FCIDM_MENU_EXPLORE, FALSE, &mii))
    {
        HMENU hmenuGo = mii.hSubMenu;

        if (GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_EXPLORE, FALSE, &mii) &&
            mii.hSubMenu == hmenuGo && _menulist.IsObjectMenu(hmenuGo))
        {
            _menulist.RemoveMenu(hmenuGo);
        }
    }

    DEBUG_CODE(_hmenuHelp = hmenuHelp;)

    if (!_fKioskMode)
    {
        if (_fShowMenu)
            _SetMenu(_hmenuCur);
        else
            _SetMenu(NULL);
    }

    DEBUG_CODE(_DumpMenus(TEXT("SetMenuSB"), TRUE););

    return S_OK;
}


/*----------------------------------------------------------
Purpose: Remove menus that are shared with other menus from 
         the given browser menu.

*/
HRESULT CShellBrowser2::RemoveMenusSB(HMENU hmenuShared)
{
    // Generally, there is no need to remove most of the menus because 
    // they were cloned and inserted into this menu.  However, the 
    // Favorites menu is an exception because it is shared with
    // _hmenuFav.

    return S_OK;
}

void CShellBrowser2::_ShowHideProgress()
{
    if (_hwndProgress) {
        
        UINT uShow = SW_SHOW;
        if (SendMessage(_hwndProgress, PBM_GETPOS, 0, 0) == 0)
            uShow = SW_HIDE;
        
        ShowWindow(_hwndProgress, uShow);
        
        TraceMsg(TF_SHDPROGRESS, "CShellBrowser2::_ShowHideProgress() uShow = %X", uShow);
    }
}

HRESULT CShellBrowser2::SendControlMsg(UINT id, UINT uMsg, WPARAM wParam,
            LPARAM lParam, LRESULT *pret)
{
    HRESULT hres = SUPERCLASS::SendControlMsg(id, uMsg, wParam, lParam, pret);
    
    if (id == FCW_PROGRESS) {
        if (uMsg == PBM_SETRANGE32 || uMsg == PBM_SETPOS)
            _ShowHideProgress();
        
        if (_ptheater && _ptheater->_hwndProgress)
            SendMessage(_ptheater->_hwndProgress, uMsg, wParam, lParam);
    }
    return hres;
}

HRESULT CShellBrowser2::_QIExplorerBand(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;
    HRESULT hr = E_FAIL;
    IDeskBar* pdbBar;
    if (SUCCEEDED(FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdbBar))) && pdbBar)
    {
        IUnknown* punkBS;
        if (SUCCEEDED(pdbBar->GetClient(&punkBS)))
        {
            IBandSite* pbs;
            if (SUCCEEDED(punkBS->QueryInterface(IID_PPV_ARG(IBandSite, &pbs))))
            {
                IDeskBand* pdbBand = FindBandByClsidBS(pbs, CLSID_ExplorerBand);
                if (pdbBand)
                {
                    hr = pdbBand->QueryInterface(riid, ppvObj);
                    pdbBand->Release();
                }
                pbs->Release();
            }
            punkBS->Release();
        }
        pdbBar->Release();
    }
    return hr;
}

HRESULT CShellBrowser2::GetControlWindow(UINT id, HWND * lphwnd)
{
    // the defaults
    HRESULT hres = E_FAIL;
    *lphwnd = NULL;

    switch (id)
    {
    case FCW_INTERNETBAR:
        if (_GetITBar() && _GetToolbarItem(ITB_ITBAR)->fShow)
            hres = _GetITBar()->GetWindow(lphwnd);
        break;
        
    case FCW_TOOLBAR:
        *lphwnd = _hwndDummyTB;
        break;

    case FCW_STATUS:
        *lphwnd = _hwndStatus;
        break;
        
    case FCW_PROGRESS:
        if (!_hwndProgress && _hwndStatus) {
            _hwndProgress = CreateWindowEx(0, PROGRESS_CLASS, NULL,
                                           WS_CHILD | WS_CLIPSIBLINGS | PBS_SMOOTH,
                                           0, 0, 1, 1,
                                           _hwndStatus, (HMENU)1,
                                           HINST_THISDLL, NULL);

            // we yank off this bit because we REALLY don't want it because
            // the status bar already draws this for us when we specify rects
            //
            // but the progress bar forces this bit on during creation
            if (_hwndProgress)
                SHSetWindowBits(_hwndProgress, GWL_EXSTYLE, WS_EX_STATICEDGE, 0);
        }
        *lphwnd = _hwndProgress;
        break;

    case FCW_TREE:
        {
            BOOL fExplorerBandVisible;
            if (SUCCEEDED(IsControlWindowShown(FCW_TREE, &fExplorerBandVisible)) && fExplorerBandVisible)
            {
                IOleWindow* pow;
                if (SUCCEEDED(_QIExplorerBand(IID_IOleWindow, (void**)&pow)))
                {
                    pow->GetWindow(lphwnd);
                    pow->Release();
                }
            }
        }
        break;
    }

    if (*lphwnd) {
        hres = S_OK;
    }
    return hres;
}


//==========================================================================
//
//==========================================================================
HRESULT CShellBrowser2::SetToolbarItems(LPTBBUTTON pViewButtons, UINT nButtons,
            UINT uFlags)
{
    LPTBBUTTON pStart= NULL, pbtn= NULL;
    int nFirstDiff = 0, nTotalButtons = 0;
    BOOL bVisible = FALSE;

    if (uFlags & FCT_CONFIGABLE)
    {
        return S_OK;
    }

    // Allocate buffer for the default buttons plus the ones passed in
    //
    pStart = (LPTBBUTTON)LocalAlloc(LPTR, nButtons * sizeof(TBBUTTON));
    if (!pStart)
        return S_OK;

    pbtn = pStart;
    nTotalButtons = 0;

    if (pViewButtons)
    {
        int i;
        for (i = nButtons - 1; i >= 0; --i)
        {
            // copy in the callers buttons
            //
            pbtn[i] = pViewButtons[i];
            // make sure this is properly set to -1.
            // in win95, we had no strings so extensions couldn't set it, but some didn't initialize to -1
            if ((!pbtn[i].iString || (pbtn[i].iString <= (MAX_TB_BUTTONS + NUMBER_SHELLGLYPHS - 1))))
            {
                // We should not set our own shell iString to -1
                ASSERT(pbtn[i].iString != pbtn[i].iBitmap);
                // comment about Hummingbird passing 0xc always
                COMPILETIME_ASSERT(MAX_TB_BUTTONS + NUMBER_SHELLGLYPHS >= 0xc);
                pbtn[i].iString = -1;
            }
        }

        pbtn += nButtons;
        nTotalButtons += nButtons;
    }

    
    if (_pxtb)
    {
        // for right now, disable customize for all old style views
        DWORD dwFlags = VBF_NOCUSTOMIZE; 
        TCHAR szScratch[32];
    
        if (_nTBTextRows  == -1) {
            if (MLLoadString(IDS_SHELL_TB_TEXTROWS, szScratch, ARRAYSIZE(szScratch)))
                _nTBTextRows   = (UINT)StrToInt(szScratch);
            else    
                _nTBTextRows   = 0;
        }

        if (_nTBTextRows   == 1)
            dwFlags |= VBF_ONELINETEXT;
        else if (_nTBTextRows   == 2)
            dwFlags |= VBF_TWOLINESTEXT;
            
        
        _pxtb->SetCommandTarget((IUnknown *)SAFECAST(this, IOleCommandTarget *), &CGID_ShellBrowser, dwFlags);
        if (_lpPendingButtons)
            LocalFree(_lpPendingButtons);
        _lpPendingButtons = (TBBUTTON*)pStart;
        _nButtonsPending =  nTotalButtons;
    }
    else
    {
        LocalFree(pStart);
    }
    
    return S_OK;
}


#ifdef DEBUG
//---------------------------------------------------------------------------
// Copy the exception info so we can get debug info for Raised exceptions
// which don't go through the debugger.
void _CopyExceptionInfo(LPEXCEPTION_POINTERS pep)
{
    PEXCEPTION_RECORD per;

    per = pep->ExceptionRecord;
    TraceMsg(DM_ERROR, "Exception %x at %#08x.", per->ExceptionCode, per->ExceptionAddress);

    if (per->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
    {
        // If the first param is 1 then this was a write.
        // If the first param is 0 then this was a read.
        if (per->ExceptionInformation[0])
        {
            TraceMsg(DM_ERROR, "Invalid write to %#08x.", per->ExceptionInformation[1]);
        }
        else
        {
            TraceMsg(DM_ERROR, "Invalid read of %#08x.", per->ExceptionInformation[1]);
        }
    }
}
#else
#define _CopyExceptionInfo(x) TRUE
#endif

#define SVSI_SELFLAGS (SVSI_SELECT|SVSI_FOCUSED|SVSI_DESELECTOTHERS|SVSI_ENSUREVISIBLE)

void CShellBrowser2::_AfterWindowCreated(IETHREADPARAM *piei)
{
    //
    // Let interested people know we are alive
    //
    if (piei->uFlags & COF_SELECT)
    {
        IShellView* psv = _pbbd->_psv ? _pbbd->_psv : _pbbd->_psvPending;
        if (psv)
            psv->SelectItem(piei->pidlSelect, SVSI_SELFLAGS);
    }

#ifdef UNIX
    //
    // Since on Unix we are using browser window to display
    // help instead of HTML Help Check for Help mode and 
    // remove internet decorations and statusbar.
    //
    // Also remove any bars on the browser.
    
    if (piei->uFlags & COF_HELPMODE)
    {
#ifdef NO_MARSHALLING
        if (piei->fOnIEThread)
        {
#endif 
            v_ShowControl(FCW_INTERNETBAR, SBSC_HIDE);
            v_ShowControl(FCW_STATUS, SBSC_HIDE);
#ifdef NO_MARSHALLING
        } 
        else 
        {
            v_ShowControl(FCW_MENUBAR, SBSC_HIDE);
            v_ShowControl(FCW_ADDRESSBAR, SBSC_HIDE);
            v_ShowControl(FCW_LINKSBAR, SBSC_HIDE);
            v_ShowControl(FCW_TOOLBAND, SBSC_HIDE);
            IUnknown_Exec(_GetITBar(),&CGID_PrivCITCommands, CITIDM_SHOWBRAND, FALSE, NULL, NULL);
        }
#endif 
        _SetBrowserBarState(_idmInfo, NULL, 0);
        _SetBrowserBarState(_idmComm, NULL, 0);
    }
#endif // UNIX

    //
    //  Keep it hidden if this is the first instance which is started
    // with "/automation" flag or this object is being created as the
    // result of our CreateInstance.
    //
    if (!_fAutomation && !piei->piehs)
    {
        if (_fKioskMode)
        {
            // Turn off flag as we need to let the next function set it...
            _fKioskMode = FALSE;

            // Hack -1 implies
            ShowControlWindow((UINT)-1, TRUE);
        }
        
        UINT nCmdShow = piei->nCmdShow;
        BOOL fSetForeground = FALSE;
        BOOL fStartTheater = FALSE;

        // we need to do this setforegroundwindow 
        // because of a bug in user.  if the previous thread didn't have
        // activation, ShowWindow will NOT give us activation even though
        // it's supposed to
        switch (nCmdShow) {
        case SW_SHOWNORMAL:
        case SW_SHOWMAXIMIZED:
        case SW_SHOW:
            fSetForeground = TRUE;
            break;
        }
        
        if (_fUseIEPersistence) 
        {
            fStartTheater = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                TEXT("FullScreen"), FALSE, FALSE);
        }
        
        if (fStartTheater) 
        {
            _TheaterMode(TRUE, FALSE);
            if (fSetForeground)
                nCmdShow = SW_SHOW;
        }

        MSG msg;
        if (!PeekMessage(&msg, _pbbd->_hwnd, WM_CLOSE, WM_CLOSE, PM_NOREMOVE)) 
        {
            ShowWindow(_pbbd->_hwnd, nCmdShow);
            //
            // AT THIS POINT ALL DDE TRANSACTIONS SHOULD SUCCEED. THE BROWSER
            // WINDOW WAS ADDED TO THE DDE WINITEM LIST ON WM_NCCREATE,
            // AUTOMATION WAS REGISTERED AS STARTED ON THE OnCreate,
            // AND THE WINDOW IS NOW VISIBLE AS A PART OF THE SHOWWINDOW.
            // 99% OF ALL DDE STARTUP BUGS ARE CAUSED BY SOMEBODY CHECKING FOR
            // MESSAGES (PEEKMESSAGE, GETMESSAGE, INTERPROC SENDMESSAGE, ETC.)
            // BEFORE THIS POINT.
            //
            // On UNIX it is not common to force the window to the top of Z-order.
            //      
#ifndef UNIX
            if (fSetForeground)
                SetForegroundWindow(_pbbd->_hwnd);
#endif
        } 
        else 
        {
            ASSERT(msg.hwnd == _pbbd->_hwnd);
        }            
    }

    _SetTitle(NULL);

    //
    // Delay register our window now.
    //  Note that we need to do it after SetEvent(piei->piehs->GetHevent()) to
    //  avoid soft dead-lock in OLE, and we need to do it after the
    //  ShowWindow above because this will allow DDE messages to get
    //  sent to us.
    //
    //  RegisterWindow() shouldnt have been called yet, but if it has, we dont want
    //  to change its registration class from here.  zekel 9-SEP-97
    //
    ASSERT(!_fDidRegisterWindow);

    RegisterWindow(FALSE, (piei->uFlags & COF_EXPLORE) ? SWC_EXPLORER : SWC_BROWSER);


    // Delay loading accelerators from v_initmembers
    ASSERT(MLGetHinst());
    HACCEL hacc = LoadAccelerators(MLGetHinst(), MAKEINTRESOURCE(ACCEL_MERGE));
    ASSERT(hacc);
    SetAcceleratorMenu(hacc);

    // Send size so status bar shows
    SendMessage(_pbbd->_hwnd, WM_SIZE, 0, 0);

    // delay doing a bunch of registrations
    // things we don't want our subclass to inherit
    if (v_InitMembers == CShellBrowser2::v_InitMembers) 
    {
        // register to get filesys notifications
        _uFSNotify = RegisterNotify(_pbbd->_hwnd, CWM_FSNOTIFY, NULL, SHELLBROWSER_FSNOTIFY_FLAGS,
                                    SHCNRF_ShellLevel | SHCNRF_InterruptLevel, TRUE);
    }
    
    SignalFileOpen(piei->pidl);
}

//
//  RegisterWindow() should only be called with Unregister if the caller
//  wants to insure that the new ShellWindowClass is used.  this is used
//  by CIEFrameAuto to force the browser window in the 3rdParty winlist.
//
HRESULT CShellBrowser2::RegisterWindow(BOOL fForceReregister, int swc)
{
    if (!_psw) 
        _psw = WinList_GetShellWindows(FALSE);
    
    if (_psw)
    {
        if (fForceReregister && _fDidRegisterWindow)
        {
            _psw->Revoke(_dwRegisterWinList);
            _fDidRegisterWindow = FALSE;
        }

        if (!_fDidRegisterWindow)
        {
            // raymondc- HandleToLong should really be HANDLE_PTR or something - Browser folks need to fix the IDL
            _psw->Register(NULL, HandleToLong(_pbbd->_hwnd), swc, &_dwRegisterWinList);
            _fDidRegisterWindow = TRUE;
            _swcRegistered = swc;

            UpdateWindowList();
        }
        return S_OK;
    }
    return E_FAIL;
}

LRESULT CALLBACK IEFrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void InitializeExplorerClass()
{
    static BOOL fInited = FALSE;

    if (!fInited) 
    {
        ENTERCRITICAL;
        if (!fInited) {

            WNDCLASS  wc;

            ZeroMemory(&wc, sizeof(wc));
            wc.style            = CS_BYTEALIGNWINDOW;
            wc.lpfnWndProc      = IEFrameWndProc;
            wc.cbWndExtra       = sizeof(void *);
            wc.hInstance        = HINST_THISDLL;
            wc.hIcon            = LoadIcon(HinstShdocvw(), MAKEINTRESOURCE(ICO_TREEUP));
            wc.hCursor          = LoadCursor(NULL, IDC_SIZEWE);
            wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1);
            wc.lpszClassName    = c_szExploreClass;

            RegisterClass(&wc);

#ifndef UNIX
            wc.hIcon            = LoadIcon(HinstShdocvw(), MAKEINTRESOURCE(IDI_STATE_NORMAL));
#else
            if (SHGetCurColorRes() < 2)
                wc.hIcon        = LoadIcon(HinstShdocvw(), MAKEINTRESOURCE(IDI_MONOFRAME));
            else
                wc.hIcon        = LoadIcon(HinstShdocvw(), MAKEINTRESOURCE(IDI_STATE_NORMAL));
#endif
            wc.hCursor          = LoadCursor(NULL, IDC_ARROW);

            wc.lpszClassName    = c_szIExploreClass;
            RegisterClass(&wc);
            
            // shell32 is stuck with this id forever since it came out on win95
#define IDI_FOLDEROPEN          5      // open folder
            wc.hIcon            = LoadIcon(HinstShell32(), MAKEINTRESOURCE(IDI_FOLDEROPEN));
            wc.lpszClassName    = c_szCabinetClass;
            RegisterClass(&wc);

            // this needs to be set at the END..
            // because otherwise a race condition occurs and some guys run throught the
            // outter most check and try to create before we're registered.
            fInited = TRUE;
        }
        LEAVECRITICAL;
    }
}

// compatability: we need to have the right class name so people can find our window
//
LPCTSTR _GetExplorerClassName(UINT uFlags)
{
    if (uFlags & COF_EXPLORE)
        return c_szExploreClass;
    else if (uFlags & COF_IEXPLORE || WhichPlatform() == PLATFORM_BROWSERONLY)
        return c_szIExploreClass;
    else
        return c_szCabinetClass;
}

void TimedDispatchMessage(MSG *pmsg)
{
    DWORD dwTime;
    if (g_dwStopWatchMode & SPMODE_MSGTRACE)
        dwTime = StopWatch_DispatchTime(TRUE, *pmsg, 0);
        
    DispatchMessage(pmsg);
    
    if (g_dwStopWatchMode)
    {
        if (g_dwStopWatchMode & SPMODE_MSGTRACE)
            StopWatch_DispatchTime(FALSE, *pmsg, dwTime);

        if ((g_dwStopWatchMode & SPMODE_SHELL) && (pmsg->message == WM_PAINT))
            StopWatch_TimerHandler(pmsg->hwnd, 1, SWMSG_PAINT, pmsg); // Save tick count for paint msg
    }
}


void DesktopChannel();

void BrowserThreadProc(IETHREADPARAM* piei)
{
    HMENU hmenu;
    HWND hwnd;
    DWORD dwExStyle = WS_EX_WINDOWEDGE;
    LONG cRefMsgLoop;           // the ref count for this thread
    IUnknown *punkMsgLoop;      // the ref object (wraps cRefMsgLoop) for this thread
    IUnknown *punkRefProcess;   // the process ref this thread holds (may be none)
    
#ifdef NO_MARSHALLING
    THREADWINDOWINFO *lpThreadWindowInfo = InitializeThreadInfoStructs();
    if (!lpThreadWindowInfo)
       goto Done;
#endif

    UINT tidCur = GetCurrentThreadId();
    UINT uFlags = piei->uFlags;

    // Set our priority higher for startup so that we are not starved by background tasks and
    // other pesky system activity
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

#ifndef NO_ETW_TRACING
    // Event trace for windows enable by shlwapi.
    if (g_dwStopWatchMode & SPMODE_EVENTTRACE)
        EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_STARTFRAME, NULL);
#endif
    if (g_dwStopWatchMode & (SPMODE_SHELL | SPMODE_BROWSER | SPMODE_JAVA | SPMODE_MSGTRACE))
        StopWatch_MarkFrameStart(piei->uFlags & COF_EXPLORE ? " (explore)" : "");

    punkRefProcess = piei->punkRefProcess;
    piei->punkRefProcess = NULL;        // we took ownership
   
    LPWSTR pszCloseEvent = (piei->uFlags & COF_FIREEVENTONCLOSE) ? StrDupW(piei->szCloseEvent) : NULL;

    // if we're going to do desktop channel stuff, do it and return
#ifdef ENABLE_CHANNELS
    if (piei->fDesktopChannel) 
    {
        if (piei->pSplash)
        {
            piei->pSplash->Dismiss();
            ATOMICRELEASE(piei->pSplash);
        }

        if (piei->uFlags & COF_FIREEVENTONDDEREG) 
        {
            ASSERT(piei->szDdeRegEvent[0]);
            FireEventSzW(piei->szDdeRegEvent);
        }

        DesktopChannel();
        goto Done;
    }
#endif  / ENABLE_CHANNELS
    TraceMsg(TF_SHDTHREAD, "BrowserThreadProc() - IE_ThreadProc(%x) just started.", tidCur);

    InitializeExplorerClass();

    if (SUCCEEDED(SHCreateThreadRef(&cRefMsgLoop, &punkMsgLoop)))
    {
        if (tidCur == g_tidParking)
        {
            SHSetInstanceExplorer(punkMsgLoop);   // we are process reference
        }
        SHSetThreadRef(punkMsgLoop);
    }

    // Set our title temporarily (for people who grab our title, like the SHEnumErrorMessage guy
    TCHAR szTempTitle[MAX_PATH];
    if (piei->uFlags & COF_IEXPLORE)
        MLLoadString(IDS_TITLE, szTempTitle, ARRAYSIZE(szTempTitle));
    else
        MLLoadString(IDS_CABINET, szTempTitle, ARRAYSIZE(szTempTitle));

    //
    // APPCOMPAT - apps like WebCD require a non-null menu on the
    // browser.  Thankfully USER won't draw a menuband on an empty hmenu.
    //
    hmenu = CreateMenu();
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd | dwExStyleNoInheritLayout: 0L;

    hwnd = SHNoFusionCreateWindowEx(dwExStyle, _GetExplorerClassName(piei->uFlags), szTempTitle,
        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, 
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, 
        hmenu, HINST_THISDLL, piei);

    if (punkMsgLoop)
        punkMsgLoop->Release();     // browser (in open state) holds the ref

    if (piei->pSplash)
    {
        piei->pSplash->Dismiss();
        ATOMICRELEASE(piei->pSplash);
    }
    
    if (hwnd)
    {
#ifdef UNIX
        UnixAdjustWindowSize(hwnd, piei);
#endif
        if (g_dwStopWatchMode & SPMODE_SHELL)   // Create the timer to start watching for paint messages
            StopWatch_TimerHandler(hwnd, 0, SWMSG_CREATE, NULL);

        CShellBrowser2* psb = (CShellBrowser2*)GetWindowPtr0(hwnd);
        if (psb)
        {
#ifdef NO_MARSHALLING
            AddFirstBrowserToList(psb);
#endif
            psb->AddRef();
            psb->_AfterWindowCreated(piei);

            SHDestroyIETHREADPARAM(piei);
            piei = NULL;

            TraceMsg(TF_SHDTHREAD, "BrowserThreadProc() - IE_ThreadProc(%x) about to start the message loop", tidCur);
#ifdef UNIX
            BOOL fNoSignalUI = !!getenv("IE_NO_SIGNAL_UI");
            for (int nMessagePumpCount = 0;  nMessagePumpCount < 2;  nMessagePumpCount += 2)
            {
            __try
            {
#endif
            BOOL fThreadPriorityHasBeenReset = FALSE;

            while (1)
            {
                MSG  msg;
                BOOL fPeek;

                fPeek = PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);

                if (fPeek)
                {

#ifndef NO_ETW_TRACING
                    if (g_dwStopWatchMode & SPMODE_EVENTTRACE) {
                        if (msg.message == WM_KEYDOWN) {
                            if (msg.wParam == VK_RETURN) {
                                EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_USERINPUTRET, NULL);
                            }
                            else if (msg.wParam == VK_BACK) {
                                EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_USERINPUTBACK, NULL);
                            }
                            else if (msg.wParam == VK_NEXT) {
                                EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_USERINPUTNEXT, NULL);
                            }
                            else if (msg.wParam == VK_PRIOR) {
                                EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_USERINPUTPRIOR, NULL);
                            }
                        }
                        else if (msg.message == WM_LBUTTONUP) {
                            EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_USERINPUTLBUT, NULL);
                        }
                    }
#endif

                    if (g_dwStopWatchMode)
                        StopWatch_CheckMsg(hwnd, msg, uFlags == COF_EXPLORE ? " (explore) " : "");  // Key off of WM_KEYDOWN to start timing
#ifdef NO_MARSHALLING
                    CShellBrowser2 *psbOld = psb;
                    CShellBrowser2 *psb = CheckAndForwardMessage(lpThreadWindowInfo, psbOld, msg);
                    if (!psb) 
                        psb = psbOld;
#endif
                    if (psb->_pbbd->_hwnd && IsWindow(psb->_pbbd->_hwnd))
                    {
                        //
                        // Directly dispatch WM_CLOSE message to distinguish nested
                        // message loop case.
                        //
                        if ((msg.message == WM_CLOSE) && (msg.hwnd == psb->_pbbd->_hwnd)) 
                        {
                            psb->_OnClose(FALSE);
                            continue;
                        }
#ifdef NO_MARSHALLING
                        HWND hwnd = GetActiveWindow();
                        if (!IsNamedWindow(hwnd, TEXT("Internet Explorer_TridentDlgFrame")))
                        {
                            if (S_OK == psb->v_MayTranslateAccelerator(&msg))
                                continue;
                        }
                        else
                        {
                            DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);
                            if (dwExStyle & WS_EX_MWMODAL_POPUP)
                            {
                                if (S_OK == psb->v_MayTranslateAccelerator(&msg))
                                    continue;
                            }
                            else
                            {
                                if (msg.message >= WM_KEYFIRST && msg.message <= WM_KEYLAST && 
                                    (TranslateModelessAccelerator(&msg, hwnd) == S_OK))
                                    continue;
                            }
                        }
#else
                        if (S_OK == psb->v_MayTranslateAccelerator(&msg))
                            continue;
#endif
                    }

                    TranslateMessage(&msg);
                    TimedDispatchMessage(&msg);
                }
#ifdef NO_MARSHALLING
                else if ((cRefMsgLoop == 0) && (lpThreadWindowInfo->cWindowCount == 0))
#else
                else if (cRefMsgLoop == 0)
#endif
                {
                    TraceMsg(TF_SHDTHREAD, "BrowserThreadProc() - cRefMsgLoop == 0, done");
                    break;  // exit while (1), no more refs on this thread
                } 
                else 
                {
                    if (!fThreadPriorityHasBeenReset)
                    {
                        fThreadPriorityHasBeenReset = TRUE;
                        // Reset our priority to normal now that we have finished the startup
                        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
#ifdef PERF_LOGGING
                        HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("ExplorerWindowIdle"));
                        if (hEvent)
                        {
                            SetEvent(hEvent);
                            CloseHandle(hEvent);
                        }
#endif
                    }

                    WaitMessage();

                    if (g_dwStopWatchMode & SPMODE_MSGTRACE)
                        StopWatch_SetMsgLastLocation(2);
                }
            }
#ifdef UNIX
            }
            __except((fNoSignalUI || nMessagePumpCount > 0)
                      ? EXCEPTION_CONTINUE_SEARCH 
                      : EXCEPTION_EXECUTE_HANDLER)
            {
                // we will try to display a message box to tell the user
                // that a thread has died...
                //
                int result = MLShellMessageBox(NULL, MAKEINTRESOURCE(IDS_EXCEPTIONMSGSH),
                                               MAKEINTRESOURCE(IDS_TITLE),
                                               MB_OK |
                                               MB_APPLMODAL |
                                               MB_ICONEXCLAMATION |
                                               MB_SETFOREGROUND);
                if (result != IDNO) 
                {
                    MwExecuteAtExit(); // why doesn't ExitProcess do this!?!?!?
                    ExitProcess(0);
                }
                nMessagePumpCount -= 2; // -=2 for no limit, -=1 to only show panel once
            }
            __endexcept
            }
#endif

            TraceMsg(TF_SHDTHREAD, "BrowserThreadProc() - IE_ThreadProc(%x) end of message loop", tidCur);
            psb->Release();
        }
    } 
    else 
    {
        // Unregister any pending that may be there
        WinList_Revoke(piei->dwRegister);
        TraceMsg(TF_WARNING, "BrowserThreadProc() - IE_ThreadProc CreateWindow failed");
    }
#if defined(ENABLE_CHANNELS) || defined(NO_MARSHALLING)
Done:
#endif
    // Make sure we return the thread priority to normal in case this thread is re-used.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);

    if (pszCloseEvent) 
    {
        FireEventSzW(pszCloseEvent);
        LocalFree(pszCloseEvent);
    }

    SHDestroyIETHREADPARAM(piei);

    if (punkRefProcess)
        punkRefProcess->Release();

#ifdef NO_MARSHALLING
    FreeThreadInfoStructs();
#endif
}

DWORD CALLBACK BrowserProtectedThreadProc(void *pv)
{
    if (g_dwProfileCAP & 0x00000004)
        StartCAP();

    HRESULT hrInit = OleInitialize(NULL);

    PostMessage(GetShellWindow(), DTM_SETAPPSTARTCUR, 0, 0);

#ifdef DEBUG
    if (hrInit != S_OK)
    {
        TraceMsg(TF_WARNING, "BrowserProtectedThreadProc: OleInitialize returned %x ?!?", hrInit);
    }
#endif

    ULONG_PTR dwCookie = 0;
    NT5_ActivateActCtx(NULL, &dwCookie);        // Set to inherit the process context

#if !defined(FULL_DEBUG) && (!defined(UNIX) || (defined(UNIX) && defined(GOLDEN)))

    EXCEPTION_RECORD exr;
    
    _try
    {
        BrowserThreadProc((IETHREADPARAM*)pv);
    }
    _except((exr = *((GetExceptionInformation())->ExceptionRecord),
            _CopyExceptionInfo(GetExceptionInformation()),
            UnhandledExceptionFilter(GetExceptionInformation())))
    {
        LPCTSTR pszMsg = NULL;
        //  we will try to display a message box to tell the user
        // that a thread has died...
        //
        if (GetExceptionCode() == STATUS_NO_MEMORY)
            pszMsg = MAKEINTRESOURCE(IDS_EXCEPTIONNOMEMORY);
        else if (WhichPlatform() == PLATFORM_BROWSERONLY)
        {
            pszMsg =  MAKEINTRESOURCE(IDS_EXCEPTIONMSG);
        }
        // don't show the message box on non-nt systems
        //  older than millennium (with an older shell)
        //  see IE5.5 bug#93165
        else if (g_fRunningOnNT || (GetUIVersion() < 5))
        {
            pszMsg = MAKEINTRESOURCE(IDS_EXCEPTIONMSGSH);
        }

        if (pszMsg)
        {
            MLShellMessageBox(NULL, pszMsg,
                              MAKEINTRESOURCE(IDS_TITLE), MB_ICONEXCLAMATION|MB_SETFOREGROUND);
        }

        if (GetExceptionCode() != STATUS_NO_MEMORY)
            IEWriteErrorLog(&exr);
    }
    __endexcept
#else
    // IEUNIX : This exception handler should only be used in Release 
    // version of the product. We are disabling it for debugging purposes.

    BrowserThreadProc((IETHREADPARAM*)pv);
#endif

    NT5_DeactivateActCtx(dwCookie);
    
    if (SUCCEEDED(hrInit))
    {
        OleUninitialize();
    }

    return 0;
}


// Check if this IETHREADPARAM/LPITEMIDLIST requires launch in a new process
// and if so launch it and return TRUE.
//
BOOL TryNewProcessIfNeeded(LPCITEMIDLIST pidl)
{
    if (pidl && IsBrowseNewProcessAndExplorer() 
    && IsBrowserFrameOptionsPidlSet(pidl, BFO_PREFER_IEPROCESS))
    {
        TCHAR szURL[MAX_URL_STRING];

        HRESULT hres = ::IEGetDisplayName(pidl, szURL, SHGDN_FORPARSING);
        if (SUCCEEDED(hres))
        {
            hres = IENavigateIEProcess(szURL, FALSE);
            if (SUCCEEDED(hres))
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL TryNewProcessIfNeeded(IETHREADPARAM * piei)
{
    BOOL bRet = TryNewProcessIfNeeded(piei->pidl);
    if (bRet)
    {
        SHDestroyIETHREADPARAM(piei);
    }
    return bRet;
}


// NOTE: this is a ThreadProc (shdocvw creates this as a thread)
//
// this takes ownership of piei and will free it
//
BOOL SHOpenFolderWindow(IETHREADPARAM* piei)
{
    BOOL fSuccess = FALSE;

    _InitAppGlobals();

    CABINETSTATE cs;
    GetCabState(&cs);

    //
    // If "/select" switch is specified, but we haven't splitted
    // the pidl yet (because the path is passed rather than pidl),
    // split it here.
    //
    if ((piei->uFlags & COF_SELECT) && piei->pidlSelect == NULL) 
    {
        LPITEMIDLIST pidlLast = ILFindLastID(piei->pidl);
        // Warning: pidlLast can be NULL if the command line is
        // sufficiently wacky.  E.g.,
        //
        // explorer /select
        //
        if (pidlLast)
        {
            piei->pidlSelect = ILClone(pidlLast);
            pidlLast->mkid.cb = 0;
        }
    }

    if (GetAsyncKeyState(VK_CONTROL) < 0)
        cs.fNewWindowMode = !cs.fNewWindowMode;

    //
    // Check to see if we can reuse the existing window first
    //

    OLECMD  rgCmds[1] = {0};
    rgCmds[0].cmdID = SBCMDID_EXPLORERBAR;
    BOOL bForceSameWindow = (piei->uFlags & COF_EXPLORE) &&
        SUCCEEDED(IUnknown_QueryStatus(piei->psbCaller, &CGID_Explorer, ARRAYSIZE(rgCmds), rgCmds, NULL)) && 
        (rgCmds[0].cmdf & OLECMDF_LATCHED);
    if (bForceSameWindow ||
        piei->psbCaller &&
        !(piei->uFlags & COF_CREATENEWWINDOW) &&
        !cs.fNewWindowMode)
    {
        if (piei->pidl)
        {
            UINT uFlags = SBSP_SAMEBROWSER;
            
            if (piei->uFlags & COF_EXPLORE)
                uFlags |= SBSP_EXPLOREMODE;
            else 
                uFlags |= SBSP_OPENMODE;

            if (SUCCEEDED(piei->psbCaller->BrowseObject(piei->pidl, uFlags)))
                goto ReusedWindow;
        }
    }

    //
    // Don't look for an existing window if we are opening an explorer.
    //
    if (!((piei->uFlags & COF_EXPLORE) || (piei->uFlags & COF_NOFINDWINDOW))) 
    {
        HWND hwnd;
        IWebBrowserApp* pwba;
        HRESULT hres = WinList_FindFolderWindow(piei->pidl, NULL, &hwnd, &pwba);
        if (hres == S_OK)
        {
            ASSERT(pwba); // WinList_FindFolerWindow should not return S_OK if this fails
            SetForegroundWindow(hwnd);

            //  IE30COMPAT - we need to refresh when we hunt and pick up these windows - zekel 31-JUL-97
            //  this will happen if we just do a navigate to ourself.  this is the
            //  same kind of behavior we see when we do a shellexec of an URL.
            //  
            //  we dont use the pwb from FindFolderWindow because it turns out that RPC will
            //  fail the QI for it when we are being called from another process.  this
            //  occurs when IExplore.exe Sends the WM_COPYDATA to the desktop to navigate
            //  a window to an URL that is already there.  so instead of using the pwb
            //  we do a CDDEAuto_Navigate().  which actually goes and uses pwb itself.
            //
            TCHAR szUrl[MAX_URL_STRING];
            if (SUCCEEDED(IEGetNameAndFlags(piei->pidl, SHGDN_FORPARSING, szUrl, SIZECHARS(szUrl), NULL)))
            {
                BSTR bstrUrl = SysAllocString(szUrl);
                if (bstrUrl)
                {
                    pwba->Navigate(bstrUrl, NULL, NULL, NULL, NULL);
                    SysFreeString(bstrUrl);
                }   
            }
            pwba->Release();

            if (IsIconic(hwnd))
                ShowWindow(hwnd, SW_RESTORE);
            if (piei->nCmdShow)
                ShowWindow(hwnd, piei->nCmdShow);
            goto ReusedWindow;
        }
        else if (hres == E_PENDING)
            goto ReusedWindow;        // Assume it will come up sooner or later
    }

    // Okay, we're opening up a new window, let's honor
    // the BrowseNewProcess flag, even though we lose
    // other info (COF_EXPLORE, etc).
    //
    if (TryNewProcessIfNeeded(piei))
        return TRUE;

    if (((piei->uFlags & (COF_INPROC | COF_IEXPLORE)) == (COF_INPROC | COF_IEXPLORE)) &&
        g_tidParking == 0) 
    {
        // we're starting from iexplore.exe 
        g_tidParking = GetCurrentThreadId();
    }
    
    if (piei->pidl && IsURLChild(piei->pidl, TRUE))
        piei->uFlags |= COF_IEXPLORE;

    ASSERT(piei->punkRefProcess == NULL);
    SHGetInstanceExplorer(&piei->punkRefProcess);     // pick up the process ref (if any)

    if (piei->uFlags & COF_INPROC)
    {
        BrowserProtectedThreadProc(piei);
        fSuccess = TRUE;
    } 
    else 
    {
#ifndef NO_MARSHALLING

        DWORD idThread;
        HANDLE hThread = CreateThread(NULL,
#ifdef DEBUG
                                      0, // on debug builds we inherit the default process stack size (so we can identify excessive stack usage)
#else
                                      (1024 * 56), // we pre-allocate a 56k stack for browser windows
#endif
                                      BrowserProtectedThreadProc,
                                      piei,
                                      CREATE_SUSPENDED,
                                      &idThread);
        if (hThread) 
        {
            WinList_RegisterPending(idThread, piei->pidl, NULL, &piei->dwRegister);

            ResumeThread(hThread);
            CloseHandle(hThread);
            fSuccess = TRUE;
        } 
        else 
        {
            SHDestroyIETHREADPARAM(piei);
        }
#else
        IEFrameNewWindowSameThread(piei);
#endif
    }
    return fSuccess;
    
ReusedWindow:
    SHDestroyIETHREADPARAM(piei);
    return TRUE;
}


//
// Notes: pidlNew will be freed
//
STDAPI SHOpenNewFrame(LPITEMIDLIST pidlNew, ITravelLog *ptl, DWORD dwBrowserIndex, UINT uFlags)
{
    HRESULT hres;

    IETHREADPARAM* piei = SHCreateIETHREADPARAM(NULL, SW_SHOWNORMAL, ptl, NULL);
    if (piei) 
    {
        hres = S_OK;

        if (ptl)
            piei->dwBrowserIndex = dwBrowserIndex;

        if (pidlNew)
        {
            piei->pidl = pidlNew;
            pidlNew = NULL;
        }

        piei->uFlags = uFlags;

        if (!TryNewProcessIfNeeded(piei))
        {
#ifndef NO_MARSHALLING
            ASSERT(piei->punkRefProcess == NULL);
            SHGetInstanceExplorer(&piei->punkRefProcess);     // pick up the process ref (if any)

            DWORD idThread;
            HANDLE hThread = CreateThread(NULL,
#ifdef DEBUG
                                          0, // on debug builds we inherit the default process stack size (so we can identify excessive stack usage)
#else
                                          (1024 * 56), // we pre-allocate a 56k stack for browser windows
#endif
                                          BrowserProtectedThreadProc,
                                          piei,
                                          0,
                                          &idThread);
            if (hThread)
            {
                //  this handles removing this from the debug memory list of
                //  the opening thread.
                CloseHandle(hThread);
            } 
            else 
            {
                SHDestroyIETHREADPARAM(piei);
                hres = E_FAIL;
            }
#else
            IEFrameNewWindowSameThread(piei);
#endif
        }
    } 
    else 
        hres = E_OUTOFMEMORY;

    ILFree(pidlNew);

    return hres;
}


HRESULT CShellBrowser2::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, 
                                   OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres = SUPERCLASS::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
    
    if (pguidCmdGroup == NULL) 
    {
        //
        //  If the curretly focused toolbar suppors the IOleCommandTarget
        // ask it the status of clipboard commands.
        // actually we should ask *both* ourselves (the active target)
        // and then the view (the same way our IOCT::Exec does...)
        //
        if (_HasToolbarFocus())
        {
            LPTOOLBARITEM ptbi;
            ptbi = _GetToolbarItem(_get_itbLastFocus());
            if (ptbi && ptbi->ptbar)
            {
                IOleCommandTarget* pcmd;
                HRESULT hresT = ptbi->ptbar->QueryInterface(
                                    IID_IOleCommandTarget, (void**)&pcmd);
                if (SUCCEEDED(hresT)) 
                {
                    for (ULONG i = 0; i < cCmds; i++) 
                    {
                        switch (rgCmds[i].cmdID)
                        {
                        case OLECMDID_CUT:
                        case OLECMDID_COPY:
                        case OLECMDID_PASTE:
                            pcmd->QueryStatus(pguidCmdGroup, 1, &rgCmds[i], pcmdtext);
                            break;
                        }
                    }
                    pcmd->Release();
                }
            }
        }
    }
    else if (IsEqualGUID(CGID_ShellBrowser, *pguidCmdGroup)) 
    {
        if (pcmdtext) {
            ASSERT(cCmds == 1);
            switch (pcmdtext->cmdtextf)
            {
            case OLECMDTEXTF_NAME:
            {
                TOOLTIPTEXTA ttt = { NULL };
                CHAR *pszBuffer = ttt.szText;
                CHAR szTemp[MAX_TOOLTIP_STRING];

                ttt.hdr.code = TTN_NEEDTEXTA;
                ttt.hdr.idFrom = rgCmds[0].cmdID;
                ttt.lpszText = ttt.szText;
                OnNotify((LPNMHDR)&ttt);

                if (ttt.hinst)
                {
                    LoadStringA(ttt.hinst, (UINT) PtrToUlong(ttt.lpszText), szTemp, ARRAYSIZE(szTemp));
                    pszBuffer = szTemp;
                }
                else if (ttt.lpszText)
                    pszBuffer = ttt.lpszText;

                pcmdtext->cwActual = SHAnsiToUnicode(pszBuffer, pcmdtext->rgwz, pcmdtext->cwBuf);
                pcmdtext->cwActual -= 1;
                hres = S_OK;
                break;
            }

            default:    
                hres = E_FAIL;
                break;
            }        
        } else {
            for (ULONG i = 0 ; i < cCmds ; i++) {

                switch(rgCmds[i].cmdID) {
                case FCIDM_PREVIOUSFOLDER:
                    if (_ShouldAllowNavigateParent())
                        rgCmds[i].cmdf |= OLECMDF_ENABLED;
                    else
                        rgCmds[i].cmdf &= OLECMDF_ENABLED;

                    hres = S_OK;
                    break;
                }
            }
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        // should fill pcmdtext as well

        for (ULONG i = 0 ; i < cCmds ; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case SBCMDID_SHOWCONTROL:
            case SBCMDID_DOFAVORITESMENU:
            case SBCMDID_ACTIVEOBJECTMENUS:            
            case SBCMDID_SETMERGEDWEBMENU:
                rgCmds[i].cmdf = OLECMDF_ENABLED;   // support these unconditionally
                break;

            case SBCMDID_DOMAILMENU:
                rgCmds[i].cmdf = SHIsRegisteredClient(NEWS_DEF_KEY) || SHIsRegisteredClient(MAIL_DEF_KEY) ? OLECMDF_ENABLED : 0;
                //If go menu is restricted, disable mail menu on toolbar also
                if (SHRestricted2(REST_GoMenu, NULL, 0))
                    rgCmds[i].cmdf = 0;
                break;

            case SBCMDID_SEARCHBAR:
            case SBCMDID_FAVORITESBAR:
            case SBCMDID_HISTORYBAR:
            case SBCMDID_EXPLORERBAR:
            case SBCMDID_DISCUSSIONBAND:
            case SBCMDID_MEDIABAR:
                {
                UINT idm;

                rgCmds[i].cmdf |= OLECMDF_SUPPORTED|OLECMDF_ENABLED;
                
                switch (rgCmds[i].cmdID) {
                case SBCMDID_DISCUSSIONBAND: 
                    {
                        // Perf: Avoid calling _InfoCLSIDToIdm unless we have loaded
                        // the band info already because it is very expensive!
                        if (_pbsmInfo && FCIDM_VBBNOHORIZONTALBAR != _idmComm)
                        {
                            idm = _InfoCLSIDToIdm(&CLSID_DiscussionBand);
                            if (idm == -1)
                            {
                                // The discussion band is not registered
                                ClearFlag(rgCmds[i].cmdf, OLECMDF_SUPPORTED|OLECMDF_ENABLED);
                            }
                            else if (idm == _idmComm)
                            {
                                rgCmds[i].cmdf |= OLECMDF_LATCHED;
                            }
                        }
                        else
                        {
                            //
                            // Since the band info has not been loaded or idmComm is FCIDM_VBBNONE,
                            // we know that the discussion band is not up and is not latched.  So
                            // we can check the registry instead and avoid defer the cost of
                            // initializing _pbsmInfo
                            //
                            // See if the discussions band is registered for the CATID_CommBand
                            idm = -1;
                            HKEY hkey = NULL;
                            static BOOL fDiscussionBand = -1;

                            // We get called a lot, so only read the registry once.
                            if (-1 == fDiscussionBand)
                            {
                                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, c_szDiscussionBandReg, NULL, KEY_READ, &hkey) == ERROR_SUCCESS)
                                {
                                    // We found the discussions band
                                    fDiscussionBand = 1;
                                    RegCloseKey(hkey);
                                }
                                else
                                {
                                    fDiscussionBand = 0;
                                }
                            }

                            if (!fDiscussionBand)
                            {
                                // The discussions band is not registered
                                ClearFlag(rgCmds[i].cmdf, OLECMDF_SUPPORTED|OLECMDF_ENABLED);
                            }
                        }
                        break;
                    }
                case SBCMDID_SEARCHBAR:      idm=FCIDM_VBBSEARCHBAND     ; break;
                case SBCMDID_FAVORITESBAR:  
                    idm=FCIDM_VBBFAVORITESBAND;
                    if (SHRestricted2(REST_NoFavorites, NULL, 0))
                        ClearFlag(rgCmds[i].cmdf, OLECMDF_ENABLED);
                    break;
                case SBCMDID_HISTORYBAR:     idm=FCIDM_VBBHISTORYBAND    ; break;
                case SBCMDID_EXPLORERBAR:    idm=FCIDM_VBBEXPLORERBAND   ; break;
                case SBCMDID_MEDIABAR:       idm=FCIDM_VBBMEDIABAND      ; break;

                default:
                    ASSERT(FALSE);
                    return E_FAIL;
                }

                if (idm == _idmInfo)
                    rgCmds[i].cmdf |= OLECMDF_LATCHED;

                break;
                }
            }
        }
        hres = S_OK;
    }
        
    return hres;
}

// REARCHITECT (980710 adp) should clean up to do consistent routing.  this
// ad-hoc per-nCmdID stuff is too error-prone.
HRESULT CShellBrowser2::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, 
                             VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        switch (nCmdID) 
        {
        case OLECMDID_SETTITLE:
            // NT #282632: This bug is caused when the current IShellView is a web page and
            //    the pending view is a shell folder w/Web View that has certain timing charataristics.
            //    MSHTML from the Web View will fire OLECMDID_SETTITLE with the URL of the
            //    web view template.  The problem is that there is a bug in IE4 SI's shell32
            //    that let that message go to the browser (here), even though the view wasn't
            //    active.  Since we don't know who it came from, we forward it down to the current
            //    view who squirls away the title.  This title is then given in the Back toolbar
            //    button drop down history.  This is hack around the IE4 SI shell32 bug is to kill
            //    that message. -BryanSt
            TraceMsg(DM_TRACE, "csb.e: SetTitle is called");
            break;  // continue.

        // Clipboard commands and common operations will be dispatched 
        // to the currently focused toolbar.
        case OLECMDID_CUT:
        case OLECMDID_COPY:
        case OLECMDID_PASTE:
        case OLECMDID_DELETE:
        case OLECMDID_PROPERTIES:
            if (_HasToolbarFocus()) {
                LPTOOLBARITEM ptbi;
                if (ptbi = _GetToolbarItem(_get_itbLastFocus()))
                {
                    HRESULT hres = IUnknown_Exec(ptbi->ptbar, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                    if (SUCCEEDED(hres))
                        return hres;
                }
            }
            break;  // give the view a chance
        }
    }
    else if (IsEqualGUID(CGID_DefView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
            case DVID_RESETDEFAULT:

//  99/02/09 #226140 vtan: Exec command issued from
//  CFolderOptionsPsx::ResetDefFolderSettings()
//  when user clicks "Reset All Folders" in folder
//  options "View" tab. Pass this thru to DefView.

                ASSERTMSG(nCmdexecopt == OLECMDEXECOPT_DODEFAULT, "nCmdexecopt must be OLECMDEXECOPT_DODEFAULT");
                ASSERTMSG(pvarargIn == NULL, "pvarargIn must be NULL");
                ASSERTMSG(pvarargOut == NULL, "pvarargOut must be NULL");
                IUnknown_Exec(_pbbd->_psv, &CGID_DefView, DVID_RESETDEFAULT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
                return(S_OK);
                break;
            default:
                break;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
#ifdef UNIX
        case SBCMDID_MSGBAND:
            if (_pbbd->_hwnd)
            {
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = (LONG)_pbbd->_hwnd;
                return S_OK;
            }
            return S_FALSE;
#endif
        case SBCMDID_MAYSAVEVIEWSTATE:
            return _fDontSaveViewOptions ? S_FALSE : S_OK;  // May need to save out earlier...
            
        case SBCMDID_CANCELANDCLOSE:
            _CancelPendingNavigationAsync();
            PostMessage(_pbbd->_hwnd, WM_CLOSE, 0, 0);

            return S_OK;

        case SBCMDID_CANCELNAVIGATION:
            //
            // Special code to close the window if the very first navigation caused
            // an asynchronous download (e.g. from athena).
            //
            if (!_pbbd->_pidlCur && pvarargIn && pvarargIn->vt == VT_I4 && pvarargIn->lVal == FALSE) 
            {
                _CancelPendingNavigationAsync();
                PostMessage(_pbbd->_hwnd, WM_CLOSE, 0, 0);

                return S_OK;
            }

            break; // fall through

        case SBCMDID_MIXEDZONE:
            _UpdateZonesPane(pvarargIn);
            break;

        case SBCMDID_ISIEMODEBROWSER:
            return v_IsIEModeBrowser() ? S_OK : S_FALSE;

        case SBCMDID_STARTEDFORINTERNET:
            return _fInternetStart ? S_OK : S_FALSE;

        case SBCMDID_ISBROWSERACTIVE:
            return _fActivated ? S_OK : S_FALSE;

        case SBCMDID_SUGGESTSAVEWINPOS:
            if (_ShouldSaveWindowPlacement())
            {
                StorePlacementOfWindow(_pbbd->_hwnd);
                return S_OK;
            }
            return S_FALSE;

        case SBCMDID_ONVIEWMOVETOTOP:
            if (_ptheater)
            {
                return _ptheater->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
            return S_FALSE;
        }    
    } 
    else if (IsEqualGUID(CGID_MenuBandHandler, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case MBHANDCID_PIDLSELECT:
            {
                LPITEMIDLIST pidl = VariantToIDList(pvarargIn);
                if (pidl)
                {
                    if (!ILIsEmpty(pidl))
                    {
                        if (_pidlMenuSelect)
                            KillTimer(_pbbd->_hwnd, SHBTIMER_MENUSELECT);
                    
                        // Opening the favorites' shortcuts can be slow.  So set a
                        // timer so we don't open needlessly as the mouse runs over
                        // the menu quickly.
                        if (Pidl_Set(&_pidlMenuSelect, pidl))
                        {
                            if (!SetTimer(_pbbd->_hwnd, SHBTIMER_MENUSELECT, MENUSELECT_TIME, NULL))
                                Pidl_Set(&_pidlMenuSelect, NULL);
                        }
                    }
                    ILFree(pidl);
                }
            }
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_MenuBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case MBANDCID_EXITMENU:
            // we're done with the menu band (favorites)
            // kill the timer
            // this is to fix bug #61917 where the status bar would get stack
            // in the simple mode (actually the timer would go off after we 
            // navigated to the page with the proper status bar mode, but then
            // we would call _DisplayFavoriteStatus that would put it back in
            // the simple mode)
            if (_pidlMenuSelect)
                KillTimer(_pbbd->_hwnd, SHBTIMER_MENUSELECT);
            
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_FilterObject, *pguidCmdGroup))
    {
        HRESULT hres = E_INVALIDARG;

        switch (nCmdID)
        {
        case PHID_FilterOutPidl:
            {
                LPITEMIDLIST pidl = VariantToIDList(pvarargIn);
                if (pidl)
                {
                    // We are filtering out everything except folders, shortcuts, and 
                    // internet shortcuts
                    DWORD dwAttribs = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_LINK;

                    // include everthing by default
                    VariantClearLazy(pvarargOut); 
                    pvarargOut->vt = VT_BOOL;
                    pvarargOut->boolVal = VARIANT_FALSE;    

                    IEGetAttributesOf(pidl, &dwAttribs);

                    // include all non file system objects, folders and links
                    // (non file system things like the Channel folders contents)
                    if (!(dwAttribs & (SFGAO_FOLDER | SFGAO_LINK)) &&
                         (dwAttribs & SFGAO_FILESYSTEM))
                        pvarargOut->boolVal = VARIANT_TRUE; // don't include

                    hres = S_OK;
                    ILFree(pidl);
                }
            }
            break;

        default:
            TraceMsg(TF_WARNING, "csb.e: Received unknown CGID_FilterObject cmdid (%d)", nCmdID);
            break;
        }

        return hres;
    } 
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        // we reflect AMBIENTPROPCHANGE down because this is how iedisp notifies dochost
        // that an ambient property has changed. we don't need to reflect this down in
        // cwebbrowsersb because only the top-level iwebbrowser2 is allowed to change props
        case SHDVID_AMBIENTPROPCHANGE:
        case SHDVID_PRINTFRAME:
        case SHDVID_MIMECSETMENUOPEN:
        case SHDVID_FONTMENUOPEN:
            if (pvarargIn)
            {
                if ((VT_I4 == pvarargIn->vt) && (DISPID_AMBIENT_OFFLINEIFNOTCONNECTED == pvarargIn->lVal))
                {
                    VARIANT_BOOL fIsOffline;
                    if (_pbbd->_pautoWB2)
                    {
                        _pbbd->_pautoWB2->get_Offline(&fIsOffline);
                        if (fIsOffline)
                        {
                            // this top level frame just went Offline 
                            //  - so decr net session count
                            _DecrNetSessionCount();
                        }
                        else
                        {
                            // this top level frame went online. 
                            _IncrNetSessionCount();
                        }     
                    }
                }
            }
            break;
        }
    }

    HRESULT hres = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    if (pguidCmdGroup == NULL)
    {
DefaultCommandGroup:

        switch (nCmdID) 
        {
        case OLECMDID_REFRESH:
            // FolderOptions.Advanced refreshes all browser windows
            _UpdateRegFlags();
            _SetTitle(NULL); // maybe "full path in title bar" changed

            v_ShowHideChildWindows(FALSE);
            
            // pass this to the browserbar
            IDeskBar* pdb;
            FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdb));
            if (pdb) 
            {
                IUnknown_Exec(pdb, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                pdb->Release();
            }            
            hres = S_OK;
            break;
        }
    }
    else if (IsEqualGUID(CGID_ShellBrowser, *pguidCmdGroup))
    {
        // toolbar buttons we put there ourselves

        hres = S_OK;    // assume accepted

        switch (nCmdID)
        {
        case FCIDM_PREVIOUSFOLDER:
            v_ParentFolder();
            break;

        case FCIDM_CONNECT:
            DoNetConnect(_pbbd->_hwnd);
            break;
    
        case FCIDM_DISCONNECT:
            DoNetDisconnect(_pbbd->_hwnd);
            break;

        case FCIDM_GETSTATUSBAR:
            if (pvarargOut->vt == VT_I4)
                pvarargOut->lVal = _fStatusBar;
            break;

        case FCIDM_SETSTATUSBAR:
            if (pvarargIn->vt == VT_I4) 
            {
                _fStatusBar = pvarargIn->lVal;
                v_ShowHideChildWindows(FALSE);
            }
            break;

        case FCIDM_PERSISTTOOLBAR:
            _SaveITbarLayout();
            break;

        default:
            // pass off the nCmdID to the view for processing / translation.
            DFVCMDDATA cd;

            cd.pva = pvarargIn;
            cd.hwnd = _pbbd->_hwnd;
            cd.nCmdIDTranslated = 0;
            SendMessage(_pbbd->_hwndView, WM_COMMAND, nCmdID, (LONG_PTR)&cd);

            if (cd.nCmdIDTranslated)
            {
                // We sent the private nCmdID to the view.  The view did not
                // process it (probably because it didn't have the focus),
                // but instead translated it into a standard OLECMDID for
                // further processing by the toolbar with the focus.

                pguidCmdGroup = NULL;
                nCmdID = cd.nCmdIDTranslated;
                hres = OLECMDERR_E_NOTSUPPORTED;
                goto DefaultCommandGroup;
            }
            break;
        }
    }
    else if (IsEqualGUID(IID_IExplorerToolbar, *pguidCmdGroup))
    {
        // these are commands to intercept
        if (_HasToolbarFocus() && _get_itbLastFocus() != ITB_ITBAR)
        {
            int idCmd = -1;

            // certain shell commands we should pick off
            switch (nCmdID)
            {
            case OLECMDID_DELETE:
            case SFVIDM_FILE_DELETE:
                idCmd = FCIDM_DELETE;
                break;

            case OLECMDID_PROPERTIES:
            case SFVIDM_FILE_PROPERTIES:
                idCmd = FCIDM_PROPERTIES;
                break;

            case OLECMDID_CUT:
            case SFVIDM_EDIT_CUT:
                idCmd = FCIDM_MOVE;
                break;

            case OLECMDID_COPY:
            case SFVIDM_EDIT_COPY:
                idCmd = FCIDM_COPY;
                break;

            case OLECMDID_PASTE:
            case SFVIDM_EDIT_PASTE:
                idCmd = FCIDM_PASTE;
                break;
            }

            if (idCmd != -1)
            {
                OnCommand(GET_WM_COMMAND_MPS(idCmd, 0, NULL));
                return S_OK;
            }
        }
    } 
    else if (IsEqualGUID(CGID_PrivCITCommands, *pguidCmdGroup)) 
    {
        return IUnknown_Exec(_GetITBar(), pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        hres = S_OK;        // assume we will get it

        switch(nCmdID) 
        {
        case SBCMDID_SETMERGEDWEBMENU:
            if (!_hmenuPreMerged)
                _hmenuPreMerged = _MenuTemplate(MENU_PREMERGED, FALSE);

            if (SHRestricted2W(REST_NoHelpMenu, NULL, 0))
            {
                DeleteMenu(_hmenuPreMerged, FCIDM_MENU_HELP, MF_BYCOMMAND);
            }

            SetMenuSB(_hmenuPreMerged, NULL, NULL);
            if (pvarargOut) {
                pvarargOut->vt = VT_INT_PTR;
                pvarargOut->byref = _hmenuPreMerged;
            }
            break;

        case SBCMDID_ACTIVEOBJECTMENUS:
            _fDispatchMenuMsgs = TRUE;
            break;

        case SBCMDID_SENDPAGE:
        case SBCMDID_SENDSHORTCUT:
            _SendCurrentPage(nCmdID == SBCMDID_SENDPAGE ? FORCE_COPY : FORCE_LINK);
            break;

        case SBCMDID_SEARCHBAR:
        case SBCMDID_FAVORITESBAR:
        case SBCMDID_HISTORYBAR:
        case SBCMDID_EXPLORERBAR:
        case SBCMDID_DISCUSSIONBAND:
        case SBCMDID_MEDIABAR:
            {
            UINT idm;

            switch (nCmdID) 
            {
            case SBCMDID_SEARCHBAR:      idm = FCIDM_VBBSEARCHBAND      ; break;
            case SBCMDID_FAVORITESBAR:   idm = FCIDM_VBBFAVORITESBAND   ; break;
            case SBCMDID_HISTORYBAR:     idm = FCIDM_VBBHISTORYBAND     ; break;
            case SBCMDID_EXPLORERBAR:    idm = FCIDM_VBBEXPLORERBAND    ; break;
            case SBCMDID_MEDIABAR:       idm = FCIDM_VBBMEDIABAND       ; break;

            // The discussion band maps to one of the dynamic bands
            case SBCMDID_DISCUSSIONBAND: idm = _InfoCLSIDToIdm(&CLSID_DiscussionBand)  ; break;
            default:                     idm = -1; break;
            }

            if (idm != -1)
            {
                // default is toggle (-1)
                int i = (pvarargIn && EVAL(pvarargIn->vt == VT_I4)) ? pvarargIn->lVal : -1;
                LPITEMIDLIST pidl = VariantToIDList(pvarargOut);    // accepts null variant input
                _SetBrowserBarState(idm, NULL, i, pidl);
                ILFree(pidl);   // accepts NULL
            }

            hres = S_OK;

            break;
            }

        case SBCMDID_SHOWCONTROL:
        {
            DWORD dwRet;
            int iControl, iCmd;
            
            if (nCmdexecopt == OLECMDEXECOPT_DODEFAULT &&
                pvarargIn &&
                pvarargIn->vt == VT_I4) 
            {
                iControl = (int)(short)LOWORD(pvarargIn->lVal);
                iCmd = (int)(short)HIWORD(pvarargIn->lVal);
            } 
            else 
            {
                iControl = (int)(short)LOWORD(nCmdexecopt);
                iCmd = (HIWORD(nCmdexecopt) ? SBSC_SHOW : SBSC_HIDE);
            }                

            dwRet = v_ShowControl(iControl, iCmd);
            if (dwRet == (DWORD)-1)
                break;

            if (pvarargOut) 
            {
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = dwRet;
            }
            break;
        }

        case SBCMDID_DOFAVORITESMENU:
        case SBCMDID_DOMAILMENU:
            {
                HMENU hmenu = NULL;

                if (nCmdID == SBCMDID_DOFAVORITESMENU)
                {
                    HMENU hmenuWnd = NULL;
                   
                    IShellMenu* psm;
                    if (SUCCEEDED(_pmb->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
                    {
                        psm->GetMenu(&hmenuWnd, NULL, NULL);
                        psm->Release();
                    }
                    
                    if (hmenuWnd)
                    {
                        hmenu = SHGetMenuFromID(hmenuWnd, FCIDM_MENU_FAVORITES);
                    }
                }
                else
                    hmenu = LoadMenuPopup(MENU_MAILNEWS);

                if (hmenu)
                {
                    if (pvarargIn && pvarargIn->vt == VT_I4) 
                    {
                        TrackPopupMenu(hmenu, 0, 
                            GET_X_LPARAM(pvarargIn->lVal), GET_Y_LPARAM(pvarargIn->lVal), 
                            0, _GetCaptionWindow(), NULL);
                    }
                    if (nCmdID == SBCMDID_DOMAILMENU)
                        DestroyMenu(hmenu);
                }
            }
            break;

        case SBCMDID_SELECTHISTPIDL:
            {
                //  remember most recent hist pidl.  if we have history band visible, tell it
                //  the hist pidl.  if the band is not visible, it is it's responsibility to
                //  query the most recent hist pidl via SBCMDID_GETHISTPIDL
                //  the semantics of the call from UrlStorage is that if we respond S_OK to
                //  to this command, we take ownership of pidl and must ILFree it.
                //  when we call the band, on the other hand, they must ILClone it if they want
                //  to use it outside of the Exec call.
                if (_pidlLastHist) 
                {
                    ILFree(_pidlLastHist);
                    _pidlLastHist = NULL;
                }
                _pidlLastHist = VariantToIDList(pvarargIn); // take ownership

                if (_poctNsc)
                {
                    _poctNsc->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                }
            }
            break;

        case SBCMDID_GETHISTPIDL:
            if (pvarargOut) {
                VariantClearLazy(pvarargOut);
                if (_pidlLastHist)
                {
                    InitVariantFromIDList(pvarargOut, _pidlLastHist);
                }
            }
            break;

        case SBCMDID_UNREGISTERNSCBAND:
            if (pvarargIn && pvarargIn->vt == VT_UNKNOWN && pvarargIn->punkVal)
            {
                if (_poctNsc && SHIsSameObject(_poctNsc, pvarargIn->punkVal))
                {
                    ATOMICRELEASE(_poctNsc);
                    IUnknown_SetSite(_pcmNsc, NULL);
                    ATOMICRELEASE(_pcmNsc);
                }
            }
            break;

        case SBCMDID_REGISTERNSCBAND:
            ATOMICRELEASE(_poctNsc);
            IUnknown_SetSite(_pcmNsc, NULL);
            ATOMICRELEASE(_pcmNsc);
            if (pvarargIn && pvarargIn->vt == VT_UNKNOWN && pvarargIn->punkVal)
            {
                pvarargIn->punkVal->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_poctNsc));
            }
            break;
                    
        case SBCMDID_TOOLBAREMPTY:
            if (pvarargIn && VT_UNKNOWN == pvarargIn->vt && pvarargIn->punkVal) 
            {
                if (_IsSameToolbar(INFOBAR_TBNAME, pvarargIn->punkVal))
                    _SetBrowserBarState(_idmInfo, NULL, 0);
                else if (_IsSameToolbar(COMMBAR_TBNAME, pvarargIn->punkVal))
                    _SetBrowserBarState(_idmComm, NULL, 0);
                else
                    _HideToolbar(pvarargIn->punkVal);
            }
            break;

        case SBCMDID_GETTEMPLATEMENU:
            if (pvarargOut) 
            {
                pvarargOut->vt = VT_INT_PTR;
                pvarargOut->byref = (LPVOID)_hmenuTemplate;
            }
            break;

        case SBCMDID_GETCURRENTMENU:
            if (pvarargOut) 
            {
                pvarargOut->vt = VT_INT_PTR;
                pvarargOut->byref = (LPVOID)_hmenuCur;
            }
            break;

        default:
            //
            // Note that we should return hres from the super class as-is.
            //
            // hres = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    } 
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case SHDVID_GETSYSIMAGEINDEX:
            pvarargOut->vt = VT_I4;
            pvarargOut->lVal = _GetIconIndex();
            hres = (pvarargOut->lVal==-1) ? E_FAIL : S_OK;
            break;
            
        case SHDVID_HELP:
            SHHtmlHelpOnDemandWrap(_pbbd->_hwnd, TEXT("iexplore.chm > iedefault"), HH_DISPLAY_TOPIC, 0, ML_CROSSCODEPAGE);
            hres = S_OK;
            break;
            
        case SHDVID_GETBROWSERBAR:
        {
            const CLSID *pclsid = _InfoIdmToCLSID(_idmInfo);
            // kinda strange to (ab-)use checked menu items as
            // state marker to persist the CLSID between Exec calls (applies also to SHDVID_NAVIGATEBBTOURL below)!!
            // but that's how both SHDVID_GETBROWSERBAR and SHDVID_NAVIGATEBBTOURL are called
            //
            // assume that the currently checked menu points to the explorer bar
            // this navigate to URL is aimed to.
            // Currently Trident's NavigateInBand is the only caller
            // using this command; it calls SHDVID_GETBROWSERBAR first and thus set the _idmInfo

            IBandSite *pbs;
            hres = E_FAIL;

            VariantInit(pvarargOut);

            _GetBrowserBar(IDBAR_VERTICAL, TRUE, &pbs, pclsid);
            if (pbs) 
            {
                IDeskBand *pband = _GetInfoBandBS(pbs, *pclsid);
                if (pband) 
                {
                    pvarargOut->vt = VT_UNKNOWN;
                    pvarargOut->punkVal = pband;
                    hres = S_OK;
                }
                pbs->Release();
            }
            break;
        }
        
        case SHDVID_SHOWBROWSERBAR:
            {
                CLSID *pclsid;
                CLSID guid;
                if (pvarargIn->vt == VT_BSTR) 
                {
                    if (SUCCEEDED(IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_VIEWEXTERNALBAND_BYCLASSID, nCmdexecopt, pvarargIn, NULL))) 
                    {
                        hres = S_OK;
                        break;
                    }

                    // external (can marshal)
                    if (!GUIDFromString(pvarargIn->bstrVal, &guid))
                        return S_OK; // Invalid CLSID; IE5 returned S_OK so I guess it's ok

                    pclsid = &guid;
                }
                else if (pvarargIn->vt == VT_INT_PTR) 
                {
                    // internal (can't marshal)
                    ASSERT(0);  // dead code?  let's make sure...
                    TraceMsg(TF_WARNING, "csb.e: SHDVID_SHOWBROWSERBAR clsid !marshall (!)");
                    pclsid = (CLSID *) (pvarargIn->byref);
                }
                else 
                {
                    ASSERT(0);
                    pclsid = NULL;
                    break;
                }

                // enforce mediabar restriction: even though menu and toolbar have MediaBar disabled, resp. removed
                // user can still launch thru targeting _media or when mediabar was last open explorer bar before restriction is set
                if (    IsEqualIID(*pclsid, CLSID_MediaBand)
                    && SHRestricted2(REST_No_LaunchMediaBar, NULL, 0) )
                {
                    hres = E_ACCESSDENIED;
                    pclsid = NULL;
                    break;
                }
                _SetBrowserBarState(-1, pclsid, nCmdexecopt ? 1 : 0);
                hres = S_OK;
                break;
            }

        case SHDVID_ISBROWSERBARVISIBLE:
            // Quickly return false if both bars are hidden
            hres = S_FALSE;
            if (_idmComm != FCIDM_VBBNOHORIZONTALBAR || _idmInfo != FCIDM_VBBNOVERTICALBAR)
            {
                if (pvarargIn->vt == VT_BSTR)
                {
                    // Get the associated id
                    CLSID clsid;
                    if (GUIDFromString(pvarargIn->bstrVal, &clsid))
                    {
                        UINT idm = _InfoCLSIDToIdm(&clsid);
                        if (_idmComm == idm || _idmInfo == idm)
                        {
                            // It's visible!
                            hres = S_OK; 
                        }
                    }
                }
            }
            return hres;

        case SHDVID_ISEXPLORERBARVISIBLE:
            hres = (_idmInfo != FCIDM_VBBNOVERTICALBAR) ? S_OK : S_FALSE;
            return hres;

        case SHDVID_NAVIGATEBB:
        {
            LPITEMIDLIST pidl = VariantToIDList(pvarargIn);
            if (pidl)
            {
                if (!ILIsEmpty(pidl))
                {
                    IBandSite   * pbs;
                    const CLSID * pclsid = _InfoIdmToCLSID(_idmInfo);

                    _GetBrowserBar(IDBAR_VERTICAL, TRUE, &pbs, pclsid);
                    if (pbs) 
                    {
                        IDeskBand *pband = _GetInfoBandBS(pbs, *pclsid);
                        if (pband) 
                        {
                            IBandNavigate *pbn;
                            pband->QueryInterface(IID_PPV_ARG(IBandNavigate, &pbn));
                            if (pbn) 
                            {
                                pbn->Select(pidl);
                                pbn->Release();
                            }
                            pband->Release();
                        }
                        pbs->Release();
                    }
                    hres = S_OK;
                }
                ILFree(pidl);
            }
            break;
        }

        case SHDVID_NAVIGATEBBTOURL:
        {
            const CLSID *pclsid = _InfoIdmToCLSID(_idmInfo);
            if (    IsEqualIID(*pclsid, CLSID_MediaBand)
                &&  SHRegGetBoolUSValue(REG_MEDIA_STR, TEXT("SuppressOnlineContent"), FALSE, FALSE))
            {
                hres = E_FAIL;
                break;
            }
            LPITEMIDLIST pidl;
            hres = IEParseDisplayNameWithBCW(CP_ACP, V_BSTR(pvarargIn), NULL, &pidl);
            
            if (!hres && pidl && !ILIsEmpty(pidl))
            {
                // see comments in SHDVID_GETBROWSERBAR above!
                //
                // assume that the currently checked menu points to the explorer bar
                // this navigate to URL is aimed to.
                // Currently Trident's NavigateInBand is the only caller
                // using this command; it calls SHDVID_GETBROWSERBAR first and thus set the _idmInfo

                IBandSite *pbs;
                _GetBrowserBar(IDBAR_VERTICAL, TRUE, &pbs, pclsid);
            
                if (pbs) 
                {
                    IDeskBand *pband = _GetInfoBandBS(pbs, *pclsid);
                    if (pband) 
                    {
                        // 
                        // See if we can use ISearchBandTBHelper which has a "truer" navigate
                        // method.
                        //
                        ISearchBandTBHelper * pSearchBandTBHelper = NULL;

                        pband->QueryInterface(IID_ISearchBandTBHelper, (void**)&pSearchBandTBHelper);
                        if (pSearchBandTBHelper)
                        {
                            pSearchBandTBHelper->NavigateToPidl(pidl);
                            pSearchBandTBHelper->Release();
                        }
                        else
                        {
                            //
                            // Probably a different band.  See if it implements 
                            // IBandNavigate
                            //
                            IBandNavigate * pbn = NULL;
                    
                            pband->QueryInterface(IID_PPV_ARG(IBandNavigate, &pbn));
                            if (pbn) 
                            {
                                pbn->Select(pidl);
                                pbn->Release();
                            }
                            pband->Release();
                        }
                    }
                    pbs->Release();
                }
                
                ILFree(pidl);
            }
            break;
        }

        case SHDVID_CLSIDTOIDM:
            ASSERT(pvarargIn && pvarargIn->vt == VT_BSTR && pvarargOut);
            CLSID clsid;

            GUIDFromString(pvarargIn->bstrVal, &clsid);

            pvarargOut->vt = VT_I4;
            pvarargOut->lVal = _InfoCLSIDToIdm(&clsid);
            
            hres = S_OK;
            break;
        }
    } 
    else if (IsEqualGUID(CGID_Theater, *pguidCmdGroup)) 
    {
        if (_ptheater)
            hres = _ptheater->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else if (IsEqualGUID(CGID_ExplorerBarDoc, *pguidCmdGroup)) 
    {
        //  These are commands that should be applied to all the explorer bar bands.  for example
        //  to reflect font size changes to the search band. they should be applied to the
        //  contained doc object, changing guid to CGID_MSTHML
        _ExecAllBands(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else if (IsEqualGUID(CGID_DocHostCmdPriv, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        // This command is sent by Trident when 
        // navigating in a shell view.
        //
        case DOCHOST_DOCHYPERLINK:  // Sent by Trident when in a shell view.
            hres = E_FAIL;
            
            if (VT_BSTR == V_VT(pvarargIn))
            {
                LPITEMIDLIST pidl = NULL;
            
                hres = IEParseDisplayNameWithBCW(CP_ACP, V_BSTR(pvarargIn), NULL, &pidl);

                if (pidl)
                {
                    hres = BrowseObject(pidl, SBSP_SAMEBROWSER);
                    ILFree(pidl);
                }
            }

            break;

       
        default:
            break;
        }
    }

    return hres;
}


//***   _IsSameToolbar -- does punkBar have specified name?
// ENTRY/EXIT
//  fRet    TRUE if matches, o.w. FALSE
//
BOOL CShellBrowser2::_IsSameToolbar(LPWSTR wszBarName, IUnknown *punkBar)
{
    BOOL fRet = FALSE;
    IUnknown *punk;
    HRESULT hres = FindToolbar(wszBarName, IID_PPV_ARG(IUnknown, &punk));
    ASSERT((hres == S_OK) == (punk != NULL));
    if (punk) 
    {
        if (SHIsSameObject(punkBar, punk)) 
        {
            fRet = TRUE;
        }
        punk->Release();
    }
    return fRet;
}

STDAPI SHGetWindowTitle(LPCITEMIDLIST pidl, LPTSTR pszFullName, DWORD cchSize)
{
    CABINETSTATE cs;
    GetCabState(&cs);

    return SHTitleFromPidl(pidl, pszFullName, cchSize, cs.fFullPathTitle);
}

// pwszName - The Name of the URL, not
//            limited in size, but the result will
//            be truncated if the imput is too long.
//
// The title will be generated by taking the
// title of the HTML page (pszName) and appending
// the name of the browser to the end in the
// following format:
//    "HTML_TITLE - BROWSER_NAME", like:
//    "My Web Page - Microsoft Internet Explorer"

void CShellBrowser2::_SetTitle(LPCWSTR pwszName)
{
    TCHAR szTitle[MAX_BROWSER_WINDOW_TITLE];
    TCHAR szFullName[MAX_PATH];
    BOOL fNotDisplayable = FALSE;

    if (!pwszName && _fTitleSet) 
    {
        // if the content has once set our title,
        // don't revert to our own mocked up name
        return;
    }
    else if (pwszName)
    {
        _fTitleSet = TRUE;
    }

    BOOL fDisplayable = SHIsDisplayable(pwszName, g_fRunOnFE, g_bRunOnNT5);

    if (pwszName && fDisplayable) 
    {
        StrCpyN(szFullName, pwszName, ARRAYSIZE(szFullName));
        SHCleanupUrlForDisplay(szFullName);
    }
    else if (_pbbd->_pidlCur)
    {
        SHGetWindowTitle(_pbbd->_pidlCur, szFullName, ARRAYSIZE(szFullName));
    }
    else if (_pbbd->_pidlPending)
    {
        SHGetWindowTitle(_pbbd->_pidlPending, szFullName, ARRAYSIZE(szFullName));
    }
    else
        szFullName[0] = 0;

    // Before adding on the app title truncate the szFullName so that if it is 
    // really long then when the app title " - Microsoft Internet Explorer" is
    // appended it fits.
    //
    // Used to be 100, but that wasn't quite enough to display default title.
    //
    ASSERT(96 <= ARRAYSIZE(szFullName));
    SHTruncateString(szFullName, 96); // any more than 60 is useless anyways

    if (szFullName[0]) 
    {
        TCHAR szBuf[MAX_URL_STRING];

        v_GetAppTitleTemplate(szBuf, szFullName);

        wnsprintf(szTitle, ARRAYSIZE(szTitle), szBuf, szFullName); 
    }
    else if (_fInternetStart)
    {
        _GetAppTitle(szTitle, ARRAYSIZE(szTitle));
    } 
    else
        szTitle[0] = 0;

    SendMessage(_pbbd->_hwnd, WM_SETTEXT, 0, (LPARAM)szTitle);
}

void _SetWindowIcon (HWND hwnd, HICON hIcon, BOOL bLarge)

{
    HICON   hOldIcon;
    //
    // If the shell window is RTL mirrored, then flip the icon now,
    // before inserting them into the system cache, so that they end up
    // normal (not mirrrored) on the shell. This is mainly a concern for
    // 3rd party components. [samera]
    //
    if (IS_PROCESS_RTL_MIRRORED())
    {        
        SHMirrorIcon(&hIcon, NULL);
    }

    hOldIcon = (HICON)SendMessage(hwnd, WM_SETICON, bLarge, (LPARAM)hIcon);
    if (hOldIcon &&
        (hOldIcon != hIcon))
    {
        DestroyIcon(hOldIcon);
    }
}

void _WindowIconFromImagelist(HWND hwndMain, int nIndex, BOOL bLarge)
{
    HIMAGELIST himlSysLarge = NULL;
    HIMAGELIST himlSysSmall = NULL;

    Shell_GetImageLists(&himlSysLarge, &himlSysSmall);

    // if we're using the def open icon or if extracting fails,
    // use the icon we've already created.
    HICON hIcon = ImageList_ExtractIcon(g_hinst, bLarge ? himlSysLarge : himlSysSmall, nIndex);
    if (hIcon)
        _SetWindowIcon(hwndMain, hIcon, bLarge);
}

int CShellBrowser2::_GetIconIndex(void)
{

    int iSelectedImage = -1;
    if (_pbbd->_pidlCur) 
    {
        if (_pbbd->_pctView) // we must check!
        {
            VARIANT var = {0};
            HRESULT hresT = _pbbd->_pctView->Exec(&CGID_ShellDocView, SHDVID_GETSYSIMAGEINDEX, 0, NULL, &var);
            if (SUCCEEDED(hresT)) {
                if (var.vt==VT_I4) {
                    iSelectedImage= var.lVal;
                } else {
                    ASSERT(0);
                    VariantClearLazy(&var);
                }
            }
        }

        if (iSelectedImage==-1)
        {
            //
            // Put Optimization here. 
            //
            IShellFolder *psfParent;
            LPCITEMIDLIST pidlChild;

            if (SUCCEEDED(IEBindToParentFolder(_pbbd->_pidlCur, &psfParent, &pidlChild))) 
            {
                // set the small one first to prevent user stretch blt on the large one
                SHMapPIDLToSystemImageListIndex(psfParent, pidlChild, &iSelectedImage);
                psfParent->Release();
            }
        }
    }
    return iSelectedImage;
}

bool    CShellBrowser2::_IsExplorerBandVisible (void)

//  99/02/10 #254171 vtan: This function determines whether
//  the explorer band is visible. This class should not really
//  care but it needs to know to change the window's icon.
//  This is a hack and should be moved or re-architected.

//  99/02/12 #292249 vtan: Re-worked algorithm to use
//  IBandSite::QueryBand and IPersistStream::GetClassID to
//  recognize the explorer band. Note that the old routine
//  used IDeskBand's inclusion of IOleWindow to get the HWND
//  and use the Win32 API IsWindowVisible().

//  99/06/25 #359477 vtan: Put this code back.
//  IsControlWindowShown uses QueryStatus for the explorer
//  band which doesn't work when v_SetIcon is called. The
//  band is NOT considered latched and therefore not visible.

{
    IDeskBar    *pIDeskBar;
    bool bVisible = false;
    HRESULT hResult = FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pIDeskBar));
    if (SUCCEEDED(hResult) && (pIDeskBar != NULL))
    {
        UINT    uiToolBar;

        uiToolBar = _FindTBar(pIDeskBar);
        if (uiToolBar != static_cast<UINT>(-1))
        {
            LPTOOLBARITEM   pToolBarItem;

            pToolBarItem = _GetToolbarItem(uiToolBar);
            if ((pToolBarItem != NULL) && pToolBarItem->fShow)  // check this state
            {
                IUnknown    *pIUnknown;

                hResult = pIDeskBar->GetClient(reinterpret_cast<IUnknown**>(&pIUnknown));
                if (SUCCEEDED(hResult) && (pIUnknown != NULL))
                {
                    IBandSite   *pIBandSite;

                    hResult = pIUnknown->QueryInterface(IID_IBandSite, reinterpret_cast<void**>(&pIBandSite));
                    if (SUCCEEDED(hResult) && (pIBandSite != NULL))
                    {
                        UINT    uiBandIndex;
                        DWORD   dwBandID;

                        uiBandIndex = 0;
                        hResult = pIBandSite->EnumBands(uiBandIndex, &dwBandID);
                        while (SUCCEEDED(hResult))
                        {
                            DWORD       dwState;
                            IDeskBand   *pIDeskBand;

                            dwState = 0;
                            hResult = pIBandSite->QueryBand(dwBandID, &pIDeskBand, &dwState, NULL, 0);
                            if (SUCCEEDED(hResult))
                            {
                                CLSID   clsid;

                                hResult = IUnknown_GetClassID(pIDeskBand, &clsid);
                                if (SUCCEEDED(hResult) && IsEqualGUID(clsid, CLSID_ExplorerBand))
                                    bVisible = ((dwState & BSSF_VISIBLE) != 0);     // and this state
                                pIDeskBand->Release();
                                hResult = pIBandSite->EnumBands(++uiBandIndex, &dwBandID);
                            }
                        }
                        pIBandSite->Release();
                    }
                    pIUnknown->Release();
                }
            }
        }
        pIDeskBar->Release();
    }
    return(bVisible);
}

void CShellBrowser2::v_SetIcon()
{
    if (_IsExplorerBandVisible())
    {
        #define IDI_STFLDRPROP          46
        //  Explorer tree view pane is visible - use the magnifying glass icon
        HICON hIcon = reinterpret_cast<HICON>(LoadImage(HinstShell32(), MAKEINTRESOURCE(IDI_STFLDRPROP), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0));
        _SetWindowIcon(_pbbd->_hwnd, hIcon, ICON_SMALL);
        hIcon = reinterpret_cast<HICON>(LoadImage(HinstShell32(), MAKEINTRESOURCE(IDI_STFLDRPROP), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CXICON), 0));
        _SetWindowIcon(_pbbd->_hwnd, hIcon, ICON_BIG);
    }
    else
    {
        //  Otherwise use whatever icon it really should be
        int iSelectedImage = _GetIconIndex();
        if (iSelectedImage != -1) 
        {
            _WindowIconFromImagelist(_pbbd->_hwnd, iSelectedImage, ICON_SMALL);
            _WindowIconFromImagelist(_pbbd->_hwnd, iSelectedImage, ICON_BIG);
        }
    }
}

HRESULT CShellBrowser2::SetTitle(IShellView * psv, LPCWSTR lpszName)
{
    // If the pending view had it's title set immediately and waits
    // in pending state for a while. And if the current view has script updating
    // the title. Then the current title will be displayed after the navigate
    // is complete. I added psv to fix this problem to CBaseBrowser2, but I
    // didn't fix it here. [mikesh]
    //
    //  Don't set title if view is still pending (or you'll show unrated titles)
        // Figure out which object is changing.

    if (SHIsSameObject(_pbbd->_psv, psv))
    {
        _SetTitle(lpszName);
    }

    SUPERCLASS::SetTitle(psv, lpszName);
    return S_OK;
}

HRESULT CShellBrowser2::UpdateWindowList(void)
{
    if (_psw) {
        WinList_NotifyNewLocation(_psw, _dwRegisterWinList, _pbbd->_pidlCur);
    }
    return S_OK;
}

HRESULT CShellBrowser2::SetFlags(DWORD dwFlags, DWORD dwFlagMask)
{
    if (dwFlagMask & BSF_THEATERMODE)
        _TheaterMode(dwFlags & BSF_THEATERMODE, TRUE);

    if (dwFlagMask & BSF_RESIZABLE)
        SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_SIZEBOX, (dwFlags & BSF_RESIZABLE) ? WS_SIZEBOX : 0);

     if (dwFlagMask & BSF_CANMAXIMIZE)
        SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_MAXIMIZEBOX, (dwFlags & BSF_CANMAXIMIZE) ? WS_MAXIMIZEBOX : 0);

    if ((dwFlagMask & BSF_UISETBYAUTOMATION) && (dwFlags & BSF_UISETBYAUTOMATION))
    {
        _fDontSaveViewOptions = TRUE;
        _fUISetByAutomation = TRUE;
        // to hide any visible browser bar
        //REARCHITECT this will be removed when explorer bars become 1st class toolbars
        _SetBrowserBarState(_idmInfo, NULL, 0);
        _SetBrowserBarState(_idmComm, NULL, 0);
    }

    return SUPERCLASS::SetFlags(dwFlags, dwFlagMask);
}

HRESULT CShellBrowser2::GetFlags(DWORD *pdwFlags)
{
    DWORD dwFlags;
    
    SUPERCLASS::GetFlags(&dwFlags);

    if (_fUISetByAutomation)
        dwFlags |= BSF_UISETBYAUTOMATION;
    if (_fNoLocalFileWarning)
        dwFlags |= BSF_NOLOCALFILEWARNING;
    if (_ptheater)
        dwFlags |= BSF_THEATERMODE;
    *pdwFlags = dwFlags;

    return S_OK;
}

DWORD CShellBrowser2::v_ShowControl(UINT iControl, int iCmd)
{
    int iShowing = -1;
    int nWhichBand;

    switch (iControl) 
    {
    case FCW_STATUS:
        iShowing = (_fStatusBar ? SBSC_SHOW : SBSC_HIDE);
        if (iCmd != SBSC_QUERY && (iShowing != iCmd)) 
        {
            _fStatusBar = !_fStatusBar;
            // let itbar know that a change has occurred
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_STATUSCHANGED, 0, NULL, NULL);
            v_ShowHideChildWindows(FALSE);
        }
        break;

    case FCW_INTERNETBAR:
        {
            LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
            iShowing = (ptbi->fShow ? SBSC_SHOW : SBSC_HIDE);
            if (iCmd != SBSC_QUERY &&
                (iShowing != iCmd)) 
            {
                ptbi->fShow = !ptbi->fShow;
                v_ShowHideChildWindows(FALSE);
            }
        }
        break;

    case FCW_ADDRESSBAR:
    case FCW_TOOLBAND:
    case FCW_LINKSBAR:
    case FCW_MENUBAR:
        switch(iControl)
        {
            case FCW_ADDRESSBAR:
                nWhichBand = CITIDM_SHOWADDRESS;
                break;

            case FCW_TOOLBAND:
                nWhichBand = CITIDM_SHOWTOOLS;
                break;

            case FCW_LINKSBAR:
                nWhichBand = CITIDM_SHOWLINKS;
                break;

            case FCW_MENUBAR:
                nWhichBand = CITIDM_SHOWMENU;
                break;
        }
        if (iCmd != SBSC_QUERY)
        {
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, 
                nWhichBand, (iCmd == SBSC_SHOW), NULL, NULL);
        }
        break;

    default:
        break;
    }

    return iShowing;
}

HRESULT CShellBrowser2::ShowControlWindow(UINT id, BOOL fShow)
{
    switch (id)
    {
    case (UINT)-1:  // Set into Kiosk mode...
        if (BOOLIFY(_fKioskMode) != fShow)
        {
            _fKioskMode = fShow;
            if (_fKioskMode)
            {
                _wndpl.length = sizeof(WINDOWPLACEMENT);
                GetWindowPlacement(_pbbd->_hwnd, &_wndpl);
                SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX, 0);
                SHSetWindowBits(_pbbd->_hwnd, GWL_EXSTYLE, WS_EX_WINDOWEDGE, 0);
                _SetMenu(NULL);

                LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
                if (ptbi)
                {
                    ptbi->fShow = FALSE;
                }

                HMONITOR hmon = MonitorFromRect(&_wndpl.rcNormalPosition, MONITOR_DEFAULTTONEAREST);
                RECT rcMonitor;
                GetMonitorRect(hmon, &rcMonitor);
                
                SetWindowPos(_pbbd->_hwnd, NULL, rcMonitor.top, rcMonitor.left, RECTWIDTH(rcMonitor),
                        RECTHEIGHT(rcMonitor), SWP_NOZORDER);
            }
            else
            {
                if (_fShowMenu)
                    _SetMenu(_hmenuCur);
                else
                    _SetMenu(NULL);

                SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX, WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX);
                SHSetWindowBits(_pbbd->_hwnd, GWL_EXSTYLE, WS_EX_WINDOWEDGE, WS_EX_WINDOWEDGE);
                SetWindowPlacement(_pbbd->_hwnd, &_wndpl);
            }

            // Let window manager know to recalculate things...
            v_ShowHideChildWindows(FALSE);

            SetWindowPos(_pbbd->_hwnd, NULL, 0, 0, 0, 0,
                    SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_FRAMECHANGED);
        }
        break;

    case FCW_INTERNETBAR:
    case FCW_STATUS:
    case FCW_ADDRESSBAR:
        v_ShowControl(id, fShow ? SBSC_SHOW : SBSC_HIDE);
        break;
        
    case FCW_MENUBAR:
        if (BOOLIFY(_fShowMenu) != BOOLIFY(fShow))
        {
            _fShowMenu = BOOLIFY(fShow);
            if (_fShowMenu)
            {
                _SetMenu(_hmenuCur);
            }
            else
            {
                _SetMenu(NULL);
            }

            // Let window manager know to recalculate things...
            v_ShowControl(id, fShow ? SBSC_SHOW : SBSC_HIDE);
            // Let ITBar know whether to allow selection of menu bar or no
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_DISABLESHOWMENU, !_fShowMenu, NULL, NULL);

            SetWindowPos(_pbbd->_hwnd, NULL, 0, 0, 0, 0,
                    SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_FRAMECHANGED);
        }
        break;

    default:
        return E_INVALIDARG;   // Not one of the ones we support...
    }
    return S_OK;
}

BOOL CShellBrowser2::_ShouldAllowNavigateParent()
{
    LPCITEMIDLIST pidl = ILIsRooted(_pbbd->_pidlCur) ? ILGetNext(_pbbd->_pidlCur) : _pbbd->_pidlCur;
    return !ILIsEmpty(pidl);
}

HRESULT CShellBrowser2::IsControlWindowShown(UINT id, BOOL *pfShown)
{
    switch (id)
    {
    case (UINT)-1:  // Set into Kiosk mode...
        *pfShown = _fKioskMode;
        break;

    case FCW_INTERNETBAR:
        *pfShown = _GetToolbarItem(ITB_ITBAR)->fShow;
        break;

    case FCW_STATUS:
        *pfShown = _fStatusBar;
        break;
        
    case FCW_MENUBAR:
        *pfShown = _fShowMenu;
        break;
        
    case FCW_TREE:
    {
        BOOL    fShown;

        OLECMD rgCmds[1] = {0};
        rgCmds[0].cmdID = SBCMDID_EXPLORERBAR;
        QueryStatus(&CGID_Explorer, ARRAYSIZE(rgCmds), rgCmds, NULL);
        fShown = (rgCmds[0].cmdf & OLECMDF_LATCHED);
        if (pfShown != NULL)
            *pfShown = fShown;
        break;
    }

    default:
        return E_INVALIDARG;   // Not one of the ones we support...
    }

    return S_OK;
}

HRESULT CShellBrowser2::SetReferrer(LPITEMIDLIST pidl)
{
    //
    //  this is only used when we create a new window, and
    //  we need some sort of ZoneCrossing context.
    //
    Pidl_Set(&_pidlReferrer, pidl);

    return (_pidlReferrer || !pidl) ? S_OK :E_FAIL;
}

HRESULT CShellBrowser2::_CheckZoneCrossing(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    //
    //  NOTE - right now we only handle having one or the other - zekel 8-AUG-97
    //  we should only have pidlReferrer if we have been freshly 
    //  created.  if we decide to use it on frames that already exist,
    //  then we need to decide whether we should show pidlCur or pidlReferrer.
    //  by default we give Referrer preference.
    //
    AssertMsg((!_pidlReferrer && !_pbbd->_pidlCur) || 
        (_pidlReferrer && !_pbbd->_pidlCur) || 
        (!_pidlReferrer && _pbbd->_pidlCur), 
        TEXT("REVIEW: should this be allowed?? -zekel"));

    LPITEMIDLIST pidlRef = _pidlReferrer ? _pidlReferrer : _pbbd->_pidlCur;

    //
    //  Call InternetConfirmZoneCrossingA API only if this is the top-level
    // browser (not a browser control) AND there is a current page.
    //
    if (pidlRef) {
        
        HRESULT hresT = S_OK;
        // Get the URL of the current page.
        WCHAR szURLPrev[MAX_URL_STRING];

        const WCHAR c_szURLFile[] = L"file:///c:\\";  // dummy one
        LPCWSTR pszURLPrev = c_szURLFile;    // assume file:

        //         We should get the display name first and then only use
        //         the default value if the szURLPrev doesn't have a scheme.
        //         Also do this for szURLNew below.  This will fix Folder Shortcuts
        //         especially to Web Folders.  We also need to use the pidlTarget
        //         Folder Shortcut pidl.
        if (IsURLChild(pidlRef, FALSE))
        {
            hresT = ::IEGetDisplayName(pidlRef, szURLPrev, SHGDN_FORPARSING);
            pszURLPrev = szURLPrev;
        }

        if (SUCCEEDED(hresT))
        {
            // Get the URL of the new page.
            WCHAR szURLNew[MAX_URL_STRING];
            LPCWSTR pszURLNew = c_szURLFile;
            if (IsURLChild(pidl, FALSE)) {
                hresT = ::IEGetDisplayName(pidl, szURLNew, SHGDN_FORPARSING);
                pszURLNew = szURLNew;
            }

            if (pszURLPrev != pszURLNew && SUCCEEDED(hresT))
            {
                // HACK: This API takes LPTSTR instead of LPCTSTR. 
                DWORD err = InternetConfirmZoneCrossing(_pbbd->_hwnd, (LPWSTR)pszURLPrev, (LPWSTR) pszURLNew, FALSE);

                hr = HRESULT_FROM_WIN32(err);
                TraceMsg(DM_ZONE, "CSB::_CheckZoneCrossing InetConfirmZoneXing %hs %hs returned %d", pszURLPrev, pszURLNew, err);
                if (FAILED(hr) &&
                    (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) &&
                    (E_OUTOFMEMORY != hr))
                {
                    // We only need to investigate an error if it is unexpected.  Out of memory and
                    // a user cancelling the dialog are valid.
                    TraceMsg(DM_ERROR, "CSB::_CheckZoneCrossing ICZC returned error (%d)", err);
                }
            }
            else
            {
                TraceMsg(DM_ZONE, "CSB::_CheckZoneCrossing IEGetDisplayName(pidl) failed %x", hresT);
            }
        }
        else
        {
            TraceMsg(DM_ZONE, "CSB::_CheckZoneCrossing IEGetDisplayName(pidlRef) failed %x", hresT);
        }
    }

    SetReferrer(NULL);

    return hr;
}

BOOL CShellBrowser2::v_IsIEModeBrowser()
{
    //
    // if we didnt register the window or if it is not registered as 3rdparty,
    //  then it is allowed to be an IEModeBrowser.
    //
    return (!_fDidRegisterWindow || (_swcRegistered != SWC_3RDPARTY)) && 
        (_fInternetStart || (_pbbd->_pidlCur && IsURLChild(_pbbd->_pidlCur, TRUE)));
}


// IServiceProvider::QueryService

STDMETHODIMP CShellBrowser2::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SExplorerToolbar)) 
    {
        LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
        if (ptbi->ptbar) 
        {
            return ptbi->ptbar->QueryInterface(riid, ppvObj);
        }
    } 
    else if (IsEqualGUID(guidService, SID_SMenuBandHandler) || 
             IsEqualGUID(guidService, SID_SHostProxyFilter))
    {
        return QueryInterface(riid, ppvObj);
    }
    
    return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}

HRESULT CShellBrowser2::EnableModelessSB(BOOL fEnable)
{
    HRESULT hres = SUPERCLASS::EnableModelessSB(fEnable);
//
//  We don't want to leave the frame window disabled if a control left
// us disabled because of its bug. Instead, we'll put a warning dialog
// box -- IDS_CLOSEANYWAY. (SatoNa)
//
#if 0
    EnableMenuItem(GetSystemMenu(_pbbd->_hwnd, FALSE), SC_CLOSE, (S_OK == _DisableModeless()) ?
                         (MF_BYCOMMAND | MF_GRAYED) : (MF_BYCOMMAND| MF_ENABLED));
#endif
    return hres;
}

LPCITEMIDLIST CShellBrowser2::_GetPidl()
{
    LPCITEMIDLIST pidl = _pbbd->_pidlNewShellView;

    if (pidl == NULL)
        pidl = _pbbd->_pidlPending;

    if (pidl == NULL)
        pidl = _pbbd->_pidlCur;

    return pidl;
}

BOOL CShellBrowser2::_DoesPidlRoam(LPCITEMIDLIST pidl)
{
    WCHAR szPath[MAX_PATH];
    BOOL fRet = SHGetPathFromIDList(pidl, szPath);
    if (fRet)
    {
        fRet = PathIsUNC(szPath);
    }
    return fRet;
}

HRESULT CShellBrowser2::_CreateFakeNilPidl(LPITEMIDLIST *ppidl)
{
    IShellFolder *psfDesktop;
    HRESULT hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(STGM_CREATE, &pbc);
        if (SUCCEEDED(hr))
        {
            // the new "nil" clsid
            hr = psfDesktop->ParseDisplayName(NULL, pbc, L"::{cce6191f-13b2-44fa-8d14-324728beef2c}", NULL, ppidl, NULL);
            pbc->Release();
        }
        psfDesktop->Release();
    }
    return hr;
}

BOOL CShellBrowser2::_IsPageInternet(LPCITEMIDLIST pidl)
{
    BOOL fInternet = FALSE;
    if (((NULL == pidl) && IsEqualCLSID(_clsidThis, CLSID_InternetExplorer)) ||
        IsBrowserFrameOptionsPidlSet(pidl, BFO_BROWSER_PERSIST_SETTINGS))
    {
        fInternet = TRUE;
    }

    return fInternet;
}

HRESULT CShellBrowser2::_GetPropertyBag(LPCITEMIDLIST pidl, DWORD dwFlags, REFIID riid, void** ppv)
{
    HRESULT hr;

    if (_IsPageInternet(pidl))
    {
        LPITEMIDLIST pidlIE = IEGetInternetRootID();

        if (pidlIE)
        {
            hr = SHGetViewStatePropertyBag(pidlIE, VS_BAGSTR_EXPLORER, dwFlags, riid, ppv);
            ILFree(pidlIE);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    else if (!pidl || _fNilViewStream)
    {
        // the old-style save-to-stream code faked up a "nil" location in the case of NULL.
        // additionally if we loaded from this fake stream we had to save to it later.
        // the search window actually relies on this behavior since it doesnt get its
        // pidl for navigation until the window is already up.
        // it's too late to change the way search initializes its view window and the
        // solution is nontrivial anyway, so mimic the old behavior here.
        LPITEMIDLIST pidlNil;
        hr = _CreateFakeNilPidl(&pidlNil);
        if (SUCCEEDED(hr))
        {
            hr = SHGetViewStatePropertyBag(pidlNil, VS_BAGSTR_EXPLORER, dwFlags, riid, ppv);
            ILFree(pidlNil);
        }
        _fNilViewStream = TRUE;
    }
    else
    {
        if (_DoesPidlRoam(pidl))
        {
            dwFlags |= SHGVSPB_ROAM;
        }

        hr = SHGetViewStatePropertyBag(pidl, VS_BAGSTR_EXPLORER, dwFlags, riid, ppv);
    }

    return hr;
}

HRESULT CShellBrowser2::GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv)
{
    LPCITEMIDLIST pidl = _GetPidl();

    return _GetPropertyBag(pidl, dwFlags, riid, ppv);
}

HRESULT CShellBrowser2::GetViewStateStream(DWORD grfMode, IStream **ppstm)

//  99/02/05 #226140 vtan: DefView doesn't perist the dwDefRevCount
//  like ShellBrowser does. When DefView asks ShellBrowser for the
//  view state stream ShellBrowser would blindly return the stream
//  (implemented in the super class CCommonBrowser). In order to
//  ensure the stream's validity the method is now replaced with
//  this code which verifies the dwDefRevCount matches. If there
//  is a mismatch the function bails with an error otherwise it
//  calls the regularly scheduled program (super CCommonBrowser).

//  This will have to be revisited when separating frame
//  state from view state.

{
    HRESULT         hResult;
    IStream*        pIStream;
    LPCITEMIDLIST   pIDL;

    pIDL = _GetPidl();
    pIStream = v_GetViewStream(pIDL, STGM_READ, L"CabView");
    if (pIStream != NULL)
    {
        CABSH   cabinetStateHeader;

        hResult = _FillCabinetStateHeader(pIStream, &cabinetStateHeader);
        pIStream->Release();
        if (SUCCEEDED(hResult) &&
            ((cabinetStateHeader.fMask & CABSHM_REVCOUNT) != 0) &&
            (g_dfs.dwDefRevCount != cabinetStateHeader.dwRevCount))
        {
            *ppstm = NULL;
            return(E_FAIL);
        }
    }
    return(SUPERCLASS::GetViewStateStream(grfMode, ppstm));
}

LRESULT CALLBACK CShellBrowser2::DummyTBWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CShellBrowser2* pSB = (CShellBrowser2*)GetWindowPtr0(hwnd);    // GetWindowLong(hwnd, 0)
    LRESULT lRes = 0L;
    
    if (uMsg < WM_USER)
        return(::DefWindowProcWrap(hwnd, uMsg, wParam, lParam));
    else    
    {
        switch (uMsg) {
            
        case TB_ADDBITMAP:
            pSB->_pxtb->AddBitmap(&CGID_ShellBrowser, BITMAP_NORMAL, (UINT)wParam, (TBADDBITMAP*)lParam, &lRes, RGB(192,192,192));
            pSB->_pxtb->AddBitmap(&CGID_ShellBrowser, BITMAP_HOT, (UINT)wParam, (TBADDBITMAP*)lParam, &lRes, RGB(192,192,192));
            break;
            
        default:
            if (pSB->_pxtb)
                pSB->_pxtb->SendToolbarMsg(&CGID_ShellBrowser, uMsg, wParam, lParam, &lRes);
            return lRes;
        }
    }
    return lRes;
}    

// When a view adds buttons with no text, the CInternet toolbar may call back and ask
// for the tooltip strings. Unfortunately, at that time _pbbd->_hwndView is not yet set and therefore
// the tooltip texts will not be set. 
//
// So, to get around that, we do not add the buttons if there is no _pbbd->_hwndView (see ::SetToolbarItem)
// The CBaseBrowser2's ::_SwitchActivationNow() is the one that sets the _pbbd->_hwndView. So when this hwnd is
// set then we add the buttons
// 
// We send the WM_NOTIFYFORMAT because when CInternetToolbar::AddButtons calls back with the WM_NOTIFYs 
// for the tooltips, we need to know whether or not the view is UNICODE or not.
HRESULT CShellBrowser2::_SwitchActivationNow()
{
    ASSERT(_pbbd->_psvPending);

#if 0
    // if we have a progress control, make sure it's off before we switch activation
    if (_hwndProgress)
        SendControlMsg(FCW_PROGRESS, PBM_SETRANGE32, 0, 0, NULL);
#endif

    SUPERCLASS::_SwitchActivationNow();

    // need to do this as close to the assign of _pbbd->_hwndView as possible
    _fUnicode = (SendMessage (_pbbd->_hwndView, WM_NOTIFYFORMAT,
                                 (WPARAM)_pbbd->_hwnd, NF_QUERY) == NFR_UNICODE);
    
    if (_lpButtons) {
        LocalFree(_lpButtons);
        _lpButtons = NULL;
        _nButtons = 0;
    }
    
    if (_lpPendingButtons)
    {
        
        _lpButtons = _lpPendingButtons;
        _nButtons = _nButtonsPending;
        _lpPendingButtons = NULL;
        _nButtonsPending = 0;
        
        if ((_pxtb) && (_pbbd->_hwndView))
            _pxtb->AddButtons(&CGID_ShellBrowser, _nButtons, _lpButtons);
        
    }    
    return S_OK;
}


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dump the menu handles for this browser.  Optionally
         breaks after dumping handles.

*/
void
CShellBrowser2::_DumpMenus(
    IN LPCTSTR pszMsg,
    IN BOOL    bBreak)
{
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGMENU))
    {
        ASSERT(pszMsg);

        TraceMsg(TF_ALWAYS, "CShellBrowser2: Dumping menus for %#08x %s", (void *)this, pszMsg);
        TraceMsg(TF_ALWAYS, "   _hmenuTemplate = %x, _hmenuFull = %x, _hmenuBrowser = %x",
                 _hmenuTemplate, _hmenuFull, _hmenuBrowser);
        TraceMsg(TF_ALWAYS, "   _hmenuCur = %x, _hmenuPreMerged = %x, _hmenuHelp = %x",
                 _hmenuCur, _hmenuPreMerged, _hmenuHelp);

        _menulist.Dump(pszMsg);
        
        if (bBreak && IsFlagSet(g_dwBreakFlags, BF_ONDUMPMENU))
            DebugBreak();
    }
}
#endif

HRESULT CShellBrowser2::SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths)
{
    return SUPERCLASS::SetBorderSpaceDW(punkSrc, pborderwidths);
}

//
//  This is a helper member of CBaseBroaser class (non-virtual), which
// returns the effective client area. We get this rectangle by subtracting
// the status bar area from the real client area.
//
HRESULT CShellBrowser2::_GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon)
{
    static const int s_rgnViews[] =  {1, 0, 1, FCIDM_STATUS, 0, 0};

    // n.b. do *not* call SUPER/_psbInner

    ASSERT(hmon == NULL);
    GetEffectiveClientRect(_pbbd->_hwnd, lprectBorder, (LPINT)s_rgnViews);
    return S_OK;
}

// Should we return more informative return values?
// "Browser Helper Objects"

BOOL CShellBrowser2::_LoadBrowserHelperObjects(void)
{
    BOOL bRet = FALSE;
    BOOL bNoExplorer = FALSE;
    HKEY hkey;

    // We shouldn't load browser extensions if we're in fail-safe mode, or if the user asked us to disable these extensions/
    // In the future, we should allow disabling on a per-extension basis (when not in safe mode)
    if ((!SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main"), TEXT("Enable Browser Extensions"), FALSE, TRUE))
        || (GetSystemMetrics(SM_CLEANBOOT)!=0))
    {
        return TRUE;
    }

    if (_pbbd->_pautoWB2 &&
        RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_EXPLORER TEXT("\\Browser Helper Objects"), &hkey) == ERROR_SUCCESS)
    {
        TCHAR szGUID[64];
        DWORD cb = ARRAYSIZE(szGUID);
        for (int i = 0;
             RegEnumKeyEx(hkey, i, szGUID, &cb, NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
             i++)
        {
            // If we're not in IEXPLORE's process
            //
            if (!_fRunningInIexploreExe)
            {
                // Check to see if there's a "NoExplorer" value
                //
                bNoExplorer = (ERROR_SUCCESS == SHGetValue(hkey, szGUID, TEXT("NoExplorer"), NULL, NULL, NULL));
            }

            // If we're in IEXPLORE.EXE or we're in EXPLORER.EXE but there's no "NoExplorer" value, then
            // go ahead and load the BHO
            if (_fRunningInIexploreExe || !bNoExplorer)
            {
                CLSID clsid;
                IObjectWithSite *pows;
                if (GUIDFromString(szGUID, &clsid) &&
                    !(SHGetObjectCompatFlags(NULL, &clsid) & OBJCOMPATF_UNBINDABLE) &&
                    SUCCEEDED(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IObjectWithSite, &pows))))
                {
                    pows->SetSite(_pbbd->_pautoWB2);    // give the poinetr to IWebBrowser2

                    SA_BSTRGUID strClsid;
                    // now register this object so that it can be found through automation.
                    SHTCharToUnicode(szGUID, strClsid.wsz, ARRAYSIZE(strClsid.wsz));
                    strClsid.cb = lstrlenW(strClsid.wsz) * sizeof(WCHAR);

                    VARIANT varUnknown = {0};
                    varUnknown.vt = VT_UNKNOWN;
                    varUnknown.punkVal = pows;
                    _pbbd->_pautoWB2->PutProperty(strClsid.wsz, varUnknown);

                    pows->Release(); // Instead of calling variantClear() 

                    bRet = TRUE;
                }
            }
            cb = ARRAYSIZE(szGUID);
        }
        RegCloseKey(hkey);
    }
    return bRet;
}

HRESULT CShellBrowser2::OnViewWindowActive(IShellView * psv)
{
    _pbsInner->SetActivateState(SVUIA_ACTIVATE_FOCUS);
    return SUPERCLASS::OnViewWindowActive(psv);
}

HRESULT CShellBrowser2::_PositionViewWindow(HWND hwnd, LPRECT prc)
{
    if (hwnd == _hwndDelayedSize)
    {
        _fHaveDelayedSize = TRUE;
        _rcDelayedSize = *prc;
    }
    else
    {
        RECT rc = *prc;

        if (_ptheater) {
            InflateRect(&rc, GetSystemMetrics(SM_CXEDGE), GetSystemMetrics(SM_CYEDGE));
        }
        
        SetWindowPos(hwnd, NULL,
                     rc.left, rc.top, 
                     rc.right - rc.left, 
                     rc.bottom - rc.top,
                     SWP_NOZORDER | SWP_NOACTIVATE);
    }

    return S_OK;
}

HRESULT CShellBrowser2::OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus)
{
    if (fSetFocus && _ptheater && SHIsSameObject(punkSrc, _GetITBar())) {
        _ptheater->Exec(&CGID_Theater, THID_TOOLBARACTIVATED, 0, NULL, NULL);
    }
    return SUPERCLASS::OnFocusChangeIS(punkSrc, fSetFocus);
}


HRESULT CShellBrowser2::Offline(int iCmd)
{
    HRESULT hresIsOffline = SUPERCLASS::Offline(iCmd);
        
    if (iCmd == SBSC_TOGGLE)
    {        
        VARIANTARG var = {0};
        if (_pbbd->_pctView && SUCCEEDED(_pbbd->_pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_OFFLINE, NULL, &var))
            && V_UI4(&var) != PANE_NONE)
        {
            SendControlMsg(FCW_STATUS, SB_SETICON, V_UI4(&var), 
                (hresIsOffline == S_OK) ? (LPARAM) OfflineIcon() : NULL, NULL);
            if (hresIsOffline == S_OK) {
                InitTitleStrings();
                SendControlMsg(FCW_STATUS, SB_SETTIPTEXT, V_UI4(&var), 
                               (LPARAM) g_szWorkingOfflineTip, NULL);
            }
        } 
    }
        
    return hresIsOffline;
}

HRESULT CShellBrowser2::_FreshenComponentCategoriesCache(BOOL bForceUpdate)
{
    CATID catids[2] ;
    ULONG cCatids = 0 ;
    catids[0] = CATID_InfoBand ;
    catids[1] = CATID_CommBand ;

    //  Check if our CATIDs are cached...
    if (!bForceUpdate)
    {
        for(ULONG i=0; i< ARRAYSIZE(catids); i++)
        {
            if (S_OK != SHDoesComCatCacheExist(catids[i], TRUE))
            {
                bForceUpdate = TRUE ;
                break ;
            }
        }
    }

    if (bForceUpdate)
    {
        // Create an event for the comcat task to signal when it's
        // done.  We need to do this because sometimes the task hasn't
        // finished by the time the user opens the "Explorer Bars"
        // submenu, and so they won't see the Bloomberg bar (for
        // example) that they just installed unless we wait for the task
        // to complete.

        if (_hEventComCat == NULL)
            _hEventComCat = CreateEvent(NULL, FALSE, FALSE, NULL);

        return SHWriteClassesOfCategories(ARRAYSIZE(catids), catids, 0, NULL, 
                                   TRUE, FALSE /*no wait*/, _hEventComCat) ;
    }

    return S_FALSE ;
}

void CShellBrowser2::_QueryHKCRChanged()
{
    ASSERT(g_fRunningOnNT && GetUIVersion() >= 5);

    //  In an integrated installation >= v5 on NT, we have the benefit
    //  of an HKCR change notification.  Posting this message will cause
    //  the desktop to check to see if HKCR was modified recently; if so, 
    //  the _SetupAppRan handler will execute in the desktop process.   
    //  This causes, among other evil, freshening of our component categories cache.
    //  it is ok that this is isnt synchronous because the update
    //  is async regardless.

    PostMessage(GetShellWindow(), DTM_QUERYHKCRCHANGED, 
                 QHKCRID_VIEWMENUPOPUP, (LPARAM)NULL) ;
}


#ifdef UNIX

BOOL CShellBrowser2::_HandleActivation(WPARAM wParam)
{
    LPTOOLBARITEM ptbi;
    IDockingWindow *ptbTmp;
    IOleCommandTarget* pcmdt;
    
    // Activation is explicitly handled only in MOTIF LOOK
    if (MwCurrentLook() != LOOK_MOTIF)
        return FALSE;
    
    // Get InetnetToolbar IDockingWindow interface
    ptbi = _GetToolbarItem(ITB_ITBAR);
    if (!ptbi)
        return FALSE;
    
    ptbTmp = ptbi->ptbar;
    
    if (ptbTmp)
    {
        // Exec Command. IOleCommandTarget::Exec for CInternetToobar window
        // forwards the commands to the address band.
        HRESULT hres = ptbTmp->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
        if (SUCCEEDED(hres)) 
        {
            if (wParam == WA_ACTIVE || wParam == WA_CLICKACTIVE)
            {
                // Did we have toobar focus when deactivated.
                if (_fSetAddressBarFocus)
                {
                    VARIANTARG vaOut = {0};
                    hres = pcmdt->Exec(&CGID_Explorer, SBCMDID_SETADDRESSBARFOCUS, 0, NULL, &vaOut);
                    
                    // SERADDRESSBARFOCUS command handled by the retrieved IOleCommandTarget.
                    // No need to process any furthur.
                    if (SUCCEEDED(hres)) 
                    {
                        pcmdt->Release();
                        return TRUE;
                    }
                }
            }
            else
            {
                // Focus should only be set to the Addressbar if we already had
                // focus there before losing activation, otherwise do default 
                // processing.
                VARIANTARG vaOut = {0};
                hres = pcmdt->Exec(&CGID_Explorer, SBCMDID_HASADDRESSBARFOCUS, 0, NULL, &vaOut);
                
                _fSetAddressBarFocus = SUCCEEDED(hres);
            }
            
            pcmdt->Release();
        }
    }
    
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\theater.cpp ===
#include "priv.h"
#include "theater.h"
#include "itbar.h"
#include "sccls.h"
#include "resource.h"
#include "brand.h"
#include "legacy.h"

#include "mluisupp.h"

#if defined(MAINWIN)
#include <mainwin.h>
#endif

#ifndef DISABLE_FULLSCREEN

#define IDT_INITIAL             1
#define IDT_UNHIDE              2
#define IDT_TOOLBAR             3
#define IDT_BROWBAR             4
#define IDT_TASKBAR             5
#define IDT_DELAY               6
#define IDT_HIDETOOLBAR         7
#define IDT_HIDEBROWBAR         8
#define IDT_HIDEFLOATER         9
#define IDT_HIDEFLOATER1SEC     10
#define IDT_INITIALBROWSERBAR   11

#define TF_THEATER              0

#define E_TOP       0
#define E_LEFT      1
#define E_RIGHT     2
#define E_BOTTOM    3

// association list.  sort of like dpa, but by association key rather than by index
// we need this because windows hooks are global and have no data associated with them.
// on the callback, we use our thread id as the key
CAssociationList CTheater::_al; // associate threadid with CTheater objects


// _GetWindowRectRel: gets window's coordinates relative to _hwndBrowser
BOOL CTheater::_GetWindowRectRel(HWND hWnd, LPRECT lpRect)
{
    BOOL bResult = GetWindowRect(hWnd, lpRect);
    if (bResult)
        MapWindowPoints(HWND_DESKTOP, _hwndBrowser, (LPPOINT)lpRect, 2);
    return bResult;
}

CTheater::CTheater(HWND hwnd, HWND hwndToolbar, IUnknown* punkOwner) :
   _hwndBrowser(hwnd), _hwndToolbar(hwndToolbar), _cRef(1)
{
    ASSERT(punkOwner);
    _punkOwner = punkOwner;
    _punkOwner->AddRef();

    _al.Add(GetCurrentThreadId(), this);

    _wp.length = SIZEOF(_wp);
    GetWindowPlacement(_hwndBrowser, &_wp);
    GetWindowRect(_hwndBrowser, &_rcOld);
#ifndef FULL_DEBUG
    SetWindowZorder(_hwndBrowser, HWND_TOPMOST);
#endif
    ShowWindow(_hwndBrowser, SW_MAXIMIZE);
    _Initialize();

    
    _fAutoHideBrowserBar = TRUE;
}

CTheater::~CTheater()
{
    SetWindowZorder(_hwndBrowser, HWND_NOTOPMOST);
    SetBrowserBar(NULL, 0, 0);
    if (_hhook)
    {
        UnhookWindowsHookEx(_hhook);
        _hhook = NULL;
    }
    _al.Delete(GetCurrentThreadId());
    
    KillTimer(_hwndFloater, IDT_UNHIDE);
    KillTimer(_hwndFloater, IDT_DELAY);
    KillTimer(_hwndFloater, IDT_HIDETOOLBAR);
    KillTimer(_hwndFloater, IDT_HIDEBROWBAR);

    if (_pdbBrand) {
        IUnknown_SetSite(_pdbBrand, NULL);
        _pdbBrand->CloseDW(0);
        _pdbBrand->Release();
    }
    
    if (_hwndClose) {
        HIMAGELIST himl = (HIMAGELIST)SendMessage(_hwndClose, TB_SETIMAGELIST, 0, 0);
        ImageList_Destroy(himl);
    }
    
    if (_hwndFloater) {
        DestroyWindow(_hwndFloater);

    }

    _punkOwner->Release();
}

BOOL CTheater::_IsBrowserActive()
{
    HRESULT hr = IUnknown_Exec(_punkOwner, &CGID_Explorer, SBCMDID_ISBROWSERACTIVE, 0, NULL, NULL);
    return (hr == S_OK);
}

void CTheater::_ShowTaskbar()
{    
    if (SHForceWindowZorder(_hwndTaskbar, HWND_TOPMOST))
        _fTaskbarShown = TRUE;
}

void CTheater::_HideTaskbar()
{
    if (_IsBrowserActive())
    {
        HWND hwnd = GetForegroundWindow();
        if (!GetCapture() && (SHIsChildOrSelf(_hwndTaskbar, hwnd) != S_OK))
        {
            if (SetWindowZorder(_hwndTaskbar, _hwndBrowser))
                _fTaskbarShown = FALSE;
        } 
    }
}

void CTheater::_ShowToolbar()
{
    if (!_fShown)
    {
        KillTimer(_hwndFloater, IDT_HIDETOOLBAR);                

        if (_hwndToolbar)
        {
            RECT rcParent;
            RECT rc;

            GetWindowRect(_hwndToolbar, &rc);
            GetClientRect(_hwndBrowser, &rcParent);
        
            IUnknown_Exec(_punkOwner, &CGID_PrivCITCommands, CITIDM_THEATER, THF_UNHIDE, NULL, NULL);
            
            SetWindowPos(_hwndToolbar, _hwndFloater, 0, 0, RECTWIDTH(rcParent), RECTHEIGHT(rc), SWP_NOACTIVATE | SWP_SHOWWINDOW);
            _ShowFloater();
        }        
        _fShown = TRUE;
    }
}

void CTheater::_HideToolbar()
{
    // don't start hiding if floater is still active
    if (!_cActiveRef) 
    {
        if (_fAutoHideToolbar && (GetCapture() == NULL) && !IsChild(_hwndToolbar, GetFocus()))
        {        
            _HideFloater();

            SetTimer(_hwndFloater, IDT_HIDETOOLBAR, 50, NULL);
            _cyLast = -1;
            _fShown = FALSE;       
        }
    }
}

void CTheater::_ContinueHideToolbar()
{
    while (1) {
        RECT rc;
        int cy;

        _GetWindowRectRel(_hwndToolbar, &rc);

#ifdef MAINWIN
    if (MwIsMwwmAllwm(_hwndBrowser))
    {
        // Simulating
        rc.right = rc.right - rc.left;
        rc.bottom = rc.bottom - rc.top;
        rc.top = 0;
        rc.bottom = 0;
    }
#endif

        cy = rc.bottom;
        OffsetRect(&rc, 0, -4);
        
        if (cy > 0 && cy != _cyLast) {
            RECT rcT;
            _GetWindowRectRel(_hwndToolbar, &rcT);
            
            SetWindowPos(_hwndToolbar, NULL, rcT.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
            UpdateWindow(_hwndToolbar);
            Sleep(10);
            _cyLast = cy;
        } else {
            IUnknown_Exec(_punkOwner, &CGID_PrivCITCommands, CITIDM_THEATER, THF_HIDE, NULL, NULL);
            ShowWindow(_hwndToolbar, SW_HIDE);

            // Hide floater and restore parenthood so msgs are picked up again
            ShowWindow(_hwndFloater, SW_HIDE);            
            SetParent(_hwndFloater, _hwndBrowser);            
            
            break;
        }
    }
}

void CTheater::_ShowBrowBar()
{
    if (!_fBrowBarShown)
    {
        RECT rc;        

        KillTimer(_hwndFloater, IDT_HIDEBROWBAR);
        _GetWindowRectRel(_hwndBrowBar, &rc);        

        rc.left = 0;
        rc.right = _cxBrowBarShown;
        SetWindowPos(_hwndBrowBar, _hwndToolbar, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOACTIVATE);

        _SanityCheckZorder();
        
        _fBrowBarShown = TRUE;
    }
}

void CTheater::_HideBrowBar()
{
    // don't start hiding if something has capture
    if (_fBrowBarShown && _CanHideWindow(_hwndBrowBar))
    {
        SetTimer(_hwndFloater, IDT_HIDEBROWBAR, 50, NULL);        
        _fBrowBarShown = FALSE;
        if (_fInitialBrowserBar)
            KillTimer(_hwndFloater, IDT_INITIALBROWSERBAR);                        
    }
}

// REARCHITECT: We should signal browser bar to suppress resizing during autohide.  Current scheme 
// works only because browser bar doesn't resize itself upon SetWindowPos to zero width.
void CTheater::_ContinueHideBrowBar()
{
    RECT rc;
    POINT pt;
    INT cxOffset, cxEdge;
    
    if (!_GetWindowRectRel(_hwndBrowBar, &rc))
        return;             // bail
    cxEdge = rc.left;
    
    if (_fInitialBrowserBar)
        cxOffset = -2;      // slow hide
    else
        cxOffset = -6;      // fast hide
    _fInitialBrowserBar = FALSE;
    
    while (rc.right > cxEdge)
    {
        // If mouse has moved over the bar, kill the hide
        GetCursorPos(&pt);
        MapWindowPoints(HWND_DESKTOP, _hwndBrowser, &pt, 1);
        if (PtInRect(&rc, pt))
        {
            _ShowBrowBar();
            return;
        }
        OffsetRect(&rc, cxOffset, 0);                
        SetWindowPos(_hwndBrowBar, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_NOACTIVATE);
        RedrawWindow(_hwndBrowBar, NULL, NULL, RDW_UPDATENOW | RDW_ALLCHILDREN);
        Sleep(5);
    }
}

BOOL CTheater::_CanHideWindow(HWND hwnd)
{
    return (!GetCapture() && !IsChild(hwnd, GetFocus()));
}

void CTheater::_ShowFloater()
{    
    if (!_fFloaterShown) 
    {
        _fFloaterShown = TRUE;
        SetParent(_hwndFloater, _hwndBrowser);

        KillTimer(_hwndFloater, IDT_HIDEFLOATER);
        
        _SizeFloater();
        SetWindowPos(_hwndFloater, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);
        InvalidateRect(_hwndFloater, NULL, TRUE);
        UpdateWindow(_hwndFloater);
        
        ShowWindow(_hwndFloater, SW_SHOW);
        if (!_fShown && _fAutoHideToolbar)
            _DelayHideFloater();
    }    
}

void CTheater::_DelayHideFloater()
{
    if (!_cActiveRef)
    {
        SetTimer(_hwndFloater, IDT_HIDEFLOATER1SEC, 1000, NULL);
    }
}

void CTheater::_HideFloater()
{
    if (_fAutoHideToolbar && _fFloaterShown)
    {
        if (!_fShown)
        {
            // don't start hiding if something has capture
            if (_CanHideWindow(_hwndFloater))
            {
                SetTimer(_hwndFloater, IDT_HIDEFLOATER, 50, NULL);        
                _fFloaterShown = FALSE;
                ASSERT(!_cActiveRef);
                _cActiveRef++;
                return;
            }
            else
            {
                _DelayHideFloater();
            }
        }
        else
        {
            SetParent(_hwndFloater, _hwndToolbar);
            _fFloaterShown = FALSE;
        }
    }
}

void CTheater::_ContinueHideFloater()
{
    while (1) 
    {
        RECT rc;        
        _GetWindowRectRel(_hwndFloater, &rc);        

        rc.left += 6;
        
        if (rc.left < rc.right) 
        {            
            SetWindowPos(_hwndFloater, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_NOACTIVATE);
            UpdateWindow(_hwndFloater);
            Sleep(5);            
        } 
        else 
        {                        
            ShowWindow(_hwndFloater, SW_HIDE);
            _cActiveRef--;            
            break;
        }
    }
}

void CTheater::_Unhide(int iWhich, UINT uDelay)
{
    _iUnhidee = iWhich;
    SetTimer(_hwndFloater, IDT_UNHIDE, uDelay, NULL);    
}

BOOL CTheater::_PtNearWindow(POINT pt, HWND hwnd)
{
    RECT rc;

    _GetWindowRectRel(hwnd, &rc);
    InflateRect(&rc, 60, 60);
    return (PtInRect(&rc, pt));
}

int GetWindowHeight(HWND hwnd)
{
    ASSERT(hwnd);

    RECT rc;
    GetWindowRect(hwnd, &rc);
    return RECTHEIGHT(rc);
}

BOOL CTheater::_PtOnEdge(POINT pt, int iEdge)
{
    RECT rc;
    _GetWindowRectRel(_hwndBrowser, &rc);    

    switch (iEdge)
    {
        case E_LEFT:
            rc.right = rc.left + CX_HIT;
            goto leftright;

        case E_RIGHT:
            rc.left = rc.right - CX_HIT;
leftright:
            rc.top += GetWindowHeight(_hwndToolbar);
            rc.bottom -= GetSystemMetrics(SM_CXVSCROLL);
            break;

        case E_TOP:
            rc.bottom = rc.top + CX_HIT;
            goto topbottom;

        case E_BOTTOM:
            rc.top = rc.bottom - CX_HIT;
topbottom:
            InflateRect(&rc, - GetSystemMetrics(SM_CXVSCROLL), 0);
            break;
    }
    return (PtInRect(&rc, pt));
}

LRESULT CTheater::_OnMsgHook(int nCode, WPARAM wParam, MOUSEHOOKSTRUCT *pmhs, BOOL fFake)
{    
    if (nCode >= 0) 
    {
        POINT pt;
        GetCursorPos(&pt);
        MapWindowPoints(HWND_DESKTOP, _hwndBrowser, &pt, 1);

        BOOL bTryUnhideTaskbar = !_fTaskbarShown;

        // The timer business is so that we don't unhide 
        // on a user trying to get to the scrollbar
        if (_iUnhidee) 
        {
            KillTimer(_hwndFloater, IDT_UNHIDE);
            _iUnhidee = 0;
        }
        
        if (_PtOnEdge(pt, E_LEFT))
        {
            if (!_fBrowBarShown && _hwndBrowBar)
                _Unhide(IDT_BROWBAR, SHORT_DELAY);
        }
        else if (_PtOnEdge(pt, E_TOP))
        {
            if (!_fShown)
                _Unhide(IDT_TOOLBAR, SHORT_DELAY);
        }
        else if (!_PtOnEdge(pt, E_RIGHT) && !_PtOnEdge(pt, E_BOTTOM))
        {
            bTryUnhideTaskbar = FALSE;
        }
        
#ifndef UNIX
        if (bTryUnhideTaskbar && !_fDelay && !_iUnhidee)
        {
            RECT rc;
            _GetWindowRectRel(_hwndTaskbar, &rc);
            if (PtInRect(&rc, pt))
                _Unhide(IDT_TASKBAR, GetCapture() ? LONG_DELAY : SHORT_DELAY);
        }
#endif

        if (_fAutoHideBrowserBar && _fBrowBarShown && !_PtNearWindow(pt, _hwndBrowBar))
            _HideBrowBar();
        
        if (_fAutoHideToolbar && _fShown && !_PtNearWindow(pt, _hwndToolbar))
            _HideToolbar();        
        
#ifndef UNIX
        if (_fTaskbarShown && !_PtNearWindow(pt, _hwndTaskbar))
           _HideTaskbar();
#endif
    }

    if (fFake)
        return 0;
    else
        return CallNextHookEx(_hhook, nCode, wParam, (LPARAM)pmhs);
}

LRESULT CTheater::_MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    CTheater* pTheater;
    if (SUCCEEDED(_al.Find(GetCurrentThreadId(), (LPVOID*)&pTheater)))
    {
        return pTheater->_OnMsgHook(nCode, wParam, (MOUSEHOOKSTRUCT*)lParam, FALSE);
    }
    return 0;
}

void CTheater::Begin()
{
    _ShowToolbar();    
    SetTimer(_hwndFloater, IDT_INITIAL, 1500, NULL);
}

void CTheater::_SizeBrowser()
{
    // position & size the browser window
    RECT rc;
    HMONITOR hMon = MonitorFromWindow(_hwndBrowser, MONITOR_DEFAULTTONEAREST);
    GetMonitorRect(hMon, &rc);
    InflateRect(&rc, CX_BROWOVERLAP, CX_BROWOVERLAP);
    SetWindowPos(_hwndBrowser, HWND_TOP, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), 0);
}

void CTheater::_SizeFloater()
{
    // position & size the floater
    RECT rc;
    GetWindowRect(_hwndBrowser, &rc);
    int x = RECTWIDTH(rc) - (CX_FLOATERSHOWN + CX_BROWOVERLAP);
    int y = 0;

    int cy = GetWindowHeight(_hwndToolbar);

    SetWindowPos(_hwndFloater, HWND_TOP, x, y, CX_FLOATERSHOWN, cy, SWP_NOACTIVATE);
}

void CTheater::_CreateCloseMinimize()
{
    _hwndClose = CreateWindowEx( WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                WS_VISIBLE | WS_CHILD | 
                                TBSTYLE_TOOLTIPS | TBSTYLE_FLAT | TBSTYLE_TRANSPARENT |
                                WS_CLIPCHILDREN | WS_CLIPSIBLINGS | 
                                CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                CCS_NORESIZE,
                                0, 0,
                                CLOSEMIN_WIDTH, CLOSEMIN_HEIGHT,
                                _hwndFloater, 0, HINST_THISDLL, NULL);

    if (_hwndClose) {
        static const TBBUTTON tb[] =
        {
            { 0, SC_MINIMIZE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 },
            { 1, SC_RESTORE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 },
            { 2, SC_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 }
        };

        HIMAGELIST himl = ImageList_LoadImage(HINST_THISDLL,
                                              MAKEINTRESOURCE(IDB_THEATERCLOSE),
                                              10, 0, RGB(255,0,255),
                                              IMAGE_BITMAP, LR_CREATEDIBSECTION);
        ImageList_SetBkColor(himl, RGB(0,0,0));

        SendMessage(_hwndClose, TB_SETIMAGELIST, 0, (LPARAM)himl);
        SendMessage(_hwndClose, TB_BUTTONSTRUCTSIZE,    SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndClose, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM)tb);
        SendMessage(_hwndClose, TB_SETMAXTEXTROWS,      0, 0L);
        TBBUTTONINFO tbbi;
        TCHAR szBuf[256];
        tbbi.cbSize = SIZEOF(TBBUTTONINFO);
        tbbi.dwMask = TBIF_TEXT;
        tbbi.pszText = szBuf;
        MLLoadString(IDS_CLOSE, szBuf, ARRAYSIZE(szBuf));
        SendMessage(_hwndClose, TB_SETBUTTONINFO, SC_CLOSE, (LPARAM)&tbbi);
        MLLoadString(IDS_RESTORE, szBuf, ARRAYSIZE(szBuf));
        SendMessage(_hwndClose, TB_SETBUTTONINFO, SC_RESTORE, (LPARAM)&tbbi);
        MLLoadString(IDS_MINIMIZE, szBuf, ARRAYSIZE(szBuf));
        SendMessage(_hwndClose, TB_SETBUTTONINFO, SC_MINIMIZE, (LPARAM)&tbbi);
    }    
}

void CTheater::_Initialize()
{
    _SizeBrowser();
    
#ifndef UNIX
    _hwndTaskbar = FindWindow(TEXT("Shell_TrayWnd"), NULL);

#ifdef DEBUG
    if (!_hwndTaskbar)
    {
        TraceMsg(TF_WARNING, "CTheater::_Initialize -- couldn't find taskbar window");
    }
#endif // DEBUG

#else
    _hwndTaskbar   = NULL;
#endif
    _fTaskbarShown = FALSE;

    _hwndFloater = SHCreateWorkerWindow(_FloaterWndProc, _hwndBrowser,  
#if defined(MAINWIN)
                                      // Removing window manager decors
                                      WS_EX_MW_UNMANAGED_WINDOW |
#endif
                                      WS_EX_TOOLWINDOW, 
                                      WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, NULL, this);
    if (_hwndFloater) {

        int cx = 0;        
        
        // create animating E logo
        IUnknown* punk;
        CBrandBand_CreateInstance(NULL, (IUnknown **)&punk, NULL);
        if (punk) {
            punk->QueryInterface(IID_IDeskBand, (LPVOID*)&_pdbBrand);
            if (_pdbBrand) {
                HWND hwndBrand;
                
                IUnknown_SetSite(_pdbBrand, SAFECAST(this, IOleWindow*));                                
                IUnknown_GetWindow(_pdbBrand, &hwndBrand);
                                
                ASSERT(hwndBrand);
#ifdef DEBUG
                // Make sure brand isn't too tall
                DESKBANDINFO dbi = {0};
                _pdbBrand->GetBandInfo(0, 0, &dbi);
                ASSERT(!(dbi.ptMinSize.y > BRAND_HEIGHT));
#endif
                if (hwndBrand) 
                {
                    SetWindowPos(hwndBrand, NULL, 
                        cx, BRAND_YOFFSET, BRAND_WIDTH, BRAND_HEIGHT,
                        SWP_NOZORDER | SWP_SHOWWINDOW);
                    cx += BRAND_WIDTH + CLOSEMIN_XOFFSET;                    
                }
                // get floater background color
                VARIANTARG var = {VT_I4};
                IUnknown_Exec(_pdbBrand, &CGID_PrivCITCommands, CITIDM_GETDEFAULTBRANDCOLOR, 0, NULL, &var);
                _clrBrandBk = (COLORREF) var.lVal;
            }
            punk->Release();
        }
        
        // now create the progress bar        
        _hwndProgress = CreateWindowEx(0, PROGRESS_CLASS, NULL,
                                       WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | PBS_SMOOTH,
                                       cx - 1, PROGRESS_YPOS, 
                                       PROGRESS_WIDTH, PROGRESS_HEIGHT,
                                       _hwndFloater, (HMENU)TMC_PROGRESSBAR,
                                       HINST_THISDLL, NULL);
        if (_hwndProgress)
        {
            SendMessage(_hwndProgress, PBM_SETBKCOLOR, 0, _clrBrandBk);
            SendMessage(_hwndProgress, PBM_SETBARCOLOR, 0, GetSysColor(COLOR_BTNSHADOW));

            // hack of the 3d client edge that WM_BORDER implies in dialogs
            // add the 1 pixel static edge that we really want
            SHSetWindowBits(_hwndProgress, GWL_EXSTYLE, WS_EX_STATICEDGE, 0);
            SetWindowPos(_hwndProgress, NULL, 0,0,0,0, 
                SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
        }
        
        // make the close/minimize buttons & position them
        _CreateCloseMinimize();
        if (_hwndClose)
        {
            SetWindowPos(_hwndClose, HWND_TOP, cx, CLOSEMIN_YOFFSET, 0, 0, 
                SWP_NOSIZE | SWP_NOACTIVATE);
        }

        _SizeFloater();
    }
}

void CTheater::_SwapParents(HWND hwndOldParent, HWND hwndNewParent)
{
    HWND hwnd = ::GetWindow(hwndOldParent, GW_CHILD);

    while (hwnd) {
        //
        //  Note that we must get the next sibling BEFORE we set the new
        // parent.
        //
        HWND hwndNext = ::GetWindow(hwnd, GW_HWNDNEXT);
        if (hwnd != _hwndToolbar) {
            ::SetParent(hwnd, hwndNewParent);
        }
        hwnd = hwndNext;
    }
}

//////  begin floating palette (floater) window implementation
///  
/// floater keeps a ref count of activation (via command target)
/// when the last activity goes away, it sets a timer and hides after a second.
/// this is a regional window that will host the animation icon, progress bar, and 
/// close / minimize buttons

ULONG CTheater::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTheater::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTheater::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTheater, IOleWindow),
        QITABENT(CTheater, IOleCommandTarget),
        QITABENT(CTheater, IServiceProvider),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CTheater::GetWindow(HWND * lphwnd) 
{
    *lphwnd = _hwndFloater; 
    if (_hwndFloater)
        return S_OK; 
    return E_FAIL;
}

void CTheater::_SanityCheckZorder()
{
    //
    // The view may have jumped to HWND_TOP, so we need to
    // fix up the floater, toolbar, and browbar positions
    // within the z-order.
    //
    SetWindowZorder(_hwndFloater, HWND_TOP);
    SetWindowZorder(_hwndToolbar, _hwndFloater);
    SetWindowZorder(_hwndBrowBar, _hwndToolbar);
}

HRESULT CTheater::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, 
                                  OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return OLECMDERR_E_UNKNOWNGROUP;
}

HRESULT CTheater::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, 
                           VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_NOTSUPPORTED;
    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_Theater, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case THID_ACTIVATE:
            _cActiveRef++;
            if (_cActiveRef == 1)
                _ShowFloater();            
            break;
            
        case THID_DEACTIVATE:
            // we can get a deactivate before the first activate if 
            // we come up during a navigate
            if (_cActiveRef > 0)
            {
                _cActiveRef--;               
                _DelayHideFloater();
            }
            break;
            
        case THID_SETBROWSERBARAUTOHIDE:
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                _fAutoHideBrowserBar = pvarargIn->lVal;
                if (!_fAutoHideBrowserBar)
                {
                    // clear initial hide anymore.  they are well aware of it if
                    // they hit this switch
                    _fInitialBrowserBar = FALSE;
                    _ShowBrowBar();
                }
            }            
            break;
            
        case THID_SETBROWSERBARWIDTH:
            if (pvarargIn && pvarargIn->vt == VT_I4)
                _cxBrowBarShown = pvarargIn->lVal;
            break;
            
        case THID_SETTOOLBARAUTOHIDE:
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                _fAutoHideToolbar = pvarargIn->lVal;
                if (pvarargIn->lVal)
                    _HideToolbar();
                else                             
                    _ShowToolbar();                                    
            }
            break;         

        case THID_ONINTERNET:
            IUnknown_Exec(_pdbBrand, &CGID_PrivCITCommands, CITIDM_ONINTERNET, nCmdexecopt, pvarargIn, pvarargOut);
            break;

        case THID_RECALCSIZING:
            RecalcSizing();
            break;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SBCMDID_ONVIEWMOVETOTOP:
            _SanityCheckZorder();
            hres = S_OK;
            break;
        }
    }
    
    return hres;
}

void CTheater::_OnCommand(UINT idCmd)
{
    PostMessage(_hwndBrowser, WM_SYSCOMMAND, idCmd, 0);
}

LRESULT CTheater::_FloaterWndProc(HWND  hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CTheater *t = (CTheater*)GetWindowPtr0(hwnd);
    if (!t)
        return 0;

    switch (uMsg)
    {
    case WM_COMMAND:
        t->_OnCommand(GET_WM_COMMAND_ID(wParam, lParam));
        break;

    case WM_CLOSE:
    case WM_NOTIFY:
        return SendMessage(t->_hwndBrowser, uMsg, wParam, lParam);

    case WM_TIMER:
    {           
        switch (wParam) {

        case IDT_HIDEFLOATER1SEC:
            t->_HideFloater();
            break;                       

        case IDT_INITIALBROWSERBAR:
            // _fAutoHideBrowserBar may have changed after the timer was set
            if (t->_fAutoHideBrowserBar)
                t->_HideBrowBar();
            return 1;
            
        case IDT_INITIAL:
            {
                t->_HideToolbar();
                t->_hhook = SetWindowsHookEx(WH_MOUSE, _MsgHook, MLGetHinst(), GetCurrentThreadId());

                HWND hwndInsertAfter;
                if (t->_IsBrowserActive())
                {
                    // We're active, just move to non-topmost
                    hwndInsertAfter = HWND_NOTOPMOST;
                }
                else
                {
                    // Another window became active while we were
                    // moving to fullscreen mode; move ourselves below
                    // that window.  We need to walk up the parent chain
                    // so that if the window has a modal dialog open we
                    // won't insert ourselves between the dialog and the
                    // app.
                    hwndInsertAfter = GetForegroundWindow();
                    HWND hwnd;
                    while (hwnd = GetParent(hwndInsertAfter))
                    {
                        hwndInsertAfter = hwnd;
                    }
                }

                SetWindowZorder(t->_hwndBrowser, hwndInsertAfter);

                // Call the hook handler manually to insure that even if there's no mouse
                // movement the handler will get called once.  That way, bar unhiding will
                // still work if the user has already given up and stopped moving the mouse.

                t->_OnMsgHook(0, 0, NULL, TRUE);
            }

            break;
            
        case IDT_UNHIDE:
            switch (t->_iUnhidee)
            {
                case IDT_TOOLBAR:
                    t->_ShowToolbar();
                    break;
                
                case IDT_BROWBAR:
                    t->_ShowBrowBar();
                    break;
                
                case IDT_TASKBAR:
                    t->_ShowTaskbar();
                    break;

            }
            SetTimer(t->_hwndFloater, IDT_DELAY, LONG_DELAY, NULL);
            t->_fDelay = TRUE;            
            t->_iUnhidee = 0;
            break;

        case IDT_DELAY:
            t->_fDelay = FALSE;
            break;        
            
        case IDT_HIDETOOLBAR:
            t->_ContinueHideToolbar();
            break;
            
        case IDT_HIDEBROWBAR:
            t->_ContinueHideBrowBar();
            break;

        case IDT_HIDEFLOATER:
            t->_ContinueHideFloater();
            break;
        }
        KillTimer(hwnd, wParam);
        break;
    }

    case WM_SETTINGCHANGE:
        if (wParam == SPI_SETNONCLIENTMETRICS)
        {
            t->RecalcSizing();
        }
        break;

    case WM_ERASEBKGND:
    {
        HDC hdc = (HDC)wParam;
        RECT rc;
        GetClientRect(hwnd, &rc);
        SHFillRectClr(hdc, &rc, t->_clrBrandBk);        
        return 1;
    }        

    default:
        return ::DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }        

    return 0;
}

void CTheater::RecalcSizing()
{
    _SizeBrowser();
    _SizeFloater();
}

HRESULT CTheater::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    return IUnknown_QueryService(_punkOwner, guidService, riid, ppvObj);
}

HRESULT CTheater::SetBrowserBar(IUnknown* punk, int cxHidden, int cxExpanded)
{
    if (punk != _punkBrowBar) {
        IUnknown_Exec(_punkBrowBar, &CGID_Theater, THID_DEACTIVATE, 0, NULL, NULL);
        ATOMICRELEASE(_punkBrowBar);

        IUnknown_GetWindow(punk, &_hwndBrowBar);
        _punkBrowBar = punk;
        if (punk)
            punk->AddRef();
    
        if (_hwndBrowBar) 
        {
            _cxBrowBarShown = cxExpanded;
            
            // tell the browser bar to only ever request the hidden window size
            VARIANT var = { VT_I4 };
            var.lVal = _fAutoHideBrowserBar;
            IUnknown_Exec(_punkBrowBar, &CGID_Theater, THID_ACTIVATE, 0, &var, &var);
            _fAutoHideBrowserBar = var.lVal;            
        }
    } 

    if (punk) {
        if (_hwndBrowBar)
            _ShowBrowBar();                
   
        // if we're in autohide mode, the first hide should be slow
        if (_fAutoHideBrowserBar) {
            _fInitialBrowserBar = TRUE;        
            SetTimer(_hwndFloater, IDT_INITIALBROWSERBAR, 1000, NULL);
        }
    }
    return S_OK;
}

#endif /* !DISABLE_FULLSCREEN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\unixstuff.cpp ===
/*----------------------------------------------------------
Purpose: Unix-menus related functions.

*/

#include <tchar.h>
#include <process.h>

#include "priv.h"
#pragma hdrstop

#ifdef UNIX

#include "unixstuff.h"
#include "resource.h"

DWORD g_dwTlsInfo = 0xffffffff;

void UnixStuffInit()
{
    g_dwTlsInfo = TlsAlloc();
}

// This is OK since we use Old Nt40 Shell32.

STDAPI_(BOOL) WINAPI SHGetFileClassKey (LPCTSTR szFile, HKEY * phkey, HKEY * phkeyBase);
STDAPI_(VOID) WINAPI SHCloseClassKey   (HKEY hkey);

void InitializeExplorerClass();

STDAPI_(BOOL) FileHasProperAssociation (LPCTSTR path)
{
    BOOL bRet = FALSE;
    HKEY hkClass = NULL, hkBase = NULL;
    if( SHGetFileClassKey(path, &hkClass, &hkBase ) )
    {
        bRet = TRUE;
        if(hkClass) SHCloseClassKey( hkClass );
        if(hkBase ) SHCloseClassKey( hkBase  );
    }
    return bRet;
}

#define WMC_UNIX_NEWWINDOW            (WM_USER + 0x0400)

LRESULT HandleCopyDataUnix(CShellBrowser2* psb, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
    case WMC_DISPATCH:
    {
        DDENAVIGATESTRUCT *pDDENav;
        LPSTR szURL;
        LRESULT lres = 0;

        szURL = (LPSTR)((COPYDATASTRUCT*)lParam)->lpData;
        pDDENav = new(DDENAVIGATESTRUCT);
        if (pDDENav)
        {
            pDDENav->wszUrl = (LPWSTR)LocalAlloc(LPTR, (lstrlenA(szURL) + 1) * sizeof(WCHAR));
            if (pDDENav->wszUrl)
            {
                pDDENav->transID = 0;
                MultiByteToWideChar(CP_ACP, 0, szURL, lstrlenA(szURL), pDDENav->wszUrl, lstrlenA(szURL));
                lres = psb->WndProcBS(hwnd, WMC_DISPATCH, (WPARAM)DSID_NAVIGATEIEBROWSER, (LPARAM)pDDENav);
                LocalFree(pDDENav->wszUrl);
            }
            delete(pDDENav);
        }
        return lres;
    }
    case WMC_UNIX_NEWWINDOW:
    {
        LPSTR szURL;
        WCHAR wszURL[MAX_URL_STRING];
        LPITEMIDLIST pidl;
        HRESULT hres = S_OK;

        szURL = (LPSTR)((COPYDATASTRUCT*)lParam)->lpData;
        if (szURL[0])
        {
            MultiByteToWideChar(CP_ACP, 0, szURL, lstrlenA(szURL) + 1, wszURL, ARRAYSIZE(wszURL));
        }
        else
        {
            hres = _GetStdLocation(wszURL, ARRAYSIZE(wszURL), DVIDM_GOHOME);
        }
        if (SUCCEEDED(hres)) 
        {
            hres = psb->IEParseDisplayName(CP_ACP, wszURL, &pidl);
            if (SUCCEEDED(hres)) 
                hres = psb->BrowseObject(pidl, SBSP_NEWBROWSER);
        }
        ILFree(pidl);
        return hres;
    }
    default:
        return FALSE;
    }
}

void StoreIEWindowInfo( HWND hwnd )
{
    if (g_dwTlsInfo != 0xffffffff)
    {
        TlsSetValue( g_dwTlsInfo, hwnd );
    }
}

HWND GetIEWindowOnThread( )
{
    if (g_dwTlsInfo != 0xffffffff)
    {
        return (HWND)TlsGetValue( g_dwTlsInfo );
    }

    return (HWND)0;
}


void PrintIEVersion()
{
    CHAR aboutInf[MAX_PATH] = "", *ptr;

    // Get the version information from Shlwapi
    SHAboutInfoA( aboutInf, sizeof(aboutInf) );
    ptr = StrChrA( aboutInf, '~' );
    if( ptr ) *ptr = '\0';
    
    printf("Internet Explorer %s ; Copyright (c) 1995-98 Microsoft Corp.\n", aboutInf);
}

void PrintIEHelp()
{
    CHAR aboutInf[MAX_PATH] = "", *ptr;

    // Get the version information from Shlwapi
    SHAboutInfoA( aboutInf, sizeof(aboutInf) );
    ptr = StrChrA( aboutInf, '~' );
    if( ptr ) *ptr = '\0';
    
    printf("Internet Explorer %s :\n\tUsage : iexplorer [ options ... ] [ URL ]\n\n", aboutInf);
    printf("Valid command line options :\n");
    printf("\t-root    : Opens Internet Explorer, connects to default home page.\n");
    printf("\t-slf     : Opens Internet Explorer, loads home page from cache.\n");
    printf("\t-k       : Kiosk mode.\n");
    printf("\t-version : Prints out the version of Internet Explorer.\n");
    printf("\t-v       : Same as -version.\n\n");
    printf("URL - Name that will be interpreted as either a URL or a file to be loaded.\n");
}

BOOL CheckForInvalidOptions( LPCTSTR inCmdLine )
{
    LPTSTR pszCmdLine = (LPTSTR) inCmdLine;

    TCHAR * knownOptions[] = { TEXT("help"), TEXT("embedding"), TEXT("slf"), TEXT("root"), TEXT("k"), TEXT("version"), TEXT("v"), TEXT("nohome") };

    int nCountOptions = sizeof(knownOptions)/sizeof(TCHAR *);

    while( 1 )
    {
        TCHAR * pos = StrChr( pszCmdLine, TEXT('-') );
        if( pos )
        {
            BOOL bFound = FALSE;
            pos++;
            TCHAR * option = pos;
            while( *pos && *pos != TEXT(' ') ) pos++;

            // Check for empty option or embedded '-'

            if( pos != option && 
              ( (option <= inCmdLine+1) || (*(option-2) == TEXT(' ')) ) )
            {
                for(int i = 0; i<nCountOptions; i++ )
                    if(!StrCmpNI( option, knownOptions[i], 
                                  lstrlen(knownOptions[i]))) 
                    {
                         bFound = TRUE;
                         break;
                    } 

                if( bFound == FALSE )
                {
                    *pos = TCHAR('\0');
                    printf("Unknown option : %s\n\n", option);
                    PrintIEHelp();
                    return bFound;
                }
            }
             
            pszCmdLine = pos;
        }
        else break;
    }

    return TRUE;
}



#ifdef NO_MARSHALLING

// We have multiple windows on a thread.
// So we store the list of psbs in a THREADWINDOWINFO * 
// in each thread (stored in a TLS).

#define DWSTYLE WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN

extern "C" DWORD g_TLSThreadWindowInfo = ~0; 

STDAPI CoMarshalInterfaceDummy( IStream *pStm, REFIID riid, IUnknown *pUnk, DWORD dwDestContext, void *pvDestContext, DWORD mshlflags )
{
    if (pStm)
    {
       HRESULT hres;
       ULONG pcbWrite = 0;
       pStm->Seek(c_li0, STREAM_SEEK_SET, NULL);
       hres = pStm->Write( &pUnk, SIZEOF(pUnk), &pcbWrite );
       pUnk->AddRef(); 
       return hres;
    }
    
    return E_FAIL;
} 


LPCTSTR _GetExplorerClassName(UINT uFlags);

EXTERN_C void IEFrameNewWindowSameThread(IETHREADPARAM* piei)
{
    DWORD uFlags = piei->uFlags;
    THREADWINDOWINFO *lpThreadWindowInfo;
#ifdef NO_MARSHALLING
    BOOL fFirstTime = FALSE;
#endif 

    ASSERT(piei);

    if (!piei)
        return;

    LPWSTR pszCloseEvent = NULL;
    if (uFlags & COF_FIREEVENTONCLOSE)
    {
        ASSERT(piei->szCloseEvent[0]);
        pszCloseEvent = StrDup(piei->szCloseEvent);
    }

    // We shouldn't be the first ones 
    ASSERT(~0 != g_TLSThreadWindowInfo)
    lpThreadWindowInfo = (THREADWINDOWINFO *) TlsGetValue(g_TLSThreadWindowInfo);
    ASSERT(lpThreadWindowInfo); 
    if (!lpThreadWindowInfo)
    {
#ifdef NO_MARSHALLING
        if (!(lpThreadWindowInfo = InitializeThreadInfoStructs()))
            goto Done;
        fFirstTime = TRUE;
#else
        goto Done;
#endif 
    }

#ifdef DEBUG_EXPLORER
    piei->wv.bTree = TRUE;
    piei->TreeSplit = 200; // some random default
#endif

    TraceMsg(TF_COCREATE, "IEFrameNewWindowSameThread calling CreateWindowEx");

#ifdef NO_MARSHALLING
    if (!piei->fOnIEThread)
        InitializeExplorerClass();
#endif 

    LPCTSTR pszClass;
    
    HMENU hmenu = CreateMenu();
    HWND  hwnd  = CreateWindowEx(WS_EX_WINDOWEDGE, 
                   _GetExplorerClassName(piei->uFlags), NULL, DWSTYLE,
                   CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                   NULL, 
                   hmenu, 
                   HINST_THISDLL, piei);
    if (uFlags & COF_HELPMODE )
    {
        RECT rc;
        GetWindowRect( hwnd, &rc );
        SetWindowPos ( hwnd, 0, rc.left, rc.top, BROWSER_DEFAULT_WIDTH * 3 /4, BROWSER_DEFAULT_HEIGHT * 3 / 4, SWP_NOZORDER );
    }

    if (hwnd)
    {
        // Enable File Manager drag-drop for win16
        DragAcceptFiles(hwnd, TRUE);

        CShellBrowser2* psb = (CShellBrowser2*)GetWindowLong(hwnd, 0);

        if (psb)
        {
            // We are string another refrence to this object in
            // ThreadInfo Stuctures, so AddRef.

            psb->AddRef();

            psb->_AfterWindowCreated(piei);
#ifdef NO_MARSHALLING
            if (fFirstTime)
            {
                // this should happen only if IE is created on a different
                // thread, such as OE dochost
                AddFirstBrowserToList(psb);
            }
            else 
            {
#endif 
                lpThreadWindowInfo->cWindowCount++;
                // tack new window on end of list
                CShellBrowser2** rgpsb = (CShellBrowser2**)
                LocalReAlloc(lpThreadWindowInfo->rgpsb, 
                             lpThreadWindowInfo->cWindowCount * sizeof(CShellBrowser2 *), LMEM_MOVEABLE);
                ASSERT(rgpsb);
                if (rgpsb)
                {
                    lpThreadWindowInfo->rgpsb = rgpsb;
                    rgpsb[lpThreadWindowInfo->cWindowCount-1] = psb;
                    psb->AddRef();
                }
#ifdef NO_MARSHALLING
            }
#endif 
            // The message pump would go here.
            // Let the threadproc handle it.

            psb->Release();
        }
    }
    else
    {
        // Unregister any pending that may be there
        WinList_Revoke(piei->dwRegister);
        TraceMsg(DM_ERROR, "IEFrameNewWindowSameThread CreateWindow failed");
    }

Done:
    if (pszCloseEvent)
    {
        FireEventSz(pszCloseEvent);
    }

    if (piei)
        delete piei;
}

EXTERN_C THREADWINDOWINFO * InitializeThreadInfoStructs()
{
    THREADWINDOWINFO *lpThreadWindowInfo;

    // Allocate a TLS if needed. Will be freed in the WEP.
    if (~0 == g_TLSThreadWindowInfo)
    {
        g_TLSThreadWindowInfo = TlsAlloc();
        ASSERT (~0 != g_TLSThreadWindowInfo);
        lpThreadWindowInfo = NULL;
    }
    else
    {
        lpThreadWindowInfo = (THREADWINDOWINFO *) TlsGetValue(g_TLSThreadWindowInfo);
    }

    if (NULL == lpThreadWindowInfo && ~0 != g_TLSThreadWindowInfo)
    {
        lpThreadWindowInfo = (THREADWINDOWINFO *) LocalAlloc(LPTR, sizeof(*lpThreadWindowInfo));
        TlsSetValue(g_TLSThreadWindowInfo, lpThreadWindowInfo);
    }

    ASSERT(lpThreadWindowInfo);

    return lpThreadWindowInfo;

}

EXTERN_C void FreeThreadInfoStructs()
{
    THREADWINDOWINFO *lpThreadWindowInfo;
    lpThreadWindowInfo = (THREADWINDOWINFO *)TlsGetValue(g_TLSThreadWindowInfo);

    if( lpThreadWindowInfo )
    {
        LocalFree(lpThreadWindowInfo->rgpsb);
        LocalFree(lpThreadWindowInfo);
        TlsSetValue(g_TLSThreadWindowInfo, NULL);
    }
}

EXTERN_C void AddFirstBrowserToList( CShellBrowser2 *psb )
{
    if( psb )
    {
        THREADWINDOWINFO *lpThreadWindowInfo;
        lpThreadWindowInfo = (THREADWINDOWINFO *) TlsGetValue(g_TLSThreadWindowInfo);
        lpThreadWindowInfo->cWindowCount++;
        // tack new window on end of list
        lpThreadWindowInfo->rgpsb = (CShellBrowser2**) LocalAlloc(LPTR, sizeof(CShellBrowser2 *));
        ASSERT(lpThreadWindowInfo->rgpsb); // if this fails we're DEAD
        if( lpThreadWindowInfo->rgpsb )
        {
            lpThreadWindowInfo->rgpsb[0] = psb;
            psb->AddRef();
        }
    }
}

EXTERN_C void RemoveBrowserFromList( CShellBrowser2 *psb )
{
    if (psb->_fReallyClosed)
    {
        int i;
        BOOL fFoundSB = FALSE;
        THREADWINDOWINFO *lpThreadWindowInfo;
        lpThreadWindowInfo = (THREADWINDOWINFO *) TlsGetValue(g_TLSThreadWindowInfo);
        // remove the window from the list. 
        ASSERT(psb->_pbbd->_hwnd == NULL); 

        for (i = 0; i < lpThreadWindowInfo->cWindowCount; i++)
        {
            if( psb == lpThreadWindowInfo->rgpsb[i] ) 
            {
                fFoundSB = TRUE;
                break;
            }
        }

        if ( fFoundSB )
        {  
            memmove(&lpThreadWindowInfo->rgpsb[i], 
                 &lpThreadWindowInfo->rgpsb[i+1], 
                 (--lpThreadWindowInfo->cWindowCount - i) * sizeof(psb));
            psb->Release(); 
        }
    }
}

#endif // NO_MARSHALLING

#endif // UNIX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\theater.h ===
#ifndef _THEATER_H
#define _THEATER_H

// Metrics for this view mode
#define THEATER_CYTOOLBAR       26
#define CLOSEMIN_HEIGHT         16
#define CLOSEMIN_YOFFSET        1
#define CLOSEMIN_XOFFSET        1
#define CLOSEMIN_WIDTH          54
#define PROGRESS_WIDTH          (CLOSEMIN_WIDTH + 2)
#define PROGRESS_HEIGHT         6
#define PROGRESS_YPOS           (CLOSEMIN_HEIGHT + (2 * CLOSEMIN_YOFFSET) + 1)
#define BRAND_YOFFSET           0
#define BRAND_WIDTH             34
#define BRAND_HEIGHT            26
#define CX_HIT                  (GetSystemMetrics(SM_CXEDGE) * 3)
#define CX_BROWOVERLAP          (GetSystemMetrics(SM_CXEDGE) / 2)
#define CX_FLOATERSHOWN         (BRAND_WIDTH + CLOSEMIN_WIDTH + (2 * CLOSEMIN_XOFFSET))

#define SHORT_DELAY             90
#define LONG_DELAY              (4 * SHORT_DELAY)

// Theatre mode controls
#define TMC_PROGRESSBAR     1
#define TMC_BRANDBAND       2
#define TMC_STATUSBAR       3

#define TM_STATUS_PANES                2
#define TM_STATUS_PANE_NAVIGATION      0
#define TM_STATUS_PANE_SSL             1

class CShellBrowser2;

class CTheater:
   public IOleWindow, 
   public IOleCommandTarget, 
   public IServiceProvider
{
    
public:
    HWND GetMasterWindow() {return _hwndBrowser;};
    void Begin();
    CTheater(HWND hwnd, HWND hwndToolbar, IUnknown *punkOwner);
    ~CTheater();
    
    
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }
    
    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    HRESULT SetBrowserBar(IUnknown* punk, int cxHidden, int cxExpanded);
    void GetPreviousWindowPlacement(WINDOWPLACEMENT* pwp, LPRECT prc)  { *pwp = _wp; *prc = _rcOld;};
    void SetAutoHideToolbar(long val) { _fAutoHideToolbar = val; };            
    void RecalcSizing();

protected:
    friend class CShellBrowser2;
    // save data
    // we put the save state data in here so that the browser doesn't have to waste memory with this data when not in theater mode
    // also, because it's transient, don't use bitfields.  save code instead of memory for transient stuff
    
private:
    int _cyLast;
    HWND _hwndToolbar; // this is the toolbar window that we want to make sure the hidden window encompasses
    HWND _hwndBrowser; // this is the hwnd that we slide down
    HWND _hwndTaskbar;
    BOOL _fShown;
    BOOL _fTaskbarShown;
    BOOL _fDelay;
    BOOL _fAutoHideToolbar;
    BOOL _fInitialBrowserBar;
    BOOL _fAutoHideBrowserBar;    

    HHOOK   _hhook;
    IUnknown *_punkOwner;
    IUnknown *_punkBrowBar;
    HWND _hwndBrowBar;
    WINDOWPLACEMENT _wp;
    RECT _rcOld;
    
    UINT _cRef;
    
    IDeskBand* _pdbBrand;
    HWND _hwndClose;
    HWND _hwndFloater;      // the Floating pallete window
    HWND _hwndProgress;     // used in CShellBrowser(2) - maybe move to interface
    int _cActiveRef;        // the ref count for activating the Floatering palette

    static CAssociationList _al; // associate threadid with CTheater objects
    
    void _SwapParents(HWND hwndOld, HWND hwndNew);
    void _Initialize();
    void _SizeBrowser();
    void _SizeFloater();
    void _CreateCloseMinimize();
    void _PositionCloseRestore();
    void _DelayHideFloater();

    void _DelayHideToolbar();
    void _HideToolbar();
    void _ShowToolbar();
    void _ContinueHideToolbar();
    LRESULT _OnMsgHook(int nCode, WPARAM wParam, MOUSEHOOKSTRUCT *pmhs, BOOL fFake);

    BOOL _IsBrowserActive();
    
    void _ShowTaskbar();
    void _HideTaskbar();

    void _Unhide(int iWhich, UINT uDelay);
    int _iUnhidee;

    BOOL _PtNearWindow(POINT pt, HWND hwnd);
    BOOL _PtOnEdge(POINT pt, int iEdge);
    BOOL _GetWindowRectRel(HWND hWnd, LPRECT lpRect);

    BOOL_PTR _HasBegun() { return (BOOL_PTR)_hhook; }
    
    BOOL _fBrowBarShown;
    int _cxBrowBarShown;
    int _cxBrowBarHidden;
    void _ContinueHideBrowBar();
    void _HideBrowBar();
    void _ShowBrowBar();

    BOOL _CanHideWindow(HWND hwnd);

    BOOL _fFloaterShown;
    COLORREF _clrBrandBk;
    void _ContinueHideFloater();
    void _HideFloater();
    void _ShowFloater();

    void _SanityCheckZorder();
    void _OnCommand(UINT idCmd);

    static LRESULT _MsgHook(int nCode, WPARAM wParam, LPARAM lParam);
    static LRESULT _FloaterWndProc(HWND  hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#define THID_ACTIVATE               1
#define THID_DEACTIVATE             2
#define THID_SETBROWSERBARWIDTH     3  // tells the browser bar what it's fixed width should be
#define THID_SETTOOLBARAUTOHIDE     4
#define THID_SETBROWSERBARAUTOHIDE  5
#define THID_TOOLBARACTIVATED       6
#define THID_ONINTERNET             7
#define THID_RECALCSIZING           8

// Explorer bar registry save structure
typedef struct _BROWBARSAVE {
    UINT uiWidthOrHeight;
    BOOL fAutoHide : 1;
} BROWBARSAVE;

#define SZ_REGVALUE_EXPLORERBARA  "ExplorerBar"
#define SZ_REGVALUE_EXPLORERBAR   TEXT(SZ_REGVALUE_EXPLORERBARA)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\trsite.h ===
#ifndef _TRSITE_H
#define _TRSITE_H

class CTransitionSite;
class CTransitionSitePropertyBag;

/////////////////////////////////////////////////////////////////////////////
// Typedefs and Structs
/////////////////////////////////////////////////////////////////////////////
enum TransitionEvent    // Transition Event type
{
    teFirstEvent        = 0,

    teSiteEnter         = teFirstEvent,
    tePageEnter,
    teSiteExit,
    tePageExit,

    teNumEvents,    // NOTE: Must follow last event!

    teUserDefault       = teNumEvents
};

struct TRANSITIONINFO   // Transition Event information
{
    CLSID                           clsid;
    CTransitionSitePropertyBag *    pPropBag;
};

struct NAMEVALUE
{
    WCHAR * pwszName;
    VARIANT varValue;
};

/////////////////////////////////////////////////////////////////////////////
// CTransitionSite
/////////////////////////////////////////////////////////////////////////////
class CTransitionSite : public IViewFilter,
                        public IViewFilterSite,
                        public IAdviseSink,
                        public IDispatch
{
// Construction/Destruction
public:
    CTransitionSite(IShellBrowser * pcont);
    ~CTransitionSite();

    HRESULT _SetTransitionInfo(TransitionEvent te, TRANSITIONINFO * pti);

    HRESULT _ApplyTransition(BOOL bSiteChange);
    HRESULT _StartTransition();
    HRESULT _StopTransition();

    HRESULT _UpdateEventList();

    enum TRSTATE
    {
        TRSTATE_NONE            = 0,
        TRSTATE_INITIALIZING    = 1,
        TRSTATE_STARTPAINTING   = 2,
        TRSTATE_PAINTING        = 3
    };

    TRSTATE         _uState;
    IShellView *    _psvNew;        // Valid only while we are playing
    IViewObject *   _pvoNew;
    BOOL            _fViewIsVisible;
    HWND            _hwndViewNew;
    IViewFilter *   _pTransition;
    IDispatch *     _pDispTransition;
    DWORD           _dwTransitionSink;

// Data
private:
    IShellBrowser *     _pContainer;    // CBaseBrowser container of parent
    IViewFilterSite *   _pSite;

    TRANSITIONINFO *    _ptiCurrent;
    TRANSITIONINFO      _tiEventInfo[teNumEvents];

// Internal methods
private:
    HRESULT _LoadTransition();
    HRESULT _InitWait();
    HRESULT _OnComplete();

// Interfaces
public:
    // IUnknown
    STDMETHOD(QueryInterface)   (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef)   (void);
    STDMETHOD_(ULONG, Release)  (void);
    
    // IViewFilter
    STDMETHOD(SetSource)        (IViewFilter *pFilter);
    STDMETHOD(GetSource)        (IViewFilter **ppFilter);
    STDMETHOD(SetSite)          (IViewFilterSite *pSink);
    STDMETHOD(GetSite)          (IViewFilterSite **ppSink);
    STDMETHOD(SetPosition)      (LPCRECT prc);
    STDMETHOD(Draw)             (HDC hdc, LPCRECT prc);
    STDMETHOD(GetStatusBits)    (DWORD *pdwFlags);
    
    // IViewFilterSite
    STDMETHOD(GetDC)                (LPCRECT prc, DWORD dwFlags, HDC *phdc);
    STDMETHOD(ReleaseDC)            (HDC hdc);
    STDMETHOD(InvalidateRect)       (LPCRECT prc, BOOL fErase);
    STDMETHOD(InvalidateRgn)        (HRGN hrgn, BOOL fErase);
    STDMETHOD(OnStatusBitsChange)   (DWORD dwFlags);

    // IAdviseSink
    STDMETHOD_(void, OnDataChange)  (FORMATETC * pFormatetc, STGMEDIUM * pStgmed) {}
    STDMETHOD_(void, OnViewChange)  (DWORD dwAspect, LONG lindex);
    STDMETHOD_(void, OnRename)      (IMoniker * pmk) {}
    STDMETHOD_(void, OnSave)        () {}
    STDMETHOD_(void, OnClose)       () {}

    // IDispatch
    STDMETHOD(GetTypeInfoCount) (UINT * pctinfo) { return E_NOTIMPL; }
    STDMETHOD(GetTypeInfo)      (UINT itinfo, LCID lcid, ITypeInfo ** pptinfo) { return E_NOTIMPL; }
    STDMETHOD(GetIDsOfNames)    (REFIID riid, OLECHAR ** rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid) { return E_NOTIMPL; }
    STDMETHOD(Invoke)           (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);
};

/////////////////////////////////////////////////////////////////////////////
// CTransitionSitePropertyBag
/////////////////////////////////////////////////////////////////////////////
class CTransitionSitePropertyBag : public IPropertyBag
{
// Construction/Destruction
public:
    CTransitionSitePropertyBag();
    virtual ~CTransitionSitePropertyBag();

    HRESULT _AddProperty(WCHAR * wszPropName, VARIANT * pvarValue);

// Data
protected:
    UINT    _cRef;
    HDPA    _hdpaProperties;

// Implementation
protected:
    static int _DPA_FreeProperties(LPVOID pv, LPVOID pData);

// Interfaces
public:
    // IUnknown
    STDMETHOD(QueryInterface)   (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef)   (void);
    STDMETHOD_(ULONG, Release)  (void);

    // IPropertyBag
    STDMETHOD(Read) (LPCOLESTR pszPropName, VARIANT * pVar, IErrorLog * pErrorLog);
    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT * pVar)
    { return E_NOTIMPL; }
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions
/////////////////////////////////////////////////////////////////////////////
HRESULT CLSIDFromTransitionName(LPCTSTR pszName, LPCLSID clsidName);
BOOL    ParseTransitionInfo(WCHAR * pwz, TRANSITIONINFO * pti);

#define ISSPACE(ch) (((ch) == 32) || ((unsigned)((ch) - 9)) <= 13 - 9)

#endif  // _TRSITE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\unixstuff.h ===
/* Unix specific function prototypes */

#include <mainwin.h>
#include "../shdocvw/unixstuff.h"
#include "shbrows2.h"
#include "shalias.h"

#define MAIL_ACTION_SEND 1
#define MAIL_ACTION_READ 2

#define UNIX_TITLE_SUFFIX TEXT("")

EXTERN_C MwPaintSpecialEOBorder( HWND hWnd, HDC hDC );

BOOL CheckForInvalidOptions( LPCTSTR inCmdLine );
void PrintIEHelp();
void PrintIEVersion();

// IE Thread Info stuff
void UnixStuffInit();
void StoreIEWindowInfo( HWND hwnd );
HWND GetIEWindowOnThread();

// Marshalling stuff

#define CoMarshalInterface CoMarshalInterfaceDummy

STDAPI CoMarshalInterfaceDummy( IStream *, REFIID, IUnknown *, DWORD, void *, DWORD );

struct THREADWINDOWINFO
{
    int cWindowCount;
    CShellBrowser2** rgpsb;
};

EXTERN_C THREADWINDOWINFO * InitializeThreadInfoStructs();
EXTERN_C HRESULT TranslateModelessAccelerator(MSG* msg, HWND hwnd);
EXTERN_C void FreeThreadInfoStructs();
EXTERN_C void AddFirstBrowserToList( CShellBrowser2 *psb );
EXTERN_C void RemoveBrowserFromList( CShellBrowser2 *psb );
EXTERN_C void IEFrameNewWindowSameThread(IETHREADPARAM* piei);
STDAPI_(BOOL) FileHasProperAssociation (LPCTSTR path);

BOOL IsNamedWindow(HWND hwnd, LPCTSTR pszClass);

LRESULT HandleCopyDataUnix(CShellBrowser2* psb, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#define DM_THREADWINDOWINFO          0

inline CShellBrowser2 * CheckAndForwardMessage( 
       THREADWINDOWINFO * lpThreadWindowInfo ,
       CShellBrowser2 * psb, 
       MSG msg
       )
{
    // get psb for msg.hwnd. (Note psb inside scope may != psb outside)
    if (lpThreadWindowInfo->cWindowCount)
    {
        CShellBrowser2* psb, *psbActive = NULL;
        int i;
        BOOL fFoundSB = FALSE, fDelayClosed = FALSE;
        for (i = 0; i < lpThreadWindowInfo->cWindowCount; i++)
        {
            psb = lpThreadWindowInfo->rgpsb[i];

            // Save the active window here so that  we don't have to 
            // loop again.
            if(psb->_fActivated) 
            {
                psbActive = psb;
            }

            if(psb->_fDelayedClose)
            {
                fDelayClosed = TRUE;
            }

            if (psb->_pbbd->_hwnd == msg.hwnd || IsChild(psb->_pbbd->_hwnd, msg.hwnd))
            {
                fFoundSB = TRUE;
                break;
            }
       }

#ifdef DEBUG
       if (!fFoundSB)
       {
           TraceMsg(DM_THREADWINDOWINFO, "CheckAndForwardMessage() ThreadWindowInfo didnt find psb for hwnd = %X, reusing hwnd = %X", msg.hwnd, psb->_pbbd->_hwnd);
       }
#endif //DEBUG                            

       if( fDelayClosed || (i<lpThreadWindowInfo->cWindowCount) )
       {
           // Post WM_CLOSE messages for all the windows which are delayClosed.
           for (i = 0; i < lpThreadWindowInfo->cWindowCount; i++)
           {
               CShellBrowser2* psbDel = lpThreadWindowInfo->rgpsb[i];
               if( psbDel->_fDelayedClose )
               {
                   psbDel->_fDelayedClose = FALSE;
                   PostMessage( psbDel->_pbbd->_hwnd, WM_CLOSE, 0, 0 );
               }
           }
       }

       // Pass message to the current active window, because we fail to find the
       // appropriate parent. This happens in case of favorites window and msgs
       // get diverted to the last window on the array, which may be wrong.

       if( !fFoundSB && psbActive )
       {
           psb = psbActive;
       }
  
       return psb;
    }
    return NULL;
}

#undef KEYBOARDCUES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\xbarglyph.cpp ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      XBarGlyph.h
//
//  Contents:  image of an xBar pane
//
//  Classes:   CXBarGlyph
//
//------------------------------------------------------------------------

#include "priv.h"
#include "XBarGlyph.h"
#include "resource.h"
#include "tb_ids.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#define CX_SMALL_ICON   16
#define CX_LARGE_ICON   20

// These defines are zero-index offsets into the existing toolbar buttons
#define IBAR_ICON_FAVORITES 6
#define IBAR_ICON_SEARCH    5
#define IBAR_ICON_HISTORY   12
#define IBAR_ICON_EXPLORER  43
#define IBAR_ICON_DEFAULT   10


//------------------------------------------------------------------------
CXBarGlyph::CXBarGlyph()
  : _hbmpColor(NULL),
    _hbmpMask(NULL),
    _fAlpha(FALSE),
    _lWidth(0),
    _lHeight(0)
{

}

//------------------------------------------------------------------------
CXBarGlyph::~CXBarGlyph()
{
    DESTROY_OBJ_WITH_HANDLE(_hbmpColor, DeleteObject);
    DESTROY_OBJ_WITH_HANDLE(_hbmpMask, DeleteObject);
}

//------------------------------------------------------------------------
HRESULT
    CXBarGlyph::SetIcon(HICON hIcon, BOOL fAlpha)
{
    DESTROY_OBJ_WITH_HANDLE(_hbmpColor, DeleteObject);
    DESTROY_OBJ_WITH_HANDLE(_hbmpMask, DeleteObject);

    if (hIcon == NULL) {
        return E_INVALIDARG;
    }
    ICONINFO    ii = {0};
    if (GetIconInfo(hIcon, &ii))
    {
        _hbmpColor = ii.hbmColor;
        _hbmpMask = ii.hbmMask;
        _fAlpha = fAlpha;
        _EnsureDimensions();
    }
    else {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

//------------------------------------------------------------------------
HICON
    CXBarGlyph::GetIcon(void)
{
    ICONINFO ii = {0};
    ii.fIcon = TRUE;
    ii.hbmColor = _hbmpColor;
    ii.hbmMask = _hbmpMask;
    return CreateIconIndirect(&ii);
}

//------------------------------------------------------------------------
BOOL
    CXBarGlyph::HaveGlyph(void)
{
    return (_hbmpColor != NULL);
}

//------------------------------------------------------------------------
LONG
    CXBarGlyph::GetWidth(void)
{
    _EnsureDimensions();
    return _lWidth;
}

//------------------------------------------------------------------------
LONG
    CXBarGlyph::GetHeight(void)
{
    _EnsureDimensions();
    return _lHeight;
}

//------------------------------------------------------------------------
HRESULT
    CXBarGlyph::LoadGlyphFile(LPCTSTR pszPath, BOOL fSmall)
{
    // ISSUE/010304/davidjen  could be smarter and make educated guess of file format by analyzing file name
    // now we assume it's always an icon format
    USES_CONVERSION;
    HRESULT hr = E_FAIL;
    if (pszPath && *pszPath)
    {
        CString strPath = pszPath;
        HICON   hIcon = NULL;
        int nBmpIndex = PathParseIconLocation((LPWSTR)T2CW(strPath));
        strPath.ReleaseBuffer();

        CString strExpPath;
        SHExpandEnvironmentStrings(strPath, strExpPath.GetBuffer(MAX_PATH), MAX_PATH);
        strExpPath.ReleaseBuffer();

        // If no resource id, assume it's an ico file
        UINT cx = fSmall ? CX_SMALL_ICON : CX_LARGE_ICON;
        if (nBmpIndex == 0)
        {
            hIcon = (HICON)LoadImage(0, strExpPath, IMAGE_ICON, cx, cx, LR_LOADFROMFILE);
        }

        if (hIcon == NULL)
        {
            // try loading as a embedded icon file
            HINSTANCE hInst = LoadLibraryEx(strExpPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
            if (hInst)
            {
                hIcon = (HICON)LoadImage(hInst, MAKEINTRESOURCE(nBmpIndex), IMAGE_ICON, cx, cx, LR_DEFAULTCOLOR);
                FreeLibrary(hInst);
            }
        }
        if (hIcon != NULL)
        {
            // ISSUE/010304/davidjen
            //  assume that we only have non-alpha icons, could be smarter and look at bitmap
            hr = SetIcon(hIcon, false);
        }
    }
    else {
        hr = E_INVALIDARG;
    }
    return hr;
}

//------------------------------------------------------------------------
HRESULT
    CXBarGlyph::LoadDefaultGlyph(BOOL fSmall, BOOL fHot)
{
    HRESULT hr = E_FAIL;
    UINT id = ((SHGetCurColorRes() <= 8) ? IDB_IETOOLBAR: IDB_IETOOLBARHICOLOR);
    id += (fSmall ? 2 : 0) + (fHot ? 1 : 0);
    UINT cx = fSmall ? CX_SMALL_ICON : CX_LARGE_ICON;

    // We should use a cached default icon, rather than repeatedly crafting the default icon ourselves
    HICON hIcon = NULL;
    HIMAGELIST himl = ImageList_LoadImage(HINST_THISDLL,
                                          MAKEINTRESOURCE(id), cx, 0, 
                                          RGB(255, 0, 255),
                                          IMAGE_BITMAP, LR_CREATEDIBSECTION);
    if (himl)
    {
        hIcon = ImageList_GetIcon(himl, IBAR_ICON_DEFAULT, ILD_NORMAL);
        hr = SetIcon(hIcon, false);  // know that this is always non-alpha channel bitmap
        ImageList_Destroy(himl);
    }
    return hr;
}


//------------------------------------------------------------------------
HRESULT
    CXBarGlyph::Draw(HDC hdc, int x, int y)
{
    if (_hbmpColor)
    {
        BITMAP bm;
        GetObject(_hbmpColor, sizeof(bm), &bm);
        if (_fAlpha && (bm.bmBitsPixel >= 32) && IsOS(OS_WHISTLERORGREATER))
        {
            DrawAlphaBitmap(hdc, x, y, GetWidth(), GetHeight(), _hbmpColor);
        }
        else
        {
            DrawTransparentBitmap(hdc, x, y, _hbmpColor, _hbmpMask);
        }
    }
    else
    {
        return S_FALSE; // no glyph
    }
    return S_OK;
}

//------------------------------------------------------------------------
void
    CXBarGlyph::_EnsureDimensions(void)
{
    if (_hbmpColor == NULL)
    {
        _lWidth = _lHeight = 0;
        return;
    }

    // update dimensions of glyph
    if ((_lWidth <= 0) || (_lHeight <= 0))
    {
        BITMAP bm;
        GetObject(_hbmpColor, sizeof(bm), &bm);
        _lWidth = bm.bmWidth;
        _lHeight = bm.bmHeight;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

int IsVK_TABCycler(MSG *pMsg);
BOOL IsVK_CtlTABCycler(MSG *pMsg);

#ifdef __cplusplus
//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
#ifdef DEBUG
    const DWORD* _pdwSigniture;
    const static DWORD s_dummy;
#endif
  public:
    TempBuffer(ULONG cBytes) {
#ifdef DEBUG
        _pdwSigniture = &s_dummy;
#endif
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : LocalAlloc(LMEM_FIXED, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) LocalFree(m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

#endif  // __cplusplus

#ifdef __cplusplus
extern "C" {
#endif

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

BOOL __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...);

HRESULT IUnknown_FileSysChange(IUnknown* punk, DWORD dwEvent, LPCITEMIDLIST* ppidl);
HRESULT QueryService_SID_IBandProxy(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj);
HRESULT CreateIBandProxyAndSetSite(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj);
DWORD GetPreferedDropEffect(IDataObject *pdtobj);
HRESULT _SetPreferedDropEffect(IDataObject *pdtobj, DWORD dwEffect);
#ifdef DEBUG
int SearchDWP(DWORD_PTR *pdwBuf, int cbBuf, DWORD_PTR dwVal);
#endif


#define REGVALUE_STREAMSA           "Streams"
#define REGVALUE_STREAMS            TEXT(REGVALUE_STREAMSA)

#define SZ_REGKEY_TYPEDCMDMRU       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU")
#define SZ_REGKEY_TYPEDURLMRU       TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs")
#define SZ_REGVAL_MRUENTRY          TEXT("url%lu")

#define SZ_REGKEY_INETCPL_POLICIES   TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define SZ_REGVALUE_RESETWEBSETTINGS TEXT("ResetWebSettings")

#define SZ_REGKEY_IE_POLICIES       TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Main")
#define SZ_REGVALUE_IEREPAIR        TEXT("Repair IE Option")
#define SZ_REGKEY_ACTIVE_SETUP      TEXT("Software\\Microsoft\\Active Setup")
#define SZ_REGVALUE_DISABLE_REPAIR  TEXT("DisableRepair")

#if 0
BOOL    IsIERepairOn();
#endif

BOOL IsResetWebSettingsEnabled(void);

HRESULT GetMRUEntry(HKEY hKey, DWORD dwMRUIndex, LPTSTR pszMRUEntry, DWORD cchMRUEntry, LPITEMIDLIST * ppidl);

extern UINT g_cfURL;
extern UINT g_cfHIDA;
extern UINT g_cfFileDescA;
extern UINT g_cfFileDescW;
extern UINT g_cfFileContents;

extern const CLSID g_clsidNull; // for those that want a NULL clsid.

void InitClipboardFormats();

// raymondc's futile attempt to reduce confusion
//
// EICH_KBLAH = a registry key named blah
// EICH_SBLAH = a win.ini section named blah

#define EICH_UNKNOWN        0xFFFFFFFF
#define EICH_KINET          0x00000002
#define EICH_KINETMAIN      0x00000004
#define EICH_KWIN           0x00000008
#define EICH_KWINPOLICY     0x00000010
#define EICH_KWINEXPLORER   0x00000020
#define EICH_SSAVETASKBAR   0x00000040
#define EICH_SWINDOWMETRICS 0x00000080
#define EICH_SPOLICY        0x00000100
#define EICH_SSHELLMENU     0x00000200
#define EICH_KWINEXPLSMICO  0x00000400
#define EICH_SWINDOWS       0x00000800

DWORD SHIsExplorerIniChange(WPARAM wParam, LPARAM lParam);


#define GEN_DEBUGSTRW(str)  ((str) ? (str) : L"<Null Str>")
#define GEN_DEBUGSTRA(str)  ((str) ? (str) : "<Null Str>")

#ifdef UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRW
#else // UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRA
#endif // UNICODE


void _InitAppGlobals();
BOOL _InitComCtl32();


void* DataObj_GetDataOfType(IDataObject* pdtobj, UINT cfType, STGMEDIUM *pstg);
HRESULT RootCreateFromPath(LPCTSTR pszPath, LPITEMIDLIST * ppidl);

extern DEFFOLDERSETTINGS g_dfs;

STDAPI_(void) SaveDefaultFolderSettings(UINT flags);
STDAPI_(void) GetCabState(CABINETSTATE *pcs);

//-------------------------------------------------------------------------

//***   Reg_GetStrs -- read registry strings into struct fields
struct regstrs
{
    LPTSTR  name;   // registry name
    int     off;    // struct offset
};

BOOL    ViewIDFromViewMode(UINT uViewMode, SHELLVIEWID *pvid);
void Reg_GetStrs(HKEY hkey, const struct regstrs *tab, TCHAR *szBuf, int cchBuf, void *pv);

HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState);
HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState, IUnknown *pUnkSite);

#ifdef DEBUG
void    Dbg_DumpMenu(LPCTSTR psz, HMENU hmenu);
#else
#define Dbg_DumpMenu(psz, hmenu)
#endif

extern const LARGE_INTEGER c_li0;
extern BOOL g_fNewNotify;
// FEATURE: Need to handle two different implementations of SHChangeRegister...
typedef ULONG (* PFNSHCHANGENOTIFYREGISTER)(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, SHChangeNotifyEntry *pshcne);
typedef BOOL  (* PFNSHCHANGENOTIFYDEREGISTER)(unsigned long ulID);

ULONG RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive);

int PropBag_ReadInt4(IPropertyBag* pPropBag, LPWSTR pszKey, int iDefault);
HINSTANCE HinstShdocvw();
HINSTANCE HinstShell32();

extern const VARIANT c_vaEmpty;
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)

BOOL ILIsBrowsable(LPCITEMIDLIST pidl, BOOL *pfISFolder);

STDAPI_(LPITEMIDLIST) IEILCreate(UINT cbSize);

BOOL GetInfoTipEx(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax);
BOOL IsBrowsableShellExt(LPCITEMIDLIST pidl);
void OpenFolderPidl(LPCITEMIDLIST pidl);
void OpenFolderPath(LPCTSTR pszPath);
int WINAPI _SHHandleUpdateImage( LPCITEMIDLIST pidlExtra );

extern BOOL g_fICWCheckComplete;
BOOL    CheckSoftwareUpdateUI( HWND hwndOwner, IShellBrowser *pisb );
BOOL    CheckRunICW(LPCTSTR);

#ifdef DEBUG
LPTSTR Dbg_PidlStr(LPCITEMIDLIST pidl, LPTSTR pszBuffer, DWORD cchBufferSize);
#else // DEBUG
#define Dbg_PidlStr(pidl, pszBuffer, cchBufferSize)   ((LPTSTR)NULL)
#endif // DEBUG

HRESULT SavePidlAsLink(IUnknown* punkSite, IStream *pstm, LPCITEMIDLIST pidl);
HRESULT LoadPidlAsLink(IUnknown* punkSite, IStream *pstm, LPITEMIDLIST *ppidl);

#define ADJUST_TO_WCHAR_POS     0
#define ADJUST_TO_TCHAR_POS     1
int AdjustECPosition(char *psz, int iPos, int iType);
BOOL ExecItemFromFolder(HWND hwnd, LPCSTR pszVerb, IShellFolder* psf, LPCITEMIDLIST pidlItem);

// See if a give URL is actually present as an installed entry
STDAPI_(BOOL) CallCoInternetQueryInfo(LPCTSTR pszURL, QUERYOPTION QueryOption);
#define UrlIsInstalledEntry(pszURL) CallCoInternetQueryInfo(pszURL, QUERY_IS_INSTALLEDENTRY)

BOOL IsSubscribableA(LPCSTR pszUrl);
BOOL IsSubscribableW(LPCWSTR pwzUrl);

HRESULT IURLQualifyW(IN LPCWSTR pcwzURL, DWORD dwFlags, OUT LPWSTR pwzTranslatedURL, LPBOOL pbWasSearchURL, LPBOOL pbWasCorrected);

#ifdef UNICODE
#define IsSubscribable IsSubscribableW
#define IURLQualifyT   IURLQualifyW
#else // UNICODE
#define IsSubscribable IsSubscribableA
#define IURLQualifyT   IURLQualifyA
#endif // UNICODE

#define IURLQualifyA   IURLQualify


HDPA    GetSortedIDList(LPITEMIDLIST pidl);
void    FreeSortedIDList(HDPA hdpa);

//#define StopWatch       StopWatchT

int GetColorComponent(LPSTR *ppsz);
COLORREF RegGetColorRefString( HKEY hkey, LPTSTR RegValue, COLORREF Value);
LRESULT SetHyperlinkCursor(IShellFolder* pShellFolder, LPCITEMIDLIST pidl);

HRESULT StrCmpIWithRoot(LPCTSTR szDispNameIn, BOOL fTotalStrCmp, LPTSTR * ppszCachedRoot);
STDAPI UpdateSubscriptions();

enum TRI_STATE
{
    TRI_UNKNOWN = 2,
    TRI_TRUE = TRUE,
    TRI_FALSE = FALSE
};
LONG OpenRegUSKey(LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
HWND GetTrayWindow();

#define STREAMSIZE_UNKNOWN  0xFFFFFFFF
HRESULT SaveStreamHeader(IStream *pstm, DWORD dwSignature, DWORD dwVersion, DWORD dwSize);
HRESULT LoadStreamHeader(IStream *pstm, DWORD dwSignature, DWORD dwStartVersion, DWORD dwEndVersion, DWORD * pdwSize, DWORD * pdwVersionOut);

// _FrameTrack flags
#define TRACKHOT        0x0001
#define TRACKEXPAND     0x0002
#define TRACKNOCHILD    0x0004
void FrameTrack(HDC hdc, LPRECT prc, UINT uFlags);

#ifdef __cplusplus
//+-------------------------------------------------------------------------
// This function scans the document for the given HTML tag and returns the
// result in a collection.
//--------------------------------------------------------------------------
interface IHTMLDocument2;
interface IHTMLElementCollection;
HRESULT GetDocumentTags(IHTMLDocument2* pHTMLDocument, LPOLESTR pszTagName, IHTMLElementCollection** ppTagsCollection);


// CMenuList:  a small class that tracks whether a given hmenu belongs
//             to the frame or the object, so the messages can be
//             dispatched correctly.
class CMenuList
{
public:
    CMenuList(void);
    ~CMenuList(void);

    void Set(HMENU hmenuShared, HMENU hmenuFrame);
    void AddMenu(HMENU hmenu);
    void RemoveMenu(HMENU hmenu);
    BOOL IsObjectMenu(HMENU hmenu);

#ifdef DEBUG
    void Dump(LPCTSTR pszMsg);
#endif

private:
    HDSA    _hdsa;
};


};
#endif


#ifdef __cplusplus
class CAssociationList
{
public:
    //
    // WARNING: We don't want a destructor on this because then it can't
    // be a global object without bringing in the CRT main.  So
    // we can't free the DSA in a destructor.  The DSA memory will be
    // freed by the OS when the process detaches.  If this
    // class is ever dynamically allocated (ie not a static) then
    // we will need to free the DSA.
    //
//    ~CAssociationList();
    BOOL    Add(DWORD dwKey, LPVOID lpData);
    void    Delete(DWORD dwKey);
    HRESULT Find(DWORD dwKey, LPVOID* ppData);

protected:
    int     FindEntry(DWORD dwKey);

    struct ASSOCDATA
    {
            DWORD dwKey;
            LPVOID lpData;
    };

    HDSA    _hdsa;
};

#endif

STDAPI_(void) DrawMenuItem(DRAWITEMSTRUCT* pdi, LPCTSTR lpszMenuText, UINT iIcon);
STDAPI_(LRESULT) MeasureMenuItem(MEASUREITEMSTRUCT *lpmi, LPCTSTR lpszMenuText);

void FireEventSz(LPCTSTR szEvent);
#ifndef UNICODE
void FireEventSzW(LPCWSTR szEvent);
#else
#define FireEventSzW FireEventSz
#endif

// comctl32.dll doesn't really implement Str_SetPtrW.
STDAPI_(BOOL) Str_SetPtrPrivateW(WCHAR * UNALIGNED * ppwzCurrent, LPCWSTR pwzNew);

// This function is similar to Str_SetPtrPrivateW but it is compatible with API's
// that use LocalAlloc for string memory
STDAPI_(BOOL) SetStr(WCHAR * UNALIGNED * ppwzCurrent, LPCWSTR pwzNew);

// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
STDAPI_(void) _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject);
STDAPI_(void) _DragMove(HWND hwndTarget, const POINTL ptStart);

#define Str_SetPtrW         Str_SetPtrPrivateW

STDAPI_(BOOL) _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand);

STDAPI GetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl, DWORD *pdwAttribs);

STDAPI_(BOOL) DoDragDropWithInternetShortcut(IOleCommandTarget *pcmdt, LPITEMIDLIST pidl, HWND hwnd);

STDAPI_(BSTR) SysAllocStringA(LPCSTR);

#ifdef UNICODE
#define SysAllocStringT(psz)    SysAllocString(psz)
#else
#define SysAllocStringT(psz)    SysAllocStringA(psz)
#endif

void EnableOKButton(HWND hDlg, int id, LPTSTR pszText);
BOOL IsExplorerWindow(HWND hwnd);
BOOL IsFolderWindow(HWND hwnd);

STDAPI_(BOOL) WasOpenedAsBrowser(IUnknown *punkSite);

STDAPI_(HWND) GetTopLevelAncestor(HWND hWnd);

STDAPI SHNavigateToFavorite(IShellFolder* psf, LPCITEMIDLIST pidl, IUnknown* punkSite, DWORD dwFlags);
STDAPI SHGetTopBrowserWindow(IUnknown* punk, HWND* phwnd);
STDAPI_(void) UpdateButtonArray(TBBUTTON *ptbDst, const TBBUTTON *ptbSrc, int ctb, LONG_PTR lStrOffset);
STDAPI_(BOOL) DoesAppWantUrl(LPCTSTR pszCmdLine);

STDAPI SHCreateThreadRef(LONG *pcRef, IUnknown **ppunk);
BOOL ILIsFolder(LPCITEMIDLIST pidl);
HRESULT URLToCacheFile(LPCWSTR pszUrl, LPWSTR pszFile, int cchFile);

#ifdef DEBUG
void DebugDumpPidl(DWORD dwDumpFlag, LPTSTR pszOutputString, LPCITEMIDLIST pidl);
#else
#define DebugDumpPidl(p, q, w)
#endif

STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl);
#define ILClone         SafeILClone   

WPARAM AnsiWparamToUnicode(WPARAM wParam);
HMONITOR GetPrimaryMonitor();
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork);
#define GetMonitorRect(hMon, prc) \
        GetMonitorRects((hMon), (prc), FALSE)
#define GetMonitorWorkArea(hMon, prc) \
        GetMonitorRects((hMon), (prc), TRUE)
#define IsMonitorValid(hMon) \
        GetMonitorRects((hMon), NULL, TRUE)
#define GetNumberOfMonitors() \
        GetSystemMetrics(SM_CMONITORS)

void SHOutlineRect(HDC hdc, const RECT* prc, COLORREF cr);



//------------------------------------------------------------------------
typedef struct tagBMPCACHE
{
    HBITMAP hbmp;
    COLORREF cr3D;
} BMPCACHE;


//------------------------------------------------------------------------
//  determine background settings and source for toolbar,
//  load bitmap (file/resource) and update cache
HBITMAP LoadToolbarBackBmp(LPTSTR * ppszBitmap, BMPCACHE * pbmpCache, BOOL fInternet);

UINT MapClsidToID(REFCLSID rclsid);

VOID StripDecorations(PTSTR psz, BOOL fStripAmp);
LPCTSTR UnescapeDoubleAmpersand(LPTSTR pszTitle);

// Create mask from given bitmap, use color at pixel (x/y) as transparent color
HBITMAP CreateMaskBitmap(HDC hdc, int x, int y, HBITMAP hbmpImage);

// draw bitmap transparently; on Win2K and up, one could use MaskBlt()
BOOL DrawTransparentBitmap(HDC hdc, int x, int y, HBITMAP hbmpImage, HBITMAP hbmpMask);
BOOL DrawTransparentBitmapPart(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbmpImage, HBITMAP hbmpMask);
BOOL DrawAlphaBitmap(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbmpImage);


STDAPI_(IDeskBand *) FindBandByClsidBS(IBandSite *pbs, REFCLSID clsid);
HIMAGELIST CreateImageList(HINSTANCE hi, LPCTSTR lpbmp, int cx, int cGrow, COLORREF crMask,
                           UINT uType, UINT uFlags, BOOL bUseNewMirroringSupport);


#ifdef __cplusplus
//------------------------------------------------------------------------
// ref count base class for non-COM classes
class CRefCount
{
public:
                    CRefCount() : _cRef(0) {};
    ULONG           AddRef(void)
                    {
                        return InterlockedIncrement(&_cRef);
                    }

    ULONG           Release(void)
                    {
                        ASSERT(_cRef > 0);
                        long cRef = InterlockedDecrement(&_cRef);

                        if (cRef > 0)
                            return cRef;

                        delete this;
                        return 0;
                    }

protected:
    virtual        ~CRefCount() {};

    long            _cRef;
};


//------------------------------------------------------------------------
// smart pointer for non-COM classes
template <class T>
    class _NoAddRefReleaseOnCRefPtr : public T
{
    private:
        STDMETHOD_(ULONG, AddRef)()=0;
        STDMETHOD_(ULONG, Release)()=0;
};

//------------------------------------------------------------------------
template<class T>
    class CRefPtr
{
public:
    CRefPtr()
    {
        _p = NULL;
    }
    CRefPtr(T* p)
    {
        _p = p;
        if (_p != NULL)
            _p->AddRef();
    }
    CRefPtr(const CRefPtr<T>& p)
    {
        _p = p;
        if (_p != NULL)
            _p->AddRef();
    }
    ~CRefPtr()
    {
        if (_p)
            _p->Release();
    }
    void Release()
    {
        T* pTemp = _p;
        if (pTemp)
        {
            _p = NULL;
            pTemp->Release();
        }
    }
    operator T*() const
    {
        return (T*)_p;
    }
    T& operator*() const
    {
        ASSERT(_p != NULL);
        return *_p;
    }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&()
    {
        ASSERT(_p == NULL);
        return &_p;
    }
    _NoAddRefReleaseOnCRefPtr<T>* operator->() const
    {
        ASSERT(_p != NULL);
        return (_NoAddRefReleaseOnCRefPtr<T>*)_p;
    }
    T* operator=(T* p)
    {
        if (p != NULL)
            p->AddRef();
        if (_p)
            (_p)->Release();
        _p = p;
        return p;
    }
    T* operator=(const CRefPtr<T>& p)
    {
        if (p != NULL)
            p->AddRef();
        if (_p)
            (_p)->Release();
        _p = p;
        return p;
    }
    bool operator!() const
    {
        return (_p == NULL);
    }
    bool operator<(T* pT) const
    {
        return _p < pT;
    }
    bool operator==(T* pT) const
    {
        return _p == pT;
    }
    T* Detach()
    {
        T* pt = _p;
        _p = NULL;  // no release here, hand out live ptr!
        return pt;
    }
private:
    T   *_p;
};

#endif // __cplusplus

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\xbarglyph.h ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      XBarGlyph.h
//
//  Contents:  image of an xBar pane
//
//  Classes:   CXBarGlyph
//
//------------------------------------------------------------------------

#ifndef _XBAR_GLYPH_H_
#define _XBAR_GLYPH_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//------------------------------------------------------------------------
// encapsule the image used by xBar panes,
// can potentially be any format, for now we only support icon format
class CXBarGlyph  :
        public     CRefCount
{
public:
	                    CXBarGlyph();
protected:
	virtual            ~CXBarGlyph();

// operations
public:
    HRESULT             SetIcon(HICON hIcon, BOOL fAlpha);
    HICON               GetIcon(void);
    BOOL                IsAlpha(void)   { return _fAlpha; }
    BOOL                HaveGlyph(void);
    LONG                GetWidth(void);
    LONG                GetHeight(void);
    HRESULT             LoadGlyphFile(LPCTSTR pszPath, BOOL fSmall);
    HRESULT             LoadDefaultGlyph(BOOL fSmall, BOOL fHot);
    HRESULT             Draw(HDC hdc, int x, int y);

private:
    void                _EnsureDimensions(void);

// attributes
protected:
    HBITMAP             _hbmpColor;
    HBITMAP             _hbmpMask;
    BOOL                _fAlpha;
    LONG                _lWidth;
    LONG                _lHeight;

private:
};

#endif // !defined(_XBAR_GLYPH_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\dll\makefile.inc ===
..\browseui.rc : $(CCSHELL_DIR)\lib\$O\brdispp.tlb $(SELFREGNAME) $(BROWSELCR_DEP)

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\util.cpp ===
#include "priv.h"
#include "sccls.h"
#include "mlang.h"  // fo char conversion
#include "bandprxy.h"
#include "resource.h"
#include <shdocvw.h>
#include <icwcfg.h>
#include <advpub.h> // for IE activesetup GUID
#include <shellapi.h>
#include "apithk.h" //for WM_KEYBOARDCUES msg
#include <platform.h>
#include <mobsync.h>
#include <mobsyncp.h>

#include "..\shell32\shitemid.h"    // for SHID_XX

#ifdef UNIX
#include "unixstuff.h"
#endif /* UNIX */

#define MLUI_INIT
#include "mluisupp.h"

//small (previously duplicated) functions shared between shdcovw and browseui
#include "..\inc\brutil.cpp"

// #define MLUI_SUPPORT   1

LCID g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);

#define DM_NAV              TF_SHDNAVIGATE
#define DM_ZONE             TF_SHDNAVIGATE
#define DM_IEDDE            DM_TRACE
#define DM_CANCELMODE       0
#define DM_UIWINDOW         0
#define DM_ENABLEMODELESS   0
#define DM_EXPLORERMENU     0
#define DM_BACKFORWARD      0
#define DM_PROTOCOL         0
#define DM_ITBAR            0
#define DM_STARTUP          0
#define DM_AUTOLIFE         0
#define DM_PALETTE          0

const VARIANT c_vaEmpty = {0};
const LARGE_INTEGER c_li0 = { 0, 0 };

#ifdef DEBUG
const DWORD TempBuffer::s_dummy = 0;
#endif



#undef VariantCopy

WINOLEAUTAPI VariantCopyLazy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc)
{
    VariantClearLazy(pvargDest);

    switch(pvargSrc->vt)
    {
    case VT_I4:
    case VT_UI4:
    case VT_BOOL:
        // we can add more
        *pvargDest = *pvargSrc;
        return S_OK;

    case VT_UNKNOWN:
        if (pvargDest)
        {
            *pvargDest = *pvargSrc;
            pvargDest->punkVal->AddRef();
            return S_OK;
        }
        ASSERT(0);
        return E_INVALIDARG;
    }

    return VariantCopy(pvargDest, pvargSrc);
}

//
// WARNING: This function must be placed at the end because we #undef
// VariantClear
//
#undef VariantClear

HRESULT VariantClearLazy(VARIANTARG *pvarg)
{
    switch(pvarg->vt)
    {
    case VT_I4:
    case VT_UI4:
    case VT_EMPTY:
    case VT_BOOL:
        // No operation
        break;

    default:
        return VariantClear(pvarg);
    }
    return S_OK;
}


HRESULT QueryService_SID_IBandProxy(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj)
{
    HRESULT hr = E_FAIL;

    if (ppbp)
    {
        if (NULL == (*ppbp))
            hr = IUnknown_QueryService(punkParent, SID_IBandProxy, IID_PPV_ARG(IBandProxy, ppbp));

        if (*ppbp && ppvObj)
            hr = (*ppbp)->QueryInterface(riid, ppvObj);        // They already have the object.
    }


    return hr;
}

HRESULT CreateIBandProxyAndSetSite(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj)
{
    ASSERT(ppbp);

    HRESULT hr = CoCreateInstance(CLSID_BandProxy, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandProxy, ppbp));
    if (SUCCEEDED(hr))
    {
        // Set the site
        ASSERT(*ppbp);
        (*ppbp)->SetSite(punkParent);

        if (ppvObj)
            hr = (*ppbp)->QueryInterface(riid, ppvObj);
    }
    else
    {
        if (ppvObj)
            *ppvObj = NULL;
    }
    return hr;
}

HRESULT IUnknown_FileSysChange(IUnknown* punk, DWORD dwEvent, LPCITEMIDLIST* ppidl)
{
    HRESULT hres = E_FAIL;
    if (punk)
    {
        IAddressBand * pab;
        hres = punk->QueryInterface(IID_PPV_ARG(IAddressBand, &pab));
        if (SUCCEEDED(hres))
        {
            hres = pab->FileSysChange(dwEvent, ppidl);
            pab->Release();
        }
    }
    return hres;
}


UINT    g_cfURL = 0;
UINT    g_cfHIDA = 0;
UINT    g_cfFileDescA = 0;
UINT    g_cfFileDescW = 0;
UINT    g_cfFileContents = 0;
UINT    g_cfPreferedEffect = 0;

void InitClipboardFormats()
{
    if (g_cfURL == 0)
    {
        g_cfURL = RegisterClipboardFormat(CFSTR_SHELLURL);
        g_cfHIDA = RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        g_cfFileDescA = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
        g_cfFileDescW = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
        g_cfFileContents = RegisterClipboardFormat(CFSTR_FILECONTENTS);
        g_cfPreferedEffect = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
    }
}

DEFFOLDERSETTINGS g_dfs = INIT_DEFFOLDERSETTINGS;

void _InitDefaultFolderSettings()
{
    if (GetSystemMetrics(SM_CLEANBOOT))
        return;

    g_dfs.vid = g_bRunOnNT5 ? VID_LargeIcons : DFS_VID_Default;

    DEFFOLDERSETTINGS dfs = g_dfs;
    DWORD dwType, cbData = sizeof(dfs);

    if (SUCCEEDED(SKGetValue(SHELLKEY_HKCU_EXPLORER, REGVALUE_STREAMS, TEXT("Settings"), &dwType, &dfs, &cbData)) 
    && dwType == REG_BINARY)
    {
        if (cbData < sizeof(DEFFOLDERSETTINGS_W2K) || dfs.dwStructVersion < DFS_NASH_VER)
        {
            dfs.vid = g_bRunOnNT5 ? VID_LargeIcons : DFS_VID_Default;
            dfs.dwStructVersion = DFS_NASH_VER;
            dfs.bUseVID = TRUE;
        }

        if (cbData < sizeof(DEFFOLDERSETTINGS) || dfs.dwStructVersion < DFS_WHISTLER_VER)
        {
            dfs.dwViewPriority = VIEW_PRIORITY_CACHEMISS;
            dfs.dwStructVersion = DFS_WHISTLER_VER;
        }

        g_dfs = dfs;
    }
}

CABINETSTATE g_CabState = { 0 };
extern HANDLE g_hCabStateChange;
LONG g_lCabStateCount = -1;     // never a valid count

void GetCabState(CABINETSTATE *pcs)
{
    if (g_hCabStateChange == NULL)
        g_hCabStateChange = SHGlobalCounterCreate(GUID_FolderSettingsChange);

    LONG lCabStateCur = SHGlobalCounterGetValue(g_hCabStateChange);
    if (g_lCabStateCount != lCabStateCur)
    {
        g_lCabStateCount = lCabStateCur;
        if (!ReadCabinetState(&g_CabState, sizeof(g_CabState)))
        {
            WriteCabinetState(&g_CabState);
        }
    }
    *pcs = g_CabState;
}

typedef struct tagINIPAIR
{
    DWORD dwFlags;
    LPCTSTR pszSection;
}
INIPAIR, *PINIPAIR;

const INIPAIR c_aIniPairs[] =
{
    EICH_KINET,          TEXT("Software\\Microsoft\\Internet Explorer"),
    EICH_KINETMAIN,      TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
    EICH_KWIN,           TEXT("Software\\Microsoft\\Windows\\CurrentVersion"),
    EICH_KWINEXPLORER,   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
    EICH_KWINEXPLSMICO,  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SmallIcons"),
    EICH_KWINPOLICY,     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"),
    EICH_SSAVETASKBAR,   TEXT("SaveTaskbar"),
    EICH_SWINDOWMETRICS, TEXT("WindowMetrics"),
    EICH_SSHELLMENU,     TEXT("ShellMenu"),
    EICH_SPOLICY,        TEXT("Policy"),
    EICH_SWINDOWS,       TEXT("Windows"),
};

DWORD SHIsExplorerIniChange(WPARAM wParam, LPARAM lParam)
{
    DWORD dwFlags = 0;

    if (lParam == 0)
    {
        if (wParam == 0)
        {
            dwFlags = EICH_UNKNOWN;
        }
    }
    else
    {
        //
        // In the wacky world of browseui, UNICODE-ANSI doesn't vary from
        // window to window.  Instead, on NT browseui registers all windows
        // UNICODE, while on 9x user browseui registers all windows ANSI.
        //
        USES_CONVERSION;
        LPCTSTR pszSection;

        if (g_fRunningOnNT)
            pszSection = W2CT((LPCWSTR)lParam);
        else
            pszSection = A2CT((LPCSTR)lParam);

        for (int i = 0; !dwFlags && i < ARRAYSIZE(c_aIniPairs); i++)
        {
            if (StrCmpI(pszSection, c_aIniPairs[i].pszSection) == 0)
            {
                dwFlags = c_aIniPairs[i].dwFlags;
            }
        }
    }

    return dwFlags;
}

void _InitAppGlobals()
{
    static BOOL fInitialized = FALSE;
    if (!fInitialized)
    {
        _InitComCtl32();
        _InitDefaultFolderSettings();

        // dont put anything else here. instead init on demand

        fInitialized = TRUE;        // allow a race on the above calls
    }
}

BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;
    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS
            | ICC_NATIVEFNTCTL_CLASS;
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}


DWORD GetPreferedDropEffect(IDataObject *pdtobj)
{
    InitClipboardFormats();

    DWORD dwEffect = 0;
    STGMEDIUM medium;
    DWORD *pdw = (DWORD *)DataObj_GetDataOfType(pdtobj, g_cfPreferedEffect, &medium);
    if (pdw)
    {
        dwEffect = *pdw;
        ReleaseStgMediumHGLOBAL(pdw,&medium);
    }
    return dwEffect;
}

HRESULT _SetPreferedDropEffect(IDataObject *pdtobj, DWORD dwEffect)
{
    InitClipboardFormats();

    HRESULT hres = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(*pdw));
    if (pdw)
    {
        STGMEDIUM medium;
        FORMATETC fmte = {g_cfPreferedEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        *pdw = dwEffect;

        medium.tymed = TYMED_HGLOBAL;
        medium.hGlobal = pdw;
        medium.pUnkForRelease = NULL;

        hres = pdtobj->SetData(&fmte, &medium, TRUE);

        if (FAILED(hres))
            GlobalFree((HGLOBAL)pdw);
    }
    return hres;
}

//***   Reg_GetStrs -- get values from registry, assign to struct
void Reg_GetStrs(HKEY hkey, const struct regstrs *tab, LPTSTR szBuf, int cchBuf, void *pv)
{
    for (; tab->name != NULL; tab++)
    {
        ULONG cbTmp = cchBuf;

        // NOTE: IE4 did *NOT* support SHLoadRegUIString, so don't call Reg_GetStrs
        // on roamable data.  (Or at least don't register plugui strings there.)
        if (ERROR_SUCCESS == SHLoadRegUIString(hkey, tab->name, szBuf, cbTmp))
        {
            // pv->field = StrDup(szBuf)
            *(LPTSTR *)((char *)pv + tab->off) = StrDup(szBuf);
        }
    }
    return;
}

BOOL g_fNewNotify = FALSE;   // Are we using classic mode (W95 or new mode?
PFNSHCHANGENOTIFYREGISTER    g_pfnSHChangeNotifyRegister = NULL;
PFNSHCHANGENOTIFYDEREGISTER  g_pfnSHChangeNotifyDeregister = NULL;

#define GET_PRIVATE_PROC_ADDRESS(_hinst, _fname, _ord) GetProcAddress(_hinst, _ord)

BOOL _DelayLoadRegisterNotify(void)
{
    // See if we need to still figure out which version of SHChange Notify to call?
    if  (g_pfnSHChangeNotifyDeregister == NULL)
    {
        // This should never fail, since we are load-time-linked to SHELL32
        HMODULE hmodShell32 = GetModuleHandleA("SHELL32.DLL");
        if (hmodShell32)
        {
            g_pfnSHChangeNotifyRegister = (PFNSHCHANGENOTIFYREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32, "NTSHChangeNotifyRegister",MAKEINTRESOURCEA(640));
            if (g_pfnSHChangeNotifyRegister && (WhichPlatform() == PLATFORM_INTEGRATED))
            {
                g_pfnSHChangeNotifyDeregister = (PFNSHCHANGENOTIFYDEREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32,"NTSHChangeNotifyDeregister", MAKEINTRESOURCEA(641));
                g_fNewNotify = TRUE;
            }
            else
            {
                g_pfnSHChangeNotifyRegister = (PFNSHCHANGENOTIFYREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32, "SHChangeNotifyRegister", MAKEINTRESOURCEA(2));
                g_pfnSHChangeNotifyDeregister = (PFNSHCHANGENOTIFYDEREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32, "SHChangeNotifyDeregister",MAKEINTRESOURCEA(4));
            }
        }
    }
    return (NULL == g_pfnSHChangeNotifyDeregister) ? FALSE : TRUE;
}

ULONG RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive)
{
    if (_DelayLoadRegisterNotify())
    {
        SHChangeNotifyEntry fsne;

        if (g_fNewNotify)
            uFlags |= SHCNRF_NewDelivery;

        fsne.fRecursive = fRecursive;
        fsne.pidl = pidl;
        return g_pfnSHChangeNotifyRegister(hwnd, uFlags, dwEvents, nMsg, 1, &fsne);
    }
    return 0;
}

int PropBag_ReadInt4(IPropertyBag* pPropBag, LPWSTR pszKey, int iDefault)
{
    SHPropertyBag_ReadInt(pPropBag, pszKey, &iDefault);
    return iDefault;
}


STDAPI_(BOOL) _EnsureLoaded(HINSTANCE *phinst, LPCSTR pszDLL)
{
    if (*phinst == NULL)
    {
#ifdef DEBUG
        if (g_dwDumpFlags & DF_DELAYLOADDLL)
        {
            TraceMsg(TF_ALWAYS, "DLLLOAD: Loading %s for the first time", pszDLL);
        }

        if (g_dwBreakFlags & 0x00000080)
        {
            DebugBreak();
        }
#endif
        *phinst = LoadLibraryA(pszDLL);
        if (*phinst == NULL)
        {
            return FALSE;
        }
    }
    return TRUE;
}


// global g_hinst values 
HINSTANCE g_hinstSHDOCVW = NULL;
HINSTANCE g_hinstShell32 = NULL;

HINSTANCE HinstShdocvw()
{
    _EnsureLoaded(&g_hinstSHDOCVW, "shdocvw.dll");
    return g_hinstSHDOCVW;
}

HINSTANCE HinstShell32()
{
    _EnsureLoaded(&g_hinstShell32, "shell32.dll");
    return g_hinstShell32;
}

STDAPI_(BOOL) CallCoInternetQueryInfo(LPCTSTR pszURL, QUERYOPTION QueryOption)
{
    DWORD fRetVal;
    DWORD dwSize;
    WCHAR wszURL[MAX_URL_STRING];

    SHTCharToUnicode(pszURL, wszURL, ARRAYSIZE(wszURL));
    return SUCCEEDED(CoInternetQueryInfo(
                        wszURL, QueryOption,
                        0, &fRetVal, sizeof(fRetVal), &dwSize, 0)) && fRetVal;
}


HRESULT IURLQualifyW(IN LPCWSTR pcwzURL, DWORD dwFlags, OUT LPWSTR pwzTranslatedURL, LPBOOL pbWasSearchURL, LPBOOL pbWasCorrected)
{
    return IURLQualify(pcwzURL, dwFlags, pwzTranslatedURL, pbWasSearchURL, pbWasCorrected);
}

BSTR LoadBSTR(HINSTANCE hinst, UINT uID)
{
    WCHAR wszBuf[128];
    if (LoadStringW(hinst, uID, wszBuf, ARRAYSIZE(wszBuf)))
    {
        return SysAllocString(wszBuf);
    }
    return NULL;
}

HRESULT _SetStdLocation(LPTSTR szPath, UINT id)
{
    HRESULT hres = E_FAIL;
    WCHAR szDefaultPath[MAX_URL_STRING];

    ASSERT(id == DVIDM_GOHOME);
    if (SUCCEEDED(URLSubLoadString(MLGetHinst(), IDS_DEF_HOME, szDefaultPath, SIZECHARS(szDefaultPath), URLSUB_ALL)))
    {
        if (!StrCmp(szDefaultPath, szPath))
            return S_OK;  // We don't need to write out the name string.
    }

    DWORD cbSize = (lstrlen(szPath) + 1) * sizeof(TCHAR);
    if (ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Main"), (id==DVIDM_GOHOME) ? TEXT("Start Page") : TEXT("Search Page"),
                REG_SZ, (LPBYTE)szPath, cbSize))
    {
        hres = S_OK;
    }

    return hres;
}

//***   IsVK_TABCycler -- is key a TAB-equivalent
// ENTRY/EXIT
//  dir     0 if not a TAB, non-0 if a TAB
// NOTES
//  NYI: -1 for shift+tab, 1 for tab
//
int IsVK_TABCycler(MSG *pMsg)
{
    int nDir = 0;

    if (!pMsg)
        return nDir;

    if (pMsg->message != WM_KEYDOWN)
        return nDir;
    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        return nDir;

    nDir = (GetKeyState(VK_SHIFT) < 0) ? -1 : 1;

#ifdef KEYBOARDCUES
    HWND hwndParent = GetParent(pMsg->hwnd);

    if (hwndParent)
        SendMessage(hwndParent, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0);
#endif
    return nDir ;
}

BOOL IsVK_CtlTABCycler(MSG *pMsg)
{
    if (IsVK_TABCycler(pMsg))
    {
        if (GetKeyState(VK_CONTROL) < 0 || (pMsg->wParam == VK_F6))
            return TRUE;
    }

    return FALSE;
}

const ITEMIDLIST s_idlNULL = { 0 } ;

// Copied from shell32 (was _ILCreate), which does not export this.
// The fsmenu code needs this function.
STDAPI_(LPITEMIDLIST) IEILCreate(UINT cbSize)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST)SHAlloc(cbSize);
    if (pidl)
        memset(pidl, 0, cbSize);      // needed for external task allicator

    return pidl;
}

void SaveDefaultFolderSettings(UINT flags)
{
    ASSERT(!(flags & ~GFSS_VALID));

    if (flags & GFSS_SETASDEFAULT)
        g_dfs.dwDefRevCount++;

    SKSetValue(SHELLKEY_HKCU_EXPLORER, REGVALUE_STREAMS, TEXT("Settings"), REG_BINARY, &g_dfs, sizeof(g_dfs));
}

BOOL ViewIDFromViewMode(UINT uViewMode, SHELLVIEWID *pvid)
{
    switch (uViewMode)
    {
    case FVM_ICON:
        *pvid = VID_LargeIcons;
        break;

    case FVM_SMALLICON:
        *pvid = VID_SmallIcons;
        break;

    case FVM_LIST:
        *pvid = VID_List;
        break;

    case FVM_DETAILS:
        *pvid = VID_Details;
        break;

    case FVM_THUMBNAIL:
        *pvid = VID_Thumbnails;
        break;

    case FVM_TILE:
        *pvid = VID_Tile;
        break;

    default:
        *pvid = VID_LargeIcons;
        return(FALSE);
    }

    return(TRUE);
}

// This is a hack for IE6 23652 Beta 2. Remove in Whistler RC 1.
BOOL CheckForOutlookExpress()
{
    HKEY hKeyMail   = NULL;
    HKEY hKeyOE     = NULL;
    DWORD dwErr     = 0;
    DWORD dwSize    = 0;
    TCHAR szBuf[MAX_PATH];
    DWORD dwType    = 0;
    BOOL bRet = FALSE;

    // Open the key for default internet mail client
    // HKLM\Software\Clients\Mail

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Clients\\Mail"), 0, KEY_READ, &hKeyMail);
    if(dwErr != ERROR_SUCCESS)
    {
        // DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        goto out;
    }

    dwSize = ARRAYSIZE(szBuf);         // Expect ERROR_MORE_DATA
    dwErr = RegQueryValueEx(    hKeyMail, NULL, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if(dwErr != ERROR_SUCCESS)
    {
        goto out;
    }

    if(!lstrcmpi(szBuf, TEXT("Outlook Express")))
    {
        // Yes its outlook express ..
        bRet = TRUE;
    }

out:
    if(hKeyOE)
        RegCloseKey(hKeyOE);
    if(hKeyMail)
        RegCloseKey(hKeyMail);
    return bRet;
}


HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState)
{
    IDropTarget *pdrop;
    HRESULT hres = CoCreateInstance(CLSID_MailRecipient,
        NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_PPV_ARG(IDropTarget, &pdrop));

    ULONG_PTR uCookie = 0;
    if (CheckForOutlookExpress())
    {
        SHActivateContext(&uCookie);
    }
    if (SUCCEEDED(hres))
    {
        hres = SHSimulateDrop(pdrop, pdtobj, grfKeyState, NULL, NULL);
        pdrop->Release();
    }
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    return hres;
}



//
// This function cannot return Non -NULL pointers if
// it returns a FAILED(hr)
//

HRESULT CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(
    LPCITEMIDLIST pidl,
    IUnknown *pUnkSite,
    IUniformResourceLocator **ppUrlOut,
    IDataObject **ppdtobj
)
{
    HRESULT hr;
    TCHAR szUrl[MAX_URL_STRING];


    ASSERT(ppUrlOut);
    ASSERT(ppdtobj);
    *ppUrlOut = NULL;
    *ppdtobj = NULL;
    szUrl[0] = TEXT('\0');

    hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szUrl, SIZECHARS(szUrl), NULL);

    if ((S_OK == hr) && (*szUrl))
    {

       BOOL fIsHTML = FALSE;
       BOOL fHitsNet = UrlHitsNetW(szUrl);

       if (!fHitsNet)
       {
            if (URL_SCHEME_FILE == GetUrlScheme(szUrl))
            {
                TCHAR *szExt = PathFindExtension(szUrl);
                if (szExt)
                {
                    fIsHTML = ((0 == StrCmpNI(szExt, TEXT(".htm"),4)) ||
                              (0 == StrCmpNI(szExt, TEXT(".html"),5)));
                }
            }
       }

       if (fHitsNet || fIsHTML)
       {
            // Create a shortcut object and
            HRESULT hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                            IID_PPV_ARG(IUniformResourceLocator, ppUrlOut));
            if (SUCCEEDED(hr))
            {

                hr = (*ppUrlOut)->SetURL(szUrl, 0);
                if (S_OK == hr)
                {

                    // Get the IDataObject and send that back for the Drag Drop
                    hr = (*ppUrlOut)->QueryInterface(IID_PPV_ARG(IDataObject, ppdtobj));
                    if (SUCCEEDED(hr))
                    {
                        IUnknown_SetSite(*ppUrlOut, pUnkSite); // Only set the site if we're sure of
                                                          // returning SUCCESS
                    }
                }
           }
       }
       else
       {
            hr = E_FAIL;
       }
    }

    if (FAILED(hr))
    {
        SAFERELEASE(*ppUrlOut);
        SAFERELEASE(*ppdtobj);
    }
    return hr;
}

HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState, IUnknown *pUnkSite)
{
    IDataObject *pdtobj = NULL;
    IUniformResourceLocator *purl = NULL;
    HRESULT hr = CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(pidl, pUnkSite, &purl, &pdtobj);
    if (FAILED(hr))
    {
        ASSERT(NULL == pdtobj);
        ASSERT(NULL == purl);
        hr = GetDataObjectForPidl(pidl, &pdtobj);
    }

    if (SUCCEEDED(hr))
    {
        IQueryCodePage * pQcp;
        if (SUCCEEDED(pdtobj->QueryInterface(IID_PPV_ARG(IQueryCodePage, &pQcp))))
        {
            pQcp->SetCodePage(uiCodePage);
            pQcp->Release();
        }
        hr = DropOnMailRecipient(pdtobj, grfKeyState);
        pdtobj->Release();
    }

    if (purl)
    {
        IUnknown_SetSite(purl, NULL);
        purl->Release();
    }
    return hr;
}

#ifdef DEBUG
/****************************************************\
    FUNCTION: Dbg_PidlStr

    DESCRIPTION:
        Create a display name for the pidl passed in
    and store the display name in pszBuffer.
\****************************************************/
LPTSTR Dbg_PidlStr(LPCITEMIDLIST pidl, LPTSTR pszBuffer, DWORD cchBufferSize)
{
    if (pidl)
    {
        if (ILIsRooted(pidl))
            StrCpyN(pszBuffer, TEXT("<ROOTED>"), cchBufferSize);
        else
        {
            IEGetNameAndFlags(pidl, SHGDN_FORPARSING, pszBuffer, cchBufferSize, NULL);
        }
    }
    else
        StrCpyN(pszBuffer, TEXT("<NULL>"), cchBufferSize);

    return pszBuffer;
}
#endif // DEBUG


#ifdef DEBUG
#define MAX_DEPTH 8

void Dbg_RecursiveDumpMenu(HMENU hmenu, int iDepth)
{
    if (!hmenu || iDepth > MAX_DEPTH)
        return;

    TCHAR szTabs[MAX_DEPTH + 1];
    for (int i = 0; i < iDepth; i++)
    {
        szTabs[i] = '\t';
    }
    szTabs[iDepth] = '\0';

    int cItems = GetMenuItemCount(hmenu);
    for (i = 0; i < cItems; i++)
    {
        MENUITEMINFO mii;
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_SUBMENU | MIIM_TYPE;

        TCHAR szTmp[64];
        mii.dwTypeData = szTmp;
        mii.cch = ARRAYSIZE(szTmp);

        if (GetMenuItemInfoWrap(hmenu, i, TRUE, &mii))
        {
            LPTSTR pszType;
            if (mii.fType == MFT_STRING && mii.dwTypeData)
                pszType = mii.dwTypeData;
            else
                pszType = TEXT("");

            TraceMsg(TF_ALWAYS, "%swID %x\tfType %x\t%s", szTabs, mii.wID, mii.fType, pszType);

            if (mii.hSubMenu)
            {
                Dbg_RecursiveDumpMenu(mii.hSubMenu, iDepth + 1);
            }
        }
    }
}

// FUNCTION: Dbg_DumpMenu
//
// walk hmenu & dump every item
void Dbg_DumpMenu(LPCTSTR psz, HMENU hmenu)
{
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGMENU))
    {
        TraceMsg(TF_ALWAYS, "Dumping hmenu %x (%s)", hmenu, psz);
        Dbg_RecursiveDumpMenu(hmenu, 0);
        TraceMsg(TF_ALWAYS, "End hmenu dump");
    }
}
#endif


// evil evil evil. for browse only mode support. not the right way to do things
STDAPI LookForDesktopIniText(IShellFolder *psf, LPCITEMIDLIST pidl, LPCTSTR pszKey, LPTSTR pszBuffer, DWORD cbSize);

#define CLSID_SIZE 40

HRESULT LoadHandler(const CLSID * pCLSID, LPCWSTR pszBuffer, REFIID riid, void **ppvObj)
{
    ASSERT(pszBuffer);
    CLSID clsid;

    if (!pCLSID)
    {
        // find the extension first ....
        // REARCHITECT - Shouldn't this be PathFindExtension?
        // Otherwise we will get confused by "foo.bar\baz"
        LPCWSTR pszDot = StrRChrW(pszBuffer, NULL, WCHAR('.'));
        if (!pszDot)
        {
            return E_NOINTERFACE;
        }

        HKEY hKey;
        USES_CONVERSION;
        LONG lRes = RegOpenKey(HKEY_CLASSES_ROOT, W2CT(pszDot), &hKey);
        if (lRes != ERROR_SUCCESS)
        {
            return E_NOINTERFACE;
        }

        TCHAR szSubKey[CLSID_SIZE + 10];
        StrCpy(szSubKey, TEXT("shellex\\"));
        SHStringFromGUID(riid, szSubKey + 8, CLSID_SIZE);

        TCHAR szCLSID[CLSID_SIZE];

        DWORD cbSize = sizeof(szCLSID);
        DWORD dwType;

        // should we test for a value as well as a key ?
        lRes = SHGetValue(hKey, szSubKey, TEXT(""), &dwType, szCLSID, &cbSize);
        RegCloseKey(hKey);

        if (lRes != ERROR_SUCCESS || dwType != REG_SZ)
        {
            return E_NOINTERFACE;
        }

        if (!GUIDFromString(szCLSID, &clsid))
        {
            return E_NOINTERFACE;
        }
        pCLSID = &clsid;
    }

    ASSERT(pCLSID);

    IPersistFile *pFile;
    HRESULT hr = CoCreateInstance(*pCLSID, NULL, CLSCTX_INPROC_SERVER,
                                   IID_PPV_ARG(IPersistFile, &pFile));
    if (FAILED(hr))
    {
        return E_NOINTERFACE;
    }

    *ppvObj = NULL;

    hr = pFile->Load(pszBuffer, TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pFile->QueryInterface(riid, ppvObj);
    }

    ATOMICRELEASE(pFile);

    return hr;
}

// routine used to make us think it really came from the right place....
HRESULT FakeGetUIObjectOf(IShellFolder *psf, LPCITEMIDLIST pidl, UINT * prgfFlags, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        // we are on Nashville try the new mechanism first...
        hr = psf->GetUIObjectOf(NULL, 1, & pidl, riid, NULL, ppvObj);
        if (SUCCEEDED(hr))
        {
            return hr;
        }
    }

    // failure cases...
    if (riid == IID_IExtractImage || riid == IID_IExtractLogo || riid == IID_IQueryInfo)
    {
        // make sure this hacked up code is only executed for browser only release....
        // otherwise people will not register their stuff right and what a mess that will be.....
        if (WhichPlatform() == PLATFORM_INTEGRATED)
        {
            return hr;
        }

        // try the IconExtractor first ....
        IExtractIconA *pIcon;
        hr = psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IExtractIconA, NULL, &pIcon));
        if (SUCCEEDED(hr))
        {
            if (riid != IID_IQueryInfo)
            {
                hr = pIcon->QueryInterface(IID_IExtractLogo, ppvObj);
                ATOMICRELEASE(pIcon);

                if (SUCCEEDED(hr))
                    return NOERROR;
            }
            else
            {
                hr = pIcon->QueryInterface(IID_IQueryInfo, ppvObj);
                ATOMICRELEASE(pIcon);

                //if someone is asking for an IQueryInfo, don't try giving them an IExtractImage
                return hr;
            }
        }

        // browser mode only hack so we can detect if we are asking for the normal logo or the wide one...
        LPCTSTR pszTag = TEXT("Logo");
        if (prgfFlags != NULL && *prgfFlags)
        {
            pszTag = TEXT("WideLogo");
        }

        TCHAR szBuffer[MAX_PATH];
        hr = LookForDesktopIniText(psf, pidl, pszTag, szBuffer, ARRAYSIZE(szBuffer));
        if (SUCCEEDED(hr))
        {
            // use IID_IExtractImage, this is the same interface as IExtractLogo, just IExtractLogo
            // allows us to restrict the things that show up in Logo View...
            USES_CONVERSION;

            hr = LoadHandler(NULL, T2W(szBuffer), IID_IExtractImage, ppvObj);
        }
    }

    return hr;
}

BOOL GetInfoTipEx(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax)
{
    BOOL fRet = FALSE;

    *pszText = 0;   // empty for failure

    if (pidl)
    {
        IQueryInfo *pqi;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IQueryInfo, NULL, &pqi))))
        {
            WCHAR *pwszTip;
            pqi->GetInfoTip(dwFlags, &pwszTip);
            if (pwszTip)
            {
                fRet = TRUE;
                SHUnicodeToTChar(pwszTip, pszText, cchTextMax);
                SHFree(pwszTip);
            }
            pqi->Release();
        }
        else if (SUCCEEDED(FakeGetUIObjectOf(psf, pidl, 0, IID_PPV_ARG(IQueryInfo, &pqi))))
        {
            WCHAR *pwszTip;
            pqi->GetInfoTip(0, &pwszTip);
            if (pwszTip)
            {
                fRet = TRUE;
                SHUnicodeToTChar(pwszTip, pszText, cchTextMax);
                SHFree(pwszTip);
            }
            pqi->Release();
        }
    }
    return fRet;
}

BOOL GetInfoTip(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax)
{
    return GetInfoTipEx(psf, 0, pidl, pszText, cchTextMax);
}


#define MAX_CLASS   80  // From ..\shell32\fstreex.c
BOOL IsBrowsableShellExt(LPCITEMIDLIST pidl)
{
    DWORD    cb;
    LPCTSTR pszExt;
    TCHAR   szFile[MAX_PATH];
    TCHAR   szProgID[MAX_CLASS];
    TCHAR   szCLSID[GUIDSTR_MAX], szCATID[GUIDSTR_MAX];
    TCHAR   szKey[GUIDSTR_MAX * 4];
    HKEY    hkeyProgID = NULL;
    BOOL    fRet = FALSE;

    for (;;)
    {
        // Make sure we have a file extension
        if  (
            !SHGetPathFromIDList(pidl, szFile)
            ||
            ((pszExt = PathFindExtension(szFile)) == NULL)
            ||
            (pszExt[0] != TEXT('.'))
           )
        {
            break;
        }

        // Get the ProgID.
        cb = sizeof(szProgID);
        if  (
            (SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szProgID, &cb) != ERROR_SUCCESS)
            ||
            (RegOpenKey(HKEY_CLASSES_ROOT, szProgID, &hkeyProgID) != ERROR_SUCCESS)
           )
        {
            break;
        }

        // From the ProgID, get the CLSID.
        cb = sizeof(szCLSID);
        if (SHGetValue(hkeyProgID, TEXT("CLSID"), NULL, NULL, szCLSID, &cb) != ERROR_SUCCESS)
            break;

        // Construct the registry key that detects if
        // a CLSID is a member of a CATID.
        SHStringFromGUID(CATID_BrowsableShellExt, szCATID, ARRAYSIZE(szCATID));
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("CLSID\\%s\\Implemented Categories\\%s"),
                 szCLSID, szCATID);

        // See if it's there.
        cb = 0;
        if (SHGetValue(HKEY_CLASSES_ROOT, szKey, NULL, NULL, NULL, &cb) != ERROR_SUCCESS)
            break;

        fRet = TRUE;
        break;
    }

    if (hkeyProgID != NULL)
        RegCloseKey(hkeyProgID);

    return fRet;
}


void OpenFolderPidl(LPCITEMIDLIST pidl)
{
    SHELLEXECUTEINFO shei = { 0 };

    shei.cbSize     = sizeof(shei);
    shei.fMask      = SEE_MASK_INVOKEIDLIST;
    shei.nShow      = SW_SHOWNORMAL;
    shei.lpIDList   = (LPITEMIDLIST)pidl;
    ShellExecuteEx(&shei);
}

void OpenFolderPath(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl = ILCreateFromPath(pszPath);
    if (pidl)
    {
        OpenFolderPidl(pidl);
        ILFree(pidl);
    }
}

// NOTE: this is only called from browseui, why is it in the lib directory?
STDAPI UpdateSubscriptions()
{
#ifndef DISABLE_SUBSCRIPTIONS

    HRESULT hr;

    if (!SHRestricted2W(REST_NoManualUpdates, NULL, 0))
    {
        ISyncMgrSynchronizeInvoke *pSyncMgrInvoke;
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_PPV_ARG(ISyncMgrSynchronizeInvoke, &pSyncMgrInvoke));

        if (SUCCEEDED(hr))
        {
            hr = pSyncMgrInvoke->UpdateAll();
            pSyncMgrInvoke->Release();
        }
    }
    else
    {
        SHRestrictedMessageBox(NULL);
        hr = S_FALSE;
    }
    
    return hr;

#else  /* !DISABLE_SUBSCRIPTIONS */

    return E_FAIL;

#endif /* !DISABLE_SUBSCRIPTIONS */
}


STDAPI_(int) _SHHandleUpdateImage(LPCITEMIDLIST pidlExtra)
{
    SHChangeUpdateImageIDList * pUs = (SHChangeUpdateImageIDList*) pidlExtra;

    if (!pUs)
    {
        return -1;
    }

    // if in the same process, or an old style notification
    if (pUs->dwProcessID == GetCurrentProcessId())
    {
        return (int) pUs->iCurIndex;
    }
    else
    {
        WCHAR szBuffer[MAX_PATH];
        int iIconIndex = *(int UNALIGNED *)((BYTE *)&pUs->iIconIndex);
        UINT uFlags = *(UINT UNALIGNED *)((BYTE *)&pUs->uFlags);

        ualstrcpyW(szBuffer, pUs->szName);

        // we are in a different process, look up the hash in our index to get the right one...

        return Shell_GetCachedImageIndex(szBuffer, iIconIndex, uFlags);
    }
}

// As perf, share IShellLink implementations between bands and ask
// the bandsite for an implementation. Don't rely on the bandsite
// because you never know who will host us in the future. (And bandsite
// can change to not have us hosted at save/load time. Ex: it doesn't
// set our site before loading us from the stream, which sounds buggy.)
//
HRESULT SavePidlAsLink(IUnknown* punkSite, IStream *pstm, LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;
    IShellLinkA* psl;

    if (punkSite)
        hr = IUnknown_QueryService(punkSite, IID_IBandSite, IID_PPV_ARG(IShellLinkA, &psl));
    if (FAILED(hr))
        hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &psl));
    if (SUCCEEDED(hr))
    {
        IPersistStream *pps;
        hr = psl->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
        if (EVAL(SUCCEEDED(hr)))
        {
            ASSERT(pidl);
            psl->SetIDList(pidl);

            hr = pps->Save(pstm, FALSE);

            // Win95 and NT4 shell32 have a bug in the CShellLink implementation
            // THEY DON'T NULL TERMINATE THEIR "EXTRA DATA SECTION". This causes
            // the object to trash the rest of the stream when it reads back in.
            // Fix this by writing the NULL out in the Browser Only case.
            if (SUCCEEDED(hr) && (PLATFORM_BROWSERONLY == WhichPlatform()))
            {
                DWORD dw = 0;
                pstm->Write(&dw, sizeof(dw), NULL);
            }

            pps->Release();
        }
        psl->Release();
    }
    return hr;
}

HRESULT LoadPidlAsLink(IUnknown* punkSite, IStream *pstm, LPITEMIDLIST *ppidl)
{
    IShellLinkA* psl;
    HRESULT hr = IUnknown_QueryService(punkSite, IID_IBandSite, IID_PPV_ARG(IShellLinkA, &psl));
    if (FAILED(hr))
        hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &psl));
    if (SUCCEEDED(hr))
    {
        IPersistStream *pps;
        hr = psl->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = pps->Load(pstm);
            if (EVAL(SUCCEEDED(hr)))
            {
                hr = psl->GetIDList(ppidl);

                // Don't make me resolve the link because it's soo slow because
                // it often loads 80k of networking dlls.
                if (!EVAL(SUCCEEDED(hr)))
                {
                    hr = psl->Resolve(NULL, SLR_NOUPDATE | SLR_NO_UI);
                    if (EVAL(SUCCEEDED(hr)))
                        hr = psl->GetIDList(ppidl);
                }

                hr = *ppidl ? S_OK : E_FAIL;
            }
            pps->Release();
        }
        psl->Release();
    }
    return hr;
}



// AdjustECPosition
//
// purpose: because FE NT always uses WCHAR position for ComboBoxEx32
//          even though we're ANSI module for EM_GETSEL/EM_SETSEL,
//          we need to adjust between WCHAR and TCHAR position.
// iType:   ADJUST_TO_WCHAR_POS or ADJUST_TO_TCHAR_POS
//
int AdjustECPosition(char *psz, int iPos, int iType)
{
    char *pstr = psz;
    int iNewPos = iPos;

    if (psz && g_fRunOnFE && g_fRunningOnNT)
    {
        if (ADJUST_TO_WCHAR_POS == iType)
        {
            iNewPos = 0;
            while (*pstr && (pstr - psz != iPos))
            {
                pstr = CharNextA(pstr);
                iNewPos++;
            }
        }
        else if (ADJUST_TO_TCHAR_POS == iType)
        {
            while (*pstr && iPos--)
                pstr = CharNextA(pstr);
            iNewPos = (int)(pstr - psz);
        }
    }
    return iNewPos;
}

int CALLBACK _CompareIDs(LPARAM p1, LPARAM p2, LPARAM psf)
{
    HRESULT hr = ((IShellFolder*)psf)->CompareIDs(0, (LPITEMIDLIST)p1, (LPITEMIDLIST)p2);

    //ASSERT(SUCCEEDED(hr))
    return (short)HRESULT_CODE(hr);
}
HDPA GetSortedIDList(LPITEMIDLIST pidl)
{
    HDPA hdpa = DPA_Create(4);
    if (hdpa)
    {
        IShellFolder* psf;
        if (SUCCEEDED(IEBindToObject(pidl, &psf)))
        {
            LPENUMIDLIST penum;
            SHELLSTATE ss = {0};

            SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);

            if (S_OK == IShellFolder_EnumObjects(psf, NULL,
                ss.fShowAllObjects ? SHCONTF_FOLDERS | SHCONTF_INCLUDEHIDDEN : SHCONTF_FOLDERS,
                &penum))
            {
                LPITEMIDLIST pidl;
                ULONG celt;
                while (penum->Next(1, &pidl, &celt) == S_OK && celt == 1)
                {
                    if (DPA_AppendPtr(hdpa, pidl) == -1)
                    {
                        SHFree(pidl);
                    }
                }
                penum->Release();
            }
            DPA_Sort(hdpa, (PFNDPACOMPARE)_CompareIDs, (LPARAM)psf);
            psf->Release();
        }
    }

    return hdpa;
}

int DPA_SHFreeCallback(void * p, void * d)
{
    SHFree((LPITEMIDLIST)p);
    return 1;
}

void FreeSortedIDList(HDPA hdpa)
{
    DPA_DestroyCallback(hdpa, (PFNDPAENUMCALLBACK)DPA_SHFreeCallback, 0);
    hdpa = NULL;
}

/****************************************************\
    FUNCTION: StrCmpIWithRoot

    PARAMETERS:
        szDispNameIn - Str to see if it is the same as the
                Display Name of the Root ISF.
        fTotalStrCmp - If TRUE, pszDispNameIn has to completely equal the
                Root's Display Name to succeed.  If FALSE, only the first part
                of pszDispNameIn needs to compare to the Root's Display Name
                for this function to return successful.
        ppszCachedRoot (In/Out Optional) - If this function will be called more than
                once, this function will cache the string and make it run
                quicker. The first time this function is called, (*ppszCachedRoot)
                needs to be NULL.  This function will allocate and the caller
                needs to call LocalFree() when it's no longer needed.

    DESCRIPTION:
        This function will get the Display Name of the Root ISF (Desktop) and
    see if the first cchDispNameComp chars of szDispNameIn
    match that display name.  S_OK will be returned if TRUE, and
    S_FALSE if not.
\****************************************************/
HRESULT StrCmpIWithRoot(LPCTSTR pszDispNameIn, BOOL fTotalStrCmp, LPTSTR * ppszCachedRoot)
{
    HRESULT hr;
    TCHAR szDispNameTemp[MAX_PATH];
    LPTSTR pszDispName = szDispNameTemp;

    ASSERT(IS_VALID_STRING_PTR(pszDispNameIn, -1));
    ASSERT(NULL == ppszCachedRoot || IS_VALID_WRITE_PTR(ppszCachedRoot, LPTSTR));

    // Did the caller supply the display name of the namespace root?
    if ((!ppszCachedRoot) ||
        (ppszCachedRoot && !*ppszCachedRoot))
    {
        MLLoadString(IDS_DESKTOP, szDispNameTemp, SIZECHARS(szDispNameTemp));

        // Cache this guy?
        if (ppszCachedRoot)
        {
            // Yes
            *ppszCachedRoot = StrDup(szDispNameTemp);
            if (!*ppszCachedRoot)
                return E_OUTOFMEMORY;
        }
    }

    if (ppszCachedRoot && *ppszCachedRoot)
        pszDispName = *ppszCachedRoot;

    // Do we want to compare the entire string or just the first part of it?
    if (fTotalStrCmp)
        hr = (0 == lstrcmpi(pszDispName, pszDispNameIn)) ? S_OK : S_FALSE;   // Entire String
    else if (ppszCachedRoot)
    {
        // Compare the first part of the string
        DWORD cchDispNameComp = lstrlen(*ppszCachedRoot);
        hr = (0 == StrCmpNI(pszDispName, pszDispNameIn, cchDispNameComp)) ? S_OK : S_FALSE;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

/****************************************************\
    FUNCTION: GetMRUEntry

    PARAMETERS:
        hKey - Pointer to Registry Key to retrieve MRU entries from.
        dwMRUIndex - 0 based MRU Index to retrieve.
        pszMRUEntry - Location to store MRU Entry string.
        cchMRUEntry - Size of Buffer in characters.

    DESCRIPTION:
        This function will retrieve the MRU Entry specified
    by dwMRUIndex.
\****************************************************/
HRESULT GetMRUEntry(HKEY hKey, DWORD dwMRUIndex, LPTSTR pszMRUEntry, DWORD cchMRUEntry, LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;
    TCHAR szValueName[15];   // big enough for "url99999"

    ASSERT(hKey);
    ASSERT(pszMRUEntry);
    ASSERT(cchMRUEntry);

    // make a value name a la "url1" (1-based for historical reasons)
    wnsprintf(szValueName, ARRAYSIZE(szValueName), SZ_REGVAL_MRUENTRY, dwMRUIndex+1);
    cchMRUEntry *= sizeof(TCHAR);

    if (ERROR_SUCCESS != SHQueryValueEx(hKey, szValueName, NULL, NULL, (LPBYTE) pszMRUEntry, &cchMRUEntry))
    {
        pszMRUEntry[0] = TEXT('\0');
        hr = E_FAIL;
    }

    return hr;
}

/*----------------------------------------------------------
Purpose: Gets a registry value that is User Specifc.
         This will open HKEY_CURRENT_USER if it exists,
         otherwise it will open HKEY_LOCAL_MACHINE.

Returns: DWORD containing success or error code.
Cond:    --
*/
LONG OpenRegUSKey(LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
    DWORD dwRet = RegOpenKeyEx(HKEY_CURRENT_USER, lpSubKey, ulOptions, samDesired, phkResult);

    if (ERROR_SUCCESS != dwRet)
        dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpSubKey, ulOptions, samDesired, phkResult);

    return dwRet;
}



typedef struct tagSTREAMHEADER
{
    DWORD dwHeaderSize;
    DWORD dwDataSize;
    DWORD dwSignature;
    DWORD dwVersion;
} STREAMHEADER;


/****************************************************\
    FUNCTION: LoadStreamHeader

    PARAMETERS:
        dwSignature - The signature that the caller supports
        dwStartVersion - The lowest version the caller chooses to support.
        dwEndVersion - The highest version the caller chooses to support.
        pdwSize (OUT) - The size that the caller should read.
        pdwVersionOut (OUT) - The version found.
        return - if S_OK, then the caller needs to read pdwSize bytes
                               of data.
                 if S_FALSE, then the caller should use default settings
                                  and return S_OK.

    DESCRIPTION:
        This function see if the caller owns this
    data in the stream.  If the caller does own the
    stream segment, the size and version will be returned.
    If the caller doesn't own the stream segment then S_FALSE is
    returned to indicate that the caller should use default
    data.  If the caller doesn't claim to support the version
    found (because of the dwStartVersion-dwEndVersion range),
    then S_FALSE is returned to indicate to use default values
    and this function skips over that segment in the stream
    so the next segment can be parsed.
\****************************************************/
HRESULT LoadStreamHeader(IStream *pstm,
                                    DWORD dwSignature,      // What version?
                                    DWORD dwStartVersion,   // What is the earlies version supported?
                                    DWORD dwEndVersion,     // What is the oldest version supported?
                                    DWORD * pdwSize,        // What is the size to read?
                                    DWORD * pdwVersionOut)  // What version was found in the stream?
{
    HRESULT hr;
    STREAMHEADER shHeader;
    BOOL fNotOurs = FALSE;
    BOOL fSkipData = FALSE;

    hr = pstm->Read(&shHeader, sizeof(shHeader), NULL);

    ASSERT(pdwSize && pdwVersionOut);
    *pdwSize = 0;
    *pdwVersionOut = 0;

    if (SUCCEEDED(hr))
    {
        if (shHeader.dwHeaderSize != sizeof(shHeader))
            fNotOurs = TRUE;
        else if (shHeader.dwSignature != dwSignature)
            fNotOurs = TRUE;
        else if (shHeader.dwVersion < dwStartVersion)
            fSkipData = TRUE;
        else if (shHeader.dwVersion > dwEndVersion)
            fSkipData = TRUE;

        if (fNotOurs)
        {
            // It's not, so reset it so the next guy will be able to read correctly.
            LARGE_INTEGER li;

            li.LowPart = (DWORD)-(LONG)sizeof(shHeader);
            li.HighPart = 0;

            hr = pstm->Seek(li, STREAM_SEEK_CUR, NULL);
            hr = S_FALSE; // Means caller should use default data.
        }

        // Do we want to skip the Data for this part of the stream?
        if (fSkipData)
        {
            ASSERT(STREAMSIZE_UNKNOWN != shHeader.dwDataSize);  // SERIOUS, we cannot skip over data because we don't know size.

            if (STREAMSIZE_UNKNOWN != shHeader.dwDataSize)
            {
                // Yes.  The caller cannot read in this data because the caller doesn't support
                // this version of the data.  Therefore, we skip past the data and return S_FALSE
                // to indicate to the caller that default settings should be used.
                LARGE_INTEGER li;

                li.LowPart = shHeader.dwDataSize;
                li.HighPart = 0;

                hr = pstm->Seek(li, STREAM_SEEK_CUR, NULL);
                hr = S_FALSE; // Means caller should use default data.
            }
        }

        if (!fNotOurs && !fSkipData)
        {
            *pdwSize = shHeader.dwDataSize;
            *pdwVersionOut = shHeader.dwVersion;
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: SaveStreamHeader

    DESCRIPTION:
        This function will save a StreamHeader to
    the stream that will allow the caller to verify
    if he/she owns the data the next time it's read in.
    It will also support the ability to ignore old
    or future versions of data.
\****************************************************/
HRESULT SaveStreamHeader(IStream *pstm, DWORD dwSignature, DWORD dwVersion, DWORD dwSize)
{
    HRESULT hr;
    STREAMHEADER shHeader;

    shHeader.dwHeaderSize = sizeof(STREAMHEADER);
    shHeader.dwDataSize = dwSize;
    shHeader.dwSignature = dwSignature;
    shHeader.dwVersion = dwVersion;

    hr = pstm->Write(&shHeader, sizeof(shHeader), NULL);
    return hr;
}


//----------------------------------------------------------------------
//
// CMenuList
//
//----------------------------------------------------------------------


typedef struct
{
    HMENU   hmenu;
    BITBOOL bObject:1;              // TRUE: menu belongs to object
} MLITEM;       // CMenuList item


CMenuList::CMenuList(void)
{
    ASSERT(NULL == _hdsa);
}


CMenuList::~CMenuList(void)
{
    if (_hdsa)
    {
        DSA_Destroy(_hdsa);
        _hdsa = NULL;
    }
}


/*----------------------------------------------------------
Purpose: Set the menu list (comparable to HOLEMENU) so we can
         dispatch commands to the frame or the object correctly.
         We do this since menu bands bypass OLE's FrameFilterWndProc.

         We build the menu list by comparing the given hmenuShared
         with hmenuFrame.  Anything in hmenuShared that is not
         in hmenuFrame belongs to the object.

*/
void CMenuList::Set(HMENU hmenuShared, HMENU hmenuFrame)
{
    ASSERT(NULL == hmenuShared || IS_VALID_HANDLE(hmenuShared, MENU));
    ASSERT(NULL == hmenuFrame || IS_VALID_HANDLE(hmenuFrame, MENU));

    if (_hdsa)
    {
        ASSERT(IS_VALID_HANDLE(_hdsa, DSA));

        DSA_DeleteAllItems(_hdsa);
    }
    else
        _hdsa = DSA_Create(sizeof(MLITEM), 10);

    if (_hdsa && hmenuShared && hmenuFrame)
    {
        int i;
        int iFrame = 0;
        int cmenu = GetMenuItemCount(hmenuShared);
        int cmenuFrame = GetMenuItemCount(hmenuFrame);
        BOOL bMatched;
        int iSaveFrame;
        int iHaveFrame = -1;

        TCHAR sz[64];
        TCHAR szFrame[64];
        MENUITEMINFO miiFrame;
        MENUITEMINFO mii;
        MLITEM mlitem;

        miiFrame.cbSize = sizeof(miiFrame);
        miiFrame.hSubMenu = NULL;
        mii.cbSize = sizeof(mii);

        for (i = 0; i < cmenu; i++)
        {

            mii.cch = SIZECHARS(sz);
            mii.fMask  = MIIM_SUBMENU | MIIM_TYPE;
            mii.dwTypeData = sz;
            EVAL(GetMenuItemInfoWrap(hmenuShared, i, TRUE, &mii));

            ASSERT(IS_VALID_HANDLE(mii.hSubMenu, MENU));

            mlitem.hmenu = mii.hSubMenu;

            iSaveFrame = iFrame;
            bMatched = FALSE;

            //  DocObject might have dropped some of our menus, like edit and view
            //  Need to be able to skip over dropped frame menus
            while (1)
            {
                if (iHaveFrame != iFrame)
                {
                    iHaveFrame = iFrame;
                    if (iFrame < cmenuFrame)
                    {
                        miiFrame.cch = SIZECHARS(szFrame);
                        miiFrame.fMask  = MIIM_SUBMENU | MIIM_TYPE;
                        miiFrame.dwTypeData = szFrame;
                        EVAL(GetMenuItemInfoWrap(hmenuFrame, iFrame, TRUE, &miiFrame));
                    }
                    else
                    {
                        // Make it so it won't compare
                        miiFrame.hSubMenu = NULL;
                        *szFrame = 0;
                    }

                }
                ASSERT(iFrame >= cmenuFrame || IS_VALID_HANDLE(miiFrame.hSubMenu, MENU));

                // The browser may have a menu that was not merged into
                // the shared menu because the object put one in with
                // the same name.  Have we hit this case? Check by comparing
                // sz and szFrame

                if (mii.hSubMenu == miiFrame.hSubMenu || 0 == StrCmp(sz, szFrame))
                {
                    bMatched = TRUE;
                    break;
                }
                else
                {
                    if (iFrame >= cmenuFrame)
                    {
                        break;
                    }
                    iFrame++;
                }
            }

            // Is this one of our menus?
            mlitem.bObject = (mii.hSubMenu == miiFrame.hSubMenu) ? FALSE:TRUE;
            if (bMatched)
            {
                iFrame++;
            }
            else
            {
                iFrame = iSaveFrame;
            }
            DSA_SetItem(_hdsa, i, &mlitem);
        }
    }
}


/*----------------------------------------------------------
Purpose: Adds the given hmenu to the list.

*/
void CMenuList::AddMenu(HMENU hmenu)
{
    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        MLITEM mlitem;

        mlitem.hmenu = hmenu;
        mlitem.bObject = TRUE;

        DSA_AppendItem(_hdsa, &mlitem);
    }
}


/*----------------------------------------------------------
Purpose: Removes the given hmenu from the list.

*/
void CMenuList::RemoveMenu(HMENU hmenu)
{
    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        int i = DSA_GetItemCount(_hdsa) - 1;

        for (; i >= 0; i--)
        {
            MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
            ASSERT(pmlitem);

            if (hmenu == pmlitem->hmenu)
            {
                DSA_DeleteItem(_hdsa, i);
                break;
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the given hmenu belongs to the object.

*/
BOOL CMenuList::IsObjectMenu(HMENU hmenu)
{
    BOOL bRet = FALSE;

    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        int i;

        for (i = 0; i < DSA_GetItemCount(_hdsa); i++)
        {
            MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
            ASSERT(pmlitem);

            if (hmenu == pmlitem->hmenu)
            {
                bRet = pmlitem->bObject;
                break;
            }
        }
    }
    return bRet;
}


#ifdef DEBUG

void CMenuList::Dump(LPCTSTR pszMsg)
{
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGMENU))
    {
        TraceMsg(TF_ALWAYS, "CMenuList: Dumping menus for %#08x %s", this, pszMsg);

        if (_hdsa)
        {
            int i;

            for (i = 0; i < DSA_GetItemCount(_hdsa); i++)
            {
                MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
                ASSERT(pmlitem);

                TraceMsg(TF_ALWAYS, "   [%d] = %x", i, pmlitem->hmenu);
            }
        }
    }
}

#endif

#define REGVAL_FIRST_HOME_PAGE          TEXT("First Home Page")
#define REGVAL_UPDATE_CHECK_PAGE        TEXT("Update_Check_Page")
#define REGVAL_UPDATE_CHECK_INTERVAL    TEXT("Update_Check_Interval")
#define REGVAL_LASTCHECKEDHI            TEXT("LastCheckedHi")
#define REGSTR_PATH_INFODEL_REST        TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Restrictions")
#define REGVAL_IEUPDATECHECK_REST       TEXT("NoUpdateCheck")
#define DEFAULT_IEUPDATECHECK_PAGE      TEXT("http://www.microsoft.com/isapi/redir.dll?Prd=ie&Pver=5.0&Ar=ie5update&O1=b1")

BOOL
IsUpdateCheckRestricted()
{

    HKEY hkeyRest = 0;
    BOOL bUpdateCheckRest = FALSE;
    DWORD dwValue = 0;
    DWORD dwLen = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_INFODEL_REST, 0, KEY_READ, &hkeyRest) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hkeyRest, REGVAL_IEUPDATECHECK_REST, NULL, NULL,
                      (LPBYTE)&dwValue, &dwLen) == ERROR_SUCCESS && dwValue)
            bUpdateCheckRest = TRUE;

        RegCloseKey(hkeyRest);
    }

    if (!bUpdateCheckRest)
    {
        // Check to see if the user has turned it off under advanced options
        dwValue = 0;
        dwLen = sizeof(DWORD);
        if (SHRegGetUSValue(REGSTR_PATH_MAIN, REGVAL_IEUPDATECHECK_REST, NULL, (LPBYTE)&dwValue, &dwLen, 0,NULL,0) == ERROR_SUCCESS && dwValue)
                bUpdateCheckRest = TRUE;
    }

    return bUpdateCheckRest;
}


HRESULT
CheckIEMinimalUpdate()
{
    HRESULT hr = S_OK;
    HKEY hkeyIE = 0;
    TCHAR szUpdateUrl[MAX_URL_STRING];
    DWORD dwSize;
    DWORD dwType;
    FILETIME ftlast, ftnow;
    DWORD dwMagicDays = 0;
    DWORD dwMagicPerDay = 201;

    if (IsUpdateCheckRestricted())
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Exit;
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_MAIN, 0, KEY_READ, &hkeyIE) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);

    if ((RegQueryValueEx(hkeyIE, REGVAL_UPDATE_CHECK_INTERVAL, NULL, &dwType,
            (unsigned char *)&dwMagicDays, &dwSize) != ERROR_SUCCESS) || dwMagicDays == 0)
    {
        dwMagicDays = 30;   // hardcode default to check every 30 days.
    }

    StrCpy(szUpdateUrl, DEFAULT_IEUPDATECHECK_PAGE);
    dwType = REG_SZ;
    dwSize = MAX_URL_STRING;
    if (RegQueryValueEx(hkeyIE, REGVAL_UPDATE_CHECK_PAGE, NULL, &dwType,
        (LPBYTE)szUpdateUrl, &dwSize) != ERROR_SUCCESS)
    {
        // go to default page on micorosoft.com
        //hr = HRESULT_FROM_WIN32(GetLastError());
        //goto Exit;
    }

    RegCloseKey(hkeyIE);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, 0, KEY_READ|KEY_SET_VALUE, &hkeyIE) == ERROR_SUCCESS)
    {
        dwType = REG_SZ;
        dwSize = MAX_URL_STRING;
        if (RegQueryValueEx(hkeyIE, REGVAL_FIRST_HOME_PAGE, NULL, &dwType,
            NULL, &dwSize) == ERROR_SUCCESS)
        {
            // if already exists then skip this write
            hr = S_FALSE;
            goto Exit;
        }

        GetSystemTimeAsFileTime(&ftnow);
        ftnow.dwLowDateTime = 0;

        ZeroMemory(&ftlast, sizeof(ftlast));

        dwType = REG_DWORD;
        dwSize = sizeof(DWORD);
        if (RegQueryValueEx(hkeyIE, REGVAL_LASTCHECKEDHI, NULL, &dwType,
            (unsigned char *)&ftlast.dwHighDateTime, &dwSize)==ERROR_SUCCESS)
        {
            ftlast.dwHighDateTime += (dwMagicPerDay * dwMagicDays);
        }

        if (CompareFileTime(&ftlast, &ftnow) > 0)
        {
            hr = S_FALSE;
        }
        else
        {

            RegSetValueEx(hkeyIE,REGVAL_FIRST_HOME_PAGE, NULL,
                REG_SZ,(LPBYTE)szUpdateUrl, (lstrlen(szUpdateUrl)+1)*sizeof(TCHAR));

            RegSetValueEx(hkeyIE, REGVAL_LASTCHECKEDHI, NULL, REG_DWORD,
               (unsigned char *)&ftnow.dwHighDateTime, sizeof(DWORD));
        }

        RegCloseKey(hkeyIE);
    }

Exit:

    return hr;
}


static BOOL s_fSUCheckComplete = FALSE;
// returns:
//      TRUE    The user clicked Update Now and we ShellExe'ed
//              the update URL.
//      FALSE   We did not launch a browser to the update page.
// NOTE: the "run-once-ness" of this is controlled by the ICW check
//       variable g_fICWCheckComplete.

BOOL CheckSoftwareUpdateUI(HWND hwndOwner, IShellBrowser *pisb)
{
    BOOL fLaunchUpdate = FALSE;

#ifndef UNIX
    HRESULT hr = S_OK;
    int nRes;
    SOFTDISTINFO sdi = { 0 };
    sdi.cbSize = sizeof(SOFTDISTINFO);

    if (s_fSUCheckComplete)
        return FALSE;
    else
        s_fSUCheckComplete = TRUE;

    // We're putting up a message box, so make the msg pump modal
    pisb->EnableModelessSB(FALSE);

    nRes = SoftwareUpdateMessageBox(hwndOwner, awchMSIE4GUID, 0, &sdi);

    pisb->EnableModelessSB(TRUE);

    if (nRes != IDABORT)
    {
        if (nRes == IDYES)
        {
            // Okay, we tried to do this a couple of different ways.
            // Originally, this was done with ShellExecEx. This failed
            // because the http hook wasn't 100% reliable on Win95.
            // The next stab was to:
            //LPITEMIDLIST pidl;
            // The user wants to navigate to the install page.
            //hr = pibs->IEParseDisplayName(CP_ACP, sdi.szHREF, &pidl);
            //if (SUCCEEDED(hr))
            //{
            //    OpenFolderPidl(pidl);
            //    ILFree(pidl);
            //}
            hr = NavToUrlUsingIEW(sdi.szHREF, TRUE);

        } // if user wants update

        if (sdi.szTitle != NULL)
            CoTaskMemFree(sdi.szTitle);
        if (sdi.szAbstract != NULL)
            CoTaskMemFree(sdi.szAbstract);
        if (sdi.szHREF != NULL)
            CoTaskMemFree(sdi.szHREF);

        fLaunchUpdate = nRes == IDYES && SUCCEEDED(hr);

    }

    if (!fLaunchUpdate)
    {
        // for minimal install of IE every N days or so we want to
        // hijack the home page to check if an update is available
        // for us.

        CheckIEMinimalUpdate();
    }
#endif

    return fLaunchUpdate;
}



BOOL g_fICWCheckComplete = FALSE;

// returns:
//      TRUE    Internet Connection Wizard (ICW) was run, and we should exit
//              the browser since we likely need to restart the system
//      FALSE   did not run the ICW, continue on as normal

BOOL CheckRunICW(LPCTSTR pszURL)
{
    if (g_fICWCheckComplete)
        return FALSE;

    DWORD dwICWCompleted = 0;
    BOOL fRet = FALSE;

    // Check if ICW has already been run

    DWORD dwSize = sizeof(dwICWCompleted);
    SHGetValue(HKEY_CURRENT_USER, TEXT(ICW_REGPATHSETTINGS), TEXT(ICW_REGKEYCOMPLETED), NULL, &dwICWCompleted, &dwSize);

    if (!dwICWCompleted)
    {
        HINSTANCE hInetCfgDll = LoadLibrary(TEXT("inetcfg.dll"));
        // set this to TRUE here so that if there's an error in loading the dll, or getting the proc address,
        // we don't keep trying to do that.
        g_fICWCheckComplete = TRUE;
        if (hInetCfgDll)
        {
            PFNCHECKCONNECTIONWIZARD fp = (PFNCHECKCONNECTIONWIZARD)GetProcAddress(hInetCfgDll, "CheckConnectionWizard");
            if (fp)
            {
                DWORD dwRet;
                DWORD dwFlags = ICW_LAUNCHFULL | ICW_LAUNCHMANUAL | ICW_FULL_SMARTSTART;

                if (pszURL)
                {
                    PFNSETSHELLNEXT fpSetShellNext = (PFNSETSHELLNEXT)GetProcAddress(hInetCfgDll, "SetShellNext");
                    if (fpSetShellNext)
                    {
                        CHAR szAnsiUrl[MAX_URL_STRING];

                        SHTCharToAnsi(pszURL, szAnsiUrl, ARRAYSIZE(szAnsiUrl));
                        dwFlags |= ICW_USE_SHELLNEXT;
                        fpSetShellNext(szAnsiUrl);
                    }
                }

                // if we get this far, set the fICWCheckComplete back to FALSE (had to be false since we didn't early out)
                // and let the ICW set the reg key.  this is so that if the user decides to cancel and come back later,
                // we respect that.
                g_fICWCheckComplete = FALSE;

                // Launch ICW full or manual path, whichever is available
                // NOTE: the ICW code makes sure only a single instance is up
                fp(dwFlags, &dwRet);

                // If it was launched successfully, we need to exit
                // since ICW may restart the machine if it needs to
                // install system files.
                if (dwRet & (ICW_LAUNCHEDFULL | ICW_LAUNCHEDMANUAL))
                {
                    fRet = TRUE;
                }
            }
            FreeLibrary(hInetCfgDll);
        }
    }
    else
    {
        g_fICWCheckComplete = TRUE;
    }

    return fRet;
}


int GetColorComponent(LPSTR *ppsz)
{
    int iColor = 0;
    if (*ppsz)
    {
        LPSTR pBuf = *ppsz;
        iColor = StrToIntA(pBuf);

        // find the next comma
        while(pBuf && *pBuf && *pBuf!=L',')
            pBuf++;

        // if valid and not NULL...
        if (pBuf && *pBuf)
            pBuf++;         // increment

        *ppsz = pBuf;
    }
    return iColor;
}

// Read the registry for a string (REG_SZ) of comma separated RGB values
COLORREF RegGetColorRefString(HKEY hkey, LPTSTR RegValue, COLORREF Value)
{
    CHAR SmallBuf[80];
    CHAR szRegKey[MAXIMUM_SUB_KEY_LENGTH];
    LPSTR pszBuf;
    DWORD cb;
    int iRed, iGreen, iBlue;

    SHTCharToAnsi(RegValue, szRegKey, ARRAYSIZE(szRegKey));
    cb = sizeof(SmallBuf);
    if (SHQueryValueExA(hkey, szRegKey, NULL, NULL, (LPBYTE)&SmallBuf, &cb)
        == ERROR_SUCCESS)
    {
        pszBuf = SmallBuf;

        iRed = GetColorComponent(&pszBuf);
        iGreen = GetColorComponent(&pszBuf);
        iBlue = GetColorComponent(&pszBuf);

        // make sure all values are valid
        iRed    %= 256;
        iGreen  %= 256;
        iBlue   %= 256;

        Value = RGB(iRed, iGreen, iBlue);
    }

    return Value;
}

LRESULT SetHyperlinkCursor(IShellFolder* pShellFolder, LPCITEMIDLIST pidl)
{
    HCURSOR hCursor;
    BOOL fCursorSet = FALSE;

    if (!pidl)
        return 0;

    if (SHIsGlobalOffline())
    {
        IQueryInfo *pqi;
        if (SUCCEEDED(pShellFolder->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IQueryInfo, NULL, &pqi))))
        {
            DWORD dwFlags = 0;
            if (SUCCEEDED(pqi->GetInfoFlags(&dwFlags)))
            {
                if (0 == (dwFlags & QIF_CACHED))
                {
                    // Load Offline cursor since not cached
                    hCursor = (HCURSOR)LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_OFFLINE_HAND));
                    if (hCursor)
                    {
                        SetCursor(hCursor);
                        fCursorSet = TRUE;
                    }
                }
            }
            pqi->Release();
        }
    }

    if (!fCursorSet)
    {
        // For whatever reason, offline cursor was not set
        hCursor = LoadHandCursor(0);
        if (hCursor)
            SetCursor(hCursor);
    }

    return 1;
}

BOOL IsSubscribableA(LPCSTR pszUrl)
{
    //  REARCHITECT: this should be method on the subscription mgr interface - zekel
    DWORD dwScheme = GetUrlSchemeA(pszUrl);
    return (dwScheme == URL_SCHEME_HTTP) || (dwScheme == URL_SCHEME_HTTPS);
}

BOOL IsSubscribableW(LPCWSTR pwzUrl)
{
    //  REARCHITECT: this should be method on the subscription mgr interface - zekel
    DWORD dwScheme = GetUrlSchemeW(pwzUrl);
    return (dwScheme == URL_SCHEME_HTTP) || (dwScheme == URL_SCHEME_HTTPS);
}

HWND GetTrayWindow()
{
#ifndef UNIX
    static HWND s_hwndTray = NULL;

    if (!IsWindow(s_hwndTray))
    {
        s_hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);
    }
    return s_hwndTray;
#else
    return NULL;
#endif
}

void FireEventSzA(LPCSTR szEvent)
{
    HANDLE hEvent = OpenEventA(EVENT_MODIFY_STATE, FALSE, szEvent);
    if (hEvent)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
}

void FireEventSzW(LPCWSTR pszEvent)
{
    USES_CONVERSION;
    FireEventSzA(W2A(pszEvent));
}

BOOL IsNamedWindow(HWND hwnd, LPCTSTR pszClass)
{
#ifndef UNIX
    TCHAR szClass[32];
#else // UNIX use this function for trident dialog window
    TCHAR szClass[64];
#endif

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return lstrcmp(szClass, pszClass) == 0;
}

BOOL IsExplorerWindow(HWND hwnd)
{
    return IsNamedWindow(hwnd, c_szExploreClass);
}

BOOL IsFolderWindow(HWND hwnd)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return (lstrcmp(szClass, c_szCabinetClass) == 0) || (lstrcmp(szClass, c_szIExploreClass) == 0);
}


// returns TRUE if the unknown is on a window that was opened as IE
// returns FALSE if the window was opened on the shell namespace, even if it's now showing a web page
// returns FALSE in other cases e.g. on the taskbar

STDAPI_(BOOL) WasOpenedAsBrowser(IUnknown *punkSite) 
{
    // this is a more reliable way of distinguishing windows opened for a URL.  Checking
    // the hwnd's classname does not work -- clicking on a hyperlink from Outlook 98 opens
    // a browser window with a shell window's classname.

    return (S_OK == IUnknown_QueryServiceExec(punkSite, SID_STopLevelBrowser, &CGID_Explorer, SBCMDID_STARTEDFORINTERNET, 0, NULL, NULL));
}


#define DXTRACK 1
void FrameTrack(HDC hdc, LPRECT prc, UINT uFlags)
{
    COLORREF clrSave, clr;
    RECT    rc;

    // upperleft
    switch (uFlags)
    {
    case TRACKHOT:
        clr = GetSysColor(COLOR_BTNHILIGHT);
        break;
    case TRACKNOCHILD:
    case TRACKEXPAND:
        clr = GetSysColor(COLOR_BTNSHADOW);
        break;
    default:
        ASSERT(FALSE);
        break;
    }
    clrSave = SetBkColor(hdc, clr);
    rc = *prc;
    rc.bottom = rc.top + DXTRACK;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    rc.bottom = prc->bottom;
    rc.right = rc.left + DXTRACK;
    rc.top = prc->top + DXTRACK;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    // lowerright
    switch (uFlags)
    {
    case TRACKHOT:
        clr = GetSysColor(COLOR_BTNSHADOW);
        break;
    case TRACKNOCHILD:
    case TRACKEXPAND:
        clr = GetSysColor(COLOR_BTNHILIGHT);
        break;
    default:
        ASSERT(FALSE);
        break;
    }
    SetBkColor(hdc, clr);
    if (uFlags & (TRACKHOT | TRACKNOCHILD))
    {
        rc.right = prc->right;
        rc.top = rc.bottom - DXTRACK;
        rc.left = prc->left;
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    }
    rc.right = prc->right;
    rc.left = prc->right - DXTRACK;
    rc.top = prc->top;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    SetBkColor(hdc, clrSave);
    return;
}

#ifdef DEBUG // {
//***   SearchDW -- scan for DWORD in buffer
// ENTRY/EXIT
//  pdwBuf  buffer
//  cbBuf   size of buffer in *bytes* (*not* DWORDs)
//  dwVal   DWORD we're looking for
//  dOff    (return) byte offset in buffer; o.w. -1 if not found
//
int SearchDWP(DWORD_PTR *pdwBuf, int cbBuf, DWORD_PTR dwVal)
{
    int dOff;

    for (dOff = 0; dOff < cbBuf; dOff += sizeof(DWORD_PTR), pdwBuf++)
    {
        if (*pdwBuf == dwVal)
            return dOff;
    }

    return -1;
}
#endif // }


int CAssociationList::FindEntry(DWORD dwKey)
{
    if (_hdsa)
    {
        for (int i = 0; i < DSA_GetItemCount(_hdsa); i++)
        {
            ASSOCDATA* pad;
            pad = (ASSOCDATA*)DSA_GetItemPtr(_hdsa, i);
            if (pad->dwKey == dwKey)
                return i;
        }
    }
    return -1;
}

HRESULT CAssociationList::Find(DWORD dwKey, void ** ppData)
{
    HRESULT hr = E_FAIL;

    ENTERCRITICAL;
    int i = FindEntry(dwKey);
    if (i != -1)
    {
        ASSOCDATA* pad = (ASSOCDATA*)DSA_GetItemPtr(_hdsa, i);
        ASSERT(dwKey == pad->dwKey);
        *ppData = pad->lpData;
        hr = S_OK;
    }
    LEAVECRITICAL;

    return hr;
}

void CAssociationList::Delete(DWORD dwKey)
{
    ENTERCRITICAL;
    int i = FindEntry(dwKey);
    if (i != -1)
    {
        DSA_DeleteItem(_hdsa, i);
    }
    LEAVECRITICAL;
}


BOOL CAssociationList::Add(DWORD dwKey, void *lpData)
{
    ENTERCRITICAL;
    if (!_hdsa)
    {
        _hdsa = DSA_Create(sizeof(ASSOCDATA), 4);
    }
    LEAVECRITICAL;

    BOOL fRet = FALSE;
    if (_hdsa)
    {
        ASSOCDATA ad;
        ad.dwKey = dwKey;
        ad.lpData = lpData;

        ENTERCRITICAL;
        fRet = DSA_AppendItem(_hdsa, &ad) != -1;
        LEAVECRITICAL;
    }
    return fRet;
}

int g_cxSmIcon = 0;
int g_cySmIcon = 0;
HIMAGELIST g_himlSysSmall = NULL;

void _InitSmallImageList()
{
    if (!g_himlSysSmall)
    {
        Shell_GetImageLists(NULL, &g_himlSysSmall);
        ImageList_GetIconSize(g_himlSysSmall, &g_cxSmIcon, &g_cySmIcon);
    }
}


#define CXIMAGEGAP      6

STDAPI_(void) DrawMenuItem(DRAWITEMSTRUCT* lpdi, LPCTSTR lpszMenuText, UINT iIcon)
{
    _InitSmallImageList();

    if ((lpdi->itemAction & ODA_SELECT) || (lpdi->itemAction & ODA_DRAWENTIRE))
    {
        int x, y;
        SIZE sz;
        RECT rc;

        // Draw the image (if there is one).
        GetTextExtentPoint32(lpdi->hDC, lpszMenuText, lstrlen(lpszMenuText), &sz);

        if (lpdi->itemState & ODS_SELECTED)
        {
            SetBkColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            FillRect(lpdi->hDC,&lpdi->rcItem,GetSysColorBrush(COLOR_HIGHLIGHT));
        }
        else
        {
            SetTextColor(lpdi->hDC, GetSysColor(COLOR_MENUTEXT));
            FillRect(lpdi->hDC,&lpdi->rcItem,GetSysColorBrush(COLOR_MENU));
        }

        rc = lpdi->rcItem;
        rc.left += +2 * CXIMAGEGAP + g_cxSmIcon;

        DrawText(lpdi->hDC, lpszMenuText, lstrlen(lpszMenuText), &rc, DT_SINGLELINE | DT_VCENTER | DT_EXPANDTABS);
        if (iIcon != -1)
        {
            x = lpdi->rcItem.left + CXIMAGEGAP;
            y = (lpdi->rcItem.bottom + lpdi->rcItem.top - g_cySmIcon) / 2;
            ImageList_Draw(g_himlSysSmall, iIcon, lpdi->hDC, x, y, ILD_TRANSPARENT);
        }
        else
        {
            x = lpdi->rcItem.left + CXIMAGEGAP;
            y = (lpdi->rcItem.bottom + lpdi->rcItem.top - g_cySmIcon) / 2;
        }
    }
}

STDAPI_(LRESULT) MeasureMenuItem(MEASUREITEMSTRUCT *lpmi, LPCTSTR lpszMenuText)
{
    LRESULT lres = FALSE;

    if (0 == g_cxSmIcon)
    {
        _InitSmallImageList();
    }

    // Get the rough height of an item so we can work out when to break the
    // menu. User should really do this for us but that would be useful.
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        // REVIEW cache out the menu font?
        NONCLIENTMETRICSA ncm;
        ncm.cbSize = sizeof(ncm);
        if (SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
        {
            HFONT hfont = CreateFontIndirectA(&ncm.lfMenuFont);
            if (hfont)
            {
                SIZE sz;
                HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
                GetTextExtentPoint32(hdc, lpszMenuText, lstrlen(lpszMenuText), &sz);
                lpmi->itemHeight = max (g_cySmIcon+CXIMAGEGAP/2, ncm.iMenuHeight);
                lpmi->itemWidth = g_cxSmIcon + 2*CXIMAGEGAP + sz.cx;
                SelectObject(hdc, hfontOld);
                DeleteObject(hfont);
                lres = TRUE;
            }
        }
        ReleaseDC(NULL, hdc);
    }
    return lres;
}

//+-------------------------------------------------------------------------
// This function scans the document for the given HTML tag and returns the
// result in a collection.
//--------------------------------------------------------------------------
HRESULT GetDocumentTags
(
    IHTMLDocument2 *          pHTMLDocument,    // doc to search
    LPOLESTR                  pszTagName,       // tag name to search for
    IHTMLElementCollection ** ppTagsCollection  // returned collection
)
{
    HRESULT hr;

    *ppTagsCollection = NULL;

    //
    // First get all document elements
    //
    IHTMLElementCollection * pAllCollection;
    if (SUCCEEDED(hr = pHTMLDocument->get_all(&pAllCollection)))
    {
        //
        // Now get all the elements with tags == pszTagName
        //
        VARIANT v;
        v.vt = VT_BSTR;
        v.bstrVal = ::SysAllocString(pszTagName);
        if (v.bstrVal)
        {
            IDispatch * pDispTagsCollection;
            if (SUCCEEDED(hr = pAllCollection->tags(v, &pDispTagsCollection)))
            {
                hr = pDispTagsCollection->QueryInterface(IID_PPV_ARG(IHTMLElementCollection, ppTagsCollection));
                pDispTagsCollection->Release();
            }

            pAllCollection->Release();
            VariantClear(&v);
        }
    }

    return hr;
}

// This function uses the memory allocator from comctrl (which differs between NT and W95)
BOOL WINAPI Str_SetPtrPrivateW(WCHAR FAR * UNALIGNED * ppwzCurrent, LPCWSTR pwzNew)
{
    LPWSTR pwzNewCopy = NULL;

    if (pwzNew)
    {
        pwzNewCopy = StrDup(pwzNew);
        if (!pwzNewCopy)
            return FALSE;
    }

    LPWSTR pwzOld = (LPWSTR)InterlockedExchangePointer((void * *)ppwzCurrent, (void *)pwzNewCopy);
    if (pwzOld)
        LocalFree(pwzOld);

    return TRUE;
}

// This function is compatible with API's that use LocalAlloc for string memory
BOOL WINAPI SetStr(WCHAR FAR * UNALIGNED * ppwzCurrent, LPCWSTR pwzNew)
{
    int cchLength;
    LPWSTR pwzOld;
    LPWSTR pwzNewCopy = NULL;

    if (pwzNew)
    {
        cchLength = lstrlenW(pwzNew);

        // alloc a new buffer w/ room for the null terminator
        pwzNewCopy = (LPWSTR)LocalAlloc(LPTR, (cchLength + 1) * sizeof(WCHAR));

        if (!pwzNewCopy)
            return FALSE;

        StrCpyNW(pwzNewCopy, pwzNew, cchLength + 1);
    }

    pwzOld = (LPWSTR)InterlockedExchangePointer((void * *)ppwzCurrent, (void *)pwzNewCopy);

    if (pwzOld)
        LocalFree(pwzOld);

    return TRUE;
}

//---------------------------------------------------------------------------
// If the string contains &ch or begins with ch then return TRUE.
BOOL _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand)
{
    LPTSTR pchAS = StrChr(lpsz, TEXT('&')); // Find the first ampersand.
    if (pchAS && !fIgnoreAmpersand)
    {
        // Yep, is the next char the one we want.
        if (CharUpperChar(*CharNext(pchAS)) == CharUpperChar(ch))
        {
            // Yep.
            return TRUE;
        }
    }
    else if (CharUpperChar(*lpsz) == CharUpperChar(ch))
    {
        return TRUE;
    }

    return FALSE;
}

// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject)
{
    RECT    rc;
    POINT   pt;

    GetWindowRect(hwndTarget, &rc);

    //
    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    DAD_DragEnterEx2(hwndTarget, pt, pdtObject);
    return;
}

void _DragMove(HWND hwndTarget, const POINTL ptStart)
{
    RECT rc;
    POINT pt;

    GetWindowRect(hwndTarget, &rc);

    //
    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    DAD_DragMove(pt);
    return;
}



HRESULT CheckDesktopIni(LPCTSTR pszPath, LPCTSTR pszKey, LPTSTR pszBuffer, DWORD cbSize)
{
    // NOTE:
    // NOTE: DO NOT COPY THIS CODE. We only do this here for channels because we expect
    // NOTE: the 99% case to be that it succeeds. If you need to find out if it is a
    // NOTE: system folder, then you need to hack the pidl to get the system bit
    // NOTE:
    DWORD dwAttrs = GetFileAttributes(pszPath);
    if (dwAttrs == (DWORD) -1 || !(dwAttrs & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)))
        return E_NOINTERFACE;

    TCHAR szDIPath[MAX_PATH];

    PathCombine(szDIPath, pszPath, TEXT("desktop.ini"));
    if (pszKey == NULL)
    {
        if (GetFileAttributes(szDIPath) == (DWORD) -1)
        {
            return E_FAIL;
        }
    }
    else
    {
        GetPrivateProfileString(TEXT(".ShellClassInfo"), pszKey, TEXT(""), pszBuffer, cbSize, szDIPath);
        if (*pszBuffer == 0)
            return E_NOINTERFACE;

        // if its not a URL, then
        if (!PathIsURL(pszBuffer))
        {
            PathCombine(pszBuffer, pszPath, pszBuffer);
        }
    }
    return NOERROR;
}

STDAPI LookForDesktopIniText(IShellFolder *psf, LPCITEMIDLIST pidl, LPCTSTR pszKey, LPTSTR pszBuffer, DWORD cbSize)
{
    TCHAR szPath[MAX_PATH];
    DWORD ulFlags = SFGAO_FOLDER | SFGAO_FILESYSTEM;
    HRESULT hr = GetPathForItem(psf, pidl, szPath, &ulFlags);
    if (SUCCEEDED(hr) && (ulFlags & SFGAO_FOLDER))
    {
        hr = CheckDesktopIni(szPath, pszKey, pszBuffer, cbSize);
    }
    return hr;
}

// this is for channel category folders

HRESULT FakeGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    HRESULT hres = E_FAIL;

    WIN32_FIND_DATAA wfd;

    // before looking for a desktop.ini (which hits the disk), cheaply
    // see if it's a system folder.
    //
    // SHGetDataFromIDListA returns E_INVALIDARG on IE4.0 shell32 and
    // IE4.01 shell32.  It is fixed in IE4.01qfe shell32 and IE4.01sp1
    // shell32.  It also appears to work on NT4 and W95 shell32.  If
    // SHGetDataFromIDListA returns E_INVALIDARG we drop through and
    // do the slow LookForDesktopIniText call.
    //

    HRESULT hresTemp = SHGetDataFromIDListA(psf, pidl, SHGDFIL_FINDDATA, &wfd, sizeof(wfd));

    // on win95 non integrated, only the A version is implemented
    if ((E_INVALIDARG == hresTemp) ||
        (SUCCEEDED(hresTemp) &&
        (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (wfd.dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY))))
    {
        // final failure case, check to see if it is a system folder with a desktop.ini file. This is gross and slow,
        // but this is only called when the user has navigated so we can be a little slower. Please do NOT COPY this
        // code or DavidDS will get really really upset and perf will be bad.
        TCHAR szBuffer[MAX_URL_STRING];

        // this will check for SFGAO_FOLDER & SFGAO_FILESYSTEM first...
        hres = LookForDesktopIniText(psf, pidl, TEXT("URL"), szBuffer, ARRAYSIZE(szBuffer));
        if (SUCCEEDED(hres))
        {
            DWORD dwChar = ARRAYSIZE(szBuffer);
            // this call uses a temp, so we can reuse the buffer...
            hres = UrlCreateFromPath(szBuffer, szBuffer, &dwChar, 0);
            if (SUCCEEDED(hres))
                hres = IECreateFromPath(szBuffer, ppidl);
        }
    }
    else
    {
        hres = E_FAIL;
    }
    return hres;
}

// Can we browse or navigate to this pidl?  If not, need
BOOL ILIsBrowsable(LPCITEMIDLIST pidl, BOOL *pfIsFolder)
{
    if (!pidl)
        return FALSE;
    DWORD dwAttributes = SFGAO_FOLDER | SFGAO_BROWSABLE;
    HRESULT hr = IEGetAttributesOf(pidl, &dwAttributes);

    if (pfIsFolder && SUCCEEDED(hr))
        *pfIsFolder = dwAttributes & SFGAO_FOLDER;

    return SUCCEEDED(hr) && (dwAttributes & (SFGAO_FOLDER | SFGAO_BROWSABLE));
}



// gets a target pidl given a name space item. typically this is a .lnk or .url file
//
//  in:
//        psf         shell folder for item
//        pidl        item relative to psf, single level
//
//  in/out
//        pdwAttribs  [optional] attributes mask to filter on (returned).
//        must be initalized
//
//
//  returns
//        *ppidl      the target pidl
//        *pdwAttribs [optional] attributes of the source object

STDAPI SHGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl,
                         LPITEMIDLIST *ppidl, DWORD *pdwAttribs)
{
    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(NULL == pdwAttribs || IS_VALID_WRITE_PTR(pdwAttribs, DWORD));
    ASSERT(ILFindLastID(pidl) == pidl);   // must be single level PIDL

    *ppidl = NULL;      // assume failure

    DWORD dwAttribs = SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_LINK | SFGAO_BROWSABLE;

    if (pdwAttribs)
        dwAttribs |= *pdwAttribs;

    HRESULT hres = psf->GetAttributesOf(1, &pidl, &dwAttribs);
    if (SUCCEEDED(hres))
    {
        // first try the most efficient way
        IShellLinkA *psl;       // "A" so this works on Win95
        hres = psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IShellLinkA, NULL, &psl));
        if (SUCCEEDED(hres))
        {
            hres = psl->GetIDList(ppidl);
            psl->Release();
        }

        // this is for .lnk and .url files that don't register properly
        if (FAILED(hres) && (dwAttribs & (SFGAO_FILESYSTEM | SFGAO_LINK)) == (SFGAO_FILESYSTEM | SFGAO_LINK))
        {
            TCHAR szPath[MAX_PATH];

            hres = GetPathForItem(psf, pidl, szPath, NULL);
            if (SUCCEEDED(hres))
                hres = GetLinkTargetIDList(szPath, NULL, 0, ppidl);
        }

        // .doc or .html. return the pidl for this.
        // (fully qualify against the folder pidl)
        if (FAILED(hres) && (dwAttribs & SFGAO_BROWSABLE))
        {
            LPITEMIDLIST pidlFolder;
            hres = SHGetIDListFromUnk(psf, &pidlFolder);
            if (SUCCEEDED(hres))
            {
                *ppidl = ILCombine(pidlFolder, pidl); // navigate to this thing...
                hres = *ppidl ? S_OK : E_OUTOFMEMORY;
                ILFree(pidlFolder);
            }
        }

        // channel name space items on non integrated
        if (FAILED(hres) && WhichPlatform() != PLATFORM_INTEGRATED)
        {
            IExtractIconA *pxicon;   // Use IID_IExtractIconA so we work on W95.
            hres = psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IExtractIconA, NULL, &pxicon));
            if (SUCCEEDED(hres))
            {
                hres = pxicon->QueryInterface(IID_PPV_ARG(IShellLinkA, &psl));
                if (SUCCEEDED(hres))
                {
                    hres = psl->GetIDList(ppidl);
                    psl->Release();
                }
                pxicon->Release();
            }
        }

#ifdef ENABLE_CHANNEL_CATEGORY_FOLDERS
        // channel category folders
        if (FAILED(hres))
            hres = FakeGetNavigateTarget(psf, pidl, ppidl);
#endif //ENABLE_CHANNEL_CATEGORY_FOLDERS

        // Callers of SHGetNavigateTarget assume that the returned pidl
        // is navigatable (SFGAO_FOLDER or SFGAO_BROWSER), which isn't
        // the case for a link (it could be a link to an exe).
        //
        if (SUCCEEDED(hres) && !ILIsBrowsable(*ppidl, NULL))
        {
            ILFree(*ppidl);
            *ppidl = NULL;
            hres = E_FAIL;
        }

        if (SUCCEEDED(hres) && pdwAttribs)
            *pdwAttribs = dwAttribs;
    }
    return hres;
}

BOOL CreateShortcutAndDoDragDropIfPIDLIsNetUrl(IOleCommandTarget *pcmdt, LPITEMIDLIST pidl, HWND hwnd)
{
    IUniformResourceLocator *purl;
    IDataObject *pdtobj;

    HRESULT hr = CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(pidl, pcmdt, &purl, &pdtobj);

    if (SUCCEEDED(hr))
    {
        ASSERT(pdtobj);
        ASSERT(purl);

        // REARCHITECT: we should be binding to the parent and getting the attributes
        // to determine the allowed effects - like we do in DragDrop()
        DWORD dwEffect = (DROPEFFECT_COPY | DROPEFFECT_LINK);

        ::_SetPreferedDropEffect(pdtobj, DROPEFFECT_LINK);
        // Win95 Browser Only - the shell32 in this process doesn't know
        // ole is loaded, even though it is.
        SHLoadOLE(SHELLNOTIFY_OLELOADED);

        hr = SHDoDragDrop(hwnd, pdtobj, NULL, dwEffect, &dwEffect);
        // the returned value is not S_OK even tho' the drag drop succeeded
        // however it is a success return
        if (SUCCEEDED(hr))
        {
            // Since drag drop succeeded
            // Bring down the icon for this shortcut
            IUnknown_Exec(purl, &CGID_ShortCut, ISHCUTCMDID_DOWNLOADICON, 0, NULL, NULL);
        }
        pdtobj->Release();
        IUnknown_SetSite(purl, NULL);
        purl->Release();
    }

    return SUCCEEDED(hr);
}

BOOL DoDragDropWithInternetShortcut(IOleCommandTarget *pcmdt, LPITEMIDLIST pidl, HWND hwnd)
{
    BOOL fDragDropDone = CreateShortcutAndDoDragDropIfPIDLIsNetUrl(pcmdt, pidl, hwnd);
    if (FALSE == fDragDropDone)
    {
        // simply use PIDL and get none of the persistence effect
        fDragDropDone = SUCCEEDED(DragDrop(hwnd, NULL, pidl, DROPEFFECT_LINK, NULL));
    }
    return fDragDropDone;
}

STDAPI_(HWND) GetTopLevelAncestor(HWND hWnd)
{
    HWND hwndTemp;

    while ((hwndTemp=GetParent(hWnd)) != NULL)
    {
        hWnd = hwndTemp;
    }

    return(hWnd);
}

#if 0
BOOL IsIERepairOn()
{
    static DWORD     dwChecked = -1;

    if (dwChecked == -1)
    {
        DWORD   dwSize, dwType;

        // First check the OS setting. On NT5 and Win98-OSR, Repair is Off.
        // OS turned Off Repair ==> "DisableRepair" RegValue is set to 1.
        dwChecked = 1;       // The default Repair is ON
        dwSize = sizeof(dwChecked);
        if (SHRegGetUSValue(SZ_REGKEY_ACTIVE_SETUP, SZ_REGVALUE_DISABLE_REPAIR, &dwType, (void *) &dwChecked, &dwSize, TRUE, (void *)NULL, 0) == ERROR_SUCCESS)
        {
            // OS Reg setting of 0 ==> Repair is ON
            // OS Reg setting of 1 ==> Repair is OFF
            dwChecked = (dwChecked == 0) ? 1 : 0;
        }
        else
        {
            dwChecked = 1;   // if we fail to read Reg, go back to default.
        }

        // Check for Admin policy only if OS setting leaves Repair On.
        if (dwChecked == 1)
        {
            dwSize = sizeof(dwChecked);
            if (SHRegGetUSValue(SZ_REGKEY_IE_POLICIES, SZ_REGVALUE_IEREPAIR, &dwType, (void *) &dwChecked, &dwSize, TRUE, (void *)NULL, 0) != ERROR_SUCCESS)
            {
                dwChecked = 1;   // if we fail to read Reg, go back to default.
            }
        }
    }
    return (dwChecked == 1);
}

#endif

BOOL IsResetWebSettingsEnabled(void)
{
    static BOOL fUseCache = FALSE;  // have we already looked up the answer in the registry?
    static BOOL fEnabled;           // is the feature enabled or disabled?

    if (!fUseCache)
    {

        DWORD dwData;
        DWORD dwSize = sizeof(dwData);
        DWORD dwType;

        //
        // Next time, we'll use the cached value instead of
        // looking in the registry
        //
        fUseCache = TRUE;

        //
        // Look up the appropriate ieak value in the registry
        //
        if (ERROR_SUCCESS == SHRegGetUSValue(
                                SZ_REGKEY_INETCPL_POLICIES,
                                SZ_REGVALUE_RESETWEBSETTINGS,
                                &dwType,
                                (void *)&dwData,
                                &dwSize,
                                FALSE,
                                NULL,
                                0))
        {
            //
            // If the value was found in the registry, then
            // set fEnabled accordingly
            //
            fEnabled = !dwData;

        }
        else
        {
            //
            // If the value is missing from the registry, then
            // assume the feature is enabled
            //
            fEnabled = TRUE;

        }

    }

    return fEnabled;

}

STDAPI_(BOOL) InitOCHostClass(const SHDRC * pshdrc)
{
    // It would be nice to remove this, but since it was exported, we keep it here for compat
    RIPMSG(FALSE, "This export is dead, caller needs to call SHDOCVW!DllRegisterWindowClasses directly");
    return DllRegisterWindowClasses(pshdrc);
}

STDAPI SHNavigateToFavorite(IShellFolder* psf, LPCITEMIDLIST pidl, IUnknown* punkSite, DWORD dwFlags)
{
    HRESULT hres = S_FALSE;

    TCHAR szPath[MAX_PATH];

    // Can we navigate to this favorite?
    BOOL fNavigateDone = SUCCEEDED(GetPathForItem(psf, pidl, szPath, NULL)) &&
                         SUCCEEDED(NavFrameWithFile(szPath, punkSite));
    if (fNavigateDone)
        return S_OK;

    LPITEMIDLIST pidlGoto;

    ASSERT(!(dwFlags & (SBSP_NEWBROWSER | SBSP_SAMEBROWSER)));
    
    if (SUCCEEDED(SHGetNavigateTarget(psf, pidl, &pidlGoto, NULL)))
    {
        IShellBrowser* psb;
        if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_STopLevelBrowser,
            IID_PPV_ARG(IShellBrowser, &psb))))
        {
            hres = psb->BrowseObject(pidlGoto, dwFlags | SBSP_SAMEBROWSER);
            psb->Release();
        }
        ILFree(pidlGoto);
    }
    return hres;
}
STDAPI SHGetTopBrowserWindow(IUnknown* punk, HWND* phwnd)
{
    IOleWindow* pOleWindow;
    HRESULT hr = IUnknown_QueryService(punk, SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pOleWindow));
    if (SUCCEEDED(hr))
    {
        hr = pOleWindow->GetWindow(phwnd);
        pOleWindow->Release();
    }
    return hr;
}


BOOL ILIsFolder(LPCITEMIDLIST pidl)
{
    BOOL fIsFolder = FALSE;
    DWORD dwAttributes = SFGAO_FOLDER;
    HRESULT hr = IEGetAttributesOf(pidl, &dwAttributes);

    if (SFGAO_FOLDER == dwAttributes)
        fIsFolder = TRUE;

    return fIsFolder;
}


STDAPI_(LPITEMIDLIST) IEGetInternetRootID(void)
{
    LPITEMIDLIST pidl;

    //
    //  HACKHACK - we want the pidl to the Internet SF
    //  so we make a dummy URL and parse it.  then
    //  we know its parent will be the Internet SF.
    //
    if (SUCCEEDED(IECreateFromPath(TEXT("dummy://url"), &pidl)))
    {
        ASSERT(!ILIsEmpty(_ILNext(pidl)));
        ASSERT(IsURLChild(pidl, FALSE));

        //  we only want the parent Internt SF
        _ILNext(pidl)->mkid.cb = 0;
        return pidl;
    }
    return NULL;
}

STDAPI_(void) UpdateButtonArray(TBBUTTON *ptbDst, const TBBUTTON *ptbSrc, int ctb, LONG_PTR lStrOffset)
{
    memcpy(ptbDst, ptbSrc, ctb*sizeof(TBBUTTON));
    if (lStrOffset == -1)
    {
        // handle failure case
        for (int i = 0; i < ctb; i++)
            ptbDst[i].iString = 0;
    }
    else
    {
        for (int i = 0; i < ctb; i++)
            ptbDst[i].iString += lStrOffset;
    }
}

//----------------------------------------------------------------------------
//  <Swipped from the NT5 version of Shell32>
//
STDAPI_(void) PathToAppPathKey(LPCTSTR pszPath, LPTSTR pszKey, int cchKey)
{
    // Use the szTemp variable of pseem to build key to the programs specific
    // key in the registry as well as other things...
    StrCpyN(pszKey, REGSTR_PATH_APPPATHS, cchKey);
    StrCatBuff(pszKey, TEXT("\\"), cchKey);
    StrCatBuff(pszKey, PathFindFileName(pszPath), cchKey);

    // Currently we will only look up .EXE if an extension is not
    // specified
    if (*PathFindExtension(pszKey) == 0)
    {
        StrCatBuff(pszKey, TEXT(".exe"), cchKey);
    }
}

//----------------------------------------------------------------------------
//  <Swipped from the NT5 version of Shell32>
//
// this function checks for the existance of a value called "useURL" under the
// App Paths key in the registry associated with the app that is passed in.

STDAPI_(BOOL) DoesAppWantUrl(LPCTSTR pszCmdLine)
{
    TCHAR szRegKeyName[MAX_PATH];
    HKEY hKeyAppPaths;
    BOOL bRet = FALSE;

// bug 61538 - The edit button never passes in args or quotes and the 
// code below was screwing up if there were spaces in the path.
//
    // need to copy the string since PathRemoveArgs whacks in a \0
//    TCHAR szTemp[MAX_PATH];
//    lstrcpyn(szTemp, pszCmdLine, ARRAYSIZE(szTemp));
//    PathRemoveArgs(szTemp);
//    PathUnquoteSpaces(szTemp);

    PathToAppPathKey(pszCmdLine, szRegKeyName, ARRAYSIZE(szRegKeyName));
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegKeyName, 0L, KEY_QUERY_VALUE, &hKeyAppPaths) == ERROR_SUCCESS)
    {
        bRet = RegQueryValueEx(hKeyAppPaths, TEXT("UseURL"), NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
        RegCloseKey(hKeyAppPaths);
    }

    return bRet;
}


// thread reference count object, this uses SHSetThreadRef()to let other code
// in this process hold a reference to this main thread, and thus the main thread in this process

class CRefThread : public IUnknown
{
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    CRefThread(LONG *pcRef);

private:
    ~CRefThread();

    LONG *_pcRef;
    UINT _idThread;
};


CRefThread::CRefThread(LONG *pcRef) 
{
    _idThread = GetCurrentThreadId();
    _pcRef = pcRef;
    *_pcRef = 1;

}

//
//  Note that this code tightens but does not close a race window.
//  Although we nuke the process reference, the class factory for
//  the web browser has yet to be deregistered, so if somebody decides
//  to create one, our class factory will wake up and create a
//  shell folder, which will flake out because it can't get a
//  process reference.
//
CRefThread::~CRefThread() 
{
    // Avoid re-entrancy during destruction
    *_pcRef = 1000;

    // If we are the process reference, then revoke the process reference
    // since we're going away.

    IUnknown *punk;
    SHGetInstanceExplorer(&punk);
    if (punk == this)
        SHSetInstanceExplorer(NULL);
    ATOMICRELEASE(punk);

    // Nobody should've rescued our reference
    ASSERT(*_pcRef == 1000);
    *_pcRef = 0;

    // get the other thread out of WaitMessage() or GetMessage()
    PostThreadMessage(_idThread, WM_NULL, 0, 0);
}


HRESULT CRefThread::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { { 0 }, };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CRefThread::AddRef()
{
    return InterlockedIncrement(_pcRef);
}

ULONG CRefThread::Release()
{
    if (InterlockedDecrement(_pcRef))
        return *_pcRef;

    delete this;
    return 0;
}

STDAPI SHCreateThreadRef(LONG *pcRef, IUnknown **ppunk)
{
    *ppunk = new CRefThread(pcRef);
    if (*ppunk)
        return S_OK;

    *pcRef = 0;
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

//
// Returns the cache file associated with a URL.  For file: urls, the associated
// disk file is returned.  Not that we don't use URLDownloadToCacheFile because 
// it causes another I-M-S GET to to be sent to the server
//
HRESULT URLToCacheFile
(
    LPCWSTR pszUrl,
    LPWSTR pszFile,
    int    cchFile
)
{
    HRESULT hr = E_FAIL;
    DWORD dwScheme = GetUrlScheme(pszUrl);
    if (URL_SCHEME_FILE == dwScheme)
    {
        ULONG cch = cchFile;
        hr = PathCreateFromUrl(pszUrl, pszFile, &cch, 0);
    }
    else
    {
        // bug 73386 - GetUrlCacheEntryInfoExW fails to find entries if there is an anchor
        // so we have to whack it off.
        //
        // We should really fix GetUrlCacheEntryInfoExW instead, but apparently 
        // this is risky for 5.x
        //
        WCHAR szUrlBuf[MAX_URL_STRING];
        if (URL_SCHEME_HTTP == dwScheme || URL_SCHEME_HTTPS == dwScheme)
        {
            LPWSTR pszAnchor = StrChr(pszUrl, L'#');
            if (pszAnchor)
            {
                int cch = (int)min((int)(pszAnchor - pszUrl + 1), ARRAYSIZE(szUrlBuf));
                StrCpyN(szUrlBuf, pszUrl, cch);
                pszUrl = szUrlBuf;
            }
        }

        char szBuf[1024];
        LPINTERNET_CACHE_ENTRY_INFOW pCE = (LPINTERNET_CACHE_ENTRY_INFOW)szBuf;
        DWORD dwEntrySize = sizeof(szBuf);

        BOOL fGotCacheInfo = GetUrlCacheEntryInfoExW(pszUrl, pCE, &dwEntrySize, NULL, NULL, NULL, 0);
        if (!fGotCacheInfo)
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // We guessed too small for the buffer so allocate the correct size & retry
                pCE = (LPINTERNET_CACHE_ENTRY_INFOW)LocalAlloc(LPTR, dwEntrySize);
                if (pCE)
                {
                    fGotCacheInfo = GetUrlCacheEntryInfoEx(pszUrl, pCE, &dwEntrySize, NULL, NULL, NULL, 0);
                }
            }
            else 
            {
                // Retry using UTF8 encoding 
                //
                // This fix belongs in GetUrlCacheEntryInfoEx (StevePro 01/19/99)
                //
                char szUrl[MAX_URL_STRING];
                if (SHUnicodeToAnsiCP(CP_UTF8, pszUrl, szUrl, ARRAYSIZE(szUrl)))
                {
                    szUrl[ARRAYSIZE(szUrl)-1] = '\0';   // paranoia

                    // UrlEscapeA Internally converts to unicode which messes up utf8.  So we
                    // copy the string to a WCHAR buffer without coverting and call the unicode version.
                    // Yuk!
                    WCHAR wzUrl[ARRAYSIZE(szUrl)];
                    char* psz = szUrl;
                    WCHAR* pwz = wzUrl;

                    while (*psz!= NULL)
                    {
                        *pwz++ = ((WCHAR)*psz++) & 0xff;
                    }
                    *pwz = L'\0';

                    ULONG cch = ARRAYSIZE(wzUrl);
                    UrlEscapeW(wzUrl, wzUrl, &cch, /*URL_ESCAPE_PERCENT*/0);

                    psz = szUrl;
                    pwz = wzUrl;
                    while (*pwz!= NULL) 
                    {
                        *psz++ = (char)LOWORD(*pwz++);
                    }
                    *psz = '\0';

                    LPINTERNET_CACHE_ENTRY_INFOA pCEA = (LPINTERNET_CACHE_ENTRY_INFOA)szBuf;
                    dwEntrySize = sizeof(szBuf);

                    BOOL fUtf8Worked = GetUrlCacheEntryInfoExA(szUrl, pCEA, &dwEntrySize, NULL, NULL, NULL, 0);
                    if (!fUtf8Worked)
                    {
                        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                        {
                            // We guessed too small for the buffer so allocate the correct size & retry
                            pCEA = (LPINTERNET_CACHE_ENTRY_INFOA)LocalAlloc(LPTR, dwEntrySize);
                            if (pCEA)
                            {
                                fUtf8Worked = GetUrlCacheEntryInfoExA(szUrl, pCEA, &dwEntrySize, NULL, NULL, NULL, 0);
                            }
                        }
                    }

                    if (fUtf8Worked)
                    {
                        SHAnsiToUnicode(pCEA->lpszLocalFileName, pszFile, cchFile);
                        hr = S_OK;
                    }

                    if ((char *)pCEA != szBuf)
                    {
                        LocalFree((HLOCAL)pCEA);
                    }
                }
            }
        }

        if (fGotCacheInfo)
        {
            StrCpyN(pszFile, pCE->lpszLocalFileName, cchFile);
            hr = S_OK;
        }

        // Free our GetUrlCacheEntryInfo buffer if we allocated one
        if ((char *)pCE != szBuf)
        {
            LocalFree((HLOCAL)pCE);
        }
    }
    return hr;
}

#ifdef DEBUG
void DebugDumpPidl(DWORD dwDumpFlag, LPTSTR pszOutputString, LPCITEMIDLIST pidl)
{
    if (g_dwDumpFlags & dwDumpFlag)
    {
        TCHAR szPath[MAX_PATH];
        LPTSTR lpsz;
        if (pidl)  
        {
            lpsz = szPath;
            SHGetPathFromIDList(pidl, szPath);
        } 
        else 
        {
            lpsz = TEXT("(NULL)");
        }
        TraceMsg(TF_ALWAYS, "%s: \"%s\"", pszOutputString, lpsz);
    }
}
#endif

// Variable argument version that ultimately call FormatMessageLiteW
BOOL __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...)
{
    BOOL fRet;
    va_list ArgList;
    va_start(ArgList, cchBuf);

    fRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING, szTemplate, 0, 0, szBuf, cchBuf, &ArgList);

    va_end(ArgList);
    return fRet;
}


// [msadek], On win9x we get the message thru a chain from explorer /iexplore (ANSI app.).
// and pass it to comctl32 (Unicode) so it will fail to match the hot key.
// the system sends the message with ANSI char and we treated it as Unicode.
// It looks like noone is affected with this bug (US, FE) since they have hot keys always in Latin.
// Bidi platforms are affected since they do have hot keys in native language.

WPARAM AnsiWparamToUnicode(WPARAM wParam)
{
    char szCh[2];
    WCHAR wszCh[2];
    szCh[0] = (BYTE)wParam;
    szCh[1] = '\0';

    if (MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szCh, ARRAYSIZE(szCh),
                                   wszCh, ARRAYSIZE(wszCh)))
    {
        memcpy(&wParam, wszCh, sizeof(WCHAR));
    }

    return wParam;
}

void SHOutlineRect(HDC hdc, const RECT* prc, COLORREF cr)
{
    RECT rc;
    COLORREF clrSave = SetBkColor(hdc, cr);
    
    //top
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->top + 1;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    //left
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->left + 1;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    //right
    rc.left = prc->right - 1;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    // bottom
    rc.left = prc->left;
    rc.top = prc->bottom - 1;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    SetBkColor(hdc, clrSave);
}

HMONITOR GetPrimaryMonitor()
{
    POINT pt = {0,0};
    return MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY); 
}

// Gets the Monitor's bounding or work rectangle, if the hMon is bad, return
// the primary monitor's bounding rectangle. 
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork)
{
    MONITORINFO mi; 
    mi.cbSize = sizeof(mi);
    if (hMon && GetMonitorInfo(hMon, &mi))
    {
        if (!prc)
            return TRUE;
        
        else if (bWork)
            CopyRect(prc, &mi.rcWork);
        else 
            CopyRect(prc, &mi.rcMonitor);
        
        return TRUE;
    }
    
    if (prc)
        SetRect(prc, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//  Utils to load background bitmap for toolbars etc.
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////



//------------------------------------------------------------------------
// determine source name for bitmap, sift thru IE history....
HRESULT _GetBackBitmapLocation(LPTSTR psz, BOOL fInternet)
{
    HRESULT hres = E_FAIL;
    DWORD dwType;
    DWORD dwcbData;
    static const TCHAR c_szRegKeyCoolbar[] = TSZIEPATH TEXT("\\Toolbar");

    // IE4 shipped back bitmap customization affecting both browser and shell.
    // IE5 wants these to be separate customizations.  But in the roaming
    // case a customized IE4 customer shouldn't lose customization when going
    // to the IE5 machine.  So we might need to check twice:
    //
    if (fInternet)
    {
        // Try the IE5 internet location.
        dwcbData = MAX_PATH * sizeof(TCHAR);
        hres = SHGetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, TEXT("BackBitmapIE5"), &dwType, psz, &dwcbData);
    }
    else
    {
        // Try the NT5 shell location.
        dwcbData = MAX_PATH * sizeof(TCHAR);
        hres = SHGetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, TEXT("BackBitmapShell"), &dwType, psz, &dwcbData);
    }
    if (ERROR_SUCCESS != hres)
    {
        // Try the old combined internet/shell location
        dwcbData = MAX_PATH * sizeof(TCHAR);
        hres = SHGetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, TEXT("BackBitmap"), &dwType, psz, &dwcbData);
    }

    return hres;
}


//------------------------------------------------------------------------
//  determine background settings and source for toolbar,
//  load bitmap (file/resource) and update cache
HBITMAP LoadToolbarBackBmp(LPTSTR * ppszBitmap, BMPCACHE * pbmpCache, BOOL fInternet)
{
    HIGHCONTRAST    hc;
    HBITMAP     hbmp = pbmpCache->hbmp;
    COLORREF    cr3D = GetSysColor(COLOR_3DFACE);
    TCHAR       szScratch[MAX_PATH];
    LPTSTR      pszBitmap = NULL;
    BOOL        fBitmapInvalid = FALSE;


    ENTERCRITICAL;

    // If the stashed hbmp's cr3D color changed, we need to mark invalid
    if (pbmpCache->hbmp && pbmpCache->cr3D != cr3D)
        fBitmapInvalid = TRUE;

    // get the location spec for the bitmap
    hc.cbSize = sizeof(HIGHCONTRAST);
    if ((SystemParametersInfoA(SPI_GETHIGHCONTRAST, hc.cbSize, (LPVOID) &hc, FALSE)) &&
        (hc.dwFlags & HCF_HIGHCONTRASTON))
    {
        // we have no bitmap in high contrast
    }
    else if (SUCCEEDED(_GetBackBitmapLocation(szScratch, fInternet)))
    {
        pszBitmap = szScratch;
    }

    // if they are removing the bitmap, we need to mark invalid
    if (!pszBitmap && *ppszBitmap)
        fBitmapInvalid = TRUE;

    // or it's location has been changed, we need to mark invalid
    if (pszBitmap && (!*ppszBitmap || lstrcmpi(pszBitmap, *ppszBitmap)))
        fBitmapInvalid = TRUE;

    if (fBitmapInvalid)
    {
        TraceMsg(DM_ITBAR, "LoadToolbarBackBmp: Loading Background Bitmap");

        Str_SetPtr(ppszBitmap, pszBitmap);

        hbmp=NULL;
        if (*ppszBitmap)
        {
            if ((*ppszBitmap)[0])
            {
                hbmp = (HBITMAP) LoadImage(NULL, szScratch, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE | LR_LOADMAP3DCOLORS );
            }

            if (!hbmp)
            {
#ifdef OLD_SWIRLY_BACKDROP
                if (SHGetCurColorRes() <= 8)
                    hbmp = (HBITMAP) LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_BACK), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADMAP3DCOLORS );
#endif
            }
        }

#ifdef OLD_LEGACY_BAD_COLOUR_CODE
        if (hbmp)
        {
            // mapping needed ?
            // DONTWORRYABOUTTHIS: this will be removed as soon as I get the new backdrop....
            if ( /* cr3D != RGB(192,192,192) */ FALSE)
            {
                RGBQUAD     rgbTable[256];
                RGBQUAD     rgbFace;
                HDC         dc;
                HBITMAP     hbmSave;
                UINT        i;
                UINT        n;

                dc = CreateCompatibleDC(NULL);
                hbmSave = (HBITMAP)SelectObject(dc, hbmp);
                n = GetDIBColorTable(dc, 0, 256, rgbTable);

                rgbFace.rgbRed   = GetRValue(cr3D);
                rgbFace.rgbGreen = GetGValue(cr3D);
                rgbFace.rgbBlue  = GetBValue(cr3D);

                for (i = 0; i < n; i++)
                {
                    if ( rgbTable[i].rgbRed == 192 && rgbTable[i].rgbGreen == 192 && rgbTable[i].rgbBlue == 192 )
                    {
                        rgbTable[i] = rgbFace;
                    }
                    else
                    {
                        rgbTable[i].rgbRed   = (rgbTable[i].rgbRed   * rgbFace.rgbRed  ) / 192;
                        rgbTable[i].rgbGreen = (rgbTable[i].rgbGreen * rgbFace.rgbGreen) / 192;
                        rgbTable[i].rgbBlue  = (rgbTable[i].rgbBlue  * rgbFace.rgbBlue ) / 192;
                    }
                }

                SetDIBColorTable(dc, 0, n, rgbTable);
                SelectObject(dc, hbmSave);
                DeleteDC(dc);
            }
        }
#endif

        if (pbmpCache->hbmp)
            DeleteObject(pbmpCache->hbmp);
        pbmpCache->hbmp = hbmp;
        pbmpCache->cr3D = cr3D;
    }

    LEAVECRITICAL;

    return hbmp;
}


VOID StripDecorations(PTSTR pszTitle, BOOL fStripAmp)
{
    LPTSTR  pszCleaned = pszTitle;    // work in-place
    LPCTSTR psz = pszTitle;
    while (*psz && (*psz != TEXT('\t')))
    {
        if (*psz != TEXT('&') || !fStripAmp)
        {
            *pszCleaned = *psz;
            pszCleaned++;
        }
        psz++;
    }
    *pszCleaned = TEXT('\0');
}

//------------------------------------------------------------------------
LPCTSTR UnescapeDoubleAmpersand(LPTSTR pszTitle)
{
    LPTSTR  pszCleaned = pszTitle;    // work in-place
    LPCTSTR psz = pszTitle;
    bool fEscapedAmp = false;
    while (*psz)
    {
        if (*psz != TEXT('&') || fEscapedAmp)
        {
            // copy character
            *pszCleaned = *psz;
            pszCleaned++;
            fEscapedAmp = false;
        }
        else
        {
            LPCTSTR pszNext = psz + 1;
            if (pszNext && (*pszNext == TEXT('&'))) {
                fEscapedAmp = true; // keep next ampersand
            }
        }
        psz++;
    }
    *pszCleaned = TEXT('\0');
    return pszTitle;
}

UINT MapClsidToID(REFCLSID rclsid)
{
    UINT nCmdID;

    nCmdID = 0;

    if (IsEqualCLSID(CLSID_SearchBand, rclsid))
        nCmdID = FCIDM_VBBSEARCHBAND;
    else if (IsEqualCLSID(CLSID_FavBand, rclsid))
        nCmdID = FCIDM_VBBFAVORITESBAND;
    else if (IsEqualCLSID(CLSID_HistBand, rclsid))
        nCmdID = FCIDM_VBBHISTORYBAND;
    else if (IsEqualCLSID(CLSID_ExplorerBand, rclsid))
        nCmdID = FCIDM_VBBEXPLORERBAND;
    else if (IsEqualCLSID(CLSID_FileSearchBand, rclsid))
        nCmdID = FCIDM_VBBSEARCHBAND;

    return nCmdID;        
}


// Create mask from given bitmap, use color at pixel (x/y) as transparent color
HBITMAP CreateMaskBitmap(HDC hdc, int x, int y, HBITMAP hbmpImage)
{
    ASSERT(hbmpImage);
    BITMAP bm;
    if (::GetObject(hbmpImage, sizeof(BITMAP), &bm) != sizeof(BITMAP)) {
        return FALSE;
    }

    HDC hdcImg = NULL;
    HDC hdcMask = NULL;
    HBITMAP hbmpMask = NULL;
    HBITMAP hbmpOldImg = NULL;
    HBITMAP hbmpOldMsk = NULL;
    COLORREF clrTransparent = 0;

    hdcImg = ::CreateCompatibleDC(hdc);
    if (hdcImg == NULL)     goto _CMBcleanup;
    hdcMask = ::CreateCompatibleDC(hdc);
    if (hdcMask == NULL)    goto _CMBcleanup;

    hbmpMask = ::CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
    if (hbmpMask == NULL)   goto _CMBcleanup;
    hbmpOldImg = (HBITMAP) ::SelectObject(hdcImg, hbmpImage);
    hbmpOldMsk = (HBITMAP) ::SelectObject(hdcMask, hbmpMask);

    clrTransparent = ::GetPixel(hdcImg, 0, 0);
    ::SetBkColor(hdcImg, clrTransparent);
    ::BitBlt(hdcMask, 0, 0, bm.bmWidth, bm.bmHeight, hdcImg, 0, 0, SRCCOPY);

_CMBcleanup:
    if (hbmpOldImg && hdcImg)
        SelectObject(hdcImg, hbmpOldImg);
    if (hdcImg)
        DeleteDC(hdcImg);
    if (hbmpOldMsk && hdcMask)
        SelectObject(hdcMask, hbmpOldMsk);
    if (hdcMask)
        DeleteDC(hdcMask);

    return hbmpMask;
}

// draw bitmap transparently; on Win2K and up, one could use MaskBlt()
BOOL DrawTransparentBitmapPart(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbmpImage, HBITMAP hbmpMask)
{
    ASSERT(hbmpImage);
    BITMAP bm;
    if (::GetObject(hbmpImage, sizeof(BITMAP), &bm) != sizeof(BITMAP)) {
        return FALSE;
    }

    HBITMAP hbmpTmpMask = NULL;
    // create temporary mask bitmap if none supplied
    if (hbmpMask == NULL) {
        hbmpMask = hbmpTmpMask = CreateMaskBitmap(hdc, 0, 0, hbmpImage);
    }
    if (hbmpMask == NULL) {
        return FALSE;
    }

    HDC hdcOffScr = NULL;
    HBITMAP hbmOffScr = NULL;
    HBITMAP hbmOldOffScr = NULL;
    HDC hdcImage = NULL;
    HBITMAP hbmOldImage = NULL;
    HDC hdcMask = NULL;
    HBITMAP hbmOldMask = NULL;

    // draw.to offscreen bitmap
    hdcOffScr = ::CreateCompatibleDC(hdc);
    if (hdcOffScr == NULL)      goto _DTBcleanup;
    hbmOffScr = ::CreateBitmap(dx, dy,GetDeviceCaps(hdc, PLANES),
                               (BYTE)GetDeviceCaps(hdc, BITSPIXEL), NULL);
    if (hbmOffScr == NULL)      goto _DTBcleanup;
    hbmOldOffScr = (HBITMAP)::SelectObject(hdcOffScr, hbmOffScr);

    // Copy the image of the destination rectangle to the
    // off-screen buffer DC, so we can play with it.
    ::BitBlt(hdcOffScr, 0, 0, dx, dy, hdc, x, y, SRCCOPY);

    // prepare DCs for both image and mask
    hdcImage = ::CreateCompatibleDC(hdc); 
    if (hdcImage == NULL)       goto _DTBcleanup;
    hbmOldImage = (HBITMAP)::SelectObject(hdcImage, hbmpImage);
    hdcMask = ::CreateCompatibleDC(hdc);
    if (hdcMask == NULL)        goto _DTBcleanup;
    hbmOldMask = (HBITMAP)::SelectObject(hdcMask, hbmpMask);

    ::SetBkColor(hdcOffScr, RGB(255,255,255));
    ::BitBlt(hdcOffScr, 0, 0, dx, dy, hdcImage, 0, 0, SRCINVERT);
    ::BitBlt(hdcOffScr, 0, 0, dx, dy, hdcMask,  0, 0, SRCAND);
    ::BitBlt(hdcOffScr, 0, 0, dx, dy, hdcImage, 0, 0, SRCINVERT);

    // Copy the resultant image back to the screen DC.
    ::BitBlt(hdc,       x, y, dx, dy, hdcOffScr, 0, 0, SRCCOPY);

_DTBcleanup:
    if (hdcOffScr && hbmOldOffScr)
        ::SelectObject(hdcOffScr, hbmOldOffScr);
    if (hdcOffScr)
        ::DeleteDC(hdcOffScr);
    if (hbmOffScr)
        ::DeleteObject(hbmOffScr);

    if (hdcImage && hbmOldImage)
        ::SelectObject(hdcImage, hbmOldImage);
    if (hdcImage)
        ::DeleteDC(hdcImage);

    if (hdcMask && hbmOldMask)
        ::SelectObject(hdcMask, hbmOldMask);
    if (hdcMask)
        ::DeleteDC(hdcMask);
    if (hbmpTmpMask)
        ::DeleteObject(hbmpTmpMask);

    return TRUE;
}

// draw bitmap transparently; on Win2K and up, one could use MaskBlt()
BOOL DrawTransparentBitmap(HDC hdc, int x, int y, HBITMAP hbmpImage, HBITMAP hbmpMask)
{
    ASSERT(hbmpImage);
    BITMAP bm;
    if (::GetObject(hbmpImage, sizeof(BITMAP), &bm) != sizeof(BITMAP)) {
        return FALSE;
    }

    return DrawTransparentBitmapPart(hdc, x, y, bm.bmWidth, bm.bmHeight, hbmpImage, hbmpMask);
}

//------------------------------------------------------------------------
BOOL
    DrawAlphaBitmap(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbmpImage)
{
    BLENDFUNCTION bf = {0};
    HDC hdcImage = ::CreateCompatibleDC(hdc);
    if (hdcImage == NULL) {
        return false;
    }
    HBITMAP hbmOldImage = (HBITMAP)::SelectObject(hdcImage, hbmpImage);

    bf.BlendOp = AC_SRC_OVER;
    bf.SourceConstantAlpha = 255;
    bf.AlphaFormat = AC_SRC_ALPHA;
    AlphaBlend(hdc, x, y, dx, dy, hdcImage, 0, 0, dx, dy, bf);
    
    if (hbmOldImage) {
        SelectObject(hdcImage, hbmOldImage);
    }
    DESTROY_OBJ_WITH_HANDLE(hdcImage, DeleteObject);

    return true;
}


STDAPI_(IDeskBand *) FindBandByClsidBS(IBandSite *pbs, REFCLSID clsidToFind)
{
    DWORD dwBandID;
    for (int i = 0; SUCCEEDED(pbs->EnumBands(i, &dwBandID)); i++) 
    {
        IDeskBand *pstb;
        HRESULT hr = pbs->QueryBand(dwBandID, &pstb, NULL, NULL, 0);
        if (SUCCEEDED(hr)) 
        {
            CLSID clsid;

            hr = IUnknown_GetClassID(pstb, &clsid);
            if (SUCCEEDED(hr) && IsEqualGUID(clsidToFind, clsid)) 
            {
                return pstb;
            }
            pstb->Release();
        }
    }

    return NULL;
}

HIMAGELIST CreateImageList(HINSTANCE hi, LPCTSTR lpbmp, int cx, int cGrow, COLORREF crMask,
                           UINT uType, UINT uFlags, BOOL bUseNewMirroringSupport)
{
    HBITMAP hbmImage;
    HIMAGELIST piml = NULL;
    BITMAP bm;
    int cy, cInitial;
    UINT flags;

    hbmImage = (HBITMAP)LoadImage(hi, lpbmp, uType, 0, 0, uFlags);
    if (hbmImage && (sizeof(bm) == GetObject(hbmImage, sizeof(bm), &bm)))
    {
        // If cx is not stated assume it is the same as cy.
        // ASSERT(cx);
        cy = bm.bmHeight;

        if (cx == 0)
            cx = cy;

        cInitial = bm.bmWidth / cx;

        ENTERCRITICAL;

        if (bUseNewMirroringSupport)
        {
            flags = ILC_MIRROR | PrivateILC_PERITEMMIRROR;
        }
        else
        {
            flags = 0;
        }

        if (crMask != CLR_NONE)
            flags |= ILC_MASK;
        if (bm.bmBits)
            flags |= (bm.bmBitsPixel & ILC_COLORMASK);

        piml = ImageList_Create(cx, cy, flags, cInitial, cGrow);
        if (piml)
        {
            int added;

            if (crMask == CLR_NONE)
                added = ImageList_Add(piml, hbmImage, NULL);
            else
                added = ImageList_AddMasked(piml, hbmImage, crMask);

            if (added < 0)
            {
                ImageList_Destroy(piml);
                piml = NULL;
            }
        }
        LEAVECRITICAL;
    }

    if (hbmImage)
        DeleteObject(hbmImage);

    return piml;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\emclient\libem.h ===
//***
//

#define YY_NODYNRULES   // ISSUE: suppress emrule.h DEBUG=>DYNRULES
#define YY_CTOR     1
#define YY_DELAYED  1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\emclient\libem.c ===
//***   libem.c -- 'source library' inclusions for client-side evtmon stuff
// DESCRIPTION
//  some of the client-side evtmon stuff needs to be built by us, in our
// context (rather than pulled in from emsvr .obj or .lib or .dll)
// this file builds it in the current directory (and in our *.h context).
// NOTES

#include "priv.h"

#include "libem.h"   // configure genem.c and other client-side stuff
#include "genem.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\emclient\makefile.inc ===
# special stuff for evtmon
# the -D's come from the office guys' original 'emtest' sample app
# WARNING: DEBUG implies DYN_RULE for some reason
EM_DEFINES  =
EM_DEFINES  = $(EM_STUFF) \
    -DSTANDALONE -DSTANDALONE_WIN32 \
    -DSTATIC_INIT -DANSI_XCHAR

# static  EM-supplied    hdrs/srcs come from evtmon/inc
# dynamic rulc-generated hdrs/srcs come from -I$O
# the -I$O is semi-weird but they're config-dependent so they need to go there
EM_INCLUDES =
EM_INCLUDES = $(EM_INCLUDES);$(CCSHELL_DIR)\inc\evtmon
EM_INCLUDES = $(EM_INCLUDES);$O

# rulc generated headers, from ierules.rul
# we'd like to key off of all of these, but they're not always
# created (sigh), so for now we key off emeval.c, which always is
YYHDR   = \
        $O\emdef.h $O\emacts.h $O\emactr.h $O\emruli.h \
        $O\emeval.c $O\emsqck.c_ $O\emact.c_
YYHDR   = $O\emeval.c

YYSRC   = $(CCSHELL_DIR)\lib\genem.c
# BUGBUG tmp hack until we put genem.c in shell/lib/evtmon
YYSRC   = $(CCSHELL_DIR)\inc\evtmon\genem.c

$O\libem.obj : libem.c $(YYSRC) $(YYHDR)

# rulc puts its stuff in "." so we need to pushd/popd around it
# also rulc doesn't (re)gen 'unneeded' files so we need to cleanup beforehand
# we 
$(YYHDR) : ierules.rul
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS) ierules.rul > $(O)\ierules.rl
        cd $O
        del emdef.h emactr.h emacts.h emruli.h
        del emeval.c emact.c_ emfilt.c
        rulc ierules.rl
        cd $(CCSHELL_DIR)\browseui\emclient


!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\emclient\regdb.h ===
//***   CEMDBLog --
//
#define XXX_CACHE   1       // caching on

class CEMDBLog : public IUASession
{
public:
    ULONG AddRef(void)
        {
            return InterlockedIncrement(&_cRef);
        }

    ULONG Release(void)
        {
            if (InterlockedDecrement(&_cRef))
                return _cRef;

            delete this;
            return 0;
        }

    //*** THISCLASS
    virtual HRESULT Initialize(HKEY hkey, DWORD grfMode);
    HRESULT SetRoot(HKEY hkey, DWORD grfMode);
    HRESULT ChDir(LPCTSTR pszSubKey);
    // fast versions, no OLESTR nonsense
    HRESULT QueryValueStr(LPCTSTR pszName, LPTSTR pszValue, LPDWORD pcbValue);
    HRESULT SetValueStr(LPCTSTR pszName, LPCTSTR pszValue);
    HRESULT SetValueStrEx(LPCTSTR pszName, DWORD dwType, LPCTSTR pszValue);

    /*virtual HRESULT Initialize(HKEY hk, DWORD grfMode);*/
    HRESULT QueryValue(LPCTSTR pszName, BYTE *pbData, LPDWORD pcbData);
    HRESULT SetValue(LPCTSTR pszName, DWORD dwType, const BYTE *pbData, DWORD cbData);
    HRESULT DeleteValue(LPCTSTR pszName);
    HRESULT RmDir(LPCTSTR pszName, BOOL fRecurse);

    HKEY GetHkey()  { return _hkey; }

    // IUASession
    virtual void SetSession(UAQUANTUM uaq, BOOL fForce);
    virtual int GetSessionId();

    // THISCLASS
    HRESULT GetCount(LPCTSTR pszCmd);
    HRESULT IncCount(LPCTSTR pszCmd);
    FILETIME GetFileTime(LPCTSTR pszCmd);
    HRESULT SetCount(LPCTSTR pszCmd, int cCnt);
    HRESULT SetFileTime(LPCTSTR pszCmd, const FILETIME *pft);
    DWORD _SetFlags(DWORD dwMask, DWORD dwFlags);
    HRESULT GarbageCollect(BOOL fForce);


protected:
    CEMDBLog();
    friend CEMDBLog *CEMDBLog_Create();
    friend void CEMDBLog_CleanUp();
    friend class CGCTask;

    // THISCLASS helpers
    HRESULT _GetCountWithDefault(LPCTSTR pszCmd, BOOL fDefault, CUACount *pCnt);
    HRESULT _GetCountRW(LPCTSTR pszCmd, BOOL fUpdate);
    static HRESULT s_Read(void *pvBuf, DWORD cbBuf, PNRWINFO prwi);
    static HRESULT s_Write(void *pvBuf, DWORD cbBuf, PNRWINFO prwi);
    static HRESULT s_Delete(void *pvBuf, DWORD cbBuf, PNRWINFO prwi);
#if XXX_CACHE
    typedef enum e_cacheop { CO_READ=0, CO_WRITE=1, CO_DELETE=2, } CACHEOP;
    HRESULT CacheOp(CACHEOP op, void *pvBuf, DWORD cbBuf, PNRWINFO prwi);
#endif
    TCHAR *_MayEncrypt(LPCTSTR pszSrcPlain, LPTSTR pszDstEnc, int cchDst);
    HRESULT IsDead(LPCTSTR pszCmd);
    HRESULT _GarbageCollectSlow();

    static FNNRW3 s_Nrw3Info;
#if XXX_CACHE
    struct
    {
        UINT  cbSize;
        void* pv;
    } _rgCache[2];
#endif
protected:
    virtual ~CEMDBLog();

    long _cRef;
    HKEY    _hkey;
    int     _grfMode;   // read/write (subset of STGM_* values)


    BITBOOL     _fNoPurge : 1;      // 1:...
    BITBOOL     _fBackup : 1;       // 1:simulate delete (debug)
    BITBOOL     _fNoEncrypt : 1;    // 1:...
    BITBOOL     _fNoDecay : 1;      // 1:...

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\emclient\uacount.cpp ===
//***   CUACount -- user-assistance counter w/ decay
// NOTES
//  todo: scavenging to clean out registry.  but see caveats in UAC_CDEF.

#include "priv.h"
#include "uacount.h"
#include "uareg.h"

#define DM_UEMTRACE     TF_UEM

#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

//***   UAC_CDEFAULT -- initial _cCnt for entry (we *always* show items)
// NOTES
//  eventually we might want to scavenge all entries, decaying them down
// and deleting any that decay to 0.  note however that this will cause
// them to look like they have a default count of 1 (see CUAC::Init), so
// they'll suddenly appear on the menus again.
#define UAC_CDEFAULT    0       // initial _cCnt for entry

#define SID_SDEFAULT    SID_SNOWREAD    // initial _sidMru for new entry


//***
// NOTES
//  it's getting to the point that we should disallow stack-alloc'ed
// guys and instead count on new() to 0-init us.
CUACount::CUACount()
{
    // Since this is created on the stack, we don't get the benefits of the 
    // Heap allocator's zero initialization...
    ZeroMemory(_GetRawData(), _GetRawCount());

    _fInited = FALSE;   // need to call Initialize
#if XXX_VERSIONED
    _cbSize = -1;
#endif
#if XXX_DELETE
    _fInherited = FALSE;
#endif
    _fDirty = FALSE;
    _fNoDecay = _fNoPurge = FALSE;

    return;
}

#ifdef DEBUG
BOOL CUACount::DBIsInit()
{
#if XXX_VERSIONED
    ASSERT((_cbSize == SIZEOF(SUACount)) == BOOLIFY(_fInited));
#endif
    return _fInited;
}
#endif

HRESULT CUACount::Initialize(IUASession *puas)
{
    _puas = puas;
    if (!_fInited) {
        _fInited = TRUE;
#if XXX_VERSIONED
        // todo: _cbSize -1 means no entry, < SIZEOF means version upgrade
        _cbSize = SIZEOF(SUACount);
#endif
        // hardcode the SZ_CUACount_ctor values here
        _cCnt = UAC_CDEFAULT;       // all items start out visible
        _sidMruDisk = SID_SNOWREAD; // ... and non-aged
    }

    _sidMru = _sidMruDisk;
    if (ISSID_SSPECIAL(_sidMruDisk)) {
        _sidMru = _ExpandSpecial(_sidMruDisk);
        if (_sidMruDisk == SID_SNOWINIT) {
            _sidMruDisk = _sidMru;
            _fDirty = TRUE;
        }
        else if (_sidMruDisk == SID_SNOWREAD) {
            _sidMruDisk = _sidMru;
            ASSERT(!_fDirty);
        }
    }

    return S_OK;
}

HRESULT CUACount::LoadFrom(PFNNRW3 pfnIO, PNRWINFO pRwi)
{
    HRESULT hr;

    hr = (*pfnIO->_pfnRead)(_GetRawData(), _GetRawCount(), pRwi);
    if (SUCCEEDED(hr))
        _fInited = TRUE;
    return hr;
}

HRESULT CUACount::SaveTo(BOOL fForce, PFNNRW3 pfnIO, PNRWINFO pRwi)
{
    HRESULT hr;

    hr = S_FALSE;
    if (fForce || _fDirty) {
        if (!ISSID_SSPECIAL(_sidMruDisk)) 
            _sidMruDisk = _sidMru;
#if XXX_DELETE
        if (_cCnt == 0 && !_fNoPurge && pfnIO->_pfnDelete)
            hr = (*pfnIO->_pfnDelete)(_GetRawData(), _GetRawCount(), pRwi);
        else
#endif
        hr = (*pfnIO->_pfnWrite)(_GetRawData(), _GetRawCount(), pRwi);
        // ASSERT(SUCCEEDED(hr)); // this legitimately happens (low memory, access denied)
        _fDirty = FALSE;
    }
    return hr;
}

//***   GetCount -- get count info (w/ lazy decay)
//
int CUACount::GetCount()
{
    ASSERT(DBIsInit());

    int cCnt = _DecayCount(FALSE);

    return cCnt;
}

void CUACount::IncCount()
{
    AddCount(1);
    return;
}

void CUACount::AddCount(int i)
{
    ASSERT(DBIsInit());

    _DecayCount(TRUE);
    _cCnt += i;

    if (_cCnt == 0 && i > 0) {
        // nt5:173048
        // handle wrap
        // should never happen, but what the heck
        // do *not* remove this assert, if we ever let people do DecCount
        // we'll need to rethink it...
        ASSERT(0);  // 'impossible'
        _cCnt++;
    }

    // 981029 new incr algorithm per ie5 PM
    // UAC_MINCOUNT: initial inc starts at 6
    // _fNoDecay: but, UAssist2 doesn't do this
    if (_cCnt < UAC_MINCOUNT && !_fNoDecay)
        _cCnt = UAC_MINCOUNT;

    return;
}

//***
// NOTES
//  should we update the timestamp?  maybe add a fMru param?
void CUACount::SetCount(int cCnt)
{
    ASSERT(DBIsInit());

    _cCnt = cCnt;

    return;
}

void CUACount::SetFileTime(const FILETIME *pft)
{
    ASSERT(DBIsInit());

    _ftExecuteTime = *pft;

    return;
}



#if XXX_DELETE
#define BTOM(b, m)  ((b) ? (m) : 0)

DWORD CUACount::_SetFlags(DWORD dwMask, DWORD dwFlags)
{
    // standard guys
    if (dwMask & UAXF_NOPURGE)
        _fNoPurge = BOOLIFY(dwFlags & UAXF_NOPURGE);
#if 0
    if (dwMask & UAXF_BACKUP)
        _fBackup = BOOLIFY(dwFlags & UAXF_BACKUP);
#endif
    if (dwMask & UAXF_NODECAY)
        _fNoDecay = BOOLIFY(dwFlags & UAXF_NODECAY);

    // my guys
    if (dwMask & UACF_INHERITED)
        _fInherited = BOOLIFY(dwFlags & UACF_INHERITED);

    return 0    // n.b. see continuation line(s)!!!
#if XXX_DELETE
        | BTOM(_fInherited, UACF_INHERITED)
#endif
        | BTOM(_fNoPurge, UAXF_NOPURGE)
        | BTOM(_fNoDecay, UAXF_NODECAY)
        ;
}
#endif

//***   PCTOF -- p% of n (w/o floating point!)
//
#define PCTOF(n, p)   (((n) * (p)) / 100)

//***   _DecayCount -- decay (and propagate) count
// ENTRY/EXIT
//  fWrite  TRUE if want to update object and timestamp, o.w. FALSE
//  cNew    (return) new count
// DESCRIPTION
//  on a read, we do the decay but don't update the object.  on the write
// we decay and update.
// NOTES
//  todo: if/when we make cCnt a vector, we can propagate stuff here.
// this would allow us to usually inc a single small-granularity elt,
// and propagate to the large-gran elts only when we really need them.
//  perf: we could make the table 'cumulative', then we wouldn't have
// to do as much computation.  not worth the trouble...
int CUACount::_DecayCount(BOOL fWrite)
{
    int cCnt;

    cCnt = _cCnt;
    if (cCnt > 0 || fWrite) {
        UINT sidNow;

        sidNow = _puas->GetSessionId();

        if (!_fNoDecay) {
            // from mso-9 spec
            // last used 'timTab' sessions ago => dec by >-of abs, pct
            // n.b. this table is non-cumulative
            static const int timTab[] = { 3, 6, 9, 12, 17, 23, 29,  31,  -1, };
            static const int absTab[] = { 1, 1, 1,  2,  3,  4,  5,   0,   0, };
            static const int pctTab[] = { 0, 0, 0, 25, 25, 50, 75, 100, 100, };

            UINT sidMru;
            int dt;
            int i;

            sidMru = _sidMru;
            ASSERT(!ISSID_SSPECIAL(_sidMru));

            ASSERT(sidMru != SID_SDEFAULT);
            if (sidMru != SID_SDEFAULT) {
                dt = sidNow - sidMru;
                // iterate fwd not bkwd so bail early in common case
                for (i = 0; i < ARRAYSIZE(timTab); i++) {
                    if ((UINT)dt < (UINT)timTab[i])
                        break;

                    cCnt -= MAX(absTab[i], PCTOF(cCnt, pctTab[i]));
                    // don't go negative!
                    // gotta check *each* time thru loop (o.w. PCT is bogus)
                    cCnt = MAX(0, cCnt);
                }
            }
        }

        if (cCnt != _cCnt)
            TraceMsg(DM_UEMTRACE, "uac.dc: decay %d->%d", _cCnt, cCnt);

        if (fWrite) {
            _sidMru = sidNow;
            _cCnt = cCnt;
        }

#if XXX_DELETE
        if (cCnt == 0 && !_fInherited) {
            // if we decay down to 0, mark so it will be deleted
            TraceMsg(DM_UEMTRACE, "uac.dc: decay %d->%d => mark dirty pRaw=0x%x", _cCnt, cCnt, _GetRawData());
            _cCnt = 0;
            _fDirty = TRUE;
        }
#endif
    }

    return cCnt;
}

//***
// NOTES
//   perf: currently all special guys return sidNow so no 'switch' necessary
UINT CUACount::_ExpandSpecial(UINT sidMru)
{
    UINT sidNow;

    if (EVAL(ISSID_SSPECIAL(sidMru))) {
        ASSERT(_puas);
        sidNow = _puas->GetSessionId();     // perf: multiple calls
        switch (sidMru) {
        case SID_SNOWALWAYS:
            return sidNow;
            //break;

        case SID_SNOWREAD:
        case SID_SNOWINIT:
            return sidNow;
            //break;

#ifdef DEBUG
        default:
            ASSERT(0);
            break;
#endif
        }
    }

    return sidMru;
}


// Return the encoded filetime. This is read from the registry or
// generated from UpdateFileTime.
FILETIME CUACount::GetFileTime()
{
    return _ftExecuteTime;
}

// Updates the internal filetime information. This info
// will be later persisted to the registry.
void CUACount::UpdateFileTime()
{
    SYSTEMTIME st;
    // Get the current system time.
    GetSystemTime(&st);

    // This is done for ARP. They use filetimes, not the system time 
    // for the calculation of the last execute time.
    SystemTimeToFileTime(&st, &_ftExecuteTime);
}


// {
//***   UATIME --

//***   FTToUATime -- convert FILETIME to UATIME
// DESCRIPTION
//  UATIME granularity is (approximately) 1 minute.  the math works out
// roughly as follows:
//      filetime granularity is 100 nanosec
//      1 ft = 10^-7 sec
//      highword is 2^32 ft = 2^32 * 10^-7 sec
//      1 sec = hiw / (2^32 * 10^-7)
//      1 min = hiw * 60 / (2^32 * 10^-7)
//          = hiw * 60 / (1G * 10^-7)
//          ~= hiw * 60 / ~429
//          = hiw / 7.15
//          ~= hiw / 8 approx
//  the exact granularity is:
//      ...
#define FTToUATime(pft)  ((DWORD)(*(_int64 *)(pft) >> 29))  // 1 minute (approx)

//***   GetUaTime -- convert systemtime (or 'now') to UATIME
//
UATIME GetUaTime(LPSYSTEMTIME pst)
{
    FILETIME ft;
    UATIME uat;

    if (pst == NULL)
    {
        GetSystemTimeAsFileTime(&ft);
    }
    else
    {
        SystemTimeToFileTime(pst, &ft);
    }

    uat = FTToUATime(&ft);    // minutes

    return uat;
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\emclient\uareg.h ===
//***   uareg.h -- UAssist registry settings and flags
//

//***   SZ_* -- registry locations
//
#define SZ_UASSIST          TEXT("UserAssist")
#define SZ_UASSIST2         TEXT("UserAssist2")
  #define SZ_SETTINGS         TEXT("Settings")
    #define SZ_SESSTIME         TEXT("SessionTime")
    #define SZ_IDLETIME         TEXT("IdleTime")
    #define SZ_CLEANTIME        TEXT("CleanupTime")
    #define SZ_NOPURGE          TEXT("NoPurge")     // (debug) don't nuke 0s
    #define SZ_BACKUP           TEXT("Backup")      // (debug) simulate deletes
    #define SZ_NOLOG            TEXT("NoLog")
    #define SZ_INSTRUMENT       TEXT("Instrument")
    #define SZ_NOENCRYPT        TEXT("NoEncrypt")   // (debug) don't encrypt
//{guid}
    #define SZ_UAVERSION      TEXT("Version")
    #define SZ_COUNT          TEXT("Count")
//    #define SZ_CTLSESSION     TEXT("UEME_CTLSESSION")
//    #define SZ_CUACount_ctor  TEXT("UEME_CTLCUACount:ctor")

//***   UA*F_* -- flags
// standard, shared by some of {CUserAssist,CUADbase,CUACount}
#define UAXF_NOPURGE    0x01000000
#define UAXF_BACKUP     0x02000000
#define UAXF_NOENCRYPT  0x04000000
#define UAXF_NODECAY    0x08000000
#define UAXF_RESERVED2  0x10000000
#define UAXF_RESERVED3  0x20000000
#define UAXF_RESERVED4  0x40000000
#define UAXF_RESERVED5  0x80000000

#define UAXF_XMASK      0xff000000

// for CUserAssist API
#define UAAF_NOLOG      0x01
#define UAAF_INSTR      0x02

// for CUADbase
#define UADF_UNUSED     0x01

// for CUACount
#define UACF_UNUSED     0x01


//***
//
#define UEMIND_NINSTR   0
#ifdef UAAF_INSTR
#undef  UEMIND_NINSTR
#define UEMIND_NINSTR   2

#define UEMIND_SHELL2   (UEMIND_SHELL + UEMIND_NINSTR)
#define UEMIND_BROWSER2 (UEMIND_BROWSER + UEMIND_NINSTR)
#endif

#define IND_NONINSTR(iGrp) \
    (!IND_ISINSTR(iGrp) ? (iGrp) : ((iGrp) - UEMIND_NINSTR))
#define IND_ISINSTR(iGrp)   (UEMIND_NINSTR && iSvr >= UEMIND_NINSTR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\emclient\regdb.cpp ===
#include "priv.h"
#include <runtask.h>
#include "uacount.h"
#include "regdb.h"
#include "uemapp.h"
#include "uareg.h"

#define DM_UEMTRACE     TF_UEM
#define DM_PERF         0           // perf tune

#define DB_NOLOG        FALSE

#define SZ_CTLSESSION       TEXT("UEME_CTLSESSION")
#define SZ_CUACount_ctor    TEXT("UEME_CTLCUACount:ctor")

#define SZ_DEL_PREFIX       TEXT("del.")
#define SZ_RUN_PREFIX       TEXT("UEME_RUN")


//***   Reg_CreateOpenKey -- merged RegCreate/RegOpen
//
HKEY Reg_CreateOpenKey(HKEY hkey, LPCTSTR pszSubKey, DWORD grfMode)
{
    HKEY hkeyNew = 0;
    long i;
    CHAR szSubKey[MAXIMUM_SUB_KEY_LENGTH];

    SHTCharToAnsi(pszSubKey, szSubKey, ARRAYSIZE(szSubKey));
    ASSERT(grfMode == STGM_READ || grfMode == STGM_WRITE);

    ASSERT(pszSubKey != NULL);
    if (pszSubKey != NULL) {
        if (grfMode == STGM_READ) {
            i = RegOpenKeyA(hkey, szSubKey, &hkeyNew);
        }
        else {
            i = RegCreateKeyA(hkey, szSubKey, &hkeyNew);
        }
        // the following ASSERT is not req'd but is currently always true.
        // if you hit it, the bug is someplace in the caller.
        // i.e. do *not* remove this ASSERT to 'fix' your pblm.
        // a typical cause of failure is that CoCreateInst is failing because
        // something isn't properly regsvr32'ed.
        ASSERT(i == ERROR_SUCCESS || hkeyNew == 0);
    }

    return hkeyNew;
}


//***
// DESCRIPTION
//  inc this any time you change the format of *anything* below {guid}
//  doing so will cause us to nuke the {guid} subtree and start fresh
#define UA_VERSION      3

#if 0
char c_szDotDot[] = TEXT("..");     // RegStrFS does *not* support
#endif


// kind of hoaky to do INITGUID, but we want the GUID private to this file
#define INITGUID
#include <initguid.h>
// {C28EB156-523C-11d2-A561-00A0C92DBFE8}
DEFINE_GUID(CLSID_GCTaskTOID,
    0xc28eb156, 0x523c, 0x11d2, 0xa5, 0x61, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
#undef  INITGUID


class CGCTask : public CRunnableTask
{
public:
    //*** IUnknown
    // (... from CRunnableTask)

    //*** THISCLASS
    HRESULT Initialize(CEMDBLog *that);
    virtual STDMETHODIMP RunInitRT();

protected:
    CGCTask();
    virtual ~CGCTask();

    friend CGCTask *CGCTask_Create(CEMDBLog *that);

    CEMDBLog    *_that;
};


// {
//***   CEMDBLog --

//CRITICAL_SECTION g_csDbSvr /*=0*/ ;

CEMDBLog *g_uempDbSvr[UEMIND_NSTANDARD + UEMIND_NINSTR];    // 0=shell 1=browser

//***   g_fDidUAGC -- breadcrumbs in case we die (even non-DEBUG)
// keep minimal state in case we deadlock or die or whatever
// 0:not 1:pre-task 2:pre-GC 3:post-GC
int g_fDidUAGC;


FNNRW3 CEMDBLog::s_Nrw3Info = {
    CEMDBLog::s_Read,
    CEMDBLog::s_Write,
    CEMDBLog::s_Delete,
};

//*** helpers {

//***
// NOTES
//  or, could use Reg_CreateOpenKey(..., STGM_READ) if we removed the asserts
STDAPI_(DWORD) SHRegOpenKey(HKEY hk, LPCTSTR ptszSubKey, PHKEY phkOut)
{
    long i;
    CHAR szSubKey[MAXIMUM_SUB_KEY_LENGTH];
    CHAR *psz;

    if (ptszSubKey) {
        SHTCharToAnsi(ptszSubKey, szSubKey, ARRAYSIZE(szSubKey));
        psz = szSubKey;
    }
    else {
        psz = NULL;
    }

    i = RegOpenKeyA(hk, psz, phkOut);
    return (DWORD)i;
}

STDAPI_(DWORD) SHRegOpenKeyEx(HKEY hk, LPCTSTR ptszSubKey, DWORD dwReserved, REGSAM samDesired, PHKEY phkOut)
{
    long i;
    CHAR szSubKey[MAXIMUM_SUB_KEY_LENGTH];
    CHAR *psz;

    if (ptszSubKey) {
        SHTCharToAnsi(ptszSubKey, szSubKey, ARRAYSIZE(szSubKey));
        psz = szSubKey;
    }
    else {
        psz = NULL;
    }

    i = RegOpenKeyExA(hk, psz, dwReserved, samDesired, phkOut);
    return (DWORD)i;
}

#define E_NUKE      (E_FAIL + 1)

//***   RegGetVersion -- check registry tree 'Version'
// ENTRY/EXIT
//  (see RegChkVersion)
//  hr          (ret) S_OK:ok  S_FALSE:no tree  E_NUKE:old  E_FAIL:new
HRESULT RegGetVersion(HKEY hk, LPTSTR pszSubkey, LPTSTR pszValue, DWORD dwVers)
{
    HRESULT hr;
    HKEY hk2;
    DWORD dwData;
    DWORD cbSize;

    if (!pszValue)
        pszValue = TEXT("Version");

    hr = S_FALSE;               // assume nothing there at all
    if (SHRegOpenKey(hk, pszSubkey, &hk2) == ERROR_SUCCESS) {
        hr = E_NUKE;                    // assume version mismatch
        cbSize = SIZEOF(dwData);
        if (SHGetValue(hk2, NULL, pszValue, NULL, (BYTE*)&dwData, &cbSize) == ERROR_SUCCESS) {
            if (dwData == dwVers)
                hr = S_OK;              // great!
            else if (dwData > dwVers)
                hr = E_FAIL;            // we're an old client, fail
            else
                ASSERT(hr == E_NUKE);   // we're a new client, nuke it
        }
        RegCloseKey(hk2);
    }

    return hr;
}

//***   RegChkVersion -- check registry tree 'version', nuke if outdated 
// ENTRY/EXIT
//  hk          e.g. hkey for "HKCU/.../Uassist"
//  pszSubkey   e.g. "{clsid}"
//  pszValue    e.g. "Version"
//  dwVers      e.g. 3
//  hr          (ret) S_OK:matched, S_FAIL:mismatched and del'ed, E_FAIL:o.w.
//  (other)     (SE) pszSubkey deleted if not matched
HRESULT RegChkVersion(HKEY hk, LPTSTR pszSubkey, LPTSTR pszValue, DWORD dwVers)
{
    HRESULT hr;
    DWORD i;

    // RegGetVersion()  S_OK:ok  S_FALSE:new  E_NUKE:old  E_FAIL:fail
    hr = RegGetVersion(hk, pszSubkey, pszValue, dwVers);

    // at this point, we have:
    //  S_OK: ok
    //  S_FALSE: entire tree missing
    //  E_NUKE: no "Version" or old version (nuke it)
    //  E_FAIL: new version (we can't handle it)
    if (hr == E_FAIL) {
        TraceMsg(DM_UEMTRACE, "bui.rcv: incompat (uplevel)");
    }

    if (hr == E_NUKE) {
        TraceMsg(DM_UEMTRACE, "bui.rcv: bad tree, try delete");
        hr = S_FALSE;       // assume nuked
        i = SHDeleteKey(hk, pszSubkey);
        if (i != ERROR_SUCCESS) {
            TraceMsg(DM_UEMTRACE, "bui.rcv: delete failed!");
            hr = E_FAIL;    // bogus tree left laying around
        }
    }

    TraceMsg(DM_UEMTRACE, "bui.rcv: hr=0x%x", hr);

    return hr;
}

//***   GetUEMLogger -- get the (shared) instance of our logger object
// NOTES
//  BY DESIGN: we leak g_uempDbSvr.
//  race condition on g_uempDbSvr.  our caller guards against this.
//  the 5 billion ASSERTs below were for diagnosing nt5:145449 (fixed).
HRESULT GetUEMLogger(int iSvr, CEMDBLog **p)
{
    HRESULT hr, hrVers;
    CEMDBLog *pDbSvr;
    DWORD dwData, cbSize;

    ASSERT(iSvr < ARRAYSIZE(g_uempDbSvr));
    pDbSvr = g_uempDbSvr[iSvr];

    if (pDbSvr) {
        pDbSvr->AddRef();
        *p = pDbSvr;
        return S_OK;
    }

    pDbSvr = CEMDBLog_Create();

    if (EVAL(pDbSvr)) {
        TCHAR szClass[GUIDSTR_MAX];     // "{clsid}"

        SHStringFromGUID(IND_NONINSTR(iSvr) ? UEMIID_BROWSER : UEMIID_SHELL, szClass, GUIDSTR_MAX);
        TraceMsg(DM_UEMTRACE, "bui.gul: UEMIID_%s=%s", IND_NONINSTR(iSvr) ? TEXT("BROWSER") : TEXT("SHELL"), szClass);

        hr = pDbSvr->ChDir(!IND_ISINSTR(iSvr) ? SZ_UASSIST : SZ_UASSIST2);
        if (SUCCEEDED(hr)) {
            hrVers = RegChkVersion(pDbSvr->GetHkey(), szClass, SZ_UAVERSION, UA_VERSION);
            if (FAILED(hrVers)) {
                TraceMsg(DM_UEMTRACE, "bui.gul: rcv()=0x%x (!)", hrVers);
                hr = hrVers;
            }
        }
        if (SUCCEEDED(hr)) {
            hr = pDbSvr->ChDir(szClass);
            ASSERT(hrVers == S_OK || hrVers == S_FALSE);
            if (SUCCEEDED(hr) && hrVers == S_FALSE) {
                dwData = UA_VERSION;
                cbSize = SIZEOF(dwData);
                hr = pDbSvr->SetValue(SZ_UAVERSION, REG_DWORD, (BYTE*)&dwData, cbSize);
            }
        }
        if (SUCCEEDED(hr))
            hr = pDbSvr->ChDir(SZ_COUNT);

        // n.b. we can't call pDbSvr->GarbageCollect here since flags
        // (e.g. _fNoDecay) not set yet
        // pDbSvr->GarbageCollect(FALSE);

        if (FAILED(hr)) 
        {
            // this fails during RunOnce
            pDbSvr->Release();
            pDbSvr = NULL;
        }
    }

    if (pDbSvr) {
        ENTERCRITICAL;
        if (g_uempDbSvr[iSvr] == 0) {
            g_uempDbSvr[iSvr] = pDbSvr;     // xfer refcnt
            pDbSvr = NULL;
        }
        LEAVECRITICAL;
        if (pDbSvr)
            pDbSvr->Release();
    }

    *p = g_uempDbSvr[iSvr];

    return *p ? S_OK : E_FAIL;
}

CEMDBLog::CEMDBLog() : _cRef(1)
{
    ASSERT(_fBackup == FALSE);
    ASSERT(_fNoEncrypt == FALSE);
    return;
}

CEMDBLog::~CEMDBLog()
{
#if XXX_CACHE
    int i;

    for (i = 0; i < ARRAYSIZE(_rgCache); i++) 
    {
        if (_rgCache[i].pv) 
        {
            LocalFree(_rgCache[i].pv);
            _rgCache[i].pv = NULL;
            _rgCache[i].cbSize = 0;

        }
    }
#endif

    SetRoot(0, STGM_READ);         // close
    ASSERT(!_hkey);

    return;
}

void CEMDBLog_CleanUp()
{
    int i;
    CEMDBLog *pDbSvr;

    TraceMsg(DM_UEMTRACE, "bui.uadb_cu: cleaning up");
    for (i = 0; i < UEMIND_NSTANDARD + UEMIND_NINSTR; i++) {
        if ((pDbSvr = (CEMDBLog *)InterlockedExchangePointer((void**) &g_uempDbSvr[i], (LPVOID) -1)))
            delete pDbSvr;
    }
    return;
}


HRESULT CEMDBLog::Initialize(HKEY hkey, DWORD grfMode)
{
    HRESULT hr;

    hr = SetRoot(hkey, grfMode);
    return hr;
}

//***
//  hkey        e.g. HKLM
//  pszSubKey   e.g. "...\\Explorer\\Instance\\{...}"
//  grfMode     subset of STGM_* values
HRESULT CEMDBLog::SetRoot(HKEY hkeyNew, DWORD grfMode)
{
    ASSERT(grfMode == STGM_READ || grfMode == STGM_WRITE);
    if (_hkey) {
        RegCloseKey(_hkey);
        _grfMode = 0;
        _hkey = 0;
    }

    if (hkeyNew) {
        _grfMode = grfMode;
        _hkey = SHRegDuplicateHKey(hkeyNew);    // xfer ownership (and up khey refcnt)
        if (_hkey == NULL)
            return E_FAIL;
    }

    return S_OK;
}

HRESULT CEMDBLog::ChDir(LPCTSTR pszSubKey)
{
    HRESULT hr = E_FAIL;
    HKEY hkeyNew;

    ASSERT(_hkey);
    ASSERT(_grfMode == STGM_READ || _grfMode == STGM_WRITE);

    hkeyNew = Reg_CreateOpenKey(_hkey, pszSubKey, _grfMode);
    if (hkeyNew) {
        RegCloseKey(_hkey);
        _hkey = hkeyNew;
        hr = S_OK;
    }

    return hr;
}

HRESULT CEMDBLog::QueryValueStr(LPCTSTR pszName, LPTSTR pszVal, LPDWORD pcbVal)
{
    long i;
    CHAR szSubKey[MAXIMUM_SUB_KEY_LENGTH];
    CHAR szStrData[MAX_URL_STRING];
    DWORD cbSize = sizeof(szStrData);

    SHTCharToAnsi(pszName, szSubKey, ARRAYSIZE(szSubKey));
    i = SHQueryValueExA(_hkey, szSubKey, NULL, NULL, (BYTE*)szStrData, &cbSize);
    ASSERT((int)*pcbVal > lstrlenA(szStrData));    // I better be using a big enough buffer.
    SHAnsiToTChar(szStrData, pszVal, *pcbVal / sizeof(TCHAR));

    if (pcbVal)
        *pcbVal = lstrlen(pszVal);

    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CEMDBLog::SetValueStr(LPCTSTR pszName, LPCTSTR pszVal)
{
    return SetValueStrEx(pszName, REG_SZ, pszVal);
}

HRESULT CEMDBLog::SetValueStrEx(LPCTSTR pszName, DWORD dwType, LPCTSTR pszVal)
{
    long i;
    int cbTmp;
    CHAR szSubKey[MAXIMUM_SUB_KEY_LENGTH];
    CHAR szStrData[MAX_URL_STRING];

    SHTCharToAnsi(pszName, szSubKey, ARRAYSIZE(szSubKey));
    SHTCharToAnsi(pszVal, szStrData, ARRAYSIZE(szStrData));

    ASSERT(_grfMode == STGM_WRITE);
    cbTmp = (lstrlenA(szStrData) + 1);
    i = RegSetValueExA(_hkey, szSubKey, NULL, dwType, (BYTE*)szStrData, cbTmp);
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

// }

// }

// {
//***   CEMDBLog -- file-system-like view of registry
// DESCRIPTION
//  basically keeps track of where we are and does 'relative' opens from
// there.  NYI: intent is to eventually support 'chdir' ops.
// NOTES
//

CEMDBLog *CEMDBLog_Create()
{
    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, NULL, TRUE);
    if (hk)
    {
        CEMDBLog *prsfs = new CEMDBLog;
        if (prsfs && FAILED(prsfs->Initialize(hk, STGM_WRITE))) {
            prsfs->Release();
            prsfs = NULL;
        }
        RegCloseKey(hk);
        return prsfs;
    }
    return NULL;

}

//***   IsREG_XX_SZ -- see if ansi/unicode is an issue
//
#define IsREG_XX_SZ(dwTyp) \
    ((dwTyp) == REG_SZ || (dwTyp) == REG_MULTI_SZ || (dwTyp) == REG_EXPAND_SZ)

HRESULT CEMDBLog::QueryValue(LPCTSTR pszName, BYTE *pbData, LPDWORD pcbData)
{
    long i;
    DWORD dwType;
    CHAR szaTmp[MAX_URL_STRING];

    // we need to thunk since no RegXxxValueW on win95
    SHTCharToAnsi(pszName, szaTmp, ARRAYSIZE(szaTmp));

    i = SHQueryValueExA(_hkey, szaTmp, NULL, &dwType, pbData, pcbData);
    ASSERT(i != ERROR_SUCCESS || !IsREG_XX_SZ(dwType));
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CEMDBLog::SetValue(LPCTSTR pszName, DWORD dwType, const BYTE *pbData, DWORD cbData)
{
    long i;
    CHAR szaTmp[MAX_URL_STRING];

    ASSERT(_grfMode == STGM_WRITE);

    // we need to thunk since no RegXxxValueW on win95
    SHTCharToAnsi(pszName, szaTmp, ARRAYSIZE(szaTmp));
    ASSERT(!IsREG_XX_SZ(dwType));

    i = RegSetValueExA(_hkey, szaTmp, NULL, dwType, pbData, cbData);
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CEMDBLog::DeleteValue(LPCTSTR pszName)
{
    long i;

    ASSERT(_grfMode == STGM_WRITE);
    i = SHDeleteValue(_hkey, NULL, pszName);
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CEMDBLog::RmDir(LPCTSTR pszName, BOOL fRecurse)
{
    HRESULT hr = E_FAIL;
    DWORD i;

    CHAR szaTmp[MAX_URL_STRING];

    ASSERT(fRecurse);   // others NYI

    ASSERT(_grfMode == STGM_WRITE);

    SHTCharToAnsi(pszName, szaTmp, ARRAYSIZE(szaTmp));

    if (fRecurse) {
        i = SHDeleteKeyA(_hkey, szaTmp);
    }
    else {
        // not sure what to do, since we want a non-recursive delete
        // but we do want to handle presence of values (which shlwapi
        // doesn't support)
        //i = DeleteEmptyKey(_hkey, pszName);
        i = -1;
    }

    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}


//***   THIS::Count -- increment profile count for command
// ENTRY/EXIT
//  fUpdate     FALSE for the GC case (since can't update reg during RegEnum)
// NOTES
HRESULT CEMDBLog::GetCount(LPCTSTR pszCmd)
{
    return _GetCountRW(pszCmd, TRUE);
}

// Returns the Filetime that is encoded in the Count Object. 
// note: we do a delayed upgrade of the binary stream in the registry. We will
// use the old uem count info, but tack on the new filetime information when we increment the useage.
FILETIME CEMDBLog::GetFileTime(LPCTSTR pszCmd)
{
    NRWINFO rwi;
    HRESULT hres;
    CUACount aCnt;
    rwi.self = this;
    rwi.pszName = pszCmd;
    // This is a bizzar way of reading a string from the registry....
    hres = aCnt.LoadFrom(&s_Nrw3Info, &rwi);
    return aCnt.GetFileTime();
}


HRESULT CEMDBLog::_GetCountRW(LPCTSTR pszCmd, BOOL fUpdate)
{
    HRESULT hr;
    CUACount aCnt;
    NRWINFO rwi;
    int i;

    hr = _GetCountWithDefault(pszCmd, TRUE, &aCnt);

    i = aCnt.GetCount();

    if (fUpdate) {
        rwi.self = this;
        rwi.pszName = pszCmd;
        hr = aCnt.SaveTo(FALSE, &s_Nrw3Info, &rwi);
    }

    return i;
}

//***
// ENTRY/EXIT
//  hr  (ret) S_OK if dead, o.w. != S_OK
HRESULT CEMDBLog::IsDead(LPCTSTR pszCmd)
{
    HRESULT hr;

    hr = _GetCountRW(pszCmd, FALSE);
    return hr;
}

extern DWORD g_dCleanSess;

//***
// NOTES
//  we need to be careful not to party on guys that either aren't counts
// (e.g. UEME_CTLSESSION), or are 'special' (e.g. UEME_CTLCUACOUNT), or
// shouldn't be deleted (e.g. "del.xxx").  for now we take a conservative
// approach and just nuke things w/ UEME_RUN* as a prefix.  better might
// be to use a dope vector and delete anything that's marked as 'cleanup'.
HRESULT CEMDBLog::GarbageCollect(BOOL fForce)
{
    int i;

    if (!fForce) {
        if (g_dCleanSess != 0) {
            i = GetSessionId();
            if ((i % g_dCleanSess) != 0) {
                TraceMsg(DM_UEMTRACE, "uadb.gc: skip");
                return S_FALSE;
            }
        }
    }

    g_fDidUAGC = 1;     // breadcrumbs in case we die (even non-DEBUG)

    // do _GarbageCollectSlow(), in the background
    HRESULT hr = E_FAIL;
    CGCTask *pTask = CGCTask_Create(this);
    if (pTask) {
        IShellTaskScheduler *pSched;
        hr = CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_IShellTaskScheduler, (void**)&pSched);

        if (SUCCEEDED(hr)) {
            hr = pSched->AddTask(pTask, CLSID_GCTaskTOID, 0L, ITSAT_DEFAULT_PRIORITY);
            pSched->Release();  // (o.k. even if task hasn't completed)
        }
        pTask->Release();
    }

    return hr;
}

HRESULT CEMDBLog::_GarbageCollectSlow()
{
    HKEY hk;
    int i;
    DWORD dwI, dwCch, dwType;
    HDSA hdsa;
    TCHAR *p;
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];

    TraceMsg(DM_UEMTRACE, "uadb.gc: hit");

    hdsa = DSA_Create(SIZEOF(szKey), 4);    // max size, oh well...
    if (hdsa) {
        TCHAR szRun[SIZEOF(SZ_RUN_PREFIX)];
        TCHAR *pszRun;

        pszRun = _MayEncrypt(SZ_RUN_PREFIX, szRun, ARRAYSIZE(szRun));
        if (pszRun != szRun)
            lstrcpy(szRun, pszRun);
        ASSERT(lstrlen(szRun) == lstrlen(SZ_RUN_PREFIX));
        hk = GetHkey();
        for (dwI = 0; ; dwI++) {
            dwCch = ARRAYSIZE(szKey);
            if (SHEnumValue(hk, dwI, szKey, &dwCch, &dwType, NULL, NULL) != NOERROR)
                break;
            if (StrCmpN(szKey, szRun, ARRAYSIZE(szRun) - 1) == 0) {
                if (IsDead(szKey) == S_OK)
                    DSA_AppendItem(hdsa, szKey);
            }
        }

        for (i = DSA_GetItemCount(hdsa) - 1; i > 0; i--) {
            p = (TCHAR *)DSA_GetItemPtr(hdsa, i);
            TraceMsg(DM_UEMTRACE, "uadb.gc: nuke %s", p);
            GetCount(p);    // decay to 0 will delete
        }

        DSA_Destroy(hdsa);
        hdsa = NULL;
    }

    return S_OK;
}

HRESULT CEMDBLog::IncCount(LPCTSTR pszCmd)
{
    HRESULT hr;
    NRWINFO rwi;

    TraceMsg(DM_UEMTRACE, "uemt: ic <%s>", pszCmd);

    if (DB_NOLOG)
        return E_FAIL;

#if 0 // ChDir is currently done at create time 
    hr = ChDir(SZ_COUNT);
#endif

    CUACount aCnt;

    hr = _GetCountWithDefault(pszCmd, TRUE, &aCnt);

    aCnt.IncCount();

    // Since we are incrementing the count,
    // We should update the last execute time
    aCnt.UpdateFileTime();

    rwi.self = this;
    rwi.pszName = pszCmd;
    hr = aCnt.SaveTo(TRUE, &s_Nrw3Info, &rwi);

    return hr;
}

HRESULT CEMDBLog::SetCount(LPCTSTR pszCmd, int cCnt)
{
    HRESULT hr;
    NRWINFO rwi;

    TraceMsg(DM_UEMTRACE, "uemt: ic <%s>", pszCmd);

    if (DB_NOLOG)
        return E_FAIL;

    CUACount aCnt;

    // fDef=FALSE so don't create if doesn't exist
    hr = _GetCountWithDefault(pszCmd, /*fDef=*/FALSE, &aCnt);

    if (SUCCEEDED(hr)) {       // don't want default...
        aCnt.SetCount(cCnt);

        rwi.self = this;
        rwi.pszName = pszCmd;
        hr = aCnt.SaveTo(TRUE, &s_Nrw3Info, &rwi);
    }

    return hr;
}

//***
// ENTRY/EXIT
//  fDefault    provide default if entry not found
//  ret         S_OK: found w/o default; S_FALSE: needed default; E_xxx: error
// NOTES
//  calling w/ fDefault=FALSE can still return S_FALSE
HRESULT CEMDBLog::_GetCountWithDefault(LPCTSTR pszCmd, BOOL fDefault, CUACount *pCnt)
{
    HRESULT hr, hrDef;
    NRWINFO rwi;

    rwi.self = this;
    rwi.pszName = pszCmd;
    hr = pCnt->LoadFrom(&s_Nrw3Info, &rwi);

    hrDef = S_OK;
    if (FAILED(hr)) {
        hrDef = S_FALSE;
        if (fDefault) {
            rwi.pszName = SZ_CUACount_ctor;
            hr = pCnt->LoadFrom(&s_Nrw3Info, &rwi);

            // pCnt->Initialize happens below (possibly 2x)
            if (FAILED(hr)) {
                TraceMsg(DM_UEMTRACE, "uadb._gcwd: create ctor %s", SZ_CUACount_ctor);
                hr = pCnt->Initialize(SAFECAST(this, IUASession *));

                ASSERT(pCnt->_GetCount() == 0);
                pCnt->_SetMru(SID_SNOWINIT);    // start clock ticking...

                // cnt=UAC_NEWCOUNT, age=Now
                int i = _fNoDecay ? 1 : UAC_NEWCOUNT;
                pCnt->SetCount(i);      // force age
                ASSERT(pCnt->_GetCount() == i);

                hr = pCnt->SaveTo(/*fForce*/TRUE, &s_Nrw3Info, &rwi);
            }

#if XXX_DELETE
            pCnt->_SetFlags(UACF_INHERITED, UACF_INHERITED);
#endif
        }
    }

    hr = pCnt->Initialize(SAFECAST(this, IUASession *));
    if (SUCCEEDED(hr))
        pCnt->_SetFlags(UAXF_XMASK, _SetFlags(0, 0) & UAXF_XMASK);

    return SUCCEEDED(hr) ? hrDef : hr;
}

HRESULT CEMDBLog::SetFileTime(LPCTSTR pszCmd, const FILETIME *pft)
{
    HRESULT hr;
    NRWINFO rwi;

    TraceMsg(DM_UEMTRACE, "uemt: sft <%s>", pszCmd);

    if (DB_NOLOG)
        return E_FAIL;

    CUACount aCnt;

    // fDef=FALSE so don't create if doesn't exist
    hr = _GetCountWithDefault(pszCmd, /*fDef=*/FALSE, &aCnt);

    if (SUCCEEDED(hr)) {       // don't want default...
        aCnt.SetFileTime(pft);

        rwi.self = this;
        rwi.pszName = pszCmd;
        hr = aCnt.SaveTo(TRUE, &s_Nrw3Info, &rwi);
    }

    return hr;
}


#if XXX_DELETE
#define BTOM(b, m)  ((b) ? (m) : 0)

DWORD CEMDBLog::_SetFlags(DWORD dwMask, DWORD dwFlags)
{
    // standard guys
    if (dwMask & UAXF_NOPURGE)
        _fNoPurge = BOOLIFY(dwFlags & UAXF_NOPURGE);
    if (dwMask & UAXF_BACKUP)
        _fBackup = BOOLIFY(dwFlags & UAXF_BACKUP);
    if (dwMask & UAXF_NOENCRYPT)
        _fNoEncrypt = BOOLIFY(dwFlags & UAXF_NOENCRYPT);
    if (dwMask & UAXF_NODECAY)
        _fNoDecay = BOOLIFY(dwFlags & UAXF_NODECAY);

    // my guys
    // (none)

    return 0    // n.b. see continuation line(s)!!!
        | BTOM(_fNoPurge  , UAXF_NOPURGE)
        | BTOM(_fBackup   , UAXF_BACKUP)
        | BTOM(_fNoEncrypt, UAXF_NOENCRYPT)
        | BTOM(_fNoDecay  , UAXF_NODECAY)
        ;
}
#endif

#define ROT13(i)    (((i) + 13) % 26)

#define XXX_HASH    0       // proto code for way-shorter regnames
#if !defined(DEBUG) && XXX_HASH
#pragma message("warning: XXX_HASH defined non-DEBUG")
#endif

//***   _MayEncrypt -- encrypt registry key/value name
// NOTES
TCHAR *CEMDBLog::_MayEncrypt(LPCTSTR pszSrcPlain, LPTSTR pszDstEnc, int cchDst)
{
    TCHAR *pszName;

    if (!_fNoEncrypt) {
#if XXX_HASH
        DWORD dwHash;

        HashData((BYTE*)pszSrcPlain, lstrlen(pszSrcPlain), (BYTE*)&dwHash, SIZEOF(dwHash));
        pszName = pszDstEnc;
        if (EVAL(cchDst >= (8 + 1)))
            wsprintf(pszName, TEXT("%x"), dwHash);
        else
            pszName = (TCHAR *)pszSrcPlain;
#else
        TCHAR ch;

        // uh-oh, gotta figure out an intl-aware encryption scheme...
        pszName = pszDstEnc;
        pszDstEnc[--cchDst] = 0;      // pre-terminate for overflow case
        ch = -1;
        while (cchDst-- > 0 && ch != 0) {
            ch = *pszSrcPlain++;

            if (TEXT('a') <= ch && ch <= TEXT('z'))
                ch = TEXT('a') + ROT13(ch - TEXT('a'));
            else if (TEXT('A') <= ch && ch <= TEXT('Z'))
                ch = TEXT('A') + ROT13(ch - TEXT('A'));
            else
                ;

            *pszDstEnc++ = ch;
        }
#endif
        TraceMsg(DM_UEMTRACE, "uadb._me: plain=%s(enc=%s)", pszSrcPlain - (pszDstEnc - pszName), pszName);
    }
    else {
        pszName = (TCHAR *)pszSrcPlain;
    }

    return pszName;
}

#if XXX_CACHE // {
//***
// ENTRY/EXIT
//  op      0:read, 1:write, 2:delete
//
HRESULT CEMDBLog::CacheOp(CACHEOP op, void *pvBuf, DWORD cbBuf, PNRWINFO prwi)
{
    static TCHAR * const pszNameTab[] = { SZ_CTLSESSION, SZ_CUACount_ctor, };
    int i;

    ASSERT(ARRAYSIZE(pszNameTab) == ARRAYSIZE(_rgCache));

    for (i = 0; i < ARRAYSIZE(pszNameTab); i++) 
    {
        if (lstrcmp(prwi->pszName, pszNameTab[i]) == 0) 
        {
            TraceMsg(DM_PERF, "cedl.s_%c: this'=%x n=%s", TEXT("rwd")[op], prwi->self, prwi->pszName);

            switch (op) 
            {
                // Read from the cache
            case CO_READ:
                // Do we have a cached item?
                if (_rgCache[i].pv) 
                {
                    // The cached buffer should be smaller than or equal to the 
                    // passed buffer size, or we get a buffer overflow
                    ASSERT (_rgCache[i].cbSize <= cbBuf);
                    // Load the cache into the buffer. Note that the
                    // size requested may be larger than the size cached. This
                    // is due to upgrade senarios
                    memcpy(pvBuf, _rgCache[i].pv, _rgCache[i].cbSize);
                    return S_OK;
                }
                break;

                // Write to the Cache
            case CO_WRITE:

                // Is the size different or not initialized?
                // When we first allocate this spot, it's size is zero. The
                // incomming buffer should be greater.
                if (_rgCache[i].cbSize != cbBuf)
                {
                    // The size is different or uninialized.
                    if (_rgCache[i].pv)                         // Free whatever we've got 
                    {                                           // because we're getting a new one.
                        _rgCache[i].cbSize = 0;                 // Set the size to zero.
                        LocalFree(_rgCache[i].pv);
                    }

                    // Allocate a new buffer of the current size.
                    _rgCache[i].pv = LocalAlloc(LPTR, cbBuf);
                }


                // Were we successful in allocating a cache buffer?
                if (_rgCache[i].pv) 
                {
                    // Yes, make the buffer size the same... Do this here incase the
                    // allocate fails.
                    _rgCache[i].cbSize = cbBuf;
                    memcpy(_rgCache[i].pv, pvBuf, _rgCache[i].cbSize);
                    return S_OK;
                }
                break;

            case CO_DELETE:     // delete
                if (_rgCache[i].pv) 
                {
                    LocalFree(_rgCache[i].pv);
                    _rgCache[i].pv = NULL;
                    _rgCache[i].cbSize = 0;
                }
                return S_OK;

            default:
                ASSERT(0);  // 'impossible'
                break;
            }

            TraceMsg(DM_PERF, "cedl.s_%c: this'=%x n=%s cache miss", TEXT("rwd")[op], prwi->self, prwi->pszName);
            break;
        }
    }
    return S_FALSE;
}
#endif // }

HRESULT CEMDBLog::s_Read(void *pvBuf, DWORD cbBuf, PNRWINFO prwi)
{
    HRESULT hr;
    CEMDBLog *pdb = (CEMDBLog *)prwi->self;
    TCHAR *pszName;
    TCHAR szNameEnc[MAX_URL_STRING];

#if XXX_CACHE
    if (pdb->CacheOp(CO_READ, pvBuf, cbBuf, prwi) == S_OK)
        return S_OK;
#endif
    pszName = pdb->_MayEncrypt(prwi->pszName, szNameEnc, ARRAYSIZE(szNameEnc));
    hr = pdb->QueryValue(pszName, (BYTE *)pvBuf, &cbBuf);
#if XXX_CACHE
    pdb->CacheOp(CO_WRITE, pvBuf, cbBuf, prwi);
#endif
    return hr;
}

HRESULT CEMDBLog::s_Write(void *pvBuf, DWORD cbBuf, PNRWINFO prwi)
{
    HRESULT hr;
    CEMDBLog *pdb = (CEMDBLog *)prwi->self;
    TCHAR *pszName;
    TCHAR szNameEnc[MAX_URL_STRING];

#if XXX_CACHE
    // CO_DELETE not CO_WRITE (easier/safer) (perf fine since rarely write)
    pdb->CacheOp(CO_DELETE, pvBuf, cbBuf, prwi);
#endif
    pszName = pdb->_MayEncrypt(prwi->pszName, szNameEnc, ARRAYSIZE(szNameEnc));
    hr = pdb->SetValue(pszName, REG_BINARY, (BYTE *)pvBuf, cbBuf);
    return hr;
}

HRESULT CEMDBLog::s_Delete(void *pvBuf, DWORD cbBuf, PNRWINFO prwi)
{
    HRESULT hr;
    CEMDBLog *pdb = (CEMDBLog *)prwi->self;
    TCHAR *pszName;
    TCHAR szNameEnc[MAX_URL_STRING];

#if XXX_CACHE
    pdb->CacheOp(CO_DELETE, pvBuf, cbBuf, prwi);
#endif
    pszName = pdb->_MayEncrypt(prwi->pszName, szNameEnc, ARRAYSIZE(szNameEnc));
    if (pdb->_fBackup) {
        TCHAR szDel[MAX_URL_STRING];

        wnsprintf(szDel, ARRAYSIZE(szDel), SZ_DEL_PREFIX TEXT("%s"), pszName);
        if (pvBuf == NULL) {
            // happily we already have the data
            // o.w. we'd need to QueryValue into a mega-buffer
            TraceMsg(TF_WARNING, "uadb.s_d: _fBackup && !pvBuf (!)");
            ASSERT(0);
        }
        if (pvBuf != NULL) {
            hr = pdb->SetValue(szDel, REG_BINARY, (BYTE *)pvBuf, cbBuf);
            if (FAILED(hr))
                TraceMsg(TF_WARNING, "uadb.s_d: _fBackup hr=%x (!)", hr);
        }
        // (we'll do delete whether or not the _fBackup works)
    }

    hr = pdb->DeleteValue(pszName);
    TraceMsg(DM_UEMTRACE, "uadb.s_d: delete s=%s(%s) (_fBackup=%d) pRaw=0x%x hr=%x", pszName, prwi->pszName, pdb->_fBackup, pvBuf, hr);
#if 1 // unneeded?
    if (FAILED(hr))
        hr = s_Write(pvBuf, cbBuf, prwi);
#endif
    return hr;
}

// }

//***   THIS::IUASession::* {

int CEMDBLog::GetSessionId()
{
    HRESULT hr;
    NRWINFO rwi;
    CUASession aSess;
    int i;

    rwi.self = this;
    rwi.pszName = SZ_CTLSESSION;
    hr = aSess.LoadFrom(&s_Nrw3Info, &rwi);
    aSess.Initialize();

    i = aSess.GetSessionId();

    hr = aSess.SaveTo(FALSE, &s_Nrw3Info, &rwi);

    return i;
}

void CEMDBLog::SetSession(UAQUANTUM uaq, BOOL fForce)
{
    HRESULT hr;
    NRWINFO rwi;
    CUASession aSess;

    rwi.self = this;
    rwi.pszName = SZ_CTLSESSION;
    hr = aSess.LoadFrom(&s_Nrw3Info, &rwi);
    aSess.Initialize();

    aSess.SetSession(uaq, fForce);

    hr = aSess.SaveTo(TRUE, &s_Nrw3Info, &rwi);

    return;
}

// }

//***   THIS::CUASession::* {

extern DWORD g_dSessTime;

CUASession::CUASession()
{
    _fInited = FALSE;
    _fDirty = FALSE;
    return;
}

HRESULT CUASession::Initialize()
{
    if (!_fInited) {
        _fInited = TRUE;

        _cCnt = 0;
        _qtMru = 0;
        _fDirty = TRUE;
    }

    return S_OK;
}

//***   THIS::GetSessionId -- increment profile count for command
//
int CUASession::GetSessionId()
{
    return _cCnt;
}

//***
// ENTRY/EXIT
//  fForce  ignore threshhold rules (e.g. for DEBUG)
void CUASession::SetSession(UAQUANTUM uaq, BOOL fForce)
{
    UATIME qtNow;

    qtNow = GetUaTime(NULL);
    if (qtNow - _qtMru >= g_dSessTime || fForce) {
        TraceMsg(DM_UEMTRACE, "uadb.ss: sid=%d++", _cCnt);
        _cCnt++;
        // nt5:173090
        // if we wrap, there's nothing we can do.  it would be pretty
        // bad, since everything would get promoted (since 'now' will
        // be *older* than 'mru' so there will be no decay).  worse still
        // they'd stay promoted for a v. long time.  we could detect that
        // in the decay code and (lazily) reset the count to 'now,1' or
        // somesuch, but it should never happen so we simply ASSERT.
        ASSERT(_cCnt != 0);     // 'impossible'
        _qtMru = qtNow;

        _fDirty = TRUE;
    }

    return;
}

HRESULT CUASession::LoadFrom(PFNNRW3 pfnIO, PNRWINFO pRwi)
{
    HRESULT hr;

    hr = (*pfnIO->_pfnRead)(_GetRawData(), _GetRawCount(), pRwi);
    if (SUCCEEDED(hr))
        _fInited = TRUE;
    return hr;
}

HRESULT CUASession::SaveTo(BOOL fForce, PFNNRW3 pfnIO, PNRWINFO pRwi)
{
    HRESULT hr;

    hr = S_FALSE;
    if (fForce || _fDirty) {
        hr = (*pfnIO->_pfnWrite)(_GetRawData(), _GetRawCount(), pRwi);
        _fDirty = FALSE;
    }
    return hr;
}

// }

//*** CGCTask::* {
CGCTask *CGCTask_Create(CEMDBLog *that)
{
    CGCTask *pthis = new CGCTask;
    if (pthis) {
        if (FAILED(pthis->Initialize(that))) {
            delete pthis;
            pthis = NULL;
        }
    }
    return pthis;
}

HRESULT CGCTask::Initialize(CEMDBLog *that)
{
    ASSERT(!_that);
    ASSERT(that);
    that->AddRef();
    _that = that;
    return S_OK;
}

CGCTask::CGCTask() : CRunnableTask(RTF_DEFAULT)
{
}

CGCTask::~CGCTask()
{
    if (_that)
        _that->Release();
}

//***   CGCTask::CRunnableTaskRT::* {

HRESULT CGCTask::RunInitRT()
{
    HRESULT hr;

    ASSERT(_that);
    g_fDidUAGC = 2;     // breadcrumbs in case we die (even non-DEBUG)
    hr = _that->_GarbageCollectSlow();
    g_fDidUAGC = 3;     // breadcrumbs in case we die (even non-DEBUG)
    return hr;
}

// }

// }

#if 0
#ifdef DEBUG
void emdbtst()
{
    HRESULT hr;
    CEMDBLog *pdb = new CEMDBLog;

    if (pdb)
    {
        hr = pdb->Initialize(HKEY_CURRENT_USER, TEXT("UIProf"));
        ASSERT(SUCCEEDED(hr));

        pdb->CountIncr("foo");
        pdb->CountIncr("bar");
        pdb->CountIncr("foo");

        delete pdb;
    }

    return;
}
#endif
#endif

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\emclient\uemapp.cpp ===
//***   uemapp.cpp -- application side of event monitor
// DESCRIPTION
//  event generators, actions, helpers, etc.

#include "priv.h"
#include <trayp.h>
#include "sccls.h"
#include "uemapp.h"
#include "uacount.h"
#include "regdb.h"
#include "uareg.h"
#include "resource.h"

#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define BIT_ASSIGN(dwBits, dwMasks, dwVals) \
    (((dwBits) & ~(dwMasks)) | (dwVals))

#define FEATURE_EMDLL   0       // turn this *off* until msoem.dll in setup!

#if FEATURE_EMDLL
#include "mso.h"
#include "msoem.h"
#include "emrule.h"
#include "libem.h"   // configure genem.c and other client-side stuff

#include "emdef.h"              // rulc-generated
#endif

#if FEATURE_EMDLL
/* UEMEvalIE... */
extern "C" int FInitEm(void);
#else
#define UEMEvalIE(irul, val, ecmd)  /*NOTHING*/
#define FInitEm()                   /*NOTHING*/
#endif

#define DM_UEMTRACE     0
#define DM_UEMTRACE2    0           // verbose
#define DM_IDLEDETECT   0           // TF_CUSTOM2
#define DM_EVTMON       TF_UEM

int SHSearchInt(int *psrc, int cnt, int val);
int UEMIIDToInd(const GUID *pguidGrp);

void UEMEnableTimer(UINT uTimeout);

//***   event firers {

//CASSERT(UEMIND_SHELL == 0 && UEMIND_BROWSER == 1);
HRESULT GetUEMLogger(int iCmd, CEMDBLog **p);

CEMDBLog *g_uempDbLog[UEMIND_NSTANDARD + UEMIND_NINSTR];

DWORD g_uemdwFlags /*=0*/;      // UAF_* and UAAF_*

// Turning this so that it's a Flat 12hours. You have to explicitly set the SessionTime=0 
// in the registry to debug.
#ifdef DEBUG_UEM_TIMEOUTS
#define UAS_SESSTIME    UAT_MINUTE1
#else
#define UAS_SESSTIME    UAT_HOUR12
#endif

#define UAS_SESSMIN     0
#define UAS_SESSMAX     ... none for now ...

DWORD g_dSessTime = UAS_SESSTIME;           // session time threshhold

#define UAS_IDLETIME    UAT_HOUR12
#define UAS_IDLEMIN     0
#define UAS_IDLEMAX     ... none for now ...

DWORD g_dIdleTime = UAS_IDLETIME;           // idle time threshhold

#define UAS_CLEANSESS   16
DWORD g_dCleanSess = UAS_CLEANSESS;         // cleanup session count threshhold

#if FEATURE_EMDLL // {

#if YY_DELAYED
extern "C" MSOACTTBL  *_pacttbl;
extern "C" void DoPendingActions(void);
#endif

//***   UEMEvalIE -- sched and eval event (and generic)
//
void UEMEvalIE(IRUL irul, long val, int eCmd)
{

#ifdef DEBUG
    static long iDepth = 0;
#endif

    ASSERT(iDepth == 0);
    ASSERT(InterlockedIncrement(&iDepth) > 0);

    TraceMsg(DM_EVTMON, "uemeie: sched/eval irul=%d val=0x%x eCmd=%d", irul, val, eCmd);
    MsoScheduleIrul(irul, val);  // e.g. irulIE_UIMENU
    MsoScheduleIrul(irulIE_GENERIC, eCmd);  // e.g. UEME_UIMENU
    MsoEvaluateEvents(rulevtEmIE);

#if YY_DELAYED
    if (_pacttbl->pactPending)
        DoPendingActions();
#endif

    ASSERT(InterlockedDecrement(&iDepth) == 0);

}

#endif // }

void UEMSpecial(int iTab, int iGrp, int eCmd, WPARAM wParam, LPARAM lParam)
{
    CEMDBLog *pDbLog;

    pDbLog = g_uempDbLog[iGrp];

    if (!pDbLog) 
    {
        ASSERT(0);
        TraceMsg(TF_ERROR, "uemt: pDbLog not initialized iTab=%d iGrp=%d eCmd=%d wParam=0x%x lParam=0x%x", iTab, iGrp, eCmd, wParam, lParam);
        return;
    }

    switch (eCmd) {
    case UEME_DBTRACEA:
        TraceMsg(DM_UEMTRACE, "uemt: e=runtrace s=%hs(0x%x)", (int)lParam, (int)lParam);
        break;
    case UEME_DBTRACEW:
        TraceMsg(DM_UEMTRACE, "uemt: e=runtrace s=%ls(0x%x)", (int)lParam, (int)lParam);
        break;
#ifdef DEBUG
    case UEME_DBSLEEP:
        Sleep((DWORD)lParam);
        break;
#endif

    // UEME_DONE*
    case UEME_DONECANCEL:
        TraceMsg(DM_UEMTRACE, "uemt: e=donecancel lP=%x", (int)lParam);
        break;

    // UEME_ERROR*
    case UEME_ERRORA:
        TraceMsg(DM_UEMTRACE, "uemt: e=errora id=%hs(0x%x)", (LPSTR)lParam, (int)lParam);
        break;
    case UEME_ERRORW:
        TraceMsg(DM_UEMTRACE, "uemt: e=errorw id=%ls(0x%x)", (LPWSTR)lParam, (int)lParam);
        break;

    case UEME_CTLSESSION:
        ASSERT(lParam == -1);   // eventually, UAQ_*
        pDbLog->SetSession(UAQ_SESSION, (BOOL)wParam);
#ifdef UAAF_INSTR
        // might be safer to copy UA.sess rather than inc UA2.sess in parallel?
        if (g_uemdwFlags & UAAF_INSTR) 
        {
            if (EVAL(g_uempDbLog[iGrp + UEMIND_NINSTR]))
                g_uempDbLog[iGrp + UEMIND_NINSTR]->SetSession(UAQ_SESSION, (BOOL)wParam);
        }
#endif
        break;

    default:
        TraceMsg(DM_UEMTRACE, "uemt: e=0x%x(%d) lP=0x%x(%d)", eCmd, eCmd, (int)lParam, (int)lParam);
        break;
    }
    return;
}

#ifdef DEBUG // {
int DBShellMenuValTab[] = 
{
    0x8,    // UEMC_FILERUN
    401,    // IDM_FILERUN
};

TCHAR * DBShellMenuStrTab[] = 
{
    TEXT("run"),
    TEXT("run"),
};

int DBBrowserMenuValTab[] = {
    0x106,
};
TCHAR * DBBrowserMenuStrTab[] = {
    TEXT("properties"),
};

int DBBrowserTbarValTab[] = {
    0x124, 0x122,
};
TCHAR * DBBrowserTbarStrTab[] = {
    TEXT("stop"),
    TEXT("home"),
};

// Function used only in this file, and only in debug,
// so no point in adding to shlwapi
LPTSTR SHSearchMapIntStr(const int *src, const LPTSTR *dst, int cnt, int val)
{
    for (; cnt > 0; cnt--, src++, dst++) {
        if (*src == val)
            return *dst;
    }
    return (LPTSTR)-1;
}
#endif // }


#define TABDAT(ueme, dope, u1, u2, u3, u4)  ueme,
int UemeValTab[] = {
    #include "uemedat.h"
};
#undef  TABDAT

#define TABDAT(ueme, dope, u1, u2, u3, u4)  TEXT(# ueme),
TCHAR *UemeStrTab[] = {
    #include "uemedat.h"
};
#undef  TABDAT

#define TABDAT(ueme, dope, u1, u2, u3, u4)  dope,
char *UemeDopeTab[] = {
    #include "uemedat.h"
};
#undef  TABDAT

BOOL UEMEncodePidl(IShellFolder *psf, LPITEMIDLIST pidlItem,
    LPTSTR pszBuf, DWORD cchBuf, int* piIndexStart, int* pcsidl);

#define MAX_EVENT_NAME      32

//***
// NOTES
//  todo: could put more encoding instrs in dope vector (e.g. %pidl, %tstr)
//  for now there are only a couple so we hard-code them
void UEMEncode(int iTab, TCHAR *pszEvent, TCHAR *pszEncoded, DWORD cchEncoded, int iGrp, int eCmd, WPARAM wParam, LPARAM lParam)
{
#ifdef DEBUG
    TCHAR *pdb2;
#endif
    int i, csIdl;
    TCHAR szBufTmp[MAX_URL_STRING];
    TCHAR szEvent[MAX_PATH];


    ASSERT(pszEvent[0] == 0);
    ASSERT(pszEncoded == 0 || pszEncoded[0] == 0);

    if (iTab == -1) {
        lstrcpy(pszEvent, TEXT("UEM?_?"));
        //pszEncoded[0] = 0;
    }
    else {
        lstrcpy(pszEvent, UemeStrTab[iTab]);
        ASSERT(lstrlen(pszEvent) < MAX_EVENT_NAME);
        
        if (pszEncoded) {
            switch (eCmd) {
            case UEME_RUNPIDL:
                if (UEMEncodePidl((IShellFolder *)wParam, (LPITEMIDLIST)lParam, szBufTmp, SIZECHARS(szBufTmp), &i, &csIdl)) {
                    wnsprintf(pszEncoded, cchEncoded, TEXT("%s:%%csidl%d%%%s"), pszEvent, csIdl, szBufTmp + i);
                }
                else {
                    wnsprintf(pszEncoded, cchEncoded, TEXT("%s:%s"), pszEvent, szBufTmp);
                }
                break;

            case UEME_RUNPATHA:
                ASSERT(lstrcmp(pszEvent, TEXT("UEME_RUNPATHA")) == 0);
                ASSERT(pszEvent[12] == TEXT('A'));
                pszEvent[12] = 0;    // nuke the 'A'/'W'

                SHAnsiToTChar((LPSTR)lParam, szEvent, MAX_PATH);

                if (wParam != -1) {
                    wnsprintf(pszEncoded, cchEncoded, TEXT("%s:%%csidl%d%%%s"), pszEvent, wParam, szEvent);
                }
                else {
                    wnsprintf(pszEncoded, cchEncoded, TEXT("%s:%s"), pszEvent, szEvent);
                }
                break;
            case UEME_RUNPATHW:
                ASSERT(lstrcmp(pszEvent, TEXT("UEME_RUNPATHW")) == 0);
                ASSERT(pszEvent[12] == TEXT('W'));
                pszEvent[12] = 0;    // nuke the 'A'/'W'

                if (wParam != -1) {
                    wnsprintf(pszEncoded, cchEncoded, TEXT("%s:%%csidl%d%%%ls"), pszEvent, wParam, (WCHAR*)lParam);
                }
                else {
                    wnsprintf(pszEncoded, cchEncoded, TEXT("%s:%ls"), pszEvent, (WCHAR *)lParam);
                }
                break;

            case UEME_RUNCPLA:
                ASSERT(lstrcmp(pszEvent, TEXT("UEME_RUNCPLA")) == 0);
                ASSERT(pszEvent[11] == TEXT('A'));
                pszEvent[11] = 0;    // nuke the 'A'/'W'

                SHAnsiToTChar((LPSTR)lParam, szEvent, MAX_PATH);

                wnsprintf(pszEncoded, cchEncoded, TEXT("%s:%s"), pszEvent, szEvent);
                break;

            case UEME_RUNCPLW:
                ASSERT(lstrcmp(pszEvent, TEXT("UEME_RUNCPLW")) == 0);
                ASSERT(pszEvent[11] == TEXT('W'));
                pszEvent[11] = 0;    // nuke the 'A'/'W'

                wnsprintf(pszEncoded, cchEncoded, TEXT("%s:%ls"), pszEvent, (WCHAR *)lParam);
                break;

            default:
                wnsprintf(pszEncoded, cchEncoded, TEXT("%s:0x%x,%x"), pszEvent, (DWORD)wParam, (DWORD)lParam);
                break;
            }
        }
    }

#ifdef DEBUG
    pdb2 = (TCHAR *)-1;

    switch (eCmd) {
    case UEME_UIMENU:
        switch (iGrp) {
        case UEMIND_SHELL:
            pdb2 = SHSearchMapIntStr(DBShellMenuValTab, DBShellMenuStrTab, ARRAYSIZE(DBShellMenuValTab), (int)lParam);
            break;
        case UEMIND_BROWSER:
            pdb2 = SHSearchMapIntStr(DBBrowserMenuValTab, DBBrowserMenuStrTab, ARRAYSIZE(DBBrowserMenuValTab), (int)lParam);
            break;
        default:
            break;
        }
        break;

    case UEME_UITOOLBAR:
        ASSERT(iGrp == UEMIND_BROWSER);
        pdb2 = SHSearchMapIntStr(DBBrowserTbarValTab, DBBrowserTbarStrTab, ARRAYSIZE(DBBrowserTbarValTab), (int)lParam);
        break;

    default:
        break;
    }

    if (pdb2 != (TCHAR *)-1) {
        if (pszEncoded)
            wnsprintf(pszEncoded, cchEncoded, TEXT("%s:%s"), pszEvent, pdb2);
    }
#endif

    return;
}

STDAPI _UEMGetDisplayName(IShellFolder *psf, LPCITEMIDLIST pidl, UINT shgdnf, LPTSTR pszOut, DWORD cchOut)
{
    HRESULT hr;
    
    if (psf)
    {
        ASSERT(pidl == ILFindLastID(pidl));
        STRRET str;
        
        hr = psf->GetDisplayNameOf(pidl, shgdnf, &str);
        if (SUCCEEDED(hr))
            hr = StrRetToBuf(&str, pidl, pszOut, cchOut);
    }
    else
        hr = SHGetNameAndFlags(pidl, shgdnf, pszOut, cchOut, NULL);

    return hr;
}

//***   FoldCSIDL -- folder special CSIDLs to keep start menu happy
//
#define FoldCSIDL(csidl) \
    ((csidl) == CSIDL_COMMON_PROGRAMS ? CSIDL_PROGRAMS : (csidl))

//***   UemEncodePidl -- encode pidl into csidl and relative path
//
BOOL UEMEncodePidl(IShellFolder *psf, LPITEMIDLIST pidlItem,
    LPTSTR pszBuf, DWORD cchBuf, int* piIndexStart, int* pcsidl)
{
    static UINT csidlTab[] = { CSIDL_PROGRAMS, CSIDL_COMMON_PROGRAMS, CSIDL_FAVORITES, -1 };
    UINT *pcsidlCur;
    int i;
    TCHAR szFolderPath[MAX_PATH];

    _UEMGetDisplayName(psf, pidlItem, SHGDN_FORPARSING, pszBuf, cchBuf);

    for (pcsidlCur = csidlTab; *pcsidlCur != (UINT)-1; pcsidlCur++) 
    {
        // perf: assume shell32 caches this (it does)
        if (SHGetSpecialFolderPath(NULL, szFolderPath, *pcsidlCur, FALSE))
        {
            i = PathCommonPrefix(szFolderPath, pszBuf, NULL);

            if (i != 0 && i == lstrlen(szFolderPath))  
            {
                *pcsidl = FoldCSIDL(*pcsidlCur);
                *piIndexStart = i;
                return TRUE;
            }
        }
    }

    return FALSE;
}

//***   UEMEvalMsg -- fire event
// ENTRY/EXIT
//  pguidGrp    'owner' of event.  e.g. shell, browser, joe-app, etc.
//  eCmd        command.  one of UEME_* (standard) or UEME_USER+xxx (custom).
//  wP, lP      args.
// NOTES
//  - pri=1 gotta filter events for privacy issues (esp. Ger).  not sure if
//  we should add a param saying 'usage' of event or just infer it from the
//  event.
//  - pri=? gotta encrypt the data we log
//  - pri=? change to UemEvalMsg(eCmd, wParam, lParam)
//
void UEMEvalMsg(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;

    hr = UEMFireEvent(pguidGrp, eCmd, UEMF_XEVENT, wParam, lParam);
    return;
}

STDAPI_(BOOL) UEMGetInfo(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    HRESULT hr;

    hr = UEMQueryEvent(pguidGrp, eCmd, wParam, lParam, pui);
    return SUCCEEDED(hr);
}

class CUserAssist : public IUserAssist
{
public:
    //*** IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    //*** IUserAssist
    virtual STDMETHODIMP FireEvent(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP QueryEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);
    virtual STDMETHODIMP SetEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);

protected:
    CUserAssist();
    HRESULT Initialize();
    virtual ~CUserAssist();
    friend HRESULT CUserAssist_CI2(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    friend void CUserAssist_CleanUp(DWORD dwReason, void *lpvReserved);

    friend HRESULT UEMRegisterNotify(UEMCallback pfnUEMCB, void *param);

    HRESULT _InitLock();
    HRESULT _Lock();
    HRESULT _Unlock();

    void FireNotify(const GUID *pguidGrp, int eCmd)
    {
        // Assume that we have the lock
        if (_pfnNotifyCB)
            _pfnNotifyCB(_param, pguidGrp, eCmd);
    }

    HRESULT RegisterNotify(UEMCallback pfnUEMCB, void *param)
    {
        HRESULT hr;
        int cTries = 0;
        do
        {
            cTries++;
            hr = _Lock();
            if (SUCCEEDED(hr))
            {
                _pfnNotifyCB = pfnUEMCB;
                _param = param;
                _Unlock();
            }
            else
            {
                ::Sleep(100); // wait some for the lock to get freed up
            }
        }
        while (FAILED(hr) && cTries < 20);
        return hr;
    }

private:
    LONG    _cRef;

    HANDLE  _hLock;

    UEMCallback _pfnNotifyCB;
    void        *_param;

};

#define SZ_UALOCK   TEXT("_SHuassist.mtx")


void DoLog(CEMDBLog *pDbLog, TCHAR *pszBuf1, TCHAR *pszBuf2)
{
    if (pDbLog && *pszBuf1) {
        pDbLog->IncCount(pszBuf1);
        if (*pszBuf2) {
            //ASSERT(iGrp == UEMIND_BROWSER);   // not req'd but currently true
            pDbLog->IncCount(pszBuf2);
        }
    }

    return;
}

HRESULT CUserAssist::FireEvent(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf1[32];               // "UEME_xxx"
    TCHAR szBuf2[MAX_URL_STRING];   // "UEME_xxx:0x%x,%x"
    int iGrp;
    CEMDBLog *pDbLog;
    int i, iTab;
    char ch;
    char *pszDope;

    ASSERT(this != 0);

    // If called for instrumentation (NOT event monitor) and instrumentation not enabled
    // we should exit!
    if ((UEMF_INSTRUMENT == (dwFlags & UEMF_MASK)) && (!(g_uemdwFlags & UAAF_INSTR)))
        return E_FAIL;
    
    if (g_uemdwFlags & UAAF_NOLOG)
        return E_FAIL;

    if (eCmd & UEME_FBROWSER) {
        ASSERT(0);
        ASSERT(IsEqualIID(*pguidGrp, UEMIID_NIL));
        pguidGrp = &UEMIID_BROWSER;
        eCmd &= ~UEME_FBROWSER;
    }

    iGrp = UEMIIDToInd(pguidGrp);

    pDbLog = g_uempDbLog[iGrp];

    TraceMsg(DM_UEMTRACE2, "uemt: eCmd=0x%x wP=0x%x lP=0x%x(%d)", eCmd, wParam, (int)lParam, (int)lParam);

    szBuf1[0] = szBuf2[0] = 0;

    iTab = SHSearchInt(UemeValTab, ARRAYSIZE(UemeValTab), eCmd);
    if (iTab == -1) {
        ASSERT(0);
        return E_FAIL;
    }

    pszDope = UemeDopeTab[iTab];

    while (ch = *pszDope++) {
        switch (ch) {
        case 'e':
            i = *pszDope++ - '0';
            UEMEncode(iTab, szBuf1, i >= 2 ? szBuf2 : NULL, SIZECHARS(szBuf2), iGrp, eCmd, wParam, lParam);
            TraceMsg(DM_UEMTRACE, "uemt: %s %s (0x%x %x %x)", szBuf1, szBuf2, eCmd, wParam, lParam);
            break;

        case 'f':
            // make sure we don't cause ourselves trouble in future
            // EM only gives us a couple of DWORDs, so we need s.t. like:
            //  bits(UEMIND_*)+bits(wParam)+bits(lParam) <= bits(DWORD)
            // for now we allow 0/-1 in hiword, if/when we use EM we'll
            // need to clean that up.
#if 0
            // fails for pidls, sigh...
            ASSERT((int)(unsigned short)lParam == lParam ||
                ((int)(short)lParam == lParam));
            UEMEvalIE(irulXxx, fTrue, eCmd);
#endif
            break;

        case 'l':
            if (SUCCEEDED(_Lock())) {
                if (dwFlags & UEMF_EVENTMON)
                    DoLog(pDbLog, szBuf1, szBuf2);
#ifdef UAAF_INSTR
                if ((g_uemdwFlags & UAAF_INSTR) && (dwFlags & UEMF_INSTRUMENT))
                    DoLog(g_uempDbLog[iGrp + UEMIND_NINSTR], szBuf1, szBuf2);
#endif
                FireNotify(pguidGrp, eCmd);
                _Unlock();
            }
            break;

        case 'x':
            TraceMsg(DM_UEMTRACE, "uemt: NYI");
            goto Lnodope;

#ifdef DEBUG
        case '!':
            ASSERT(0);
            break;
#endif

        case '@':
            if (SUCCEEDED(_Lock())) {
                UEMSpecial(iTab, iGrp, eCmd, wParam, lParam);
                FireNotify(pguidGrp, eCmd);
                _Unlock();
            }
            break;
        }
    }
Lnodope:

    return S_OK;
}

HRESULT CUserAssist::QueryEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    int iGrp;
    CEMDBLog *pDbLog;
    TCHAR szBuf1[32];               // "UEME_xxx"
    TCHAR szBuf2[MAX_URL_STRING];   // "UEME_xxx:0x%x,%x"

    ASSERT(this != 0);

    if (g_uemdwFlags & UAAF_NOLOG)
        return E_FAIL;

    ASSERT(eCmd == UEME_RUNPIDL
        || eCmd == UEME_RUNPATH || eCmd == UEME_RUNWMCMD);  // others NYI

    ASSERT(pui->cbSize == SIZEOF(*pui));
    // pui->dwVersion?

    iGrp = UEMIIDToInd(pguidGrp);

    pDbLog = g_uempDbLog[iGrp];

    TraceMsg(DM_UEMTRACE2, "uemgi: eCmd=0x%x wP=0x%x lP=0x%x(%d)", eCmd, wParam, (int)lParam, (int)lParam);

    szBuf1[0] = szBuf2[0] = 0;

    int iTab = SHSearchInt(UemeValTab, ARRAYSIZE(UemeValTab), eCmd);
    UEMEncode(iTab, szBuf1, szBuf2, SIZECHARS(szBuf2), iGrp, eCmd, wParam, lParam);

    int cHit;
    //if (SUCCEEDED(_Lock()))
    cHit = pDbLog->GetCount(szBuf2);
    //_Unlock();

    TraceMsg(DM_UEMTRACE, "uemgi: cHit=%d psz=%s", cHit, szBuf2);

    if (pui->dwMask & UEIM_HIT) 
    {
        pui->cHit = cHit;
    }

    if (pui->dwMask & UEIM_FILETIME) 
    {
        pui->ftExecute = pDbLog->GetFileTime(szBuf2);
    }

    return S_OK;
}

HRESULT CUserAssist::SetEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    int iGrp;
    CEMDBLog *pDbLog;
    TCHAR szBuf1[32];               // "UEME_xxx"
    TCHAR szBuf2[MAX_URL_STRING];   // "UEME_xxx:0x%x,%x"

    ASSERT(this != 0);

    if (g_uemdwFlags & UAAF_NOLOG)
        return E_FAIL;

    ASSERT(pui->cbSize == SIZEOF(*pui));
    // pui->dwVersion?

    iGrp = UEMIIDToInd(pguidGrp);

    pDbLog = g_uempDbLog[iGrp];

    TraceMsg(DM_UEMTRACE2, "uemgi: eCmd=0x%x wP=0x%x lP=0x%x(%d)", eCmd, wParam, (int)lParam, (int)lParam);

    szBuf1[0] = szBuf2[0] = 0;

    int iTab = SHSearchInt(UemeValTab, ARRAYSIZE(UemeValTab), eCmd);
    UEMEncode(iTab, szBuf1, szBuf2, SIZECHARS(szBuf2), iGrp, eCmd, wParam, lParam);

    pui->dwMask &= UEIM_HIT | UEIM_FILETIME;    // what we support

    if (pui->dwMask && SUCCEEDED(_Lock())) {
        if (pui->dwMask & UEIM_HIT) {
            pDbLog->SetCount(szBuf2, pui->cHit);
        }
        if (pui->dwMask & UEIM_FILETIME) {
            pDbLog->SetFileTime(szBuf2, &pui->ftExecute);
        }
        _Unlock();
    }

    return S_OK;
}

//***   CUserAssist::CCI,ctor/dtor/init {

IUnknown *g_uempUaSingleton;

//***   CUserAssist_CreateInstance -- manage *singleton* instance
//
HRESULT CUserAssist_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr = E_FAIL;

    if (g_uempUaSingleton == 0) {
        IUnknown *pua;

        hr = CUserAssist_CI2(pUnkOuter, &pua, poi);
        if (pua)
        {
            ENTERCRITICAL;
            if (g_uempUaSingleton == 0)
            {
                // Now the global owns the ref.
                g_uempUaSingleton = pua;    // xfer refcnt
                pua = NULL;
            }
            LEAVECRITICAL;
            if (pua)
            {
                // somebody beat us.
                // free up the 2nd one we just created, and use new one
                TraceMsg(DM_UEMTRACE, "sl.cua_ci: undo race");
                pua->Release();
            }

            // Now, the caller gets it's own ref.
            g_uempUaSingleton->AddRef();
            TraceMsg(DM_UEMTRACE, "sl.cua_ci: create pua=0x%x g_uempUaSingleton=%x", pua, g_uempUaSingleton);
        }
    }
    else {
        g_uempUaSingleton->AddRef();
    }

    TraceMsg(DM_UEMTRACE, "sl.cua_ci: ret g_uempUaSingleton=0x%x", g_uempUaSingleton);
    *ppunk = g_uempUaSingleton;
    return *ppunk ? S_OK : hr;
}

//***   CUserAssist_CI2 -- *always* create instance
//
HRESULT CUserAssist_CI2(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CUserAssist * p = new CUserAssist();

    if (p && FAILED(p->Initialize())) {
        delete p;
        p = NULL;
    }

    if (p) {
        *ppunk = SAFECAST(p, IUserAssist*);
        return S_OK;
    }

    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

extern "C"
HRESULT UEMRegisterNotify(UEMCallback pfnUEMCB, void *param)
{
    HRESULT hr = E_UNEXPECTED;
    if (g_uempUaSingleton)
    {
        CUserAssist *pua = reinterpret_cast<CUserAssist *>(g_uempUaSingleton);
        hr = pua->RegisterNotify(pfnUEMCB, param);
    }
    return hr;
}

extern void GetUEMSettings();
DWORD g_dwSessionStart; // When did this session start?

#if defined(_M_IX86) && (_MSC_VER < 1200)
#pragma optimize("", off)
#define BUG_OPTIMIZE        // restore, see below
#endif

//***
HRESULT CUserAssist::Initialize()
{
    HRESULT hr = S_OK;

    ASSERT(UEMIND_SHELL == 0 && UEMIND_BROWSER == 1);

    hr = _InitLock();

    // get standard loggers
    if (SUCCEEDED(hr))
        hr = GetUEMLogger(UEMIND_SHELL, &g_uempDbLog[UEMIND_SHELL]);
    if (SUCCEEDED(hr))
        hr = GetUEMLogger(UEMIND_BROWSER, &g_uempDbLog[UEMIND_BROWSER]);

    if (SUCCEEDED(hr)) {
        FInitEm();
    }

    GetUEMSettings();

#define UAXF_XSETTINGS  (UAXF_NOPURGE|UAXF_BACKUP|UAXF_NOENCRYPT)
    if (g_uempDbLog[UEMIND_SHELL]) 
    {
        g_uempDbLog[UEMIND_SHELL]->_SetFlags(UAXF_XSETTINGS, g_uemdwFlags & UAXF_XSETTINGS);
        // n.b. just for shell (browser no need, instr no decay)
        g_uempDbLog[UEMIND_SHELL]->GarbageCollect(FALSE);
    }

    if (g_uempDbLog[UEMIND_BROWSER])
    {
        g_uempDbLog[UEMIND_BROWSER]->_SetFlags(UAXF_XSETTINGS, g_uemdwFlags & UAXF_XSETTINGS);
        g_uempDbLog[UEMIND_BROWSER]->GarbageCollect(FALSE);
    }
    
#ifdef UAAF_INSTR
    if (g_uemdwFlags & UAAF_INSTR) {
        if (SUCCEEDED(hr))
            hr = GetUEMLogger(UEMIND_SHELL2, &g_uempDbLog[UEMIND_SHELL2]);
        if (SUCCEEDED(hr))
            hr = GetUEMLogger(UEMIND_BROWSER2, &g_uempDbLog[UEMIND_BROWSER2]);
        if (g_uempDbLog[UEMIND_SHELL2]) {
            g_uempDbLog[UEMIND_SHELL2]->_SetFlags(UAXF_XSETTINGS, g_uemdwFlags & UAXF_XSETTINGS);
            g_uempDbLog[UEMIND_SHELL2]->_SetFlags(UAXF_NODECAY, UAXF_NODECAY);
        }
        if (g_uempDbLog[UEMIND_BROWSER2]) {
            g_uempDbLog[UEMIND_BROWSER2]->_SetFlags(UAXF_XSETTINGS, g_uemdwFlags & UAXF_XSETTINGS);
            g_uempDbLog[UEMIND_BROWSER2]->_SetFlags(UAXF_NODECAY, UAXF_NODECAY);
        }
    }
#endif

    g_dwSessionStart = GetTickCount();
    UEMEnableTimer(UATTOMSEC(g_dIdleTime));

    return hr;
}

#ifdef BUG_OPTIMIZE
#pragma optimize("", on)
#undef BUG_OPTIMIZE
#endif

void CEMDBLog_CleanUp();

//***   CUserAssist_CleanUp -- free up the world (on DLL_PROCESS_DETACH)
// NOTES
//  a bit hoaky right now since our UEMLog object isn't really refcnt'ed
void CUserAssist_CleanUp(DWORD dwReason, void *lpvReserved)
{
    int i;
    IUnknown *pUa;

    ASSERT(dwReason == DLL_PROCESS_DETACH);
    if (lpvReserved != 0) {
        // on process termination, *don't* nuke us since:
        //  - safety: other DLLs in our process may still be using us, and
        // they'll blow up when they reference us if we're freed
        //  - leaks: process termination will free us up when all is done,
        // so there's no worry about a leak
        TraceMsg(DM_UEMTRACE, "bui.cua_cu: skip cleanup (end process/non-FreeLibrary)");
        return;
    }
    // otherwise, on FreeLibrary, *do* nuke us since:
    //  - safety: our refcnt is 0, so nobody is using us any more
    //  - leaks: multiple Load/FreeLibrary calls will cause a leak if we
    // don't free ourselves here

    //ENTERCRITICAL;

    TraceMsg(DM_UEMTRACE, "bui.cua_cu: cleaning up");

    UEMEnableTimer(0);

    // free cache (and make sure we'll GPF if we party on it further)
    for (i = 0; i < UEMIND_NSTANDARD + UEMIND_NINSTR; i++) {
        // UEMIND_SHELL, UEMIND_BROWSER, UEMIND_SHELL2, UEMIND_BROWSER2
        InterlockedExchangePointer((void**) &g_uempDbLog[i], (LPVOID) -1);
    }

    // free 'real' guy
    CEMDBLog_CleanUp();

    // free THIS
    if (pUa = (IUnknown *)InterlockedExchangePointer((void**) &g_uempUaSingleton, (LPVOID) -1)) {
        delete SAFECAST(pUa, CUserAssist *);
    }

    //LEAVECRITICAL;
}

DWORD Reg_GetFlags(DWORD dwInit, HKEY hk, LPCTSTR pszSubkey, LPCTSTR const pszNameTab[], DWORD *dwMaskTab, int cTab)
{
    int i;
    DWORD dwMasks, dwVals;

    dwMasks = dwVals = 0;
    for (i = 0; i < cTab; i++) {
        DWORD dwData, cbSize = SIZEOF(dwData);
        if (SHGetValue(hk, pszSubkey, pszNameTab[i], NULL, &dwData, &cbSize) == ERROR_SUCCESS) {
            TraceMsg(DM_UEMTRACE, "ua: regkey %s\\%s=0x%x", pszSubkey, pszNameTab[i], dwData);
            dwMasks |= dwMaskTab[i];
            if (dwData)
                dwVals |= dwMaskTab[i];
        }
    }
    dwInit = BIT_ASSIGN(dwInit, dwMasks, dwVals);
    TraceMsg(DM_UEMTRACE, "ua.grs: ret 0x%x", dwInit);
    return dwInit;
}

void Reg_GetVals(HKEY hk, LPCTSTR pszSubkey, LPCTSTR const pszNameTab[], DWORD **dwValTab, int cTab)
{
    for (int i = 0; i < cTab; i++) {
        DWORD dwData, cbSize = SIZEOF(dwData);
        if (SHGetValue(hk, pszSubkey, pszNameTab[i], NULL, &dwData, &cbSize) == ERROR_SUCCESS) {
            TraceMsg(DM_UEMTRACE, "ua: regkey %s/%s=0x%x", pszSubkey, pszNameTab[i], dwData);
            *dwValTab[i] = dwData;
        }
    }
}

void GetUEMSettings()
{
    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, NULL, FALSE);
    if (hk)
    {
        static const LPCTSTR pszName1Tab[] = {
            SZ_NOPURGE  , SZ_BACKUP  , SZ_NOLOG  , SZ_INSTRUMENT, SZ_NOENCRYPT,
        };
        static DWORD dwMask1Tab[] = {
            UAXF_NOPURGE, UAXF_BACKUP, UAAF_NOLOG, UAAF_INSTR   , UAXF_NOENCRYPT,
        };
        static const LPCTSTR pszName2Tab[] = { SZ_SESSTIME,  SZ_IDLETIME , SZ_CLEANTIME, };
        static DWORD *dwVal2Tab[]   = { &g_dSessTime, &g_dIdleTime, &g_dCleanSess,};

        g_uemdwFlags = Reg_GetFlags(g_uemdwFlags, hk, SZ_UASSIST TEXT("\\") SZ_SETTINGS, pszName1Tab, dwMask1Tab, ARRAYSIZE(pszName1Tab));

        TraceMsg(DM_UEMTRACE, "ua: g_uemdwFlags=0x%x", g_uemdwFlags);

        Reg_GetVals(hk, SZ_UASSIST TEXT("\\") SZ_SETTINGS, pszName2Tab, dwVal2Tab, ARRAYSIZE(pszName2Tab));
        if (!((int)UAS_SESSMIN <= (int)g_dSessTime /*&& g_dSessTime<=UAS_SESSMAX*/))
            g_dSessTime = UAS_SESSTIME;
        if (!((int)UAS_IDLEMIN <= (int)g_dIdleTime /*&& g_dIdleTime<=UAS_IDLEMAX*/))
            g_dIdleTime = UAS_IDLETIME;

        RegCloseKey(hk);
    }

    if (SHRestricted2(REST_NoUserAssist, NULL, 0)) {
        TraceMsg(DM_WARNING, "ua: restrict off!");
        g_uemdwFlags |= UAAF_NOLOG;
        g_uemdwFlags &= ~UAAF_INSTR;    // paranoia (UAAF_NOLOG should be enuf)
    }

#ifdef DEBUG
    if (g_uemdwFlags & UAAF_NOLOG)
        TraceMsg(DM_WARNING, "ua: logging off!");
#endif

    return;
}

CUserAssist::CUserAssist() : _cRef(1)
{
    return;
}

//***
// NOTES
//  n.b. we're only called on DLL_PROCESS_DETACH (refcnt never really
// goes to 0).
CUserAssist::~CUserAssist()
{
    if (_hLock)
        CloseHandle(_hLock);
#if 1 // 981022 breadcrumbs for stress failure (see if we're double freed)
    //memcpy((BYTE *)_hLock, "CUAd", 4);
    _hLock = (void *)0x77777777;
#endif

    return;
}

// }

//***   CUserAssist::IUnknown::* {

ULONG CUserAssist::AddRef()
{
    TraceMsg(DM_UEMTRACE2, "cua.ar: _cRef=%d++", _cRef);
    return InterlockedIncrement(&_cRef);
}

ULONG CUserAssist::Release()
{
    ASSERT(_cRef > 0);

    TraceMsg(DM_UEMTRACE2, "cua.r: _cRef=%d--", _cRef);
    // n.b. returns <0,=0,>0 (not actual dec result)
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CUserAssist::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CUserAssist, IUserAssist),         // IID_IUserAssist
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

// }

//***   locking stuff {

HRESULT CUserAssist::_InitLock()
{
    HRESULT hr = S_OK;

    if ((_hLock = CreateMutex(NULL, FALSE, SZ_UALOCK)) == NULL) {
        TraceMsg(TF_ERROR, "cua.i: no mutex");
        hr = E_FAIL;
    }

    return hr;
}

#define LOCK_TIMEOUT    0   // immediate timeout, should be rare

HRESULT CUserAssist::_Lock()
{
    DWORD dwRes;

    dwRes = WaitForSingleObject(_hLock, LOCK_TIMEOUT);
    switch (dwRes) {
    case WAIT_ABANDONED:
        return S_FALSE;

    case WAIT_OBJECT_0:
        return S_OK;

    case WAIT_TIMEOUT:
        TraceMsg(DM_UEMTRACE, "cua.l: locked (timeout)");
        return E_FAIL;
    }
    /*NOTREACHED*/
    return E_FAIL;
}

HRESULT CUserAssist::_Unlock()
{
    ReleaseMutex(_hLock);
    return S_OK;
}


// }

//***   timer stuff {

DWORD_PTR g_idTimer;
BOOL g_fIdle /*=FALSE*/;

#if !(_WIN32_WINNT >= 0x0500) // {

#define GetLastInputInfo    UEMGetLastInputInfo

typedef struct {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO;

DWORD g_dwTime;         // prev GetTickCount
int g_csKeys;           // prev GetKeyboardState
int g_csCursor;         // prev GetCursorPos

BOOL (*g_pfnGLII)(LASTINPUTINFO *plii);     // 'real' version

//***   memsum -- checksum bytes
//
int memsum(void *pv, int n)
{
    unsigned char *pb = (unsigned char *)pv;
    int sum = 0;

    while (n-- > 0)
        sum += *pb++;

    return sum;
}

//***   UEMGetLastInputInfo -- simulate (sort of...) GetLastInputInfo
// DESCRIPTION
//  we fake it big time.  our detection of 'currently non-idle' is pretty
// good, but the the actual *time* we were idle is pretty iffy.  each time
// we're called defines a checkpoint.  any time the new checkpoint differs
// from the old one, we update our (approx) idle start point.
BOOL UEMGetLastInputInfo(LASTINPUTINFO *plii)
{
    int csCursor, csKeys;
    POINT ptCursor;
    BYTE ksKeys[256];       // per GetKeyboardState spec

    if (g_dwTime == 0) {
        // 1st time here...
        g_dwTime = GetTickCount();
        g_csCursor = g_csKeys = -1;
        // GetProcAddress only accepts ANSI.
        *(FARPROC *)&g_pfnGLII = GetProcAddress(GetModuleHandle(TEXT("user32.dll")),
            "GetLastInputInfo");
        TraceMsg(DM_UEMTRACE, "bui.glii: init g_dwTime=%d pfn=0x%x", g_dwTime, g_pfnGLII);
    }

#if 1 // 980313 adp: off until we can test it!
    // 1st try the easy (and exact) way...
    if (g_pfnGLII)
        return (*g_pfnGLII)(plii);
#endif

    // now the hard (and approximate) way...
    csCursor = csKeys = -1;
    if (GetCursorPos(&ptCursor))
        csCursor = memsum(&ptCursor, SIZEOF(ptCursor));
    if (GetKeyboardState(ksKeys))
        csKeys = memsum(ksKeys, SIZEOF(ksKeys));
    
    if (csCursor != g_csCursor || csKeys != g_csKeys
      || (csCursor == -1 && csKeys == -1)) {
        TraceMsg(DM_UEMTRACE, "bui.glli: !idle cur=0x%x cur'=%x keys=%x keys'=%x gtc(old)=%x",
            g_csCursor, csCursor, g_csKeys, csKeys, g_dwTime);
        g_dwTime = GetTickCount();
        g_csCursor = csCursor;
        g_csKeys = csKeys;
    }

    plii->dwTime = g_dwTime;

    TraceMsg(DM_UEMTRACE, "bui.uastp: !nt5, simulate GLII()=%d", plii->dwTime);

    return TRUE;
}

#endif // }

LRESULT UEMSendTrayMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    //  We may be sending a function pointer, so make sure the target window
    //  is in our address space.
    //
    //  We need to revalidate that g_hwndTray really is the
    //  tray window, because Explorer may have crashed, and then the
    //  window handle got recycled into our process, and so we send
    //  a random message to a window that isn't what we think it is.
    // (raymondc)
    //
    HWND hwndTray;
    DWORD dwPid;
    LRESULT lres;

    hwndTray = GetTrayWindow();
    if (IsWindow(hwndTray) &&
        GetWindowThreadProcessId(hwndTray, &dwPid) &&
        dwPid == GetCurrentProcessId()) {
        lres = SendMessage(hwndTray, uMsg, wParam, lParam);
    } else {
        lres = 0;
    }
    return lres;
}

//***
//
//  UEMTimerProc
//
//  Periodically checks if the user has gone idle.
//
//  Rules for session increment:
//
//  No session lasts longer than g_dIdleTime units.
//
//  If the user remains idle for a long time, keep bumping the
//  "start of session" timer so time spent idle does not count towards
//  the new session.
//
void CALLBACK UEMTimerProc(HWND hwnd, UINT uMsg, UINT idEvt, DWORD dwNow)
{
#ifdef DEBUG
    static long iDepth;     // make sure we don't get 2 ticks
#endif
    UINT dwIdleTime;        // mSec
    LASTINPUTINFO lii;

    ASSERT(iDepth == 0);
    ASSERT(InterlockedIncrement(&iDepth) > 0);

    UEMEnableTimer(0);

    dwIdleTime = UATTOMSEC(g_dIdleTime);    // convert to mSec's (again...)

    lii.cbSize = SIZEOF(lii);
    if (GetLastInputInfo(&lii)) {
        DWORD dwNow = GetTickCount();

        TraceMsg(DM_IDLEDETECT, "UEM.tp: now-start=%d, now-last=%d",
                 dwNow - g_dwSessionStart, dwNow - lii.dwTime);

        if (!g_fIdle && dwNow - g_dwSessionStart >= dwIdleTime)
        {
            g_fIdle = TRUE;
            g_dwSessionStart = dwNow;
            TraceMsg(DM_IDLEDETECT, "UEM.tp: IncrementSession");
            UEMFireEvent(&UEMIID_SHELL, UEME_CTLSESSION, UEMF_XEVENT, TRUE, -1);
            UEMFireEvent(&UEMIID_BROWSER, UEME_CTLSESSION, UEMF_XEVENT, TRUE, -1);
            UEMSendTrayMessage(TM_REFRESH, 0, 0); // RefreshStartMenu
        }

        //
        //  Get out of idle mode if the user has done anything since
        //  the session started.  And mark the session as having started
        //  at the point the user did something.
        //
        if (dwNow - lii.dwTime < dwNow - g_dwSessionStart) {
            TraceMsg(DM_IDLEDETECT, "UEM.tp: not idle; starting new session");
            g_dwSessionStart = lii.dwTime;
            g_fIdle = FALSE;
        }

        //
        //  Now decide how much longer before the next interesting event.
        //
        DWORD dwWait = g_fIdle ? dwIdleTime : dwIdleTime - (dwNow - g_dwSessionStart);

        TraceMsg(DM_UEMTRACE, "UEM.tp: sleep=%d", dwWait);
        UEMEnableTimer(dwWait);
    }
    //else timer left disabled

    ASSERT(InterlockedDecrement(&iDepth) == 0);
    return;
}

//***   UEMEnableTimer -- turn timer on/off
// ENTRY
//  uTimeout    delay in mSec; 0 means disable
void UEMEnableTimer(UINT uTimeout)
{
#if !(_WIN32_WINNT >= 0x0500)
    static BOOL fVirg = TRUE;   // 1st time thru?

    if (fVirg) {
        LASTINPUTINFO lii;

        fVirg = FALSE;

        lii.cbSize = SIZEOF(lii);
        GetLastInputInfo(&lii);     // prime it in case it's simulated
    }
#endif

    if (uTimeout) {
        // ASSERT(!g_idTimer); // race window can hit this assert spuriously
        g_idTimer = UEMSendTrayMessage(TM_SETTIMER, uTimeout, (LPARAM)UEMTimerProc);
    }
    else if (g_idTimer) {
        UEMSendTrayMessage(TM_KILLTIMER, 0, g_idTimer);
        g_idTimer = 0;
    }

    return;
}

// }

// }

//***   utils {

//***   FAST_IsEqualIID -- fast compare
// (cast to 'int' so don't get overloaded ==)
#define FAST_IsEqualIID(piid1, piid2)   ((int) (piid1) == (int) (piid2))

//***
// ENTRY/EXIT
//  iGuid   (return) index of GUID in table, o.w. -1 if not found
// NOTES
//  move to shlwapi if this is needed some place other than here.
int SHSearchIID(IID **pguidTab, int cnt, IID *pguidVal)
{
    IID **pguid;
    BOOL fInt;

    pguid = pguidTab;
    fInt = (pguidVal == 0 || pguidVal == (IID *)-1);
    for (; cnt > 0; cnt--, pguid++) {
        if (fInt) {
            if (*pguid == pguidVal)
                goto Lfound;
        }
        else if (IsEqualIID(**pguid, *pguidVal)) {
Lfound:
            return (int)(pguid - pguidTab);
        }
    }
    return -1;
}

int SHSearchInt(int *psrc, int cnt, int val)
{
    int *pcur;

    pcur = psrc;
    for (; cnt > 0; cnt--, pcur++) {
        if (*pcur == val)
            return (int)(pcur - psrc);
    }
    return -1;
}

int UEMIIDToInd(const GUID *pguidGrp)
{
    int iGrp;

    if (IsEqualIID(*pguidGrp, UEMIID_BROWSER))
        iGrp = UEMIND_BROWSER;
    else if (IsEqualIID(*pguidGrp, UEMIID_SHELL))
        iGrp = UEMIND_SHELL;
    else 
    {
        ASSERT(IsEqualIID(*pguidGrp, UEMIID_NIL));
        iGrp = UEMIND_SHELL;
    }

    return iGrp;
}
// }


// {
#if 0 // currently unused

// glue for standalone test {
//#define XXX_TEST
//#define XXX_DEBUG

#ifdef XXX_TEST // {
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

#define lstrlen(s1)         strlen(s1)
#define lstrcmp(s1, s2)     strcmp(s1, s2)
#define lstrncmp(s1, s2, n) strncmp(s1, s2, n)

#define TRUE    1
#define FALSE   0
#endif // }
// }

//***   rule: smart rename
// DESCRIPTION
//  we recognize renames that remove prefixes (e.g. "Shortcut to ..."),
//  and apply automatically to future renames.  adding back the prefix
//  resets to the original state.
// NOTES
//  assumes only care about prefix, which is bogus for non-US

struct renpre {
    char    *pszPrefix;     // prefix we care about
    int     fChange;        // recent change: 0=nil +1=add -1=del
};

struct renpre SmartPrefixTab[] = {
    { "Shortcut to ", 0 },
    0
};

//***   IsSuffix -- return index of (possible) suffix in string
// ENTRY/EXIT
//  i   (return) index of suffix in string, o.w. -1
int IsSuffix(char *pszStr, char *pszSuf)
{
    int cchStr, cchSuf;
    int i;

    cchStr = lstrlen(pszStr);
    cchSuf = lstrlen(pszSuf);
    if (cchSuf > cchStr)
        return -1;
    i = cchStr - cchSuf;
    if (lstrcmp(pszStr + i, pszSuf) == 0)
        return i;
    return -1;
}

int UpdateSmartPrefix(char *pszOld, char *pszNew, int fChange);

//***   UEMOnRename -- track renames for interesting patterns
// ENTRY/EXIT
//  (SE)    updates smart prefix table if rename effects it
void UEMOnRename(char *pszOld, char *pszNew)
{
    if (UpdateSmartPrefix(pszOld, pszNew, -1)) {
#ifdef XXX_DEBUG
        //  "Shortcut to foo" to "foo"
        printf("or: -1\n");
#endif
    }
    else if (UpdateSmartPrefix(pszNew, pszOld, +1)) {
#ifdef XXX_DEBUG
        //  "foo" to "Shortcut to foo"
        printf("or: +1\n");
#endif
    }
    return;
}

//***   UpdateSmartPrefix -- if op effects prefix, mark change
//
int UpdateSmartPrefix(char *pszOld, char *pszNew, int fChange)
{
    int i;
    struct renpre *prp;

    // (note that if we rename to the same thing, i==0, so we don't
    // do anything.  this is as it should be).

    if ((i = IsSuffix(pszOld, pszNew)) > 0) {
        prp = &SmartPrefixTab[0];   // TODO: for each ...

        // iSuf==cchPre, so pszOld[0..iSuf-1] is prefix
        if (i == lstrlen(prp->pszPrefix) && lstrncmp(pszOld, prp->pszPrefix, i) == 0) {
#ifdef XXX_DEBUG
            printf("usp: o=%s n=%s p=%s f=%d\n", pszOld, pszNew, SmartPrefixTab[0].pszPrefix, fChange);
#endif
            prp->fChange = fChange;
            return 1;
        }
    }

    return 0;
}

//***   GetSmartRename --
// ENTRY/EXIT
//  pszDef  proposed default name (in 'original' form, e.g. 'Shortcut to')
//  i       (ret) index of 'smart' default name
int GetSmartRename(char *pszDef)
{
    char *pszPre;
    int cchPre;

    // for each prefix in smartPrefixList ...
    pszPre = SmartPrefixTab[0].pszPrefix;

    cchPre = lstrlen(pszPre);
    if (strncmp(pszDef, pszPre, cchPre) == 0) {
        if (SmartPrefixTab[0].fChange == -1)
            return cchPre;
    }
    return 0;
}
#endif
// }

#ifdef XXX_TEST // {
char c_szScToFoo[] = "Shortcut to foo";
char c_szScToFred[] = "Shortcut to fred";

char *TestTab[] = {
    c_szScToFoo,
    c_szScToFred,
    "bar",
    0
};

pr(char *p)
{
    int i;

    i = GetSmartRename(p);
    if (i >= 0)
        printf("\t<%s>", p + i);
    else
        printf("\t<%s>", p);
    return;
}

prtab()
{
    pr("foo");
    pr(c_szScToFoo);
    pr(c_szScToFred);
    printf("\n");
}

TstRename()
{
    int i;

    // original
    prtab();

    // delete
    printf("del\n");
    UEMOnRename(c_szScToFoo, "foo");
    prtab();

    // ... again
    printf("del\n");
    UEMOnRename(c_szScToFoo, "foo");
    prtab();

    // add (restore)
    printf("add\n");
    UEMOnRename("foo", c_szScToFoo);
    prtab();

    // ... again
    printf("add\n");
    UEMOnRename("foo", c_szScToFoo);
    prtab();

    // delete partial (shouldn't look like prefix)
    printf("del partial\n");
    UEMOnRename(c_szScToFoo, "to foo");
    prtab();

    // rename to same (shouldn't look like prefix)
    printf("ren same\n");
    UEMOnRename(c_szScToFoo, "c_szScToFoo");
    prtab();
}

main()
{
    TstRename();
}

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\emclient\uacount.h ===
//***   CUACount -- user-assistance counter w/ decay
//
#define XXX_DELETE      1
#define XXX_VERSIONED   0

//***   NRW -- named i/o
// DESCRIPTION
//  i/o to a 'named' location (e.g. registry)
typedef struct {
    void *self;
    LPCTSTR pszName;
} NRWINFO, *PNRWINFO;

typedef HRESULT (*PFNNRW)(void *pvBuf, DWORD cbBuf, PNRWINFO prwi);
typedef struct {
    PFNNRW _pfnRead;
    PFNNRW _pfnWrite;
    PFNNRW _pfnDelete;
} FNNRW3, *PFNNRW3;

//***   UAQ_* -- quantum
// NOTES
//  todo: for now everything is flat
typedef enum {
    UAQ_TASK=0,
    UAQ_DOC=0,
    UAQ_APP=0,
    UAQ_SESSION=0
} UAQUANTUM;
#define UAQ_DEFAULT UAQ_SESSION         // currently implemented quanta
#define UAQ_COUNT   (UAQ_SESSION + 1)

typedef DWORD   UATIME;                 // 1 minute (approx)

#define UAT_MINUTE1 ((UATIME)1)         // 1  minute
#define UAT_HOUR12  ((UATIME)(12 * 60)) // 12 hours (see FTToUATime)

extern UATIME GetUaTime(LPSYSTEMTIME pst);

//***   UATTOMSEC -- convert UATIME to mSec's
// NOTES
//  ISSUE: we should be more accurate.  currently we just assume a UATIME
// is exactly 1 minute, which it's not...  easy enough to do, but we'll
// wait until i have time to do the math.
#define UATTOMSEC(uat)      ((uat) * 60 * 1000)

class IUASession
{
public:
    virtual void SetSession(UAQUANTUM uaq, BOOL fForce) PURE;
    virtual int GetSessionId() PURE;
};

class CUASession : public IUASession
{
    struct SUASession {
#if XXX_VERSIONED
        UINT    _cbSize;
#endif
        UATIME  _qtMru;
        int     _cCnt;
    };

public:
    void SetSession(UAQUANTUM uaq, BOOL fForce);
    int GetSessionId();

    CUASession();           // n.b. public so can stack-alloc
    HRESULT Initialize();
    HRESULT LoadFrom(PFNNRW3 pfnIO, PNRWINFO pRwi);
    HRESULT SaveTo(BOOL fForce, PFNNRW3 pfnIO, PNRWINFO pRwi);

protected:
    // for xfers directly into me w/o an extra copy-ctor
    // e.g. p->QueryValue(pszName, aUac.GetRawData(), &cb);
    // e.g. p->SetValue  (pszName, aUac.GetRawData(), aUac.GetRawCount());
    _inline BYTE *  _GetRawData() { return (BYTE *)&_qtMru; };
    _inline DWORD   _GetRawCount() { return SIZEOF(SUASession); };

    //struct SUASession {
#if XXX_VERSIONED
        UINT    _cbSize;
#endif
        UATIME  _qtMru;
        int     _cCnt;
    //};

    BITBOOL         _fInited : 1;   // 1:we've been initialized
    BITBOOL         _fDirty : 1;    // 1:save me (e.g. _sidMru was xformed)
};

// all special values are < 0 for easy check
#define SID_SNOWREAD    (-1)    // like SID_SNOWINIT, but no auto-save
#define SID_SNOWINIT    (-2)    // convert to 'now' on 1st read
#define SID_SNOWALWAYS  (-3)    // always 'now'

#define ISSID_SSPECIAL(s) ((int)(s) < 0)

// tunable values for IncCount (talk to your neighborhood PM)
#define UAC_NEWCOUNT    2      // brand-new count starts from here
#define UAC_MINCOUNT    6      // incr to a minimum of this

class CUACount
{
    // must match CUACount semi-embedded struct
    struct SUACount 
    {
#define UAC_d0  _sidMruDisk
#if XXX_VERSIONED
#undef  UAC_d0
#define UAC_d0  _cbSize
        UINT    _cbSize;
#endif
        UINT    _sidMruDisk;    // MRU for this entry
        // todo: eventually we'll want task,doc,app,session
        // so this will be _cCnt[UAQ_COUNT], and we'll index by _cCnt[quanta]
        int     _cCnt;      // use count (lazily decayed)
        FILETIME _ftExecuteTime;
    };

public:
    CUACount();         // n.b. public so can stack-alloc
    HRESULT Initialize(IUASession *puas);
    HRESULT LoadFrom(PFNNRW3 pfnIO, PNRWINFO pRwi);
    HRESULT SaveTo(BOOL fForce, PFNNRW3 pfnIO, PNRWINFO pRwi);

#ifdef DEBUG
    BOOL    DBIsInit();
#endif
    int     GetCount();
    void    IncCount();
    void    AddCount(int i);
    void    SetCount(int cCnt);
    void    UpdateFileTime();
    FILETIME GetFileTime();
    void SetFileTime(const FILETIME *pft);

    // most people should *not* call these
    void    _SetMru(UINT sidMru) { _sidMruDisk = sidMru; Initialize(_puas); };
    int     _GetCount() { return _cCnt; };
#if XXX_DELETE
    DWORD   _SetFlags(DWORD dwMask, DWORD dwValue);
        #define UACF_INHERITED  0x01
        #define UACF_NODECAY    0x02
#endif

protected:
    int     _DecayCount(BOOL fWrite);
    UINT    _ExpandSpecial(UINT sidMru);

    // for xfers directly into me w/o an extra copy-ctor
    // e.g. p->QueryValue(pszName, aUac.GetRawData(), &cb);
    // e.g. p->SetValue  (pszName, aUac.GetRawData(), aUac.GetRawCount());
    _inline BYTE *  _GetRawData() { return (BYTE *)&UAC_d0; };
    _inline DWORD   _GetRawCount() { return SIZEOF(SUACount); };

    // struct SUACount {
#if XXX_VERSIONED
    UINT    _cbSize;        // SIZEOF
#endif
    UINT    _sidMruDisk;    // MRU for this entry
    // todo: eventually we'll want task,doc,app,session
    // so this will be cCnt[UAQ_COUNT], and we'll index by cCnt[quanta]
    int     _cCnt;      // use count (lazily decayed)
    FILETIME _ftExecuteTime;
    // }
    UINT    _sidMru;    // MRU for this entry

    IUASession *    _puas;          // session callback
    BITBOOL         _fInited : 1;   // 1:we've been initialized
    BITBOOL         _fDirty : 1;    // 1:save me (e.g. _sidMru was xformed)
#if XXX_DELETE
    BITBOOL         _fInherited : 1;    // 1:we didn't exist
#else
    BITBOOL         _fUnused : 1;
#endif
    BITBOOL         _fNoDecay : 1;      // 1:don't decay me
    BITBOOL         _fNoPurge : 1;      // 1:don't auto-delete me (debug)

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\augisf.h ===
#ifndef _AUGISF_H
#define _AUGISF_H


// Augmented IShellFolder Object.  This takes two IShellFolder interfaces
// and wraps them so an object can enumerate as if they were in a single
// IShellFolder implementation.


class CAugmentedISF : public IAugmentedShellFolder2,
                      public IShellService,
                      public ITranslateShellChangeNotify
{
    
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID,void **);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
    // *** IShellFolder methods ***
    virtual STDMETHODIMP ParseDisplayName(HWND hwndOwner,
                                LPBC pbcReserved, LPOLESTR lpszDisplayName,
                                ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);

    virtual STDMETHODIMP EnumObjects( THIS_ HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList);

    virtual STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                                ULONG * rgfInOut);
    virtual STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                REFIID riid, UINT * prgfInOut, LPVOID * ppvOut);
    virtual STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    virtual STDMETHODIMP SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                                LPCOLESTR lpszName, DWORD uFlags,
                                LPITEMIDLIST * ppidlOut);

    // *** IAugmentedShellFolder methods ***
    virtual STDMETHODIMP AddNameSpace(const GUID * pguidObject, IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags);
    virtual STDMETHODIMP GetNameSpaceID(LPCITEMIDLIST pidl, GUID * pguidOut);
    virtual STDMETHODIMP QueryNameSpace(DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf);
    virtual STDMETHODIMP EnumNameSpace(DWORD uNameSpace, DWORD * pdwID);

    // *** IAugmentedShellFolder2 methods ***
    //not used
    //virtual STDMETHODIMP GetNameSpaceCount( OUT LONG* pcNamespaces ) ;
    //virtual STDMETHODIMP GetIDListWrapCount( LPCITEMIDLIST pidlWrap, OUT LONG * pcPidls) ;
    virtual STDMETHODIMP UnWrapIDList( LPCITEMIDLIST pidlWrap, LONG cPidls, IShellFolder** apsf, LPITEMIDLIST * apidlFolder, LPITEMIDLIST * apidlItems, LONG * pcFetched ) ;

    // *** IShellService methods ***
    virtual STDMETHODIMP SetOwner(IUnknown * punkOwner);

    // *** ITranslateShellChangeNotify methods ***
    virtual STDMETHODIMP TranslateIDs(LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                      LONG *plEvent2, LPITEMIDLIST * ppidlOut1Event2, LPITEMIDLIST * ppidlOut2Event2);
    virtual STDMETHODIMP IsChildID(LPCITEMIDLIST pidlKid, BOOL fImmediate);
    virtual STDMETHODIMP IsEqualID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual STDMETHODIMP Register(HWND hwnd, UINT uMsg, long lEvents);
    virtual STDMETHODIMP Unregister();

protected:
    CAugmentedISF();
    ~CAugmentedISF();

    friend HRESULT  CAugmentedISF_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    
    IShellFolder *  _GetObjectPSF(int nID);
    BOOL            _IsCommonPidl(LPCITEMIDLIST pidl);

    STDMETHOD_( LPITEMIDLIST, TranslatePidl )( LPCITEMIDLIST pidlNS, LPCITEMIDLIST pidl, LPARAM lParam /*int nID*/) ;
    STDMETHOD_( LPITEMIDLIST, GetNativePidl )( LPCITEMIDLIST pidl, LPARAM lParam /*int nID*/) ;



    int     _cRef;
    HDPA    _hdpa;

    IUnknown * _punkOwner;
};


#endif  // _AUGISF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\augm.cpp ===
//-------------------------------------------------------------------------//
//  
//  AugMisf.cpp  - Augmented Merge IShellFolder class implementation.
//
//-------------------------------------------------------------------------//
#include "priv.h"
#include "augmisf.h"
#include "resource.h"

#include "mluisupp.h"

#define TF_AUGM 0x10000000
//-------------------------------------------------------------------------//
//  BUGBUG: Shell allocator bullchit, inserted here because SHRealloc 
//  isn't imported into browseui, this module's hosting executable.
//  If we get SHRealloc, the following block can be removed:
#define _EXPL_SHELL_ALLOCATOR_

#ifdef  _EXPL_SHELL_ALLOCATOR_

#define SHRealloc( pv, cb )     shrealloc( pv, cb )

void* shrealloc( void* pv,  size_t cb )
{
    IMalloc* pMalloc ;
    void*    pvRet = NULL ;
    if( SUCCEEDED( SHGetMalloc( &pMalloc ) ) )  {
        pvRet = pMalloc->Realloc( pv, cb ) ;
        ATOMICRELEASE( pMalloc ) ;
    }
    return pvRet ;
}

#endif _EXPL_SHELL_ALLOCATOR_

BOOL     AffectAllUsers(HWND hwnd);

// id - verb mappings for IContextMenu impl
const struct
{
    UINT     id;
    LPCSTR   pszVerb;
} c_sIDVerbMap[] = 
{
    {SMIDM_DELETE,     "delete"},
    {SMIDM_RENAME,     "rename"},
    {SMIDM_PROPERTIES, "properties"},
    //{SMIDM_OPEN,       "open"},
    //{SMIDM_EXPLORE,    "explore"},
};

// augmisf context menu

class CAugMergeISFContextMenu : public IContextMenu2
{
public:
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(REFIID, void**);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT* pwReserved, LPSTR pszName, UINT cchMax);

    // *** IContextMenu2 methods ***    
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    CAugMergeISFContextMenu(IShellFolder *psfCommon, LPCITEMIDLIST pidlCommon, 
                            IShellFolder *psfUser,   LPCITEMIDLIST pidlUser, LPITEMIDLIST pidl,
                            HWND hwnd, UINT * prgfInOut);
    ~CAugMergeISFContextMenu();

    friend class CAugmentedMergeISF;
    friend CAugMergeISFContextMenu* CreateMergeISFContextMenu(
                            IShellFolder *psfCommon, LPCITEMIDLIST pidlCommon, 
                            IShellFolder *psfUser,   LPCITEMIDLIST pidlUser, LPITEMIDLIST pidl,
                            HWND hwnd, UINT * prgfInOut);
protected:
    LPITEMIDLIST    _pidlItem;
    IShellFolder *  _psfCommon;
    IShellFolder *  _psfUser;
    IContextMenu *  _pcmCommon;
    IContextMenu *  _pcmUser;
    LPITEMIDLIST    _pidlCommon;
    LPITEMIDLIST    _pidlUser;
    UINT            _idFirst;
    LONG            _cRef;
    HWND            _hwnd;
};

CAugMergeISFContextMenu* CreateMergeISFContextMenu(
                            IShellFolder *psfCommon, LPCITEMIDLIST pidlCommon, 
                            IShellFolder *psfUser,   LPCITEMIDLIST pidlUser, LPITEMIDLIST pidl,
                            HWND hwnd, UINT * prgfInOut)
{
    CAugMergeISFContextMenu* pcm = new CAugMergeISFContextMenu(psfCommon, pidlCommon,
                                                               psfUser, pidlUser,
                                                               pidl, hwnd, prgfInOut);
    if (pcm)
    {
        if (!pcm->_pidlItem)
        {
            delete pcm;
            pcm = NULL;
        }
    }
    return pcm;
}


CAugMergeISFContextMenu::CAugMergeISFContextMenu(IShellFolder *psfCommon, LPCITEMIDLIST pidlCommon,
                                                 IShellFolder *psfUser, LPCITEMIDLIST pidlUser,
                                                 LPITEMIDLIST pidl, HWND hwnd, UINT * prgfInOut)
{
    _cRef = 1;
    HRESULT hres;

    _hwnd = hwnd;
    _psfCommon = psfCommon;
    if (_psfCommon)
    {
        _psfCommon->AddRef();
        hres = _psfCommon->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pidl, IID_IContextMenu, prgfInOut, (void **)&_pcmCommon);

        ASSERT(SUCCEEDED(hres) || !_pcmCommon);
        _pidlCommon = ILClone(pidlCommon);
    }
    _psfUser = psfUser;
    if (_psfUser)
    {
        _psfUser->AddRef();
        hres = _psfUser->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pidl, IID_IContextMenu, prgfInOut, (void **)&_pcmUser);

        ASSERT(SUCCEEDED(hres) || !_pcmUser);
        _pidlUser = ILClone(pidlUser);
    }
    _pidlItem = ILClone(pidl);
    ASSERT(_psfCommon || _psfUser);
}

CAugMergeISFContextMenu::~CAugMergeISFContextMenu()
{
    ATOMICRELEASE(_psfCommon);
    ATOMICRELEASE(_pcmCommon);
    ATOMICRELEASE(_psfUser);
    ATOMICRELEASE(_pcmUser);
    ILFree(_pidlCommon);
    ILFree(_pidlUser);
    ILFree(_pidlItem);
}

STDMETHODIMP CAugMergeISFContextMenu::QueryInterface(REFIID riid, LPVOID *ppvOut)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CAugMergeISFContextMenu, IContextMenu, IContextMenu2),
        QITABENT(CAugMergeISFContextMenu, IContextMenu2),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvOut);
}

STDMETHODIMP_(ULONG) CAugMergeISFContextMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CAugMergeISFContextMenu::Release()
{
    if (InterlockedDecrement(&_cRef)) 
        return _cRef;

    delete this;
    return 0;
}

HRESULT CAugMergeISFContextMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hres = E_INVALIDARG;
    
    if (hmenu)
    {
        HMENU hmContext = LoadMenuPopup(MENU_SM_CONTEXTMENU);
        if (hmContext)
        {
            if (!_psfCommon || !_psfUser)
            {
                DeleteMenu(hmContext, SMIDM_OPENCOMMON, MF_BYCOMMAND);
                DeleteMenu(hmContext, SMIDM_EXPLORECOMMON, MF_BYCOMMAND);
            }

            _idFirst = idCmdFirst;
            Shell_MergeMenus(hmenu, hmContext, -1, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
            DestroyMenu(hmContext);

            // Make it look "Shell Like"
            SetMenuDefaultItem(hmenu, 0, MF_BYPOSITION);

            hres = S_OK;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    
    return hres;
}

HRESULT CAugMergeISFContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT    id = -1;
    HRESULT hres = E_FAIL;
    CMINVOKECOMMANDINFO ici = *pici;

    if (pici->cbSize < SIZEOF(CMINVOKECOMMANDINFO))
        return E_INVALIDARG;

    if (HIWORD(pici->lpVerb))
    {
        for (int i=0; i < ARRAYSIZE(c_sIDVerbMap); i++)
        {
            if (lstrcmpiA(pici->lpVerb, c_sIDVerbMap[i].pszVerb) == 0)
            {
                id = c_sIDVerbMap[i].id;
                break;
            }
        }
    }
    else
        id = (UINT) PtrToUlong( pici->lpVerb ); // Win64: should be ok since MAKEINTRESOURCE assumed

    switch (id)
    {
        case -1:
            hres = E_INVALIDARG;
            break;

        case SMIDM_OPEN:
        case SMIDM_EXPLORE:
        case SMIDM_OPENCOMMON:
        case SMIDM_EXPLORECOMMON:
            {
                IShellFolder * psf;
                LPITEMIDLIST   pidl;

                if (id == SMIDM_OPEN || id == SMIDM_EXPLORE)
                {
                    if (_psfUser)
                    {
                        psf  = _psfUser;
                        pidl = _pidlUser;
                    }
                    else
                    {
                        psf  = _psfCommon;
                        pidl = _pidlCommon;
                    }
                }
                else
                {
                    psf  = _psfCommon;
                    pidl = _pidlCommon;
                }
                    
                if (psf && pidl)
                {
                    SHELLEXECUTEINFO shei = {0};

                    shei.lpIDList = ILCombine(pidl, _pidlItem);
                    if (shei.lpIDList)
                    {
                        shei.cbSize     = sizeof(shei);
                        shei.fMask      = SEE_MASK_IDLIST;
                        shei.nShow      = SW_SHOWNORMAL;
                        if (id == SMIDM_EXPLORE || id == SMIDM_EXPLORECOMMON)
                            shei.lpVerb = TEXT("explore");
                        else
                            shei.lpVerb = TEXT("open");
                        hres = ShellExecuteEx(&shei) ? S_OK : E_FAIL;
                        ILFree((LPITEMIDLIST)shei.lpIDList);
                    }
                }
            }
            break;

        case SMIDM_PROPERTIES:
            {
                IContextMenu * pcm = _pcmUser ? _pcmUser : _pcmCommon;

                if (pcm)
                {
                    ici.lpVerb = "properties";
                    hres = pcm->InvokeCommand(&ici);
                }
            }
            break;
        case SMIDM_DELETE:
            ici.lpVerb = "delete";
            hres = S_OK;
            
            if (_pcmUser)
            {
                hres = _pcmUser->InvokeCommand(&ici);
            }
            else if (_pcmCommon)
            {
                ici.fMask |= CMIC_MASK_FLAG_NO_UI;
                if (AffectAllUsers(_hwnd))
                    hres = _pcmCommon->InvokeCommand(&ici);   
                else
                    hres = E_FAIL;
            }   
                
            break;
            
        case SMIDM_RENAME:
            ASSERT(0);
            hres = E_NOTIMPL; // sftbar picks this off
            break;
      }
    
    return hres;
}

HRESULT CAugMergeISFContextMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT* pwReserved, LPSTR pszName, UINT cchMax)
{
    HRESULT hres = E_NOTIMPL;

    // if hiword in not null then a string is passed to us. we don't handle that case (yet?)
    if (!HIWORD(idCmd) && (uType == GCS_VERBA || uType == GCS_VERBW))
    {
        hres = E_INVALIDARG;

        for (int i = 0; hres != S_OK && i < ARRAYSIZE(c_sIDVerbMap); i++)
        {
            if (c_sIDVerbMap[i].id == idCmd)
            {
                if (uType == GCS_VERBA)
                    lstrcpynA(pszName, c_sIDVerbMap[i].pszVerb, cchMax);
                else
                    SHAnsiToUnicode(c_sIDVerbMap[i].pszVerb, (LPWSTR)pszName, cchMax);
                    
                hres = S_OK;
            }
        }
    }
    return hres;
}

// we need IContextMenu2 although HandleMenuMsg is not impl because of the way sftbar
// works -- it caches only IContextMenu2 so if we don't have ICM2 sftbar will think
// that it does not have context menu so it will eat the messages intended for the hmenu
// that way, with context menu up, if user presses esc it will kill start menu sub menu
// not the context menu.
HRESULT CAugMergeISFContextMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return E_NOTIMPL;
}
//-------------------------------------------------------------------------//
//  Augmented Merge Shell Folder's pidl wrapper package consists of a versioned 
//  header followed by n 'source namespace' pidl wrappers.
//  Each individual pidl wrapper consists of a header containing a
//  collection lookup index followed by the source pidl itself.  The 
//  source pidl's mkid.cb member is used to seek the next pidl wrap in
//  the package.
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//--- Augmented Merge Shell Folder's pidl wrapper header
typedef struct tagAUGM_IDWRAP {
    USHORT      cb ;         // pidl wrap length 
    USHORT      Reserved ;   // reserved.
    ULONG       tag ;        // AugMergeISF pidl signature
    ULONG       version ;    // AugMergeISF pidl version
    ULONG       cSrcs ;      // Number of source namespace objects backing this composite pidl
} AUGM_IDWRAP;

typedef UNALIGNED AUGM_IDWRAP *PAUGM_IDWRAP;

//--- Source pidl header.  One or more of these records will be concatenated 
//    within the wrap following the wrap header.
typedef struct tagAUGM_IDSRC   {
    UINT        nID     ;     // source namespace index
    BYTE        pidl[0] ;     // source pidl
} AUGM_IDSRC;

typedef UNALIGNED AUGM_IDSRC *PAUGM_IDSRC;

//-------------------------------------------------------------------------//
//  Constants
//-------------------------------------------------------------------------//
#define AUGM_WRAPTAG            MAKELONG( MAKEWORD('A','u'), MAKEWORD('g','M') )
#define AUGM_WRAPVERSION_1_0    MAKELONG( 1, 0 )
#define AUGM_WRAPCURRENTVERSION AUGM_WRAPVERSION_1_0
#define INVALID_NAMESPACE_INDEX ((UINT)-1)
#define CB_IDLIST_TERMINATOR    sizeof(USHORT)


//-------------------------------------------------------------------------//
//  Augmented Merge shell folder pidl wrap utilities
//-------------------------------------------------------------------------//


//-------------------------------------------------------------------------//
//  Resolves the wrap header from the indicated pidl.  
#define AugMergeISF_GetWrap( p ) ((PAUGM_IDWRAP)(p))

//-------------------------------------------------------------------------//
//  Determines whether the indicated pidl is an Augmented Merge 
//  shell folder pidl wrapper.
HRESULT AugMergeISF_IsWrap(
    IN LPCITEMIDLIST pidlTest, 
    IN ULONG nVersion = AUGM_WRAPCURRENTVERSION )
{
    ASSERT(IS_VALID_PIDL( pidlTest ));

    if (pidlTest)
    {
        PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pidlTest ) ;

        return  (pWrap->cb >= sizeof(AUGM_IDWRAP) && 
                pWrap->tag == AUGM_WRAPTAG && 
                pWrap->version == nVersion) ?  
                    S_OK : E_UNEXPECTED ;         //BUGBUG: better error code for version mismatch?
    }
    else
    {
        return E_INVALIDARG;
    }
}


//-------------------------------------------------------------------------//
//  Retrieves the number of source namespace pidls in the wrap.
//  If the pidl was not wrapped, the return value is -1.
ULONG AugMergeISF_GetSourceCount( IN LPCITEMIDLIST pidl )  
{
    ASSERT(SUCCEEDED(AugMergeISF_IsWrap(pidl)));
    return AugMergeISF_GetWrap(pidl)->cSrcs;
}


//-------------------------------------------------------------------------//
//  Creates an IDLIST wrapper object based on the indicated source pidl.
HRESULT AugMergeISF_CreateWrap( 
    IN LPCITEMIDLIST pidlSrc, 
    IN UINT nSrcID, 
    OUT LPITEMIDLIST* ppidlWrap )
{
    ASSERT( ppidlWrap ) ;
    ASSERT( IS_VALID_PIDL( pidlSrc ) && INVALID_NAMESPACE_INDEX != nSrcID  ) ;

    *ppidlWrap = NULL ;

    //  Allocate a header and terminator
    LPBYTE pBuf = NULL ;
    WORD   cbAlloc = sizeof(AUGM_IDWRAP) + 
                     sizeof(AUGM_IDSRC) + pidlSrc->mkid.cb + 
                     // we need two terminators, one for pidlSrc and one for the wrap
                     // the one for pidlSrc is necessary for the ILClone to work
                     // because it gets confused with the nSrcID that follows the pidl
                     CB_IDLIST_TERMINATOR + 
                     CB_IDLIST_TERMINATOR ;

    if( NULL == (pBuf = (LPBYTE)IEILCreate( cbAlloc )) )
        return E_OUTOFMEMORY ;

    //  Initialize wrap header members
    PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pBuf ) ;
    pWrap->cb       = cbAlloc - CB_IDLIST_TERMINATOR ;
    pWrap->tag      = AUGM_WRAPTAG ;
    pWrap->version  = AUGM_WRAPCURRENTVERSION ;

    if( pidlSrc )
    {
        PAUGM_IDSRC pSrc = (PAUGM_IDSRC)(pBuf + sizeof(AUGM_IDWRAP)) ;
        pSrc->nID = nSrcID ;
        memcpy( pSrc->pidl, pidlSrc, pidlSrc->mkid.cb ) ;
        pWrap->cSrcs = 1 ;
    }

    *ppidlWrap = (LPITEMIDLIST)pWrap ;
    return S_OK ;
}

BOOL WrappedPidlContainsSrcID(LPCITEMIDLIST pidlWrap, UINT uSrcID)
{
    ASSERT(SUCCEEDED(AugMergeISF_IsWrap(pidlWrap)));
    PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pidlWrap ) ;

    if( pWrap->cSrcs > 0 )
    {
        LPBYTE       p     = ((LPBYTE)pWrap) + sizeof(AUGM_IDWRAP) ; // position of first pidl header.
        PAUGM_IDSRC  pSrc  = (PAUGM_IDSRC)p ;                       
        // offset to next pidl header, needs terminator so that ILClone below can work
        UINT         cbPidl= ((LPITEMIDLIST)pSrc->pidl)->mkid.cb + CB_IDLIST_TERMINATOR;

        if (pSrc->nID != uSrcID && pWrap->cSrcs > 1)
        {
            pSrc = (PAUGM_IDSRC)(p + sizeof(AUGM_IDSRC) + cbPidl) ;
        }

        if (pSrc->nID == uSrcID)
            return TRUE;
    }

    return FALSE;
}

HRESULT AugMergeISF_WrapRemovePidl(
    IN LPITEMIDLIST pidlWrap, 
    IN UINT nSrcID, 
    OUT LPITEMIDLIST* ppidlRet )
{
    ASSERT( IS_VALID_WRITE_PTR( ppidlRet, LPITEMIDLIST )) ;
    
    *ppidlRet = NULL ;

    HRESULT hr = AugMergeISF_IsWrap(pidlWrap);
    if (SUCCEEDED(hr))
    {
        PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pidlWrap ) ;

        ASSERT(pWrap->cSrcs > 1);

        LPBYTE       p     = ((LPBYTE)pWrap) + sizeof(AUGM_IDWRAP) ; // position of first pidl header.
        PAUGM_IDSRC  pSrc  = (PAUGM_IDSRC)p ;                       
        // offset to next pidl header, needs terminator so that ILClone below can work
        UINT         cbPidl= ((LPITEMIDLIST)pSrc->pidl)->mkid.cb + CB_IDLIST_TERMINATOR;

        // We want to look for the Other SrcID. So we loop while the source id we're removing is
        // equal. When it's not equal, we've got the ID.
        if (pSrc->nID == nSrcID)
        {
            pSrc = (PAUGM_IDSRC)(p + sizeof(AUGM_IDSRC) + cbPidl) ;
        }

        if (pSrc->nID != nSrcID)
        {
            hr = AugMergeISF_CreateWrap((LPITEMIDLIST)pSrc->pidl, pSrc->nID, ppidlRet);
            ILFree(pidlWrap);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  Adds a source pidl to the indicated pidl wrap.
HRESULT AugMergeISF_WrapAddPidl( 
    IN LPCITEMIDLIST pidlSrc, 
    IN UINT nSrcID, 
    IN OUT LPITEMIDLIST* ppidlWrap )
{
    ASSERT (ppidlWrap && IS_VALID_PIDL( *ppidlWrap ));
    ASSERT (IS_VALID_PIDL( pidlSrc ));
    ASSERT (INVALID_NAMESPACE_INDEX != nSrcID );

    HRESULT hr ;
    if (FAILED((hr = AugMergeISF_IsWrap(*ppidlWrap))))
        return hr ;

    // AHHHHHHHHHHH Rewrite this.
    if (WrappedPidlContainsSrcID(*ppidlWrap, nSrcID))
    {
        if (AugMergeISF_GetSourceCount(*ppidlWrap) > 1)
        {
            hr = AugMergeISF_WrapRemovePidl((LPITEMIDLIST)*ppidlWrap, nSrcID, ppidlWrap);
        }
        else
        {
            ILFree(*ppidlWrap);
            return AugMergeISF_CreateWrap(pidlSrc, nSrcID, ppidlWrap);
        }

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //  Retrieve wrap header
    PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)*ppidlWrap ;
    
    //  Reallocate a block large enough to contain our new record.
    WORD offTerm0 = pWrap->cb,      // offset to end of existing wrap
         offTerm1 = offTerm0 + sizeof(AUGM_IDSRC) + pidlSrc->mkid.cb,  // offset to end of next record
         cbRealloc= offTerm1 + 2*CB_IDLIST_TERMINATOR ;   // total bytes to reallocate

    LPBYTE pRealloc ;
    if( NULL == (pRealloc = (LPBYTE)SHRealloc( pWrap, cbRealloc )) )
        return E_OUTOFMEMORY ;

    //  Adjust our pointers if memory moved
    pWrap = (PAUGM_IDWRAP)pRealloc ;

    //  Initialize new record in the wrap
    UNALIGNED AUGM_IDSRC* pSrc = (PAUGM_IDSRC)(pRealloc + offTerm0 ) ;
    pSrc->nID = nSrcID ;
    memcpy( pSrc->pidl, pidlSrc, pidlSrc->mkid.cb ) ;

    //  Terminate new record 
    ZeroMemory( pRealloc + offTerm1, 2*CB_IDLIST_TERMINATOR ) ; 

    //  Update our header
    pWrap->cb = cbRealloc - CB_IDLIST_TERMINATOR ;
    pWrap->cSrcs++ ;

    *ppidlWrap = (LPITEMIDLIST)pWrap ;
    return S_OK ;
}

//-------------------------------------------------------------------------//
//  Private pidl enumeration block (GetFirst/GetNext)
typedef struct tagAUGM_IDWRAP_ENUM
{
    ULONG           cbStruct ;    // structure size
    PAUGM_IDWRAP    pWrap ;       // wrap header.
    PAUGM_IDSRC     pSrcNext ;    // pointer to next src header
} AUGM_IDWRAP_ENUM, *PAUGM_IDWRAP_ENUM ;

//-------------------------------------------------------------------------//
//  Begins enumeration of source pidls in the indicated pidl wrap.
HANDLE AugMergeISF_EnumFirstSrcPidl( 
    IN LPCITEMIDLIST pidlWrap, 
    OUT UINT* pnSrcID, 
    OUT LPITEMIDLIST* ppidlRet )
{
    ASSERT( IS_VALID_WRITE_PTR( ppidlRet, LPITEMIDLIST ) && IS_VALID_WRITE_PTR( pnSrcID, UINT ) ) ;
    
    PAUGM_IDWRAP_ENUM pEnum = NULL ;
    *ppidlRet = NULL ;
    *pnSrcID  = (UINT)-1 ;

    HRESULT hr = AugMergeISF_IsWrap(pidlWrap);
    if(SUCCEEDED(hr))
    {
        PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pidlWrap ) ;

        if( pWrap->cSrcs > 0 )
        {
            LPBYTE       p     = ((LPBYTE)pWrap) + sizeof(AUGM_IDWRAP) ; // position of first pidl header.
            PAUGM_IDSRC  pSrc  = (PAUGM_IDSRC)p ;                       
            // offset to next pidl header, needs terminator so that ILClone below can work
            UINT         cbPidl= ((LPITEMIDLIST)pSrc->pidl)->mkid.cb + CB_IDLIST_TERMINATOR;
            
            if( NULL != (pEnum = new AUGM_IDWRAP_ENUM) )
            {
                pEnum->cbStruct = sizeof(*pEnum) ;
                pEnum->pWrap    = pWrap ;
                pEnum->pSrcNext = (PAUGM_IDSRC)(p + sizeof(AUGM_IDSRC) + cbPidl) ;
                *pnSrcID = pSrc->nID ;
                *ppidlRet = ILClone( (LPITEMIDLIST)pSrc->pidl ) ;
                if ( NULL == *ppidlRet )
                {
                    delete pEnum;
                    pEnum = NULL;
                }
            }
        }
    }
    return pEnum ;
}

//-------------------------------------------------------------------------//
//  Continues source pidl enumeration
BOOL AugMergeISF_EnumNextSrcPidl( 
    IN HANDLE hEnum, 
    OUT UINT* pnSrcID, 
    OUT LPITEMIDLIST* ppidlRet )
{
    PAUGM_IDWRAP_ENUM pEnum = (PAUGM_IDWRAP_ENUM)hEnum ;
    HRESULT           hr = E_UNEXPECTED ;

    ASSERT( IS_VALID_WRITE_PTR( pEnum, AUGM_IDWRAP_ENUM ) ) ;
    ASSERT( sizeof(*pEnum) == pEnum->cbStruct ) ;
    ASSERT( sizeof(*pEnum) == pEnum->cbStruct );

    *ppidlRet = NULL ;
    *pnSrcID  = (UINT)-1 ;

    if (SUCCEEDED((hr = AugMergeISF_IsWrap((LPCITEMIDLIST)pEnum->pWrap)))) 
    {
        if ((LPBYTE)(pEnum->pWrap) + pEnum->pWrap->cb <= (LPBYTE)pEnum->pSrcNext)
            hr = S_FALSE ;
        else
        {
            UNALIGNED AUGM_IDSRC* pualSrcNext = pEnum->pSrcNext;

            *pnSrcID = pualSrcNext->nID;
            *ppidlRet = ILClone((LPITEMIDLIST)pualSrcNext->pidl);
            
            pEnum->pSrcNext = (PAUGM_IDSRC)(
                                    ((LPBYTE)pualSrcNext) + 
                                    sizeof(AUGM_IDSRC) +
                                    ((LPITEMIDLIST)pualSrcNext->pidl)->mkid.cb + 
                                    CB_IDLIST_TERMINATOR);

            hr = S_OK ;
            return TRUE ;
        }
    }
    return FALSE ;
}

//-------------------------------------------------------------------------//
//  Terminates source pidl enumeration
void AugMergeISF_EndEnumSrcPidls( 
    IN OUT HANDLE& hEnum )
{
    PAUGM_IDWRAP_ENUM pEnum = (PAUGM_IDWRAP_ENUM)hEnum ;

    ASSERT( IS_VALID_WRITE_PTR( pEnum, AUGM_IDWRAP_ENUM ) && 
        sizeof(*pEnum) == pEnum->cbStruct  );
    delete pEnum ;
    hEnum = NULL ;
}

//-------------------------------------------------------------------------//
//  Allocates and returns a copy of the specified source pidl 
//  from the wrapped pidl.
HRESULT AugMergeISF_GetSrcPidl( 
    IN LPCITEMIDLIST pidlWrap, 
    IN UINT nSrcID, 
    OUT LPITEMIDLIST* ppidlRet )
{
    ASSERT( ppidlRet ) ;
    *ppidlRet = NULL ;

    HANDLE       hEnum ;
    BOOL         bEnum ;
    UINT         nSrcIDEnum ;
    LPITEMIDLIST pidlEnum ;

    for( hEnum = AugMergeISF_EnumFirstSrcPidl( pidlWrap, &nSrcIDEnum, &pidlEnum ), bEnum = TRUE ;
         hEnum && bEnum ;
         bEnum = AugMergeISF_EnumNextSrcPidl( hEnum, &nSrcIDEnum, &pidlEnum ) )
    {
        if( nSrcIDEnum == nSrcID )
        {
            *ppidlRet = pidlEnum ;
            AugMergeISF_EndEnumSrcPidls(hEnum);
            return S_OK ;
        }

        ILFree( pidlEnum ) ;
    }
    AugMergeISF_EndEnumSrcPidls( hEnum ) ;

    return E_FAIL ;
}

#ifdef DEBUG
BOOL  IsValidWrappedPidl(LPCITEMIDLIST pidlWrap)
{
    BOOL fValid = FALSE;

    if (pidlWrap == NULL)
        return FALSE;

    if (FAILED(AugMergeISF_IsWrap(pidlWrap)))
        return FALSE;


    HANDLE       hEnum ;
    UINT         nSrcIDEnum ;
    LPITEMIDLIST pidlEnum ;

    hEnum = AugMergeISF_EnumFirstSrcPidl( pidlWrap, &nSrcIDEnum, &pidlEnum );
    do 
    {
        fValid = IS_VALID_PIDL(pidlEnum);
        ILFree(pidlEnum);
    }
    while( fValid && AugMergeISF_EnumNextSrcPidl( hEnum, &nSrcIDEnum, &pidlEnum ));
    AugMergeISF_EndEnumSrcPidls( hEnum ) ;

    return fValid;
}
#endif

//-------------------------------------------------------------------------//

int AugmEnumCompare(void *pv1, void *pv2, LPARAM lParam)
{
    CAugISFEnumItem* paugmEnum1 = (CAugISFEnumItem*)pv1;
    CAugISFEnumItem* paugmEnum2 = (CAugISFEnumItem*)pv2;
    int iRet = -1;

    if (paugmEnum1 && paugmEnum2)
    {
        // Are these two items of different types?
        if (BOOLIFY(paugmEnum1->_rgfAttrib & SFGAO_FOLDER) ^ BOOLIFY(paugmEnum2->_rgfAttrib & SFGAO_FOLDER))
        {
            // Yes. Then Folders sort before items.
            iRet = BOOLIFY(paugmEnum1->_rgfAttrib & SFGAO_FOLDER) ? 1 : -1;
        }
        else    // They are of the same type. Then compare by name
        {
            iRet = lstrcmpi(paugmEnum1->_pszDisplayName, paugmEnum2->_pszDisplayName);
        }
    }
        

    return iRet;
}

LPVOID AugmEnumMerge(UINT uMsg, void * pv1, void * pv2, LPARAM lParam)
{    
    void * pvRet = pv1;
    
    switch (uMsg)
    {
        case DPAMM_MERGE:
            {
                HANDLE hEnum;
                UINT   nSrcID;
                LPITEMIDLIST pidl;
                CAugISFEnumItem* paugmeDest = (CAugISFEnumItem*)pv1;
                CAugISFEnumItem* paugmeSrc  = (CAugISFEnumItem*)pv2;

                ASSERT(paugmeDest && paugmeSrc);

                hEnum = AugMergeISF_EnumFirstSrcPidl(paugmeSrc->_pidlWrap, &nSrcID, &pidl);
                if (hEnum)
                {
                    // add pidl from src to dest
                    AugMergeISF_WrapAddPidl(pidl, nSrcID, &paugmeDest->_pidlWrap); 
                    // no longer need hEnum
                    AugMergeISF_EndEnumSrcPidls(hEnum);
                    // this was copied to paugmeDest->_pidlWrap
                    ILFree(pidl);
                }
            }
            break;
        case DPAMM_INSERT:
            {
                CAugISFEnumItem* paugmNew = new CAugISFEnumItem;
                CAugISFEnumItem* paugmSrc = (CAugISFEnumItem*)pv1;

                if (paugmNew)
                {
                    paugmNew->_pidlWrap = ILClone(paugmSrc->_pidlWrap);
                    if (paugmNew->_pidlWrap)
                    {
                        paugmNew->SetDisplayName(paugmSrc->_pszDisplayName);
                        paugmNew->_rgfAttrib = paugmSrc->_rgfAttrib;
                    }
                    else
                    {
                        delete paugmNew;
                        paugmNew = NULL;
                    }
                }
                pvRet = paugmNew;
            }
            break;
        default:
            ASSERT(0);
    }
    return pvRet;
}

typedef struct
{
    LPTSTR pszDisplayName;
    BOOL   fFolder;
} AUGMISFSEARCHFORPIDL;

int CALLBACK AugMISFSearchForOnePidlByDisplayName(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    AUGMISFSEARCHFORPIDL* pSearchFor = (AUGMISFSEARCHFORPIDL*)p1;
    CAugISFEnumItem* paugmEnum  = (CAugISFEnumItem*)p2;

    // Are they of different types?
    if (BOOLIFY(paugmEnum->_rgfAttrib & SFGAO_FOLDER) ^ pSearchFor->fFolder)
    {
        // Yes. 
        return pSearchFor->fFolder ? 1 : -1;
    }
    else    // They are of the same type. Then compare by name
    {
        return StrCmpI(pSearchFor->pszDisplayName, paugmEnum->_pszDisplayName);
    }
}

//-------------------------------------------------------------------------------------------------//
//  DPA utilities
#define DPA_GETPTRCOUNT( hdpa )         ((NULL != (hdpa)) ? DPA_GetPtrCount((hdpa)) : 0)
#define DPA_GETPTR( hdpa, i, type )     ((NULL != (hdpa)) ? (type*)DPA_GetPtr((hdpa), i) : (type*)NULL)
#define DPA_DESTROY( hdpa, pfn )        { if( NULL != hdpa ) \
                                            { DPA_DestroyCallback( hdpa, pfn, NULL ) ; \
                                              hdpa = NULL ; }}

//-------------------------------------------------------------------------------------------------//
//  Forwards...
class CEnum ;
class CChildObject ;


//-------------------------------------------------------------------------------------------------//
//  Augmented Merge Shell Folder source namespace descriptor.
//
//  Objects of class CNamespace are created by CAugmentedMergeISF in 
//  the AddNameSpace() method impl, and are maintained in the collection
//  CAugmentedMergeISF::_hdpaNamespaces.
//
class CNamespace
//-------------------------------------------------------------------------------------------------//
{
public:
    CNamespace( const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib ) ; 
    ~CNamespace() ;

    IShellFolder*   ShellFolder()   { return _psf ; }
    REFGUID         Guid()          { return _guid ; }
    ULONG           Attrib() const  { return _dwAttrib ; }
    LPITEMIDLIST    GetPidl() const { return _pidl; }

    void            Assign( const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib ) ;
    void            Unassign() ;

    HRESULT         RegisterNotify( HWND, UINT, ULONG ) ;
    HRESULT         UnregisterNotify() ;

    BOOL            SetOwner( IUnknown *punk ) ;
    
protected:
    IShellFolder*   _psf ;      // IShellFolder interface pointer
    GUID            _guid ;     // optional GUID for specialized UI handling
    LPITEMIDLIST    _pidl ;     // optional pidl
    ULONG           _dwAttrib ;  // optional flags
    UINT            _uChangeReg ; // Shell change notify registration ID.
} ;

//-------------------------------------------------------------------------------------------------//
inline CNamespace::CNamespace( const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib ) 
    :  _psf(NULL), 
       _pidl(NULL), 
       _guid(GUID_NULL), 
       _dwAttrib(0), 
       _uChangeReg(0)
{
    Assign( pguidUIObject, psf, pidl, dwAttrib ) ;
}

//-------------------------------------------------------------------------------------------------//
inline CNamespace::~CNamespace()  { 
    UnregisterNotify() ;
    Unassign() ;
}

//-------------------------------------------------------------------------------------------------//
//  Assigns data members.
void CNamespace::Assign( const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib )
{
    Unassign() ;
    if( NULL != (_psf = psf) )
        _psf->AddRef() ;

    _pidl       = ILClone( pidl ) ;
    _guid       = pguidUIObject ? *pguidUIObject : GUID_NULL ;
    _dwAttrib   = dwAttrib ;

}

//-------------------------------------------------------------------------------------------------//
//  Unassigns data members.
void CNamespace::Unassign()
{
    ATOMICRELEASE( _psf ) ; 
    ILFree( _pidl ) ;
    _pidl = NULL ;
    _guid = GUID_NULL ;
    _dwAttrib = 0L ;
}

//-------------------------------------------------------------------------------------------------//
//  Register change notification for the namespace
HRESULT CNamespace::RegisterNotify( HWND hwnd, UINT uMsg, ULONG lEvents )
{
    if( 0 == _uChangeReg )
        _uChangeReg = ::RegisterNotify(hwnd,
                                       uMsg,
                                       _pidl,
                                       lEvents,
                                       SHCNRF_ShellLevel | SHCNRF_InterruptLevel | SHCNRF_RecursiveInterrupt,
                                       TRUE);

    return 0 != _uChangeReg ? S_OK : E_FAIL ;
}

//-------------------------------------------------------------------------------------------------//
//  Unregister change notification for the namespace
HRESULT CNamespace::UnregisterNotify()
{
    if( 0 != _uChangeReg )
    {
        UINT uID = _uChangeReg;

        _uChangeReg = 0;
        ::SHChangeNotifyDeregister(uID);
    }
    return S_OK;
}

//-------------------------------------------------------------------------------------------------//
inline BOOL CNamespace::SetOwner(IUnknown *punkOwner)
{
    if (_psf)
    {
        IUnknown_SetOwner(_psf, punkOwner);
        return TRUE ;
    }
    
    return FALSE ;
}

//-------------------------------------------------------------------------//
CAugmentedMergeISF::CAugmentedMergeISF() : _cRef(1)
{
    ASSERT(_hdpaNamespaces == NULL);
    ASSERT(_punkOwner == NULL);
    ASSERT(_pdt == NULL);
    DllAddRef() ;
}

//-------------------------------------------------------------------------//
CAugmentedMergeISF::~CAugmentedMergeISF()
{
    SetOwner(NULL);
    FreeNamespaces();
    DllRelease();
}

//-------------------------------------------------------------------------//
//  CAugmentedMergeISF global CreateInstance method for da class factory
//-------------------------------------------------------------------------//
STDAPI CAugmentedISF2_CreateInstance( IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi )
{
    // aggregation checking is handled in class factory
    CAugmentedMergeISF* pObj;

    if( NULL == (pObj = new CAugmentedMergeISF) )
        return E_OUTOFMEMORY ;

    *ppunk = SAFECAST( pObj, IAugmentedShellFolder2 * ) ;
    return S_OK;
}

//-------------------------------------------------------------------------//
//   CAugmentedMergeISF - IUnknown methods
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI( CAugmentedMergeISF, IShellFolder, IAugmentedShellFolder ),
        QITABENT( CAugmentedMergeISF, IAugmentedShellFolder ),
        QITABENT( CAugmentedMergeISF, IAugmentedShellFolder2 ),
        QITABENT( CAugmentedMergeISF, IShellFolder2 ),
        QITABENT( CAugmentedMergeISF, IShellService ),
        QITABENT( CAugmentedMergeISF, ITranslateShellChangeNotify ),
        QITABENT( CAugmentedMergeISF, IDropTarget ),
        { 0 },
    };
    return QISearch( this, qit, riid, ppvObj ) ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP_(ULONG) CAugmentedMergeISF::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

//-------------------------------------------------------------------------//
STDMETHODIMP_(ULONG) CAugmentedMergeISF::Release()
{
    if (InterlockedDecrement(&_cRef)) 
        return _cRef;

    delete this;
    return 0;
}

//-------------------------------------------------------------------------//
//   CAugmentedMergeISF - IShellFolder methods
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    HRESULT hr = E_FAIL;

    if (_hdpaNamespaces)
    {
        // BUGBUG (lamadio): This does not work if you have 2 enumerators. But,
        // when asking for a new enumerator, we should flush the cache.
        FreeObjects();

        *ppenumIDList = new CEnum(this, grfFlags);

        if (NULL == *ppenumIDList)
            return E_OUTOFMEMORY ;
        hr = S_OK ;
    }
    
    return hr;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::BindToObject( LPCITEMIDLIST pidlWrap, LPBC pbc, REFIID riid, LPVOID *ppvOut )
{
    ASSERT(IS_VALID_PIDL( pidlWrap ) && NULL != ppvOut);

    *ppvOut = NULL ;
        
    if (SUCCEEDED(AugMergeISF_IsWrap(pidlWrap)))
    {
        PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pidlWrap ) ;
        ASSERT(IsValidWrappedPidl(pidlWrap));
        ASSERT( pWrap ) ;
        ASSERT( pWrap->cSrcs > 0 ) ;    // should never, never happen

        HANDLE           hEnum ;
        BOOL             bEnum ;
        UINT             nIDSrc = -1 ;
        DEBUG_CODE(int   iNumBound = 0);
        LPITEMIDLIST     pidlSrc ;
        HRESULT          hr = E_UNEXPECTED ;
        CNamespace* pSrc = NULL ;
        
        CAugmentedMergeISF* pISF ;
        if (NULL == (pISF = new CAugmentedMergeISF))
            return E_OUTOFMEMORY ;
    
        for (hEnum = AugMergeISF_EnumFirstSrcPidl( pidlWrap, &nIDSrc, &pidlSrc ), bEnum = TRUE ;
             hEnum && bEnum ;
             bEnum = AugMergeISF_EnumNextSrcPidl( hEnum, &nIDSrc, &pidlSrc))
        {
            if (SUCCEEDED((hr = QueryNameSpace(nIDSrc, (PVOID*)&pSrc))) && pSrc)
            {
                IShellFolder *psf;

                hr = S_FALSE;
                if (SUCCEEDED(pSrc->ShellFolder()->BindToObject(pidlSrc, NULL, IID_IShellFolder, (void **)&psf)))
                {
                    LPCITEMIDLIST pidlParent = pSrc->GetPidl();
                    LPITEMIDLIST  pidlFull   = ILCombine(pidlParent, pidlSrc);
                                 
                    hr = pISF->AddNameSpace(NULL, psf, pidlFull, pSrc->Attrib());
#ifdef DEBUG
                    if (SUCCEEDED(hr))
                        iNumBound++;
#endif
                    ILFree(pidlFull);
                    psf->Release();
                }
                ASSERT(SUCCEEDED(hr));
            }
            ILFree(pidlSrc);
        }

             // If this hits, then something is terribly wrong. Either we were unable to bind to the
             // ShellFolders, or the add failed. This could be caused by a bad wrapped pidl.
        ASSERT(iNumBound > 0);

        AugMergeISF_EndEnumSrcPidls( hEnum ) ;
        hr = pISF->QueryInterface(riid, ppvOut);
        pISF->Release();
        return hr ;
    }
    return E_UNEXPECTED ;    
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::BindToStorage( LPCITEMIDLIST, LPBC, REFIID, void ** )
{
    return E_NOTIMPL ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::CompareIDs( 
    LPARAM lParam, 
    LPCITEMIDLIST pidl1, 
    LPCITEMIDLIST pidl2)
{
    IShellFolder    *psf1 = NULL, *psf2 = NULL;
    LPITEMIDLIST    pidlItem1 = NULL, pidlItem2 = NULL;
    int             iRet = 0 ;
    HRESULT         hr1, hr2, hr ;

    hr1 = GetDefNamespace( pidl1, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf1, &pidlItem1 ) ;
    hr2 = GetDefNamespace( pidl2, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf2, &pidlItem2 ) ;

    if( SUCCEEDED( hr1 ) && SUCCEEDED( hr2 ) )
    {
        ULONG dwAttrib1 = SFGAO_FOLDER, dwAttrib2 = SFGAO_FOLDER;
        //  Same namespace? Just forward the request.
        if( psf1 == psf2 )
        {
            hr = psf1->CompareIDs( lParam, pidlItem1, pidlItem2 ) ;
            ILFree( pidlItem1 ) ;
            ILFree( pidlItem2 ) ;
            return hr ;
        }

        hr1 = psf1->GetAttributesOf( 1, (LPCITEMIDLIST*)&pidlItem1, &dwAttrib1 ) ;
        hr2 = psf2->GetAttributesOf( 1, (LPCITEMIDLIST*)&pidlItem2, &dwAttrib2 ) ;

        if( SUCCEEDED( hr1 ) && SUCCEEDED( hr2 ) )
        {
            //  Comparison heuristics:
            //  (1) folders take precedence over nonfolders, (2) alphanum comparison
            if( 0 != (dwAttrib1 & SFGAO_FOLDER) && 
                0 == (dwAttrib2 & SFGAO_FOLDER) )
                iRet = -1 ;
            else if( 0 == (dwAttrib1 & SFGAO_FOLDER) && 
                     0 != (dwAttrib2 & SFGAO_FOLDER) )
                iRet = 1 ;
            else
            {
                STRRET  strName1, strName2;
                HRESULT hres1 = E_FAIL;
                HRESULT hres2 = E_FAIL;
                TCHAR   szName1[MAX_PATH],  szName2[MAX_PATH];
                hr1 = psf1->GetDisplayNameOf(pidlItem1, SHGDN_FORPARSING | SHGDN_INFOLDER, &strName1); 
                hr2 = psf2->GetDisplayNameOf(pidlItem2, SHGDN_FORPARSING | SHGDN_INFOLDER, &strName2);

                if (SUCCEEDED(hr1) && SUCCEEDED(hr2))
                {
                    // must call StrRetToBuf because it frees StrRet strings if allocated
                    hres1 = StrRetToBuf(&strName1, pidlItem1, szName1, ARRAYSIZE(szName1));
                    hres2 = StrRetToBuf(&strName2, pidlItem2, szName2, ARRAYSIZE(szName2));
                }
                // if the names match we return -1 because they are different pidls with
                // the same name

                if (SUCCEEDED(hr1) && SUCCEEDED(hr2) && SUCCEEDED(hres1) && SUCCEEDED(hres2))
                {
                    iRet = lstrcmp(szName1, szName2); // Comparisons are by name with items of the same type.
                }
            }
        }
    }

    hr = FAILED( hr1 ) ? hr1 : 
         FAILED( hr2 ) ? hr2 : 
         S_OK ;
   
    if( pidlItem1 )
        ILFree( pidlItem1 ) ;
    if( pidlItem2 )
        ILFree( pidlItem2 ) ;

    return MAKE_HRESULT( HRESULT_SEVERITY( hr ), HRESULT_FACILITY( hr ), iRet ) ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::CreateViewObject( 
    HWND hwndOwner, 
    REFIID riid, 
    LPVOID * ppvOut )
{
    HRESULT          hr ;
    CNamespace  *pSrc, *pSrc0 ;
    
    pSrc = pSrc0 = NULL ;

    // TODO: Handle IDropTarget here, delegate for all others.
    if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = QueryInterface(riid, ppvOut);
        if (SUCCEEDED(hr))
            _hwnd = hwndOwner;
        return hr;
    }

    //  Search for default namespace for CreateViewObj()
    if( FAILED( (hr = GetDefNamespace( ASFF_DEFNAMESPACE_VIEWOBJ, (PVOID*)&pSrc, NULL, (PVOID*)&pSrc0 )) ) )
        return hr ;

    if( NULL == pSrc ) 
        pSrc = pSrc0 ;

    if( NULL != pSrc )
    {
        ASSERT( pSrc->ShellFolder() ) ;
        hr = pSrc->ShellFolder()->CreateViewObject( hwndOwner, riid, ppvOut ) ;
    }

    return hr ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetAttributesOf( 
    UINT cidl, 
    LPCITEMIDLIST * apidl, 
    ULONG * rgfInOut )
{
    IShellFolder* pISF ;
    LPITEMIDLIST  pidlItem ;
    HRESULT       hr ;

    if( cidl > 1 )  // support 1 only.
        return E_NOTIMPL ;
        
    if( !apidl )
        return E_INVALIDARG ;
    
    //  Forward to default namespace for item attributes
    if( FAILED( (hr = GetDefNamespace(  
        apidl[0], ASFF_DEFNAMESPACE_ATTRIB, &pISF, &pidlItem )) ) )
        return hr ;

    hr = pISF->GetAttributesOf( 1, (LPCITEMIDLIST*)&pidlItem, rgfInOut ) ;
    
    ILFree( pidlItem ) ;
    return hr ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetUIObjectOf(
    HWND hwndOwner, 
    UINT cidl, 
    LPCITEMIDLIST * apidl, 
    REFIID riid, 
    UINT * prgfInOut, 
    LPVOID * ppvOut )
{
    IShellFolder* pISF ;
    LPITEMIDLIST  pidlItem ;
    HRESULT       hr ;

    if (cidl > 1)  // support 1 only.
        return E_NOTIMPL ;
        
    if (!apidl)
        return E_INVALIDARG ;

    if (IsEqualGUID(riid, IID_IContextMenu))
    {
        hr = _GetContextMenu(hwndOwner, cidl, apidl, prgfInOut, ppvOut);
    }
    else
    {
        //  Forward to default namespace for UI object
        if (FAILED((hr = GetDefNamespace(apidl[0], ASFF_DEFNAMESPACE_UIOBJ, &pISF, &pidlItem))))
            return hr ;

        hr = pISF->GetUIObjectOf(hwndOwner, 1, (LPCITEMIDLIST*)&pidlItem, riid, prgfInOut, ppvOut);
        ILFree(pidlItem);
    }
    return hr ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetDisplayNameOf( 
    LPCITEMIDLIST pidl, 
    DWORD grfFlags, 
    LPSTRRET pstrName )
{
    IShellFolder* pISF ;
    LPITEMIDLIST  pidlItem ;
    HRESULT       hr ;

    //  Forward to default namespace for display name
    if (FAILED((hr = GetDefNamespace( 
        pidl, ASFF_DEFNAMESPACE_DISPLAYNAME, &pISF, &pidlItem))))
        return hr ;

    if (SUCCEEDED((hr = pISF->GetDisplayNameOf(pidlItem, grfFlags, pstrName))))
    {
        //  STRRET_OFFSET has no meaning in context of the pidl wrapper.
        //  We can either calculate the offset into the wrapper, or allocate
        //  a wide char for the name.  For expedience, we'll allocate the name.
        
        if (pstrName->uType == STRRET_OFFSET)
        {
            UINT cch = lstrlenA( STRRET_OFFPTR( pidlItem, pstrName ) ) ;
            LPWSTR pwszName = (LPWSTR)SHAlloc( (cch + 1) * sizeof(WCHAR));

            if (NULL !=  pwszName)
            {
                SHAnsiToUnicode( STRRET_OFFPTR( pidlItem, pstrName ), pwszName, cch+1 );
                pwszName[cch] = (WCHAR)0 ;
            }
            pstrName->pOleStr = pwszName ;
            pstrName->uType   = STRRET_WSTR ;
        }

#ifdef DEBUG
        // If the trace flags are set, and this is not comming from an internal query,
        // Then append the location where this name came from
        if (g_qwTraceFlags & TF_AUGM && _fInternalGDNO == FALSE)
        {
            if (pstrName->uType == STRRET_WSTR)
            {
                LPWSTR wszOldName = pstrName->pOleStr;
                UINT cch = lstrlenW(wszOldName);

                pstrName->pOleStr = (LPWSTR)SHAlloc( (cch + 50) * sizeof(WCHAR));

                if (pstrName->pOleStr)
                {
                    StrCpyW(pstrName->pOleStr, wszOldName);

                    if (AugMergeISF_GetSourceCount(pidl) > 1)
                        StrCatW(pstrName->pOleStr, L" (Merged)");
                    else if (WrappedPidlContainsSrcID(pidl, 0))
                        StrCatW(pstrName->pOleStr, L" (1)");
                    else
                        StrCatW(pstrName->pOleStr, L" (2)");

                    SHFree(wszOldName);
                }
                else
                {
                    pstrName->pOleStr = wszOldName;
                }
            }
            else if (pstrName->uType == STRRET_CSTR)
            {
                if (AugMergeISF_GetSourceCount(pidl) > 1)
                    StrCatA(pstrName->cStr, " (Merged)");
                else if (WrappedPidlContainsSrcID(pidl, 0))
                    StrCatA(pstrName->cStr, " (1)");
                else
                    StrCatA(pstrName->cStr, " (2)");
            }
        }

#endif
    }

    ILFree( pidlItem ) ;
    return hr ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::ParseDisplayName( 
    HWND hwndOwner, 
    LPBC pbcReserved, 
    LPOLESTR pwszName, 
    ULONG * pchEaten, 
    LPITEMIDLIST * ppidl, 
    ULONG * pdwAttrib )
{
    int iIndex;
    LPITEMIDLIST pidl;

    *ppidl = NULL;
    // This ParseDisplayName should iterate through all our delegates until one works.
    for (iIndex = NamespaceCount() - 1; iIndex >=0 ; iIndex--)
    {
        CNamespace* pSrc = Namespace(iIndex) ;
        if (pSrc)
        {
            if (SUCCEEDED(pSrc->ShellFolder()->ParseDisplayName(hwndOwner, pbcReserved, pwszName, pchEaten,
                                                  &pidl, pdwAttrib)))
            {
                ASSERT(pidl);   // Make sure a valid pidl comes out.
                if (*ppidl == NULL)
                    AugMergeISF_CreateWrap(pidl, iIndex, ppidl);
                else
                    AugMergeISF_WrapAddPidl(pidl, iIndex, ppidl);

                ILFree(pidl);
            }
        }
    }

    return *ppidl? S_OK : E_FAIL;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::SetNameOf( 
    HWND hwndOwner, 
    LPCITEMIDLIST pidl, 
    LPCOLESTR pwszName, 
    DWORD uFlags, 
    LPITEMIDLIST *ppidlOut )
{
    CNamespace*   pnsCommon;
    CNamespace*   pnsUser;
    LPITEMIDLIST  pidlItem;
    HRESULT       hres;
    UINT          uiUser;
    UINT          uiCommon;

    hres = _GetNamespaces(pidl, &pnsCommon, &uiCommon, &pnsUser, &uiUser, &pidlItem, NULL);
    if (SUCCEEDED(hres))
    {
        LPITEMIDLIST pidlNew = NULL;
        UINT         uiNamespace = INVALID_NAMESPACE_INDEX;

        if (pnsUser)
        {
            hres = pnsUser->ShellFolder()->SetNameOf(hwndOwner, pidlItem, pwszName, uFlags, &pidlNew);
            uiNamespace = uiUser;
        }
        else if (pnsCommon)
        {
            hres = E_FAIL;

            if (AffectAllUsers(hwndOwner))
            {
                hres = pnsCommon->ShellFolder()->SetNameOf(hwndOwner, pidlItem, pwszName, uFlags, &pidlNew);
                uiNamespace = uiCommon;
            }
        }

        if (ppidlOut)
        {
            *ppidlOut = NULL;
            // wrap the pidl
            if (SUCCEEDED(hres) && pidlNew)
                AugMergeISF_CreateWrap(pidlNew, uiNamespace, ppidlOut);
        }
        
        ILFree(pidlNew);
        ILFree(pidlItem);
    }
    return hres;
}

//-------------------------------------------------------------------------//
//  IAugmentedShellFolder methods
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  Adds a source namespace to the Augmented Merge shell folder object.
STDMETHODIMP CAugmentedMergeISF::AddNameSpace( 
    const GUID * pguidObject, 
    IShellFolder * psf, 
    LPCITEMIDLIST pidl, 
    DWORD dwFlags )
{
    ASSERT (IS_VALID_CODE_PTR(psf, IShellFolder*));
    ASSERT (IS_VALID_PIDL(pidl));

    //  Check for duplicate via full display name
    
    for( int i=0, max = NamespaceCount() ; i < max; i++ )
    {
        CNamespace* pSrc = Namespace( i ) ;
        if (pSrc)
        {
            if (ILIsEqual(pSrc->GetPidl(), pidl))
            {
                //  Found!  Reassign attributes
                pSrc->Assign( pguidObject, psf, pidl, dwFlags ) ;
                return S_OK ;
            }
        }
    }

    //  No match; safe to append it to collection, creating DPA if necessary.
    if( NULL == _hdpaNamespaces && 
        NULL == (_hdpaNamespaces= DPA_Create( 2 )) )
        return E_OUTOFMEMORY ;

    CNamespace *pSrc = new CNamespace( pguidObject, psf, pidl, dwFlags );
    if( NULL == pSrc )
        return E_OUTOFMEMORY ;
    
    return DPA_AppendPtr( _hdpaNamespaces, pSrc ) >= 0 ?  S_OK : E_FAIL;
}

//-------------------------------------------------------------------------//
//  Retrieves the primary namespace iid for the wrapped pidl.
STDMETHODIMP CAugmentedMergeISF::GetNameSpaceID( 
    LPCITEMIDLIST pidl, 
    GUID * pguidOut )
{
    HRESULT hr ;
    if (FAILED((hr = AugMergeISF_IsWrap( pidl ))))
        return hr ;

    //  BUGBUG: need to enumerate wrapped source pidls
    return E_NOTIMPL ;
}

//-------------------------------------------------------------------------//
//  Retrieves a pointer to a source namespace descriptor associated with 
//  the specified lookup index.
STDMETHODIMP CAugmentedMergeISF::QueryNameSpace( ULONG nID, PVOID* ppSrc )
{
    if (!ppSrc)
        return E_INVALIDARG;
    *ppSrc = NULL;

    LONG cSrcs;

    if ((cSrcs = NamespaceCount()) <=0)
        return E_FAIL;

    if(nID >= (ULONG)cSrcs) 
        return E_INVALIDARG;

    if (NULL == (*ppSrc = Namespace(nID)))
        return E_UNEXPECTED;

    return S_OK;
}

//-------------------------------------------------------------------------//
//  Retrieves data for the namespace identified by dwID.
STDMETHODIMP CAugmentedMergeISF::QueryNameSpace( 
    ULONG nID, 
    GUID * pguidOut, 
    IShellFolder ** ppsf )
{
    CNamespace* pSrc = NULL ;
    HRESULT          hr = QueryNameSpace( nID, (PVOID*)&pSrc ) ;

    if( pguidOut )  
        *pguidOut = NULL != pSrc ? pSrc->Guid() : GUID_NULL ;

    if( ppsf )
    {      
        if( (*ppsf = (NULL != pSrc) ? pSrc->ShellFolder() : NULL) != NULL )
            (*ppsf)->AddRef() ;
    }

    return hr ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::EnumNameSpace( 
    DWORD uNameSpace, 
    DWORD * pdwID )
{
    return E_NOTIMPL ;
}

//-------------------------------------------------------------------------//
//  IAugmentedShellFolder2 methods
//-------------------------------------------------------------------------//

//GetNameSpaceCount and GetIDListWrapCount are not used anywhere
#if 0
//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetNameSpaceCount( OUT LONG* pcNamespaces )
{
    if( !pcNamespaces )
        return E_INVALIDARG ;

    *pcNamespaces = (LONG)NamespaceCount() ;
    return S_OK ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetIDListWrapCount(
    LPCITEMIDLIST pidlWrap, 
    OUT LONG * pcPidls)
{
    if( NULL == pidlWrap || NULL == pcPidls )
        return E_INVALIDARG ;

    *pcPidls = 0 ;

    HRESULT hr ;
    if (SUCCEEDED((hr = AugMergeISF_IsWrap(pidlWrap))))
    {
        PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap(pidlWrap);
        *pcPidls = pWrap->cSrcs;
        hr = S_OK;
    }
    return hr;
}
#endif // #if 0
//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::UnWrapIDList(
    LPCITEMIDLIST pidlWrap, 
    LONG cPidls, 
    IShellFolder** apsf, 
    LPITEMIDLIST* apidlFolder, 
    LPITEMIDLIST* apidlItems, 
    LONG* pcFetched )
{
    HRESULT         hr ;
    HANDLE          hEnum ;
    BOOL            bEnum = TRUE ;
    UINT            nSrcID ;
    LPITEMIDLIST    pidlItem ;
    LONG            cFetched = 0;

    if (NULL == pidlWrap || cPidls <= 0)
        return E_INVALIDARG ;

    if (FAILED((hr = AugMergeISF_IsWrap(pidlWrap))))
        return hr ;

    //  Enumerate pidls in wrap
    for (hEnum = AugMergeISF_EnumFirstSrcPidl( pidlWrap, &nSrcID, &pidlItem);
         cFetched < cPidls && hEnum && bEnum ;
         bEnum = AugMergeISF_EnumNextSrcPidl( hEnum, &nSrcID, &pidlItem))
    {
        //  Retrieve namespace data
        CNamespace* pSrc ;
        if (SUCCEEDED((hr = QueryNameSpace(nSrcID, (PVOID*)&pSrc))))
        {
            if (apsf)
            {
                apsf[cFetched] = pSrc->ShellFolder() ;
                if (apsf[cFetched])
                    apsf[cFetched]->AddRef();
            }
            if (apidlFolder)
                apidlFolder[cFetched] = ILClone(pSrc->GetPidl());
            if (apidlItems)
            {
                apidlItems[cFetched] = pidlItem;
                pidlItem = NULL; // paranoia -- just making sure we, somehow, don't free this guy at the end of the for loop
            }
            cFetched++ ;
        }
        else
        {
            ILFree( pidlItem ) ;
        }
    }
    ILFree(pidlItem); // AugMergeISF_EnumNextSrcPidl is called (if there are 2 wrapped pidls and we ask for only one)
                      // right before we exit the for loop so we have to free pidl if allocated.
    if (hEnum)
        AugMergeISF_EndEnumSrcPidls( hEnum );

    if( pcFetched )
        *pcFetched = cFetched ;
    
    return cFetched == cPidls ? S_OK : S_FALSE ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::SetOwner( IUnknown* punkOwner )
{
    HRESULT hr = S_OK ;
    
    int cSrcs = NamespaceCount() ;

    if( cSrcs > 0 )
        DPA_EnumCallback( _hdpaNamespaces, SetOwnerProc, NULL ) ;

    ATOMICRELEASE( _punkOwner ) ;

    if( punkOwner )
    {
        hr = punkOwner->QueryInterface(IID_IUnknown, (LPVOID *)&_punkOwner ) ;
        
        if( cSrcs )
            DPA_EnumCallback( _hdpaNamespaces, SetOwnerProc, (void *)_punkOwner);
    }

    return hr ;
}

//-------------------------------------------------------------------------//
int CAugmentedMergeISF::SetOwnerProc( LPVOID pv, LPVOID pvParam )
{
    CNamespace* pSrc = (CNamespace*) pv ;
    ASSERT( pSrc ) ;

    return pSrc->SetOwner( (IUnknown*)pvParam ) ;
}

//-------------------------------------------------------------------------//
//  ITranslateShellChangeNotify methods
//-------------------------------------------------------------------------//

LPITEMIDLIST ILCombineBase(LPCITEMIDLIST pidlContainingBase, LPCITEMIDLIST pidlRel)
{
    // This routine differs from ILCombine in that it takes the First pidl's base, and
    // cats on the last id of the second pidl. We need this so Wrapped pidls
    // end up with the same base, and we get a valid full pidl.
    LPITEMIDLIST pidlRet = NULL;
    LPITEMIDLIST pidlBase = ILClone(pidlContainingBase);
    if (pidlBase)
    {
        ILRemoveLastID(pidlBase);

        pidlRet = ILCombine(pidlBase, pidlRel);

        ILFree(pidlBase);
    }

    return pidlRet;
}

BOOL IsFolderEvent(LONG lEvent)
{
    return lEvent == SHCNE_MKDIR || lEvent == SHCNE_RMDIR || lEvent == SHCNE_RENAMEFOLDER;
}

#ifdef DEBUG
void CAugmentedMergeISF::DumpObjects()
{
    if (g_dwDumpFlags & TF_AUGM)
    {
        ASSERT(_hdpaObjects);
        int iObjectCount = DPA_GetPtrCount(_hdpaObjects);
        TraceMsg(TF_AUGM, "CAugMISF::DumpObjects: Number of items: %d", iObjectCount);

        CNamespace* pns = (CNamespace *)DPA_FastGetPtr(_hdpaNamespaces, 0);
        if (pns)
            DebugDumpPidl(TF_AUGM, TEXT("CAugMISF::DumpObjects Namespace 1"), pns->GetPidl());

        pns = (CNamespace *)DPA_FastGetPtr(_hdpaNamespaces, 1);
        if (pns)
            DebugDumpPidl(TF_AUGM, TEXT("CAugMISF::DumpObjects Namespace 2"), pns->GetPidl());

        for (int i = 0; i < iObjectCount; i++)
        {
            CAugISFEnumItem* pEnumItem = (CAugISFEnumItem*)DPA_FastGetPtr(_hdpaObjects, i);
            TraceMsg(TF_ALWAYS, "CAugMISF::DumpObjects: %s, Folder: %s Merged: %s",
                pEnumItem->_pszDisplayName, 
                BOOLIFY(pEnumItem->_rgfAttrib & SFGAO_FOLDER) ? TEXT("Yes") : TEXT("No"),
                (AugMergeISF_GetSourceCount(pEnumItem->_pidlWrap) > 1)? TEXT("Yes") : TEXT("No")); 
        }
    }
}
#endif

BOOL GetRealPidlFromSimple(LPCITEMIDLIST pidlSimple, LPITEMIDLIST* ppidlReal)
{
    // Similar to SHGetRealIDL in Function, but SHGetRealIDL does SHGDN_FORPARSING | INFOLDER.
    // I need the parsing name. I can't rev SHGetRealIDL very easily, so here's this one!
    TCHAR szFullName[MAX_PATH];
    if (SUCCEEDED(SHGetNameAndFlags(pidlSimple, SHGDN_FORPARSING, szFullName, SIZECHARS(szFullName), NULL)))
    {
        *ppidlReal = ILCreateFromPath(szFullName);
    }

    if (*ppidlReal == NULL) // Unable to create? Then use the simple pidl. This is because it does not exist any more
    {                       // For say, a Delete Notify
        *ppidlReal = ILClone(pidlSimple);
    }

    return *ppidlReal != NULL;
}



//-------------------------------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::TranslateIDs( 
    LONG *plEvent, 
    LPCITEMIDLIST pidl1, 
    LPCITEMIDLIST pidl2, 
    LPITEMIDLIST * ppidlOut1, 
    LPITEMIDLIST * ppidlOut2,
    LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
    LPITEMIDLIST *ppidlOut2Event2)
{
    HRESULT hres = E_FAIL;

    switch (*plEvent)
    {
    case SHCNE_EXTENDED_EVENT:
    case SHCNE_ASSOCCHANGED:
    case SHCNE_UPDATEIMAGE:
        return S_OK;

    case SHCNE_UPDATEDIR:
        FreeObjects();
        return S_OK;
    }

    ASSERT(ppidlOut1);
    ASSERT(ppidlOut2);
    LONG lEvent = *plEvent;

    *plEvent2 = (LONG)-1;
    *ppidlOut1Event2 = NULL;
    *ppidlOut2Event2 = NULL;

    
    *ppidlOut1 = (LPITEMIDLIST)pidl1;
    *ppidlOut2 = (LPITEMIDLIST)pidl2;

    if (!plEvent)
        return E_FAIL;

    // If they are already wrapped, don't wrap twice.
    if ((pidl1 && SUCCEEDED(AugMergeISF_IsWrap(ILFindLastID(pidl1)))) ||
        (pidl2 && SUCCEEDED(AugMergeISF_IsWrap(ILFindLastID(pidl2)))))
    {
        // We don't want to wrap twice.
        return E_FAIL;
    }

    if (!_hdpaNamespaces)
        return E_FAIL;

    if (!_hdpaObjects)
        return E_FAIL;

    CAugISFEnumItem* pEnumItem;

    int iIndex;
    int iShellFolder1 = -1;
    int iShellFolder2 = -1;
    IShellFolder* psf1 = NULL;
    IShellFolder* psf2 = NULL;
    LPITEMIDLIST pidlReal1 = NULL;
    LPITEMIDLIST pidlReal2 = NULL;
    LPITEMIDLIST pidlRealRel1 = NULL;
    LPITEMIDLIST pidlRealRel2 = NULL;
    BOOL fFolder = IsFolderEvent(*plEvent);

    // Get the information about these Simple pidls: Are they our Children? If so, what namespace?
    BOOL fChild1 = IsChildIDInternal(pidl1, TRUE, &iShellFolder1);
    BOOL fChild2 = IsChildIDInternal(pidl2, TRUE, &iShellFolder2);

    // Is either a child?
    if (!(fChild1 || fChild2))
        return hres;

    // Ok, pidl1 is a child, can we get the Real pidl from the simple one?
    if (pidl1 && !GetRealPidlFromSimple(pidl1, &pidlReal1))
        goto Cleanup;

    // Ok, pidl2 is a child, can we get the Real pidl from the simple one?
    if (pidl2 && !GetRealPidlFromSimple(pidl2, &pidlReal2))
        goto Cleanup;

    // These are for code clarity later on. We deal with Relative pidls from here until the very end,
    // when we combine the base of the in pidls with the outgoing wrapped pidls.
    if (pidlReal1)
        pidlRealRel1 = ILFindLastID(pidlReal1);

    if (pidlReal2)
        pidlRealRel2 = ILFindLastID(pidlReal2);

    // Is Pidl1 in our namespaces?
    if (iShellFolder1 != -1)
    {
        // Yes, lets get the non-refcounted shell folder that know's about this pidl.
        CNamespace * pns = (CNamespace *)DPA_GetPtr(_hdpaNamespaces, iShellFolder1);
        psf1 = pns->ShellFolder();  // Non ref counted.
    }

    // Is Pidl2 in our namespaces?
    if (iShellFolder2 != -1)
    {
        // Yes, lets get the non-refcounted shell folder that know's about this pidl.
        CNamespace * pns = (CNamespace *)DPA_GetPtr(_hdpaNamespaces, iShellFolder2);
        psf2 = pns->ShellFolder();  // Non ref counted.
    }

    hres = S_OK;

    DEBUG_CODE(_fInternalGDNO = TRUE);

    switch(*plEvent)
    {
    case 0: // Just look up the pidls and return.
        {
            DWORD rgfAttrib = SFGAO_FOLDER;
            if (iShellFolder1 != -1)
            {
                psf1->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlRealRel1, &rgfAttrib);
                if (S_OK == _SearchForPidl(psf1, pidlRealRel1, BOOLIFY(rgfAttrib & SFGAO_FOLDER), &iIndex, &pEnumItem))
                {
                    *ppidlOut1 = ILCombineBase(pidlReal1, pEnumItem->_pidlWrap);
                    if (!*ppidlOut1)
                        hres = E_OUTOFMEMORY;
                }
            }

            rgfAttrib = SFGAO_FOLDER;
            if (iShellFolder2 != -1 && SUCCEEDED(hres))
            {
                psf2->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlRealRel2, &rgfAttrib);
                if (S_OK == _SearchForPidl(psf2, pidlRealRel2, BOOLIFY(rgfAttrib & SFGAO_FOLDER), &iIndex, &pEnumItem))
                {
                    *ppidlOut2 = ILCombineBase(pidlReal2, pEnumItem->_pidlWrap);
                    if (!*ppidlOut2)
                        hres = E_OUTOFMEMORY;
                }
            }
        }

        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        {
            TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s", fFolder? 
                TEXT("SHCNE_MKDIR") : TEXT("SHCNE_CREATE")); 
            // Is there a thing of this name already?
            if (S_OK == _SearchForPidl(psf1, pidlRealRel1, fFolder, &iIndex, &pEnumItem))
            {
                TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s needs to be merged. Converting to Rename", pEnumItem->_pszDisplayName);
                // Yes; Then we need to merge this new pidl into the wrapped pidl, and change this
                // to a rename, passing the Old wrapped pidl as the first arg, and the new wrapped pidl
                // as the second arg. I have to be careful about the freeing:
                // Free *ppidlOut1
                // Clone pEnumItem->_pidlWrap -> *ppidlOut1.
                // Add pidl1 to pEnumItem->_pidlWrap.
                // Clone new pEnumItem->_pidlWrap -> *ppidlOut2.  ASSERT(*ppidlOut2 == NULL)

                *ppidlOut1 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);
                if (*ppidlOut1)
                {
                    AugMergeISF_WrapAddPidl(pidlRealRel1, iShellFolder1, &pEnumItem->_pidlWrap); 
                    *ppidlOut2 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);

                    if (!*ppidlOut2)
                        TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl2");

                    *plEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                }
                else
                {
                    TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl1");
                }

            }
            else
            {
                LPITEMIDLIST pidlWrap;
                CAugISFEnumItem* paugmEnum = new CAugISFEnumItem;
                if (paugmEnum)
                {
                    if (SUCCEEDED(AugMergeISF_CreateWrap(pidlRealRel1, (UINT)iShellFolder1, &pidlWrap)) &&
                        paugmEnum->InitWithWrappedToOwn(SAFECAST(this, IAugmentedShellFolder2*), 
                                                        iShellFolder1, pidlWrap))
                    {
                        AUGMISFSEARCHFORPIDL AugMSearch;
                        AugMSearch.pszDisplayName = paugmEnum->_pszDisplayName;
                        AugMSearch.fFolder = fFolder;

                        int iInsertIndex = DPA_Search(_hdpaObjects, (LPVOID)&AugMSearch, 0,
                                AugMISFSearchForOnePidlByDisplayName, NULL, DPAS_SORTED | DPAS_INSERTAFTER);

                        TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Creating new unmerged %s at %d", 
                            paugmEnum->_pszDisplayName, iInsertIndex);

                        if (iInsertIndex < 0)
                            iInsertIndex = DA_LAST;

                        if (DPA_InsertPtr(_hdpaObjects, iInsertIndex, paugmEnum) == -1)
                        {
                            TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Was unable to add %s for some reason. Bailing", 
                                paugmEnum->_pszDisplayName);
                            DestroyObjectsProc(paugmEnum, NULL);
                        }
                        else
                        {
                            *ppidlOut1 = ILCombineBase(pidl1, paugmEnum->_pidlWrap);
                        }
                    }
                    else
                        DestroyObjectsProc(paugmEnum, NULL);
                }
            }

        }
        break;

    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        {
            TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s", fFolder? 
                TEXT("SHCNE_RMDIR") : TEXT("SHCNE_DELETE")); 
            int iDeleteIndex;
            // Is there a folder of this name already?
            if (S_OK == _SearchForPidl(psf1, pidlRealRel1, 
                fFolder, &iDeleteIndex, &pEnumItem))
            {
                TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Found %s checking merge state.", pEnumItem->_pszDisplayName); 
                // Yes; Then we need to unmerge this pidl from the wrapped pidl, and change this
                // to a rename, passing the Old wrapped pidl as the first arg, and the new wrapped pidl
                // as the second arg. I have to be careful about the freeing:
                // Free *ppidlOut1
                // Clone pEnumItem->_pidlWrap -> *ppidlOut1.
                // Remove pidl1 from pEnumItem->_pidlWrap
                // Convert to rename, pass new wrapped as second arg. 

                if (AugMergeISF_GetSourceCount( pEnumItem->_pidlWrap )  > 1 )
                {
                    TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is Merged. Removing pidl, convert to rename", pEnumItem->_pszDisplayName); 
                    *ppidlOut1 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);
                    if (*ppidlOut1)
                    {
                        EVAL(SUCCEEDED(AugMergeISF_WrapRemovePidl(pEnumItem->_pidlWrap, 
                            iShellFolder1, &pEnumItem->_pidlWrap)));

                        *ppidlOut2 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);

                        if (!*ppidlOut2)
                            TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl2");

                        *plEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                    }
                    else
                    {
                        TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl1");
                    }
                }
                else
                {
                    TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is not Merged. deleteing", pEnumItem->_pszDisplayName); 
                    pEnumItem = (CAugISFEnumItem*)DPA_DeletePtr(_hdpaObjects, iDeleteIndex);

                    if (EVAL(pEnumItem))
                    {
                        *ppidlOut1 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);
                        DestroyObjectsProc(pEnumItem, NULL);
                    }
                    else
                    {
                        TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to get %d from DPA", iDeleteIndex);
                    }
                }

            }

        }
        break;

    case SHCNE_RENAMEITEM:
    case SHCNE_RENAMEFOLDER:
        {
            // BUGBUG (lamadio): When renaming an item in the menu, this code will split it into
            // a Delete and a Create. We need to detect this situation and convert it to 1 rename. This
            // will solve the problem of the lost order during a rename....
            BOOL fEvent1Set = FALSE;
            BOOL fFirstPidlInNamespace = FALSE;
            TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s", fFolder? 
                TEXT("SHCNE_RENAMEFOLDER") : TEXT("SHCNE_RENAMEITEM")); 

            // Is this item being renamed FROM the Folder?
            if (iShellFolder1 != -1 &&          // Is this pidl a child of the Folder?
                S_OK == _SearchForPidl(psf1, pidlRealRel1, 
                fFolder, &iIndex, &pEnumItem))  // Is it found?
            {
                TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Old pidl %s is in the Folder", pEnumItem->_pszDisplayName); 
                // Yes.
                // Then we need to see if the item that it's being renamed from was Merged

                // Need this for reentrancy
                if (WrappedPidlContainsSrcID(pEnumItem->_pidlWrap, iShellFolder1))
                {
                    // Was it merged?
                    if (AugMergeISF_GetSourceCount(pEnumItem->_pidlWrap) > 1)    // Case 3)
                    {
                        TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is Merged. Removing pidl. Convert to rename for event 1", 
                            pEnumItem->_pszDisplayName); 
                        // Yes;
                        // Then we need to unmerge that item.
                        *ppidlOut1 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);
                        if (*ppidlOut1)
                        {
                            // UnWrap
                            AugMergeISF_WrapRemovePidl(pEnumItem->_pidlWrap, iShellFolder1, &pEnumItem->_pidlWrap); 

                            *ppidlOut2 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);

                            if (!*ppidlOut2)
                                TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl2");

                            // This We need to "Rename" the old wrapped pidl, to this new one
                            // that does not contain the old item.
                            fEvent1Set = TRUE;
                        }
                        else
                        {
                            TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl1");
                        }
                    }
                    else
                    {
                        TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is not merged. Nuking item Convert to Delete for event 1.", 
                            pEnumItem->_pszDisplayName); 
                        // No, This was not a wrapped pidl. Then, convert to a delete:
                        pEnumItem = (CAugISFEnumItem*)DPA_DeletePtr(_hdpaObjects, iIndex);

                        if (EVAL(pEnumItem))
                        {
                            // If we're renaming from this folder, into this folder, Then the first event stays a rename.
                            if (iShellFolder2 == -1)
                            {
                                fEvent1Set = TRUE;
                                *plEvent = fFolder? SHCNE_RMDIR : SHCNE_DELETE;
                            }
                            else
                            {
                                fFirstPidlInNamespace = TRUE;
                            }
                            *ppidlOut1 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);
                            DestroyObjectsProc(pEnumItem, NULL);
                        }
                        else
                        {
                            TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to find Item at %d", iIndex);
                        }

                    }
                }
                else
                {
                    TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Skipping this because we already processed it."
                        "Dragging To Desktop?");
                    hres = E_FAIL;
                }

            }

            // Is this item is being rename INTO the Start Menu?
            if (iShellFolder2 != -1)
            {
                TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: New pidl is in the Folder"); 
                LPITEMIDLIST* ppidlNewWrapped1 = ppidlOut1;
                LPITEMIDLIST* ppidlNewWrapped2 = ppidlOut2;
                LONG* plNewEvent = plEvent;

                if (fEvent1Set)
                {
                    plNewEvent = plEvent2;
                    ppidlNewWrapped1 = ppidlOut1Event2;
                    ppidlNewWrapped2 = ppidlOut2Event2;
                }

                if (S_OK == _SearchForPidl(psf2, pidlRealRel2, 
                    fFolder, &iIndex, &pEnumItem))
                {

                    // If we're renaming from this folder, into this folder, Check to see if the destination has a
                    // conflict. If there is a confict (This case), then convert first event to a remove, 
                    // and the second event to the rename.
                    if (fFirstPidlInNamespace)
                    {
                        fEvent1Set = TRUE;
                        *plEvent = fFolder? SHCNE_RMDIR : SHCNE_DELETE;
                        plNewEvent = plEvent2;
                        ppidlNewWrapped1 = ppidlOut1Event2;
                        ppidlNewWrapped2 = ppidlOut2Event2;
                    }
                    
                    
                    TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is in Folder", pEnumItem->_pszDisplayName);
                    TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Adding pidl to %s. Convert to Rename for event %s", 
                        pEnumItem->_pszDisplayName, fEvent1Set? TEXT("2") : TEXT("1"));

                    // Then the destination needs to be merged.
                    *ppidlNewWrapped1 = ILCombineBase(pidl2, pEnumItem->_pidlWrap);
                    if (*ppidlNewWrapped1)
                    {
                        TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Successfully created out pidl1");
                        AugMergeISF_WrapAddPidl(pidlRealRel2, iShellFolder2, &pEnumItem->_pidlWrap); 

                        *ppidlNewWrapped2 = ILCombineBase(pidl2, pEnumItem->_pidlWrap);

                        *plNewEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                    }
                }
                else
                {
                    LPITEMIDLIST pidlWrap;
                    CAugISFEnumItem* paugmEnum = new CAugISFEnumItem;

                    if (paugmEnum)
                    {
                        if (SUCCEEDED(AugMergeISF_CreateWrap(pidlRealRel2, (UINT)iShellFolder2, &pidlWrap)) &&
                            paugmEnum->InitWithWrappedToOwn(SAFECAST(this, IAugmentedShellFolder2*), 
                                                            iShellFolder2, pidlWrap))
                        {
                            AUGMISFSEARCHFORPIDL AugMSearch;
                            AugMSearch.pszDisplayName = paugmEnum->_pszDisplayName;
                            AugMSearch.fFolder = BOOLIFY(paugmEnum->_rgfAttrib & SFGAO_FOLDER);

                            int iInsertIndex = DPA_Search(_hdpaObjects, &AugMSearch, 0,
                                    AugMISFSearchForOnePidlByDisplayName, NULL, DPAS_SORTED | DPAS_INSERTAFTER);

                            TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is a new item. Converting to Create", 
                                paugmEnum->_pszDisplayName);

                            if (iInsertIndex < 0)
                                iInsertIndex = DA_LAST;

                            if (DPA_InsertPtr(_hdpaObjects, iInsertIndex, paugmEnum) == -1)
                            {
                                TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Was unable to add %s for some reason. Bailing", 
                                    paugmEnum->_pszDisplayName);
                                DestroyObjectsProc(paugmEnum, NULL);
                            }
                            else
                            {
                                TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Creating new item %s at %d for event %s", 
                                    paugmEnum->_pszDisplayName, iInsertIndex,  fEvent1Set? TEXT("2") : TEXT("1"));

                                // If we're renaming from this folder, into this folder, Then the first event stays
                                // a rename.
                                if (!fFirstPidlInNamespace)
                                {
                                    *plNewEvent = fFolder ? SHCNE_MKDIR : SHCNE_CREATE;
                                    *ppidlNewWrapped1 = ILCombineBase(pidl2, pidlWrap);
                                    *ppidlNewWrapped2 = NULL;
                                }
                                else
                                    *ppidlOut2 = ILCombineBase(pidl2, pidlWrap);

                            }
                        }
                        else
                            DestroyObjectsProc(paugmEnum, NULL);

                    }
                }
            }
        }
        break;

    default:
        break;
    }

Cleanup:
    ILFree(pidlReal1);
    ILFree(pidlReal2);

#ifdef DEBUG
    DumpObjects();
    _fInternalGDNO = FALSE;
#endif


    return hres;
}

BOOL CAugmentedMergeISF::IsChildIDInternal(LPCITEMIDLIST pidlKid, BOOL fImmediate, int* piShellFolder)
{
    // This is basically the same Method as the interface method, but returns the shell folder
    // that it came from.
    BOOL fChild = FALSE;

    //At this point we should have a translated pidl
    if (pidlKid)
    {
        if (SUCCEEDED(AugMergeISF_IsWrap(pidlKid)))
        {
            LPCITEMIDLIST pidlRelKid = ILFindLastID(pidlKid);
            if (pidlRelKid)
            {
                UINT   uiId;
                LPITEMIDLIST pidl;
                HANDLE hEnum = AugMergeISF_EnumFirstSrcPidl(pidlRelKid, &uiId, &pidl);

                if (hEnum)
                {
                    do
                    {
                        ILFree(pidl);

                        for (int i = 0; fChild == FALSE && i < DPA_GetPtrCount(_hdpaNamespaces); i++)
                        {
                            CNamespace * pns = (CNamespace *)DPA_GetPtr(_hdpaNamespaces, i);
                            // reuse pidl
                            if (pns && (pidl = pns->GetPidl()) != NULL)
                            {
                                if (ILIsParent(pidl, pidlKid, fImmediate) &&
                                    !ILIsEqual(pidl, pidlKid))
                                {
                                    fChild = TRUE;
                                    if (piShellFolder)
                                        *piShellFolder = i;
                                }
                            }
                        }
                    }
                    while (fChild == FALSE && AugMergeISF_EnumNextSrcPidl(hEnum, &uiId, &pidl));

                    AugMergeISF_EndEnumSrcPidls(hEnum);
                }
            }
        }
        else
        {
            int cSrcs = NamespaceCount();

            for(int i = 0; fChild == FALSE && i < cSrcs ; i++)
            {
                CNamespace* pSrc = Namespace(i);
                if (pSrc && ILIsParent(pSrc->GetPidl(), pidlKid, fImmediate) && 
                    !ILIsEqual(pSrc->GetPidl(), pidlKid))
                {
                    fChild = TRUE;
                    if (piShellFolder)
                        *piShellFolder = i;
                }
            }
        }
    }

    return fChild;
}

//-------------------------------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::IsChildID( LPCITEMIDLIST pidlKid, BOOL fImmediate)
{
    return IsChildIDInternal(pidlKid, fImmediate, NULL) ? S_OK : S_FALSE;
}

//-------------------------------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::IsEqualID( LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2 )
{
    // This used to return E_NOTIMPL. I'm kinda overloading the interface to mean:
    // is this equal tp any of your namespaces.
    HRESULT hres = S_FALSE;
    int cSrcs = NamespaceCount();

    for(int i = 0; hres == S_FALSE && i < cSrcs ; i++)
    {
        CNamespace* pSrc = Namespace(i);
        if (pidl1)
        {
            if (pSrc && ILIsEqual(pSrc->GetPidl(), pidl1))
                hres = S_OK;
        }
        else if (pidl2) // If you pass a pidl2 it means: Is pidl2 a parent of one of my namespaces?
        {
            if (pSrc && ILIsParent(pidl2, pSrc->GetPidl(), FALSE))
                hres = S_OK;
        }

    }
    return hres;
}

//-------------------------------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::Register( 
    HWND hwnd, 
    UINT uMsg, 
    long lEvents )
{
    int i, cSrcs ;

    if( 0 >= (cSrcs = NamespaceCount()) )
        return E_FAIL ;
    
    for( i = 0; i < cSrcs ; i++ )
    {
        CNamespace* pSrc ;
        if( NULL != (pSrc = Namespace( i )) )
            pSrc->RegisterNotify( hwnd, uMsg, lEvents ) ;
    }
    return S_OK ;
}

//-------------------------------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::Unregister ()
{
    int i, cSrcs = NamespaceCount() ;
    
    if( cSrcs <= 0 )
        return E_FAIL ;
    
    for( i = 0; i < cSrcs ; i++ )
    {
        CNamespace* pSrc ;
        if( NULL != (pSrc = Namespace( i )) )
            pSrc->UnregisterNotify() ;
    }
    return S_OK ;
}

// *** IDropTarget methods ***
#define HIDA_GetPIDLFolder(pida)        (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])
#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])

HRESULT CAugmentedMergeISF::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    ASSERT(!_fCommon);
    ASSERT(_pdt == NULL);
    if (pDataObj)
    {        
        InitClipboardFormats();
        
        FORMATETC fmte = {g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium;

        medium.pUnkForRelease = NULL;
        medium.hGlobal = NULL;

        if (SUCCEEDED(pDataObj->GetData(&fmte, &medium)))
        {
            LPIDA pida = (LPIDA)GlobalLock(medium.hGlobal);
            
            if (pida)
            {
                LPCITEMIDLIST pidlItem = HIDA_GetPIDLFolder(pida);

                _fCommon = BOOLIFY(_IsCommonPidl(pidlItem));
                GlobalUnlock(medium.hGlobal);
            }
            ReleaseStgMedium(&medium);
        }

        CNamespace *pSrc = NULL;
        ULONG gdnsAttribs = 0;
        
        if (!_fCommon)
            gdnsAttribs = ASFF_DEFNAMESPACE_ALL;
            
        if (SUCCEEDED(GetDefNamespace(gdnsAttribs, (PVOID*)&pSrc, NULL, NULL)))
        {
            if (SUCCEEDED(pSrc->ShellFolder()->CreateViewObject(_hwnd, IID_IDropTarget, (void **)&_pdt)))
            {
                _pdt->DragEnter(pDataObj, grfKeyState, pt, pdwEffect);
            }
        }        
    }

    _grfDragEnterKeyState = grfKeyState;
    _dwDragEnterEffect = *pdwEffect;

    return S_OK;
}

HRESULT CAugmentedMergeISF::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres = S_OK;

    if (_pdt)
        hres = _pdt->DragOver(grfKeyState, pt, pdwEffect);
        
    return hres;
}

HRESULT CAugmentedMergeISF::DragLeave(void)
{
    HRESULT hres = S_OK;

    _fCommon = 0;
    if (_pdt)
    {
        hres = _pdt->DragLeave();
        ATOMICRELEASE(_pdt);
    }
    
    return hres;
}

HRESULT CAugmentedMergeISF::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres = S_OK;
    BOOL    bNoUI = !_fCommon;
    BOOL    bConfirmed = !_fCommon;

    if (!_pdt && pDataObj)
    {
        LPITEMIDLIST pidlParent = NULL,
                     pidlOther  = NULL;
        
        int csidl = _fCommon ? CSIDL_COMMON_STARTMENU : CSIDL_STARTMENU,
            csidlOther = _fCommon ? CSIDL_STARTMENU : CSIDL_COMMON_STARTMENU;

        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl, &pidlParent)) &&
            SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidlOther, &pidlOther)))
        {
            FORMATETC fmte = {g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            STGMEDIUM medium;
            
            medium.pUnkForRelease = NULL;
            medium.hGlobal = NULL;

            if (SUCCEEDED(pDataObj->GetData(&fmte, &medium)))
            {
                LPIDA pida = (LPIDA)GlobalLock(medium.hGlobal);
                
                if (pida)
                {
                    IShellFolder *psfParent = NULL,
                                 *psfOther  = NULL;

                    if (SUCCEEDED(IEBindToObject(pidlParent, &psfParent)) &&
                        SUCCEEDED(IEBindToObject(pidlOther,  &psfOther)))
                    {
                        LPCITEMIDLIST pidlItem, pidl;
                        LPITEMIDLIST  pidlRel;
                                      
                        pidlItem   = HIDA_GetPIDLItem(pida, 0);

                        // we came here because we don't have pdt which means that
                        // there is only one folder in our namespace and that's not
                        // the one we have to drop IDataObj on.

                        CNamespace* pCNamespace = Namespace(0);

                        if (pCNamespace)
                        {
                            pidl = pCNamespace->GetPidl();  // don't need to free pidl.

                            if (pidl)
                            {
                                pidlRel = ILClone(ILFindChild(pidlOther, pidl));
                        
                                if (pidlRel)
                                {
                                    STRRET strret;
                                    TCHAR  szDir[MAX_PATH];

                                    strret.uType = STRRET_CSTR;
                                    if (SUCCEEDED(psfParent->GetDisplayNameOf(pidlRel, SHGDN_FORPARSING, &strret)) &&
                                        SUCCEEDED(StrRetToBuf(&strret, pidlRel, szDir, ARRAYSIZE(szDir))))
                                    {
                                        if (_fCommon)
                                        {
                                            bConfirmed = AffectAllUsers(_hwnd);
                                            bNoUI = TRUE;
                                        }

                                        if (bConfirmed)
                                        {
                                            BOOL bCreated = FALSE;

                                            switch (SHCreateDirectory(_hwnd, szDir))
                                            {
                                            case ERROR_FILENAME_EXCED_RANGE:
                                            case ERROR_FILE_EXISTS:
                                            case ERROR_ALREADY_EXISTS:
                                            case 0: // It was created successfully.
                                                bCreated = TRUE;
                                            }

                                            if (bCreated)
                                            {
                                                IShellFolder *psf;
                                    
                                                if (SUCCEEDED(psfParent->BindToObject(pidlRel, NULL, IID_IShellFolder, (void **)&psf)))
                                                {
                                                    psf->CreateViewObject(_hwnd, IID_IDropTarget, (void **)&_pdt);
                                                    // we're going to call drop on it, call dragenter first
                                                    if (_pdt)
                                                        _pdt->DragEnter(pDataObj, _grfDragEnterKeyState, pt, &_dwDragEnterEffect);
                                                    psf->Release();
                                                }
                                            }
                                        }
                                    }
                          
                                    ILFree(pidlRel);
                                }
                            }
                        }
                    }
                    if (psfParent)
                        psfParent->Release();
                    if (psfOther)
                        psfOther->Release();

                    GlobalUnlock(medium.hGlobal);
                }
                ReleaseStgMedium(&medium);
            }
        }
        ILFree(pidlParent);
        ILFree(pidlOther);
    }

    if (_pdt)
    {
        hres = E_FAIL;
        
        if ((bNoUI || (bConfirmed = AffectAllUsers(_hwnd))) && bConfirmed)
            hres = _pdt->Drop(pDataObj, grfKeyState, pt, pdwEffect);
        else
            hres = _pdt->DragLeave();

        ATOMICRELEASE(_pdt);
    }
    _fCommon = 0;

    return hres;
}

//-------------------------------------------------------------------------------------------------//
LPITEMIDLIST CAugmentedMergeISF::GetNativePidl(LPCITEMIDLIST pidlWrap, LPARAM nSrcID /*int nID*/)
{
    LPITEMIDLIST pidlRet = NULL;

    if (SUCCEEDED(AugMergeISF_GetSrcPidl(pidlWrap, (UINT)nSrcID, &pidlRet)))
        return pidlRet ;

    // not wrapped by me.
    return NULL;
}

BOOL AffectAllUsers(HWND hwnd)
{
    TCHAR szMessage[255];
    TCHAR szTitle[20];
    BOOL  bRet = FALSE;

    if (MLLoadShellLangString(IDS_ALLUSER_WARNING, szMessage, ARRAYSIZE(szMessage)) > 0 &&
        MLLoadShellLangString(IDS_ALLUSER_WARNING_TITLE, szTitle, ARRAYSIZE(szTitle)) > 0)
    {
        bRet = IDYES == MessageBox(hwnd, szMessage, szTitle, MB_YESNO | MB_ICONINFORMATION);
    }
    return bRet;
}

BOOL CAugmentedMergeISF::_IsCommonPidl(LPCITEMIDLIST pidlItem)
{
    BOOL bRet = FALSE;
    LPITEMIDLIST pidlCommon;
    
    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_STARTMENU, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }
    if (!bRet &&
        SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }
    if (!bRet &&
        SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }

    return bRet;
}

HRESULT CAugmentedMergeISF::_SearchForPidl(IShellFolder* psf, LPCITEMIDLIST pidl, BOOL fFolder, int* piIndex, CAugISFEnumItem** ppEnumItem)
{
    STRRET str;
    TCHAR szDisplayName[MAX_PATH];
    int iIndex = -1;

    *ppEnumItem = NULL;

    if (SUCCEEDED(psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, &str)) &&
        SUCCEEDED(StrRetToBuf(&str, pidl, szDisplayName, ARRAYSIZE(szDisplayName))))
    {
        AUGMISFSEARCHFORPIDL SearchFor;
        SearchFor.pszDisplayName = szDisplayName;
        SearchFor.fFolder = fFolder;

        iIndex = DPA_Search(_hdpaObjects, (LPVOID)&SearchFor, 0,
                AugMISFSearchForOnePidlByDisplayName, NULL, DPAS_SORTED);

        if (iIndex >= 0)
        {
            *ppEnumItem = DPA_GETPTR( _hdpaObjects, iIndex, CAugISFEnumItem);
        }
    }

    if (piIndex)
        *piIndex = iIndex;

    if (*ppEnumItem)
        return S_OK;

    return S_FALSE;
}


// given a wrapped pidl
// f-n returns common and user namespaces (if they are in wrapped pidl) -- note that they are not addrefed
// unwrapped pidl, and if the unwrapped pidl is folder or not
HRESULT CAugmentedMergeISF::_GetNamespaces(LPCITEMIDLIST pidlWrap, 
                                           CNamespace** ppnsCommon, 
                                           UINT* pnCommonID,
                                           CNamespace** ppnsUser, 
                                           UINT* pnUserID,
                                           LPITEMIDLIST* ppidl, 
                                           BOOL *pbIsFolder)
{    
    HRESULT      hres;
    UINT         nSrcID;
    CNamespace * pns;
    int          cWrapped;
    HANDLE       hEnum;
    
    ASSERT(ppnsCommon && ppnsUser && ppidl);

    *ppnsCommon = NULL;
    *ppnsUser   = NULL;
    *ppidl      = NULL;

    ASSERT(SUCCEEDED(AugMergeISF_IsWrap(pidlWrap)));
        
    cWrapped = AugMergeISF_GetSourceCount(pidlWrap);

    if (NULL == _hdpaNamespaces || 0 >= cWrapped || 
        NULL == (hEnum = AugMergeISF_EnumFirstSrcPidl(pidlWrap, &nSrcID, ppidl)))
        return E_FAIL;
        
    hres = QueryNameSpace(nSrcID, (void **)&pns);
    if (EVAL(SUCCEEDED(hres)))
    {
        IShellFolder * psf;
        ULONG rgf = SFGAO_FOLDER;

        psf = pns->ShellFolder(); // no addref
        ASSERT(psf);
        if (SUCCEEDED(psf->GetAttributesOf(1, (LPCITEMIDLIST*)ppidl, &rgf)))
        {
            if (pbIsFolder)
                *pbIsFolder = rgf & SFGAO_FOLDER;
                
            LPITEMIDLIST   pidlItem;
            UINT           nCommonID;
            CNamespace*    pnsCommonTemp;

            // get common namespace (attribs = 0)
            hres = GetDefNamespace(0, (void **)&pnsCommonTemp, &nCommonID, NULL);
            ASSERT(NamespaceCount() == 2 && SUCCEEDED(hres) || NamespaceCount() == 1);
            if (FAILED(hres))
                nCommonID = 1;

            if (nCommonID == nSrcID)
            {
                *ppnsCommon = pns;
                if (pnCommonID)
                    *pnCommonID = nCommonID;
            }
            else
            {
                *ppnsUser = pns;
                if (pnUserID)
                    *pnUserID = nSrcID;
            }
            
            if (AugMergeISF_EnumNextSrcPidl(hEnum, &nSrcID, &pidlItem))
            {
                ASSERT(ILIsEqual(*ppidl, pidlItem));
                ILFree(pidlItem);
                if (SUCCEEDED(QueryNameSpace(nSrcID, (void **)&pns)))
                {
                    ASSERT(pns);
                    if (nCommonID == nSrcID)
                    {
                        *ppnsCommon = pns;
                        if (pnCommonID)
                            *pnCommonID = nCommonID;
                    }
                    else
                    {
                        *ppnsUser = pns;
                        if (pnUserID)
                            *pnUserID = nSrcID;
                    }
                }
            }

            hres = S_OK;
        }
    }
    AugMergeISF_EndEnumSrcPidls(hEnum);

    return hres;
}

HRESULT CAugmentedMergeISF::_GetContextMenu(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, 
                                            UINT * prgfInOut, void ** ppvOut)
{
    HRESULT      hres;
    LPITEMIDLIST pidl;
    BOOL         bIsFolder;
    CNamespace * pnsCommon;
    CNamespace * pnsUser;

    ASSERT(cidl == 1);

    // psfCommon and psfUser are not addrefed
    hres = _GetNamespaces(apidl[0], &pnsCommon, NULL, &pnsUser, NULL, &pidl, &bIsFolder);
    if (SUCCEEDED(hres))
    {
        ASSERT(pnsCommon || pnsUser);
        if (bIsFolder)
        {
            // folder? need our context menu
            IShellFolder * psfCommon = NULL;
            IShellFolder * psfUser = NULL;
            LPCITEMIDLIST  pidlCommon = NULL;
            LPCITEMIDLIST  pidlUser = NULL;

            if (pnsCommon)
            {
                psfCommon  = pnsCommon->ShellFolder();
                pidlCommon = pnsCommon->GetPidl();
            }
            if (pnsUser)
            {
                psfUser    = pnsUser->ShellFolder();
                pidlUser   = pnsUser->GetPidl();
            }
            CAugMergeISFContextMenu * pcm = CreateMergeISFContextMenu(psfCommon, pidlCommon, 
                                                                      psfUser, pidlUser,
                                                                      pidl, hwnd, prgfInOut);

            if (pcm)
            {
                hres = pcm->QueryInterface(IID_IContextMenu, ppvOut);
                pcm->Release();
            }
            else
                hres = E_OUTOFMEMORY;
        }
        else
        {   // it's not a folder
            // delegate to the isf
            IShellFolder * psf = pnsUser ? pnsUser->ShellFolder() : pnsCommon->ShellFolder();

            hres = psf->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pidl, IID_IContextMenu, prgfInOut, ppvOut);
        }
        ILFree(pidl);
    }

    return hres;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetDefNamespace( 
    LPCITEMIDLIST pidlWrap, 
    ULONG dwAttrib, 
    OUT IShellFolder** ppsf,
    OUT LPITEMIDLIST* ppidlItem )
{
    HRESULT          hr ;
    LPITEMIDLIST     pidl ;
    CNamespace* pSrc ;
    ULONG            dwDefAttrib = dwAttrib & ASFF_DEFNAMESPACE_ALL ;
    int              cWrapped ;
    UINT             nSrcID ;
    HANDLE           hEnum ;

    ASSERT( ppsf ) ;
    
    *ppsf = NULL ;
    if (ppidlItem) 
        *ppidlItem = NULL ;

    if (FAILED((hr = AugMergeISF_IsWrap( pidlWrap ))))
        return hr ;
    cWrapped = AugMergeISF_GetSourceCount( pidlWrap ) ;

    //  No namespaces?
    if (NULL == _hdpaNamespaces || 0 >= cWrapped || 
        NULL == (hEnum = AugMergeISF_EnumFirstSrcPidl( pidlWrap, &nSrcID, &pidl)))
        return E_FAIL ;

    //  Only one namespace in wrap? Give up the shell folder and item ID.
    if (1 == cWrapped || 0==dwDefAttrib)
    {
        AugMergeISF_EndEnumSrcPidls( hEnum ) ; // no need to go further

        //  Retrieve the namespace object identified by nSrcID.
        if( SUCCEEDED( (hr = QueryNameSpace( nSrcID, (PVOID*)&pSrc )) ) ) 
        {
            *ppsf = pSrc->ShellFolder() ;
            if( ppidlItem )
                *ppidlItem = pidl ;
            return S_OK ;
        }

        ILFree( pidl ) ;
        return hr ;
    }

    //  More than one namespace in wrap?
    if( cWrapped > 1 )
    {
        LPITEMIDLIST   pidl0   = NULL ;
        CNamespace*    pSrc0   = NULL ;  // get this below.

        for (BOOL bEnum = TRUE ; bEnum ; 
             bEnum = AugMergeISF_EnumNextSrcPidl(hEnum, &nSrcID,  &pidl))
        {
            if (SUCCEEDED((hr = QueryNameSpace(nSrcID, (PVOID*)&pSrc)))) 
            {
                if (dwDefAttrib & pSrc->Attrib())
                {
                    //  Matched attributes; we're done.
                    AugMergeISF_EndEnumSrcPidls(hEnum);
                    *ppsf = pSrc->ShellFolder() ;
                    if (ppidlItem)
                        *ppidlItem = pidl;
                    if(pidl0) 
                        ILFree(pidl0);
                    return S_OK ;
                }

                //  Stash first namespace object and item pidl.  
                //  We'll default to these if                
                if( NULL == pSrc0 )
                {
                    pSrc0 = pSrc ;
                    pidl0 = ILClone( pidl ) ;
                }
            }
            ILFree( pidl ) ;
        }
        AugMergeISF_EndEnumSrcPidls( hEnum ) ;
        
        //  Default to first namespace
        if( pSrc0 && pidl0 )
        {
            *ppsf       = pSrc0->ShellFolder() ;
            if( ppidlItem )
                *ppidlItem  = pidl0 ;
            return S_OK ;
        }
    }
    
    return E_UNEXPECTED ;
}

//-------------------------------------------------------------------------//
//  Retrieves the default namespaces for the indicated attibutes.
//  The dwAttrib arg must be initialized prior to function entry,
STDMETHODIMP CAugmentedMergeISF::GetDefNamespace( 
    ULONG dwAttrib,
    OUT   PVOID* ppSrc, UINT *pnSrcID, PVOID* ppSrc0 )
{
    CNamespace* pSrc ;
    ULONG       dwDefAttrib = dwAttrib & ASFF_DEFNAMESPACE_ALL ;

    // this is an internal helper so we better make sure we pass the correct params!
    //if (NULL == ppSrc)
    //    return E_INVALIDARG ;
    *ppSrc = NULL ;
    if( ppSrc0 ) 
        *ppSrc0 = NULL ;

    for( int i = 0, cSrcs = NamespaceCount(); i < cSrcs ; i++ )
    {
        if( NULL != (pSrc = Namespace( i )) )
        {
            if( 0 == i && ppSrc0 )
                *ppSrc0 = pSrc ;

            if( dwDefAttrib & pSrc->Attrib() || 
                dwDefAttrib == 0 && !(pSrc->Attrib() & ASFF_DEFNAMESPACE_ALL))
            {
                *ppSrc = pSrc;
                if (NULL != pnSrcID)
                    *pnSrcID = i;
                return S_OK ;
            }
        }
    }

    return E_FAIL ;
}

// BUGBUG(lamadio): Move this to a better location, This is a nice generic function
#ifdef DEBUG
BOOL DPA_VerifySorted(HDPA hdpa, PFNDPACOMPARE pfn, LPARAM lParam)
{
    if (!EVAL(hdpa))
        return FALSE;

    for (int i = 0; i < DPA_GetPtrCount(hdpa) - 1; i++)
    {
        if (pfn(DPA_FastGetPtr(hdpa, i), DPA_FastGetPtr(hdpa, i + 1), lParam) > 0)
            return FALSE;
    }

    return TRUE;
}
#else
#define DPA_VerifySorted(hdpa, pfn, lParam)
#endif

int CAugmentedMergeISF::AcquireObjects()
{
    HDPA hdpa2 = NULL;

    DEBUG_CODE(_fInternalGDNO = TRUE);
    
    for (int i = 0; i < DPA_GETPTRCOUNT(_hdpaNamespaces); i++)
    {
        CNamespace * pns = DPA_GETPTR(_hdpaNamespaces, i, CNamespace);
        IShellFolder * psf;
        IEnumIDList  * peid;
        HDPA         * phdpa;

        ASSERT(pns);
        psf = pns->ShellFolder(); // no addref here!

        if (i == 0)
        {
            phdpa = &_hdpaObjects;
            _hdpaObjects = DPA_Create(4);   // We should always create the DPA
        }
        else
        {
            ASSERT(i == 1); // no support for more than 2 isf's
            phdpa = &hdpa2;
        }
        
        HRESULT hres = psf->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN, &peid);
        if (SUCCEEDED(hres))
        {
            if (!*phdpa)
                *phdpa = DPA_Create(4);

            if (*phdpa)
            {
                LPITEMIDLIST pidl;
                ULONG        cEnum;
                
                while (SUCCEEDED(peid->Next(1, &pidl, &cEnum)) && 1 == cEnum)
                {
                    CAugISFEnumItem* paugmEnum = new CAugISFEnumItem;

                    if (paugmEnum)
                    {
                        
                        if (paugmEnum->Init(SAFECAST(this, IAugmentedShellFolder2*), i, pidl))
                        {
                            if (DPA_AppendPtr(*phdpa, paugmEnum) == -1)
                                DestroyObjectsProc(paugmEnum, NULL);
                        }
                        else
                            delete paugmEnum;
                    }
                    ILFree(pidl);
                }
            }
            peid->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "CAugMISF::AcquireObjects: Failed to get enumerator 0x%x", hres);

        }
    }

    // now that we have both hdpa's (or one) let's merge them.
    if (DPA_GETPTRCOUNT(_hdpaNamespaces) == 2 && hdpa2)
    {
        DPA_Merge(_hdpaObjects, hdpa2, DPAM_UNION, AugmEnumCompare, AugmEnumMerge, (LPARAM)0);
        DPA_DESTROY(hdpa2, DestroyObjectsProc);
    }
    else
    {
        DPA_Sort(_hdpaObjects, AugmEnumCompare, 0);
    }

    ASSERT(DPA_VerifySorted(_hdpaObjects, AugmEnumCompare, 0));

    DEBUG_CODE(_fInternalGDNO = FALSE);


#ifdef DEBUG
    TraceMsg(TF_AUGM, "CAugMISF::AcquireObjects");
    DumpObjects();
#endif

    _count = DPA_GETPTRCOUNT(_hdpaObjects);
    
    return _count;
}

//-------------------------------------------------------------------------//
void CAugmentedMergeISF::FreeObjects()
{
    DPA_DESTROY( _hdpaObjects, DestroyObjectsProc ) ;
    _hdpaObjects = NULL;
    _count = 0 ;
}

//-------------------------------------------------------------------------//
int CAugmentedMergeISF::DestroyObjectsProc( LPVOID pv, LPVOID pvData )
{
    CAugISFEnumItem* paugmEnum = (CAugISFEnumItem*)pv;

    if (EVAL(NULL != paugmEnum))
    {
        delete paugmEnum;
    }
    return TRUE ;
}

//-------------------------------------------------------------------------//
void CAugmentedMergeISF::FreeNamespaces()
{
    DPA_DESTROY( _hdpaNamespaces, DestroyNamespacesProc ) ;
}

//-------------------------------------------------------------------------//
int CAugmentedMergeISF::DestroyNamespacesProc( LPVOID pv, LPVOID pvData )
{
    CNamespace* p ;
    if( NULL != (p = (CNamespace*)pv) )
        delete p ;
    return TRUE ;
}


STDMETHODIMP CAugmentedMergeISF::GetPidl(int* piPos, DWORD grfEnumFlags, LPITEMIDLIST* ppidl)
{
    *ppidl = NULL;

    if (_hdpaObjects == NULL)
        AcquireObjects();

    if (_hdpaObjects == NULL)
        return E_OUTOFMEMORY;

    BOOL   fWantFolders    = 0 != (grfEnumFlags & SHCONTF_FOLDERS),
           fWantNonFolders = 0 != (grfEnumFlags & SHCONTF_NONFOLDERS),
           fWantHidden     = 0 != (grfEnumFlags & SHCONTF_INCLUDEHIDDEN) ;

    while (*piPos < _count)
    {
        CAugISFEnumItem* paugmEnum = DPA_GETPTR( _hdpaObjects, *piPos, CAugISFEnumItem);
        if ( NULL != paugmEnum )
        {
            BOOL fFolder         = 0 != (paugmEnum->_rgfAttrib & SFGAO_FOLDER),
                 fHidden         = 0 != (paugmEnum->_rgfAttrib & SFGAO_HIDDEN);
             
            if ((!fHidden || fWantHidden) && 
                ((fFolder && fWantFolders) || (!fFolder && fWantNonFolders)))
            {
                //  Copy out the pidl ;
                *ppidl = ILClone(paugmEnum->_pidlWrap);
                break;
            }
            else
            {
                (*piPos)++;
            }
        }
    }

    if (*ppidl)
        return S_OK;

    return S_FALSE;
}


//-------------------------------------------------------------------------//
CEnum::CEnum(IAugmentedMergedShellFolderInternal* psmsfi, DWORD grfEnumFlags, int iPos) : 
        _cRef(1), 
        _iPos(iPos),
        _psmsfi(psmsfi),
        _grfEnumFlags(grfEnumFlags)

{ 
    _psmsfi->AddRef();
}

CEnum::~CEnum()
{
    ATOMICRELEASE(_psmsfi);
}

//-------------------------------------------------------------------------//
//  class CEnum - IUnknown methods 
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
STDMETHODIMP CEnum::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    static const QITAB qit[] = { 
        QITABENT(CEnum, IEnumIDList), 
        { 0 } 
    };
    return QISearch(this, qit, riid, ppvObj);
}
//-------------------------------------------------------------------------//
STDMETHODIMP_(ULONG) CEnum::AddRef ()
{
    return InterlockedIncrement((LONG*)&_cRef);
}
//-------------------------------------------------------------------------//
STDMETHODIMP_(ULONG) CEnum::Release ()
{
    if (InterlockedDecrement((LONG*)&_cRef)) 
        return _cRef;
    
    delete this ;
    return 0;
}

//-------------------------------------------------------------------------//
//  class CEnum - IEnumIDList methods 
//-------------------------------------------------------------------------//
STDMETHODIMP CEnum::Next( 
    ULONG celt,
    LPITEMIDLIST *rgelt,
    ULONG *pceltFetched )
{
    int iStart = _iPos;
    int cFetched = 0;
    HRESULT hres = S_OK;

    if( !(celt > 0 && rgelt) || (NULL == pceltFetched && celt > 1 ) )
        return E_INVALIDARG ;
    
    *rgelt = 0;

    while(hres == S_OK && (_iPos - iStart) < (int)celt)
    {
        LPITEMIDLIST pidl;
        hres = _psmsfi->GetPidl(&_iPos, _grfEnumFlags, &pidl);
        if (hres == S_OK)
        {
            rgelt[cFetched] = pidl;
            cFetched++ ;
        }
        _iPos++;
    }
    
    if( pceltFetched )
        *pceltFetched = cFetched ;
    
    return celt == (ULONG)cFetched ? S_OK : S_FALSE ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CEnum::Skip(ULONG celt)
{
    _iPos += celt;
    return S_OK ;
}
//-------------------------------------------------------------------------//
STDMETHODIMP CEnum::Reset()
{
    _iPos = 0;
    return S_OK ;
}
//-------------------------------------------------------------------------//
// REVIEW: Can probably be E_NOTIMPL
STDMETHODIMP CEnum::Clone( IEnumIDList **ppenum )
{
    if( NULL == (*ppenum = new CEnum( _psmsfi, _grfEnumFlags, _iPos )) )
        return E_OUTOFMEMORY;

    return S_OK;
}



BOOL CAugISFEnumItem::Init(IShellFolder* psf, int iShellFolder, LPCITEMIDLIST pidl)
{
    // This is ok, the memory just gets written to twice. 
    if (SUCCEEDED(AugMergeISF_CreateWrap(pidl, iShellFolder, &_pidlWrap)))
    {
        // Takes ownership of passed in pidl.
        return InitWithWrappedToOwn(psf, iShellFolder, _pidlWrap);
    }

    return FALSE;
}

BOOL CAugISFEnumItem::InitWithWrappedToOwn(IShellFolder* psf, int iShellFolder, LPITEMIDLIST pidl)
{
    BOOL fRet = FALSE;
    STRRET str;
    TCHAR  szDisplayName[MAX_PATH];

    _pidlWrap = pidl;
    
    _rgfAttrib = SFGAO_FOLDER | SFGAO_HIDDEN;

    psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidl, &_rgfAttrib);

    if (SUCCEEDED(psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, &str)) &&
        SUCCEEDED(StrRetToBuf(&str, pidl, szDisplayName, ARRAYSIZE(szDisplayName))))
    {
        SetDisplayName(szDisplayName);
        fRet = TRUE;
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\channel.h ===
#ifndef _CHANNEL_H
#define _CHANNEL_H


void Channel_UpdateQlinks();

HRESULT Channel_GetFolder(LPTSTR pszPath, int cchPath);
LPITEMIDLIST Channel_GetFolderPidl();
HRESULT ChannelBand_CreateInstance(IUnknown** ppunk);
HRESULT Channels_OpenBrowser(IWebBrowser2 **ppwb, BOOL fInPlace);


#endif

BOOL GetFirstUrl(TCHAR szURL[], DWORD cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\augisf.cpp ===
#include "priv.h"
#include "sccls.h"
#include "iface.h"
#include "augisf.h"
#include "menuisf.h"

//=================================================================
// Implementation of an IShellFolder that wraps a collection of
// other IShellFolders.  We call this an augmented IShellFolder
// object.
//
//=================================================================

// The CAugmentedISF wraps all the pidls so it can identify which pidl
// belongs to which IShellFolder object.

typedef struct tagIDWRAP
{
    // Real pidl goes on the end
    
    UINT   nID;         // Refers to a specific IShellFolder object
    UINT   cbOriginal;  // the original size of the pidl.  we need this because we dword align the pidl before wrapping it
} IDWRAP, * PIDWRAP;

#define IDWrap_GetWrap(pidl)            ((PIDWRAP)(((LPBYTE)pidl) + (pidl)->mkid.cb - SIZEOF(IDWRAP)))
#define IDWrap_GetID(pidl)              (IDWrap_GetWrap(pidl)->nID)
#define IDWrap_GetOriginalSize(pidl)    (IDWrap_GetWrap(pidl)->cbOriginal)

/*----------------------------------------------------------
    The CAugmentedISF object holds an array of CISFElems, each of which
    refers to an IShellFolder which will be enumerated.
*/
class CISFElem
{
public:
    CISFElem *      Clone(void);
    HRESULT         AcquireEnumerator(DWORD dwFlags);
    IShellFolder *  GetPSF()                { return _psf; };
    IEnumIDList *   GetEnumerator()         { return _pei; };
    void            GetNameSpaceID(GUID * rguid);
    HRESULT         SetPidl(LPCITEMIDLIST pidl);
    LPCITEMIDLIST   GetPidl()               { return _pidl; };
    DWORD           GetFlags()              { return _dwFlags; };
    void            SetRegister(UINT uReg)  { _uRegister = uReg; };
    UINT            GetRegister()           { return _uRegister; };

    CISFElem(const GUID * pguid, IShellFolder * psf, DWORD dwFlags);
    ~CISFElem();

protected:

    GUID           _guid;       // Unique ID
    IShellFolder * _psf;
    IEnumIDList *  _pei;        // Used by CAugSIFEnum only
    LPITEMIDLIST   _pidl;
    DWORD          _dwFlags;
    UINT           _uRegister;

    friend BOOL IsValidPCISFElem(CISFElem * pel);
};

//
// CAugmentedISF enumerator
//
class CAugISFEnum : public IEnumIDList
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef) () ;
    STDMETHOD_(ULONG,Release) ();

    // *** IEnumIDList methods ***
    STDMETHOD(Next)  (ULONG celt,
                      LPITEMIDLIST *rgelt,
                      ULONG *pceltFetched);
    STDMETHOD(Skip)  (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (IEnumIDList **ppenum);

    // Other methods
    HRESULT     Init(HDPA hdpaISF, DWORD dwEnumFlags);
        
    CAugISFEnum();
    ~CAugISFEnum();

protected:
    IEnumIDList *   _GetObjectEnumerator(int nID);

    UINT    _cRef;
    int     _iCurISF;       // current item in _hdpaISF
    HDPA    _hdpaISF;
};

/*----------------------------------------------------------
    Pidl wrapping routine
*/
LPITEMIDLIST AugISF_WrapPidl( LPCITEMIDLIST pidl, int nID )
{
    LPITEMIDLIST pidlRet = NULL;

    // get the size of the pidl
    // round up to dword align.  
    UINT cbPidlSize = (pidl->mkid.cb + 3) & ~3; 
    
    ASSERT(cbPidlSize >= pidl->mkid.cb);
    UINT cbSize = SIZEOF(IDWRAP) + cbPidlSize + SIZEOF(DWORD); // pidl plus terminator
    LPBYTE p = (LPBYTE)SHAlloc(cbSize);
    if (p)
    {
        ZeroMemory(p, cbSize); 
        memcpy(p, pidl, pidl->mkid.cb);

        IDWRAP* pidw = (IDWRAP*) (p + cbPidlSize);
        pidw->nID = nID;
        pidw->cbOriginal = pidl->mkid.cb;
                           
        // now make the cb be the whole pidl (not including the final null)
        pidlRet = (LPITEMIDLIST)p;
        pidlRet->mkid.cb = (USHORT) (cbPidlSize + SIZEOF(IDWRAP));
    }
    return pidlRet;
}    

// GetIDListWrapCount and GetNameSpaceCount are not used anywhere
#if 0
/*----------------------------------------------------------
Purpose: IAugmentedShellFolder2::GetIDListWrapCount
*/
STDMETHODIMP CAugmentedISF::GetNameSpaceCount( OUT LONG* pcNamespaces )
{
    if( NULL == pcNamespaces )
        return E_INVALIDARG ;

    *pcNamespaces = (NULL != _hdpa) ? DPA_GetPtrCount( _hdpa ) : 0 ;
    return S_OK ;
}

/*----------------------------------------------------------
Purpose: IAugmentedShellFolder2::GetIDListWrapCount
*/
STDMETHODIMP CAugmentedISF::GetIDListWrapCount( 
    LPCITEMIDLIST pidlWrap, 
    OUT LONG * pcPidls )
{
    if( NULL == pidlWrap || NULL == pcPidls )   
        return E_INVALIDARG ;

    PIDWRAP pWrap = IDWrap_GetWrap(pidlWrap) ;
    *pcPidls = 0 ;

    if( NULL != _hdpa && 
        DPA_GetPtrCount( _hdpa ) > (int)pWrap->nID && 
        pWrap->cbOriginal < pidlWrap->mkid.cb + sizeof(IDWRAP) )
        *pcPidls = 1 ;

    return S_OK ;
}
#endif
/*----------------------------------------------------------
Purpose: IAugmentedShellFolder2::UnWrapIDList
*/
STDMETHODIMP CAugmentedISF::UnWrapIDList( 
    LPCITEMIDLIST pidl, 
    LONG cPidls, 
    IShellFolder ** ppsf, 
    LPITEMIDLIST * ppidlFolder, 
    LPITEMIDLIST * ppidl, 
    LONG * pcFetched )
{
    HRESULT hres = E_INVALIDARG;

    ASSERT(IS_VALID_PIDL(pidl));

    if( pcFetched )
        *pcFetched = 0 ;
    
    if (pidl)
    {
        UINT nId = IDWrap_GetID(pidl);
        CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, nId);

        if (pel)
        {
            LPITEMIDLIST pidlNew = ILClone(GetNativePidl(pidl, nId));
            LPITEMIDLIST pidlFolderNew = ILClone(pel->GetPidl());

            if (pidlNew && pidlFolderNew)
            {
                if ( ppsf )
                {
                    *ppsf = pel->GetPSF();
                    (*ppsf)->AddRef();
                }

                *ppidl = pidlNew;
                *ppidlFolder = pidlFolderNew;
                
                if( pcFetched ) 
                    *pcFetched = 1 ;
                
                hres = (cPidls == 1) ? S_OK : S_FALSE ;
            }
            else
            {
                ILFree(pidlNew);
                ILFree(pidlFolderNew);
                hres = E_OUTOFMEMORY;
            }
        }
        else
            hres = E_FAIL;
    }

    return hres;
}

/*----------------------------------------------------------
    Purpose: CAugmentedISF::TranslatePidl
*/
LPITEMIDLIST CAugmentedISF::TranslatePidl( LPCITEMIDLIST pidlNS, LPCITEMIDLIST pidl, LPARAM nID )
{
    LPITEMIDLIST pidlRet = NULL;

    // Is this not empty and an immediate child?
    if (ILIsParent(pidlNS, pidl, TRUE))
    {
        LPCITEMIDLIST pidlChild;
        LPITEMIDLIST pidlNew;
        TCHAR szFullName[MAX_PATH];
        LPITEMIDLIST pidlFull = NULL;

        // HACKHACK (lamadio): You cannot use SHGetRealIDL for augisf encapsulated
        // IShellFolders. This routine QIs for INeedRealShellFolder, which IAugISF 
        // doesnot forward. The fstree code does not handle aggregation, so this 
        // cannot be forwarded anyway. This code can be cleaned up when we rewrite 
        // the fstree stuff... Sep.4.1997

        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szFullName, SIZECHARS(szFullName), NULL))
        && (pidlFull = ILCreateFromPath(szFullName)) != NULL)
        {
            pidlChild = ILFindLastID(pidlFull);
            pidlNew = ILClone(pidlFull);
        }
        else
        {
            pidlChild = ILFindLastID(pidl);
            pidlNew = ILClone(pidl);
        }

        // Yes; create a new full pidl where the last element is wrapped

        if (pidlNew)
        {
            ILRemoveLastID(pidlNew);

            LPITEMIDLIST pidlWrap = AugISF_WrapPidl( pidlChild, (int)nID );
            if (pidlWrap)
            {
                pidlRet = ILCombine(pidlNew, pidlWrap);
                ILFree(pidlWrap);
            }
            ILFree(pidlNew);
        }

        ILFree(pidlFull);   //Checks for a NULL pidl
    }
    else
        pidlRet = (LPITEMIDLIST)pidl;

    return pidlRet;
}    

/*----------------------------------------------------------
    Purpose: CAugmentedISF::GetNativePidl
    Clones and returns a copy of the native ('source') pidl 
    contained in the specified wrap.
*/
LPITEMIDLIST CAugmentedISF::GetNativePidl(LPCITEMIDLIST pidl, LPARAM lParam /*int nID*/ )
{
    ASSERT(IS_VALID_PIDL(pidl));
    UNREFERENCED_PARAMETER( lParam ) ; // only one source ID in the wrap!

    LPITEMIDLIST pidlNew = ILClone(pidl);

    if (pidlNew)
    {
        // Take off our trailing wrap signature
        pidlNew->mkid.cb = IDWrap_GetOriginalSize(pidl);

        ASSERT(sizeof(IDWRAP) >= sizeof(USHORT));

        USHORT * pu = (USHORT *)_ILNext(pidlNew);
        *pu = 0;
    }
    return pidlNew;
}    




CISFElem::CISFElem(const GUID * pguid, IShellFolder * psf, DWORD dwFlags) : _dwFlags(dwFlags)
{
    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(NULL == pguid || IS_VALID_READ_PTR(pguid, GUID));

    if (pguid)
        CopyMemory(&_guid, pguid, sizeof(_guid));

    _psf = psf;
    _psf->AddRef();
}    

CISFElem::~CISFElem()
{
    ASSERT(IS_VALID_CODE_PTR(_psf, IShellFolder));
    
    _psf->Release();

    if (_pei)
        _pei->Release();

    Pidl_Set(&_pidl, NULL);
}   

CISFElem * CISFElem::Clone(void)
{
    CISFElem * pelem = new CISFElem(&_guid, _psf, _dwFlags);

    if (pelem)
    {
        // If this fails, we're punting and going ahead anyway
        pelem->SetPidl(_pidl);      
    }

    return pelem;
}     


void CISFElem::GetNameSpaceID(GUID * pguid)
{
    ASSERT(IS_VALID_WRITE_PTR(pguid, GUID));
    CopyMemory(pguid, &_guid, sizeof(_guid));
}    


HRESULT CISFElem::SetPidl(LPCITEMIDLIST pidl)
{
    HRESULT hres = S_OK;

    Pidl_Set(&_pidl, pidl);

    if (pidl && NULL == _pidl)
        hres = E_OUTOFMEMORY;

    return hres;
}

/*----------------------------------------------------------
Purpose: Gets an enumerator for the IShellFolder and caches it.

*/
HRESULT CISFElem::AcquireEnumerator(DWORD dwFlags)
{
    return IShellFolder_EnumObjects(_psf, NULL, dwFlags, &_pei);
}    


//
// CAugmentedISF object
//


#undef SUPERCLASS


#ifdef DEBUG

BOOL IsValidPCISFElem(CISFElem * pel)
{
    return (IS_VALID_WRITE_PTR(pel, CISFElem) &&
            IS_VALID_CODE_PTR(pel->_psf, IShellFolder) &&
            (NULL == pel->_pidl || IS_VALID_PIDL(pel->_pidl)));
}   
 
#endif

// Constructor
CAugmentedISF::CAugmentedISF() : 
    _cRef(1)
{
    DllAddRef();
}


/*----------------------------------------------------------
Purpose: Callback to destroy each element

*/
int CISFElem_DestroyCB(LPVOID pv, LPVOID pvData)
{
    CISFElem * pel = (CISFElem *)pv;

    ASSERT(NULL == pel || IS_VALID_STRUCT_PTR(pel, CISFElem));

    if (pel)
        delete pel;

    return TRUE;
}   


/*----------------------------------------------------------
Purpose: Callback to set the owner of each element

*/
int CISFElem_SetOwnerCB(LPVOID pv, LPVOID pvData)
{
    CISFElem * pel = (CISFElem *)pv;

    ASSERT(IS_VALID_STRUCT_PTR(pel, CISFElem));

    IShellFolder * psf = pel->GetPSF();
    if (psf)
    {
        IUnknown_SetOwner(psf, (IUnknown *)pvData);
        // don't need to release psf
    }

    return TRUE;
}   


typedef struct {
    HRESULT hres;
    HWND hwnd;
    const IID * piid;
    void ** ppvObj;
} CVODATA;

    
/*----------------------------------------------------------
Purpose: Callback to call CreateViewObject

*/
int CISFElem_CreateViewObjectCB(LPVOID pv, LPVOID pvData)
{
    CISFElem * pel = (CISFElem *)pv;
    CVODATA * pdata = (CVODATA *)pvData;

    ASSERT(IS_VALID_STRUCT_PTR(pel, CISFElem));
    ASSERT(IS_VALID_WRITE_PTR(pdata, CVODATA));

    IShellFolder * psf = pel->GetPSF();
    if (psf)
    {
        pdata->hres = psf->CreateViewObject(pdata->hwnd, *(pdata->piid), pdata->ppvObj);
        if (SUCCEEDED(pdata->hres))
            return FALSE;       // stop on first success
            
        // don't need to release psf
    }

    return TRUE;
}   



// Destructor
CAugmentedISF::~CAugmentedISF()
{
    SetOwner(NULL);

    DPA_DestroyCallback(_hdpa, CISFElem_DestroyCB, NULL);
    _hdpa = NULL;

    DllRelease();
}


STDMETHODIMP_(ULONG) CAugmentedISF::AddRef()
{
    _cRef++;
    return _cRef;
}


STDMETHODIMP_(ULONG) CAugmentedISF::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0) 
        return _cRef;

    delete this;
    return 0;
}


STDMETHODIMP CAugmentedISF::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAugmentedISF, IShellFolder),
        QITABENT(CAugmentedISF, IAugmentedShellFolder),
        QITABENT(CAugmentedISF, IAugmentedShellFolder2),
        QITABENT(CAugmentedISF, IShellService),
        QITABENT(CAugmentedISF, ITranslateShellChangeNotify),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}


/*----------------------------------------------------------
Purpose: IShellService::SetOwner method

*/
STDMETHODIMP CAugmentedISF::SetOwner(IUnknown* punk)
{
    HRESULT hres = S_OK;

    ASSERT(NULL == punk || IS_VALID_CODE_PTR(punk, IUnknown));

    if (_hdpa && _punkOwner)
        DPA_EnumCallback(_hdpa, CISFElem_SetOwnerCB, NULL);
        
    ATOMICRELEASE(_punkOwner);
    
    if (punk) 
    {
        hres = punk->QueryInterface(IID_IUnknown, (LPVOID *)&_punkOwner);
        
        if (_hdpa)
            DPA_EnumCallback(_hdpa, CISFElem_SetOwnerCB, (void *)_punkOwner);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::EnumObjects method

*/
STDMETHODIMP CAugmentedISF::EnumObjects(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList)
{
    HRESULT hres = E_FAIL;

    if (_hdpa)
    {
        *ppenumIDList = new CAugISFEnum();

        if (*ppenumIDList)
        {
            hres = ((CAugISFEnum *)(*ppenumIDList))->Init(_hdpa, grfFlags);

            if (FAILED(hres))
            {
                delete *ppenumIDList;
                *ppenumIDList = NULL;
            }
        }
        else
            hres = E_OUTOFMEMORY;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::BindToObject method

*/
STDMETHODIMP CAugmentedISF::BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                REFIID riid, LPVOID * ppvOut)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_WRITE_PTR(ppvOut, LPVOID));

    *ppvOut = NULL;

    UINT id = IDWrap_GetID(pidl);
    IShellFolder * psf = _GetObjectPSF(id);

    if (psf)
    {
        LPITEMIDLIST pidlReal = GetNativePidl(pidl, id);

        if (pidlReal)
        {
            hres = psf->BindToObject(pidlReal, pbcReserved, riid, ppvOut);
            ILFree(pidlReal);
        }
        else
            hres = E_OUTOFMEMORY;

        psf->Release();
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::BindToStorage method

*/
STDMETHODIMP CAugmentedISF::BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvObj)
{
    TraceMsg(TF_WARNING, "Called unimplemented CAugmentedISF::BindToStorage");
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IShellFolder::CompareIDs method

*/
STDMETHODIMP CAugmentedISF::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = 0;
    int nID1 = IDWrap_GetID(pidl1);
    int nID2 = IDWrap_GetID(pidl2);

    if (nID1 == nID2)
    {
        IShellFolder * psf = _GetObjectPSF(nID1);
        if (psf)
        {
            LPITEMIDLIST pidlReal1 = GetNativePidl(pidl1, nID1);

            if (pidlReal1)
            {
                LPITEMIDLIST pidlReal2 = GetNativePidl(pidl2, nID2);
                if (pidlReal2)
                {
                    hres = psf->CompareIDs(lParam, pidlReal1, pidlReal2);
                    ILFree(pidlReal2);
                }
                ILFree(pidlReal1);
            }
            psf->Release();
        }
    }
    else
    {
        //In this situation, we want to see if one of these items wants to be sorted
        // below the other. 
        CISFElem * pel1 = (CISFElem *)DPA_GetPtr(_hdpa, nID1);
        CISFElem * pel2 = (CISFElem *)DPA_GetPtr(_hdpa, nID2);
        DWORD dwel1 = 0;
        DWORD dwel2 = 0;

        if (pel1)
            dwel1 = pel1->GetFlags();

        if (pel2)
            dwel2 = pel2->GetFlags();

        // if both want their items sorted below the other, punt and do neither.
        if ((dwel1 & ASFF_SORTDOWN) ^ (dwel2 & ASFF_SORTDOWN))
            hres = ResultFromShort((dwel1 & ASFF_SORTDOWN)? 1 : -1);
        else
            hres = (nID1 - nID2);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::CreateViewObject method

*/
STDMETHODIMP CAugmentedISF::CreateViewObject (HWND hwndOwner, REFIID riid, LPVOID * ppvOut)
{
    HRESULT hres = E_FAIL;

    if (_hdpa)
    {
        CVODATA cvodata;

        cvodata.hres = E_FAIL;
        cvodata.hwnd = hwndOwner;
        cvodata.piid = &riid;
        cvodata.ppvObj = ppvOut;
        
        // Whoever responds first wins
        DPA_EnumCallback(_hdpa, CISFElem_CreateViewObjectCB, (void *)&cvodata);

        hres = cvodata.hres;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::GetAttributesOf method

*/
STDMETHODIMP CAugmentedISF::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                                   ULONG * pfInOut)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_READ_PTR(apidl, LPCITEMIDLIST));
    ASSERT(IS_VALID_WRITE_PTR(pfInOut, ULONG));

    ULONG fInOut = *pfInOut;
    *pfInOut &= 0;

    // We only handle one pidl
    if (1 == cidl && apidl)
    {
        UINT id = IDWrap_GetID(*apidl);
        IShellFolder * psf = _GetObjectPSF(id);

        if (psf)
        {
            LPITEMIDLIST pidlReal = GetNativePidl(*apidl, id);

            if (pidlReal)
            {
                hres = psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlReal, &fInOut);
                *pfInOut = fInOut;
                ILFree(pidlReal);
            }
            else
                hres = E_OUTOFMEMORY;

            psf->Release();
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::GetUIObjectOf method

*/
STDMETHODIMP CAugmentedISF::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, LPVOID * ppvOut)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_READ_PTR(apidl, LPCITEMIDLIST));

    *ppvOut = NULL;

    // We only handle one pidl
    if (1 == cidl && apidl)
    {
        UINT id = IDWrap_GetID(*apidl);
        IShellFolder * psf = _GetObjectPSF(id);

        if (psf)
        {
            LPITEMIDLIST pidlReal = GetNativePidl(*apidl, id);

            if (pidlReal)
            {
                hres = psf->GetUIObjectOf(hwndOwner, 1, (LPCITEMIDLIST *)&pidlReal, riid, prgfInOut, ppvOut);
                ILFree(pidlReal);
            }
            else
                hres = E_OUTOFMEMORY;

            psf->Release();
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::GetDisplayNameOf method

*/
STDMETHODIMP CAugmentedISF::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, 
                                             LPSTRRET pstrret)
{
    HRESULT hres = E_FAIL;

    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_WRITE_PTR(pstrret, STRRET));

    if (pidl) 
    {
        UINT id = IDWrap_GetID(pidl);
        IShellFolder * psf = _GetObjectPSF(id);

        if (psf)
        {
            LPITEMIDLIST pidlReal = GetNativePidl(pidl, id);

            if (pidlReal)
            {
                hres = psf->GetDisplayNameOf(pidlReal, uFlags, pstrret);
                ILFree(pidlReal);
            }
            else
                hres = E_OUTOFMEMORY;

            psf->Release();
        }
        else
            hres = E_FAIL;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::SetNameOf method

*/
STDMETHODIMP CAugmentedISF::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                             LPCOLESTR lpszName, DWORD uFlags,
                             LPITEMIDLIST * ppidlOut)
{
    HRESULT hres = E_FAIL;

    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));
    if (pidl) 
    {
        UINT id = IDWrap_GetID(pidl);
        IShellFolder * psf = _GetObjectPSF(id);

        if (psf)
        {
            LPITEMIDLIST pidlReal = GetNativePidl(pidl, id);

            if (pidlReal)
            {
                LPITEMIDLIST pidlOut = NULL;
                hres = psf->SetNameOf(hwndOwner, pidlReal,
                             lpszName, uFlags,
                             &pidlOut);

                // Do they want a pidl back?
                if (SUCCEEDED(hres) && ppidlOut)
                {
                    *ppidlOut = AugISF_WrapPidl( pidlOut, id );

                    if (!*ppidlOut)
                        hres = E_OUTOFMEMORY;
                }

                ILFree(pidlOut);
                ILFree(pidlReal);
            }
            else
                hres = E_OUTOFMEMORY;

            psf->Release();
        }
        else
            hres = E_FAIL;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::ParseDisplayName method

*/
STDMETHODIMP CAugmentedISF::ParseDisplayName(HWND hwndOwner,
        LPBC pbcReserved, LPOLESTR lpszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    TraceMsg(TF_WARNING, "Called unimplemented CAugmentedISF::ParseDisplayNameOf");
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IAugmentedShellFolder::AddNameSpace 

*/
STDMETHODIMP CAugmentedISF::AddNameSpace(const GUID * pguid, 
                                         IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags)
{
    HRESULT hres = E_INVALIDARG;

    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(NULL == pguid || IS_VALID_READ_PTR(pguid, GUID));
    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));

    if (NULL == _hdpa)
    {
        _hdpa = DPA_Create(4);
    }

    if (psf && _hdpa)
    {
        hres = S_OK;        // Assume success

        CISFElem * pel = new CISFElem(pguid, psf, dwFlags);
        if (pel)
        {
            hres = pel->SetPidl(pidl);
            if (SUCCEEDED(hres))
            {
                if (DPA_ERR == DPA_AppendPtr(_hdpa, pel))
                    hres = E_OUTOFMEMORY;
            }

            if (FAILED(hres))
                delete pel;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    return hres;
}    


/*----------------------------------------------------------
Purpose: IAugmentedShellFolder::GetNameSpaceID 

*/
STDMETHODIMP CAugmentedISF::GetNameSpaceID(LPCITEMIDLIST pidl, GUID * pguidOut)
{
    HRESULT hres = E_INVALIDARG;

    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_WRITE_PTR(pguidOut, GUID));

    if (pidl && pguidOut)
    {
        UINT id = IDWrap_GetID(pidl);

        hres = E_FAIL;

        if (_hdpa)
        {
            CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, id);
            if (pel)
            {
                pel->GetNameSpaceID(pguidOut);
                hres = S_OK;
            }
        }
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: IAugmentedShellFolder::QueryNameSpace

*/
STDMETHODIMP CAugmentedISF::QueryNameSpace(DWORD dwID, GUID * pguidOut, 
                                           IShellFolder ** ppsf)
{
    HRESULT hres = E_FAIL;

    ASSERT(NULL == pguidOut || IS_VALID_WRITE_PTR(pguidOut, GUID));
    ASSERT(NULL == ppsf || IS_VALID_WRITE_PTR(ppsf, IShellFolder));

    if (_hdpa)
    {
        CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, dwID);
        if (pel)
        {
            if (ppsf)
            {
                IShellFolder * psf = pel->GetPSF();
                psf->AddRef();
                *ppsf = psf;
            }

            if (pguidOut)
                pel->GetNameSpaceID(pguidOut);

            hres = S_OK;
        }
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: IAugmentedShellFolder::EnumNameSpace 

*/
STDMETHODIMP CAugmentedISF::EnumNameSpace(DWORD uNameSpace, DWORD * pdwID)
{
    HRESULT hres = E_FAIL;

    if (_hdpa)
    {
        DWORD celem = DPA_GetPtrCount(_hdpa);

        if (-1 == uNameSpace)
            hres = celem;
        else
        {
            if (uNameSpace >= celem)
                hres = E_FAIL;
            else
            {
                // For now, simply use the index given
                *pdwID = uNameSpace;
                hres = S_OK;
            }
        }
    }

    return hres;
}    



/*----------------------------------------------------------
    Purpose: ITranslateShellChangeNotify::TranslateIDs 
*/
STDMETHODIMP CAugmentedISF::TranslateIDs(LONG *plEvent, 
                                LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
                                LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
                                LPITEMIDLIST *ppidlOut2Event2)
{
    HRESULT hres = S_OK;

    *plEvent2 = (LONG)-1;

    *ppidlOut1Event2 = NULL;
    *ppidlOut2Event2 = NULL;


    *ppidlOut1 = (LPITEMIDLIST)pidl1;
    *ppidlOut2 = (LPITEMIDLIST)pidl2;

    if (_hdpa)
    {
        int cElem = DPA_GetPtrCount(_hdpa);
        int i;

        // Go thru all the namespaces and find which one should 
        // translate this notification
        for (i = 0; i < cElem; i++)
        {
            CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpa, i);
            if (pel)
            {
                LPCITEMIDLIST pidlNS = pel->GetPidl();

                if (pidlNS)
                {
                    if (pidl1)
                    {
                        *ppidlOut1 = TranslatePidl(pidlNS, pidl1, i);
                        if (NULL == *ppidlOut1)
                            hres = E_OUTOFMEMORY;
                    }

                    if (SUCCEEDED(hres) && pidl2)
                    {
                        *ppidlOut2 = TranslatePidl(pidlNS, pidl2, i);
                        if (NULL == *ppidlOut2)
                            hres = E_OUTOFMEMORY;
                    }

                    if (FAILED(hres))
                    {
                        if (*ppidlOut1 != pidl1)
                            Pidl_Set(ppidlOut1, NULL);

                        if (*ppidlOut2 != pidl2)
                            Pidl_Set(ppidlOut2, NULL);
                        break;
                    }
                    else
                    {
                        if (*ppidlOut1 != pidl1 || *ppidlOut2 != pidl2)
                            break;
                    }
                }
            }
        }
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: ITranslateShellChangeNotify::IsChildID
*/
STDMETHODIMP CAugmentedISF::IsChildID(LPCITEMIDLIST pidlKid, BOOL fImmediate)
{
    HRESULT hres = S_FALSE;
    //At this point we should have a translated pidl
    if (pidlKid)
    {
        // Weirdness: If fImmediate is TRUE, then this is a Wrapped pidl. If it's
        // false, then it's not, and we need to check to see if it's a Real FS Child.
        if (fImmediate)
        {
            LPCITEMIDLIST pidlRelKid = ILFindLastID(pidlKid);
            if (pidlRelKid)
            {
                int nID = IDWrap_GetID(pidlRelKid);
                CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, nID);
                if (pel && pel->GetPidl())
                {
                
                    if (ILIsParent(pel->GetPidl(), pidlKid, TRUE))
                        hres = S_OK;
                }
            }
        }
        else
        {
            int cElem = DPA_GetPtrCount(_hdpa);
            int i;

            for (i = 0; i < cElem; i++)
            {
                CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, i);
                if (pel && pel->GetPidl())
                {
                    if (ILIsParent(pel->GetPidl(), pidlKid, FALSE))
                    {
                        hres = S_OK;
                        break;
                    }
                }
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: ITranslateShellChangeNotify::IsEqualID

*/
STDMETHODIMP CAugmentedISF::IsEqualID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int cElem = DPA_GetPtrCount(_hdpa);
    int i;

    for (i = 0; i < cElem; i++)
    {
        CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpa, i);

        if (pel)
        {
            if (pidl1)
            {
                if (ILIsEqual(pel->GetPidl(),pidl1))
                    return S_OK;
            }
            else if (pidl2)
            {
                if (ILIsParent(pidl2, pel->GetPidl(), FALSE))
                    return S_OK;
            }
        }
    }

    return S_FALSE;
}

/*----------------------------------------------------------
Purpose: ITranslateShellChangeNotify::Register
    Registers all pidls contained to the passed in window

*/
STDMETHODIMP CAugmentedISF::Register(HWND hwnd, UINT uMsg, long lEvents)
{
    HRESULT hres = NOERROR;
    if (_hdpa)
    {
        int cElem = DPA_GetPtrCount(_hdpa);
        int i;

        for (i = 0; i < cElem; i++)
        {
            CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpa, i);

            // Has this namespace been registered yet?
            if (pel && 0 == pel->GetRegister())
            {
                // No; register it
                LPCITEMIDLIST pidlNS = pel->GetPidl();

                if (pidlNS)
                {
                    pel->SetRegister(RegisterNotify(hwnd, uMsg, pidlNS, lEvents,
                                                    SHCNRF_ShellLevel | SHCNRF_InterruptLevel, TRUE));
                }
            }
        }
    }
    else
        hres = E_FAIL;

    return hres;

}

/*----------------------------------------------------------
Purpose: ITranslateShellChangeNotify::Unregister

*/
STDMETHODIMP CAugmentedISF::Unregister()
{
    HRESULT hres = NOERROR;
    if (_hdpa)
    {
        int cElem = DPA_GetPtrCount(_hdpa);
        int i;

        for (i = 0; i < cElem; i++)
        {
            CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpa, i);
            UINT uReg;
            if (pel && (uReg = pel->GetRegister()) != 0)
            {
                // SHChangeNotifyDeregister will flush messages
                // which will send a notify which will come back here...
                pel->SetRegister(0);
                SHChangeNotifyDeregister(uReg);
            }
        }
    }
    else
        hres = E_FAIL;

    return hres;

}

/*----------------------------------------------------------
Purpose: Returns the psf associated with the ID.

*/
IShellFolder * CAugmentedISF::_GetObjectPSF(int nID)
{
    IShellFolder * psf = NULL;

    if (_hdpa)
    {
        CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, nID);
        if (pel)
        {
            psf = pel->GetPSF();
            ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));

            psf->AddRef();
        }
    }
    return psf;
}    



//
//  CAugISF Enumerator object
//

#undef SUPERCLASS


// Constructor
CAugISFEnum::CAugISFEnum() :
   _cRef(1)
{
}


// Destructor
CAugISFEnum::~CAugISFEnum()
{
    if (_hdpaISF)
    {
        DPA_DestroyCallback(_hdpaISF, CISFElem_DestroyCB, NULL);
        _hdpaISF = NULL;
    }
}


HRESULT CAugISFEnum::Init(HDPA hdpaISF, DWORD dwEnumFlags)
{
    HRESULT hres = S_OK;

    ASSERT(IS_VALID_HANDLE(hdpaISF, DPA));

    // Clone the DPA
    _hdpaISF = DPA_Clone(hdpaISF, NULL);
    if (_hdpaISF)
    {
        // Clone the elements too
        int cElem = DPA_GetPtrCount(_hdpaISF);
        int i;

        // If something fails in the loop, at least try to enumerate 
        // other namespaces.
        for (i = 0; i < cElem; i++)
        {
            CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpaISF, i);
            if (pel)
            {
                CISFElem * pelNew = pel->Clone();
                if (pelNew)
                {
                    // Get the enumerator
                    if (SUCCEEDED(pelNew->AcquireEnumerator(dwEnumFlags)))
                        DPA_SetPtr(_hdpaISF, i, pelNew);
                    else
                    {
                        TraceMsg(TF_WARNING, "CAugISFEnum::Init.  Namespace %d has no enumerator.", i);

                        // Remove it from the list to enumerate, and continue
                        DPA_DeletePtr(_hdpaISF, i);
                        cElem--;
                        i--;
                        delete pelNew;
                    }
                }
            }
        }
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}    


STDMETHODIMP CAugISFEnum::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAugISFEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}


STDMETHODIMP_(ULONG) CAugISFEnum::AddRef()
{
    return ++_cRef;
}


STDMETHODIMP_(ULONG) CAugISFEnum::Release()
{
    if (--_cRef > 0) {
        return _cRef;
    }

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IEnumIDList::Next method

         This will call the current enumerator for the next
         object.  The object's pidl is wrapped in an IDWRAP
         (which is stamped with the identifier of the specific
         IShellFolder the object belongs to) and handed back.
         
         If the current enumerator has no more items to return,
         this function will call the next enumerator for its
         first item, and returns that.  The subsequent call 
         will pick up from there.

*/
STDMETHODIMP CAugISFEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    ULONG celtFetched = 0;
    HRESULT hres = S_FALSE;

    if (celt > 0)
    {
        IEnumIDList * pei = _GetObjectEnumerator(_iCurISF);
        if (pei)
        {
            LPITEMIDLIST pidl;

            hres = pei->Next(1, &pidl, &celtFetched);

            if (SUCCEEDED(hres))
            {
                // End of enumeration for this object?
                if (S_FALSE == hres)
                {
                    // Yes; go to next ISF object
                    _iCurISF++;
                    hres = Next(celt, rgelt, &celtFetched);
                }
                else
                {
                    // No; now wrap the pidl.  
                    rgelt[0] = AugISF_WrapPidl( pidl, _iCurISF );
                    if (rgelt[0]) 
                    {
                        celtFetched = 1;
                        hres = S_OK;
                    } 
                    else 
                        hres = E_OUTOFMEMORY;

                    ILFree(pidl);
                }
            }

            pei->Release();
        }
    }
    
    if (pceltFetched) 
        *pceltFetched = celtFetched;

    return hres;
}


STDMETHODIMP CAugISFEnum::Skip(ULONG celt)
{
    return E_NOTIMPL;
}


STDMETHODIMP CAugISFEnum::Reset()
{
    if (_hdpaISF)
    {
        // Reset all the enumerators
        int cel = DPA_GetPtrCount(_hdpaISF);
        int i;

        for (i = 0; i < cel; i++)
        {
            CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpaISF, i);
            if (pel)
            {
                IEnumIDList * pei = pel->GetEnumerator();
                if (pei)
                {
                    pei->Reset();
                    // Don't Release b/c GetEnumerator doesn't AddRef
                }
            }
        }
    }

    _iCurISF = 0;

    return S_OK;
}


STDMETHODIMP CAugISFEnum::Clone(IEnumIDList **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: Returns the enumerator associated with the ID.

*/
IEnumIDList * CAugISFEnum::_GetObjectEnumerator(int nID)
{
    IEnumIDList * pei = NULL;

    if (_hdpaISF)
    {
        CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpaISF, nID);
        if (pel)
        {
            pei = pel->GetEnumerator();
            ASSERT(IS_VALID_CODE_PTR(pei, IEnumIDList));

            pei->AddRef();
        }
    }
    return pei;
}    


/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
STDAPI CAugmentedISF_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres;
    CAugmentedISF* pObj;

    hres = E_OUTOFMEMORY;

    pObj = new CAugmentedISF();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IShellFolder *);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\dpastuff.cpp ===
#include "priv.h"

#include "..\inc\dpastuff.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\iaccess.h ===
#ifndef _IAccessible_h
#define _IAccessible_h

#include "oleacc.h"
#include "mnbase.h"
#include "menuband.h"

#define CHILDID_SELF 0

#define MB_STATE_TRACK 1
#define MB_STATE_MENU  2
#define MB_STATE_ITEM  4

#define TOOLBAR_MASK 0x80000000

// BUGBUG (lamadio): The designers of the Accessibility interface did not know
// the rule about COM identity. They allow a QI for the external object IEnumVariant

class CAccessible : public IAccessible, public IEnumVARIANT, public IOleWindow
{
    int             _cRef;
    // IDispatch Support
    ITypeInfo*      _pTypeInfo;
    BOOL            _LoadTypeLib();


    // Track menu popup Support
    IAccessible*    _pInnerAcc;
    HWND            _hwndMenuWindow;
    HMENU           _hMenu;
    WORD            _wID;

    // Menuband Support
    CMenuToolbarBase* _pmtbBottom;
    CMenuToolbarBase* _pmtbTop;
    IShellMenuAcc*    _psma;
    IMenuBand*        _pmb;

    // Menuband Item Support
    CMenuToolbarBase*  _pmtbItem;

    int               _iAccIndex;
    int               _iIndex;  
    int               _iEnumIndex;
    int               _idCmd;


    // Object info
    BITBOOL         _fInitialized: 1;
    BITBOOL         _fState: 3;

    HRESULT _GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild);
    HRESULT _GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* iIndex);
    HRESULT _GetAccessibleItem(int iIndex, IDispatch** ppdisp);
    HRESULT _GetAccName(BSTR* pbstr);
    HRESULT _Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);


public:
    CAccessible(HMENU, WORD);
    CAccessible(IMenuBand*);
    CAccessible(IMenuBand*, int iIndex);
    virtual ~CAccessible();
    HRESULT InitAcc();

    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR* pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
        LCID lcid, DISPID FAR* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
        UINT FAR* puArgErr);


    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);


    // *** IAccessible methods ***
    virtual STDMETHODIMP get_accParent(IDispatch * FAR* ppdispParent);
    virtual STDMETHODIMP get_accChildCount(long FAR* pChildCount);
    virtual STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch * FAR* ppdispChild);

    virtual STDMETHODIMP get_accName(VARIANT varChild, BSTR* pszName);
    virtual STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pszValue);
    virtual STDMETHODIMP get_accDescription(VARIANT varChild, BSTR FAR* pszDescription);
    virtual STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    virtual STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);

    
    virtual STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pszHelp);
    virtual STDMETHODIMP get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
    virtual STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);

    virtual STDMETHODIMP get_accFocus(VARIANT FAR * pvarFocusChild);

    virtual STDMETHODIMP get_accSelection(VARIANT FAR * pvarSelectedChildren);
    
    virtual STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

    virtual STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);

    virtual STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);

    virtual STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    virtual STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);

    virtual STDMETHODIMP accDoDefaultAction(VARIANT varChild);

    virtual STDMETHODIMP put_accName(VARIANT varChild, BSTR szName);
    virtual STDMETHODIMP put_accValue(VARIANT varChild, BSTR pszValue);


    // *** IEnumVARIANT methods ***
    virtual STDMETHODIMP Next(unsigned long celt, 
                            VARIANT FAR* rgvar, 
                            unsigned long FAR* pceltFetched); 
    virtual STDMETHODIMP Skip(unsigned long celt); 
    virtual STDMETHODIMP Reset(); 
    virtual STDMETHODIMP Clone(IEnumVARIANT FAR* FAR* ppenum); 
};

extern "C"
{
    LRESULT LresultFromObject(REFIID riid, WPARAM wParam, IUnknown*);
    void WINAPI NotifyWinEvent(DWORD event, HWND hwnd,
        LONG idObject, LONG idChild);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\augmisf.h ===
//-------------------------------------------------------------------------//
//  
//  AugMisf.h  - Augmented Merge IShellFolder class declaration.
//
//-------------------------------------------------------------------------//

#ifndef __AUGMISF_H__
#define __AUGMISF_H__

class CAugISFEnumItem
{
public:
    CAugISFEnumItem()   {};
    BOOL Init(IShellFolder* psf, int iShellFolder, LPCITEMIDLIST pidl);
    BOOL InitWithWrappedToOwn(IShellFolder* psf, int iShellFolder, LPITEMIDLIST pidl);

    ~CAugISFEnumItem()
    {
        Str_SetPtr(&_pszDisplayName, NULL);
        ILFree(_pidlWrap);
    }
    void SetDisplayName(LPTSTR pszDispName)
    {
        Str_SetPtr(&_pszDisplayName, pszDispName);
    }
    ULONG          _rgfAttrib;
    LPTSTR         _pszDisplayName;
    LPITEMIDLIST   _pidlWrap;
};


//  Forwards:
//-------------//
class CNamespace ;
STDAPI CAugmentedISF2_CreateInstance( IUnknown*, IUnknown**, LPCOBJECTINFO );  

class IAugmentedMergedShellFolderInternal : public IUnknown
{
public:
    STDMETHOD(GetPidl)(THIS_ int* /*in|out*/ piPos, DWORD grfEnumFlags, LPITEMIDLIST* ppidl) PURE;
};

//-------------------------------------------------------------------------//
//  Supports hierarchically merged shell namespaces
class CAugmentedMergeISF : public IAugmentedShellFolder2,
                           public IShellFolder2,
                           public IShellService,
                           public ITranslateShellChangeNotify,
                           public IDropTarget,
                           public IAugmentedMergedShellFolderInternal
//-------------------------------------------------------------------------//
{
public:
    // *** IUnknown methods ***
    STDMETHOD ( QueryInterface )    ( REFIID, void ** ) ;
    STDMETHOD_( ULONG, AddRef )     ( ) ;
    STDMETHOD_( ULONG, Release )    ( ) ;
    
    // *** IShellFolder methods ***
    STDMETHOD( BindToObject )       ( LPCITEMIDLIST, LPBC, REFIID, LPVOID * ) ;
    STDMETHOD( BindToStorage )      ( LPCITEMIDLIST, LPBC, REFIID, LPVOID * ) ;
    STDMETHOD( CompareIDs )         ( LPARAM, LPCITEMIDLIST, LPCITEMIDLIST) ;
    STDMETHOD( CreateViewObject )   ( HWND, REFIID, LPVOID * ) ;
    STDMETHOD( EnumObjects )        ( HWND, DWORD, LPENUMIDLIST * ) ;
    STDMETHOD( GetAttributesOf )    ( UINT, LPCITEMIDLIST * , ULONG * ) ;
    STDMETHOD( GetDisplayNameOf )   ( LPCITEMIDLIST , DWORD , LPSTRRET ) ;
    STDMETHOD( GetUIObjectOf )      ( HWND, UINT, LPCITEMIDLIST *, REFIID, UINT *, LPVOID * ) ;
    STDMETHOD( ParseDisplayName )   ( HWND, LPBC, LPOLESTR, ULONG *, LPITEMIDLIST *, ULONG * ) ;
    STDMETHOD( SetNameOf )          ( HWND, LPCITEMIDLIST, LPCOLESTR, DWORD, LPITEMIDLIST *) ;

    // *** IShellFolder2 methods ***
    // stub implementation to indicate we support CompareIDs() for identity
    STDMETHOD( GetDefaultSearchGUID)( LPGUID ) { return E_NOTIMPL; }
    STDMETHOD( EnumSearches )       ( LPENUMEXTRASEARCH *pe) { *pe = NULL; return E_NOTIMPL; }
    STDMETHOD(GetDefaultColumn)(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) { return E_NOTIMPL; };
    STDMETHOD(GetDefaultColumnState)(UINT iColumn, DWORD *pbState) { return E_NOTIMPL; };
    STDMETHOD(GetDetailsEx)(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) { return E_NOTIMPL; };
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails){ return E_NOTIMPL; };
    STDMETHOD(MapColumnToSCID)(UINT iCol, SHCOLUMNID *pscid) { return E_NOTIMPL; };

    // *** IAugmentedShellFolder methods ***
    STDMETHOD( AddNameSpace )       ( const GUID * pguidObject, IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags ) ;
    STDMETHOD( GetNameSpaceID )     ( LPCITEMIDLIST pidl, GUID * pguidOut ) ;
    STDMETHOD( QueryNameSpace )     ( DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf ) ;
    STDMETHOD( EnumNameSpace )      ( DWORD cNameSpaces, DWORD * pdwID ) ;

    // *** IAugmentedShellFolder2 methods ***
    // not used anywhere
    //STDMETHOD( GetNameSpaceCount )  ( OUT LONG* pcNamespaces ) ;
    //STDMETHOD( GetIDListWrapCount)  ( LPCITEMIDLIST pidlWrap, OUT LONG * pcPidls) ;
    STDMETHOD( UnWrapIDList)        ( LPCITEMIDLIST pidlWrap, LONG cPidls, IShellFolder** apsf, LPITEMIDLIST* apidlFolder, LPITEMIDLIST* apidlItems, LONG* pcFetched ) ;

    // *** IShellService methods ***
    STDMETHOD( SetOwner )           ( IUnknown * punkOwner ) ;

    // *** ITranslateShellChangeNotify methods ***
    STDMETHOD( TranslateIDs )       ( LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                      LONG *plEvent2, LPITEMIDLIST * ppidlOut1Event2, LPITEMIDLIST * ppidlOut2Event2);
    STDMETHOD( IsChildID )          ( LPCITEMIDLIST pidlKid, BOOL fImmediate );
    STDMETHOD( IsEqualID )          ( LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2 );
    STDMETHOD( Register )           ( HWND hwnd, UINT uMsg, long lEvents );
    STDMETHOD( Unregister )         ( void );

    // *** IDropTarget methods ***
    STDMETHOD(DragEnter)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)(void);
    STDMETHOD(Drop)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IAugmentedMergedShellFolderInternal ***
    STDMETHODIMP GetPidl(int* piPos, DWORD grfEnumFlags, LPITEMIDLIST* ppidl);

//  Construction, Destruction
protected:
    CAugmentedMergeISF() ;
    virtual ~CAugmentedMergeISF() ;

//  Miscellaneous helpers
protected:
    STDMETHOD( QueryNameSpace )     ( DWORD dwID, OUT PVOID* ppvNameSpace ) ;
    
    //  pidl crackers
    STDMETHOD_( LPITEMIDLIST, GetNativePidl )( LPCITEMIDLIST pidl, LPARAM lParam /*int nID*/) ;

    BOOL     _IsCommonPidl(LPCITEMIDLIST pidlItem);

    HRESULT _SearchForPidl(IShellFolder* psf, LPCITEMIDLIST pidl, BOOL fFolder, int* piIndex, CAugISFEnumItem** ppEnumItem);
    HRESULT  _GetNamespaces(LPCITEMIDLIST pidlWrap, CNamespace** ppnsCommon, UINT* pnCommonID,
                                                    CNamespace** ppnsUser, UINT* pnUserID,
                                                    LPITEMIDLIST* ppidl, BOOL *pbIsFolder);
    HRESULT  _GetContextMenu(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, 
                                        UINT * prgfInOut, LPVOID* ppvOut);
    BOOL     _AffectAllUsers();
    //  namespace utility methods
    STDMETHOD( GetDefNamespace )    ( LPCITEMIDLIST pidl, ULONG, OUT IShellFolder** ppsf, OUT LPITEMIDLIST* ppv) ;
    STDMETHOD( GetDefNamespace )    ( ULONG dwAttrib, OUT PVOID* ppv, OUT UINT *pnID, OUT PVOID* ppv0) ;
    CNamespace* Namespace( int iNamespace ) ;
    int         NamespaceCount() const ;
    void        FreeNamespaces() ;

    int                 AcquireObjects() ;
    void                FreeObjects() ;
    static int CALLBACK DestroyObjectsProc( LPVOID pv, LPVOID pvData ) ;
    friend int CALLBACK AugMISFSearchForWrappedPidl(LPVOID p1, LPVOID p2, LPARAM lParam);
    BOOL IsChildIDInternal(LPCITEMIDLIST pidl, BOOL fImmediate, int* iShellFolder);

#ifdef DEBUG
    void DumpObjects();
#endif
    
//  Callback routines
private:
    static      int SetOwnerProc( LPVOID, LPVOID ) ;
    static      int DestroyNamespacesProc(LPVOID pv, LPVOID pvData) ;

//  Data
protected:
    HDPA          _hdpaNamespaces ;     // source namespace collection
    LPUNKNOWN     _punkOwner ;          // owner object
    LONG          _cRef;                // reference count.
    IDropTarget*  _pdt;
    HWND          _hwnd;
    BITBOOL       _fCommon : 1;         // is _pdt a common programs folder (or its child)
#ifdef DEBUG
    BITBOOL       _fInternalGDNO:1 ;
#endif
    HDPA          _hdpaObjects;
    int           _count;
    DWORD         _grfDragEnterKeyState;
    DWORD         _dwDragEnterEffect;

    friend HRESULT CAugmentedISF2_CreateInstance( IUnknown*, IUnknown**, LPCOBJECTINFO );  
} ;

//-------------------------------------------------------------------------//
//  inline implementation 
inline int CAugmentedMergeISF::NamespaceCount() const {
    return _hdpaNamespaces ? DPA_GetPtrCount( _hdpaNamespaces ) : 0 ;
}
inline CNamespace* CAugmentedMergeISF::Namespace( int iNamespace )  {
    return _hdpaNamespaces ? 
        (CNamespace*)DPA_GetPtr( _hdpaNamespaces, iNamespace ) : NULL ;
}

//-------------------------------------------------------------------------//
//  CAugmentedMergeISF enumerator object.
class CEnum : public IEnumIDList
//-------------------------------------------------------------------------//
{
//  Public interface methods
public:
    // *** IUnknown methods ***
    STDMETHOD ( QueryInterface ) (REFIID, void ** ) ;
    STDMETHOD_( ULONG,AddRef )  () ;
    STDMETHOD_( ULONG,Release ) () ;

    // *** IEnumIDList methods ***
    STDMETHOD( Next )  (ULONG, LPITEMIDLIST*, ULONG* ) ;
    STDMETHOD( Skip )  (ULONG) ;
    STDMETHOD( Reset ) ();
    STDMETHOD( Clone ) (IEnumIDList** ) ;

// Construction, destruction, assignment:
public:
    CEnum(IAugmentedMergedShellFolderInternal* psmsfi, DWORD grfEnumFlags, int iPos = 0);
    ~CEnum() ;

    //  Miscellaneous methods, data
protected:
    IAugmentedMergedShellFolderInternal* _psmsfi;

    DWORD _grfEnumFlags;
    int _cRef;
    int _iPos;
} ;



#endif __AUGMISF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\channel.cpp ===
#include "priv.h"
#include <varutil.h>

#ifdef ENABLE_CHANNELS
#include "channel.h"
#include "bands.h"
#include "isfband.h"
#include "itbar.h"
#include "qlink.h"
#define WANT_CBANDSITE_CLASS
#include "bandsite.h"
#include "resource.h"
#include "deskbar.h"
#include "dpastuff.h"

#include "dbapp.h"
#include "chanbar.h"

#include "subsmgr.h"
#include "chanmgr.h"
#include "chanmgrp.h"

#include "mluisupp.h"

void FrameTrack(HDC hdc, LPRECT prc, UINT uFlags);

HRESULT Channel_GetFolder(LPTSTR pszPath, int cchPath)
{
    TCHAR szChannel[MAX_PATH];
    TCHAR szFav[MAX_PATH];
    ULONG cbChannel = sizeof(szChannel);
    
    if (SHGetSpecialFolderPath(NULL, szFav, CSIDL_FAVORITES, TRUE))
    {
        //
        // Get the potentially localized name of the Channel folder from the
        // registry if it is there.  Otherwise just read it from the resource.
        // Then tack this on the favorites path.
        //

        if (ERROR_SUCCESS != SHRegGetUSValue(L"Software\\Microsoft\\Windows\\CurrentVersion",
                                             L"ChannelFolderName", NULL, (void*)szChannel,
                                             &cbChannel, TRUE, NULL, 0))
        {
            MLLoadString(IDS_CHANNEL, szChannel, ARRAYSIZE(szChannel));
        }

        PathCombine(pszPath, szFav, szChannel);

        //
        // For IE5+ use the channels dir if it exists - else use favorites
        //
        if (!PathFileExists(pszPath))
            StrCpyN(pszPath, szFav, cchPath);

        return S_OK;
    }    
    
    return E_FAIL;
}

LPITEMIDLIST Channel_GetFolderPidl()
{
    LPITEMIDLIST pidl = NULL;
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(Channel_GetFolder(szPath, ARRAYSIZE(szPath))))
    {
        pidl = ILCreateFromPath(szPath);
        if (!pidl && CreateDirectory(szPath, NULL)) {
            pidl = ILCreateFromPath(szPath);
        }
    }
    return pidl;
}



HRESULT ChannelBand_CreateInstance(IUnknown** ppunk)
{
    *ppunk = NULL;
    
    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidl = Channel_GetFolderPidl();
    if (pidl)
    {
        IFolderBandPriv *pfbp;
        hr = CISFBand_CreateEx(NULL, pidl, IID_PPV_ARG(IFolderBandPriv, &pfbp));
        if (SUCCEEDED(hr))
        {
            hr = pfbp->SetCascade(TRUE);
            if (SUCCEEDED(hr))
            {
                hr = pfbp->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
            }
            pfbp->Release();
        }
        ILFree(pidl);
    }

    return hr;
}

//
// Navigates the left browser pane to the channels directory.
//
void NavigateBrowserBarToChannels(IWebBrowser2* pwb)
{
    ASSERT(pwb);

    IChannelMgrPriv* pIChannelMgrPriv;

    if (SUCCEEDED(CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IChannelMgrPriv, (void**)&pIChannelMgrPriv)))
    {
        ASSERT(pIChannelMgrPriv);

        LPITEMIDLIST pidl;

        if (SUCCEEDED(pIChannelMgrPriv->GetChannelFolder(&pidl, IChannelMgrPriv::CF_CHANNEL)))
        {
            ASSERT(pidl);

            VARIANT varPath;

            if (SUCCEEDED(InitVariantFromIDList(&varPath, pidl)))
            {
                VARIANT varFlags;

                varFlags.vt   = VT_I4;
                varFlags.lVal = navBrowserBar;

                pwb->Navigate2(&varPath, &varFlags, PVAREMPTY, PVAREMPTY, PVAREMPTY);

                VariantClear(&varPath);
            }

            ILFree(pidl);
        }

        pIChannelMgrPriv->Release();
    }

    return;
}


STDAPI NavigateToPIDL(IWebBrowser2* pwb, LPCITEMIDLIST pidl)
{
    ASSERT(pwb);
    ASSERT(pidl);

    VARIANT varThePidl;
    HRESULT hr = InitVariantFromIDList(&varThePidl, pidl);
    if (SUCCEEDED(hr))
    {
        hr = pwb->Navigate2(&varThePidl, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);
        VariantClear(&varThePidl);       // Needed to free the copy of the PIDL in varThePidl.
    }
    return hr;
}

//
// Implements the IE4 channel quick launch shell control file functionality.
// This gets called from shdoc401 on pre-NT5 platforms and from shell32 on
// Nt5 or greater.
//
HRESULT Channel_QuickLaunch(void)
{
    IWebBrowser2* pIWebBrowser2;

    HRESULT hr = Channels_OpenBrowser(&pIWebBrowser2, FALSE);
    if (SUCCEEDED(hr))
    {
        ASSERT(pIWebBrowser2);

        NavigateBrowserBarToChannels(pIWebBrowser2);

        LPITEMIDLIST pidl;
        TCHAR szURL[MAX_URL_STRING] = TEXT("");

        GetFirstUrl(szURL, SIZEOF(szURL));

        if (szURL[0])
        {
            hr = IECreateFromPath(szURL, &pidl);

            if (SUCCEEDED(hr))
            {
                ASSERT(pidl);

                hr = NavigateToPIDL(pIWebBrowser2, pidl);

                ILFree(pidl);
            }
        }
        else
        {
            hr = E_FAIL;
        }

        pIWebBrowser2->Release();
    }

    return hr;
}



/////////////////////////////////////
////// Browser only channel band support


// the CProxyWin95Desktop class implements an OleWindow 
// to represent the win95 desktop
// the browseronly channel band will use this as its host


class CProxyWin95Desktop : 
   public IOleWindow
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    CProxyWin95Desktop(HWND hwnd);
    
protected:
    
    UINT _cRef;
    HWND _hwnd;
};

CProxyWin95Desktop::CProxyWin95Desktop(HWND hwnd) : _cRef(1), _hwnd(hwnd)
{
}

ULONG CProxyWin95Desktop::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CProxyWin95Desktop::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CProxyWin95Desktop::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IOleWindow) ||
        IsEqualIID(riid, SID_SShellDesktop)  // private hack for deskbar.cpp
       ) {
        *ppvObj = SAFECAST(this, IOleWindow*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

HRESULT CProxyWin95Desktop::GetWindow(HWND * lphwnd) 
{
    *lphwnd = _hwnd; 
    if (_hwnd)
        return S_OK; 
    return E_FAIL;
}

void Channels_InitState(IUnknown* punkBar)
{
    // initialize properties
    CDeskBarPropertyBag* ppb = new CDeskBarPropertyBag();
    if (ppb) {
        // Get the default rc
        CISSTRUCT cis;
        DWORD     cbSize = sizeof(CISSTRUCT);
        RECT     *prc = &cis.rc;

        cis.iVer = 1;  // set version number to 1
        SystemParametersInfoA(SPI_GETWORKAREA, 0, prc, 0);
        prc->bottom = min(prc->bottom - 20, prc->top + 12*38 + 28); // 12 icons + caption

        if(IS_BIDI_LOCALIZED_SYSTEM())
        {
            prc->right = prc->left + 90;
            OffsetRect(prc, 20, 10);
        }
        else
        {
            prc->left = prc->right - 90;
            OffsetRect(prc, -20, 10);
        }

        // query registry for persisted state
        SHRegGetUSValue(SZ_REGKEY_CHANBAR, SZ_REGVALUE_CHANBAR, NULL, 
                        (LPVOID)&cis, &cbSize, FALSE, (LPVOID)&cis, cbSize);

        // set ppb by prc
        ppb->SetDataDWORD(PROPDATA_MODE, WBM_FLOATING | WBMF_BROWSER);
        ppb->SetDataDWORD(PROPDATA_X, prc->left);
        ppb->SetDataDWORD(PROPDATA_Y, prc->top);
        ppb->SetDataDWORD(PROPDATA_CX, RECTWIDTH(*prc));
        ppb->SetDataDWORD(PROPDATA_CY, RECTHEIGHT(*prc));
        SHLoadFromPropertyBag(punkBar, ppb);
        ppb->Release();
    }
}

void Channels_MainLoop(IDockingWindow *pdw)
{
    MSG msg;
    HWND hwnd;
    // loop while the window exists
    do {
        GetMessage(&msg, NULL, 0, 0);
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        pdw->GetWindow(&hwnd);
    } while (hwnd);
}

void Channels_SetBandInfoSFB(IUnknown* punkBand)
{
    BANDINFOSFB bi;

    // Set band startup conditions
    bi.dwMask = ISFB_MASK_STATE | ISFB_MASK_VIEWMODE;
    bi.dwStateMask = ISFB_STATE_CHANNELBAR | ISFB_STATE_NOSHOWTEXT;
    bi.dwState = ISFB_STATE_CHANNELBAR | ISFB_STATE_NOSHOWTEXT;
    bi.wViewMode = ISFBVIEWMODE_LOGOS;

    IUnknown_SetBandInfoSFB(punkBand, &bi);
}

// from isfband.cpp
extern IDeskBand * ChannelBand_Create( LPCITEMIDLIST pidl );

// this does the desktop channel in browser only mode
void DesktopChannel()
{
    _InitComCtl32();

    // Don't show channel bar:
    //      *. in integrated mode with active desktop turned on, or
    //      *. NoChannelUI restriction is set, or
    //      *. there is already one on desktop
    
    if (SHRestricted2(REST_NoChannelUI, NULL, 0))
        return;
        
    if (WhichPlatform() == PLATFORM_INTEGRATED) {
        SHELLSTATE  ss = { 0 };

        SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE); // Get the setting
        if (ss.fDesktopHTML) {
            return;
        }
    }
        
    if (FindWindowEx(GetShellWindow(), NULL, TEXT("BaseBar"), TEXT("ChanApp")) ||
        FindWindowEx(NULL, NULL, TEXT("BaseBar"), TEXT("ChanApp"))) // can be a toplevel window
        return;

    LPITEMIDLIST pidl = Channel_GetFolderPidl();
    if (pidl) {
        IUnknown* punk = (IUnknown *) ChannelBand_Create( pidl );
        if (punk) {

            Channels_SetBandInfoSFB(punk);

            IUnknown* punkBar;
            IUnknown* punkBandSite;

            HRESULT hres = ChannelDeskBarApp_Create(&punkBar, &punkBandSite);
            if (SUCCEEDED(hres)) {
                CProxyWin95Desktop* pow = new CProxyWin95Desktop(GetShellWindow());
                if (pow) {
                    IBandSite* pbs;
                    IDockingWindow* pdw;

                    Channels_InitState(punkBar);

                    // these are always our own guys, so these QI's MUST succeed if the creation succeeded
                    punkBandSite->QueryInterface(IID_IBandSite, (LPVOID*)&pbs);
                    punkBar->QueryInterface(IID_IDockingWindow, (LPVOID*)&pdw);
                    ASSERT(pbs && pdw);

                    hres = pbs->AddBand(punk);
                    IUnknown_SetSite(pdw, (IOleWindow*)pow);

                    pbs->SetBandState((DWORD)-1, BSSF_NOTITLE, BSSF_NOTITLE);

                    pdw->ShowDW(TRUE);

                    Channels_MainLoop(pdw);

                    pdw->Release();
                    pbs->Release();
                    pow->Release();
                }
                punkBar->Release();
                punkBandSite->Release();
            }

            punk->Release();
        }
        ILFree(pidl);
    }
}

HRESULT Channels_OpenBrowser(IWebBrowser2 **ppwb, BOOL fInPlace)
{
    HRESULT hres;
    IWebBrowser2* pwb;

    if (fInPlace) {
        ASSERT(ppwb && *ppwb != NULL);
        pwb = *ppwb;
        hres = S_OK;
    }
    else {
#ifndef UNIX
        hres = CoCreateInstance(CLSID_InternetExplorer, NULL,
                                    CLSCTX_LOCAL_SERVER, IID_IWebBrowser2, (void **)&pwb);
#else
        hres = CoCreateInternetExplorer( IID_IWebBrowser2,
                                         CLSCTX_LOCAL_SERVER,
                                         (LPVOID*) &pwb );
#endif
    }
    
    if (SUCCEEDED(hres))
    {
        SA_BSTRGUID  strGuid;
        VARIANT      vaGuid;

        // Don't special case full-screen mode for channels post IE4.  Use the
        // browser's full screen setting.
        // 
        //BOOL fTheater = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Channels"),
        BOOL fTheater = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                                            TEXT("FullScreen"), FALSE, FALSE);
        pwb->put_TheaterMode( fTheater ? VARIANT_TRUE : VARIANT_FALSE);
        pwb->put_Visible(VARIANT_TRUE);


        if (!SHRestricted2(REST_NoChannelUI, NULL, 0))
        {
#ifdef ENABLE_CHANNELPANE
            StringFromGUID2(CLSID_ChannelBand, strGuid.wsz, ARRAYSIZE(strGuid.wsz));
#else
            StringFromGUID2(CLSID_FavBand, strGuid.wsz, ARRAYSIZE(strGuid.wsz));
#endif

            strGuid.cb = lstrlenW(strGuid.wsz) * SIZEOF(WCHAR);

            vaGuid.vt = VT_BSTR;
            vaGuid.bstrVal = strGuid.wsz;

            pwb->ShowBrowserBar(&vaGuid, PVAREMPTY, PVAREMPTY);
        }
        
        // don't release, we're going to return pwb.
    }
    
    if (ppwb)
        *ppwb = pwb;
    else if (pwb)
        pwb->Release();
    
    return hres;
}

BOOL GetFirstUrl(TCHAR szURL[], DWORD cb)
{
    //BOOL fFirst = FALSE;
    DWORD dwType;

    // Don't special case first channel click post IE4.
    /*if (SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), TEXT("ChannelsFirstURL"), 
            &dwType, szURL, &cb, FALSE, NULL, 0) == ERROR_SUCCESS) 
    {        
        HUSKEY hUSKey;
                
        if (SHRegOpenUSKey(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), KEY_WRITE, NULL, 
                &hUSKey, FALSE) == ERROR_SUCCESS)
        {
            SHRegDeleteUSValue(hUSKey, TEXT("ChannelsFirstURL"), SHREGDEL_HKCU);
            SHRegCloseUSKey(hUSKey);
        }
        fFirst = TRUE;
    } 
    else if (SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), TEXT("ChannelsURL"), 
        &dwType, szURL, &cb, FALSE, NULL, 0) == ERROR_SUCCESS)
    {
        // nothing
    }
    else
    {
        // BUGBUG if code is ever revived, this res:// needs to be
        // accessed through MLBuildResURLWrap because of pluggable UI
        szURL = lstrcpy(szURL, TEXT("res://ie4tour.dll/channels.htm"));
    }*/

    SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                    TEXT("ChannelsURL"), &dwType, szURL, &cb, FALSE, NULL, 0);
    return FALSE; 
}


//////////////////////////////////////////////////
//
// ChannelBand
//
// This is a special band that only looks at the channels folder.
// It overrides several functions from CISFBand.
//

#undef  SUPERCLASS
#define SUPERCLASS CISFBand

class ChannelBand : public SUPERCLASS
{
public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

protected:
    ChannelBand();
    friend IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidl);

    virtual HRESULT _LoadOrderStream();

    virtual HWND _CreatePager(HWND hwndParent);

    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW* pnmcd);

    virtual void _Dropped(int nIndex, BOOL fDroppedOnSource);
    virtual HRESULT _AfterLoad();
    virtual void _OnDragBegin(int iItem, DWORD dwPreferedEffect);
} ;


#define COLORBK     RGB(0,0,0)
ChannelBand::ChannelBand() :
    SUPERCLASS()
{
    _lEvents |= SHCNE_EXTENDED_EVENT;
    _dwStyle |= TBSTYLE_CUSTOMERASE;

    _crBkgnd = COLORBK;     // i see a channelband and i want to paint it black
    _fHaveBkColor = TRUE;
}

HWND ChannelBand::_CreatePager(HWND hwndParent)
{
    // we do want a pager for this band, so
    // override isfband's implementation w/ grandpa's
    return CSFToolbar::_CreatePager(hwndParent);
}

HRESULT ChannelBand::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IContextMenu))
        return E_NOINTERFACE;
    
    
    return SUPERCLASS::QueryInterface(riid, ppvObj);
}


IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidlDefault)
{
    ChannelBand * pBand = NULL;
    LPITEMIDLIST pidl = NULL;

    if (!pidlDefault)
    {
        pidl = Channel_GetFolderPidl();
        pidlDefault = pidl;
    }
    if (EVAL(pidlDefault))
    {
        pBand = new ChannelBand;

        if (pBand)
        {
            if (FAILED(pBand->InitializeSFB(NULL, pidlDefault)))
            {
                ATOMICRELEASE(pBand);
            }
        }

        ILFree(pidl);
    }

    return pBand;
}

HRESULT ChannelBand::_AfterLoad()
{
    HRESULT hres = SUPERCLASS::_AfterLoad();

    _LoadOrderStream();

    return hres;
}

HRESULT ChannelBand::_LoadOrderStream()
{
    OrderList_Destroy(&_hdpaOrder);

    COrderList_GetOrderList(&_hdpaOrder, _pidl, _psf);
    return S_OK;
}


HRESULT ChannelBand::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = E_FAIL;

    switch (lEvent)
    {
    case SHCNE_EXTENDED_EVENT:
    {
        SHChangeMenuAsIDList UNALIGNED * pdwidl = (SHChangeMenuAsIDList UNALIGNED *)pidl1;
        if ( pdwidl->dwItem1 == SHCNEE_ORDERCHANGED )
        {
            if (SHChangeMenuWasSentByMe(this, pidl1))
            {
                // We sent this order change, ignore it
                TraceMsg(TF_BAND, "ChannelBand::OnChange SHCNEE_ORDERCHANGED skipped (we're source)");
                hres = S_OK;
            }
            else if (EVAL(pidl2) && _pidl)
            {
                if (ILIsEqual(_pidl, pidl2))
                {
                    TraceMsg(TF_BAND, "ChannelBand::OnChange SHCNEE_ORDERCHANGED accepted");

                    _LoadOrderStream();

                    if (_fShow)
                        _FillToolbar();

                    hres = S_OK;
                }
            }
            break;
        }
        // if it wasn't SHCNEE_ORDERCHANGED, then drop through to pass to the base class..
    }

    default:
        hres = SUPERCLASS::OnChange(lEvent, pidl1, pidl2);
        break;
    }

    return hres;
}

HRESULT ChannelBand::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    if (_iDragSource >= 0)
    {
        return SUPERCLASS::OnDropDDT(pdt, pdtobj, pgrfKeyState, pt, pdwEffect);
    }
    else
    {
        // we don't call superclass in this case 'cuz we want to undo
        // it's "always use shortcut" override.
        //
        _fDropping = TRUE;
        return S_OK;
    }
}

LRESULT ChannelBand::_OnCustomDraw(NMCUSTOMDRAW* pnmcd)
{
    NMTBCUSTOMDRAW * ptbcd = (NMTBCUSTOMDRAW *)pnmcd;
    LRESULT lres;

    lres = SUPERCLASS::_OnCustomDraw(pnmcd);
        
    switch (pnmcd->dwDrawStage)
    {
    case CDDS_PREPAINT:
        lres |= CDRF_NOTIFYITEMDRAW;
        break;

    case CDDS_PREERASE:
        // Channel band has a darker background color
        {
            RECT rc;
            GetClientRect(_hwndTB, &rc);
            // BUGBUG perf: use SHFillRectClr not SetBk/ExtText/SetBk
            COLORREF old = SetBkColor(pnmcd->hdc, _crBkgnd);
            ExtTextOut(pnmcd->hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
            SetBkColor(pnmcd->hdc, old);
            lres = CDRF_SKIPDEFAULT;                
        }
        break;

    case CDDS_ITEMPREPAINT:
        // Channel band doesn't draw as buttons
        lres |= TBCDRF_NOEDGES | TBCDRF_NOOFFSET | TBCDRF_NOMARK |
                CDRF_NOTIFYPOSTPAINT;
        break;

    case CDDS_ITEMPOSTPAINT:
        // Channel band draws the hot item (CDIS_HOT)
        //
        
        pnmcd->rc.top++;
        pnmcd->rc.left++;
        if (pnmcd->uItemState & CDIS_SELECTED)
            // Mark the selected item 
            FrameTrack(pnmcd->hdc,  &(pnmcd->rc), TRACKNOCHILD);                           
        else if (pnmcd->uItemState & CDIS_HOT)
            // Mark the hot item 
            FrameTrack(pnmcd->hdc,  &(pnmcd->rc), TRACKHOT);                           
        break;

    }
    
    return lres;
}

void ChannelBand::_Dropped(int nIndex, BOOL fDroppedOnSource)
{
    ASSERT(_fDropping);

    // I'm not changing this to match the other derivatives (ISFBand, mnfolder, quick links),
    // because this structure is slightly different
    _fDropped = TRUE;

    // Persist the new order out to the registry
    if (SUCCEEDED(COrderList_SetOrderList(_hdpa, _pidl, _psf)))
    {
        // Notify everyone that the order changed
        SHSendChangeMenuNotify(this, SHCNEE_ORDERCHANGED, 0, _pidl);
    }
}

void ChannelBand::_OnDragBegin(int iItem, DWORD dwPreferedEffect)
{
    //
    // Don't allow drag if REST_NoRemovingChannels is enabled.
    //

    if (!SHRestricted2(REST_NoRemovingChannels, NULL, 0))
        SUPERCLASS::_OnDragBegin(iItem, dwPreferedEffect);

    return;
}




#endif // ENABLE_CHANNELS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\fadetsk.h ===
#ifndef _FADETSK_H
#define _FADETSK_H

#include <runtask.h>
extern const GUID TASKID_Fader;

#define FADE_BEGIN          0x00000001
#define FADE_END            0x00000002

typedef void (*PFNFADESCREENRECT)(DWORD dwFadeState, LPVOID pvParam); // Called after the Fade has begun

class CFadeTask : public CRunnableTask
{
public:
    // IRunnableTask methods (override)
    virtual STDMETHODIMP RunInitRT(void);

    CFadeTask();
    void _StopFade();
    BOOL FadeRect(PRECT prc, PFNFADESCREENRECT pfn, LPVOID pvParam);

private:
    virtual ~CFadeTask();

    HWND        _hwndFader;
    RECT        _rect;
    PFNFADESCREENRECT _pfn;
    LPVOID      _pvParam;
    HDC         _hdcFade;
    HBITMAP     _hbm;
    HBITMAP     _hbmOld;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\fadetsk.cpp ===
#include "priv.h"
#include "fadetsk.h"
#include "apithk.h"

/// Fade Rect Support
// {2DECD184-21B0-11d2-8385-00C04FD918D0}
const GUID TASKID_Fader = 
{ 0x2decd184, 0x21b0, 0x11d2, { 0x83, 0x85, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };

CFadeTask::CFadeTask() : CRunnableTask(RTF_DEFAULT)
{
    ASSERT(g_bRunOnNT5);    // This should only get created on NT5
    WNDCLASSEX wc = {0};

    if (!GetClassInfoEx(g_hinst, TEXT("SysFader"), &wc)) 
    {
        wc.cbSize          = sizeof(wc);
        wc.lpfnWndProc     = DefWindowProc;
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hInstance       = g_hinst;
        wc.lpszClassName   = TEXT("SysFader");
        wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;

        if (!RegisterClassEx(&wc))
           return;
    }

    _hwndFader = CreateWindowEx(WS_EX_LAYERED | WS_EX_TRANSPARENT | 
                            WS_EX_TOPMOST | WS_EX_TOOLWINDOW, 
                            TEXT("SysFader"), TEXT("SysFader"),
                            WS_POPUP,
                            0, 0, 0, 0, NULL, (HMENU) 0, 
                            g_hinst, NULL);
}

CFadeTask::~CFadeTask()
{
    if (_hwndFader)
        DestroyWindow(_hwndFader);
}

#define ALPHASTART (200)

BOOL CFadeTask::FadeRect(PRECT prc, PFNFADESCREENRECT pfn, LPVOID pvParam)
{
    if (IsRunning() == IRTIR_TASK_RUNNING)
        return FALSE;

    InterlockedExchange(&_lState, IRTIR_TASK_NOT_RUNNING);

    _rect = *prc;
    _pfn = pfn;
    _pvParam = pvParam;

    POINT   pt;
    POINT   ptSrc = {0, 0};
    SIZE    size;

    // prc and pt are in screen coordinates.
    pt.x = _rect.left;
    pt.y = _rect.top;

    // Get the size of the rectangle for the blits.
    size.cx = RECTWIDTH(_rect);
    size.cy = RECTHEIGHT(_rect);

    // Get the DC for the screen and window.
    HDC hdcScreen = GetDC(NULL);
    if (hdcScreen)
    {
        HDC hdcWin = GetDC(_hwndFader);
        if (hdcWin)
        {
            // If we don't have a HDC for the fade, then create one.
            if (!_hdcFade)
            {
                _hdcFade = CreateCompatibleDC(hdcScreen);
                if (!_hdcFade)
                    goto Stop;

                // Create a bitmap that covers the fade region, instead of the whole screen.
                _hbm = CreateCompatibleBitmap(hdcScreen, size.cx, size.cy);
                if (!_hbm)
                    goto Stop;

                // select it in, saving the old bitmap's handle
                _hbmOld = (HBITMAP)SelectBitmap(_hdcFade, _hbm);
            }

            // Get the stuff from the screen and squirt it into the fade dc.
            BitBlt(_hdcFade, 0, 0, size.cx, size.cy, hdcScreen, pt.x, pt.y, SRCCOPY);

            // Now let user do it's magic. We're going to mimic user and start with a slightly
            // faded, instead of opaque, rendering (Looks smoother and cleaner.
            BlendLayeredWindow(_hwndFader, hdcWin, &pt, &size, _hdcFade, &ptSrc, ALPHASTART);

            // Now that we have it all build up, display it on screen.
            SetWindowPos(_hwndFader, HWND_TOPMOST, 0, 0, 0, 0,
                SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
    Stop:
            ReleaseDC(_hwndFader, hdcWin);
        }

        ReleaseDC(NULL, hdcScreen);
    }

    if (_pfn)
        _pfn(FADE_BEGIN, _pvParam);

    return TRUE;
}



#define FADE_TIMER_ID 10
#define FADE_TIMER_TIMEOUT 10 // milliseconds
#define FADE_TIMEOUT 350 // milliseconds
#define FADE_ITERATIONS 35
#define QUAD_PART(a) ((a)##.QuadPart)

void CFadeTask::_StopFade()
{
    if (_hwndFader)
    {
        SetWindowPos(_hwndFader, HWND_BOTTOM, 0, 0, 0, 0,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
    }

    if (_pfn)
        _pfn(FADE_END, _pvParam);

    if (_hdcFade)
    {
        if (_hbmOld)
        {
            SelectBitmap(_hdcFade, _hbmOld);
        }
        DeleteDC(_hdcFade);
        _hdcFade = NULL;
    }
    
    if (_hbm)
    {
        DeleteObject(_hbm);
        _hbm = NULL;
    }
}
 
STDMETHODIMP CFadeTask::RunInitRT(void)
{
    BOOL    fRet = FALSE;
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liFreq;
    LARGE_INTEGER liStart;
    DWORD dwElapsed;
    BYTE bBlendConst;

    // Start the fade timer and the count-down for the fade.
    QueryPerformanceFrequency(&liFreq);
    QueryPerformanceCounter(&liStart);

    // Do this until the conditions specified in the loop.
    while ( TRUE )
    {
        // Calculate the elapsed time in milliseconds.
        QueryPerformanceCounter(&liDiff);
        QUAD_PART(liDiff) -= QUAD_PART(liStart);
        dwElapsed = (DWORD)((QUAD_PART(liDiff) * 1000) / QUAD_PART(liFreq));

        if (dwElapsed >= FADE_TIMEOUT) 
        {
            goto Stop;
        }

        bBlendConst = (BYTE)(ALPHASTART * (FADE_TIMEOUT - 
                dwElapsed) / FADE_TIMEOUT);

        if (bBlendConst <= 1) 
        {
            goto Stop;
        }

        // Since only the alpha is updated, there is no need to pass
        // anything but the new alpha function. This saves a source copy.
        BlendLayeredWindow(_hwndFader, NULL, NULL, NULL, NULL, NULL, bBlendConst);
        Sleep(FADE_TIMER_TIMEOUT);
    }

Stop:
    _StopFade();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\htmlbm.cpp ===
#include "priv.h"
#include "sccls.h"
#include "runtask.h"
#include "legacy.h"

#include <ntquery.h>    // defines some values used for fmtid and pid

#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }
DEFINE_SCID(SCID_WRITETIME,     PSGUID_STORAGE, PID_STG_WRITETIME);


class CThumbnail : public IThumbnail2, public CLogoBase
{
public:
    CThumbnail(void);

    // IUnknown
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);

    // IThumbnail
    STDMETHODIMP Init(HWND hwnd, UINT uMsg);
    STDMETHODIMP GetBitmap(LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight);

    // IThumbnail2
    STDMETHODIMP GetBitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight);

private:
    ~CThumbnail(void);

    LONG _cRef;
    HWND _hwnd;
    UINT _uMsg;
    IShellImageStore *_pImageStore;

    virtual IShellFolder * GetSF() {ASSERT(0);return NULL;};
    virtual HWND GetHWND() {ASSERT(0); return _hwnd;};

    HRESULT UpdateLogoCallback(DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache);
    REFTASKOWNERID GetTOID();

    BOOL _InCache(LPCWSTR pszItemPath, LPCWSTR pszGLocation, const FILETIME * pftDateStamp);
    HRESULT _BitmapFromIDList(LPCITEMIDLIST pidl, LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight);
    HRESULT _InitTaskCancelItems();
};


static const GUID TOID_Thumbnail = { 0xadec3450, 0xe907, 0x11d0, {0xa5, 0x7b, 0x00, 0xc0, 0x4f, 0xc2, 0xf7, 0x6a} };

HRESULT CDiskCacheTask_Create(CLogoBase * pView,
                               IShellImageStore *pImageStore,
                               LPCWSTR pszItem,
                               LPCWSTR pszGLocation,
                               DWORD dwItem,
                               IRunnableTask ** ppTask);
                               
class CDiskCacheTask : public CRunnableTask
{
public:
    CDiskCacheTask();

    STDMETHODIMP RunInitRT(void);

    friend HRESULT CDiskCacheTask_Create(CLogoBase * pView,
                           IShellImageStore *pImageStore,
                           LPCWSTR pszItem,
                           LPCWSTR pszGLocation,
                           DWORD dwItem,
                           const SIZE * prgSize,
                           IRunnableTask ** ppTask);

private:
    ~CDiskCacheTask();
    HRESULT PrepImage(HBITMAP * phBmp);
    
    IShellImageStore *_pImageStore;
    WCHAR _szItem[MAX_PATH];
    WCHAR _szGLocation[MAX_PATH];
    CLogoBase * _pView;
    DWORD _dwItem;
    SIZE m_rgSize;
};

// CreateInstance
HRESULT CThumbnail_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CThumbnail *pthumbnail = new CThumbnail();
    if (pthumbnail)
    {
        *ppunk = SAFECAST(pthumbnail, IThumbnail*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

// Constructor / Destructor
CThumbnail::CThumbnail(void) : _cRef(1)
{
    DllAddRef();
}

CThumbnail::~CThumbnail(void)
{
    if (_pTaskScheduler)
    {
        _pTaskScheduler->RemoveTasks(TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, FALSE);
        _pTaskScheduler->Release();
        _pTaskScheduler = NULL;
    }

    DllRelease();
}

HRESULT CThumbnail::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThumbnail, IThumbnail2), 
        QITABENTMULTI(CThumbnail, IThumbnail, IThumbnail2), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CThumbnail::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CThumbnail::Release(void)
{
    if (InterlockedDecrement(&_cRef) > 0)
        return _cRef;

    delete this;
    return 0;
}

// IThumbnail
HRESULT CThumbnail::Init(HWND hwnd, UINT uMsg)
{
    _hwnd = hwnd;
    _uMsg = uMsg;
    ASSERT(NULL == _pTaskScheduler);

    return S_OK;
}

HRESULT CThumbnail::_InitTaskCancelItems()
{
    if (!_pTaskScheduler)
    {
        if (SUCCEEDED(CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTaskScheduler, &_pTaskScheduler))))
        {
            // make sure RemoveTasks() actually kills old tasks even if they're not done yet
            _pTaskScheduler->Status(ITSSFLAG_KILL_ON_DESTROY, ITSS_THREAD_TIMEOUT_NO_CHANGE);
        }
    }

    if (_pTaskScheduler)
    {
        // Kill any old tasks in the scheduler.
        _pTaskScheduler->RemoveTasks(TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, FALSE);
    }
    return _pTaskScheduler ? S_OK : E_FAIL;
}

HRESULT CThumbnail::_BitmapFromIDList(LPCITEMIDLIST pidl, LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    LPCITEMIDLIST pidlLast;
    IShellFolder *psf;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        IExtractImage *pei;
        hr = psf->GetUIObjectOf(NULL, 1, &pidlLast, IID_PPV_ARG_NULL(IExtractImage, &pei));
        if (SUCCEEDED(hr))
        {
            DWORD dwPriority;
            DWORD dwFlags = IEIFLAG_ASYNC | IEIFLAG_SCREEN | IEIFLAG_OFFLINE;
            SIZEL rgSize = {lWidth, lHeight};

            WCHAR szBufferW[MAX_PATH];
            hr = pei->GetLocation(szBufferW, ARRAYSIZE(szBufferW), &dwPriority, &rgSize, SHGetCurColorRes(), &dwFlags);
            if (SUCCEEDED(hr))
            {
                if (S_OK == hr)
                {
                    HBITMAP hBitmap;
                    hr = pei->Extract(&hBitmap);
                    if (SUCCEEDED(hr))
                    {
                        hr = UpdateLogoCallback(dwItem, 0, hBitmap, NULL, TRUE);
                    }
                }
                else
                    hr = E_FAIL;
            }
            else if (E_PENDING == hr)
            {
                WCHAR szPath[MAX_PATH];

                if (NULL == pszFile)
                {
                    DisplayNameOf(psf, pidlLast, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath));
                    pszFile = szPath;
                }

                // now get the date stamp and check the disk cache....
                FILETIME ftImageTimeStamp;
                BOOL fNoDateStamp = TRUE;
                // try it in the background...

                // od they support date stamps....
                IExtractImage2 *pei2;
                if (SUCCEEDED(pei->QueryInterface(IID_PPV_ARG(IExtractImage2, &pei2))))
                {
                    if (SUCCEEDED(pei2->GetDateStamp(&ftImageTimeStamp)))
                    {
                        fNoDateStamp = FALSE;   // we have a date stamp..
                    }
                    pei2->Release();
                }
                else
                {
                    IShellFolder2 *psf2;
                    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
                    {
                        if (SUCCEEDED(GetDateProperty(psf2, pidlLast, &SCID_WRITETIME, &ftImageTimeStamp)))
                        {
                            fNoDateStamp = FALSE;   // we have a date stamp..
                        }
                        psf2->Release();
                    }
                }

                // if it is in the cache, and it is an uptodate image, then fetch from disk....
                // if the timestamps are wrong, then the extract code further down will then try

                // we only test the cache on NT5 because the templates are old on other platforms and 
                // thus the image will be the wrong size...
                IRunnableTask *prt;
                if (IsOS(OS_WIN2000ORGREATER) && _InCache(pszFile, szBufferW, (fNoDateStamp ? NULL : &ftImageTimeStamp)))
                {
                    hr = CDiskCacheTask_Create(this, _pImageStore, pszFile, szBufferW, dwItem, &rgSize, &prt);
                    if (SUCCEEDED(hr))
                    {
                        // let go of the image store, so the task has the only ref and the lock..
                        ATOMICRELEASE(_pImageStore);
                    }
                }
                else
                {
                    // Cannot hold the prt which is returned in a member variable since that
                    // would be a circular reference
                    hr = CExtractImageTask_Create(this, pei, L"", dwItem, -1, EITF_SAVEBITMAP | EITF_ALWAYSCALL, &prt);
                }
            
                if (SUCCEEDED(hr))
                {
                    // Add the task to the scheduler.
                    hr = _pTaskScheduler->AddTask(prt, TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, dwPriority);
                    prt->Release();
                }
            }
            
            pei->Release();
        }
        psf->Release();
    }
    
    ATOMICRELEASE(_pImageStore);
    return hr;
}

STDMETHODIMP CThumbnail::GetBitmap(LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    HRESULT hr = _InitTaskCancelItems();

    if (pszFile)
    {
        LPITEMIDLIST pidl = ILCreateFromPathW(pszFile);
        if (pidl)
        {
            hr = _BitmapFromIDList(pidl, pszFile, dwItem, lWidth, lHeight);
            ILFree(pidl);
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

// IThumbnail2

STDMETHODIMP CThumbnail::GetBitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    HRESULT hr = _InitTaskCancelItems();
    if (pidl)
    {
        hr = _BitmapFromIDList(pidl, NULL, dwItem, lWidth, lHeight);
    }
    return hr;
}


// private stuff
HRESULT CThumbnail::UpdateLogoCallback(DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache)
{
    if (!PostMessage(_hwnd, _uMsg, dwItem, (LPARAM)hImage))
    {
        DeleteObject(hImage);
    }

    return S_OK;
}

REFTASKOWNERID CThumbnail::GetTOID()    
{ 
    return TOID_Thumbnail;
}

BOOL CThumbnail::_InCache(LPCWSTR pszItemPath, LPCWSTR pszGLocation, const FILETIME * pftDateStamp)
{
    BOOL fRes = FALSE;

    HRESULT hr;
    if (_pImageStore)
        hr = S_OK;
    else
    {
        // init the cache only once, assume all items from same folder!
        WCHAR szName[MAX_PATH];
        StrCpyNW(szName, pszItemPath, ARRAYSIZE(szName));
        PathRemoveFileSpecW(szName);
        hr = LoadFromFile(CLSID_ShellThumbnailDiskCache, szName, IID_PPV_ARG(IShellImageStore, &_pImageStore));
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwStoreLock;
        hr = _pImageStore->Open(STGM_READ, &dwStoreLock);
        if (SUCCEEDED(hr))
        {
            FILETIME ftCacheDateStamp;
            hr = _pImageStore->IsEntryInStore(pszGLocation, &ftCacheDateStamp);
            if ((hr == S_OK) && (!pftDateStamp || 
                (pftDateStamp->dwLowDateTime == ftCacheDateStamp.dwLowDateTime && 
                 pftDateStamp->dwHighDateTime == ftCacheDateStamp.dwHighDateTime)))
            {
                fRes = TRUE;
            }
            _pImageStore->Close(&dwStoreLock);
        }
    }
    return fRes;
}

HRESULT CDiskCacheTask_Create(CLogoBase * pView,
                               IShellImageStore *pImageStore,
                               LPCWSTR pszItem,
                               LPCWSTR pszGLocation,
                               DWORD dwItem,
                               const SIZE * prgSize,
                               IRunnableTask ** ppTask)
{
    CDiskCacheTask *pTask = new CDiskCacheTask;
    if (pTask == NULL)
    {
        return E_OUTOFMEMORY;
    }

    StrCpyW(pTask->_szItem, pszItem);
    StrCpyW(pTask->_szGLocation, pszGLocation);
    
    pTask->_pView = pView;
    pTask->_pImageStore = pImageStore;
    pImageStore->AddRef();
    pTask->_dwItem = dwItem;

    pTask->m_rgSize = * prgSize;
    
    *ppTask = SAFECAST(pTask, IRunnableTask *);

    return S_OK;
}

STDMETHODIMP CDiskCacheTask::RunInitRT()
{
    // otherwise, run the task ....
    HBITMAP hBmp = NULL;
    DWORD dwLock;

    HRESULT hr = _pImageStore->Open(STGM_READ, &dwLock);
    if (SUCCEEDED(hr))
    {
        // at this point, we assume that it IS in the cache, and we already have a read lock on the cache...
        hr = _pImageStore->GetEntry(_szGLocation, STGM_READ, &hBmp);
    
        // release the lock, we don't need it...
        _pImageStore->Close(&dwLock);
    }
    ATOMICRELEASE(_pImageStore);

    if (hBmp)
    {
        PrepImage(&hBmp);
    
        _pView->UpdateLogoCallback(_dwItem, 0, hBmp, _szItem, TRUE);
    }

    // ensure we don't return the  "we've suspended" value...
    if (hr == E_PENDING)
        hr = E_FAIL;
        
    return hr;
}

CDiskCacheTask::CDiskCacheTask() : CRunnableTask(RTF_DEFAULT)
{
}

CDiskCacheTask::~CDiskCacheTask()
{
    ATOMICRELEASE(_pImageStore);
}

HRESULT CDiskCacheTask::PrepImage(HBITMAP * phBmp)
{
    ASSERT(phBmp && *phBmp);

    DIBSECTION rgDIB;

    if (!GetObject(*phBmp, sizeof(rgDIB), &rgDIB))
    {
        return E_FAIL;
    }

    // the disk cache only supports 32 Bpp DIBS now, so we can ignore the palette issue...
    ASSERT(rgDIB.dsBm.bmBitsPixel == 32);
    
    HBITMAP hBmpNew = NULL;
    HPALETTE hPal = NULL;
    if (SHGetCurColorRes() == 8)
    {
        hPal = SHCreateShellPalette(NULL);
    }
    
    IScaleAndSharpenImage2 * pScale;
    HRESULT hr = CoCreateInstance(CLSID_ThumbnailScaler, NULL,
                           CLSCTX_INPROC_SERVER, IID_PPV_ARG(IScaleAndSharpenImage2, &pScale));
    if (SUCCEEDED(hr))
    {
        hr = pScale->ScaleSharpen2((BITMAPINFO *) &rgDIB.dsBmih,
                                    rgDIB.dsBm.bmBits, &hBmpNew, &m_rgSize, SHGetCurColorRes(),
                                    hPal, 0, FALSE);
        pScale->Release();
    }

    if (hPal)
        DeletePalette(hPal);
    
    if (SUCCEEDED(hr) && hBmpNew)
    {
        DeleteObject(*phBmp);
        *phBmp = hBmpNew;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\icotask.cpp ===
#include "priv.h"
#include "icotask.h"

// {EB30900C-1AC4-11d2-8383-00C04FD918D0}
static const GUID TASKID_IconExtraction = 
{ 0xeb30900c, 0x1ac4, 0x11d2, { 0x83, 0x83, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };

CIconTask::CIconTask(LPITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId):
    _pidl(pidl), _pfn(pfn), _pvData(pvData), _uId(uId), CRunnableTask(RTF_DEFAULT)
   
{ 
    
}

CIconTask::~CIconTask()
{
    if (_pidl)
        ILFree(_pidl);
}

// IRunnableTask methods (override)
STDMETHODIMP CIconTask::RunInitRT(void)
{
    int iIndex = -1;
    IShellFolder* psf;
    LPCITEMIDLIST pidlItem;

    // We need to rebind because shell folders may not be thread safe.
    HRESULT hres = IEBindToParentFolder(_pidl, &psf, &pidlItem);

    if (SUCCEEDED(hres))
    {
        iIndex = SHMapPIDLToSystemImageListIndex(psf, pidlItem, NULL);
        psf->Release();
    }

    _pfn(_pvData, _uId, iIndex);
    return S_OK;        // return S_OK even if we don't get an icon.
}


// NOTE: If you pass NULL for psf and pidlFolder, you must pass a full pidl which
// the API takes ownership of. (This is an optimization) lamadio - 7.28.98

HRESULT AddIconTask(IShellTaskScheduler* pts, IShellFolder* psf, LPCITEMIDLIST pidlFolder, 
                    LPCITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, 
                    UINT uId, int* piTempIcon)
{
    if (!pts)
        return E_INVALIDARG;


    HRESULT hres = E_PENDING;
    TCHAR szIconFile[MAX_PATH];


    // The shell has a concept of GIL_ASYNC which means that an extension called with this flag
    // should not really load the target file, it should "Fake" it, returning an icon for the type.
    // Later, on a background thread, we're going to call it again without the GIL_ASYNC, and at
    // that time, it should really extract the icon.

    // This is an optimiation for slow icon extraction, such as network shares

    // NOTE: There is significant overhead to actually loading the shell extension. If you know the
    // type of the item, pass NULL to piTempIcopn


    if (piTempIcon)
    {
        *piTempIcon = -1;

        UINT uFlags;
        IExtractIconA* pixa;
        IExtractIconW* pix;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&pidl, IID_IExtractIconW, NULL, (LPVOID*)&pix)))
        {
            hres = pix->GetIconLocation(GIL_FORSHELL | GIL_ASYNC,
                        szIconFile, ARRAYSIZE(szIconFile), piTempIcon, &uFlags);
            pix->Release();
        }
        else if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1,(LPCITEMIDLIST*)&pidl, IID_IExtractIconA, NULL, (LPVOID*)&pixa)))
        {
            char szIconFileA[MAX_PATH];
            hres = pixa->GetIconLocation(GIL_FORSHELL | GIL_ASYNC,
                        szIconFileA, ARRAYSIZE(szIconFileA), piTempIcon, &uFlags);
            SHAnsiToUnicode(szIconFileA, szIconFile, ARRAYSIZE(szIconFile));
            pixa->Release();
        }
    }

    if (hres == E_PENDING)
    {
        if (piTempIcon)
            *piTempIcon = Shell_GetCachedImageIndex(szIconFile, *piTempIcon, 0);

        LPITEMIDLIST pidlFull;
        if (psf)
            pidlFull = ILCombine(pidlFolder, pidl);
        else
            pidlFull = (LPITEMIDLIST)pidl;

        hres = E_OUTOFMEMORY;
        CIconTask* pit = new CIconTask(pidlFull, pfn, pvData, uId);
        // Don't ILFree(pidlFull) because CIconTask takes ownership.
        // BUGBUG (lamadio) Remove this from the memory list. Ask Saml how to do this
        // for the IMallocSpy stuff.

        if (pit)
        {
            hres = pts->AddTask(SAFECAST(pit, IRunnableTask*), TASKID_IconExtraction, 
                ITSAT_DEFAULT_LPARAM, ITSAT_DEFAULT_PRIORITY);

            pit->Release();
        }
    }
    else
    {
        *piTempIcon = SHMapPIDLToSystemImageListIndex(psf, pidl, NULL);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\iaccess.cpp ===
#include "priv.h"
// BUGBUG (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "apithk.h"
#include "resource.h"
#include "initguid.h"
#include "iaccess.h"

#include "mluisupp.h"

CAccessible::CAccessible(HMENU hmenu, WORD wID):
    _hMenu(hmenu), _wID(wID), _cRef(1)
{
    _fState = MB_STATE_TRACK;
}

CAccessible::CAccessible(IMenuBand* pmb): _cRef(1)
{
    _fState = MB_STATE_MENU;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::CAccessible(IMenuBand* pmb, int iIndex): _cRef(1)
{
    _fState = MB_STATE_ITEM;
    _iAccIndex = iIndex;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::~CAccessible()
{
    ATOMICRELEASE(_pTypeInfo);
    ATOMICRELEASE(_pInnerAcc);
    switch (_fState)
    {
    case MB_STATE_TRACK:
        ASSERT(!_hwndMenuWindow || IsWindow(_hwndMenuWindow));
        if (_hwndMenuWindow)
        {
            // Don't Destroy hmenu. It's part of a larger one...
            SetMenu(_hwndMenuWindow, NULL);
            DestroyWindow(_hwndMenuWindow);
            _hwndMenuWindow = NULL;
        }
        break;

    case MB_STATE_ITEM:
        ATOMICRELEASE(_pmtbItem);
        // Fall Through

    case MB_STATE_MENU:
        ATOMICRELEASE(_pmtbTop);
        ATOMICRELEASE(_pmtbBottom);
        ATOMICRELEASE(_psma);
        ATOMICRELEASE(_pmb);
        break;
    }
}

HRESULT CAccessible::InitAcc()
{
    HRESULT hres = E_FAIL;
    if (_fInitialized)
        return NOERROR;

    _fInitialized = TRUE;   // We're initialized if we fail or not...

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (EVAL(_hMenu))
        {
            _hwndMenuWindow = CreateWindow(TEXT("static"),
                TEXT("MenuWindow"), WS_POPUP, 0, 0, 0, 0, NULL,
                _hMenu, g_hinst, NULL);
            if (EVAL(_hwndMenuWindow))
            {
                IAccessible* paccChild1;
                hres = CreateStdAccessibleObject(_hwndMenuWindow, OBJID_MENU, IID_IAccessible, (void**)&paccChild1);
                if(SUCCEEDED(hres))
                {
                    VARIANT varChild;
                    varChild.vt = VT_I4;
                    varChild.lVal = _wID + 1;        //Accesibility is 1 based

                    // In order to get "On par" with the OleAcc's implementation of the HMENU wrapper,
                    // we need to do this twice. Once gets us the IAccessible for the "MenuItem" on the 
                    // "Menubar". The second gets us the "Menuitem's" child. This is what we need to emulate
                    // their heirarchy.
                    IDispatch* pdispChild1;
                    hres = paccChild1->get_accChild(varChild, &pdispChild1);

                    // OLEAcc returns a Success code (S_FALSE) while initializing the out param to zero.
                    // Explicitly test this situation.

                    // Does this have a Child?
                    if (hres == S_OK)
                    {
                        // Yes. Look for that child
                        IAccessible* paccChild2;
                        hres = pdispChild1->QueryInterface(IID_IAccessible, (void**)&paccChild2);

                        // Does this have a child?
                        if (hres == S_OK)
                        {
                            // Yep, then we store this guy's child...
                            IDispatch* pdispChild2;
                            varChild.lVal = 1;        //Get the first child
                            hres = paccChild2->get_accChild(varChild, &pdispChild2);
                            if (hres == S_OK)
                            {
                                hres = pdispChild2->QueryInterface(IID_IAccessible, (void**)&_pInnerAcc);
                                pdispChild2->Release();
                            }
                            paccChild2->Release();
                        }
                        pdispChild1->Release();
                    }
                    paccChild1->Release();
                }
            }
        }
        break;


    case MB_STATE_ITEM:
    case MB_STATE_MENU:
        hres = _pmb->QueryInterface(IID_IShellMenuAcc, (void**)&_psma);
        if (SUCCEEDED(hres))
        {
            _psma->GetTop(&_pmtbTop);
            _psma->GetBottom(&_pmtbBottom);
        }

        if (_fState == MB_STATE_ITEM)
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            if (SUCCEEDED(_GetChildFromVariant(&varChild, &_pmtbItem, &_iIndex)))
                _idCmd = GetButtonCmd(_pmtbItem->_hwndMB, _iIndex);
        }

        break;
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CAccessible::AddRef()
{
    _cRef++;
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CAccessible::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CAccessible::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = 
    {
        QITABENT(CAccessible, IDispatch),
        QITABENT(CAccessible, IAccessible),
        QITABENT(CAccessible, IEnumVARIANT),
        QITABENT(CAccessible, IOleWindow),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);

    return hres;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetTypeInfoCount method

*/
STDMETHODIMP CAccessible::GetTypeInfoCount(UINT FAR* pctinfo)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfoCount(pctinfo);
    *pctinfo = 1;
    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetTypeInfo method

*/
STDMETHODIMP CAccessible::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
{
    *pptinfo = NULL;
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfo(itinfo, lcid, pptinfo);

    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (EVAL(_LoadTypeLib()))
    {
        *pptinfo = _pTypeInfo;
        _pTypeInfo->AddRef();
        return NOERROR;
    }
    else
        return E_FAIL;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetIDsOfNames method

*/
STDMETHODIMP CAccessible::GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
        LCID lcid, DISPID FAR* rgdispid)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);

    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    }
    else
        return E_FAIL;
}


/*----------------------------------------------------------
Purpose: IDispatch::Invoke method

*/
STDMETHODIMP CAccessible::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
    DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr)

{
    if (_pInnerAcc)
        return _pInnerAcc->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, 
            pexcepinfo, puArgErr);
    
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->Invoke(static_cast<IDispatch*>(this),
            dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    else
        return E_FAIL;
}

BOOL CAccessible::_LoadTypeLib()
{
    ITypeLib* pTypeLib;
    if (_pTypeInfo)
        return TRUE;

    if (SUCCEEDED(LoadTypeLib(L"oleacc.dll", &pTypeLib)))
    {
        pTypeLib->GetTypeInfoOfGuid(IID_IAccessible, &_pTypeInfo);
        ATOMICRELEASE(pTypeLib);
        return TRUE;
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accParent method

*/
STDMETHODIMP CAccessible::get_accParent(IDispatch * FAR* ppdispParent)
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accParent(ppdispParent);
        break;

    case MB_STATE_MENU:
        {
            IUnknown* punk;
            if (SUCCEEDED(_psma->GetParentSite(IID_IUnknown, (void**)&punk)))
            {
                IAccessible* pacc;
                if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                    IID_IAccessible, (void**)&pacc)))
                {
                    VARIANT varChild = {VT_I4, CHILDID_SELF};     // Init
                    hres = pacc->get_accFocus(&varChild);
                    if (SUCCEEDED(hres))
                    {
                        hres = pacc->get_accChild(varChild, ppdispParent);
                    }
                    VariantClearLazy(&varChild);
                    pacc->Release();
                }
                else
                {
                    // Another implementation headache: Accessibility requires
                    // us to return S_FALSE when there is no parent.

                    *ppdispParent = NULL;
                    hres = S_FALSE;
                }

                punk->Release();
            }

            return hres;
        }
    case MB_STATE_ITEM:
        // The parent of an item is the menuband itself
        return IUnknown_QueryService(_psma, SID_SMenuPopup, IID_IDispatch, (void**)ppdispParent);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChildCount method

*/
STDMETHODIMP CAccessible::get_accChildCount(long FAR* pChildCount)
{   
    *pChildCount = 0;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChildCount(pChildCount);
        break;

    case MB_STATE_MENU:
        {
            int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
            int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
            *pChildCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;
        }
        break;
    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
            *pChildCount = 1;
        break;

    }
    
    return NOERROR;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChild method

*/
STDMETHODIMP CAccessible::get_accChild(VARIANT varChildIndex, IDispatch * FAR* ppdispChild)     
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChild(varChildIndex, ppdispChild);
        break;

    case MB_STATE_MENU:
        {
            if (varChildIndex.vt == VT_I4 && varChildIndex.lVal == CHILDID_SELF)
            {
                // So this is the ONLY menthod that is allowed to fail when something is
                // unavailable.
                *ppdispChild = NULL;
                hres = E_INVALIDARG;
            }
            else
            {
                int iIndex;
                // Since it's returing an index, we don't need to test the success case
                _GetChildFromVariant(&varChildIndex, NULL, &iIndex);
                hres = _GetAccessibleItem(iIndex, ppdispChild);
            }
        }
        break;

    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
        {
            VARIANT varChild;
            hres = _GetVariantFromChildIndex(_pmtbItem->_hwndMB, _iIndex, &varChild);
            if (SUCCEEDED(hres))
            {
                hres = _psma->GetSubMenu(&varChild, IID_IDispatch, (void**)ppdispChild);
            }
        }
        else
            hres = E_NOINTERFACE;
        break;
    }
    
    return hres;   
}

HRESULT CAccessible::_GetAccName(BSTR* pbstr)
{
    IDispatch* pdisp;
    HRESULT hres = get_accParent(&pdisp);
    // Get parent can return a success code, but still fail to return a parent.
    // This interface sucks.
    if (hres == S_OK)
    {
        IAccessible* pacc;
        hres = pdisp->QueryInterface(IID_IAccessible, (void**)&pacc);
        if (SUCCEEDED(hres))
        {
            VARIANT varChild;
            hres = pacc->get_accFocus(&varChild);
            if (SUCCEEDED(hres))
                hres = pacc->get_accName(varChild, pbstr);
        }
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accName method

*/
STDMETHODIMP CAccessible::get_accName(VARIANT varChild, BSTR* pszName)
{   
    CMenuToolbarBase* pmtb = _pmtbItem;
    int idCmd = _idCmd;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accName(varChild, pszName);
        break;

    case MB_STATE_MENU:
        if (varChild.lVal == CHILDID_SELF)
        {
            if (_GetAccName(pszName) == S_FALSE)
            {
                TCHAR sz[100];
                MLLoadString(IDS_ACC_APP, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
                if (!*pszName)
                    return E_OUTOFMEMORY;
            }
            return NOERROR;
        }
        else
        {
            int iIndex;
            if (FAILED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                return DISP_E_MEMBERNOTFOUND;

            idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
        }

        // Fall Through

    case MB_STATE_ITEM:
        {
            TCHAR sz[MAX_PATH];
            int idString = 0;
            TBBUTTON tbb;
            if (ToolBar_GetButton(pmtb->_hwndMB, _iIndex, &tbb) && 
                tbb.fsStyle & BTNS_SEP)
            {
                idString = IDS_ACC_SEP;
            }
            else if (pmtb->GetChevronID() == _idCmd)
            {
                idString = IDS_ACC_CHEVRON;
            }

            if (idString != 0)
            {
                MLLoadString(idString, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
            }
            else if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
            {
                SHStripMneumonic(sz);
                *pszName = SysAllocString(sz);
            }

            if (_fState == MB_STATE_MENU)
                pmtb->Release();

            if (!*pszName)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accValue method

*/
STDMETHODIMP CAccessible::get_accValue(VARIANT varChild, BSTR* pszValue)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accValue(varChild, pszValue);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // This does not make sense for these.
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDescription method

*/
STDMETHODIMP CAccessible::get_accDescription(VARIANT varChild, BSTR FAR* pszDescription)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDescription(varChild, pszDescription);
        break;

    case MB_STATE_MENU:
        if (FAILED(_GetAccName(pszDescription)))
        {
            TCHAR sz[100];
            MLLoadString(IDS_ACC_APPMB, sz, ARRAYSIZE(sz));
            *pszDescription = SysAllocStringT(sz);
            if (!*pszDescription)
                return E_OUTOFMEMORY;
        }
        break;
    case MB_STATE_ITEM:
        return get_accName(varChild, pszDescription);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accRole method

*/
STDMETHODIMP CAccessible::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{   
    pvarRole->vt = VT_I4;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accRole(varChild, pvarRole);
        break;

    case MB_STATE_MENU:
        {
            BOOL fVertical;
            BOOL fOpen;
            _psma->GetState(&fVertical, &fOpen);
            pvarRole->lVal = ( fVertical )? ROLE_SYSTEM_MENUPOPUP : ROLE_SYSTEM_MENUBAR;
            return NOERROR;
        }

    case MB_STATE_ITEM:
        pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
        return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accState method

*/
STDMETHODIMP CAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accState(varChild, pvarState);
        break;

    case MB_STATE_MENU:
        {
            // All menus can be selected, and given focus. Most will be visible.
            DWORD dwState = STATE_SYSTEM_FOCUSABLE;

            BOOL fOpen;
            BOOL fVertical;
            _psma->GetState(&fVertical, &fOpen);

            // Do we have a menu popped up?
            if (fOpen)
            {
                // Yes, then we have focus
                dwState |= STATE_SYSTEM_FOCUSED;
            }
            else if (fVertical)
            {
                // If we're a vertical menu without being popped up, then we're invisible.
                dwState |= STATE_SYSTEM_INVISIBLE;
            }


            pvarState->vt = VT_I4;
            pvarState->lVal = dwState;
        }
        return NOERROR;

    case MB_STATE_ITEM:
        {
            DWORD dwAccState = STATE_SYSTEM_FOCUSABLE;

            int idHotTracked = ToolBar_GetHotItem(_pmtbItem->_hwndMB);
            DWORD dwState = ToolBar_GetState(_pmtbItem->_hwndMB, _iIndex);

            if (dwState & TBSTATE_PRESSED)
                dwAccState |= STATE_SYSTEM_SELECTABLE | STATE_SYSTEM_FOCUSED;

            if (idHotTracked == _iIndex)
                dwAccState |= STATE_SYSTEM_HOTTRACKED;

            pvarState->vt = VT_I4;
            pvarState->lVal = dwAccState;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelp method

*/
STDMETHODIMP CAccessible::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelp(varChild, pszHelp);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelpTopic method

*/
STDMETHODIMP CAccessible::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

#define CH_PREFIX TEXT('&')

TCHAR GetAccelerator(LPCTSTR psz, BOOL bUseDefault)
{
    TCHAR ch = (TCHAR)-1;
    LPCTSTR pszAccel = psz;
    // then prefixes are allowed.... see if it has one
    do 
    {
        pszAccel = StrChr(pszAccel, CH_PREFIX);
        if (pszAccel) 
        {
            pszAccel = CharNext(pszAccel);

            // handle having &&
            if (*pszAccel != CH_PREFIX)
                ch = *pszAccel;
            else
                pszAccel = CharNext(pszAccel);
        }
    } while (pszAccel && (ch == (TCHAR)-1));

    if ((ch == (TCHAR)-1) && bUseDefault)
    {
        // Since we're unicocde, we don't need to mess with MBCS
        ch = *psz;
    }

    return ch;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accKeyboardShortcut method

*/
STDMETHODIMP CAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hres = DISP_E_MEMBERNOTFOUND;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        goto labelGetaccel;

    case MB_STATE_MENU:
        {

            if (varChild.lVal != CHILDID_SELF)
            {
                if (SUCCEEDED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                {
labelGetaccel:
                    TCHAR sz[MAX_PATH];
                    TCHAR szAccel[100] = TEXT("");
                    int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                    if (S_FALSE == _psma->IsEmpty())
                    {
                        if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                        {
                            BOOL fVertical, fOpen;
                            _psma->GetState(&fVertical, &fOpen);
                            if (!fVertical)
                            {
                                MLLoadString(IDS_ACC_ALT, szAccel, ARRAYSIZE(szAccel));
                            }
                            szAccel[lstrlen(szAccel)] = GetAccelerator(sz, TRUE);
                            szAccel[lstrlen(szAccel)] = TEXT('\0');
                            hres = S_OK;
                        }
                    }

                    *pszKeyboardShortcut = SysAllocStringT(szAccel);
                    if (!*pszKeyboardShortcut)
                        hres = E_OUTOFMEMORY;
                    pmtb->Release();
                }
            }

        }
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accFocus method

*/
STDMETHODIMP CAccessible::get_accFocus(VARIANT FAR * pvarFocusChild)
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accFocus(pvarFocusChild);
        break;

    case MB_STATE_MENU:
        {
            pvarFocusChild->vt = VT_I4;
            pvarFocusChild->lVal = CHILDID_SELF;

            CMenuToolbarBase* pmtbTracked;
            _psma->GetTracked(&pmtbTracked);
            if (pmtbTracked)
            {
                int iIndex = ToolBar_GetHotItem(pmtbTracked->_hwndMB);
                hres = _GetVariantFromChildIndex(pmtbTracked->_hwndMB, 
                    iIndex, pvarFocusChild);
                pmtbTracked->Release();
            }
        }
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accSelection method

*/
STDMETHODIMP CAccessible::get_accSelection(VARIANT FAR * pvarSelectedChildren)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accSelection(pvarSelectedChildren);
        break;

    case MB_STATE_MENU:
        return get_accFocus(pvarSelectedChildren);
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDefaultAction method

*/
STDMETHODIMP CAccessible::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{   
    TCHAR sz[MAX_PATH];

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDefaultAction(varChild, pszDefaultAction);
        break;

    case MB_STATE_MENU:
        {
            MLLoadString(IDS_ACC_CLOSE, sz, ARRAYSIZE(sz));
            *pszDefaultAction = SysAllocStringT(sz);

            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }

    case MB_STATE_ITEM:
        {
            if (S_OK == _psma->IsEmpty())
            {
                sz[0] = TEXT('\0');
            }
            else
            {
                int iId = (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)? IDS_ACC_OPEN: IDS_ACC_EXEC;
                MLLoadString(iId, sz, ARRAYSIZE(sz));
            }

            *pszDefaultAction = SysAllocStringT(sz);
            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accSelect method

*/
STDMETHODIMP CAccessible::accSelect(long flagsSelect, VARIANT varChild)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accSelect(flagsSelect, varChild);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accLocation method

*/
STDMETHODIMP CAccessible::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        hres = NOERROR;
        goto labelGetRect;

    case MB_STATE_MENU:
        {
            RECT rc;
            if (varChild.vt == VT_I4)
            {
                if (varChild.lVal == CHILDID_SELF)
                {
                    IUnknown* punk;
                    hres = _psma->GetParentSite(IID_IUnknown, (void**)&punk);
                    if (SUCCEEDED(hres))
                    {
                        IOleWindow* poct;
                        hres = IUnknown_QueryService(punk, SID_SMenuPopup, 
                            IID_IOleWindow, (void**)&poct);
                        if (SUCCEEDED(hres))
                        {
                            HWND hwnd;
                            hres = poct->GetWindow(&hwnd);
                            if (SUCCEEDED(hres))
                            {
                                // Return the window rect of the menubar.
                                GetWindowRect(hwnd, &rc);
                            }

                            poct->Release();
                        }

                        punk->Release();
                    }
                }
                else
                {
                    hres = _GetChildFromVariant(&varChild, &pmtb, &iIndex);
                    if (SUCCEEDED(hres))
                    {

labelGetRect:           int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                        if (!ToolBar_GetRect(pmtb->_hwndMB, idCmd, &rc))  //1 based index
                            hres = E_INVALIDARG;
                        MapWindowPoints(pmtb->_hwndMB, NULL, (LPPOINT)&rc, 2);
                        pmtb->Release();
                    }
                }

                if (SUCCEEDED(hres))
                {
                    *pxLeft = rc.left;
                    *pyTop = rc.top;
                    *pcxWidth = rc.right - rc.left;
                    *pcyHeight = rc.bottom - rc.top;
                }
            }
        }
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accNavigate method

*/
STDMETHODIMP CAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)     
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accNavigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_MENU:
        return _Navigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_ITEM:
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            return _Navigate(navDir, varChild, pvarEndUpAt);
        }
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accHitTest method

*/
STDMETHODIMP CAccessible::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{   
    POINT pt = {xLeft, yTop};
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
        break;

    case MB_STATE_MENU:
        {
            if (_psma)
            {
                int iIndex;
                HWND hwnd = WindowFromPoint(pt);

                if (hwnd == _pmtbTop->_hwndMB || hwnd == _pmtbBottom->_hwndMB)
                {
                    ScreenToClient(hwnd, &pt);
                    iIndex = ToolBar_HitTest(hwnd, &pt);
                    if (iIndex >= 0)
                    {
                        pvarChildAtPoint->vt = VT_DISPATCH;
                        // This call expects the index to be an "Accessible" index which is one based
                        VARIANT varChild;
                        _GetVariantFromChildIndex(hwnd, iIndex, &varChild);

                        //Since this is just returining an index, we don't need to test success
                        _GetChildFromVariant(&varChild, NULL, &iIndex);
                        return _GetAccessibleItem(iIndex, &pvarChildAtPoint->pdispVal);
                    }
                }

                // Hmm, must be self
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;

                return S_OK;
            }
        }
        break;

    case MB_STATE_ITEM:
        {
            RECT rc;
            MapWindowPoints(NULL, _pmtbItem->_hwndMB, &pt, 1);

            if (ToolBar_GetRect(_pmtbItem->_hwndMB, _idCmd, &rc) &&
                PtInRect(&rc, pt))
            {
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;
            }
            else
            {
                pvarChildAtPoint->vt = VT_EMPTY;
                pvarChildAtPoint->lVal = (DWORD)(-1);
            }
            return NOERROR;
        }
        break;

    }
    
    return DISP_E_MEMBERNOTFOUND;
}

/*----------------------------------------------------------
Purpose: IAccessible::accDoDefaultAction method

*/
STDMETHODIMP CAccessible::accDoDefaultAction(VARIANT varChild)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accDoDefaultAction(varChild);
        break;

    case MB_STATE_MENU:
        if (_psma)
            return _psma->DoDefaultAction(&varChild);
        break;

    case MB_STATE_ITEM:
        if (SendMessage(_pmtbItem->_hwndMB, TB_SETHOTITEM2, _iIndex, 
            HICF_OTHER | HICF_RESELECT | HICF_TOGGLEDROPDOWN))
            return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accName method

*/
STDMETHODIMP CAccessible::put_accName(VARIANT varChild, BSTR szName)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->put_accName(varChild, szName);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accValue method

*/
STDMETHODIMP CAccessible::put_accValue(VARIANT varChild, BSTR pszValue)  
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
       if (_pInnerAcc)
            return _pInnerAcc->put_accValue(varChild, pszValue);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}


HRESULT CAccessible::_Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    ASSERT(pvarEndUpAt);
    int iIndex = 0;         // 1 based index
    int iTBIndex;
    HRESULT hres = S_FALSE;
    TBBUTTONINFO tbInfo;
    int idCmd;
    VARIANT varTemp;
    CMenuToolbarBase* pmtb;
    BOOL fVertical;
    BOOL fOpen;


    tbInfo.cbSize = sizeof(TBBUTTONINFO);

    pvarEndUpAt->vt = VT_DISPATCH;
    pvarEndUpAt->pdispVal = NULL;

    _GetChildFromVariant(&varStart, NULL, &iIndex);

    _psma->GetState(&fVertical, &fOpen);
    if (!fVertical)
    {
        static const long navMap[] = 
        {
            NAVDIR_LEFT,    // Map to Up
            NAVDIR_RIGHT,   // Map to Down
            NAVDIR_UP,      // Map to Left
            NAVDIR_DOWN,    // Map to Right
        };
        if (IsInRange(navDir, NAVDIR_UP, NAVDIR_RIGHT))
            navDir = navMap[navDir - NAVDIR_UP];
    }

    switch (navDir)
    {
    case NAVDIR_NEXT:
        {
            VARIANT varVert;
            varVert.vt = VT_BOOL;
            // For the Vertical case, Next should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                // Yes. Then punt
                hres = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through
    case NAVDIR_DOWN:

        hres = NOERROR;
        while (SUCCEEDED(hres))
        {
            iIndex++;
            hres = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hres))
            {
                hres = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hres))
                {
                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                    ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    case NAVDIR_FIRSTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hres = S_FALSE;
            break;
        }

        iIndex = 0;
        hres = NOERROR;
        break;

    case NAVDIR_LASTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hres = S_FALSE;
            break;
        }
        iIndex = -1;
        hres = NOERROR;
        break;

    case NAVDIR_LEFT:
        pvarEndUpAt->vt = VT_DISPATCH;
        return get_accParent(&pvarEndUpAt->pdispVal);
        break;

    case NAVDIR_RIGHT:
        {
            CMenuToolbarBase* pmtb = (varStart.lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
            int idCmd = GetButtonCmd(pmtb->_hwndMB, (varStart.lVal & ~TOOLBAR_MASK) - 1);
            if (pmtb->v_GetFlags(idCmd) & SMIF_SUBMENU)
            {
                IMenuPopup* pmp;
                hres = _psma->GetSubMenu(&varStart, IID_IMenuPopup, (void**)&pmp);
                if (SUCCEEDED(hres))
                {
                    IAccessible* pacc;
                    hres = IUnknown_QueryService(pmp, SID_SMenuBandChild, IID_IAccessible, (void**)&pacc);
                    if (SUCCEEDED(hres))
                    {
                        hres = pacc->accNavigate(NAVDIR_FIRSTCHILD, varStart, pvarEndUpAt);
                        pacc->Release();
                    }
                    pmp->Release();
                }
            }

                return hres;
        }
        break;

    case NAVDIR_PREVIOUS:
        {
            VARIANT varVert;
            varVert.vt = VT_BOOL;
            // For the Vertical case, Pervious should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                // Yes. Then punt
                hres = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through

    case NAVDIR_UP:
        hres = NOERROR;
        while (SUCCEEDED(hres))
        {
            iIndex--;
            hres = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hres))
            {
                hres = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hres))
                {
                    if (iTBIndex == 0)    
                    {   
                        hres = S_FALSE;
                        //Don't navigate to self, allow the top bar to get a whack.
                        IUnknown* punk;
                        if (SUCCEEDED(_psma->GetParentSite(IID_IOleCommandTarget, (void**)&punk)))
                        {
                            IOleCommandTarget* poct;
                            if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                IID_IOleCommandTarget, (void**)&poct)))
                            {
                                VARIANT varVert;
                                varVert.vt = VT_BOOL;

                                if (SUCCEEDED(poct->Exec(&CGID_MenuBand, MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                                    varVert.boolVal == VARIANT_FALSE)
                                {
                                    IAccessible* pacc;
                                    if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                        IID_IAccessible, (void**)&pacc)))
                                    {
                                        VARIANT varChild = {VT_I4, CHILDID_SELF};
                                        hres = pacc->get_accFocus(&varChild);
                                        if (SUCCEEDED(hres))
                                        {
                                            hres = pacc->get_accChild(varChild, &pvarEndUpAt->pdispVal);
                                        }

                                        VariantClearLazy(&varChild);
                                        pacc->Release();
                                    }
                                }
                                poct->Release();
                            }
                            punk->Release();
                        }
                    }   // iTBIndex == 0

                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                    ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    default:
        hres = E_INVALIDARG;
    }

    if (SUCCEEDED(hres) && S_FALSE != hres)
        hres = _GetAccessibleItem(iIndex, &pvarEndUpAt->pdispVal);

    return hres;
}

HRESULT CAccessible::_GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild)
{
    // First bit: Top 1, bottom 0
    // Rest is index into that toolbar.
    pvarChild->vt = VT_I4;
    pvarChild->lVal = iIndex + 1;

    if (hwnd)
    {
        if (hwnd == _pmtbTop->_hwndMB)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
    }
    else
    {
        // Caller wants us to figure out based on index from top.
        int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
        int iTotalCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;

        if (iIndex < iTopCount)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
        else
        {
            pvarChild->lVal -= iTopCount;
        }

        // This works because:
        // If there are 2 toolbars, the bottom one is represented by top bit clear.
        // If there is only one, then it doesn't matter if it's top or bottom.

        // lVal is not zero based....
        if (iIndex == -1)
            pvarChild->lVal = iTotalCount;

        if (iIndex >= iTotalCount)
            return E_FAIL;
    }

    return NOERROR;
}

HRESULT CAccessible::_GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* piIndex)
{
    ASSERT(_pmtbTop && _pmtbBottom);
    ASSERT(piIndex);

    if (ppmtb)
        *ppmtb = NULL;

    *piIndex = -1;

    // Passing a NULL for an HWND returns the index from the beginning of the set.
    int iAdd = 0;
    if (pvarChild->vt != VT_I4)
        return E_FAIL;

    if (pvarChild->lVal & TOOLBAR_MASK)
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbTop;
        }
    }
    else
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbBottom;
        }
        else
        {
            iAdd = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        }
    }

    if (ppmtb && *ppmtb)
        (*ppmtb)->AddRef();

    *piIndex = (pvarChild->lVal & ~TOOLBAR_MASK) + iAdd - 1;

    return (ppmtb && !*ppmtb) ? E_FAIL : S_OK;
}


HRESULT CAccessible::_GetAccessibleItem(int iIndex, IDispatch** ppdisp)
{
    HRESULT hres = E_OUTOFMEMORY;
    CAccessible* pacc = new CAccessible(_pmb, iIndex);

    if (pacc)
    {
        hres = pacc->InitAcc();
        if (SUCCEEDED(hres))
        {
            hres = pacc->QueryInterface(IID_IDispatch, (void**) ppdisp);
        }
        pacc->Release();
    }
    return hres;
}

// *** IEnumVARIANT methods ***
STDMETHODIMP CAccessible::Next(unsigned long celt, 
                        VARIANT FAR* rgvar, 
                        unsigned long FAR* pceltFetched)
{

    // Picky customer complaint. Check for NULL...
    if (pceltFetched)
        *pceltFetched = 1;
    return _GetVariantFromChildIndex(NULL, _iEnumIndex++, rgvar);
}

STDMETHODIMP CAccessible::Skip(unsigned long celt)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAccessible::Reset()
{
    _iEnumIndex = 0;
    return NOERROR;
}

STDMETHODIMP CAccessible::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    return E_NOTIMPL;
}

// *** IOleWindow methods ***
STDMETHODIMP CAccessible::GetWindow(HWND * lphwnd)
{
    *lphwnd = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        *lphwnd = _hwndMenuWindow;
        break;

    case MB_STATE_ITEM:
        *lphwnd = _pmtbItem->_hwndMB;
        break;

    case MB_STATE_MENU:
        *lphwnd = _pmtbTop->_hwndMB;
        break;
    }

    if (*lphwnd)
        return NOERROR;

    return E_FAIL;
}

STDMETHODIMP CAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\isfband.cpp ===
#include "priv.h"
#include <varutil.h>
#include "sccls.h"

#include "iface.h"
#include "itbar.h"
#include "itbdrop.h"
#include "bands.h"
#include "isfband.h"
#include "menubar.h"
#include "resource.h"
#include "menuisf.h"
#include "dpastuff.h"
#include "shlwapi.h"
#include "cobjsafe.h"
#include <iimgctx.h>
#include "uemapp.h"
#include "mnfolder.h"
#include "channel.h"
#include "browmenu.h"


#define DM_VERBOSE      0       // misc verbose traces
#define DM_PERSIST      0
#define TF_BANDDD   TF_BAND
#define DM_RENAME       0
#define DM_MISC         0       // miscellany

#define SZ_PROPERTIESA     "properties"
#define SZ_PROPERTIES      TEXT(SZ_PROPERTIESA)
#define SZ_REGKEY_ADVFOLDER        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")

// {F47162A0-C18F-11d0-A3A5-00C04FD706EC}
static const GUID TOID_ExtractImage = { 0xf47162a0, 0xc18f, 0x11d0, { 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec } };


#define SUPERCLASS CToolBand

HRESULT FakeGetUIObjectOf( IShellFolder *psf, LPCITEMIDLIST pidl, UINT * prgfFlags, REFIID riid, void **ppvObj );

extern UINT g_idFSNotify;

HRESULT CExtractImageTask_Create( CLogoBase *plb,
                                  LPEXTRACTIMAGE pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  LPRUNNABLETASK * ppTask );

class CExtractImageTask : public IRunnableTask
{
    public:
        STDMETHOD ( QueryInterface ) ( REFIID riid, void **ppvObj );
        STDMETHOD_( ULONG, AddRef ) ();
        STDMETHOD_( ULONG, Release ) ();

        STDMETHOD (Run)( void );
        STDMETHOD (Kill)( BOOL fWait );
        STDMETHOD (Suspend)( );
        STDMETHOD (Resume)( );
        STDMETHOD_( ULONG, IsRunning )( void );

    protected:

        CExtractImageTask( HRESULT * pHr,
                           CLogoBase *plb,
                           IExtractImage * pImage,
                           LPCWSTR pszCache,
                           DWORD dwItem,
                           int iIcon,
                           DWORD dwFlags );
        ~CExtractImageTask();
        HRESULT InternalResume();

    friend HRESULT CExtractImageTask_Create( CLogoBase* plb,
                                                 LPEXTRACTIMAGE pExtract,
                                                 LPCWSTR pszCache,
                                                 DWORD dwItem,
                                                 int iIcon,
                                                 DWORD dwFlags,
                                                 LPRUNNABLETASK * ppTask );

        LONG            m_cRef;
        LONG            m_lState;
        LPEXTRACTIMAGE  m_pExtract;
        LPRUNNABLETASK  m_pTask;
        WCHAR           m_szPath[MAX_PATH];
        DWORD           m_dwFlags;
        DWORD           m_dwItem;
        CLogoBase*      m_plb;
        HBITMAP         m_hBmp;
        int             m_iIcon;
};
//=================================================================
// Implementation of CISFBand
//=================================================================


CISFBand::CISFBand() : CToolbarBand()
{
    _fCanFocus = TRUE;
    _eUemLog = UEMIND_NIL;
    _dwPriv = -1;

    _fHasOrder = TRUE;  // ISFBand always has an order...
    _fAllowDropdown = BOOLIFY(SHRegGetBoolUSValue(SZ_REGKEY_ADVFOLDER, TEXT("CascadeFolderBands"),
                    FALSE,
                    FALSE)); 

    // Should we enable logging of arbirary events?
//    _pguidUEMGroup = &UEMIID_SHELL;
    ASSERT(_pguidUEMGroup == NULL);


    // Assert that this class is ZERO INITed.
    ASSERT(!_pbp);
    ASSERT(FALSE == _fCreatedBandProxy);
}


CISFBand::~CISFBand()
{
    if(_pbp && _fCreatedBandProxy)
        _pbp->SetSite(NULL);

    ATOMICRELEASE(_pbp);
}

HRESULT CISFBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres;
    CISFBand* pObj;

    hres = E_OUTOFMEMORY;

    pObj = new CISFBand();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IShellFolderBand*);
        hres = S_OK;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: See CISFBand::Init for an explanation on the parameters.

*/
CISFBand* CISFBand_CreateEx(IShellFolder* psf, LPCITEMIDLIST pidl)
{
    CISFBand * p = NULL;

    if (psf || pidl)
    {
        p = new CISFBand();
        if (p)
        {
            IShellFolderBand * psfband = SAFECAST(p, IShellFolderBand *);
            if (psfband && FAILED(psfband->InitializeSFB(psf, pidl)))
            {
                delete p;
                p = NULL;
            }
        }
    }
    return p;
}

#ifdef DEBUG
#define _AddRef(psz) { ++_cRef; TraceMsg(TF_SHDREF, "CDocObjectView(%x)::QI(%s) is AddRefing _cRef=%d", this, psz, _cRef); }
#else
#define _AddRef(psz)    ++_cRef
#endif

HRESULT CISFBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CISFBand, IShellFolderBand),
        QITABENT(CISFBand, IFolderBandPriv),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = CToolBand::QueryInterface(riid, ppvObj);

    if (FAILED(hres))
        hres = CSFToolbar::QueryInterface(riid, ppvObj);


    if (S_OK != hres)
    {
        // HACKHACK: this is yucko!
        if (IsEqualIID(riid, CLSID_ISFBand))
        {
            *ppvObj = (void*)this;
            _AddRef(TEXT("CLSID_ISFBand"));
            return S_OK;
        }
    }

    return hres;
}


#if 0
LPITEMIDLIST PidlFromFolderAndSubPath(int iFolder, TCHAR *pszSubPath)
{
    LPITEMIDLIST pidl = NULL;
    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, iFolder, &pidl))) {
        if (pszSubPath) {
            TCHAR szPath[MAX_PATH];
            SHGetPathFromIDList(pidl, szPath);
            PathCombine(szPath, szPath, pszSubPath);
            ILFree(pidl);
            pidl = ILCreateFromPath(szPath);
        }
    }
    return pidl;
}
#endif

//***   ILIsParentCSIDL -- like ILIsParent, but accepts a CSIDL_* for pidl1
// NOTES
//  TODO move to shlwapi (if/when idlist.c moves there)?
//
STDAPI_(BOOL) ILIsParentCSIDL(int csidl1, LPCITEMIDLIST pidl2, BOOL fImmediate)
{
    LPITEMIDLIST pidlSpec;
    BOOL fRet = FALSE;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl1, &pidlSpec))) {
        fRet = ILIsParent(pidlSpec, pidl2, fImmediate);
        ILFree(pidlSpec);
    }

    return fRet;
}

/*----------------------------------------------------------
Purpose: IShellFolderBand::InitializeSFB

         - supply IShellFolder with no PIDL if you want to view some
           ISF (either already instantiated from the filesystem or
           some non-filesystem ISF) that you do NOT want to receive
           notifies from (either from SHChangeNotify nor from
           IShellChangeNotify)

         - supply a PIDL with no IShellFolder for a full-blown band
           looking at a shell namespace (rooted on desktop) item.

*/
HRESULT CISFBand::InitializeSFB(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hres = S_OK;

    // Did they try to add the Recycle Bin? If so we need to reject it
    // for consistance reasons.  We also reject the Temp. Internet Files
    // for security reasons.
    if (pidl && (ILIsParentCSIDL(CSIDL_BITBUCKET, pidl, FALSE) ||
                ILIsParentCSIDL(CSIDL_INTERNET_CACHE, pidl, FALSE)))
    {
        // this will eventually show up as IDS_CANTISFBAND
        TraceMsg(DM_TRACE, "cib.isfb: recycle => E_INVALIDARG");
        hres = E_INVALIDARG;
    }

    if (SUCCEEDED(hres))
        hres = CSFToolbar::SetShellFolder(psf, pidl);
    if (SUCCEEDED(hres))
        _AfterLoad();

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolderBand::SetBandInfoSFB

*/
HRESULT CISFBand::SetBandInfoSFB(BANDINFOSFB * pbi)
{
    ASSERT(pbi);
    if (!pbi)
        return E_POINTER;

    if ((pbi->dwMask & ISFB_MASK_INVALID) ||
        (pbi->dwMask & ISFB_MASK_VIEWMODE) && (pbi->wViewMode & ~3))
        return E_INVALIDARG;

    // We don't handle ISFB_MASK_SHELLFOLDER and ISFB_MASK_IDLIST
    // in Set because there's a lot of work to resync pidl, psf, and
    // notifcations in the toolbar.  If somebody wants to do it,
    // more power to ya.  :)
    if (pbi->dwMask & (ISFB_MASK_SHELLFOLDER | ISFB_MASK_IDLIST))
        return E_INVALIDARG;

    if (pbi->dwMask & ISFB_MASK_STATE)
    {
        if (pbi->dwStateMask & ISFB_STATE_DEBOSSED)
            _fDebossed = BOOLIFY(pbi->dwState & ISFB_STATE_DEBOSSED);
        if (pbi->dwStateMask & ISFB_STATE_ALLOWRENAME)
            _fAllowRename = BOOLIFY(pbi->dwState & ISFB_STATE_ALLOWRENAME);
        if (pbi->dwStateMask & ISFB_STATE_NOSHOWTEXT)
            _fNoShowText = BOOLIFY(pbi->dwState & ISFB_STATE_NOSHOWTEXT);
        if (pbi->dwStateMask & ISFB_STATE_CHANNELBAR)
            _fChannels = BOOLIFY(pbi->dwState & ISFB_STATE_CHANNELBAR);
        /* ISFB_STATE_NOTITLE: removed 970619, use cbs::SetBandState */
        if (pbi->dwStateMask & ISFB_STATE_QLINKSMODE)
            _fLinksMode = BOOLIFY(pbi->dwState & ISFB_STATE_QLINKSMODE);
        if (pbi->dwStateMask & ISFB_STATE_FULLOPEN)
            _fFullOpen = BOOLIFY(pbi->dwState & ISFB_STATE_FULLOPEN);
        if (pbi->dwStateMask & ISFB_STATE_NONAMESORT)
            _fNoNameSort = BOOLIFY(pbi->dwState & ISFB_STATE_NONAMESORT);
        if (pbi->dwStateMask & ISFB_STATE_BTNMINSIZE)
            _fBtnMinSize = BOOLIFY(pbi->dwState & ISFB_STATE_BTNMINSIZE);
    }

    if (pbi->dwMask & ISFB_MASK_BKCOLOR)
    {
        _crBkgnd = pbi->crBkgnd;
        _fHaveBkColor = TRUE;
        if (EVAL(_hwndTB))
            SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_CUSTOMERASE, TBSTYLE_CUSTOMERASE);

        ASSERT(_hwnd);

        if (_hwndPager)
        {
            TraceMsg(TF_BAND, "cib.sbisfb: Pager_SetBkColor(_hwnd=%x crBkgnd=%x)", _hwnd, _crBkgnd);
            Pager_SetBkColor(_hwnd, _crBkgnd);
        }
    }

    // BUGBUG (kkahl): We don't support changing these once TB is created
    if (pbi->dwMask & ISFB_MASK_COLORS)
    {
        _crBtnLt = pbi->crBtnLt;
        _crBtnDk = pbi->crBtnDk;
        _fHaveColors = TRUE;
    }

    if (pbi->dwMask & ISFB_MASK_VIEWMODE)
    {
        _uIconSize = (pbi->wViewMode & 3); // stored in a 2-bit field currently...

        // only force no recalc if one of the recalcable fields was set
        _fNoRecalcDefaults = TRUE;
    }


    // If the bandsite queried us before, let it know the info may have changed
    if (_fInitialized)
        _BandInfoChanged();

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IShellFolderBand::GetBandInfoSFB

*/
HRESULT CISFBand::GetBandInfoSFB(BANDINFOSFB * pbi)
{
    ASSERT(pbi);
    if (!pbi)
        return E_POINTER;

    if (pbi->dwMask & ISFB_MASK_STATE)
    {
        pbi->dwState = 0;
        pbi->dwStateMask = ISFB_STATE_ALL;

        if (_fDebossed)
            pbi->dwState |= ISFB_STATE_DEBOSSED;
        if (_fAllowRename)
            pbi->dwState |= ISFB_STATE_ALLOWRENAME;
        if (_fNoShowText)
            pbi->dwState |= ISFB_STATE_NOSHOWTEXT;
        if (_fLinksMode)
            pbi->dwState |= ISFB_STATE_QLINKSMODE;
        if (_fFullOpen)
            pbi->dwState |= ISFB_STATE_FULLOPEN;
        if (_fNoNameSort)
            pbi->dwState |= ISFB_STATE_NONAMESORT;
        if (_fBtnMinSize)
            pbi->dwState |= ISFB_STATE_BTNMINSIZE;
    }

    if (pbi->dwMask & ISFB_MASK_BKCOLOR)
    {
        pbi->crBkgnd = (_fHaveBkColor) ? _crBkgnd : CLR_DEFAULT;
    }

    if (pbi->dwMask & ISFB_MASK_COLORS)
    {
        if (_fHaveColors)
        {
            pbi->crBtnLt = _crBtnLt;
            pbi->crBtnDk = _crBtnDk;
        }
        else
        {
            pbi->crBtnLt = CLR_DEFAULT;
            pbi->crBtnDk = CLR_DEFAULT;
        }
    }

    if (pbi->dwMask & ISFB_MASK_VIEWMODE)
    {
        pbi->wViewMode = _uIconSize;
    }

    if (pbi->dwMask & ISFB_MASK_SHELLFOLDER)
    {
        pbi->psf = _psf;
        if (pbi->psf)
            pbi->psf->AddRef();
    }

    if (pbi->dwMask & ISFB_MASK_IDLIST)
    {
        if (_pidl)
            pbi->pidl = ILClone(_pidl);
        else
            pbi->pidl = NULL;
    }
    return S_OK;
}

// *** IInputObject methods ***
HRESULT CISFBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    if (SendMessage(_hwnd, TB_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;

    return SUPERCLASS::TranslateAcceleratorIO(lpMsg);
}

void CISFBand::_SetCacheMenuPopup(IMenuPopup* pmp)
{
    if (!SHIsSameObject(pmp, _pmpCache)) {
        _ReleaseMenuPopup(&_pmpCache);
        _pmpCache = pmp;
        if (_pmpCache)
            _pmpCache->AddRef();
    }
}


void CISFBand::_ReleaseMenuPopup(IMenuPopup** ppmp)
{
    IUnknown_SetSite(*ppmp, NULL);
    ATOMICRELEASE(*ppmp);
}

/*----------------------------------------------------------
Purpose: Releases the held menu popup.

*/
void CISFBand::_ReleaseMenu()
{
    if (!SHIsSameObject(_pmp, _pmpCache)) {
        TraceMsg(TF_MENUBAND, "Releasing pmp %#lx", _pmp);
        _ReleaseMenuPopup(&_pmp);
    } else
        ATOMICRELEASE(_pmp);
}

//***
// ENTRY/EXIT
//  S_OK        desktop browser
//  S_FALSE     other browser (explorer, OC, etc.)
//  E_xxx       not a browser at all (e.g. band asking tray)
HRESULT IsDesktopBrowser(IUnknown *punkSite)
{
    HRESULT hr;
    IServiceProvider *psp;
    IUnknown *punk;

    hr = E_FAIL;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_IServiceProvider, (void**)&psp))) {
        hr = S_FALSE;
        if (SUCCEEDED(psp->QueryInterface(SID_SShellDesktop, (void**)&punk))) {
            hr = S_OK;
            punk->Release();
        }
        psp->Release();
    }

    TraceMsg(DM_VERBOSE, "idb: ret hrDesk=%x (0=dt 1=sh e=!brow)", hr);
    return hr;
}


/*----------------------------------------------------------
Purpose: IDockingWindow::SetSite method.

*/
HRESULT CISFBand::SetSite(IUnknown* punkSite)
{
    _ReleaseMenu();

    SUPERCLASS::SetSite(punkSite);

    if (_punkSite)
    {
        if (!_hwndTB)
            _CreateToolbar(_hwndParent);

        IUnknown_SetOwner(_psf, SAFECAST(this, IDeskBand*));

        _Initialize();  // BUGBUG always or just on 1st SetSite?
    }
    else
        IUnknown_SetOwner(_psf, NULL);


    // BUGBUG: the below is bogus - no need to throw away and recreate.

    // First destroy the band proxy

    // Call SetSite(NULL) only if you own
    // if not, it's the parent from whom you got it via QS who will call SetSite(NULL)

    if(_pbp && _fCreatedBandProxy)
        _pbp->SetSite(NULL);

    ATOMICRELEASE(_pbp);
    _fCreatedBandProxy = FALSE;
    // Need a bandproxy
    QueryService_SID_IBandProxy(punkSite, IID_IBandProxy, &_pbp, NULL);
    if(!_pbp)
    {
        // We need to create it ourselves since our parent couldn't help
        ASSERT(FALSE == _fCreatedBandProxy);
        HRESULT hres;
        hres = CreateIBandProxyAndSetSite(punkSite, IID_IBandProxy, &_pbp, NULL);
        if(_pbp)
        {
            ASSERT(S_OK == hres);
            _fCreatedBandProxy = TRUE;
        }
    }

    ASSERT(_pbp);
    return S_OK;
}

void CISFBand::_Initialize()
{
    _fDesktop = (IsDesktopBrowser(_punkSite) == S_OK);

    return;
}


/*----------------------------------------------------------
Purpose: IDockingWindow::CloseDW method.

*/
HRESULT CISFBand::CloseDW(DWORD dw)
{
    _fClosing = TRUE;

    // close down the task scheduler ...
    if ( _pTaskScheduler )
        ATOMICRELEASE( _pTaskScheduler );

    _UnregisterToolbar();
    EmptyToolbar();

    IUnknown_SetOwner(_psf, NULL);
    _SetCacheMenuPopup(NULL);

    // should get freed in EmptyToolbar();
    ASSERT(!_hdpa);

    return SUPERCLASS::CloseDW(dw);
}


/*----------------------------------------------------------
Purpose: IDockingWindow::ShowDW method

*/
HRESULT CISFBand::ShowDW(BOOL fShow)
{
    HRESULT hres = S_OK;

    SUPERCLASS::ShowDW(fShow);

    if (fShow)
    {
        _fShow = TRUE;

        if (_fDirty)
        {
            _FillToolbar();
        }

        if (!_fDelayInit)
        {
            _RegisterToolbar();
        }
    }
    else
    {
        _fShow = FALSE;
    }

    return hres;
}

void CISFBand::_StopDelayPainting()
{
    if (_fDelayPainting) {
        _fDelayPainting = FALSE;
        // May be called by background thread
        // Use PostMessage instead of SendMessage to avoid deadlock
        PostMessage(_hwndTB, WM_SETREDRAW, TRUE, 0);
        if (_hwndPager)
            PostMessage(_hwnd, PGM_RECALCSIZE, 0L, 0L);
    }
}

HWND CISFBand::_CreatePager(HWND hwndParent)
{
    // don't create a pager for isfbands
    return hwndParent;
}

void CISFBand::_CreateToolbar(HWND hwndParent)
{
    if (_fHaveBkColor)
        _dwStyle |= TBSTYLE_CUSTOMERASE;
    CSFToolbar::_CreateToolbar(hwndParent);
    if ( _fHaveBkColor )
        ToolBar_SetInsertMarkColor(_hwndTB, GetSysColor( COLOR_BTNFACE ));

    ASSERT(_hwndTB);

    SendMessage(_hwndTB, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);

    if(_fChannels)
    {
        SHSetWindowBits(_hwndTB, GWL_EXSTYLE, dwExStyleRTLMirrorWnd, 0);        
    }    

    _hwnd = _hwndPager ? _hwndPager : _hwndTB;

    if (_fHaveColors)
    {
        COLORSCHEME cs;

        cs.dwSize = SIZEOF(cs);
        cs.clrBtnHighlight  = _crBtnLt;
        cs.clrBtnShadow     = _crBtnDk;
        SendMessage(_hwndTB, TB_SETCOLORSCHEME, 0, (LPARAM) &cs);
    }
}

int CISFBand::_GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache)
{
    int iBitmap;
    if ( _uIconSize == ISFBVIEWMODE_LOGOS )
    {
        LPRUNNABLETASK pTask = NULL;
        DWORD dwPriority = 0;
        // fetch the logo instead...
        ASSERT(!_fDelayPainting);
       // Warning - cannot hold ptask in a member variable - it will be a circular reference
        iBitmap = GetLogoIndex( iCommandID, pibdata->GetPidl(), &pTask, &dwPriority, NULL );
        if (pTask)
        {
            AddTaskToQueue(pTask, dwPriority, (DWORD)iCommandID);
            ATOMICRELEASE(pTask);
        }
    }
    else
        iBitmap = CSFToolbar::_GetBitmap(iCommandID, pibdata, fUseCache);

    return iBitmap;
}

void CISFBand::_SetDirty(BOOL fDirty)
{
    CSFToolbar::_SetDirty(fDirty);

    if (fDirty)
        IUnknown_Exec(_punkSite, &CGID_PrivCITCommands, CITIDM_SET_DIRTYBIT, TRUE, NULL, NULL);
}

BOOL CISFBand::_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons)
{
    BOOL fChanged = (_uIconSize != uIconSize);

    _uIconSize = uIconSize;
    HIMAGELIST himl = NULL;

    if ( uIconSize == ISFBVIEWMODE_LOGOS )
    {
        if ( SUCCEEDED( InitLogoView()))
        {
            himl = GetLogoHIML();
        }
        if ( himl )
        {
            SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);

            _UpdateButtons();
        }
    }

    if ( !himl )
        fChanged |= CSFToolbar::_UpdateIconSize(uIconSize,fUpdateButtons);
    return fChanged;
}

void CISFBand::_UpdateVerticalMode(BOOL fVertical)
{
    _fVertical = (fVertical != 0);

    TraceMsg(TF_BAND, "ISFBand::_UpdateVerticalMode going %hs", _fVertical ? "VERTICAL" : "HORIZONTAL");

    ASSERT(_hwnd);

    if (_hwndPager) {
        SHSetWindowBits(_hwnd, GWL_STYLE, PGS_HORZ|PGS_VERT,
            _fVertical ? PGS_VERT : PGS_HORZ);
    }

    if (_hwndTB)
    {
        SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_WRAPABLE | CCS_VERT,
            TBSTYLE_WRAPABLE | (_fVertical ? CCS_VERT : 0));
    }
}

HRESULT IUnknown_QueryBand(IUnknown *punk, DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName)
{
    HRESULT hr;
    IBandSite *pbs;

    hr = punk->QueryInterface(IID_IBandSite, (void**)&pbs);
    if (SUCCEEDED(hr)) {
        hr = pbs->QueryBand(dwBandID, ppstb, pdwState, pszName, cchName);
        pbs->Release();
    }
    return hr;
}

#define CISFBAND_GETBUTTONSIZE()  (_hwndTB ?  (LONG)SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0L) : MAKELONG(16, 16))

//
// _GetIdealSize
//
// calculates ideal height and width for band and passes back in
// psize, if psize isn't NULL; return value is band's 'ideal length'
// (ideal height if vertical, else ideal width)
//
int CISFBand::_GetIdealSize(PSIZE psize)
{
    SIZE size;
    LONG lButtonSize = CISFBAND_GETBUTTONSIZE();
    RECT rc = {0};
    if (_hwndTB)
        GetClientRect(_hwndTB, &rc);

    if (_fVertical)
    {
        // set width to be max of toolbar width and toolbar button width
        size.cx = max(RECTWIDTH(rc), LOWORD(lButtonSize));
        // have toolbar calculate height given that width
        SendMessage(_hwndTB, TB_GETIDEALSIZE, TRUE, (LPARAM)&size);
    }
    else
    {
        // set height to be max of toolbar width and toolbar button width
        size.cy = max(RECTHEIGHT(rc), HIWORD(lButtonSize));
        // have toolbar calculate width given that height
        SendMessage(_hwndTB, TB_GETIDEALSIZE, FALSE, (LPARAM)&size);
    }

    // BUGBUG: I'm ripping out this check as it causes nt5 bug #225449 (disappearing chevron).
    // _fDirty == TRUE doesn't mean "we're still waiting to call _FillToolbar", it just means
    // "we need to persist out this order stream".  The bit gets set after a drag-and-drop
    // reordering, but we don't call a matching _FillToolbar in that case.
#if 0
    if (_fDirty)
    {
        // until the TB is populated, we get back bogus data from the
        // above.  so use -1 until we actually have a correct answer.
        size.cx = size.cy = -1;
    }
#endif

    if (psize)
        *psize = size;
    return _fVertical ? size.cy : size.cx;
}

/*----------------------------------------------------------
Purpose: IDeskBand::GetBandInfo method

*/

HRESULT CISFBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode,
                              DESKBANDINFO* pdbi)
{
    HRESULT hr = S_OK;

    _dwBandID = dwBandID;
    // We don't know the default icon size until GetBandInfo is called.
    // After we set the default, we pay attention to the context menu.
    //
    if (!_fNoRecalcDefaults)
    {
        _uIconSize = (fViewMode & (DBIF_VIEWMODE_FLOATING |DBIF_VIEWMODE_VERTICAL)) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
        _fNoRecalcDefaults = TRUE;
    }

    if (!_fInitialized) {
        _fInitialized = TRUE;
        _UpdateIconSize(_uIconSize, FALSE);
        _UpdateShowText(_fNoShowText);
    }

    // we treat floating the same as vertical
    _UpdateVerticalMode(fViewMode & (DBIF_VIEWMODE_FLOATING |DBIF_VIEWMODE_VERTICAL));

    LONG lButtonSize = CISFBAND_GETBUTTONSIZE();

    pdbi->dwModeFlags = DBIMF_VARIABLEHEIGHT | DBIMF_USECHEVRON;
    if (_fDebossed)
        pdbi->dwModeFlags |= DBIMF_DEBOSSED;

    pdbi->ptMinSize.x = 0;
    pdbi->ptMaxSize.y = 32000; // random
    pdbi->ptIntegral.y = 1;
    pdbi->ptIntegral.x = 1;

    if (!_fFullOpen)
        _iIdealLength = _GetIdealSize((PSIZE)&pdbi->ptActual);

    // CalcMinWidthHeight {
    // BUGBUG need pager msg for cx/cy scroll
    #define g_cxScrollbar   (GetSystemMetrics(SM_CXVSCROLL) * 3 / 4)
    #define g_cyScrollbar   (GetSystemMetrics(SM_CYVSCROLL) * 3 / 4)
    #define CX_TBBUTTON_MAX (16 + CX_FILENAME_AVG)  // button + name
    #define CY_TBBUTTON_MAX (16)                    // button

    int csBut, csButMin, clBut, clButMin, clScroll;

    // set up short/long aliases
    if (_fVertical) {
        csBut = LOWORD(lButtonSize);
        if (_fBtnMinSize)
            csButMin = min(csBut, CX_TBBUTTON_MAX);
        else
            csButMin = 0;   // people like to shrink things way down, so let 'em

        clBut = HIWORD(lButtonSize);
        clButMin = clBut;
        //ASSERT(min(clBut, CY_TBBUTTON_MAX) == clButMin);  // fails!

        clScroll = g_cyScrollbar;
    }
    else {
        csBut = HIWORD(lButtonSize);
        csButMin = csBut;
        //ASSERT(min(csBut, CY_TBBUTTON_MAX) == csButMin);  // fails!

        clBut = LOWORD(lButtonSize);
        clButMin = min(clBut, CX_TBBUTTON_MAX);

        clScroll = g_cxScrollbar;

        // nt5:176448: integral for horz
        //pdbi->ptIntegral.y = csBut;   this is the cause for 287082 and 341592
    }

    // n.b. virt pdbi->pt.x,y is really phys y,x (i.e. phys long,short)
    pdbi->ptMinSize.x = 0;
    pdbi->ptMinSize.y = csButMin;

    DWORD dwState = BSSF_NOTITLE;
    IUnknown_QueryBand(_punkSite, dwBandID, NULL, &dwState, NULL, 0);
    if (dwState & BSSF_NOTITLE) {   // _fNoTitle
        int i, cBut, clTmp;

        // cbut=    text    notext
        // horz     1       4
        // vert     1       1
        cBut = 1;
        if (!_fVertical && _fNoShowText) {
            // special-case for QLaunch so see several buttons
            cBut = 4;   // for both QLaunch and arbitrary ISF band
        }

        pdbi->ptMinSize.x = cBut * clButMin;

        if (_hwndPager) {
            // tack on extra space for pager arrows
            pdbi->ptMinSize.x += 2 * clScroll;
        }

        i = (int)SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0);
        if (i <= cBut) {
            clTmp = i * clBut;
            if (clTmp < pdbi->ptMinSize.x) {
                // scrollbars take as much space as button would
                // so just do the button
                pdbi->ptMinSize.x = clTmp;
            }
        }
    }
    // }

#if 0 // BUGBUG don't we need this?
    if (_fHaveBkColor) {
        pdbi->crBkgnd = _crBkgnd;
        pdbi->dwModeFlags |= DBIMF_BKCOLOR;
    }
#endif

    hr = _GetTitleW(pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    if (FAILED(hr))
    {
        // we don't support title
#ifdef DEBUG
        if (pdbi->dwMask & DBIM_TITLE)
            TraceMsg(DM_VERBOSE, "cisfb.gbi: patch ~DBIM_TITLE");
#endif
        pdbi->dwMask &= ~DBIM_TITLE;
    }

    return hr;
}

LRESULT CISFBand::_OnCustomDraw(NMCUSTOMDRAW* pnmcd)
{
    NMTBCUSTOMDRAW * ptbcd = (NMTBCUSTOMDRAW *)pnmcd;
    LRESULT lres = CDRF_DODEFAULT;

    switch (pnmcd->dwDrawStage)
    {
    case CDDS_PREPAINT:
        // if there is a palette, then quietly select it into the DC ...
        if ( _hpalHalftone && _uIconSize == ISFBVIEWMODE_LOGOS )
        {
            ASSERT( pnmcd->hdc );
            _hpalOld = SelectPalette( pnmcd->hdc, _hpalHalftone, TRUE );
            // LINTASSERT(_hpalOld || !_hpalOld);   // 0 semi-ok for SelectPalette
            RealizePalette( pnmcd->hdc );
        }

        // make sure we get the postpaint as well so we can de-select the palette...
        lres = CDRF_NOTIFYPOSTPAINT;
        break;

    case CDDS_POSTPAINT:
        // if there is a palette, then quietly select it into the DC ...
        if ( _hpalHalftone && _uIconSize == ISFBVIEWMODE_LOGOS )
        {
            ASSERT( pnmcd->hdc );
            (void) SelectPalette( pnmcd->hdc, _hpalOld, TRUE );
            // we don't need a realize here, we can keep the other palette realzied, we
            // re select the old palette above, otherwise we bleed the resource....
            // RealizePalette( pnmcd->hdc );
        }
        break;

    case CDDS_PREERASE:
        if (_fHaveBkColor)
        {
            RECT rcClient;
            GetClientRect(_hwndTB, &rcClient);
            SHFillRectClr(pnmcd->hdc, &rcClient, _crBkgnd);
            lres = CDRF_SKIPDEFAULT;
        }
        break;
    }

    return lres;
}

void CISFBand::_OnDragBegin(int iItem, DWORD dwPreferedEffect)
{
    LPCITEMIDLIST pidl = _IDToPidl(iItem, &_iDragSource);
    ToolBar_MarkButton(_hwndTB, iItem, TRUE);

    DragDrop(_hwnd, _psf, pidl, dwPreferedEffect, NULL);

    ToolBar_MarkButton(_hwndTB, iItem, FALSE);
    _iDragSource = -1;
}

LRESULT CISFBand::_OnHotItemChange(NMTBHOTITEM * pnm)
{
    LPNMTBHOTITEM  lpnmhi = (LPNMTBHOTITEM)pnm;
    LRESULT lres = 0;

    if (_hwndPager && (lpnmhi->dwFlags & HICF_ARROWKEYS))
    {
        int iOldPos, iNewPos;
        RECT rc, rcPager;
        int heightPager;

        int iSelected = lpnmhi->idNew;
        iOldPos = (int)SendMessage(_hwnd, PGM_GETPOS, (WPARAM)0, (LPARAM)0);
        iNewPos = iOldPos;
        SendMessage(_hwndTB, TB_GETITEMRECT, (WPARAM)iSelected, (LPARAM)&rc);

        if (rc.top < iOldPos)
        {
             iNewPos =rc.top;
        }

        GetClientRect(_hwnd, &rcPager);
        heightPager = RECTHEIGHT(rcPager);

        if (rc.top >= iOldPos + heightPager)
        {
             iNewPos += (rc.bottom - (iOldPos + heightPager)) ;
        }

        if (iNewPos != iOldPos)
            SendMessage(_hwnd, PGM_SETPOS, (WPARAM)0, (LPARAM)iNewPos);
    }
    else
    {
        lres = CToolbarBand::_OnHotItemChange(pnm);
    }

    return lres;
}

LRESULT CISFBand::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;
    switch (pnm->code)
    {
    case TBN_DROPDOWN:
        {
            LPNMTOOLBAR pnmtb = (LPNMTOOLBAR)pnm;
            lres = TBDDRET_DEFAULT;
            _DropdownItem(_IDToPidl(pnmtb->iItem), pnmtb->iItem);
        }
        break;

    default:
        lres = CSFToolbar::_OnNotify(pnm);
    }

    return lres;
}


HRESULT CISFBand::_TBStyleForPidl(LPCITEMIDLIST pidl, 
                               DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon)
{
    HRESULT hres = CSFToolbar::_TBStyleForPidl(pidl, pdwTBStyle, pdwTBState, pdwMIFFlags, piIcon);

    if (_fAllowDropdown &&
        !_fCascadeFolder && 
        ((_GetAttributesOfPidl(pidl, SFGAO_FOLDER) & SFGAO_FOLDER) ||
         IsBrowsableShellExt(pidl)))
    {
        *pdwTBStyle &= ~BTNS_BUTTON;
        *pdwTBStyle |= BTNS_DROPDOWN;
    }
    return hres;
}

LRESULT CISFBand::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    lres = CSFToolbar::_OnContextMenu(wParam, lParam);

    // todo: csidl?
    TraceMsg(DM_MISC, "cib._ocm: _dwPriv=%d", _dwPriv);
    UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UICONTEXT, (_dwPriv == CSIDL_APPDATA || _dwPriv == CSIDL_FAVORITES) ? UIBL_CTXTQCUTITEM : UIBL_CTXTISFITEM);

    return lres;
}

LRESULT CISFBand::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
    case WM_SIZE:
        // forward to toolbar
        SendMessage(_hwndTB, TB_AUTOSIZE, wParam, lParam);

        if (_GetIdealSize(NULL) != _iIdealLength) {
            // our ideal size has changed since the last time bandsite
            // asked; so tell bandsite ask us for our bandinfo again
            _BandInfoChanged();
        }
        return 0;
    }
    return CSFToolbar::_DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/*----------------------------------------------------------
Purpose: Set the given IMenuPopup as the submenu to expand.  Returns
         S_FALSE if the menu was modal, S_OK if it was modeless, or
         failure.

*/
HRESULT CISFBand::_SetSubMenuPopup(IMenuPopup* pmp, UINT uiCmd, LPCITEMIDLIST pidl, DWORD dwFlagsMPPF)
{
    HRESULT hres = E_FAIL;

    _ReleaseMenu();

    _pmp = pmp;

    if (pmp) {

        pmp->AddRef();

        RECT rc;
        POINT pt;

        SendMessage(_hwndTB, TB_GETRECT, uiCmd, (LPARAM)&rc);
        MapWindowPoints(_hwndTB, HWND_DESKTOP, (POINT*)&rc, 2);

        // Align the sub menu appropriately
        if (_fVertical) {
            pt.x = rc.right;
            pt.y = rc.top;
        } else {
            pt.x = rc.left;
            pt.y = rc.bottom;
        }

        //
        // Use a reflect point for the sub-menu to start
        // if the window is RTL mirrored. [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(_hwndTB)) {
            pt.x = (_fVertical) ? rc.left : rc.right;
        }

        // Tell the sub menu deskbar who we are, so it can
        // inform us later when the user navigates out of
        // its scope.
        IUnknown_SetSite(_pmp, SAFECAST(this, IDeskBand*));

        // This must be called after SetSite is done above
        _SendInitMenuPopup(pmp, pidl);

        // Show the menubar
        hres = _pmp->Popup((POINTL*)&pt, (RECTL*)&rc, dwFlagsMPPF);
    }
    return hres;
}

void CISFBand::_SendInitMenuPopup(IMenuPopup * pmp, LPCITEMIDLIST pidl)
{
}

IMenuPopup* ISFBandCreateMenuPopup(IUnknown *punk, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand)
{
    return ISFBandCreateMenuPopup2(punk, NULL, psf, pidl, pbi, bMenuBand);
}


IMenuPopup* ISFBandCreateMenuPopup2(IUnknown *punk, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand)
{
    IMenuPopup* pmpParent = NULL;
    VARIANTARG v = {0};
    BOOL fUseCache = FALSE;

    if (punk && pidl) {
        fUseCache = TRUE;
        IUnknown_Exec(punk, &CGID_ISFBand, ISFBID_CACHEPOPUP, 0, NULL, &v);
        if (v.vt == VT_UNKNOWN && v.punkVal)
            v.punkVal->QueryInterface(IID_IMenuPopup, (void **)&pmpParent);
    }

    IMenuPopup * pmp = CreateMenuPopup2(pmpParent, pmb, psf, pidl, pbi, bMenuBand);

    if (fUseCache) {
        // cache it now

        // clear from the variant above to release v.punkVal of pmpParent
        VariantClear(&v);

        if (pmp) {
            VariantInit(&v);
            v.vt = VT_UNKNOWN;
            v.punkVal = pmp;
            pmp->AddRef();
            IUnknown_Exec(punk, &CGID_ISFBand, ISFBID_CACHEPOPUP, 0, &v, NULL);
            VariantClear(&v);
        }
    }

    ATOMICRELEASE(pmpParent);
    return pmp;
}


IMenuPopup * CISFBand::_CreateMenuPopup(
    IShellFolder * psfChild,
    LPCITEMIDLIST  pidlFull,
    BANDINFOSFB *  pbi)
{
    return ISFBandCreateMenuPopup(SAFECAST(this, IOleCommandTarget*), psfChild, pidlFull, pbi, FALSE);
}

HRESULT CISFBand::_DropdownItem(LPCITEMIDLIST pidl, UINT idCmd)
{
    HRESULT hres = E_FAIL;
    if (_pidl && _psf)
    {
        LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);

        if (pidlFull)
        {
            IShellFolder* psf;

            if (SUCCEEDED(_psf->BindToObject(pidl, NULL, IID_IShellFolder, (void **)&psf)))
            {
                RECT rc;
                SendMessage(_hwndTB, TB_GETRECT, idCmd, (LPARAM)&rc);
                MapWindowPoints(_hwndTB, HWND_DESKTOP, (POINT*)&rc, 2);

                ITrackShellMenu* ptsm;
                if (SUCCEEDED(CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER,
                    IID_ITrackShellMenu, (void**)&ptsm)))
                {
                    CFavoritesCallback *pfcb = new CFavoritesCallback();
                    if(pfcb) {
                        ptsm->Initialize(pfcb, 0, 0, SMINIT_TOPLEVEL | SMINIT_VERTICAL|SMINIT_NOSETSITE);
                        pfcb->SetSite(_punkSite);
                    }
                    else 
                        ptsm->Initialize(NULL, 0, 0, SMINIT_TOPLEVEL | SMINIT_VERTICAL);


                    if (SUCCEEDED(ptsm->SetShellFolder(psf, pidlFull, NULL, SMSET_TOP | SMSET_USEBKICONEXTRACTION)))
                    {
                        POINTL pt = {rc.left, rc.right};
                        hres = ptsm->Popup(_hwndTB, &pt, (RECTL*)&rc, MPPF_BOTTOM);
                    }
                    if(pfcb)
                        pfcb->Release();

                    ptsm->Release();
                }
                psf->Release();
            }

            ILFree(pidlFull);
        }
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: Try treating the pidl as a cascading menu item.

Returns: non-zero if succeeded
*/
LRESULT CISFBand::_TryCascadingItem(LPCITEMIDLIST pidl, UINT uiCmd)
{
    LRESULT lRet = 0;

    // Do we cascade to another submenu?
    if ((GetKeyState(VK_CONTROL) < 0) || _fCascadeFolder)
    {
        // Is the item a browsable folder?
        if ((_GetAttributesOfPidl(pidl, SFGAO_FOLDER) & SFGAO_FOLDER) ||
            IsBrowsableShellExt(pidl))
        {
            // Yes; cascade the browsable folder as a submenu
            lRet = (S_OK == _DropdownItem(pidl, uiCmd));
        }
    }

    return lRet;
}

/*----------------------------------------------------------
Purpose: Try just invoking the pidl

Returns: non-zero if succeeded
*/
LRESULT CISFBand::_TrySimpleInvoke(LPCITEMIDLIST pidl)
{
    LRESULT lRet = 0;

    if (S_OK == _pbp->IsConnected())    // Force IE
    {
        LPITEMIDLIST pidlDest;

        if (SUCCEEDED(SHGetNavigateTarget(_psf, pidl, &pidlDest, NULL)) && pidlDest &&
            ILIsWeb(pidlDest))
        {

            TCHAR szPath[MAX_PATH];

            // We want to ensure that we first give NavFrameWithFile a chance
            // since this will do the right thing if the PIDL points to a
            // shortcut.
            // If the PIDL is a shortcut, NavFrameWithFile will restore any
            // persistence information stored in the shortcut
            // if that fails - we take the default code path that simply
            // uses the PIDL
            lRet = SUCCEEDED(GetPathForItem(_psf, pidl, szPath, NULL)) &&
                   SUCCEEDED(NavFrameWithFile(szPath, (IServiceProvider *)this));

            if (!lRet)
            {
                if (EVAL(_pbp) && (SUCCEEDED(_pbp->NavigateToPIDL(pidlDest))))
                    lRet = 1;
            }
            ILFree(pidlDest);
        }
    }

    if (!lRet)
    {
        IContextMenu *pcm = (LPCONTEXTMENU)_GetUIObjectOfPidl(pidl, IID_IContextMenu);
        if (pcm)
        {
            LPCSTR pVerb = NULL;
            UINT fFlags = 0;

            // If ALT double click, accelerator for "Properties..."
            if (GetKeyState(VK_MENU) < 0)
            {
                pVerb = SZ_PROPERTIESA;
            }

            //
            //  SHIFT+dblclick does a Explore by default
            //
            if (GetKeyState(VK_SHIFT) < 0)
            {
                fFlags |= CMF_EXPLORE;
            }

            IContextMenu_Invoke(pcm, _hwndTB, pVerb, fFlags);

            pcm->Release();
        }
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Helper function to call the menubar site's IMenuPopup::OnSelect
         method.

*/
HRESULT CISFBand::_SiteOnSelect(DWORD dwType)
{
    IMenuPopup * pmp;
    HRESULT hres = IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_IMenuPopup, (void **)&pmp);
    if (SUCCEEDED(hres))
    {
        pmp->OnSelect(dwType);
        pmp->Release();
    }
    return hres;
}

LRESULT CISFBand::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uiCmd = GET_WM_COMMAND_ID(wParam, lParam);
    LRESULT lres = 0;

    TraceMsg(TF_BAND, "_OnCommand 0x%x", uiCmd);

    LPCITEMIDLIST pidl = _IDToPidl(uiCmd);

    if (pidl)
    {
        if (_eUemLog != UEMIND_NIL) 
        {
            // FEATURE_UASSIST should be grp,uiCmd
            UEMFireEvent(&UEMIID_SHELL, UEME_UIQCUT, UEMF_XEVENT, -1, (LPARAM)-1);
        }

        // Only do this if we are the quick links in the browser. The derived class will set this
        if (_pguidUEMGroup)
        {
            LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);
            if (pidlFull)
            {
                UEMFireEvent(_pguidUEMGroup, UEME_RUNPIDL, UEMF_XEVENT, (WPARAM)_psf, (LPARAM)pidl);
                SHSendChangeMenuNotify(NULL, SHCNEE_PROMOTEDITEM, 0, pidlFull);
                ILFree(pidlFull);
            }
        }

        lres = _TryCascadingItem(pidl, uiCmd);

        if (!lres && _fChannels)
            lres = _TryChannelSurfing(pidl);

        if (!lres)
            lres = _TrySimpleInvoke(pidl);
    }
    else
    {
        MessageBeep(MB_OK);
    }

    return(lres);
}

// *** IPersistStream
//

HRESULT CISFBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_ISFBand;
    return S_OK;
}

//
//  This might be a directory inside CSIDL_APPDATA that was created on
//  a Win9x machine.  Win9x doesn't do the special folder signature info,
//  so when it shows up on NT, it's just a boring directory that now points
//  to the wrong place.
//
//  So if we get a bad directory, see if it's one of these corrupted
//  Win9x pidls and if so, try to reconstitute the original CSIDL_APPDATA
//  by searching for "Application Data".
//

void CISFBand::_FixupAppDataDirectory()
{
    TCHAR szDirPath[MAX_PATH];

    //  We use PathFileExists to check for existence because it turns off
    //  hard error boxes if the target is not available (e.g., floppy not
    //  in drive)

    if (SHGetPathFromIDList(_pidl, szDirPath) &&
        !PathFileExists(szDirPath))
    {
        static TCHAR szBSAppData[] = TEXT("\\Application Data");
        LPTSTR pszAppData;

        // For every instance of "Application Data", try to graft it
        // into the real CSIDL_APPDATA. If it works, run with it.

        for (pszAppData = szDirPath;
             pszAppData = StrStrI(pszAppData, szBSAppData);
             pszAppData++)
        {
            // Found a candidate.  The thing after "\\Application Data"
            // had better be another backslash (in which case we step
            // over it) or the end of the string (in which case we don't).

            TCHAR szPathBuffer[MAX_PATH];
            LPTSTR pszTail = pszAppData + ARRAYSIZE(szBSAppData) - 1;

            // If we did our math right, we should be right after the
            // "a" at the end of "Application Data".
            ASSERT(pszTail[-1] == TEXT('a'));

            if (pszTail[0] == TEXT('\\'))
                pszTail++;              // Step over separator
            else if (pszTail[0] == TEXT('\0'))
                { }                     // at end of string; stay there
            else
                continue;               // we were faked out; keep looking

            if (SHGetSpecialFolderPath(NULL, szPathBuffer, CSIDL_APPDATA, FALSE))
            {
                PathCombine(szPathBuffer, szPathBuffer, pszTail);
                if (PathFileExists(szPathBuffer))
                {
                    LPITEMIDLIST    pidlReal;
                    pidlReal = ILCreateFromPath(szPathBuffer);
                    if (pidlReal)
                    {
                        ILFree(_pidl);
                        _pidl = pidlReal;
                    }
                    ASSERT(_pidl);
                    break;              // found it; stop looking
                }
            }
        }
    }
}

typedef struct tagBANDISFSTREAM {
    WORD        wVersion;   // version of this structure
    WORD        cbSize;     // size of this structure
    DWORD       dwFlags;    // BANDISF_ flags
    DWORD       dwPriv;     // special folder identifier
    WORD        wViewMode;  // small/large/logo
    WORD        wUnused;    // For DWORD alignment
    COLORREF    crBkgnd;    // band background color
    COLORREF    crBtnLt;    // band button hilite color
    COLORREF    crBtnDk;    // band button lolite color
} BANDISFSTREAM, * PBANDISFSTREAM;

#define BANDISF_VERSION 0x22

#define BANDISF_MASK_PSF         0x00000001 // TRUE if _psf is saved
#define BANDISF_BOOL_NOSHOWTEXT  0x00000002 // TRUE if _fNoShowText
#define BANDISF_BOOL_LARGEICON   0x00000004 // last used in version 0x20
#define BANDISF_MASK_PIDLASLINK  0x00000008 // TRUE if _pidl is saved as a link
#define BANDISF_UNUSED10         0x00000010 // (obsolete) was BOOL_NOTITLE
#define BANDISF_BOOL_CHANNELS    0x00000020 // TRUE if in channel mode
#define BANDISF_BOOL_ALLOWRENAME 0x00000040 // TRUE if _psf context menu should be enabled
#define BANDISF_BOOL_DEBOSSED    0x00000080 // TRUE if band should have embossed background
#define BANDISF_MASK_ORDERLIST   0x00000100 // TRUE if an order list is saved
#define BANDISF_BOOL_BKCOLOR     0x00000200 // TRUE if bk color is persisted
#define BANDISF_BOOL_FULLOPEN    0x00000400 // TRUE if band should maximize when opened
#define BANDISF_BOOL_NONAMESORT  0x00000800 // TRUE if band should _not_ sort icons by name
#define BANDISF_BOOL_BTNMINSIZE  0x00001000 // TRUE if band should report min thickness of button
#define BANDISF_BOOL_COLORS      0x00002000 // TRUE if colors are persisted
#define BANDISF_VALIDBITS        0x00003FFF

HRESULT CISFBand::Load(IStream *pstm)
{
    HRESULT hres;
    DWORD cbRead;
    BANDISFSTREAM bisfs = {0};

    // figure out what we need to load
    //
    // read first DWORD only (old stream format started with ONE dword)
    hres = pstm->Read(&bisfs, SIZEOF(DWORD), &cbRead);

    if (SUCCEEDED(hres))
    {
        if (bisfs.cbSize == 0)
        {
            // upgrade case, IE4 beta1 shipped this way
            //
            bisfs.dwFlags = *((LPDWORD)&bisfs);
            bisfs.cbSize = SIZEOF(bisfs);
            bisfs.wVersion = BANDISF_VERSION;
            bisfs.dwPriv = -1;
            bisfs.wViewMode = (bisfs.dwFlags & BANDISF_BOOL_LARGEICON) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
        }
        else
        {
            // read rest of stream
            //
            DWORD dw = (DWORD)bisfs.cbSize;
            if (dw > SIZEOF(bisfs))
                dw = SIZEOF(bisfs);
            dw -= SIZEOF(DWORD);
            hres = pstm->Read(&(bisfs.dwFlags), dw, &cbRead);
            if (FAILED(hres))
                return(hres);
        }

        // HEY, DON'T BE LAME ANY MORE.  When you next touch this code,
        // I suggest you figure out what sizes of this structure have
        // been actually shipped and only upgrade those.  Also use
        // the offsetof macro so you don't have to keep calculating these
        // things...

        // old upgrade, I don't know what state is persisted at setup time!
        //
        if (bisfs.cbSize == SIZEOF(bisfs) - 3*SIZEOF(COLORREF) - SIZEOF(DWORD) - SIZEOF(DWORD))
        {
            bisfs.dwPriv = -1;
            bisfs.cbSize += SIZEOF(DWORD);
        }
        // most recent upgrade, this is NOT persisted in registry at setup time!!!
        //
        if (bisfs.cbSize == SIZEOF(bisfs) - 3*SIZEOF(COLORREF) - SIZEOF(DWORD))
        {
            bisfs.wViewMode = (bisfs.dwFlags & BANDISF_BOOL_LARGEICON) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
            bisfs.cbSize = SIZEOF(bisfs);
        }
        // upgrade from version 0x21 + crBkgnd only to 0x22
        //
        if (bisfs.cbSize == SIZEOF(bisfs) - 2*SIZEOF(COLORREF))
        {
            bisfs.cbSize = SIZEOF(bisfs);
        }
        // upgrade from version 0x21 to 0x22
        //
        if (bisfs.cbSize == SIZEOF(bisfs) - 3*SIZEOF(COLORREF))
        {
            bisfs.cbSize = SIZEOF(bisfs);
        }

        if (!EVAL(bisfs.cbSize >= SIZEOF(bisfs)))
        {
            return(E_FAIL);
        }
        ASSERT(!(bisfs.dwFlags & ~BANDISF_VALIDBITS));

        if (bisfs.dwFlags & BANDISF_BOOL_NOSHOWTEXT)
            _fNoShowText = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_ALLOWRENAME)
            _fAllowRename = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_DEBOSSED)
            _fDebossed = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_FULLOPEN)
            _fFullOpen = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_NONAMESORT)
            _fNoNameSort = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_BTNMINSIZE)
            _fBtnMinSize = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_BKCOLOR)
        {
            _crBkgnd = bisfs.crBkgnd;
            _fHaveBkColor = TRUE;
        }
        if (bisfs.dwFlags & BANDISF_BOOL_COLORS)
        {
            _crBtnLt = bisfs.crBtnLt;
            _crBtnDk = bisfs.crBtnDk;
            _fHaveColors = TRUE;
        }

        _dwPriv = bisfs.dwPriv;
#if 1 // BUGBUG FEATURE_UASSIST hack this should be persisted not recalc'ed
#define UEMIsLogCsidl(dwPrivID)    ((dwPrivID) == CSIDL_APPDATA)
        if (UEMIsLogCsidl(_dwPriv)) {
            _eUemLog = UEMIND_SHELL;
        }
#endif

        _uIconSize = bisfs.wViewMode;
        _fNoRecalcDefaults = TRUE;

        if (bisfs.dwFlags & BANDISF_MASK_PIDLASLINK)
        {
            ASSERT(NULL==_pidl);
            hres = LoadPidlAsLink(_punkSite, pstm, &_pidl);
            // If we hit hits, LoadPidlAsLink() read a chuck of our data. - BryanSt
            ASSERT(SUCCEEDED(hres));

//            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
//            TraceMsg(TF_BAND|TF_GENERAL, "CISFBand::Load() _pidl=>%s<", Dbg_PidlStr(_pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

            _FixupAppDataDirectory();

        }
                
        if (SUCCEEDED(hres) && (bisfs.dwFlags & BANDISF_MASK_PSF))
        {
            ASSERT(NULL == _psf);
            hres = OleLoadFromStream(pstm, IID_IShellFolder, (void **)&_psf);
        }

        // map this to working info
        //
        if (SUCCEEDED(hres))
            _AfterLoad();

        // we need _psf before we can read the order list.
        if (SUCCEEDED(hres) && (bisfs.dwFlags & BANDISF_MASK_ORDERLIST))
        {
            hres = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);

            if (SUCCEEDED(hres))
            {
                // _fDropped "persists" along with the orderlist - if this flag
                // is set, we assume we have a non-default ordering
                _fDropped = TRUE;
            }
        }
    }

    return hres;
}

HRESULT SaveIsfToStream(IShellFolder *psf, IStream *pstm)
{
    IPersistStream* pps;
    HRESULT hres = psf->QueryInterface(IID_IPersistStream, (void **)&pps);
    if (SUCCEEDED(hres))
    {
        hres = OleSaveToStream(pps, pstm);

        pps->Release();
    }
    return hres;
}

HRESULT CISFBand::Save(IStream *pstm, BOOL fClearDirty)
{
    IPersistStream* pps = NULL;
    HRESULT hres;
    BANDISFSTREAM bisfs = {0};

    // figure out what we will save
    //
    if (_pidl)
        bisfs.dwFlags |= BANDISF_MASK_PIDLASLINK;

    // BUGBUG(lamadio): This case is busted. None of the IShellFolders implement IPersistStream (at least as far as
    // TJ and I can see). Qhen quick links initializes, it will set the pidlQuickLinks as the _pidl. So, in the 
    // After load, _fPSFBandDesktop gets set to TRUE. Why? I don't know. Well, then we never attempt to persist the 
    // IShellFolder and we will never fail the save. We should remove this case so we don't run into this again.
    if (_psf && !_fPSFBandDesktop)
        bisfs.dwFlags |= BANDISF_MASK_PSF;
    if (_fDropped && (_hdpa || _hdpaOrder)) // only if a drop occurred do we have non-default ordering
        bisfs.dwFlags |= BANDISF_MASK_ORDERLIST;

    if (_fNoShowText)
        bisfs.dwFlags |= BANDISF_BOOL_NOSHOWTEXT;
    if (_fAllowRename)
        bisfs.dwFlags |= BANDISF_BOOL_ALLOWRENAME;
    if (_fDebossed)
        bisfs.dwFlags |= BANDISF_BOOL_DEBOSSED;
    if (_fFullOpen)
        bisfs.dwFlags |= BANDISF_BOOL_FULLOPEN;
    if (_fNoNameSort)
        bisfs.dwFlags |= BANDISF_BOOL_NONAMESORT;
    if (_fBtnMinSize)
        bisfs.dwFlags |= BANDISF_BOOL_BTNMINSIZE;
    if (_fHaveBkColor)
    {
        bisfs.dwFlags |= BANDISF_BOOL_BKCOLOR;
        bisfs.crBkgnd = _crBkgnd;
    }
    if (_fHaveColors)
    {
        bisfs.dwFlags |= BANDISF_BOOL_COLORS;
        bisfs.crBtnLt = _crBtnLt;
        bisfs.crBtnDk = _crBtnDk;
    }

    bisfs.cbSize = SIZEOF(bisfs);
    bisfs.wVersion = BANDISF_VERSION;
    bisfs.dwPriv = _dwPriv;
    bisfs.wViewMode = _uIconSize;

    // now save it
    //
    hres = pstm->Write(&bisfs, SIZEOF(bisfs), NULL);

    if (SUCCEEDED(hres) && bisfs.dwFlags & BANDISF_MASK_PIDLASLINK)
    {
        hres = SavePidlAsLink(_punkSite, pstm, _pidl);
        // BUGBUG: We need to save a terminator.
    }

    if (SUCCEEDED(hres) && bisfs.dwFlags & BANDISF_MASK_PSF)
    {
        hres = SaveIsfToStream(_psf, pstm);
    }

    if (SUCCEEDED(hres) && (bisfs.dwFlags & BANDISF_MASK_ORDERLIST))
    {
        hres = OrderList_SaveToStream(pstm, (_hdpa ? _hdpa : _hdpaOrder), _psf);
    }


    return(hres);
}

#if 0
// IPersistPropertyBag implementation
//
HRESULT CISFBand::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog)
{
    ASSERT(0);  // obsolete!
    _fCascadeFolder = PropBag_ReadInt4(pPropBag, L"Cascade", FALSE);
    // n.b. old "Title" property nuked
    _uIconSize = (PropBag_ReadInt4(pPropBag, L"Large", TRUE) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS);
    _fNoShowText = PropBag_ReadInt4(pPropBag, L"Text", TRUE);

    return(S_OK);
}
HRESULT CISFBand::Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return(E_NOTIMPL);
}
HRESULT CISFBand::InitNew()
{
    ASSERT(0);  // obsolete!
    return(E_NOTIMPL);
}
#endif

// IContextMenu implementation
//
HRESULT CISFBand::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    BOOL fChanged = FALSE;
    int idCmd = -1;

    UINT uNewMode = 0;
    if (!HIWORD(lpici->lpVerb))
        idCmd = LOWORD(lpici->lpVerb);
    switch (idCmd)
    {
    case ISFBIDM_LARGE:
        uNewMode = ISFBVIEWMODE_LARGEICONS;
        goto newViewMode;

    case ISFBIDM_SMALL:
        uNewMode = ISFBVIEWMODE_SMALLICONS;
newViewMode:
        if (uNewMode != _uIconSize)
        {
            BOOL fRefresh = FALSE;

            if (uNewMode == ISFBVIEWMODE_LOGOS || _uIconSize == ISFBVIEWMODE_LOGOS)
            {
                // invalidate all before switching the imagelist...
                _RememberOrder();

                EmptyToolbar();
                fRefresh = TRUE;
            }

            // we Logo view has now left the building...
            if ( uNewMode != ISFBVIEWMODE_LOGOS && _uIconSize == ISFBVIEWMODE_LOGOS )
            {
                ExitLogoView();
            }

            fChanged = _UpdateIconSize(uNewMode, TRUE);

            if ( fRefresh )
            {
                _FillToolbar();
            }
            if (fChanged)
                _BandInfoChanged();
        }
        // fall thru
    default:
        return CSFToolbar::InvokeCommand(lpici);
    }

    return(S_OK);
}

// *** IOleCommandTarget methods ***

STDMETHODIMP CISFBand::QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_ISFBand, *pguidCmdGroup))
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case ISFBID_CACHEPOPUP:
            case ISFBID_ISITEMVISIBLE:
            case ISFBID_PRIVATEID:
                rgCmds[i].cmdf |= OLECMDF_SUPPORTED;
                break;
            }
        }
        hr = S_OK;
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case SHDVID_UEMLOG:
                rgCmds[i].cmdf |= OLECMDF_SUPPORTED;
                break;
            }
        }
        hr = S_OK;
    }

    return hr;
}

HRESULT CISFBand::_IsPidlVisible(LPITEMIDLIST pidl)
{
    int i;

    if (_GetButtonFromPidl(pidl, NULL, &i)) {
        RECT rc;
        GetClientRect(_hwndTB, &rc);

        if (SHIsButtonObscured(_hwndTB, &rc, i))
            return S_FALSE;
        else
            return S_OK;
    }

    return E_FAIL;
}

HRESULT CISFBand::_OrderListFromIStream(VARIANT* pvarargIn)
{
    HRESULT hres = E_FAIL;
    if (pvarargIn->vt == VT_UNKNOWN)
    {
        IStream* pstm;
        if (SUCCEEDED(pvarargIn->punkVal->QueryInterface(IID_IStream, (void**)&pstm)))
        {
            OrderList_Destroy(&_hdpaOrder);
            hres = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);
            if (SUCCEEDED(hres))
            {
                _SetDirty(TRUE);
                if (_fShow)
                {
                    _FillToolbar();
                }
            }
            pstm->Release();
        }
    }

    return hres;
}

HRESULT CISFBand::_IStreamFromOrderList(VARIANT* pvarargOut)
{
    HRESULT hres = E_OUTOFMEMORY;
    ASSERT(pvarargOut != NULL);

    IStream* pstm = SHCreateMemStream(NULL, 0);
    if (pstm)
    {
        hres = OrderList_SaveToStream(pstm, _hdpa, _psf);
        if (SUCCEEDED(hres))
        {
            pvarargOut->vt = VT_UNKNOWN;
            pvarargOut->punkVal = pstm;
            pvarargOut->punkVal->AddRef();
        }
        pstm->Release();
    }

    return hres;
}

STDMETHODIMP CISFBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_ISFBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case ISFBID_CACHEPOPUP:
            if (pvarargIn && pvarargIn->vt == VT_UNKNOWN)
            {
                IMenuPopup* pmp = NULL;
                if (pvarargIn->punkVal)
                    pvarargIn->punkVal->QueryInterface(IID_IMenuPopup, (void **)&pmp);

                _SetCacheMenuPopup(pmp);

                ATOMICRELEASE(pmp);
            }

            if (pvarargOut)
            {
                pvarargOut->vt = VT_UNKNOWN;
                pvarargOut->punkVal = _pmpCache;
                if (_pmpCache)
                    _pmpCache->AddRef();
            }
            return S_OK;

        case ISFBID_ISITEMVISIBLE:
            {
                HRESULT hr = E_INVALIDARG;

                if (pvarargIn && pvarargIn->vt == VT_INT_PTR)
                    hr = _IsPidlVisible((LPITEMIDLIST)pvarargIn->byref);

                return hr;
            }

        case ISFBID_PRIVATEID:
            // hack hack for BSMenu to differentiate between specially created
            // isfbands. see bsmenu's _FindBand
            // if pvarargOut is set, we give back the id we have stored.
            if (pvarargOut)
            {
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _dwPriv;
            }
            // if pvarargIn is set, then we take and keep this id.
            if (pvarargIn && pvarargIn->vt == VT_I4)
                _dwPriv = pvarargIn->lVal;

            return S_OK;

        case ISFBID_GETORDERSTREAM:
            return _IStreamFromOrderList(pvarargOut);

        case ISFBID_SETORDERSTREAM:
            return _OrderListFromIStream(pvarargIn);
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SHDVID_UEMLOG:
            ASSERT(pvarargOut == NULL);
            // if pvarargIn is set, then we take and keep this id.
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                _eUemLog = pvarargIn->lVal;
                ASSERT(_eUemLog == UEMIND_SHELL || _eUemLog == UEMIND_BROWSER);
            }

            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_DeskBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBID_DELAYINIT:
            _fDelayInit = TRUE;
            break;

        case DBID_FINISHINIT:
            _fDelayInit = FALSE;
            _RegisterToolbar();
            break;
        }
        return S_OK;
    }
    
    return OLECMDERR_E_NOTSUPPORTED;
}

IShellFolder * CISFBand::GetSF()
{
    ASSERT( _psf );
    return _psf;
}

HWND CISFBand::GetHWND()
{
    return _hwndTB;
}

REFTASKOWNERID CISFBand::GetTOID()
{
    return TOID_ExtractImage;
}

HRESULT CISFBand::OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (lEvent == SHCNE_RMDIR && _IsEqualID(pidl1))
    {
        HRESULT hres = E_FAIL;
        IBandSite *pbandSite;
        if (_punkSite)
        {
            hres = _punkSite->QueryInterface(IID_IBandSite, (void **)&pbandSite);
            if (EVAL(SUCCEEDED(hres))) 
            {
                pbandSite->RemoveBand(_dwBandID);
                pbandSite->Release();
            }
        }
        return hres;
    }
    else
    {
        return CSFToolbar::OnTranslatedChange(lEvent, pidl1, pidl2);
    }
}

HRESULT CISFBand::UpdateLogoCallback( DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache )
{
    int iItem = (int)dwItem;
    HRESULT hr;
    UINT uImage;

    // catch if we are closing...
    if ( _fClosing )
        return NOERROR;

    IMAGECACHEINFO rgInfo;
    rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_LARGE | ICIFLAG_BITMAP | ICIFLAG_NOUSAGE;
    rgInfo.cbSize = sizeof( rgInfo );
    rgInfo.pszName = pszCache;

    rgInfo.hBitmapLarge = hImage;

    ASSERT(_pLogoCache);
    if (_pLogoCache)
        hr = _pLogoCache->AddImage( &rgInfo, &uImage );
    else
        hr = E_FAIL;

    // catch if we are closing...
    if ( _fClosing )
        return NOERROR;

    if ( SUCCEEDED( hr ))
    {
        // remember the icon to logo mapping....
        AddIndicesToLogoList( iIcon, uImage );

        // catch we are closing before we try and doa bloc
        PostMessage( _hwndTB, TB_CHANGEBITMAP, iItem, uImage );
    }

    // stop delay painting when the last extract image task calls back
    if (_fDelayPainting) {
        if (_pTaskScheduler && _pTaskScheduler->CountTasks(TOID_NULL) == 1) {
            _StopDelayPainting();
        }
    }

    return hr;
}

// }


HRESULT CISFBand::_GetTitleW(LPWSTR pwszTitle, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    TraceMsg(TF_BAND, "Calling baseclass CISFBand::_GetTitleW");

    if (!EVAL(pwszTitle))
        return E_INVALIDARG;

    *pwszTitle = 0;
    if (_pidl)
    {
        hr = SHGetNameAndFlagsW(_pidl, SHGDN_NORMAL, pwszTitle, cchSize, NULL);
    }
    else if (_psf && !_fPSFBandDesktop)
    {
#ifdef BUSTED
        // BUGBUG (scotth):  We cannot call GetDisplayNameOf with NULL pidl.
        //                   We must change this code so _pidl is always
        //                   valid, and key off a flag to determine whether
        //                   to receive notifies.  Remove this code once
        //                   that is done.

        STRRET strret;

        if (SUCCEEDED(_psf->GetDisplayNameOf(NULL, SHGDN_NORMAL, &strret)))
            StrRetToBufW(&strret, NULL, pwszTitle, cchSize);
#endif

    }

    return hr;
}

STDAPI NavigateToPIDL(IWebBrowser2* pwb, LPCITEMIDLIST pidl);

HRESULT FakeGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl);


LRESULT CISFBand::_TryChannelSurfing(LPCITEMIDLIST pidl)
{
    LRESULT lRet = 0;

    ASSERT(_fChannels);

    LPITEMIDLIST pidlTarget;

    HRESULT hr = SHGetNavigateTarget(_psf, pidl, &pidlTarget, NULL);

    // channel category folders hack.
    if (FAILED(hr))
        hr = FakeGetNavigateTarget(_psf, pidl, &pidlTarget);

    if (SUCCEEDED(hr))
    {
        IWebBrowser2* pwb;

        // n.b. careful! only one of GCB and C_OB up the refcnt
        _GetChannelBrowser(&pwb);
        if (SUCCEEDED(Channels_OpenBrowser(&pwb, pwb != NULL)))
        {
            lRet = 1;   // success at this point

            if (SUCCEEDED(NavigateToPIDL(pwb, pidlTarget)))
            {
                LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);
                if (pidlFull)
                {
                    VARIANT varURLpidl, flags;
                    flags.vt = VT_I4;
                    flags.lVal = navBrowserBar;
                    if (SUCCEEDED(InitVariantFromIDList(&varURLpidl, pidlFull)))
                    {
                        pwb->Navigate2(&varURLpidl, &flags, PVAREMPTY, PVAREMPTY, PVAREMPTY);
                        VariantClear(&varURLpidl);
                    }
                    ILFree(pidlFull);
                }
            }
        }
        if (pwb)
            pwb->Release();

        ILFree(pidlTarget);
    }

    return lRet;
}

//***   _GetChannelBrowser -- find appropriate browser for surfing
// DESCRIPTION
//  for the DTBrowser case, we fail (pwb=NULL, hr=S_FALSE) so that our
// caller will create a new SHBrowser (which can be put into theater mode).
// for the SHBrowser case, we find the top-level browser (so we'll navigate
// in-place).
HRESULT CISFBand::_GetChannelBrowser(IWebBrowser2 **ppwb)
{
    HRESULT hr;
    IServiceProvider *psp;

    *ppwb = NULL;   // assume failure
    if (_fDesktop) {
        ASSERT(*ppwb == NULL);
        hr = S_FALSE;
    }
    else {
        hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_IServiceProvider, (void**)&psp);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr)) {
            hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void **)ppwb);
            ASSERT(SUCCEEDED(hr));
            psp->Release();
        }
    }

    return hr;
}

HRESULT IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi)
{
    HRESULT hr = E_FAIL;
    IShellFolderBand *pisfBand;

    if (punkBand) {
        hr = punkBand->QueryInterface(IID_IShellFolderBand, (void **)&pisfBand);
        if (EVAL(SUCCEEDED(hr))) {
            hr = pisfBand->SetBandInfoSFB(pbi);
            pisfBand->Release();
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////CExtractImageTask///////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
// Warning
//
// The CLogoBase class cannot have a ref on the returned task
// since that would be a circular reference
//
// Warning

HRESULT CExtractImageTask_Create( CLogoBase *plb,
                                  LPEXTRACTIMAGE pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  LPRUNNABLETASK * ppTask )
{
    if ( !ppTask || !plb || !pExtract )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = NOERROR;
    CExtractImageTask * pNewTask = new CExtractImageTask( &hr,
                                                          plb,
                                                          pExtract,
                                                          pszCache,
                                                          dwItem,
                                                          iIcon,
                                                          dwFlags );
    if ( !pNewTask )
    {
        return E_OUTOFMEMORY;
    }
    if ( FAILED( hr ))
    {
        pNewTask->Release();
        return hr;
    }

    *ppTask = SAFECAST( pNewTask, IRunnableTask *);
    return NOERROR;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////


CExtractImageTask::CExtractImageTask( HRESULT * pHr, CLogoBase *plb, IExtractImage * pImage,
    LPCWSTR pszCache, DWORD dwItem, int iIcon, DWORD dwFlags )
{
    m_lState = IRTIR_TASK_NOT_RUNNING;

    m_plb = plb;
    m_plb->AddRef();

    // cannot assume the band will kill us before it dies....
    // hence we hold a reference

    StrCpyW( m_szPath, pszCache );

    m_pExtract = pImage;
    pImage->AddRef();

    m_cRef = 1;

    // use the upper bit of the flags to determine if we should always call....
    m_dwFlags = dwFlags;
    m_dwItem = dwItem;
    m_iIcon = iIcon;

    // Since the task moves from thread to thread,
    // don't charge this thread for the objects we're using
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
CExtractImageTask::~CExtractImageTask()
{
    ATOMICRELEASE( m_pExtract );
    ATOMICRELEASE( m_pTask );

    if ( m_hBmp && !( m_dwFlags & EITF_SAVEBITMAP ))
    {
        DeleteObject( m_hBmp );
    }

    if(m_plb)
        m_plb->Release();
}

//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtractImageTask::QueryInterface( REFIID riid, void **ppvObj )
{
    if ( !ppvObj )
    {
        return E_INVALIDARG;
    }
    if ( IsEqualIID( riid, IID_IUnknown ))
    {
        *ppvObj = SAFECAST( this, IUnknown *);
    }
    else if ( IsEqualIID( riid, IID_IRunnableTask ))
    {
        *ppvObj = SAFECAST( this, IRunnableTask *);
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_ (ULONG)  CExtractImageTask::AddRef()
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;
}

//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_ (ULONG) CExtractImageTask::Release()
{
    if (InterlockedDecrement( &m_cRef ) == 0 )
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtractImageTask::Run ( void )
{
    HRESULT hr = E_FAIL;
    if ( m_lState == IRTIR_TASK_RUNNING )
    {
        hr = S_FALSE;
    }
    else if ( m_lState == IRTIR_TASK_PENDING )
    {
        hr = E_FAIL;
    }
    else if ( m_lState == IRTIR_TASK_NOT_RUNNING )
    {
        LONG lRes = InterlockedExchange( & m_lState, IRTIR_TASK_RUNNING);
        if ( lRes == IRTIR_TASK_PENDING )
        {
            m_lState = IRTIR_TASK_FINISHED;
            return NOERROR;
        }

        // see if it supports IRunnableTask
        m_pExtract->QueryInterface( IID_IRunnableTask, (void **) & m_pTask );

#ifdef UNIX
        //Hey Guys : IE4.01 has an error - it returns the wrong VTABLE
        //when this QI is done. We know how our VTABLEs are laid out

#else
        // IE4.01 has an error - it returns the wrong VTABLE
        // when this QI is done.

        if((LPVOID)m_pTask == (LPVOID)m_pExtract)
        {
            m_pTask = m_pTask + 2; // This vtable is two ptrs away and is in fstree.cpp in shell32 in IE4.01
        }
#endif

        if ( m_lState == IRTIR_TASK_RUNNING )
        {
            // start the extractor....
            hr = m_pExtract->Extract( &m_hBmp );
        }

        if (( SUCCEEDED( hr ) || ( hr != E_PENDING && (m_dwFlags & EITF_ALWAYSCALL))) && m_lState == IRTIR_TASK_RUNNING )
        {
            hr = InternalResume();
        }

        if ( m_lState != IRTIR_TASK_SUSPENDED || hr != E_PENDING )
        {
            m_lState = IRTIR_TASK_FINISHED;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtractImageTask::Kill ( BOOL fWait )
{
    if ( m_lState != IRTIR_TASK_RUNNING )
    {
        return S_FALSE;
    }

    LONG lRes = InterlockedExchange( &m_lState, IRTIR_TASK_PENDING );
    if ( lRes == IRTIR_TASK_FINISHED )
    {
        m_lState = lRes;
        return NOERROR;
    }

    // does it support IRunnableTask ? Can we kill it ?
    HRESULT hr = E_NOTIMPL;
    if ( m_pTask != NULL )
    {
        hr = m_pTask->Kill( FALSE );
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtractImageTask::Suspend( void )
{
    if ( !m_pTask )
    {
        return E_NOTIMPL;
    }

    if ( m_lState != IRTIR_TASK_RUNNING )
    {
        return E_FAIL;
    }


    LONG lRes = InterlockedExchange( &m_lState, IRTIR_TASK_SUSPENDED );
    HRESULT hr = m_pTask->Suspend();
    if ( SUCCEEDED( hr ))
    {
        lRes = (LONG) m_pTask->IsRunning();
        if ( lRes == IRTIR_TASK_SUSPENDED )
        {
            m_lState = lRes;
        }
    }
    else
    {
        m_lState = lRes;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtractImageTask::Resume( void )
{
    if ( !m_pTask )
    {
        return E_NOTIMPL;
    }

    if ( m_lState != IRTIR_TASK_SUSPENDED )
    {
        return E_FAIL;
    }

    m_lState = IRTIR_TASK_RUNNING;

    HRESULT hr = m_pTask->Resume();
    if ( SUCCEEDED( hr ) || ( hr != E_PENDING && ( m_dwFlags & EITF_ALWAYSCALL )))
    {
        hr = InternalResume();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CExtractImageTask::InternalResume()
{
    HRESULT hr = NOERROR;
    if ( m_dwFlags & EITF_ALWAYSCALL || m_hBmp )
    {
        // call the update function
        hr = m_plb->UpdateLogoCallback( m_dwItem, m_iIcon, m_hBmp, m_szPath, TRUE );
    }

    m_lState = IRTIR_TASK_FINISHED;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CExtractImageTask:: IsRunning ( void )
{
    return m_lState;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////CLogoBase/////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// static data...
IImageCache * CLogoBase::s_pSharedWideLogoCache = NULL;
long CLogoBase::s_lSharedWideLogosRef = 0;
HDSA CLogoBase::s_hdsaWideLogoIndices = NULL;
CRITICAL_SECTION CLogoBase::s_csSharedLogos = {0};

extern "C" void CLogoBase_Initialize( void )
{
    CLogoBase::_Initialize();
}

extern "C" void CLogoBase_Cleanup( void )
{
    CLogoBase::_Cleanup( );
}

void CLogoBase::_Initialize( void )
{
    InitializeCriticalSection( &s_csSharedLogos );
}

void CLogoBase::_Cleanup( void )
{
    DeleteCriticalSection( & s_csSharedLogos );
}


CLogoBase::CLogoBase( BOOL fWide )
{
    // are we paletized, then use the global halftone palette ....
    HDC hdcTmp = GetDC( NULL );
    if (hdcTmp)
    {
        if (GetDeviceCaps( hdcTmp, RASTERCAPS) & RC_PALETTE)
        {
            ASSERT( g_hpalHalftone );
            _hpalHalftone = g_hpalHalftone;
        }
        ReleaseDC( NULL, hdcTmp );
    }

    _fWide = fWide;
}

CLogoBase::~CLogoBase()
{
    if (_pLogoCache || _pTaskScheduler)
    {
        ExitLogoView();
    }

    // NOTE: no palette release because we are using the global Halftone palette......
}

HRESULT CLogoBase::AddRefLogoCache( void )
{
    if ( _fWide )
    {
        EnterCriticalSection( &s_csSharedLogos );

        if ( !s_lSharedWideLogosRef )
        {
            if ( !s_hdsaWideLogoIndices )
            {
                s_hdsaWideLogoIndices = DSA_Create( sizeof( LogoIndex ), 5 );
                if ( !s_hdsaWideLogoIndices )
                {
                    LeaveCriticalSection( &s_csSharedLogos );
                    return E_OUTOFMEMORY;
                }
            }

            ASSERT( s_hdsaWideLogoIndices );
            ASSERT( !s_pSharedWideLogoCache );

            // BUGBUG for now CoCreate one per view
            HRESULT hr = CoCreateInstance( CLSID_ImageListCache,
                                           NULL,
                                           CLSCTX_INPROC,
                                           IID_IImageCache,
                                           (void **) & s_pSharedWideLogoCache );
            if ( FAILED( hr ))
            {
                LeaveCriticalSection( &s_csSharedLogos );
                return hr;
            }
        }

        ASSERT( s_pSharedWideLogoCache );

        // bump up the ref and get a pointer to it...
        s_lSharedWideLogosRef ++;
        _pLogoCache = s_pSharedWideLogoCache;
        _pLogoCache->AddRef();
        _hdsaLogoIndices = s_hdsaWideLogoIndices;
        LeaveCriticalSection( &s_csSharedLogos );

        return NOERROR;
    }
    else
    {
        // non wide logo version we don't share because w eonly expect there ever to be one...
        _hdsaLogoIndices = DSA_Create( sizeof( LogoIndex ), 5 );
        if ( !_hdsaLogoIndices )
        {
            return E_OUTOFMEMORY;
        }

        // BUGBUG for now CoCreate one per view
        return CoCreateInstance( CLSID_ImageListCache,
                                 NULL,
                                 CLSCTX_INPROC,
                                 IID_IImageCache,
                                 (void **) & _pLogoCache );
    }
}

HRESULT CLogoBase::ReleaseLogoCache( void )
{
    if ( !_pLogoCache )
    {
        return S_FALSE;
    }

    ATOMICRELEASE(_pLogoCache);

    if ( _fWide )
    {
        EnterCriticalSection( &s_csSharedLogos );

        ASSERT( s_lSharedWideLogosRef > 0 );

        s_lSharedWideLogosRef --;
        if ( ! s_lSharedWideLogosRef )
        {
            // let go of the final ref.....
            ATOMICRELEASE(s_pSharedWideLogoCache);

            ASSERT( s_hdsaWideLogoIndices );
            DSA_Destroy( s_hdsaWideLogoIndices );
            s_hdsaWideLogoIndices = NULL;
        }

        LeaveCriticalSection( &s_csSharedLogos );
    }
    else
    {
        // free the HDSA
        DSA_Destroy( _hdsaLogoIndices );
        _hdsaLogoIndices = NULL;
    }

    return NOERROR;
}

HRESULT CLogoBase::InitLogoView( void )
{
    HRESULT hr = AddRefLogoCache();
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_ShellTaskScheduler,
                              NULL,
                              CLSCTX_INPROC,
                              IID_IShellTaskScheduler,
                              (void **) &_pTaskScheduler);
        if (FAILED(hr))
        {
            ATOMICRELEASE(_pLogoCache);
        }
        else
        {
            _rgLogoSize.cx = ( _fWide ) ? LOGO_WIDE_WIDTH : LOGO_WIDTH ;
            _rgLogoSize.cy = LOGO_HEIGHT;

            IMAGECACHEINITINFO rgInfo;
            rgInfo.cbSize = sizeof( rgInfo );
            rgInfo.dwMask = ICIIFLAG_LARGE;
            rgInfo.iStart = 0;
            rgInfo.iGrow = 5;

            // the color depth is currently the screen resolution...
            int iColorRes = SHGetCurColorRes();

            _dwClrDepth = (DWORD) iColorRes;
            switch (iColorRes)
            {
                case 16 :   rgInfo.dwFlags = ILC_COLOR16;
                            break;
                case 24 :
                case 32 :   rgInfo.dwFlags = ILC_COLOR24;
                            break;
                default :   rgInfo.dwFlags = ILC_COLOR8;
            }

            rgInfo.rgSizeLarge = _rgLogoSize;
            if (_pLogoCache)
                hr = _pLogoCache->GetImageList(&rgInfo);
            else
                hr = E_UNEXPECTED;

            if (FAILED(hr))
            {
                ATOMICRELEASE(_pLogoCache);
                ATOMICRELEASE(_pTaskScheduler);
            }
            else
            {
                _himlLogos = rgInfo.himlLarge;

                // GetImageList() will return S_FALSE if it was already created...
                if ((hr == S_OK) && (iColorRes <= 8))
                {
                    // init the color table so that it matches The "special halftone palette"
                    HPALETTE hpal = SHCreateShellPalette(NULL);
                    PALETTEENTRY rgColours[256];
                    RGBQUAD rgDIBColours[256];

                    ASSERT( hpal );
                    int nColours = GetPaletteEntries(hpal, 0, ARRAYSIZE(rgColours), rgColours);

                    // SHGetShellPalette should always return a 256 colour palette
                    ASSERT(nColours == ARRAYSIZE(rgColours));

                    // translate from the LOGPALETTE structure to the RGBQUAD structure ...
                    for (int iColour = 0; iColour < nColours; iColour ++)
                    {
                        rgDIBColours[iColour].rgbRed = rgColours[iColour].peRed;
                        rgDIBColours[iColour].rgbBlue = rgColours[iColour].peBlue;
                        rgDIBColours[iColour].rgbGreen = rgColours[iColour].peGreen;
                        rgDIBColours[iColour].rgbReserved = 0;
                    }

                    DeletePalette(hpal);

                    ImageList_SetColorTable(_himlLogos, 0, 256, rgDIBColours);
                }
            }
        }
    }

    return hr;
}

HRESULT CLogoBase::ExitLogoView( void )
{
    ATOMICRELEASE( _pTaskScheduler );

    // the task scheduler callbacks can reference
    // the logocache, so make sure you free the
    // logo cache AFTER the task scheduler!
    ReleaseLogoCache();

    return NOERROR;
}

int CLogoBase::GetCachedLogoIndex( DWORD dwItem, LPCITEMIDLIST pidl, LPRUNNABLETASK *ppTask, DWORD * pdwPriority, DWORD *pdwFlags )
{
    DWORD dwPassedFlags = 0;

    if ( pdwFlags )
    {
        dwPassedFlags = *pdwFlags;
        *pdwFlags = 0;
    }

    // No logo cache?
    if (!_pLogoCache)
        return 0;

    ASSERT( pidl );
    // HACK: this is used on browser only mode to tell what sort of logos we need...
    UINT rgfFlags = _fWide;
    LPEXTRACTIMAGE pImage = NULL;
    int iImage = -1;
    HRESULT hr = E_FAIL;

    // IID_IEXtractLogo and IID_IExtractImage are the same interface, by using a new guid
    // it means we can selectively decided what can logo in logo view...
    hr = FakeGetUIObjectOf( GetSF(), pidl, &rgfFlags, IID_IExtractLogo, (void **) &pImage );
    if ( SUCCEEDED( hr ))
    {
        // extract ....
        HBITMAP hImage;
        WCHAR szPath[MAX_PATH];
        DWORD dwFlags = IEIFLAG_ASYNC | IEIFLAG_ASPECT | dwPassedFlags;
        IMAGECACHEINFO rgInfo;
        UINT uIndex;
        BOOL fAsync;
        DWORD dwPriority;

        rgInfo.cbSize = sizeof( rgInfo );

        hr = pImage->GetLocation( szPath, MAX_PATH, &dwPriority, &_rgLogoSize, _dwClrDepth, &dwFlags );
        fAsync = ( hr == E_PENDING );
        if ( SUCCEEDED( hr ) || fAsync )
        {
            // mask off the flags passed to use by the flags returned from the extractor...
            if ( pdwFlags )
                *pdwFlags = dwPassedFlags & dwFlags;

            rgInfo.dwMask = ICIFLAG_NAME;
            rgInfo.pszName = szPath;

            hr = _pLogoCache->FindImage( &rgInfo, &uIndex );
            if ( hr == S_OK )
            {
                ATOMICRELEASE( pImage );
                return (int) uIndex;
            }

            if ( fAsync )
            {
                LPRUNNABLETASK pTaskTmp = NULL;

                ASSERT( _pTaskScheduler );

                // pass the icon index so we can find the right logo later...
                int iIcon = SHMapPIDLToSystemImageListIndex(GetSF(), pidl, NULL);
                hr = CExtractImageTask_Create( this,
                                               pImage,
                                               szPath,
                                               dwItem,
                                               iIcon,
                                               0,
                                               &pTaskTmp );
                if ( SUCCEEDED( hr ))
                {
                    if ( !ppTask )
                    {
                        hr = AddTaskToQueue( pTaskTmp, dwPriority, dwItem );
                        pTaskTmp->Release();
                    }
                    else
                    {
                        * ppTask = pTaskTmp;

                        ASSERT( pdwPriority );
                        *pdwPriority = dwPriority;
                    }
                }
                else if ( ppTask )
                {
                    *ppTask = NULL;
                }

                // if all this failed, then we will just end up with a default
                // logo. This is only likely to fail in low memory conditions,
                // so that will be fine.

                // if this SUCCEEDED we will drop through to pick up a defualt piccy for now.
            }
            else
            {
                // otherwise extract synchronously.......
                hr = pImage->Extract( &hImage );
                if ( SUCCEEDED( hr ))
                {
                    rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_LARGE | ICIFLAG_BITMAP | ICIFLAG_NOUSAGE;
                    rgInfo.hBitmapLarge = hImage;

                    hr = _pLogoCache->AddImage( &rgInfo, &uIndex );
                    DeleteObject( hImage );
                }
                if ( SUCCEEDED( hr ))
                {
                    iImage = (int ) uIndex;
                }
            }
        }
    }

    ATOMICRELEASE( pImage );

    return iImage;
}

int CLogoBase::GetLogoIndex( DWORD dwItem, LPCITEMIDLIST pidl, LPRUNNABLETASK *ppTask, DWORD * pdwPriority, DWORD *pdwFlags )
{
    int iImage = GetCachedLogoIndex(dwItem, pidl, ppTask, pdwPriority, pdwFlags );

    if ( iImage == -1 )
    {
        // always pass FALSE, we want the proper ICON, cdfview no longer hits the
        // wire for the icon so we can safely ask for the correct icon.
        iImage = GetDefaultLogo( pidl, FALSE);

    }
    return iImage;
}

HRESULT CLogoBase::AddTaskToQueue( LPRUNNABLETASK pTask, DWORD dwPriority, DWORD dwItem )
{
    ASSERT( _pTaskScheduler );
    return _pTaskScheduler->AddTask( pTask, GetTOID(), dwItem, dwPriority );
}

int CLogoBase::GetDefaultLogo( LPCITEMIDLIST pidl, BOOL fQuick )
{
    USES_CONVERSION;

    // Get icon to draw from
    int iIndex = -1;
    if ( !fQuick )
    {
        iIndex = SHMapPIDLToSystemImageListIndex(GetSF(), pidl, NULL);
    }
    if (iIndex < 0)
    {
        iIndex = II_DOCNOASSOC;
    }

    WCHAR wszText[MAX_PATH];

    wszText[0] = 0;

    STRRET strret;
    HRESULT hr = GetSF()->GetDisplayNameOf( pidl, SHGDN_NORMAL, &strret );
    if ( SUCCEEDED( hr ))
    {
        StrRetToBufW(&strret, pidl, wszText, ARRAYSIZE(wszText));
    }

    UINT uCacheIndex = (UINT) -1;

    if (_pLogoCache)    // We didn't have one in stress.
    {
        IMAGECACHEINFO rgInfo;
        rgInfo.cbSize = sizeof( rgInfo );
        rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_INDEX;
        rgInfo.pszName = wszText;
        rgInfo.iIndex = iIndex;

        hr = _pLogoCache->FindImage( &rgInfo, &uCacheIndex );
        if ( hr == S_OK )
        {
            return uCacheIndex;
        }

        HBITMAP hDef;
        hr = CreateDefaultLogo( iIndex, _rgLogoSize.cx, _rgLogoSize.cy, W2T(wszText), &hDef );
        if ( SUCCEEDED( hr ))
        {
            rgInfo.hBitmapLarge = hDef;
            rgInfo.hMaskLarge = NULL;
            rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_INDEX | ICIFLAG_BITMAP | ICIFLAG_LARGE;

            hr = _pLogoCache->AddImage( &rgInfo, &uCacheIndex );
            if ( FAILED(hr ))
            {
                uCacheIndex = (UINT) -1;
            }
            else
            {
                // remember the index of the logo
                AddIndicesToLogoList( iIndex, uCacheIndex );
            }
            DeleteObject( hDef );
        }
    }

    return (int) uCacheIndex;
}

#define DXFUDGE     4
#define COLORTEXT   RGB(255,255,255)
#define COLORBK     RGB(0,0,0)
HRESULT CLogoBase::CreateDefaultLogo(int iIcon, int cxLogo, int cyLogo, LPCTSTR pszText, HBITMAP * phBmpLogo)
{
    HRESULT hr = E_OUTOFMEMORY;
    HBITMAP hbmp = NULL;

    HIMAGELIST himl;
    int cxIcon, cyIcon;
   int x, y, dx, dy;

    // get the small icons....
    Shell_GetImageLists(NULL, &himl);
    ImageList_GetIconSize(himl, &cxIcon, &cyIcon);

    // Calculate position info. We assume logos are wider than they are tall.
    //
    ASSERT(cxLogo >= cyLogo);

    // Put the icon on the left
    x = 2;

    // Center the icon vertically
    if (cyIcon <= cyLogo)
    {
        y = (cyLogo - cyIcon) / 2;
        dy = cyIcon;
        dx = cxIcon;
    }
    else
    {
        y = 0;
        dy = cyLogo;

        // keep shrinkage proportional
        dx = MulDiv(cxIcon, cyIcon, cyLogo);
    }

    // get ready to draw
    HDC hTBDC = GetDC( GetHWND());
    if ( !hTBDC )
    {
        return E_FAIL;
    }
    HDC hdc = CreateCompatibleDC( hTBDC );
    if (hdc)
    {
        RECT    rc;
        int     dx, dy, x, y;
        SIZE    size;
        hbmp = CreateCompatibleBitmap(hTBDC, cxLogo, cyLogo);
        if (hbmp)
        {
            HGDIOBJ hTmp = SelectObject(hdc, hbmp);
            HPALETTE hpalOld;
            HFONT hfont, hfontOld;

            if ( _hpalHalftone )
            {
                hpalOld = SelectPalette( hdc, _hpalHalftone, TRUE );
                // LINTASSERT(hpalOld || !hpalOld);     // 0 semi-ok for SelectPalette
                RealizePalette( hdc );
            }

            SetMapMode( hdc, MM_TEXT );
            rc.left = rc.top = 0;
            rc.bottom = cyLogo;
            rc.right = cxLogo;
            SHFillRectClr(hdc, &rc, COLORBK);
            // draw the icon into the memory DC.
            ImageList_GetIconSize(himl, &dx, &dy);
            x = DXFUDGE;
            y = ((cyLogo- dy) >> 1);
            ImageList_Draw( himl, iIcon, hdc, x, y, ILD_TRANSPARENT );
            hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            hfontOld = hfont ? (HFONT)SelectObject(hdc, hfont) : NULL;
            GetTextExtentPoint32(hdc, pszText, lstrlen(pszText), &size);
            x += (dx + DXFUDGE);
            y = ((cyLogo- size.cy) >> 1);
            rc.left = x;
            UINT eto = ETO_CLIPPED;
            SetTextColor(hdc, COLORTEXT);
            SetBkMode(hdc, TRANSPARENT);
            ExtTextOut(hdc, x, y, eto, &rc
                                        , pszText, lstrlen(pszText), NULL);
            if (hfontOld)
                SelectObject(hdc, hfontOld);

            if (hfont)
                DeleteObject(hfont);

            if ( _hpalHalftone )
            {
                (void) SelectPalette( hdc, hpalOld, TRUE );
                RealizePalette( hdc );
            }

            // remove the final bitmap
            SelectObject( hdc, hTmp );
            hr = S_OK;

            if (FAILED(hr))
            {
                DeleteObject(hbmp);
                hbmp = NULL;
            }
        }

        DeleteDC(hdc);
    }
    ReleaseDC( GetHWND(), hTBDC );

    *phBmpLogo = hbmp;

    return hr;
}

HRESULT CLogoBase::FlushLogoCache( )
{
    HRESULT hr = E_UNEXPECTED;

    if (_pLogoCache)
    {
        // forcibly clear out the logo cache so the items get refetched ...
        _pLogoCache->Flush(TRUE);
        hr = S_OK;
    }

    return hr;
}


HRESULT CLogoBase::DitherBitmap( HBITMAP hBmp, HBITMAP * phBmpNew )
{
//     if ( !phBmpNew )
//     {
//         return E_INVALIDARG;
//     }
//
//     if ( _dwClrDepth > 8)
//     {
//         *phBmpNew = hBmp;
//         return S_FALSE;
//     }
//
//     IIntDitherer * pDither;
//     HRESULT hr = CoCreateInstance( CLSID_IntDitherer,
//                                    NULL,
//                                    CLSCTX_INPROC_SERVER,
//                                    IID_IIntDitherer,
//                                    (void **) & pDither );
//     if ( FAILED( hr ))
//     {
//         return hr;
//     }
//
//     static BYTE rgb[32768];
//     static BOOL fInit = FALSE;
//
//     if ( !fInit )
//     {
//         // init the inverse color map table
//         SHGetInverseCMAP( rgb, sizeof( rgb ));
//         fInit = TRUE;
//     }
//
//     HDC hMemDc = CreateCompatibleDC( NULL );
//     if ( !hMemDc )
//     {
//         pDither->Release();
//         return E_FAIL;
//     }
//
//     HBITMAP hOld = SelectObject( hdc, hBmp );
//
//     BITMAPINFO bi;
//
//     ZeroMemory( &bi, sizeof( bi ));
//     bi.bmiHeader.biSize = sizeof( BITMAPINFOHEADER );
//     bi.bmiHeader.biBitCount = 0;
//     bi.bmiHeader.biCompression = 0;
//
//     // get the header information....
//     iRet = GetDIBits( hMemDc, hBmp, 0, 0, NULL, &bi, DIB_RGB_COLORS );
//     if ( iRet != 0 )
//     {
//         LPVOID  pBuffer, pBits;
//         int iOffset = 0;
//
//         if ( bi.bmiHeader.biCompression == BI_BITFIELDS )
//         {
//             iOffset = sizeof( DWORD ) * 3;
//         }
//         else if ( bi.bmiHeader.biBitCount <= 8 )
//         {
//             if ( bi.bmiHeader.biClrUsed )
//             {
//                 iOffset = sizeof( RGBQUAD ) * bi.bmiHeader.biClrUsed;
//             }
//             else
//             {
//                 iOffset = (1 << bi.bmiHeader.biBitCount) * sizeof( RGBQUAD );
//             }
//         }
//
//         bi.bmiHeader.biHeight = iHeight;
//
//         // calc
//         pBuffer = LocalAlloc( LPTR, sizeof( BITMAPINFOHEADER ) +
//             bi.bmiHeader.biSizeImage +
//             iOffset );
//
//         // calc the size of the colour table so we put the data afterwards...
//         pBits = (( LPBYTE )pBuffer ) + sizeof( BITMAPINFOHEADER ) + iOffset;
//
//         CopyMemory( pBuffer, &bi, sizeof( BITMAPINFOHEADER ) );
//         iRet = GetDIBits( hMemDc, hBmp, 0, iHeight, pBits,
//                           ( LPBITMAPINFO )pBuffer, DIB_RGB_COLORS );
//
//
//         // we know we are going to 256 colour bitmap, so create a DIBSECTION as the destination ...
//         pDither->DitherTo8bpp(  BYTE * pDestBits, LONG nDestPitch,
//                         BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc,
//                         RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
//                         rgb,
//                         LONG x, LONG y, LONG cx, LONG cy,
//                         -1, -1);
//     }
//     pDither->Release();

    ASSERT( FALSE );
    return E_NOTIMPL;
}

int CLogoBase::AddIndicesToLogoList( int iIcon, UINT uIndex )
{
    int iRet = -1;

    LogoIndex * pIndex;
    LogoIndex rgNew;

    rgNew.iIcon = iIcon;
    rgNew.iLogo = (int) uIndex;

    if ( _fWide )
    {
        EnterCriticalSection( &s_csSharedLogos );
    }

    // scan to see if we have an extact match already in there...
    for ( int n = 0; n < DSA_GetItemCount( _hdsaLogoIndices ); n ++ )
    {
        pIndex = (LogoIndex *) DSA_GetItemPtr( _hdsaLogoIndices, n );
        ASSERT( pIndex );
        if ( pIndex->iLogo == (int) uIndex )
        {
            // set the icon just incase it changed...
            pIndex->iIcon = iIcon;
            iRet = n;
            break;
        }
    }

    if ( iRet == -1 )
    {
        iRet = DSA_AppendItem( _hdsaLogoIndices, &rgNew );
    }

    if ( _fWide )
    {
        LeaveCriticalSection( &s_csSharedLogos );
    }

    return iRet;
}

int CLogoBase::FindLogoFromIcon( int iIcon, int * piLastLogo )
{
    int iRet = -1;

    if ( !piLastLogo )
    {
        return -1;
    }

    LogoIndex * pIndex;

    if ( _fWide )
    {
        EnterCriticalSection( &s_csSharedLogos );
    }

    for ( int n = *piLastLogo + 1; n < DSA_GetItemCount( _hdsaLogoIndices ); n ++ )
    {
        pIndex = (LogoIndex *) DSA_GetItemPtr( _hdsaLogoIndices, n );
        ASSERT( pIndex );

        if ( pIndex->iIcon == iIcon )
        {
            *piLastLogo = n;
            iRet = pIndex->iLogo;
            break;
        }
    }

    if ( _fWide )
    {
        LeaveCriticalSection( &s_csSharedLogos );
    }

    return iRet;
}

HRESULT CISFBand_CreateEx(IShellFolder* psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr = E_FAIL;

    if (psf || pidl)
    {
        IShellFolderBand *psfb;
        hr = CoCreateInstance(CLSID_ISFBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellFolderBand, &psfb));
        if (SUCCEEDED(hr))
        {
            hr = psfb->InitializeSFB(psf, pidl);
            if (SUCCEEDED(hr))
            {
                hr = psfb->QueryInterface(riid, ppv);
            }
            psfb->Release();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\icotask.h ===
#ifndef CIconTask_h
#define CIconTask_h

#include <runtask.h>

typedef void (*PFNICONTASKBALLBACK)(LPVOID pvData, UINT uId, UINT iIconIndex);

class CIconTask : public CRunnableTask
{
public:
#if 0   // Needed if we implement multiple interfaces
    // IUnknown methods
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CRunnableTask::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) 
        { return CRunnableTask::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
        { return CRunnableTask::QueryInterface(riid, ppvObj); };
#endif

    // IRunnableTask methods (override)
    virtual STDMETHODIMP RunInitRT(void);

    CIconTask(LPITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId);
private:
    virtual ~CIconTask();


    LPITEMIDLIST        _pidl;
    PFNICONTASKBALLBACK _pfn;
    LPVOID              _pvData;
    UINT                _uId;
};

// NOTE: If you pass NULL for psf and pidlFolder, you must pass a full pidl which
// the API takes ownership of. (This is an optimization) lamadio - 7.28.98
HRESULT AddIconTask(IShellTaskScheduler* pts, IShellFolder* psf, LPCITEMIDLIST pidlFolder,
                    LPCITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId, 
                    int* piTempIcon);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\isfmenu.cpp ===
//
// isfmenu.cpp
//
// callback for chevron drop-down menu for isfbands
//

#include "priv.h"
#include "sccls.h"
#include "isfmenu.h"
#include "legacy.h"
#include "util.h"

// *** IUnknown methods ***
STDMETHODIMP CISFMenuCallback::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CISFMenuCallback, IShellMenuCallback),
        QITABENT(CISFMenuCallback, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CISFMenuCallback::AddRef ()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CISFMenuCallback::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

BOOL CISFMenuCallback::_IsVisible(LPITEMIDLIST pidl)
{
    if (_poct) {
        VARIANTARG v;

        v.vt = VT_INT_PTR;
        v.byref = pidl;

        HRESULT hr = _poct->Exec(&CGID_ISFBand, ISFBID_ISITEMVISIBLE, 0, &v, NULL);
        return (hr == S_OK);
    }

    return FALSE;
}


HRESULT IUnknown_SeekToZero(IUnknown* punk)
{
    HRESULT hres = E_FAIL;
    IStream* pstm;
    if (punk && SUCCEEDED(punk->QueryInterface(IID_IStream, (void**)&pstm)))
    {
        // We need to seek to the beginning of the stream here. We don't do this in
        // the menubands because it's rude: They should not seek to the beginning
        // because there may be information that needs to be saved after them.
        //Set the seek pointer at the beginning.
        const LARGE_INTEGER li0 = {0};
        hres = pstm->Seek(li0, STREAM_SEEK_SET, NULL);
        pstm->Release();
    }

    return hres;
}

HRESULT CISFMenuCallback::_GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj)
{
    HRESULT hres = S_FALSE;
    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IStream))
    {
        if (_pidl && psmd->pidlFolder && psmd->pidlItem)
        {
            // Verify that the Cascading menuband is ONLY asking for this folder.
            // because if there is a sub menu, It's going to ask again with the
            // pidl of that folder, which we don't have the Stream for, and we
            // can hose things pretty good if we indescriminatly hand out order streams

            LPITEMIDLIST pidlFull = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlFull)
            {
                if (_poct && ILIsEqual(pidlFull, _pidl)) 
                {
                    VARIANTARG v = {0};

                    v.vt = VT_UNKNOWN;
                    hres = _poct->Exec(&CGID_ISFBand, ISFBID_GETORDERSTREAM, 0, NULL, &v);

                    if (SUCCEEDED(hres))
                    {
                        IUnknown_SeekToZero(v.punkVal);

                        hres = v.punkVal->QueryInterface(riid, ppvObj);
                        v.punkVal->Release();
                    }
                }
                ILFree(pidlFull);
            }
        }
    }
    return hres;
}

HRESULT CISFMenuCallback::_SetObject(LPSMDATA psmd, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;

    if (IsEqualIID(riid, IID_IStream))
    {
        if (_pidl && psmd->pidlFolder && psmd->pidlItem)
        {
            // Verify that the Cascading menuband is ONLY asking for this folder.
            // because if there is a sub menu, It's going to ask again with the
            // pidl of that folder, which we don't have the Stream for, and we
            // can hose things pretty good if we indescriminatly hand out order streams

            LPITEMIDLIST pidlFull = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlFull)
            {
                if (_poct && ILIsEqual(pidlFull, _pidl)) 
                {
                    ASSERT(ppvObj);

                    VARIANTARG v;

                    v.vt = VT_UNKNOWN;
                    v.punkVal = *(IUnknown**)ppvObj;

                    IUnknown_SeekToZero(*(IUnknown**)ppvObj);

                    hres = _poct->Exec(&CGID_ISFBand, ISFBID_SETORDERSTREAM, 0, &v, NULL);
                }
                ILFree(pidlFull);
            }
        }
    }

    return hres;
}


HRESULT CISFMenuCallback::_GetSFInfo(LPSMDATA psmd, PSMINFO psminfo)
{
    // We only want to filter pidls if:
    //  1) It's at the root of the links chevron menu
    //  2) It's _IS_ visible in the links bar. We don't want to show links
    //     in this menu that are visible.
    if (psmd->uIdAncestor == ANCESTORDEFAULT &&
        (psminfo->dwMask & SMIM_FLAGS)       && 
        _IsVisible(psmd->pidlItem))
    {
        // not obscured on the subject isfband; exclude from menu
        psminfo->dwFlags |= SMIF_HIDDEN;
    }

    return S_OK;
}

// *** IShellMenuCallback methods ***
STDMETHODIMP CISFMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;

    switch (uMsg) 
    {
    case SMC_SFEXEC:
        hr = SHNavigateToFavorite(psmd->psf, psmd->pidlItem, _punkSite, SBSP_DEFBROWSER | SBSP_DEFMODE);
        break;

    case SMC_GETSFINFO:
        hr = _GetSFInfo(psmd, (PSMINFO)lParam);
        break;

    case SMC_GETSFOBJECT:
        hr = _GetObject(psmd, *((GUID*)wParam), (void**)lParam);
        break;

    case SMC_SETSFOBJECT:
        hr = _SetObject(psmd, *((GUID*)wParam), (void**)lParam);
        break;

    }

    return hr;
}

// *** IObjectWithSite methods ***
STDMETHODIMP CISFMenuCallback::SetSite(IUnknown* punkSite)
{
    if (punkSite != _punkSite)
        IUnknown_Set(&_punkSite, punkSite);

    return S_OK;
}


HRESULT CISFMenuCallback::Initialize(IUnknown* punk)
{
    HRESULT hr = E_FAIL;

    if (punk)
        hr = punk->QueryInterface(IID_IOleCommandTarget, (PVOID*)&_poct);

    IShellFolderBand* psfb;
    hr = punk->QueryInterface(IID_IShellFolderBand, (PVOID*)&psfb);

    if (SUCCEEDED(hr)) 
    {
        BANDINFOSFB bi;
        bi.dwMask = ISFB_MASK_IDLIST | ISFB_MASK_SHELLFOLDER;

        hr = psfb->GetBandInfoSFB(&bi);
        _pidl = bi.pidl;
        if (bi.psf)
            bi.psf->Release();
        psfb->Release();
    }

    return hr;
}

CISFMenuCallback::CISFMenuCallback() : _cRef(1)
{
}

CISFMenuCallback::~CISFMenuCallback()
{
    ASSERT(_cRef == 0);

    ILFree(_pidl);

    ATOMICRELEASE(_poct);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\isfmenu.h ===
// CISFMenuCallback implementation

#ifndef _ISFMENU_H
#define _ISFMENU_H

#include "cowsite.h"

class CISFMenuCallback : public IShellMenuCallback,
                           public CObjectWithSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA smd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown* punkSite);

    CISFMenuCallback();
    HRESULT Initialize(IUnknown* punk);

private:
    virtual ~CISFMenuCallback();

    HRESULT _GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    HRESULT _SetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    BOOL _IsVisible(LPITEMIDLIST pidl);
    HRESULT _GetSFInfo(LPSMDATA psmd, PSMINFO psminfo);

    int _cRef;
    IOleCommandTarget* _poct;    // our isfband subject
    IUnknown* _punkSite;
    LPITEMIDLIST _pidl;
};

#endif // _ISFMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\menubar.h ===
#ifndef _menubar_h
#define _menubar_h


#ifdef __cplusplus

#include "iface.h"
#include "basebar.h"

IMenuPopup* CreateMenuPopup(IMenuPopup *pmpParent, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
IMenuPopup* CreateMenuPopup2(IMenuPopup *pmpParent, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
HRESULT FindBandInBandSite(IMenuPopup* pmpParent, IBandSite** ppbs, LPCITEMIDLIST pidl, REFIID riid, void** ppvOut);
HRESULT ShowBandInBandSite(IUnknown* punkBS, IUnknown* punkDB);


class CMenuDeskBar : 
        public CBaseBar
        ,public IMenuPopup
        ,public IObjectWithSite
        ,public IBanneredBar
        ,public IInitializeObject
{
public:    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CBaseBar::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CBaseBar::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd) { return CBaseBar::GetWindow(lphwnd); };
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return CBaseBar::ContextSensitiveHelp(fEnterMode); };

    // *** IDeskBar methods ***
    STDMETHODIMP SetClient(IUnknown* punk) { return CBaseBar::SetClient(punk); };
    STDMETHODIMP GetClient(IUnknown** ppunkClient) { return CBaseBar::GetClient(ppunkClient); };
    STDMETHODIMP OnPosRectChangeDB (LPRECT prc) { return CBaseBar::OnPosRectChangeDB(prc); };

    // *** IInputObjectSite methods (override) ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown * pUnkSite);
    STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
    // *** IBanneredBar methods ***
    virtual STDMETHODIMP SetIconSize(DWORD iIcon);
    virtual STDMETHODIMP GetIconSize(DWORD* piIcon)
        { ASSERT(piIcon); *piIcon = _iIconSize; return NOERROR;};
    virtual STDMETHODIMP SetBitmap(HBITMAP hBitmap);
    virtual STDMETHODIMP GetBitmap(HBITMAP* phBitmap)
        { ASSERT(phBitmap); *phBitmap = _hbmp; return NOERROR;};

    // *** IInitializeObject methods ***
    // This is for Backwards compatility with Start Menu.
    STDMETHODIMP Initialize() { return NOERROR; }


    CMenuDeskBar();

    
protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void _OnCreate();
    virtual void _OnSize();
    virtual DWORD _GetExStyle();
    virtual DWORD _GetClassStyle();
 
    void    _AllowMessageThrough(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void    _GetPopupWindowPosition(RECT* rcDesired, RECT* rcExclude, RECT *prcResult, SIZE * psizeEdge, UINT uside); 
    void    _PopDown();
    BOOL    _IsMyParent(HWND hwnd);  
    IMenuPopup* _GetMenuBarParent(IUnknown* punk);
    UINT    _GetSide() { return _uSide;};
    HRESULT _PositionWindow(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags);
    LRESULT _DoPaint(HWND hwnd, HDC hdc, DWORD dwFlags);
    void _DoNCPaint(HWND hwnd, HDC hdc);
    void _SelectItem(BOOL bFirst);
    void AdjustForTheme();

    virtual ~CMenuDeskBar();
            
    POINT   _pt;
    IMenuPopup* _pmpParent;
    IMenuPopup* _pmpChild;
    IUnknown* _punkSite;
    UINT    _uSide;


    HBITMAP _hbmp;
    DWORD   _iIconSize;
    SIZE    _sizeBmp;
    COLORREF    _rgb;

    BITBOOL _fActive: 1;

    RECT    _rcExclude;
    BITBOOL _fExcludeRect: 1;  // TRUE: _rcExclude contains valid 
    BITBOOL _fExpanded: 1;
    BITBOOL _fFlatMenuMode: 1;
    BOOL    _fNoBorder;

    friend HRESULT CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
};

HRESULT TrackShellMenu(HWND hwnd, LPRECT prc, IShellMenu* psm, DWORD dwFlags);

#endif // __cplusplus
#endif // _menubar_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\isfband.h ===
#ifndef BANDISF
#define BANDISF

//#include "iface.h"
#include "bands.h"
//#include "cwndproc.h"
//#include "droptgt.h"
#include "logo.h"
#include "sftbar.h"
#include "legacy.h"

class CISFBand : public CToolbarBand,
                 public CSFToolbar,
                 public CLogoBase,
                 public IFolderBandPriv

{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IPersistStream methods (CToolBand PURE) ***
    virtual STDMETHODIMP GetClassID(LPCLSID lpClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IContextMenu methods (override) ***
    virtual STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    
    // *** IOleCommandTarget ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);
    
    // *** IShellFolderBand methods ***
    virtual STDMETHODIMP InitializeSFB(LPSHELLFOLDER psf, LPCITEMIDLIST pidl);
    virtual STDMETHODIMP SetBandInfoSFB(BANDINFOSFB * pbi);
    virtual STDMETHODIMP GetBandInfoSFB(BANDINFOSFB * pbi);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IFolderBandPriv
    // for internal guys so that we don't have to use a prop page
    virtual STDMETHODIMP SetCascade(BOOL f) { _fCascadeFolder = BOOLIFY(f); return S_OK; };
    virtual STDMETHODIMP SetAccelerators(BOOL f) { _fAccelerators = BOOLIFY(f); return S_OK; }; 
    virtual STDMETHODIMP SetNoIcons(BOOL f)   { _fNoIcons = BOOLIFY(f); return S_OK; };
    virtual STDMETHODIMP SetNoText(BOOL f)  { _fNoShowText = BOOLIFY(f); return S_OK; };

protected:

    friend HRESULT    CISFBand_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
    friend CISFBand * CISFBand_CreateEx(IShellFolder * psf, LPCITEMIDLIST pidl);

    CISFBand();
    virtual ~CISFBand();

    void    _ReleaseMenu();
    void    _SetDirty(BOOL fDirty);
    virtual HRESULT _SetSubMenuPopup(IMenuPopup* pmp, UINT uiCmd, LPCITEMIDLIST pidl, DWORD dwFlagsMDBPU);
    virtual IMenuPopup * _CreateMenuPopup(IShellFolder * psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi);
    virtual void _SendInitMenuPopup(IMenuPopup * pmp, LPCITEMIDLIST pidl);
    virtual LRESULT _OnHotItemChange(NMTBHOTITEM * pnmhot);
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual HRESULT _TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon);

    void    _ReleaseMenuPopup(IMenuPopup** ppmp);
    void    _SetCacheMenuPopup(IMenuPopup* pmp);
    HRESULT _DropdownItem(LPCITEMIDLIST pidl, UINT idCmd);

    LRESULT _TryChannelSurfing(LPCITEMIDLIST pidl);
    HRESULT _GetChannelBrowser(IWebBrowser2 **ppwb);
    HRESULT _IStreamFromOrderList(VARIANT* pvarargOut);
    HRESULT _OrderListFromIStream(VARIANT* pvarargIn);

    IMenuPopup *_pmpCache;
    IMenuPopup *    _pmp;               // Submenu popup

    const GUID*     _pguidUEMGroup;


    BITBOOL         _fCascadeFolder :1;
    BITBOOL         _fNoRecalcDefaults :1;// Don't recalc defaults during GetBandInfo
    BITBOOL         _fInitialized :1;   // have we initialized the toolbar
    BITBOOL         _fDebossed :1;      // TRUE to enable debossed rebar style
    BITBOOL         _fLinksMode :1;     // TRUE: do not allow drag & drop onto content items.
    BITBOOL         _fHaveBkColor :1;    // TRUE if _crBkgnd is valid
    BITBOOL         _fHaveColors :1;    // TRUE if _crBtnXX are valid
    BITBOOL         _fFullOpen :1;      // TRUE if band should maximize when opened
    BITBOOL         _fClosing : 1;      // TRUE if we are shutting down....
    BITBOOL         _fDesktop :1;       // 1:desktop 0:browser(or non-ActDesk)
    BITBOOL         _fBtnMinSize :1;    // TRUE if band should report min thickness of button
    BITBOOL         _fDelayPainting :1;
    BITBOOL         _fChannels :1;      // TRUE if we want "Navigate Target" sup
    BITBOOL         _fCreatedBandProxy :1; // TRUE if we created a BandProxy ourself and hence need to call SetOwner on it
    BITBOOL         _fAllowDropdown: 1;
    BITBOOL         _fDelayInit :1;
    
    int             _eUemLog :2;        // UEMIND_* (NIL:off, o.w.:group)
    int             _iIdealLength;      // our ideal height/width last time bandsite asked
    
    COLORREF        _crBkgnd;           // Background color (must set _fHaveBkColor)
    COLORREF        _crBtnLt;           // Button hilite color (must set _fHaveColors)
    COLORREF        _crBtnDk;           // Button lolite color (must set _fHaveColors)

    DWORD _dwPriv; // private for bsmenu
    IBandProxy      * _pbp;

    HPALETTE _hpalOld;          // the old palette saved while we do a draw.....

    int _GetIdealSize(PSIZE psize);

    HRESULT _IsPidlVisible(LPITEMIDLIST pidl);

    virtual LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW* pnmcd);
    virtual void _OnDragBegin(int iItem, DWORD dwPreferedEffect);
    
    virtual void _CreateToolbar(HWND hwndParent);
    virtual HWND _CreatePager(HWND hwndParent);

    virtual int _GetBitmap(int iCommandID, PIBDATA pibData, BOOL fUseCache);
    virtual void _ToolbarChanged() { _BandInfoChanged(); };

    BOOL _IsChildID(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlChild);

    BOOL _UpdateIconSize(UINT fIconSize, BOOL fUpdateButtons);
    void _UpdateVerticalMode(BOOL fVertical);

    LRESULT _TryCascadingItem(LPCITEMIDLIST pidl, UINT uiCmd);
    LRESULT _TrySimpleInvoke(LPCITEMIDLIST pidl);

    HRESULT _SiteOnSelect(DWORD dwType);
    
    virtual HRESULT _GetTitleW(LPWSTR pwzTitle, DWORD cchSize);

    virtual void _Initialize();

    friend class CExtractImageTask;
    friend HRESULT CALLBACK UpdateBandLogo( LPVOID pData, DWORD dwItem, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );

    friend HRESULT FindBandInBandSite(IMenuPopup* pmpParent, IBandSite** ppbs, LPCITEMIDLIST pidl, REFIID riid, void** ppvOut);


    // stuff for CLogoBase
    virtual IShellFolder * GetSF();
    virtual HWND GetHWND();
    virtual REFTASKOWNERID GetTOID();
    virtual HRESULT OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HRESULT UpdateLogoCallback( DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );
    
    void _StopDelayPainting();
    void _FixupAppDataDirectory();
};

IMenuPopup* ISFBandCreateMenuPopup(IUnknown *punk, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
IMenuPopup* ISFBandCreateMenuPopup2(IUnknown *punk, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);

#define CGID_ISFBand CLSID_ISFBand

HRESULT CExtractImageTask_Create( CLogoBase* plb,
                                  LPEXTRACTIMAGE pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  LPRUNNABLETASK * ppTask );

#define EITF_SAVEBITMAP     0x00000001  // do not delete bitmap on destructor
#define EITF_ALWAYSCALL     0x00000002  // always call the update whether extract succeded or not

HRESULT IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\menuband.h ===
#ifndef _MENUBAND_H_
#define _MENUBAND_H_

#include "bands.h"
#include "mnbase.h"
#include "fadetsk.h"
#include "legacy.h"

#define CGID_MenuBand CLSID_MenuBand

// Flags for MBANDCID_POPUPITEM

#define MBPUI_SETITEM           0x00001
#define MBPUI_INITIALSELECT     0x00002
#define MBPUI_ITEMBYPOS      0x00004

#ifdef STARTMENUSPLIT
// Flags for constructor
#define MENUBAND_HORIZ      0x00000001
#define MENUBAND_TOPLEVEL   0x00000002
#endif

// Special indices for MBANDCID_SELECTITEM
#define MBSI_FIRSTITEM       0
#define MBSI_NONE           -1
#define MBSI_LASTITEM       -2

// This arrow is used when we are in Right-To-Left Mirror mode
#define CH_MENUARROWRTLA '3'

// Forward declare
struct CMBMsgFilter;

// Define this to get Shell Expando menu style
// Undefine to get "Office IntelliMenu" style
//#define DRAWEDGE

// The CMenuBand class handles all menu behavior for bands.  

class CMenuBandMetrics : public IUnknown
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    HFONT   _CalcFont(HWND hwnd, LPCTSTR pszFont, DWORD dwCharSet, TCHAR ch, int* pcx, 
        int* pcy, int* pcxMargin, int iOrientation, int iWeight);
    void    _SetMenuFont();         // (Called for TopLevMBand only) Sets: _hFontMenu
    void    _SetArrowFont(HWND hwnd);        // (Called for TopLevMBand only) Sets: _hFontArrow, _cyArrow
    void    _SetChevronFont(HWND hwnd);
    void    _SetTextBrush(HWND hwnd);

#ifndef DRAWEDGE
    void    _SetPaintMetrics(HWND hwnd);
#endif
    void    _SetColors();
    int     _cyArrow;               // Height of cascade arrow
    int     _cxArrow;               // Width of cascade arrow
    int     _cxMargin;              // Margin b/t text and arrow
    int     _cyChevron;
    int     _cxChevron;
    int     _cxChevronMargin;
    HCURSOR _hCursorOld;            // Cursor that was in use prior to entering menu mode
    HFONT   _hFontMenu;             // Font for menu text
    HFONT   _hFontArrow;            // Correct sized Marlett font for cascade arrow
    HFONT   _hFontChevron;
    HBRUSH  _hbrText;
#ifndef DRAWEDGE
    HPEN    _hPenHighlight;            // Pen for BTNHIGHLIGHT
    HPEN    _hPenShadow;               // Pen for BTNSHADOW
#endif

    COLORREF _clrBackground;
    COLORREF _clrDemoted;
    COLORREF _clrMenuText;

    BITBOOL  _fHighContrastMode;        // Accessibility

    CMenuBandMetrics(HWND hwnd);

private:
    ~CMenuBandMetrics();

    ULONG _cRef;
};


class CMenuBandState
{

    // Global State Variables
    BYTE    _fsUEMState;
    BOOL    _fKeyboardCue;
    CFadeTask* _ptFader;
    IShellTaskScheduler* _pScheduler;
    HWND    _hwndSubclassed;
    HWND    _hwndToolTip;
    HWND    _hwndWorker;
    void*   _pvContext;

    // Bits
    BITBOOL _fExpand: 1;
    BITBOOL _fContainsDrag: 1;
    BITBOOL _fTipShown: 1;
    BITBOOL _fBalloonStyle: 1;

    int     _cChangeNotify;

    // This will, in the future, contain the menuband stack
public:
    CMenuBandState();
    virtual ~CMenuBandState();

    // Set/Get the expand state for new popups.
    BOOL GetExpand()                { return (BOOL)_fExpand;      };
    void SetExpand(BOOL fExpand)    { _fExpand = BOOLIFY(fExpand);};
    BYTE GetUEMState()              { return _fsUEMState;         };
    void SetUEMState(BYTE bState)   { _fsUEMState = bState;       };
    BOOL GetKeyboardCue();
    void SetKeyboardCue(int iKC);
    BOOL HasDrag()                  { return _fContainsDrag;      };
    void HasDrag(BOOL fHasDrag)     { _fContainsDrag = BOOLIFY(fHasDrag); };
    void SetSubclassedHWND(HWND hwndSubclassed)   
                                    { _hwndSubclassed = hwndSubclassed; };
    HWND GetSubclassedHWND()        { return _hwndSubclassed; };
    HWND GetWorkerWindow(HWND hwndParent);
    void PushChangeNotify()         { ++_cChangeNotify; };
    void PopChangeNotify()          { --_cChangeNotify; };
    BOOL IsProcessingChangeNotify() { return _cChangeNotify != 0;   };

    // Context Stuff
    // a menuband context is used for the global message filter. Since we may have
    // more than one menu present in the system, there is a race condition that can occur
    // where the menu in one thread tries to pop off it's menus, when a menuband in another thread
    // tries to push them on. Through the use of a context, we can know when this is happening and
    // make sure that we pop all of the menus of one context before pushing from another.
    // - lamadio 9.15.98
    void SetContext(void* pvContext)    {_pvContext = pvContext;};
    void* GetContext()                  { return _pvContext;};

    // Fade Stuff
    BOOL FadeRect(PRECT prc, PFNFADESCREENRECT pfn, LPVOID pvParam);
    void CreateFader(HWND hwnd);
    IShellTaskScheduler* GetScheduler();

    // Chevron Tip Stuff
    void CenterOnButton(HWND hwndTB, BOOL fBalloon, int idCmd, LPTSTR pszTitle, LPTSTR szTip);
    void HideTooltip(BOOL fAllowBalloonCollapse);
    void PutTipOnTop();
};



interface IShellMenuAcc: public IUnknown
{
    // *** IShellMenuAcc methods ***
    STDMETHOD(GetTop)(THIS_ CMenuToolbarBase** ppmtbTop) PURE;
    STDMETHOD(GetBottom)(THIS_ CMenuToolbarBase** ppmtbBottom) PURE;
    STDMETHOD(GetTracked)(THIS_ CMenuToolbarBase** ppmtbTracked) PURE;
    STDMETHOD(GetParentSite)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD(GetState)(THIS_ BOOL* pfVertical, BOOL* pfOpen) PURE;
    STDMETHOD(DoDefaultAction)(THIS_ VARIANT* pvarChild) PURE;
    STDMETHOD(GetSubMenu)(THIS_ VARIANT* pvarChild, REFIID riid, void** ppvObj) PURE;
    STDMETHOD(IsEmpty)() PURE;
};

// {FAF6FE96-CE5E-11d1-8371-00C04FD918D0}
DEFINE_GUID(IID_IShellMenuAcc,              0xfaf6fe96, 0xce5e, 0x11d1, 0x83, 0x71, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);



class CMenuBand : public CToolBand,
                  public IMenuPopup,
                  public IMenuBand,
                  public IShellMenu2,
                  public IWinEventHandler,
                  public IShellMenuAcc
{
    // REVIEW (lamadio): I don't like this. Should I make these nested classes?
    friend class CMenuToolbarBase;
    friend class CMenuSFToolbar;
    friend class CMenuStaticToolbar;
    friend struct CMBMsgFilter;

public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);
    
    // *** IInputObject methods (override) ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IDeskBar methods ***
    virtual STDMETHODIMP SetClient(IUnknown* punk) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetClient(IUnknown** ppunkClient) { return E_NOTIMPL; };
    virtual STDMETHODIMP OnPosRectChangeDB (LPRECT prc);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags) { return E_NOTIMPL; };

    // *** IMenuBand methods ***
    virtual STDMETHODIMP IsMenuMessage(MSG * pmsg);
    virtual STDMETHODIMP TranslateMenuMessage(MSG * pmsg, LRESULT * plRet);

    // *** IShellMenu methods ***
    virtual STDMETHODIMP Initialize(IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags);
    virtual STDMETHODIMP GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags);
    virtual STDMETHODIMP SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hkey, DWORD dwFlags);
    virtual STDMETHODIMP GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags);
    virtual STDMETHODIMP InvalidateItem(LPSMDATA psmd, DWORD dwFlags);
    virtual STDMETHODIMP GetState(LPSMDATA psmd);
    virtual STDMETHODIMP SetMenuToolbar(IUnknown* punk, DWORD dwFlags);

    // *** IShellMenu2 methods ***
    virtual STDMETHODIMP GetSubMenu(UINT idCmd, REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP SetToolbar(HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP SetMinWidth(int cxMenu);
    virtual STDMETHODIMP SetNoBorder(BOOL fNoBorder);
    virtual STDMETHODIMP SetTheme(LPCWSTR pszTheme);

    // ** IPersist ***
    virtual STDMETHODIMP GetClassID(CLSID*) { return E_NOTIMPL; };
    virtual STDMETHODIMP Load(IStream*) { return E_NOTIMPL; };
    virtual STDMETHODIMP Save(IStream*, BOOL) { return E_NOTIMPL; };

    // ** IWinEventHandler ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);


    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IOleCommandTarget ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);

    // *** IShellMenuAcc ***
    virtual STDMETHODIMP GetTop(CMenuToolbarBase** ppmtbTop);
    virtual STDMETHODIMP GetBottom(CMenuToolbarBase** ppmtbBottom);
    virtual STDMETHODIMP GetTracked(CMenuToolbarBase** ppmtbTracked);
    virtual STDMETHODIMP GetParentSite(REFIID riid, void** ppvObj);
    virtual STDMETHODIMP GetState(BOOL* pfVertical, BOOL* pfOpen);
    virtual STDMETHODIMP DoDefaultAction(VARIANT* pvarChild);
    virtual STDMETHODIMP GetSubMenu(VARIANT* pvarChild, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP IsEmpty();
    
    // Other methods
    LRESULT GetMsgFilterCB(MSG * pmsg, BOOL bRemove);
    inline BOOL IsInSubMenu(void)       { return _fInSubMenu; };
    inline DWORD GetFlags()   {return _dwFlags; };
    
    // Other public methods
    void    ResizeMenuBar();        // Make our parent menubar resize
    void    SetTrackMenuPopup(IUnknown* punk);
    HRESULT ForwardChangeNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);   // Change notify Forwarder.

    CMenuBand();


    BOOL    SetTracked(CMenuToolbarBase* pmtb);

#ifdef UNIX
    BOOL RemoveTopLevelFocus();
#endif

private:

    friend HRESULT     CMenuBand_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
    friend CMenuBand * CMenuBand_Create(IShellFolder * psf, LPCITEMIDLIST pidl, BOOL bTopLevel);
    friend VOID CALLBACK CMenuBand_TimerProc( HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime );

    virtual ~CMenuBand();

    void    _Initialize(DWORD dwFlags);// Flags are MENUBAND_*

    HRESULT _EnterMenuMode(void);
    void    _ExitMenuMode(void);
    void    _GetFontMetrics();      // (Called for non-TopLevelMBands) Uses IUnk_QS to set
                                    //  _hFontMenu, _hFontArrow, _cyArrow based on TopLevel's values
    void    _CancelMode(DWORD dwType);
    void    _AddToolbar(CMenuToolbarBase* pmtb, DWORD dwFlags);
    HRESULT _SiteOnSelect(DWORD dwType);
    HRESULT _SubMenuOnSelect(DWORD dwType);

    HRESULT _OnSysChar(MSG * pmsg, BOOL bFirstDibs);
    HRESULT _HandleAccelerators(MSG * pmsg);

    HRESULT _SiteSetSubMenu(IMenuPopup * pmp, BOOL bSet);

    void    _OnSelectArrow(int iDir);
    void    _UpdateButtons();

    HRESULT _CallCB(DWORD dwMsg, WPARAM wParam = 0, LPARAM lParam = 0);
    HRESULT _ProcessMenuPaneMessages(MSG* pmsg);

    
    // Member variables
    int     _nItemCur;              // Current item selected
    int     _nItemNew;              // New item to be selected/expanded
    int     _nItemTimer;            // the timer id for popping up cascading menus
    int     _nItemMove;             // Current item being moved
    int     _nItemSubMenu;          // item that's cascaded
    HWND    _hwndFocusPrev;
    HWND    _hwndParent;

    CMenuToolbarBase*   _pmtbMenu;          // The static menu toolbar 
                                            //  (may be pmtbTop or pmtbBottom)
    CMenuToolbarBase*   _pmtbShellFolder;   // Non-menu toolbar (shellfolder or other)
                                            //  (may be pmtbTop or pmtbBottom)
    
    CMenuToolbarBase*   _pmtbTop;           // The top toolbar
    CMenuToolbarBase*   _pmtbBottom;        // The bottom toolbar (may be == pmtbTop)
    CMenuToolbarBase*   _pmtbTracked;       // This is transient, may be pmtbTop or pmtbBottom

    IAugmentedShellFolder2* _pasf2;

    UINT    _uId;       // Id of this band (Derived from the item that poped it up)
    UINT    _uIdAncestor;   // Id of the top most menu item.
    HMENU   _hmenu;
    HWND    _hwndMenuOwner;
    DWORD   _dwMenuFlags;


    CMenuBandState*     _pmbState;              // Menu Band global state
    CMenuBandMetrics*   _pmbm;
    IShellMenuCallback* _psmcb;             // Callback Mechanism
    HCURSOR             _hCursorOld;
    DWORD               _dwFlags;
    UINT                _uIconSize;

    IMenuPopup*         _pmpSubMenu;        // Cached submenu
    IMenuPopup*         _pmpTrackPopup;     // BUGBUG: Find a way to use only menubands.

    void*               _pvUserData;        // User associated data.


    BITBOOL _fTopLevel: 1;          // TRUE: this is the toplevel parent menu
                                    //       (may be vertical for context menus)
    BITBOOL _fMenuMode: 1;          // TRUE: we are in menu mode
    BITBOOL _fPopupNewMenu: 1;      // TRUE: popup a new menu (_nItemNew) 
                                    //    once done with current menu
    BITBOOL _fInitialSelect: 1;     // TRUE: select first item when popping up submenu
    BITBOOL _fInSubMenu: 1;         // TRUE: currently in a submenu
    BITBOOL _fAltSpace: 1;          // TRUE: Alt-space was hit
    BITBOOL _fMenuFontCreated: 1;   // TRUE: This instance created the font and should delete it
    BITBOOL _fArrowFontCreated: 1;  // TRUE: This instance created the font and should delete it
    BITBOOL _fEmpty: 1;             // TRUE: Menu is empty
    BITBOOL _fParentIsNotASite: 1;  
    BITBOOL _fKeyboardSelected: 1;  
    BITBOOL _fInvokedByDrag: 1;     // TRUE: the menu cascaded open b/c of drag/drop
    BITBOOL _fDragEntered : 1;
    BITBOOL _fSysCharHandled: 1;    // TRUE: WM_SYSCHAR was already handled
    BITBOOL _fHasSubMenu:1;
    BITBOOL _fAppActive:1;       // TRUE: The Menus should be drawn using Memphis' grey menu.
    BITBOOL _fVertical: 1;
    BITBOOL _fShow : 1;
    BITBOOL _fClosing: 1;           // TRUE: When CloseDW is called.
    BITBOOL _fForceButtonUpdate: 1; // TRUE: Force a v_UpdateButtons.
    BITBOOL _fProcessingDup: 1;     // TRUE: when the contained classes are processing Dup chars.
    BITBOOL _fExpanded: 1;          // TRUE: This band is expanded
    BITBOOL _fCascadeAnimate: 1;
    BITBOOL _fPopupNewItemOnShow: 1;    // Causes _nItemNew to be displayed at ShowDW time.
    BITBOOL _fParentIsHorizontal: 1;

#ifdef DEBUG
    BITBOOL _fInitialized: 1;
#endif
    

    DEBUG_CODE( int _nMenuLevel; )
};

CMenuBand * CMenuBand_Create(IShellFolder * psf, LPCITEMIDLIST pidl, BOOL bHorizontal);
int MsgFilter_GetCount();
HRESULT IUnknown_BandChildSetKey(IUnknown* punk, HKEY hKey);

// The message filter redirects messages to the menuband
// that is at the top of the stack.  Each additional cascade
// pushes the new menuband onto the stack, and a cancel-level
// pops one off.
typedef struct tagMBELEM
{
    CMenuBand * pmb;
    HWND        hwndTB;
    HWND        hwndBar;
    RECT        rc;             // rect of hwndBar
    BITBOOL     bInitRect: 1;   // TRUE: rc is initialized
} MBELEM;

#define CMBELEM_INIT    10
#define CMBELEM_GROW    10

struct CMBMsgFilter
{
public:
    HHOOK       _hhookMsg;
    HWND        _hwndCapture;
    FDSA        _fdsa;              // Stack
    MBELEM      _rgmbelem[CMBELEM_INIT];
    BITBOOL     _fPreventCapture : 1;
    BITBOOL     _fInitialized: 1;
    BITBOOL     _fSetAtPush: 1;
    BITBOOL     _fDontIgnoreSysChar: 1;
    BITBOOL     _fEngaged: 1;
    BITBOOL     _fModal: 1;
    BITBOOL     _fAllocated: 1;
    POINT       _ptLastMove;
    CMenuBand*  _pmb;
    int         _iSysCharStack;
    void*       _pvContext;
    HCURSOR     _hcurArrow;
    int         _cRef;
    
    DEBUG_CODE( int _nMenuLevel; )
    void    AddRef();
    void    Release();


    void    ForceModalCollapse();
    void    SetModal(BOOL fModal);      // This is so that
                                        // a modal message band (Links)
                                        // sets activation correctly.
    void*   GetContext()    {   return _pvContext;  };
    void    SetContext(void* pvContext, BOOL fSet);
    void    Push(void* pvContext, CMenuBand * pmb, IUnknown * punkSite);
    int     Pop(void* pvContext);
    void    RetakeCapture(void);
    void    AcquireMouseLocation()   { GetCursorPos(&_ptLastMove); };


    void    ReEngage(void* pvContext);
    void    DisEngage(void* pvContext);
    BOOL    IsEngaged()  { return _fEngaged;};

    CMenuBand * _GetBottomMostSelected(void);
    CMenuBand * _GetTopPtr(void);
    CMenuBand * _GetWindowOwnerPtr(HWND hwnd);
    CMenuBand * _HitTest(POINT pt, HWND * phwnd = NULL);
    LRESULT     _HandleMouseMsgs(MSG * pmsg, BOOL bRemove);
    int         GetCount();
    void        PreventCapture(BOOL bSet) { _fPreventCapture = BOOLIFY(bSet); }
    CMenuBand * GetTopMostPtr(void)         { return _pmb; };
    void        SetTopMost(CMenuBand* pmb)  {_pmb = pmb; };
    void        SetHook(BOOL fSet, BOOL fIgnoreSysChar); 

    static LRESULT CALLBACK GetMsgHook(int nCode, WPARAM wParam, LPARAM lParam);

//private:
};

CMBMsgFilter* GetMessageFilter();

extern CMBMsgFilter g_msgfilter;
extern UINT    g_nMBPopupOpen;
extern UINT    g_nMBFullCancel;
extern UINT    g_nMBDragCancel;
extern UINT    g_nMBAutomation;
extern UINT    g_nMBExecute;
extern UINT    g_nMBOpenChevronMenu;
extern long g_lMenuPopupTimeout;


#define MBTIMER_POPOUT      0x00008001         // event ID for popout menu timer
#define MBTIMER_DRAGOVER    0x00008002         // event ID for popout menu timer
#define MBTIMER_EXPAND      0x00008003
#define MBTIMER_TIMEOUT     (GetDoubleClickTime() * 4 / 5) // same formula that USER uses

#define MBTIMER_ENDEDIT     0x00008004
#define MBTIMER_ENDEDITTIME 1000

#define MBTIMER_CLOSE       0x00008005
#define MBTIMER_CLOSETIME   2000

#define MBTIMER_CLICKUNHANDLE 0x00008006

// Flashing Support
#define MBTIMER_FLASH       0x00008007
#define MBTIMER_FLASHTIME   100
#define COUNT_ENDFLASH      8

// UEM Profiling.
#define MBTIMER_UEMTIMEOUT  0x00008008

#define MBTIMER_DRAGPOPDOWN 0x00008009
#define MBTIMER_DRAGPOPDOWNTIMEOUT     (2 * GetDoubleClickTime()) //ASSERT(MBTIMER_DRAGPOPDOWNTIMEOUT > 
                                                        // MBTIMER_TIMEOUR)

#define MBTIMER_CHEVRONTIP  0x0000800A

#define MBTIMER_INFOTIP     0x0000800B
#define CH_RETURN       0xd

#define szfnMarlett     TEXT("MARLETT")

#endif  // _MENUBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\menuband.cpp ===
#include "priv.h"
#include "sccls.h"
#include "menuband.h"
#include "itbar.h"
#include "bands.h"
#include "isfband.h"
#include "menubar.h"
#include "dpastuff.h"       // COrderList_*
#include "theater.h"
#include "resource.h"
#include "oleacc.h"
#include "apithk.h"
#include "uemapp.h"
#include "mnbase.h"
#include "mnfolder.h"
#include "mnstatic.h"
#include "iaccess.h"
#include "tbmenu.h"

#include "mluisupp.h"

// BUGBUG (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"

#define DM_MISC     0               // miscellany

#define PF_USINGNTSD    0x00000400      // set this if you're debugging on ntsd

// This must be reset to -1 on any WM_WININICHANGE.  We do it in
// shbrows2.cpp, but if there are no browser windows open when the
// metric changes, we end up running around with a stale value.  Oh well.
long g_lMenuPopupTimeout = -1;
static DWORD g_tlsMessageFilter = -1;


// {AD35F50A-0CC0-11d3-AE2D-00C04F8EEA99}
static const CLSID CLSID_MenuBandMetrics =
{ 0xad35f50a, 0xcc0, 0x11d3, { 0xae, 0x2d, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99
} };

// Registered window messages for the menuband
UINT    g_nMBPopupOpen = 0;
UINT    g_nMBFullCancel = 0;
UINT    g_nMBDragCancel = 0;
UINT    g_nMBAutomation = 0;
UINT    g_nMBExecute = 0;
UINT    g_nMBOpenChevronMenu = 0;
HCURSOR g_hCursorArrow = NULL;
//UINT    g_nMBIgnoreNextDeselect = 0;  // Dealt with in menuisf.cpp

BOOL IsAncestor(HWND hwndChild, HWND hwndAncestor)
{
    HWND hwnd = hwndChild;
    while (hwnd != hwndAncestor && hwnd != NULL)
    {
        hwnd = GetParent(hwnd);
    } 

    return hwndAncestor == hwnd;
}

//=================================================================
// Implementation of menuband message filter
//=================================================================

extern "C" void DumpMsg(LPCTSTR pszLabel, MSG * pmsg);


// Just one of these, b/c we only need one message filter
CMBMsgFilter g_msgfilter = { 0 };     

void FreeMessageFilter(CMBMsgFilter* that)
{
    if (g_tlsMessageFilter != -1)
    {
        CMBMsgFilter* pmf = (CMBMsgFilter*)TlsGetValue(g_tlsMessageFilter);

        if (pmf == that)
        {
            TlsSetValue(g_tlsMessageFilter, NULL);
        }
    }
}

void CMBMsgFilter::AddRef()
{
    _cRef++;

}

void CMBMsgFilter::Release()
{
    _cRef--;
    if (_cRef <= 0 && _fAllocated)
    {
        FreeMessageFilter(this);
        delete this;
    }
}

void CMBMsgFilter::SetModal(BOOL fModal)
{
    // There was an interesting problem:
    //   Click on the Chevron menu. Right click Delete. 
    //   The menus were hosed
    // Why?
    //   Well, I'll tell you:
    //   We got a deactivate on the subclassed window. We have
    //   2 menus subclassing it: The Main menu, and the modal
    //   chevron menu. Problem is, the main menu snagged the WM_ACTIVATE
    //   and does a set context. This causes a Pop and releases the Message hook.
    //   Since I still had a menu up, this caused havoc.
    //   So I introduced a concept of a "Modal" menuband. 
    //   This says: "Ignore any request to change contexts until I'm done". When
    //   that modal band is done, it sets the old context back in.
    //   Seems like a hack, but we need a better underlying archtecture for
    //   the message passing.
    _fModal = fModal;
}

void CMBMsgFilter::ReEngage(void* pvContext)      
{ 
    // We need to make sure that we don't dis/reengage when 
    // switching contexts
    if (pvContext == _pvContext)
        _fEngaged = TRUE; 
}

void CMBMsgFilter::DisEngage(void* pvContext)     
{ 
    if (pvContext == _pvContext)
        _fEngaged = FALSE;
}

int CMBMsgFilter::GetCount()
{
    return FDSA_GetItemCount(&_fdsa);
}

int MsgFilter_GetCount()
{
    return GetMessageFilter()->GetCount();
}

CMenuBand * CMBMsgFilter::_GetTopPtr(void)   
{ 
    CMenuBand * pmb = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, cItems-1, MBELEM); 
        pmb = pmbelem->pmb;
    }
    return pmb;
}

CMenuBand * CMBMsgFilter::_GetBottomMostSelected(void)
{
    // Ick, I can't believe I just did this. Mix COM and C++ identities... Yuck.
    CMenuBand* pmb = NULL;
    if (_pmb)
    {
        IUnknown_QueryService(SAFECAST(_pmb, IMenuBand*), SID_SMenuBandBottomSelected, CLSID_MenuBand, (void**)&pmb);

        // Since we have the C++ identity, release the COM identity.
        if (pmb)
            pmb->Release();
    }

    return pmb;
}


CMenuBand * CMBMsgFilter::_GetWindowOwnerPtr(HWND hwnd)   
{ 
    CMenuBand * pmb = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        // Go thru the list of bands on the stack and return the
        // one who owns the given window.
        int i;

        for (i = 0; i < cItems; i++)
        {
            MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, i, MBELEM); 
            if (pmbelem->pmb && S_OK == pmbelem->pmb->IsWindowOwner(hwnd))
            {
                pmb = pmbelem->pmb;
                break;
            }
        }
    }
    return pmb;
}


/*----------------------------------------------------------
Purpose: Return menuband or NULL based upon hittest.  pt must be 
         in screen coords
*/
CMenuBand * CMBMsgFilter::_HitTest(POINT pt, HWND * phwnd)
{ 
    CMenuBand * pmb = NULL;
    HWND hwnd = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        // Go thru the list of bands on the stack and return the
        // one who owns the given window.  Work backwards since the
        // later bands are on top (z-order), if the menus ever overlap.
        int i = cItems - 1;

        while (0 <= i)
        {
            MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, i, MBELEM); 

            RECT rc;

            // Do this dynamically because the hwndBar hasn't been positioned
            // until after this mbelem has been pushed onto the msg filter stack.
            GetWindowRect(pmbelem->hwndBar, &rc);
            
            if (PtInRect(&rc, pt))
            {
                pmb = pmbelem->pmb;
                hwnd = pmbelem->hwndTB;
                break;
            }
            i--;
        }
    }

    if (phwnd)
        *phwnd = hwnd;

    return pmb;
}


void CMBMsgFilter::RetakeCapture(void)
{
    // The TrackPopupMenu submenus can steal the capture.  Take
    // it back.  Don't take it back if the we're in edit mode,
    // because the modal drag/drop loop has the capture at that
    // point.
    // We do not want to take capture unless we are engaged. 
    // We need to do this because we are not handling mouse messages lower down
    // in the code. When we set the capture, the messages that we do not handle
    // trickle up to the top level menu, and can cause weird problems (Such
    // as signaling a "click out of bounds" or a context menu of the ITBar)
    if (_hwndCapture && !_fPreventCapture && _fEngaged)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Setting capture to %#lx", _hwndCapture);
        SetCapture(_hwndCapture);
    }
}    

void CMBMsgFilter::SetHook(BOOL fSet, BOOL fDontIgnoreSysChar)
{
    if (fDontIgnoreSysChar)
        _iSysCharStack += fSet? 1: -1;

    if (NULL == _hhookMsg && fSet)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Initialize");
        _hhookMsg = SetWindowsHookEx(WH_GETMESSAGE, GetMsgHook, HINST_THISDLL, GetCurrentThreadId());
        _fDontIgnoreSysChar = fDontIgnoreSysChar;
    }
    else if (!fSet && _iSysCharStack == 0)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Hook removed");
        if (_hhookMsg)
        {
            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;
        }
    }
}

// 1) Set Deskbars on Both Monitors and set to chevron
// 2) On Monitor #2 open a chevron
// 3) On Monitor #1 open a chevron then open the Start Menu
// Result: Start Menu does not work.

// The reason is, we set the _fModal of the global message filter. This prevents context switches. Why? 
// The modal flag was invented to solve context switching problems with the browser frame. So what causes this?
// Well, when switching from #2 to #3, we have not switched contexts. But since we got a click out of bounds, we collapse
// the previous menu. When switching from #3 to #4, neither have the context, so things get messy.

void CMBMsgFilter::ForceModalCollapse()
{
    if (_fModal)
    {
        _fModal = FALSE;
        SetContext(NULL, TRUE);
    }
}

void CMBMsgFilter::SetContext(void* pvContext, BOOL fSet)
{
    TraceMsg(TF_MENUBAND, "CMBMsgFilter::SetContext from 0x%x to 0x%x", _pvContext, pvContext);
    // When changing a menuband context, we need to pop all of the items
    // in the stack. This is to prevent a race condition that can occur.

    // We do not want to pop all of the items off the stack if we're setting the same context.
    // We do a set context on Activation, Both when we switch from one Browser frame to another
    // but also when right clicking or causing the Rename dialog to be displayed.

    BOOL fPop = FALSE;

    if (_fModal)
        return;

    // Are we setting a new context?
    if (fSet)
    {
        // Is this different than the one we've got?
        if (pvContext != _pvContext)
        {
            // Yes, then we need to pop off all of the old items.
            fPop = TRUE;
        }

        _pvContext = pvContext;
    }
    else
    {
        // Then we are trying to unset the message hook. Make sure it still belongs to
        // this context
        if (pvContext == _pvContext)
        {
            // This context is trying to unset itself, and no other context owns it.
            // remove all the old items.
            fPop = TRUE;
        }
    }

    if (fPop)
    {
        CMenuBand* pcmb = _GetTopPtr();
        if (pcmb)
        {
            PostMessage(pcmb->_pmbState->GetSubclassedHWND(), g_nMBFullCancel, 0, 0);
            // No release.

            if (FDSA_GetItemCount(&_fdsa) != 0)
            {
                CMBMsgFilter* pmf = GetMessageFilter();
                while (pmf->Pop(pvContext))
                    ;
            }
        }
    }
}




/*----------------------------------------------------------
Purpose: Push another menuband onto the message filter's stack

*/
void CMBMsgFilter::Push(void* pvContext, CMenuBand * pmb, IUnknown * punkSite)
{
    ASSERT(IS_VALID_CODE_PTR(pmb, CMenuBand));
    TraceMsg(TF_MENUBAND, "CMBMsgFilter::Push called from context 0x%x", pvContext);

    if (pmb && pvContext == _pvContext)
    {
        BOOL bRet = TRUE;
        HWND hwndBand;

        pmb->GetWindow(&hwndBand);

        // If the bar isn't available use the band window
        HWND hwndBar = hwndBand;
        IOleWindow * pow;

        IUnknown_QueryService(punkSite, SID_SMenuPopup, IID_IOleWindow, 
                              (LPVOID *)&pow);
        if (pow)
        {
            pow->GetWindow(&hwndBar);
            pow->Release();
        }

        if (NULL == _hhookMsg)
        {
            // We want to ignore the WM_SYSCHAR message in the message filter because
            // we are using the IsMenuMessage call instead of the global message hook.
            SetHook(TRUE, FALSE);
            TraceMsg(TF_MENUBAND, "CMBMsgFilter::push Setting hook from context 0x%x", pvContext);
            _fSetAtPush = TRUE;
        }

        if (!_fInitialized)
        {
            ASSERT(NULL == _hwndCapture);
            _hwndCapture = hwndBar;

            _fInitialized = TRUE;

            bRet = FDSA_Initialize(sizeof(MBELEM), CMBELEM_GROW, &_fdsa, _rgmbelem, CMBELEM_INIT);

            // We need to initialize this for the top level guy so that we have the correct positioning
            // from the start of this new set of bands. This is used to eliminate spurious WM_MOUSEMOVE
            // messages which cause problems. See _HandleMouseMessages for more information
            AcquireMouseLocation();
        }

        if (EVAL(bRet))
        {
            MBELEM mbelem = {0};
            
            TraceMsg(TF_MENUBAND, "CMBMsgFilter: Push (pmp:%#08lx) onto stack", SAFECAST(pmb, IMenuPopup *));
            pmb->AddRef();

            mbelem.pmb = pmb;
            mbelem.hwndTB = hwndBand;
            mbelem.hwndBar = hwndBar;

            FDSA_AppendItem(&_fdsa, &mbelem);

            CMenuBand* pmbTop = _GetTopPtr();

            if ((pmbTop && (pmbTop->GetFlags() & SMINIT_LEGACYMENU)) || NULL == GetCapture())
                RetakeCapture();
        }
        else
        {
            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;
            _hwndCapture = NULL;
        }
    }
}    


/*----------------------------------------------------------
Purpose: Pop a menuband off the message filter stack

         Returns the number of bands left on the stack
*/
int CMBMsgFilter::Pop(void* pvContext)
{
    int nRet = 0;

    TraceMsg(TF_MENUBAND, "CMBMsgFilter::pop called from context 0x%x", pvContext);

    // This can be called from a context switch or when we're exiting menu mode,
    // so we'll switch off the fact that we clear _hhookMsg when we pop the top twice.
    if (pvContext == _pvContext && _hhookMsg)
    {
        int iItem = FDSA_GetItemCount(&_fdsa) - 1;
        MBELEM * pmbelem;

        ASSERT(0 <= iItem);

        pmbelem = FDSA_GetItemPtr(&_fdsa, iItem, MBELEM);
        if (EVAL(pmbelem->pmb))
        {
            TraceMsg(TF_MENUBAND, "CMBMsgFilter: Pop (pmb=%#08lx) off stack", SAFECAST(pmbelem->pmb, IMenuPopup *));
            pmbelem->pmb->Release();
            pmbelem->pmb = NULL;
        }
        FDSA_DeleteItem(&_fdsa, iItem);

        if (0 == iItem)
        {

            TraceMsg(TF_MENUBAND, "CMBMsgFilter::pop removing hook from context 0x%x", pvContext);
            if (_fSetAtPush)
                SetHook(FALSE, FALSE);

            PreventCapture(FALSE);
            _fInitialized = FALSE;

            if (_hwndCapture && GetCapture() == _hwndCapture)
            {
                TraceMsg(TF_MENUBAND, "CMBMsgFilter: Releasing capture");
                ReleaseCapture();
            }
            _hwndCapture = NULL;
        }
#ifdef UNIX
        else if (1 == iItem)
        {
            CMenuBand * pmb = _GetTopPtr();
            if( pmb )
            {
                // Change item count only if we delete successfully.
                if( pmb->RemoveTopLevelFocus() )
                    iItem = FDSA_GetItemCount(&_fdsa);
            }
        }
#endif
        nRet = iItem;
  
        
    }
    return nRet;
}    


LRESULT CMBMsgFilter::_HandleMouseMsgs(MSG * pmsg, BOOL bRemove)
{
    LRESULT lRet = 0;
    CMenuBand * pmb;
    HWND hwnd = GetCapture();

    // Do we still have the capture?
    if (hwnd != _hwndCapture)
    {
        // No; is it b/c a CTrackPopupBar has it?

#if 0 // Nuke this trace because I was getting annoyed.
        //def DEBUG
        pmb = _GetTopPtr();
        if (!EVAL(pmb) || !pmb->IsInSubMenu())
        {
            // No
            TraceMsg(TF_WARNING, "CMBMsgFilter: someone else has the capture (%#lx)", hwnd);
        }
#endif
        if (NULL == hwnd)
        {
            // There are times that we must retake the capture because
            // TrackPopupMenuEx has taken it, or some context menu
            // might have taken it, so take it back.
            RetakeCapture();
            TraceMsg(TF_WARNING, "CMBMsgFilter: taking the capture back");
        }
    }
    else
    {
        // Yes; decide what to do with it
        POINT pt;
        HWND hwndPt;
        MSG msgT;

        pt.x = GET_X_LPARAM(pmsg->lParam);
        pt.y = GET_Y_LPARAM(pmsg->lParam);
        ClientToScreen(pmsg->hwnd, &pt);

        if (WM_MOUSEMOVE == pmsg->message)
        {
            // The mouse cursor can send repeated WM_MOUSEMOVE messages
            // with the same coordinates.  When the user tries to navigate
            // thru the menus with the keyboard, and the mouse cursor
            // happens to be over a menu item, these spurious mouse 
            // messages cause us to think the menu has been invoked under
            // the mouse cursor.  
            //
            // To avoid this unpleasant rudeness, we eat any gratuitous
            // WM_MOUSEMOVE messages.
            if (_ptLastMove.x == pt.x && _ptLastMove.y == pt.y)
            {
                pmsg->message = WM_NULL;
                goto Bail;
            }

            // Since this is not a duplicate point, we need to keep it around. 
            // We will use this stored point for the above comparison

            // msadek; W2k bug# 426005
            // On a mirrored system, we got a system bug as mouse coordinates has an off-by-one
            // This makes comparing the value with what we got from GetCursorPos() always fail.
            // Do not use AcquireMouseLocation().

            if(!IS_WINDOW_RTL_MIRRORED(pmsg->hwnd))
            {
                AcquireMouseLocation();
            }
            else
            {
                _ptLastMove.x = pt.x;
                _ptLastMove.y = pt.y;                
            }
            

            if (_hcurArrow == NULL)
                _hcurArrow = LoadCursor(NULL, IDC_ARROW);

            if (GetCursor() != _hcurArrow)
                SetCursor(_hcurArrow);

        }

        pmb = _HitTest(pt, &hwndPt);

        if (pmb)
        {
            // Forward mouse message onto appropriate menuband.  Note
            // the appropriate menuband's GetMsgFilterCB (below) will call
            // ScreenToClient to convert the coords correctly.

            // Use a stack variable b/c we don't want to confuse USER32
            // by changing the coords of the real message.
            msgT = *pmsg;
            msgT.lParam = MAKELPARAM(pt.x, pt.y);
            lRet = pmb->GetMsgFilterCB(&msgT, bRemove);

            // Remember the changed message (if there was one)
            pmsg->message = msgT.message;   
        }
        // Debug note: to debug menubands on ntsd, set the prototype
        // flag accordingly.  This will keep menubands from going
        // away the moment the focus changes to the NTSD window.

        else if ((WM_LBUTTONDOWN == pmsg->message || WM_RBUTTONDOWN == pmsg->message) &&
            !(g_dwPrototype & PF_USINGNTSD))
        {
            // Mouse down happened outside the menu.  Bail.
            pmb = _GetTopPtr();
            if (EVAL(pmb))
            {
                msgT.hwnd = pmsg->hwnd;
                msgT.message = g_nMBFullCancel;
                msgT.wParam = 0;
                msgT.lParam = 0;

                TraceMsg(TF_MENUBAND, "CMBMsgFilter (pmb=%#08lx): hittest outside, bailing", SAFECAST(pmb, IMenuPopup *));
                pmb->GetMsgFilterCB(&msgT, bRemove);
            }
#if 0
            // Now send the message to the originally intended window
            SendMessage(pmsg->hwnd, pmsg->message, pmsg->wParam, pmsg->lParam);
#endif
        }
        else
        {
            pmb = _GetTopPtr();
            if (pmb)
            {
                IUnknown_QueryServiceExec(SAFECAST(pmb, IOleCommandTarget*), SID_SMenuBandBottom, 
                    &CGID_MenuBand, MBANDCID_SELECTITEM, MBSI_NONE, NULL, NULL);
            }
        }
    }

Bail:
    return lRet;    
}    


/*----------------------------------------------------------
Purpose: Message hook used to track keyboard and mouse messages
         while the menuband is "active".  
         
         The menuband can't steal the focus away -- we use this
         hook to catch messages.

*/
LRESULT CMBMsgFilter::GetMsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;
    BOOL bRemove = (PM_REMOVE == wParam);
    CMBMsgFilter* pmf = GetMessageFilter();


    // The global message filter may be in a state when we are not processing messages,
    // but the menubands are still displayed. A situation where this will occur is when
    // a dialog box is displayed because of an interaction with the menus.

    // Are we engaged? (Are we allowed to process messages?)
    if (pmf->_fEngaged)
    {
        if (WM_SYSCHAR == pmsg->message)
        {
            // _fDontIgnoreSysChar is set when the Menubands ONLY want to know about
            // WM_SYSCHAR and nothing else.
            if (pmf->_fDontIgnoreSysChar)
            {
                CMenuBand * pmb = pmf->GetTopMostPtr();
                if (pmb)
                    lRet =  pmb->GetMsgFilterCB(pmsg, bRemove);
            }
        }
        else if (pmf->_fInitialized) // Only filter if we are initalized (have items on the stack)
        {
            switch (nCode)
            {
            case HC_ACTION:
        #ifdef DEBUG
                if (g_dwDumpFlags & DF_GETMSGHOOK)
                    DumpMsg(TEXT("GetMsg"), pmsg);
        #endif

                // A lesson about GetMsgHook: it gets the same message
                // multiple times for as long as someone calls PeekMessage
                // with the PM_NOREMOVE flag.  So we want to take action 
                // only when PM_REMOVE is set (so we don't handle more than
                // once).  If we modify any messages to redirect them (on a
                // regular basis), we must modify all the time so we don't 
                // confuse the app.

                // Messages get redirected to different bands in the stack
                // in this way:
                //
                //  1) Keyboard messages go to the currently open submenu 
                //     (topmost on the stack).  
                //
                //  2) The PopupOpen message goes to the hwnd that belongs 
                //     to the menu band (via IsWindowOwner).
                //

                switch (pmsg->message)
                {
                case WM_SYSKEYDOWN:
                case WM_KEYDOWN:
                case WM_CHAR:
                case WM_KEYUP:
                case WM_CLOSE:          // only this message filter gets WM_CLOSE
                    {
                        // There is a situation that can occur when the last selected
                        // menu pane is NOT the bottom most pane.
                        // We need to see if that last selected guy is tracking a context
                        // menu so that we forward the messages correctly.
                        CMenuBand * pmb = pmf->_GetBottomMostSelected();
                        if (pmb)
                        {
                            // Is it tracking a context menu?
                            if (S_OK == IUnknown_Exec(SAFECAST(pmb, IMenuBand*), &CGID_MenuBand, 
                                MBANDCID_ISTRACKING, 0, NULL, NULL))
                            {
                                // Yes, forward for proper handling.
                                lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                            }
                            else
                            {
                                // No; Then do the default processing. This can happen if there is no
                                // context menu, but there is a selected parent and not a selected child.
                                goto TopHandler;
                            }
                        }
                        else
                        {
                    TopHandler:
                            pmb = pmf->_GetTopPtr();
                            if (pmb)
                                lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                        }
                    }
                    break;

                case WM_NULL:
                    // Handle this here (we do nothing) to avoid mistaking this for
                    // g_nMBPopupOpen below, in case g_nMBPopupOpen is 0 if
                    // RegisterWindowMessage fails.
                    break;

                default:
                    if (bRemove && IsInRange(pmsg->message, WM_MOUSEFIRST, WM_MOUSELAST))
                    {
                        lRet = pmf->_HandleMouseMsgs(pmsg, bRemove);
                    }
                    else if (pmsg->message == g_nMBPopupOpen)
                    {
                        CMenuBand * pmb = pmf->_GetWindowOwnerPtr(pmsg->hwnd);
                        if (pmb)
                            lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                    }
                    else if (pmsg->message == g_nMBExecute)
                    {
                        CMenuBand * pmb = pmf->_GetWindowOwnerPtr(pmsg->hwnd);
                        if (pmb)
                        {
                            VARIANT var;
                            var.vt = VT_UINT_PTR;
                            var.ullVal = (UINT_PTR)pmsg->hwnd;
                            pmb->Exec(&CGID_MenuBand, MBANDCID_EXECUTE, (DWORD)pmsg->wParam, &var, NULL);
                        }
                    }

                    break;
                }
                break;

            default:
                if (0 > nCode)
                    return CallNextHookEx(pmf->_hhookMsg, nCode, wParam, lParam);
                break;
            }
        }
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        return CallNextHookEx(pmf->_hhookMsg, nCode, wParam, lParam);

    return 0;       // Always return 0
}    

CMBMsgFilter* GetMessageFilter()
{
    CMBMsgFilter* pmf = NULL;

    if (g_tlsMessageFilter == -1)
    {
        DWORD tls = TlsAlloc();
        if (tls != -1)
        {
            InterlockedExchange((LONG*)&g_tlsMessageFilter, tls);
            if (tls != g_tlsMessageFilter)
            {
                TlsFree(tls);
            }
        }
    }

    if (g_tlsMessageFilter != -1)
    {
        pmf = (CMBMsgFilter*)TlsGetValue(g_tlsMessageFilter);

        if (pmf == NULL)
        {
            pmf = new CMBMsgFilter;
            if (pmf)
            {
                pmf->_fAllocated = TRUE;
                TlsSetValue(g_tlsMessageFilter, pmf);
            }
        }
    }

    if (pmf == NULL)
        pmf = &g_msgfilter;

    return pmf;
}



//=================================================================
// Implementation of CMenuBand
//=================================================================

// Struct used by EXEC with a MBANDCID_GETFONTS to return fonts
typedef struct tagMBANDFONTS
{
    HFONT hFontMenu;    // [out]    TopLevelMenuBand's menu font
    HFONT hFontArrow;   // [out]    TopLevelMenuBand's font for drawing the cascade arrow
    int   cyArrow;      // [out]    Height of TopLevelMenuBand's cascade arrow
    int   cxArrow;      // [out]    Width of TopLevelMenuBand's cascade arrow
    int   cxMargin;     // [out]    Margin b/t text and arrow
} MBANDFONTS;

#define THISCLASS CMenuBand
#define SUPERCLASS CToolBand

#ifdef DEBUG
int g_nMenuLevel = 0;

#define DBG_THIS    _nMenuLevel, SAFECAST(this, IMenuPopup *)
#else
#define DBG_THIS    0, 0
#endif


CMenuBand::CMenuBand() :
    SUPERCLASS()
{
    GetMessageFilter()->AddRef();
    _fCanFocus = TRUE;

    _fAppActive = TRUE;

    _nItemNew = -1;
    _nItemCur = -1;
    _nItemTimer = -1;
    _uIconSize = ISFBVIEWMODE_SMALLICONS;
    _uIdAncestor = ANCESTORDEFAULT;
    _nItemSubMenu = -1;
}


// The purpose of this method is to finish initializing Menubands, 
// since it can be initialized in many ways. 

void CMenuBand::_Initialize(DWORD dwFlags)
{
    _fVertical = !BOOLIFY(dwFlags & SMINIT_HORIZONTAL);
    _fTopLevel = BOOLIFY(dwFlags & SMINIT_TOPLEVEL);

    _dwFlags = dwFlags;

    // We cannot have a horizontal menu if it is not the toplevel menu
    ASSERT(!_fVertical && _fTopLevel || _fVertical);

    if (_fTopLevel)
    {
        if (!g_nMBPopupOpen) 
        {
            g_nMBPopupOpen  = RegisterWindowMessage(TEXT("CMBPopupOpen"));
            g_nMBFullCancel = RegisterWindowMessage(TEXT("CMBFullCancel"));
            g_nMBDragCancel = RegisterWindowMessage(TEXT("CMBDragCancel"));
            g_nMBAutomation = RegisterWindowMessage(TEXT("CMBAutomation"));
            g_nMBExecute    = RegisterWindowMessage(TEXT("CMBExecute"));
            g_nMBOpenChevronMenu = RegisterWindowMessage(TEXT("CMBOpenChevronMenu"));

            g_hCursorArrow = LoadCursor(NULL, IDC_ARROW);
            TraceMsg(TF_MENUBAND, "CMBPopupOpen message = %#lx", g_nMBPopupOpen);
            TraceMsg(TF_MENUBAND, "CMBFullCancel message = %#lx", g_nMBFullCancel);
        }

        if (!_pmbState)
            _pmbState = new CMenuBandState;
    }

    DEBUG_CODE( _nMenuLevel = -1; )
}


CMenuBand::~CMenuBand()
{
    CMBMsgFilter* pmf = GetMessageFilter();
    // the message filter does not have a ref'd pointer to us!!!
    if (pmf->GetTopMostPtr() == this)
        pmf->SetTopMost(NULL);

    _CallCB(SMC_DESTROY);
    ATOMICRELEASE(_psmcb);

    // Cleanup
    CloseDW(0);

    if (_pmtbMenu)
        delete _pmtbMenu;

    if (_pmtbShellFolder)
        delete _pmtbShellFolder;

    
    ASSERT(_punkSite == NULL);
    ATOMICRELEASE(_pmpTrackPopup);

    ATOMICRELEASE(_pmbm);

    if (_fTopLevel)
    {
        if (_pmbState)
            delete _pmbState;
    }

    GetMessageFilter()->Release();
}


/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
HRESULT CMenuBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres = E_OUTOFMEMORY;
    CMenuBand* pObj = new CMenuBand();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IShellMenu*);
        hres = S_OK;
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: Internal create-instance function

*/
CMenuBand * CMenuBand_Create(IShellFolder* psf, LPCITEMIDLIST pidl,
                             BOOL bHorizontal)
{
    CMenuBand * pmb = NULL;

    if (psf || pidl)
    {
        DWORD dwFlags = bHorizontal ? (SMINIT_HORIZONTAL | SMINIT_TOPLEVEL) : 0;

        pmb = new CMenuBand();
        if (pmb)
        {
            pmb->_Initialize(dwFlags);
            pmb->SetShellFolder(psf, pidl, NULL, 0);
        }
    }
    return pmb;
}
#ifdef UNIX

BOOL CMenuBand::RemoveTopLevelFocus()
{
    if( _fTopLevel )
    {
        _CancelMode( MPOS_CANCELLEVEL );
        return TRUE;
    }

    return FALSE;
}

#endif
void CMenuBand::_UpdateButtons()
{
    if (_pmtbMenu) 
        _pmtbMenu->v_UpdateButtons(FALSE);
    if (_pmtbShellFolder)
        _pmtbShellFolder->v_UpdateButtons(FALSE);

    _fForceButtonUpdate = FALSE;
}

HRESULT CMenuBand::ForwardChangeNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // Given a change notify from the ShellFolder child, we will forward that notify to each of our
    // sub menus, but only if they have a shell folder child.

    HRESULT hres = E_FAIL;
    BOOL fDone = FALSE;
    CMenuToolbarBase* pmtb = _pmtbBottom;   // Start With the bottom toolbar. This is
                                            // is an optimization because typically
                                            // menus that have both a Shell Folder portion
                                            // and a static portion have the majority
                                            // of the change activity in the bottom portion.

    // This can be NULL on a shutdown, when we're deregistering change notifies
    if (pmtb)
    {
        HWND hwnd = pmtb->_hwndMB;


        for (int iButton = 0; !fDone; iButton++)
        {
            IShellChangeNotify* ptscn;

            int idCmd = GetButtonCmd(hwnd, iButton);

#ifdef DEBUG
                TCHAR szSubmenuName[MAX_PATH];
                SendMessage(hwnd, TB_GETBUTTONTEXT, idCmd, (LPARAM)szSubmenuName);
                TraceMsg(TF_MENUBAND, "CMenuBand: Forwarding Change notify to %s", szSubmenuName);
#endif

            // If it's not a seperator, see if there is a sub menu with a shell folder child.
            if (idCmd != -1 &&
                SUCCEEDED(pmtb->v_GetSubMenu(idCmd, &SID_MenuShellFolder, IID_IShellChangeNotify, (void**)&ptscn)))
            {
                IShellMenu* psm;
                // Don't forward this notify if the sub menu has specifically registered for change notify (By not passing
                // DontRegisterChangeNotify.
                if (SUCCEEDED(ptscn->QueryInterface(IID_IShellMenu, (void**)&psm)))
                {
                    UINT uIdParent = 0;
                    DWORD dwFlags = 0;
                    // Get the flags
                    psm->GetShellFolder(&dwFlags, NULL, IID_NULL, NULL);
                    psm->GetMenuInfo(NULL, &uIdParent, NULL, NULL);

                    // If this menupane is an "Optimized" pane, (meaning that we don't register for change notify
                    // and forward from a top level menu down) then we want to forward. We also
                    // forward if this is a child of Menu Folder. If it is a child,
                    // then it also does not register for change notify, but does not explicitly set it in it's flags
                    // (review: Should we set it in it's flags?)
                    // If it is not an optimized pane, then don't forward.
                    if ((dwFlags & SMSET_DONTREGISTERCHANGENOTIFY) ||
                        uIdParent == MNFOLDER_IS_PARENT)
                    {
                        // There is!, then pass to the child the change.
                        hres = ptscn->OnChange(lEvent, pidl1, pidl2);

                        // Update Dir on a Recursive change notify forces us to update everyone... Good thing
                        // this does not happen alot and is caused by user interaction most of the time.
                    }
                    psm->Release();
                }

                ptscn->Release();
            }

            // Did we go through all of the buttons on this toolbar?
            if (iButton >= ToolBar_ButtonCount(hwnd) - 1)
            {
                // Yes, then we need to switch to the next toolbar.
                if (_pmtbTop != _pmtbBottom && pmtb != _pmtbTop)
                {
                    pmtb = _pmtbTop;
                    hwnd = pmtb->_hwndMB;
                    iButton = -1;       // -1 because at the end of the loop the for loop will increment.
                }
                else
                {
                    // No; Then we must be done.
                    fDone = TRUE;
                }
            }
        }
    }
    else
        hres = S_OK;        // Return success because we're shutting down.

    return hres;
}

// Resize the parent menubar
VOID CMenuBand::ResizeMenuBar()
{
    // If we're not shown, then we do not need to do any kind of resize.
    // NOTE: Horizontal menubands are always shown. Don't do any of the 
    // vertical stuff if we're horizontal.
    if (!_fShow)
        return;

    // If we're horizontal, don't do any Vertical sizing stuff.
    if (!_fVertical)
    {
        // BandInfoChanged is only for Horizontal Menubands.
        _BandInfoChanged();
        return;
    }

    // We need to update the buttons before a resize so that the band is the right size.
    _UpdateButtons();

    // Have the menubar think about changing its height
    IUnknown_QueryServiceExec(_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
        MBCID_RESIZE, 0, NULL, NULL);
}


STDMETHODIMP CMenuBand::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = {
        QITABENT(CMenuBand, IMenuPopup),
        QITABENT(CMenuBand, IMenuBand),
        QITABENT(CMenuBand, IShellMenu),
        QITABENT(CMenuBand, IShellMenu2),
        QITABENT(CMenuBand, IWinEventHandler),
        QITABENT(CMenuBand, IShellMenuAcc),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);


    // BUGBUG (lamadio) 8.5.98: Nuke this. We should not expose the this pointer,
    // this is a bastardization of COM.
    if (FAILED(hres) && IsEqualGUID(riid, CLSID_MenuBand)) 
    {
        AddRef();
        *ppvObj = (LPVOID)this;
        hres = S_OK;
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuBand::QueryService(REFGUID guidService,
                                     REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL; // assume error

    if (IsEqualIID(guidService, SID_SMenuPopup) || 
        IsEqualIID(guidService, SID_SMenuBandChild) || 
        IsEqualIID(guidService, SID_SMenuBandParent) || 
        (_fTopLevel && IsEqualIID(guidService, SID_SMenuBandTop)))
    {
        if (IsEqualIID(riid, IID_IAccessible) || IsEqualIID(riid, IID_IDispatch))
        {
            hres = E_OUTOFMEMORY;
            CAccessible* pacc = new CAccessible(SAFECAST(this, IMenuBand*));

            if (pacc)
            {
                hres = pacc->InitAcc();
                if (SUCCEEDED(hres))
                {
                    hres = pacc->QueryInterface(riid, ppvObj);
                }
                pacc->Release();
            }
        }
        else
            hres = QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
             IsEqualIID(guidService, SID_SMenuBandBottomSelected))
    {
        // SID_SMenuBandBottom queries down
        BOOL fLookingForSelected = IsEqualIID(SID_SMenuBandBottomSelected, guidService);

        // Are we the leaf node?
        if (!_fInSubMenu)
        {
            if ( fLookingForSelected && 
                (_pmtbTracked == NULL ||
                 ToolBar_GetHotItem(_pmtbTracked->_hwndMB) == -1))
            {
                hres = E_FAIL;
            }
            else
            {
                hres = QueryInterface(riid, ppvObj);    // Yes; QI ourselves
            }
        }
        else 
        {
            // No; QS down...

            IMenuPopup* pmp = _pmpSubMenu;
            if (_pmpTrackPopup)
                pmp = _pmpTrackPopup;
            
            ASSERT(pmp);
            hres = IUnknown_QueryService(pmp, guidService, riid, ppvObj);
            if (FAILED(hres) && fLookingForSelected && _pmtbTracked != NULL)
            {
                hres = QueryInterface(riid, ppvObj);    // Yes; QI ourselves
            }
        }
    }
    else if (IsEqualIID(guidService, SID_MenuShellFolder))
    {
        // This is a method of some other menu in the scheme to get to specifically the MenuShellfolder,
        // This is for the COM Identity property.
        if (_pmtbShellFolder)
            hres = _pmtbShellFolder->QueryInterface(riid, ppvObj);
    }
    else
        hres = SUPERCLASS::QueryService(guidService, riid, ppvObj);

    return hres;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner method

*/
STDMETHODIMP CMenuBand::IsWindowOwner(HWND hwnd)
{
    if (( _pmtbShellFolder && (_pmtbShellFolder->IsWindowOwner(hwnd) == S_OK) ) ||
        (_pmtbMenu && (_pmtbMenu->IsWindowOwner(hwnd) == S_OK)))
        return S_OK;
    return S_FALSE;
}

#define MB_EICH_FLAGS (EICH_SSAVETASKBAR | EICH_SWINDOWMETRICS | EICH_SPOLICY | EICH_SSHELLMENU | EICH_KWINPOLICY)

/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent method

         Processes messages passed on from the bandsite.
*/
STDMETHODIMP  CMenuBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hres = NOERROR;

    EnterModeless();

    // Could our metrics be changing?  (We keep track of this only for the 
    // toplevel menu)
    BOOL fProcessSettingChange = FALSE;

    switch (uMsg)
    {
    case WM_SETTINGCHANGE:
        fProcessSettingChange = !lParam || (SHIsExplorerIniChange(wParam, lParam) & MB_EICH_FLAGS);
        break;

    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        fProcessSettingChange = TRUE;
        break;
    }

    if (_fTopLevel && 
        fProcessSettingChange && 
        _pmbState && !_pmbState->IsProcessingChangeNotify())
    {

        // There is a race condition that can occur during a refresh 
        // that's really nasty. It causes another one to get pumped in the
        // middle of processing this one, Yuck!
        _pmbState->PushChangeNotify();
        // There is a race condiction that can occur when the menuband is created,
        // but not yet initialized. This has been hit by the IEAK group....
        if (_pmtbTop)
        {
            // Yes; create a new metrics object and tell the submenus
            // about it.

            CMenuBandMetrics* pmbm = new CMenuBandMetrics(_pmtbTop->_hwndMB);

            if (pmbm)
            {
                ATOMICRELEASE(_pmbm);
                _pmbm = pmbm;

                if (_pmtbMenu)
                    _pmtbMenu->SetMenuBandMetrics(_pmbm);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->SetMenuBandMetrics(_pmbm);

                _CallCB(SMC_REFRESH, wParam, lParam);

                // We need to force a button update at some point so that the new sizes are calculated
                // Setting this flag will cause the buttons to be updatted before the next time it 
                // is shown. If, however, the menu is currently displayed, then the ResizeMenuBar will
                // recalculate immediatly.
                
                _fForceButtonUpdate = TRUE;
                RECT rcOld;
                RECT rcNew;

                // Resize the MenuBar
                GetClientRect(_hwndParent, &rcOld);
                ResizeMenuBar();
                GetClientRect(_hwndParent, &rcNew);

                // If the rect sizes haven't changed, then we need to re-layout the
                // band because the button widths may have changed.
                if (EqualRect(&rcOld, &rcNew) && _fVertical)
                    _pmtbTop->NegotiateSize();
            }
        }

        if (_pmtbMenu)
            hres = _pmtbMenu->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        if (_pmtbShellFolder)
            hres = _pmtbShellFolder->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        _pmbState->PopChangeNotify();
    }
    else
    {
        if (_pmtbMenu && (_pmtbMenu->IsWindowOwner(hwnd) == S_OK) )
            hres = _pmtbMenu->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        if (_pmtbShellFolder && (_pmtbShellFolder->IsWindowOwner(hwnd) == S_OK) )
            hres = _pmtbShellFolder->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
    }

    ExitModeless();

    return hres;
}


/*----------------------------------------------------------
Purpose: IOleWindow::GetWindow method

*/
STDMETHODIMP CMenuBand::GetWindow(HWND * phwnd)
{
    // We assert that only a real menu can be hosted in a standard
    // bandsite (we're talking about the horizontal menubar).
    // So we only return the window associated with the static
    // menu.
    if (_pmtbMenu)
    {
        *phwnd = _pmtbMenu->_hwndMB;
        return NOERROR;
    }
    else
    {
        *phwnd = NULL;
        return E_FAIL;
    }
}    


/*----------------------------------------------------------
Purpose: IOleWindow::ContextSensitiveHelp method

*/
STDMETHODIMP CMenuBand::ContextSensitiveHelp(BOOL bEnterMode)
{
    return SUPERCLASS::ContextSensitiveHelp(bEnterMode);
}    


/*----------------------------------------------------------
Purpose: Handle WM_CHAR for accelerators

         This is handled for any vertical menu.  Since we have
         two toolbars (potentially), this function determines
         which toolbar gets the message depending on the 
         accelerator.

*/
HRESULT CMenuBand::_HandleAccelerators(MSG * pmsg)
{
    TCHAR ch = (TCHAR)pmsg->wParam;
    HWND hwndTop = _pmtbTop->_hwndMB;
    HWND hwndBottom = _pmtbBottom->_hwndMB;

    // Here's how this works: the menu can have one or two toolbars.
    // 
    // One toolbar: we simply forward the message onto the toolbar 
    // and let it handle any potential accelerators.
    //
    // Two toolbars: get the count of accelerators that match the
    // given char for each toolbar.  If only one toolbar has at
    // least one match, forward the message onto that toolbar.
    // Otherwise, forward the message onto the currently tracked
    // toolbar and let it negotiate which accelerator button to
    // choose (we might get a TBN_WRAPHOTITEM).
    //
    // If no match occurs, we beep.  Beep beep.
    //

    if (!_pmtbTracked)
        SetTracked(_pmtbTop);

    ASSERT(_pmtbTracked);

    if (_pmtbTop != _pmtbBottom)
    {
        int iNumBottomAccel;
        int iNumTopAccel;

        // Tell the dup handler not to handle this one....
        _fProcessingDup = TRUE;

        ToolBar_HasAccelerator(hwndTop, ch, &iNumTopAccel);
        ToolBar_HasAccelerator(hwndBottom, ch, &iNumBottomAccel);

        BOOL bBottom = (0 < iNumBottomAccel);
        BOOL bTop = (0 < iNumTopAccel);

        // Does one or the other (but not both) have an accelerator?
        if (bBottom ^ bTop)
        {
            // Yes; do the work here for that specific toolbar
            HWND hwnd = bBottom ? hwndBottom : hwndTop;
            int cAccel = bBottom ? iNumBottomAccel : iNumTopAccel;
            int idCmd;

            pmsg->message = WM_NULL;    // no need to forward the message

            // This should never really fail since we just checked
            EVAL( ToolBar_MapAccelerator(hwnd, ch, &idCmd) );

            DWORD dwFlags = HICF_ACCELERATOR | HICF_RESELECT;

            if (cAccel == 1)
                dwFlags |= HICF_TOGGLEDROPDOWN;

            int iPos = ToolBar_CommandToIndex(hwnd, idCmd);
            ToolBar_SetHotItem2(hwnd, iPos, dwFlags);
        }
        // No; were there no accelerators?
        else if ( !bTop )
        {
            // Yes
            if (_fVertical)
            {
                MessageBeep(MB_OK);
            }
            else
            {
                _CancelMode(MPOS_FULLCANCEL);
            }
        }
        // Else allow the message to go to the top toolbar

        _fProcessingDup = FALSE;
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: Callback for the get message filter.  We handle the
         keyboard messages here (rather than IInputObject::
         TranslateAcceleratorIO) so that we can redirect the
         message *and* have the message pump still call
         TranslateMessage to generate WM_CHAR and WM_SYSCHAR
         messages.

*/
LRESULT CMenuBand::GetMsgFilterCB(MSG * pmsg, BOOL bRemove)
{
    // (See the note in CMBMsgFilter::GetMsgHook about bRemove.)

    if (bRemove && !_fVertical && (pmsg->message == g_nMBPopupOpen) && _pmtbTracked)
    {
        // Menu is being popped open, send a WM_MENUSELECT equivalent.
        _pmtbTracked->v_SendMenuNotification((UINT)pmsg->wParam, FALSE);
    }

    if (_fTopLevel &&                           // Only do this for the top level
        _dwFlags & SMINIT_USEMESSAGEFILTER &&   // They want to use the message filter 
                                                // instead of IsMenuMessage
        bRemove &&                              // Only do this if we're removing it.
        WM_SYSCHAR == pmsg->message)            // We only care about WM_SYSCHAR
    {
        // We intercept Alt-key combos (when pressed together) here,
        // to prevent USER from going into a false menu loop check.  
        // There are compatibility problems if we let that happen.
        //
        // Sent by USER32 when the user hits an Alt-char combination.
        // We need to translate this into popping down the correct
        // menu.  Normally we intercept this in the message pump
        //
        if (_OnSysChar(pmsg, TRUE) == S_OK)
        {
            pmsg->message = WM_NULL;
        }
    }

    // If a user menu is up, then we do not want to intercept those messages. Intercepting
    // messages intended for the poped up user menu causes havoc with keyboard accessibility.
    // We also don't want to process messages if we're displaying a sub menu (It should be
    // handling them).

    BOOL fTracking = FALSE;
    if (_pmtbMenu)
        fTracking = _pmtbMenu->v_TrackingSubContextMenu();

    if (_pmtbShellFolder && !fTracking)
        fTracking = _pmtbShellFolder->v_TrackingSubContextMenu();


    if (!_fInSubMenu && !fTracking)    
    {
        // We don't process these messages when we're in a (modal) submenu

        switch (pmsg->message)
        {
        case WM_SYSKEYDOWN:
        case WM_KEYDOWN:
            // Don't process IME message. Restore original VK value.
            if (g_fRunOnFE && VK_PROCESSKEY == pmsg->wParam)
                pmsg->wParam = ImmGetVirtualKey(pmsg->hwnd);

            if (bRemove && 
                (VK_ESCAPE == pmsg->wParam || VK_MENU == pmsg->wParam))
            {
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received Esc in msg filter", DBG_THIS);

                DWORD dwSelect = (VK_ESCAPE == pmsg->wParam) ? MPOS_CANCELLEVEL : MPOS_FULLCANCEL;

                _CancelMode(dwSelect);

                pmsg->message = WM_NULL;
                return 1;
            }
            // Fall thru

        case WM_CHAR:
            // Hitting the spacebar should invoke the system menu
            if (!_fVertical && 
                WM_CHAR == pmsg->message && TEXT(' ') == (TCHAR)pmsg->wParam)
            {
                // We need to leave this modal loop before bringing
                // up the system menu (otherwise the user would need to 
                // hit Alt twice to get out.)  Post the message.
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Leaving menu mode for system menu", DBG_THIS);

                UIActivateIO(FALSE, NULL);

                // Say the Alt-key is down to catch DefWindowProc's attention
                pmsg->lParam |= 0x20000000;   
                pmsg->message = WM_SYSCHAR;

                // Use the parent of the toolbar, because toolbar does not
                // forward WM_SYSCHAR onto DefWindowProc.
                pmsg->hwnd = GetParent(_pmtbTop->_hwndMB);
                return 1;
            }
            else if (_fVertical && WM_CHAR == pmsg->message &&
                pmsg->wParam != VK_RETURN)
            {
#ifdef UNICODE
                // Need to do this before we ask the toolbars..
                // [msadek], On win9x we get the message thru a chain from explorer /iexplore (ANSI app.).
                // and pass it to comctl32 (Unicode) so it will fail to match the hot key.
                // the system sends the message with ANSI char and we treated it as Unicode.
                // It looks like noone is affected with this bug (US, FE) since they have hot keys always in Latin.
                // Bidi platforms are affected since they do have hot keys in native language.
                if(!g_fRunningOnNT)
                {
                    pmsg->wParam = AnsiWparamToUnicode(pmsg->wParam);
                }
#endif // UNICODE        


                // We do not want to pass VK_RETURN to _HandleAccelerators
                // because it will try to do a character match. When it fails
                // it will beep. Then we pass the VK_RETURN to the tracked toolbar
                // and it executes the command.

                // Handle accelerators here
                _HandleAccelerators(pmsg);
            }
            // Fall thru

        case WM_KEYUP:
            // Collection point for most key messages...

            if (NULL == _pmtbTracked)
            {
                // Normally we default to the top toolbar, unless that toolbar
                // cannot receive the selection (As is the case on the top level
                // start menu where the fast items are (Empty).                

                // Can the top toolbar be cycled into?
                if (!_pmtbTop->DontShowEmpty())
                {
                    // Yes;
                    SetTracked(_pmtbTop);      // default to the top toolbar
                }
                else
                {
                    // No; Set the tracked to the bottom, and hope that he can....
                    SetTracked(_pmtbBottom);
                }
            }

            // F10 has special meaning for menus. 
            //  - F10 alone, should toggle the selection of the first item 
            //      in a horizontal menu
            //  - Shift-F10 should display a context menu.

            if (VK_F10 == pmsg->wParam)
            {
                // Is this the Shift-F10 Case?
                if (GetKeyState(VK_SHIFT) < 0)
                {
                    // Yes. We need to force this message into a context menu
                    // message.
                    pmsg->message = WM_CONTEXTMENU;
                    pmsg->lParam = -1;
                    pmsg->wParam = (WPARAM)_pmtbTracked->_hwndMB;
                    return 0;
                }
                else if (!_fVertical)   //No; Then we need to toggle in the horizontal case
                {
                    if (_pmtbMenu)
                    {
                        // Set the hot item to the first one.
                        int iHot = 0;
                        if (ToolBar_GetHotItem(_pmtbMenu->_hwndMB) != -1)
                            iHot = -1;  // We're toggling the selection off.
                        ToolBar_SetHotItem(_pmtbMenu->_hwndMB, iHot);
                    }
                    return 0;
                }
            }
                
            // Redirect to the toolbar
            if (_pmtbTracked)
                pmsg->hwnd = _pmtbTracked->_hwndMB;
            return 0;

        case WM_NULL:
            // Handle this here (we do nothing) to avoid mistaking this for
            // g_nMBPopupOpen below, in case g_nMBPopupOpen is 0 if
            // RegisterWindowMessage fails.
            return 0;

        default:
            // We used to handle g_nMBPopupOpen here.  But we can't because calling TrackPopupMenu
            // (via CTrackPopupBar::Popup) w/in a GetMessageFilter is very bad.
            break;
        }
    }

    if (bRemove)
    {
        // These messages must be processed even when no submenu is open
        switch (pmsg->message)
        {
        case WM_CLOSE:
            // Being deactivated.  Bail out of menus.
            TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): sending MPOS_FULLCANCEL", DBG_THIS);

            _CancelMode(MPOS_FULLCANCEL);
            break;

        default:
            if (IsInRange(pmsg->message, WM_MOUSEFIRST, WM_MOUSELAST))
            {
                // If we move the mouse, collapse the tip. Careful not to blow away a balloon tip...
                if (_pmbState)
                    _pmbState->HideTooltip(FALSE);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->v_ForwardMouseMessage(pmsg->message, pmsg->wParam, pmsg->lParam);

                if (_pmtbMenu)
                    _pmtbMenu->v_ForwardMouseMessage(pmsg->message, pmsg->wParam, pmsg->lParam);

                // Don't let the message be dispatched now that we've
                // forwarded it.
                pmsg->message = WM_NULL;
            }
            else if (pmsg->message == g_nMBFullCancel)
            {
                // Popup 
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received private full cancel message", DBG_THIS);

                _SubMenuOnSelect(MPOS_CANCELLEVEL);
                _CancelMode(MPOS_FULLCANCEL);
                return 1;
            }
            break;
        }
    }
    
    return 0;    
}    


/*----------------------------------------------------------
Purpose: Handle WM_SYSCHAR

         This is handled for the toplevel menu only.

*/
HRESULT CMenuBand::_OnSysChar(MSG * pmsg, BOOL bFirstDibs)
{
    TCHAR ch = (TCHAR)pmsg->wParam;

    // HACKHACK (scotth): I'm only doing all this checking because I don't
    // understand why the doc-obj case sometimes (and sometimes doesn't) 
    // intercept this in its message filter.
    
    if (!bFirstDibs && _fSysCharHandled)
    {
        _fSysCharHandled = FALSE;
        return S_FALSE;
    }
    
    if (TEXT(' ') == (TCHAR)pmsg->wParam)
    {
        _fAltSpace = TRUE;  // In the words of Spock..."Remember"
        // start menu alt+space
        TraceMsg(DM_MISC, "cmb._osc: alt+space _fTopLevel(1)");
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, UIBL_INPMENU);
    }
    else if (!_fInSubMenu)
    {
        int idBtn;

        ASSERT(_fTopLevel);

        // There is a brief instant when we're merging a menu and pumping messages
        // This results in a null _pmtbMenu.
        if (_pmtbMenu)
        {
            // Only a toplevel menubar follows this codepath.  This means only
            // the static menu toolbar will exist (and not the shellfolder toolbar).
            _pmtbTracked = _pmtbMenu;

            HWND hwnd = _pmtbTracked->_hwndMB;
#ifdef UNICODE            
            // [msadek], On win9x we get the message thru a chain from explorer /iexplore (ANSI app.).
            // and pass it to comctl32 (Unicode) so it will fail to match the hot key.
            // the system sends the message with ANSI char and we treated it as Unicode.
            // It looks like noone is affected with this bug (US, FE) since they have hot keys always in Latin.
            // Bidi platforms are affected since they do have hot keys in native language.
            if(!g_fRunningOnNT)
            {
                ch = (TCHAR) AnsiWparamToUnicode(pmsg->wParam);
            }
#endif // UNICODE        
            if (ToolBar_MapAccelerator(hwnd, ch, &idBtn))
            {
                // Post a message since we're already in a menu loop
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): WM_SYSCHAR: Posting CMBPopup message", DBG_THIS);
                UIActivateIO(TRUE, NULL);
                _pmtbTracked->PostPopup(idBtn, TRUE, TRUE);
                // browser menu alt+key, start menu alt+key
                TraceMsg(DM_MISC, "cmb._osc: alt+key _fTopLevel(1)");
                UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, UIBL_INPMENU);
                return S_OK;
            }
        }
    }

    // Set or reset
    _fSysCharHandled = bFirstDibs ? TRUE : FALSE;
    
    return S_FALSE;
}

HRESULT CMenuBand::_ProcessMenuPaneMessages(MSG* pmsg)
{
    if (pmsg->message == g_nMBPopupOpen)
    {
        // Popup the submenu.  Since the top-level menuband receives this first, the
        // command must be piped down the chain to the bottom-most menuband.
        IOleCommandTarget * poct;
    
        QueryService(SID_SMenuBandBottom, IID_IOleCommandTarget, (LPVOID *)&poct);

        if (poct)
        {
            BOOL bSetItem = LOWORD(pmsg->lParam);
            BOOL bInitialSelect = HIWORD(pmsg->lParam);
            VARIANTARG vargIn;

            TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received private popup menu message", DBG_THIS);

            DWORD dwOpt = 0;

            vargIn.vt = VT_I4;
            vargIn.lVal = (LONG)pmsg->wParam;
        
            if (bSetItem)
                dwOpt |= MBPUI_SETITEM;

            if (bInitialSelect)
                dwOpt |= MBPUI_INITIALSELECT;
            
            poct->Exec(&CGID_MenuBand, MBANDCID_POPUPITEM, dwOpt, &vargIn, NULL);
            poct->Release();
            return S_OK;
        }
    }
    else if (pmsg->message == g_nMBDragCancel)
    {
        // If we got a drag cancel, make sure that the bottom most
        // menu does not have the drag enter.
        IUnknown_QueryServiceExec(SAFECAST(this, IOleCommandTarget*), 
            SID_SMenuBandBottom, &CGID_MenuBand, MBANDCID_DRAGCANCEL, 0, NULL, NULL);
        return S_OK;
    }
    else if (pmsg->message == g_nMBOpenChevronMenu)
    {

        VARIANTARG v;
        v.vt = VT_I4;
        v.lVal = (LONG)pmsg->wParam;

        IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_PUSHCHEVRON, _dwBandID, &v, NULL);
    }
    else if (pmsg->message == g_nMBFullCancel)
    {
        _SubMenuOnSelect(MPOS_CANCELLEVEL);
        _CancelMode(MPOS_FULLCANCEL);
        return S_OK;
    }

    return S_FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuBand::IsMenuMessage method

         The thread's message pump calls this function to see if any
         messages need to be redirected to the menu band.

         This returns S_OK if the message is handled.  The
         message pump should not pass it onto TranslateMessage
         or DispatchMessage if it does.

*/
STDMETHODIMP CMenuBand::IsMenuMessage(MSG * pmsg)
{
    HRESULT hres = S_FALSE;

    ASSERT(IS_VALID_WRITE_PTR(pmsg, MSG));

#ifdef DEBUG
    if (g_dwDumpFlags & DF_TRANSACCELIO)
        DumpMsg(TEXT("CMB::IsMM"), pmsg);
#endif
    if (!_fShow)
        goto Return;

    switch (pmsg->message)
    {
    case WM_SYSKEYDOWN:
        // blow this off if it's a repeated keystroke
        if (!(pmsg->lParam & 0x40000000))
        {
            SendMessage(_hwndParent, WM_CHANGEUISTATE ,MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL), 0);

            // Are we pressing the Alt key to activate the menu?
            if (!_fMenuMode && pmsg->wParam == VK_MENU && _pmbState)
            {
                // Yes; The the menu was activated because of a keyboard,
                // Set the global state to show the keyboard cues.
                _pmbState->SetKeyboardCue(TRUE);

                // Since this only happens on the top level menu,
                // We only have to tell the "Top" menu to update it's state.
                _pmtbTop->SetKeyboardCue();
            }
        }
        break;

    case WM_SYSKEYUP:
        // If we're in menu mode, ignore this message. 
        // 
        if (_fMenuMode)
            hres = S_OK;
        break;

    case WM_SYSCHAR:
        // We intercept Alt-key combos (when pressed together) here,
        // to prevent USER from going into a false menu loop check.  
        // There are compatibility problems if we let that happen.
        //
        // Sent by USER32 when the user hits an Alt-char combination.
        // We need to translate this into popping down the correct
        // menu.  Normally we intercept this in the message pump
        //

        // Outlook Express needs a message hook in order to filter this 
        // message for perf we do not use that method.

        // Athena fix 222185 (lamadio) We also don't want to do this if we are not active! 
        // otherwise when WAB is on top of OE, we'll steal it's messages

        // BUGBUG: i'm removing GetTopMostPtr check below ... breaks menu accelerators for IE5 (224040)

        // (lamadio): If the Message filter is "engaged", then we can process accelerators.
        // Engaged does not mean that the filter is running.
        if (GetMessageFilter()->IsEngaged())
        {
            hres = (_OnSysChar(pmsg, TRUE) == S_OK) ? S_OK : S_FALSE;
        }
        break;

    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_KEYUP:
        if (_fMenuMode)
        {
            // All keystrokes should be handled or eaten by menubands
            // if we're engaged.  We must do this, otherwise hosted 
            // components like mshtml or word will try to handle the 
            // keystroke in CBaseBrowser.

            // Also, don't bother forwarding tabs
            if (VK_TAB != pmsg->wParam)
            {
                // Since we're answer S_OK, dispatch it ourselves.
                TranslateMessage(pmsg);
                DispatchMessage(pmsg);
            }

            hres = S_OK;
        }
        break;

    case WM_CONTEXTMENU:
        // HACKHACK (lamadio): Since the start button has the keyboard focus,
        // the start button will handle this. We need to forward this off to the 
        // currently tracked item at the bottom of the chain
        LRESULT lres;
        IWinEventHandler* pweh;

        if (_fMenuMode &&
            SUCCEEDED(QueryService(SID_SMenuBandBottomSelected, IID_IWinEventHandler, (LPVOID *)&pweh)))
        {
            // BUGBUG (lamadio): This will only work because only one of the two possible toolbars
            // handles this
            pweh->OnWinEvent(HWND_BROADCAST, pmsg->message, 
                pmsg->wParam, pmsg->lParam, &lres);
            pweh->Release();
            hres = S_OK;
        }
        break;

    default:

        // We only want to process the pane messages in IsMenuMessage when there is no
        // top level HWND. This is for the Deskbar menus. Outlook Express needs the 
        // TranslateMenuMessage entry point

        if (_pmbState->GetSubclassedHWND() == NULL)
            hres = _ProcessMenuPaneMessages(pmsg);
        break;
    }

Return:
    if (!_fMenuMode && hres != S_OK)
        hres = E_FAIL;


    return hres;
}

BOOL HasWindowTopmostOwner(HWND hwnd)
{
    HWND hwndOwner = hwnd;
    while (hwndOwner = GetWindowOwner(hwndOwner))
    {
        if (GetWindowLong(hwndOwner, GWL_EXSTYLE) & WS_EX_TOPMOST)
            return TRUE;
    }

    return FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuBand::TranslateMenuMessage method

         The main app's window proc calls this so the menuband
         catches messages that are dispatched from a different
         message pump (than the thread's main pump).
         
         Translates messages specially for menubands.  Some messages
         are processed while the menuband is active.  Others are only
         processed when it is not.  Messages that are not b/t
         WM_KEYFIRST and WM_KEYLAST are handled here (the browser
         does not send these messages to IInputObject::
         TranslateAcceleratorIO).


Returns: S_OK if message is processed

*/
STDMETHODIMP CMenuBand::TranslateMenuMessage(MSG * pmsg, LRESULT * plRet)
{
    ASSERT(IS_VALID_WRITE_PTR(pmsg, MSG));

#ifdef DEBUG
    if (g_dwDumpFlags & DF_TRANSACCELIO)
        DumpMsg(TEXT("CMB::TMM"), pmsg);
#endif

    switch (pmsg->message)
    {
    case WM_SYSCHAR:
        // In certain doc-obj situations, the OLE message filter (??)
        // grabs this before the main thread's message pump gets a 
        // whack at it.  So we handle it here too, in case we're in
        // this scenario.
        //
        // See the comments in IsMenuMessage regarding this message.
        return _OnSysChar(pmsg, FALSE);

    case WM_INITMENUPOPUP:
        // Normally the LOWORD(lParam) is the index of the menu that 
        // is being popped up.  TrackPopupMenu (which CMenuISF uses) 
        // always sends this message with an index of 0.  This breaks 
        // clients (like DefView) who check this value.  We need to
        // massage this value if we find we're the source of the 
        // WM_INITMENUPOPUP.
        //
        // (This is not in TranslateAcceleratorIO b/c TrackPopupMenu's
        // message pump does not call it.  The wndproc must forward
        // the message to this function for us to get it.)

        if (_fInSubMenu && _pmtbTracked)
        {
            // Massage lParam to use the right index
            int iPos = ToolBar_CommandToIndex(_pmtbTracked->_hwndMB, _nItemCur);
            pmsg->lParam = MAKELPARAM(iPos, HIWORD(pmsg->lParam));

            // Return S_FALSE so this message will still be handled
        }
        break;

    case WM_UPDATEUISTATE:
        if (_pmbState)
        {
            // we don't care about UISF_HIDEFOCUS
            if (UISF_HIDEACCEL == HIWORD(pmsg->wParam))
                _pmbState->SetKeyboardCue(UIS_CLEAR == LOWORD(pmsg->wParam) ? TRUE : FALSE);
        }
        break;


    case WM_ACTIVATE:
        {
            CMBMsgFilter* pmf = GetMessageFilter();
            // Debug note: to debug menubands on ntsd, set the prototype
            // flag accordingly.  This will keep menubands from going
            // away the moment the focus changes.

            // Becomming inactive?
            if (WA_INACTIVE == LOWORD(pmsg->wParam))
            {
                // Yes; Free up the global object
                // Athena fix (lamadio) 08.02.1998: Athena uses menubands. Since they
                // have a band per window in one thread, we needed a mechanism to switch
                // between them. So we used the Msgfilter to forward messages. Since there 
                // are multiple windows, we need to set correct one.
                // But, On a deactivate, we need to NULL it out incase a window,
                // running in the same thread, has normal USER menu. We don't want to steal
                // their messages.
                if (pmf->GetTopMostPtr() == this)
                    pmf->SetTopMost(NULL);

                pmf->DisEngage(_pmbState->GetContext());

                HWND hwndLostTo = (HWND)(pmsg->lParam);

                // We won't bail on the menus if we're loosing activation to a child.
                if (!IsAncestor(hwndLostTo, _pmbState->GetWorkerWindow(NULL)))
                {
                    if (_fMenuMode &&
                        !(g_dwPrototype & PF_USINGNTSD) && 
                        !_fDragEntered)
                    {
                        // Being deactivated.  Bail out of menus.  
                        // (Only the toplevel band gets this message.)
                        if (_fInSubMenu)
                        {
                            IMenuPopup* pmp = _pmpSubMenu;
                            if (_pmpTrackPopup)
                                pmp = _pmpTrackPopup;
                            ASSERT(pmp);    // This should be valid. If not, someone screwed up.
                            pmp->OnSelect(MPOS_FULLCANCEL);
                        }

                        _CancelMode(MPOS_FULLCANCEL);
                    }
                }
            }
            else if (WA_ACTIVE == LOWORD(pmsg->wParam) || 
                     WA_CLICKACTIVE == LOWORD(pmsg->wParam))
            {
                // If I have activation, the Worker Window needs to be bottom...
                //
                // NOTE: Don't do this if the worker window has a topmost owner
                // (such as the tray).  Setting a window to HWND_NOTOPMOST moves
                // its owner windows to HWND_NOTOPMOST as well, which in this case
                // was breaking the tray's "always on top" feature.
                //
                HWND hwndWorker = _pmbState->GetWorkerWindow(NULL);
                if (hwndWorker && !HasWindowTopmostOwner(hwndWorker) && !_fDragEntered)
                    SetWindowPos(hwndWorker, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);

                // Set the context because when a menu heirarchy becomes active because the
                // subclassed HWND becomes active, we need to reenable the message hook.
                pmf->SetContext(this, TRUE);

                // When we get reactivated, we need to position ourself above the start bar.
                Exec(&CGID_MenuBand, MBANDCID_REPOSITION, TRUE, NULL, NULL);
            
                // Becomming activated. We need to reengage the message hook so that
                // we get the correct messages.
                pmf->ReEngage(_pmbState->GetContext());

                // Are we in menu mode?
                if (_fMenuMode)
                {
                    // Need to reengage some things.
                    // Take the capture back because we have lost it to context menus or dialogs.
                    pmf->RetakeCapture();

                }
                pmf->SetTopMost(this);
            }

            //
            // Memphis and NT5 grey their horizontal menus when the windows is inactive.
            //
            if (!_fVertical && (g_bRunOnMemphis || g_bRunOnNT5) && _pmtbMenu)
            {
                // This needs to stay here because of the above check...
                if (WA_INACTIVE == LOWORD(pmsg->wParam))
                {
                    _fAppActive = FALSE;
                }
                else
                {
                    _fAppActive = TRUE;
                }
                // Reduces flicker by using this instead of an InvalidateWindow/UpdateWindow Pair
                RedrawWindow(_pmtbMenu->_hwndMB, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }
        break;

    case WM_SYSCOMMAND:
        if ( !_fMenuMode )
        {
            switch (pmsg->wParam & 0xFFF0)
            {
            case SC_KEYMENU:
                // The user either hit the Alt key by itself or Alt-space.
                // If it was Alt-space, let DefWindowProc handle it so the
                // system menu comes up.  Otherwise, we'll handle it to
                // toggle the menuband.

                // Was it Alt-space?
                if (_fAltSpace)
                {
                    // Yes; let it go
                    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Caught the Alt-space", DBG_THIS);
                    _fAltSpace = FALSE;
                }
                else if (_fShow)
                {
                    // No; activate the menu
                    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Caught the WM_SYSCOMMAND, SC_KEYMENU", DBG_THIS);

                    UIActivateIO(TRUE, NULL);

                    // We sit in a modal loop here because typically
                    // WM_SYSCOMMAND doesn't return until the menu is finished.
                    //
                    while (_fMenuMode) 
                    {
                        MSG msg;
                        if (GetMessage(&msg, NULL, 0, 0)) 
                        {
                            if ( S_OK != IsMenuMessage(&msg) )
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                    }

                    *plRet = 0;
                    return S_OK;        // Caller shouldn't handle this
                }
                break;
            }
        }
        break;

    default:
        // We only want to process the pane messages in IsMenuMessage when there is no
        // top level HWND. This is for the Deskbar menus. Outlook Express needs the 
        // TranslateMenuMessage entry point
        if (_pmbState->GetSubclassedHWND() != NULL)
            return _ProcessMenuPaneMessages(pmsg);
        break;


    }
    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

         Called by the menusite to host this band.  Since the
         menuband contains two toolbars, we set their parent
         window to be the site's hwnd.

*/
STDMETHODIMP CMenuBand::SetSite(IUnknown* punkSite)
{
    // Do this first because SetParent needs to query to the top level browser for
    // sftbar who queries to the top level browser to get the drag and drop window.
    HRESULT hres = SUPERCLASS::SetSite(punkSite);

    if (_psmcb && _fTopLevel && !(_dwFlags & SMINIT_NOSETSITE))
        IUnknown_SetSite(_psmcb, punkSite);

    IUnknown_GetWindow(punkSite, &_hwndParent);

    // Need this for Closing an expanded vertical menu. Start Menu knows to do this when it's top level,
    // but the Favorites needs to know when it's parent is the horizontal menu.
    VARIANT var;
    if (SUCCEEDED(IUnknown_QueryServiceExec(punkSite, SID_SMenuBandParent, &CGID_MenuBand,
                                       MBANDCID_ISVERTICAL, 0, NULL, &var)) && 
        var.boolVal == VARIANT_FALSE)
    {
        _fParentIsHorizontal = TRUE;
    }


    // Tell the toolbars who their new parent is
    if (_pmtbMenu)
        _pmtbMenu->SetParent(_hwndParent);
    if (_pmtbShellFolder)
        _pmtbShellFolder->SetParent(_hwndParent);

    return hres;
}

/*----------------------------------------------------------
Purpose: IShellMenu::Initialize method

*/
STDMETHODIMP CMenuBand::Initialize(IShellMenuCallback* psmcb, UINT uId, UINT uIdAncestor, DWORD dwFlags)
{
    DEBUG_CODE( _fInitialized = TRUE; );

    // Initalized can be called with NULL values to only set some of them.

    // Default to Vertical
    if (!(dwFlags & SMINIT_HORIZONTAL) && !(dwFlags & SMINIT_VERTICAL))
        dwFlags |= SMINIT_VERTICAL;

    _Initialize(dwFlags);

    if (uIdAncestor != ANCESTORDEFAULT)
        _uIdAncestor = uIdAncestor;

    if (_uId != -1)
        _uId = uId;

    if (psmcb)
    {
        if (!SHIsSameObject(psmcb, _psmcb))
        {
            if (_punkSite && _fTopLevel && !(dwFlags & SMINIT_NOSETSITE))
                IUnknown_SetSite(_psmcb, NULL);

            ATOMICRELEASE(_psmcb);
            _psmcb = psmcb;
            _psmcb->AddRef();

            // We do not set the site in case this callback is shared between 2 bands (Menubar/Chevron menu)
            if (_punkSite && _fTopLevel && !(dwFlags & SMINIT_NOSETSITE))
                IUnknown_SetSite(_psmcb, _punkSite);

            // Only call this if we're setting a new one. Pass the address of the user associated
            // data section. This is so that the callback can associate data with this pane only
            _CallCB(SMC_CREATE, 0, (LPARAM)&_pvUserData);
        }
    }

    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IShellMenu::GetMenuInfo method

*/
STDMETHODIMP CMenuBand::GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags)
{
    if (ppsmc)
    {
        *ppsmc = _psmcb;
        if (_psmcb)
            ((IShellMenuCallback*)*ppsmc)->AddRef();
    }

    if (puId)
        *puId = _uId;

    if (puIdAncestor)
        *puIdAncestor = _uIdAncestor;

    if (pdwFlags)
        *pdwFlags = _dwFlags;

    return NOERROR;
}


void CMenuBand::_AddToolbar(CMenuToolbarBase* pmtb, DWORD dwFlags)
{
    pmtb->SetSite(SAFECAST(this, IMenuBand*));
    if (_hwndParent)
        pmtb->CreateToolbar(_hwndParent);
    
    // Treat this like a two-element stack, where this function
    // behaves like a "push".  The one additional trick is we 
    // could be pushing onto the top or the bottom of the "stack".

    if (dwFlags & SMSET_BOTTOM)
    {
        if (_pmtbBottom)
        {
            // I don't need to release, because _pmtbTop and _pmtbBottom are aliases for
            // _pmtbShellFolder and _pmtbMenu
            _pmtbTop = _pmtbBottom;
            _pmtbTop->SetToTop(TRUE);
        }

        _pmtbBottom = pmtb;
        _pmtbBottom->SetToTop(FALSE);
    }
    else    // Default to Top...
    {
        if (_pmtbTop)
        {
            _pmtbBottom = _pmtbTop;
            _pmtbBottom->SetToTop(FALSE);
        }

        _pmtbTop = pmtb;
        _pmtbTop->SetToTop(TRUE);
    }

    // _pmtbBottom should never be the only toolbar that exists in the menuband.
    if (!_pmtbTop)
        _pmtbTop = _pmtbBottom;

    // The menuband determines there is a single toolbar by comparing
    // the bottom with the top.  So make the bottom the same if necessary.
    if (!_pmtbBottom)
        _pmtbBottom = _pmtbTop;
}


/*----------------------------------------------------------
Purpose: IShellMenu::GetShellFolder method

*/
STDMETHODIMP CMenuBand::GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl,
                                       REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    if (_pmtbShellFolder)
    {
        *pdwFlags = _pmtbShellFolder->GetFlags();

        hres = S_OK;

        if (ppvObj)
        {
            // HACK HACK.  this should QI for a mnfolder specific interface to do this.
            hres = _pmtbShellFolder->GetShellFolder(ppidl, riid, ppvObj);
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellMenu::SetShellFolder method

*/
STDMETHODIMP CMenuBand::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hKey, DWORD dwFlags)
{
    ASSERT(_fInitialized);
    HRESULT hres = E_OUTOFMEMORY;

    // If we're processing a change notify, we cannot do anything that will modify state.
    // NOTE: if we don't have a state, we can't possibly processing a change notify
    if (_pmbState && _pmbState->IsProcessingChangeNotify())
        return E_PENDING;

    // Only one shellfolder menu can exist per menuband.  Additionally,
    // a shellfolder menu can exist either at the top of the menu, or
    // at the bottom (when it coexists with a static menu).

    // Is there already a shellfolder menu?
    if (_pmtbShellFolder)
    {
        IShellFolderBand* psfb;
        EVAL(SUCCEEDED(_pmtbShellFolder->QueryInterface(IID_IShellFolderBand, (void**)&psfb)));
        hres = psfb->InitializeSFB(psf, pidlFolder);
        psfb->Release();
        
    }
    else
    {
        _pmtbShellFolder = new CMenuSFToolbar(this, psf, pidlFolder, hKey, dwFlags);
        if (_pmtbShellFolder)
        {
            _AddToolbar(_pmtbShellFolder, dwFlags);
            hres = NOERROR;
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuBand::GetMenu method

*/
STDMETHODIMP CMenuBand::GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags)
{
    HRESULT hres = E_FAIL;

    // HACK HACK.  this should QI for a menustatic specific interface to do this.
    if (_pmtbMenu)
        hres = _pmtbMenu->GetMenu(phmenu, phwnd, pdwFlags);

    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuBand::SetMenu method

*/
STDMETHODIMP CMenuBand::SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags)
{
    // Passing a NULL hmenu is valid. It means destroy our menu object.
    ASSERT(_fInitialized);
    HRESULT hres = E_FAIL;

    // Only one static menu can exist per menuband.  Additionally,
    // a static menu can exist either at the top of the menu, or
    // at the bottom (when it coexists with a shellfolder menu).

    // Is there already a static menu?
    if (_pmtbMenu)
    {
        // Since we're merging in a new menu, make sure to update the cache...
        _hmenu = hmenu;
        // Yes
        // HACK HACK.  this should QI for a menustatic specific interface to do this.
        return _pmtbMenu->SetMenu(hmenu, hwnd, dwFlags);
    }
    else
    {
        // BUGBUG (lamadio): This is to work around a problem in the interface definintion: We have
        // no method of setting the Subclassed HWND outside of a SetMenu. So I'm just piggybacking
        // off of this. A better fix would be to introduce IMenuBand2::SetSubclass(HWND). IMenuBand
        // actually implements the "Subclassing", so extending this interface would be worthwhile.
        _hwndMenuOwner = hwnd;

        if (_fTopLevel)
        {
            _pmbState->SetSubclassedHWND(hwnd);
        }

        if (hmenu)
        {
            _hmenu = hmenu;
            _pmtbMenu = new CMenuStaticToolbar(this, hmenu, hwnd, _uId, dwFlags);
            if (_pmtbMenu)
            {
                _AddToolbar(_pmtbMenu, dwFlags);
                hres = S_OK;
            }
            else
                hres = E_OUTOFMEMORY;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellMenu::SetMenuToolbar method

*/
STDMETHODIMP CMenuBand::SetMenuToolbar(IUnknown* punk, DWORD dwFlags)
{
    CMenuToolbarBase* pmtb;
    if (punk && SUCCEEDED(punk->QueryInterface(CLSID_MenuToolbarBase, (void**)&pmtb)))
    {
        ASSERT(_pmtbShellFolder == NULL);
        _pmtbShellFolder = pmtb;
        _AddToolbar(pmtb, dwFlags);
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}


/*----------------------------------------------------------
Purpose: IShellMenu::InvalidateItem method

*/
STDMETHODIMP CMenuBand::InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{
    HRESULT hres = S_FALSE;

    // If psmd is NULL, we need to just dump the toolbars and do a full reset.
    if (psmd == NULL)
    {
        // If we're processing a change notify, we cannot do anything that will modify state.
        if (_pmbState && _pmbState->IsProcessingChangeNotify())
            return E_PENDING;

        if (_pmbState)
            _pmbState->PushChangeNotify();

        // Tell the callback we're refreshing so that it can
        // reset any cached state
        _CallCB(SMC_REFRESH);
        _fExpanded = FALSE;

        // We don't need to refill if the caller only wanted to 
        // refresh the sub menus.

        // Refresh the Shell Folder first because
        // It may have no items after it's done, and the
        // menuband may rely on this to add a seperator
        if (_pmtbShellFolder)
            _pmtbShellFolder->v_Refresh();

        // Refresh the Static menu
        if (_pmtbMenu)
            _pmtbMenu->v_Refresh();

        if (_pmpSubMenu)
        {
            _fInSubMenu = FALSE;
            IUnknown_SetSite(_pmpSubMenu, NULL);
            ATOMICRELEASE(_pmpSubMenu);
        }

        if (_pmbState)
            _pmbState->PopChangeNotify();

    }
    else
    {
        if (_pmtbTop)
            hres = _pmtbTop->v_InvalidateItem(psmd, dwFlags);

        // We refresh everything at this level if the psmd is null
        if (_pmtbBottom && hres != S_OK)
            hres = _pmtbBottom->v_InvalidateItem(psmd, dwFlags);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellMenu::GetState method

*/
STDMETHODIMP CMenuBand::GetState(LPSMDATA psmd)
{
    if (_pmtbTracked)
        return _pmtbTracked->v_GetState(-1, psmd);
    // todo: might want to put stuff from _CallCB (below) in here
    return E_FAIL;
}


HRESULT CMenuBand::_CallCB(DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    if (!_psmcb)
        return S_FALSE;

    // We don't need to check callback mask here because these are not maskable events.

    SMDATA smd = {0};
    smd.punk = SAFECAST(this, IShellMenu*);
    smd.uIdParent = _uId;
    smd.uIdAncestor = _uIdAncestor;
    smd.hwnd = _hwnd;
    smd.hmenu = _hmenu;
    smd.pvUserData = _pvUserData;
    if (_pmtbShellFolder)
        _pmtbShellFolder->GetShellFolder(&smd.pidlFolder, IID_IShellFolder, (void**)&smd.psf);
    HRESULT hres = _psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);

    ILFree(smd.pidlFolder);
    if (smd.psf)
        smd.psf->Release();

    return hres;
}


/*----------------------------------------------------------
Purpose: IInputObject::TranslateAcceleratorIO

         This is called by the base browser only when the menuband
         "has the focus", and only for messages b/t WM_KEYFIRST
         and WM_KEYLAST.  This isn't very useful for menubands.
         See the explanations in GetMsgFilterCB, IsMenuMessage
         and TranslateMenuMessage.

         In addition, menubands cannot ever have the activation,
         so this method should never be called.

         Returns S_OK if handled.
*/
STDMETHODIMP CMenuBand::TranslateAcceleratorIO(LPMSG pmsg)
{
    AssertMsg(0, TEXT("Menuband has the activation but it shouldn't!"));

    return S_FALSE;
}

/*----------------------------------------------------------
Purpose: IInputObject::HasFocusIO

*/
STDMETHODIMP CMenuBand::HasFocusIO()
{
    // We consider a menuband has the focus even if it has submenus
    // that are currently cascaded out.  All menubands in the chain
    // have the focus.
    return _fMenuMode ? S_OK : S_FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubMenu method

         The child menubar calls us with its IMenuPopup pointer.
*/
STDMETHODIMP CMenuBand::SetSubMenu(IMenuPopup * pmp, BOOL fSet)
{
    ASSERT(IS_VALID_CODE_PTR(pmp, IMenuPopup));

    if (fSet)
    {
        _fInSubMenu = TRUE;
    }
    else 
    {
        if (_pmtbTracked)
        {
            _pmtbTracked->PopupClose();
        }

        _fInSubMenu = FALSE;
        _nItemSubMenu = -1;
    }

    return S_OK;
}    

HRESULT CMenuBand::_SiteSetSubMenu(IMenuPopup * pmp, BOOL bSet)
{
    HRESULT hres;
    IMenuPopup * pmpSite;

    hres = IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_IMenuPopup, 
                                 (LPVOID *)&pmpSite);
    if (SUCCEEDED(hres))
    {
        hres = pmpSite->SetSubMenu(pmp, bSet);
        pmpSite->Release();
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Tell the GetMsg filter that this menuband is ready to
         listen to messages.

*/
HRESULT CMenuBand::_EnterMenuMode(void)
{
    ASSERT(!_fMenuMode);        // Must not push onto stack more than once

    if (g_dwProfileCAP & 0x00002000) 
        StartCAP();

    DEBUG_CODE( _nMenuLevel = g_nMenuLevel++; )

    _fMenuMode = TRUE;
    _fInSubMenu = FALSE;
    _nItemMove = -1;
    _fCascadeAnimate = TRUE;

    _hwndFocusPrev = NULL;

    if (_fTopLevel)
    {
        // BUGBUG (lamadio): this piece should be moved to the shbrowse callback

        // REVIEW (scotth): some embedded controls (like the surround
        // video ctl on the carpoint website) have another thread that
        // eats all the messages when the control has the focus.
        // This prevents us from getting any messages once we're in
        // menu mode.  I don't understand why USER menus work yet.
        // One way to work around this bug is to detect this case and
        // set the focus to our main window for the duration.
        
        if (GetWindowThreadProcessId(GetFocus(), NULL) != GetCurrentThreadId())
        {
            IShellBrowser* psb;
            
            if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_IShellBrowser, (void**)&psb)))
            {
                HWND hwndT;
                
                psb->GetWindow(&hwndT);
                _hwndFocusPrev = SetFocus(hwndT);
                psb->Release();
            }
        }
    
        _hCursorOld = GetCursor();
        SetCursor(g_hCursorArrow);
        HideCaret(NULL);
    }

    _SiteSetSubMenu(this, TRUE);

    if (_pmtbTop)
    {
        HWND hwnd = _pmtbTop->_hwndMB;
        if (!_fVertical && -1 == _nItemNew)
        {
            // The Alt key always highlights the first menu item initially
            SetTracked(_pmtbTop);
            ToolBar_SetHotItem(hwnd, 0);
            NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTop->_hwndMB, OBJID_CLIENT, 
                GetIndexFromChild(TRUE, 0));
        }

        _pmtbTop->Activate(TRUE);

        // The toolbar usually tracks mouse events.  However, as the mouse
        // moves over submenus, we still want the parent menubar to
        // behave as if it has retained the focus (that is, keep the
        // last selected item highlighted). This also prevents the toolbar
        // from handling WM_MOUSELEAVE messages unnecessarily.
        ToolBar_SetAnchorHighlight(hwnd, TRUE);

        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Entering menu mode", DBG_THIS);
        NotifyWinEvent(_fVertical? EVENT_SYSTEM_MENUPOPUPSTART: EVENT_SYSTEM_MENUSTART, 
            hwnd, OBJID_CLIENT, CHILDID_SELF);
    }

    if (_pmtbBottom)
    {
        _pmtbBottom->Activate(TRUE);
        ToolBar_SetAnchorHighlight(_pmtbBottom->_hwndMB, TRUE); // Turn off anchoring
    }

    GetMessageFilter()->Push(_pmbState->GetContext(), this, _punkSite);

    return S_OK;
}    


void CMenuBand::_ExitMenuMode(void)
{
    _fMenuMode = FALSE;
    _nItemCur = -1;
    _fPopupNewMenu = FALSE;
    _fInitialSelect = FALSE;
    CMBMsgFilter* pmf = GetMessageFilter();

    if (_pmtbTop)
    {
        HWND hwnd = _pmtbTop->_hwndMB;
        ToolBar_SetAnchorHighlight(hwnd, FALSE); // Turn off anchoring
        if (!_fVertical)
        {
            // Use the first item, since we're assuming every menu must have
            // at least one item
            _pmtbTop->v_SendMenuNotification(0, TRUE);
        
            // The user may have clicked outside the menu, which would have
            // cancelled it.  But since we set the ANCHORHIGHLIGHT attribute,
            // the toolbar won't receive a message to cause it to
            // remove the highlight.  So do it explicitly now.
            SetTracked(NULL);
            UpdateWindow(hwnd);
        }

        _pmtbTop->Activate(FALSE);

        NotifyWinEvent(_fVertical? EVENT_SYSTEM_MENUPOPUPEND: EVENT_SYSTEM_MENUEND, 
            hwnd, OBJID_CLIENT, CHILDID_SELF);
    }

    if (_pmtbBottom)
    {
        _pmtbBottom->Activate(FALSE);
        ToolBar_SetAnchorHighlight(_pmtbBottom->_hwndMB, FALSE); // Turn off anchoring
    }

    pmf->Pop(_pmbState->GetContext());

    _SiteSetSubMenu(this, FALSE);

    if (_fTopLevel)
    {
        SetCursor(_hCursorOld);
        ShowCaret(NULL);
        
        pmf->SetContext(this, FALSE);

        // We do this here, because ShowDW(FALSE) does not get called on the
        // top level menu band. This resets the state, so that the accelerators 
        // are not shown.
        if (_pmbState)
            _pmbState->SetKeyboardCue(FALSE);

        // Tell the menus to update their state to the current global cue state.
        if (_pmtbTop)
            _pmtbTop->SetKeyboardCue();

        if (_pmtbTop != _pmtbBottom && _pmtbBottom)
            _pmtbBottom->SetKeyboardCue();

    }

    if (_hwndFocusPrev)
        SetFocus(_hwndFocusPrev);

    if (_fTopLevel)
    {
        //
        // The top-level menu has gone away.  Win32 focus and ui-activation don't
        // actually change when this happens, so the browser and focused dude have
        // no idea that something happened and won't generate any AA event.  So, we
        // do it here for them.  Note that if there was a selection inside the focused
        // dude, we'll lose it.  This is the best we can do for now, as we don't
        // currently have a way to tell the focused/ui-active guy (who knows about the
        // current selection) to reannounce focus.
        //
        HWND hwndFocus = GetFocus();
        NotifyWinEvent(EVENT_OBJECT_FOCUS, hwndFocus, OBJID_CLIENT, CHILDID_SELF);
    }
        
    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Exited menu mode", DBG_THIS);
    DEBUG_CODE( g_nMenuLevel--; )
    DEBUG_CODE( _nMenuLevel = -1; )
    if (g_dwProfileCAP & 0x00002000) 
        StopCAP();
}    


/*----------------------------------------------------------
Purpose: IInputObject::UIActivateIO

         Menubands CANNOT take the activation.  Normally
         a band would return S_OK and call the site's 
         OnFocusChangeIS method, so that its TranslateAcceleratorIO
         method would receive keyboard messages.

         However, menus are different.  The window/toolbar that
         currently has the activation must retain that activation
         when the menu pops down.  Because of this, menubands use 
         a GetMessage filter to intercept messages.

*/
STDMETHODIMP CMenuBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres;
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    if (lpMsg != NULL) {
        // don't allow TAB to band (or any other 'non-explicit' activation).
        // (if we just cared about TAB we'd check IsVK_TABCycler).
        // all kinds of badness would result if we did.
        // the band can't take focus (see above), so it can't obey the
        // UIAct/OnFocChg rules (e.g. can't call OnFocusChangeIS), so
        // our basic activation-tracking assumptions would be broken.
        return S_FALSE;
    }

    if (fActivate)
    {
        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): UIActivateIO(%d)", DBG_THIS, fActivate);
        
        if (!_fMenuMode)
        {
            _EnterMenuMode();

            // BUGBUG (lamadio) : Should go in the Favorites callback.
            // The toplevel menuband does not set the real activation.  
            // But the children do, so activation can be communicated
            // with the parent menuband.
            if (_fVertical)
            {
                IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
            }
            else
            {
                IUnknown_Exec(_punkSite, &CGID_Theater, THID_TOOLBARACTIVATED, 0, NULL, NULL);
            }
        }

        if (_fPopupNewMenu)
        {
            _nItemCur = _nItemNew;
            ASSERT(-1 != _nItemCur);
            ASSERT(_pmtbTracked);

            _fPopupNewMenu = FALSE;
            _nItemNew = -1;

            // Popup a menu
            hres = _pmtbTracked->PopupOpen(_nItemCur);
            if (FAILED(hres))
            {
                // Don't fail the activation
            }
            else if (S_FALSE == hres)
            {
                // The submenu was modal and is finished now
                _ExitMenuMode();
            }
        }
    }
    else if (_fMenuMode)
    {
        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): UIActivateIO(%d)", DBG_THIS, fActivate);

        ASSERT( !_fInSubMenu );

        if (!_fTopLevel)
            IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), FALSE);

        _ExitMenuMode();
    }

    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IDeskBand::GetBandInfo method

*/
HRESULT CMenuBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{
    HRESULT hres = NOERROR;

    _dwBandID = dwBandID;           // critical for perf! (BandInfoChanged)

    pdbi->dwMask &= ~DBIM_TITLE;    // no title (ever, for now)

    // We expect that _pmtbBottom should never be the only toolbar
    // that exists in the menuband.
    ASSERT(NULL == _pmtbBottom || _pmtbTop);

    pdbi->dwModeFlags = DBIMF_USECHEVRON;

    if (_pmtbTop)
    {
        // If the buttons need to be updated in the toolbars, the we should 
        // do this before we start asking them about their sizes....
        if (_fForceButtonUpdate)
        {
            _UpdateButtons();
        }

        if (_fVertical) 
        {
            pdbi->ptMaxSize.y = 0;
            pdbi->ptMaxSize.x = 0;

            SIZE size = {0};
        
            if (_pmtbMenu)
            {
                // size param zero here => it's just an out param
                _pmtbMenu->GetSize(&size);

                // HACKHACK (lamadio): On downlevel, LARGE metrics mode causes 
                // Start menu to push the programs menu item off screen.
                if (size.cy > (3 * GetSystemMetrics(SM_CYSCREEN) / 4))
                {
                    Exec(&CGID_MenuBand, MBANDCID_SETICONSIZE, ISFBVIEWMODE_SMALLICONS, NULL, NULL);
                    size.cx = 0;
                    size.cy = 0;
                    _pmtbMenu->GetSize(&size);
                }

                pdbi->ptMaxSize.y = size.cy;
                pdbi->ptMaxSize.x = size.cx;
            }
            if (_pmtbShellFolder)
            {
                // size param should be non-zero here => it's an in/out param
                _pmtbShellFolder->GetSize(&size);
                pdbi->ptMaxSize.y += size.cy + ((_pmtbMenu && !_fExpanded)? 1 : 0);   // Minor sizing problem
                pdbi->ptMaxSize.x = max(size.cx, pdbi->ptMaxSize.x);
            }

            pdbi->ptMinSize = pdbi->ptMaxSize;

        }
        else
        {
            HWND hwnd = _pmtbTop->_hwndMB;
            ShowDW(TRUE);

            SIZE rgSize;
            if ( SendMessage( hwnd, TB_GETMAXSIZE, 0, (LPARAM) &rgSize ))
            {
                pdbi->ptActual.y = rgSize.cy;
                SendMessage(hwnd, TB_GETIDEALSIZE, FALSE, (LPARAM)&pdbi->ptActual);
            }

            // make our min size identical to the size of the first button
            // (we're assuming that the toolbar has at least one button)
            RECT rc;
            SendMessage(hwnd, TB_GETITEMRECT, 0, (WPARAM)&rc);
            pdbi->ptMinSize.x = RECTWIDTH(rc);
            pdbi->ptMinSize.y = RECTHEIGHT(rc);
        }
    }
    return hres;
}

/*----------------------------------------------------------
Purpose: IOleService::Exec method

*/
STDMETHODIMP CMenuBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdExecOpt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{

    // Don't do anything if we're closing.
    if (_fClosing)
        return E_FAIL;

    if (pguidCmdGroup == NULL) 
    {
        /*NOTHING*/
    }
    else if (IsEqualGUID(CGID_MENUDESKBAR, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case MBCID_GETSIDE:
            if (pvarargOut) 
            {
                BOOL fOurChoice = FALSE;
                pvarargOut->vt = VT_I4;
                
                if (!_fTopLevel) 
                {
                    // if we are not the top level menu, we 
                    // must continue with the direction our parent was in
                    IMenuPopup* pmpParent;
                    IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_IMenuPopup, (LPVOID*)&pmpParent);
                    if (pmpParent) 
                    {
                        if (FAILED(IUnknown_Exec(pmpParent, pguidCmdGroup, nCmdID, nCmdExecOpt, pvarargIn, pvarargOut)))
                            fOurChoice = TRUE;
                        pmpParent->Release();
                    }
                } else 
                    fOurChoice = TRUE;

                if (!fOurChoice) {
                    // only use the parent's side hint if it is in the same orientation (ie, horizontal menubar to vertical popup 
                    // means we need to make a new choice)
                    BOOL fParentVertical = (pvarargOut->lVal == MENUBAR_RIGHT || pvarargOut->lVal == MENUBAR_LEFT);
                    if (BOOLIFY(_fVertical) != BOOLIFY(fParentVertical))
                        fOurChoice = TRUE;
                }

                if (fOurChoice) 
                {
                    if (_fVertical)
                    {
                        HWND hWndMenuBand;

                        //
                        // The MenuBand is Mirrored , then start the first Menu Window
                        // as Mirrored. [samera]
                        //
                        if ((SUCCEEDED(GetWindow(&hWndMenuBand))) &&
                            (IS_WINDOW_RTL_MIRRORED(hWndMenuBand)) ) 
                            pvarargOut->lVal = MENUBAR_LEFT;
                        else
                            pvarargOut->lVal = MENUBAR_RIGHT;
                    }
                    else
                        pvarargOut->lVal = MENUBAR_BOTTOM;
                }

            }
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_MenuBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case MBANDCID_GETFONTS:
            // BUGBUG (lamadio): can I remove this?
            if (pvarargOut)
            {
                if (EVAL(_pmbm))
                {
                    // BUGBUG (lamadio): this is not marshal-safe.
                    pvarargOut->vt = VT_UNKNOWN;
                    _pmbm->QueryInterface(IID_IUnknown, (void**)&pvarargOut->punkVal);
                    return S_OK;
                }
                else
                    return E_FAIL;
            }
            else
                return E_INVALIDARG;
            break;

        case MBANDCID_SETFONTS:
            if (pvarargIn && VT_UNKNOWN == pvarargIn->vt && pvarargIn->punkVal)
            {
                // BUGBUG (lamadio): this is not marshal-safe.
                ATOMICRELEASE(_pmbm);
                pvarargIn->punkVal->QueryInterface(CLSID_MenuBandMetrics, (void**)&_pmbm);

                _fForceButtonUpdate = TRUE;
                // Force Update of Toolbars:
                if (_pmtbMenu)
                    _pmtbMenu->SetMenuBandMetrics(_pmbm);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->SetMenuBandMetrics(_pmbm);
            }
            else
                return E_INVALIDARG;
            break;


        case MBANDCID_RECAPTURE:
            GetMessageFilter()->RetakeCapture();
            break;

        case MBANDCID_NOTAREALSITE:
            _fParentIsNotASite = BOOLIFY(nCmdExecOpt);
            break;

        case MBANDCID_ITEMDROPPED:
            {
                _fDragEntered = FALSE;
                HWND hwndWorker = _pmbState->GetWorkerWindow(NULL);
                if (hwndWorker && !HasWindowTopmostOwner(hwndWorker))
                    SetWindowPos(hwndWorker, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);
            }
            break;

        case MBANDCID_DRAGENTER:
            _fDragEntered = TRUE;
            break;

        case MBANDCID_DRAGLEAVE:
            _fDragEntered = FALSE;
            break;

            
        case MBANDCID_SELECTITEM:
            {
                int iPos = nCmdExecOpt;

                // If they are passing vararg in, then this is an ID, not a position
                if (pvarargIn && pvarargIn->vt == VT_I4)
                {
                    _nItemNew = pvarargIn->lVal;
                    _fPopupNewItemOnShow = TRUE;
                }

                // This can be called outside of a created band.
                if (_pmtbTop)
                {
                    if (iPos == MBSI_NONE)
                    {
                        SetTracked(NULL);
                    }
                    else
                    {
                        CMenuToolbarBase* pmtb = (iPos == MBSI_LASTITEM) ? _pmtbBottom : _pmtbTop;
                        ASSERT(pmtb);

                        SetTracked(pmtb);
                        _pmtbTracked->SetHotItem(1, iPos, -1, HICF_OTHER);

                        // If the new hot item is in the obscured part of the menu, then the
                        // above call will have reentered & nulled out _pmtbTracked (since we
                        // drop down the chevron menu if the new hot item is obscured).  So we
                        // need to revalidate _pmtbTracked.
                        if (!_pmtbTracked)
                            break;

                        NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
                            GetIndexFromChild(TRUE, iPos));
                    }
                }
            }
            break;

        case MBANDCID_KEYBOARD:
            // If we've been executed because of a keyboard, then set the global
            // state to reflect that. This is sent by MenuBar when it's ::Popup
            // member is called with the flag MPPF_KEYBOARD. This is for start menu.
            if (_pmbState)
                _pmbState->SetKeyboardCue(TRUE);
            break;

        case MBANDCID_POPUPITEM:
            if (pvarargIn && VT_I4 == pvarargIn->vt)
            {
                // we don't want to popup a sub menu if we're tracking a context menu...
                if ( !((_pmtbBottom && _pmtbBottom->v_TrackingSubContextMenu()) || 
                       (_pmtbTop && _pmtbTop->v_TrackingSubContextMenu())))
                {
                    // No tracked item? Well default to the top (For the chevron menu)
                    if (!_pmtbTracked)
                    {
                        SetTracked(_pmtbTop);
                    }

                    // We don't want to display the sub menu if we're not shown.
                    // We do this because we could have been dismissed before the message
                    // was routed.
                    if (_fShow && _pmtbTracked)
                    {
                        int iItem;
                        int iPos;

                        if (nCmdExecOpt & MBPUI_ITEMBYPOS)
                        {
                            iPos = pvarargIn->lVal;
                            iItem = GetButtonCmd(_pmtbTracked->_hwndMB, pvarargIn->lVal);
                        }
                        else
                        {
                            iPos = ToolBar_CommandToIndex(_pmtbTracked->_hwndMB, pvarargIn->lVal);
                            iItem = pvarargIn->lVal;
                        }


                        if (nCmdExecOpt & MBPUI_SETITEM)
                        {
                            // Set the hot item explicitly since this can be
                            // invoked by the keyboard and the mouse could be 
                            // anywhere.
                            _pmtbTracked->SetHotItem(1, iPos, -1, HICF_OTHER);

                            // If the new hot item is in the obscured part of the menu, then the
                            // above call will have reentered & nulled out _pmtbTracked (since we
                            // drop down the chevron menu if the new hot item is obscured).  So we
                            // need to revalidate _pmtbTracked.
                            if (!_pmtbTracked)
                                break;

                            NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
                                GetIndexFromChild(TRUE, iPos) );
                        }

                        _pmtbTracked->PopupHelper(iItem, nCmdExecOpt & MBPUI_INITIALSELECT);
                    }
                }
            }
            break;

        case MBANDCID_ISVERTICAL:
            if (pvarargOut)
            {
                pvarargOut->vt = VT_BOOL;
                pvarargOut->boolVal = (_fVertical)? VARIANT_TRUE: VARIANT_FALSE;
            }
            break;
            
        case MBANDCID_SETICONSIZE:
            ASSERT(nCmdExecOpt == ISFBVIEWMODE_SMALLICONS || 
                nCmdExecOpt == ISFBVIEWMODE_LARGEICONS);

            _uIconSize = nCmdExecOpt;

            if (_pmtbTop)
                _pmtbTop->v_UpdateIconSize(nCmdExecOpt, TRUE);

            if (_pmtbBottom)
                _pmtbBottom->v_UpdateIconSize(nCmdExecOpt, TRUE);
            break;

        case MBANDCID_SETSTATEOBJECT:
            if (pvarargIn && VT_INT_PTR == pvarargIn->vt)
            {
                _pmbState = (CMenuBandState*)pvarargIn->byref;
            }
            break;

        case MBANDCID_ISINSUBMENU:
            if (_fInSubMenu || (_pmtbTracked && _pmtbTracked->v_TrackingSubContextMenu()))
                return S_OK;
            else
                return S_FALSE;
            break;

        case MBANDCID_ISTRACKING:
            if (_pmtbTracked && _pmtbTracked->v_TrackingSubContextMenu())
                return S_OK;
            else
                return S_FALSE;
            break;

        case MBANDCID_REPOSITION:

            // Don't reposition unless we're shown (Avoids artifacts onscreen of a bad positioning)
            if (_fShow)
            {
                // Don't forget to reposition US!!!
                IMenuPopup* pmdb;
                DWORD dwFlags = MPPF_REPOSITION | MPPF_NOANIMATE;

                // If we should force a reposition. This is so that we get
                // the trickle down reposition so things overlap correctly
                if (nCmdExecOpt)
                    dwFlags |= MPPF_FORCEZORDER;

                if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_IMenuPopup, (void**)&pmdb)))
                {
                    pmdb->Popup(NULL, NULL, dwFlags);
                    pmdb->Release();
                }

                // Reposition the Tracked sub menu based on the current popped up item 
                // since this pane has now moved
                // If they have a sub menu, tell them to reposition as well.
                if (_fInSubMenu && _pmtbTracked)
                {
                    IUnknown_QueryServiceExec(_pmpSubMenu, SID_SMenuBandChild,
                    &CGID_MenuBand, MBANDCID_REPOSITION, nCmdExecOpt, NULL, NULL);
                }
                _pmbState->PutTipOnTop();
            }
            break;

        case MBANDCID_REFRESH:
            InvalidateItem(NULL, SMINV_REFRESH);
            break;
            
        case MBANDCID_EXPAND:
            if (_pmtbShellFolder)
                _pmtbShellFolder->Expand(TRUE);

            if (_pmtbMenu)
                _pmtbMenu->Expand(TRUE);
            break;

        case MBANDCID_DRAGCANCEL:
            // If one of the Sub bands in the menu heirarchy has the drag 
            // (Either because of Drag enter or because of the drop) then 
            // we do not want to cancel. 
            if (!_pmbState->HasDrag())
                _CancelMode(MPOS_FULLCANCEL);
            break;

        case MBANDCID_EXECUTE:
            ASSERT(pvarargIn != NULL);
            if (_pmtbTop && _pmtbTop->IsWindowOwner((HWND)pvarargIn->ullVal) == S_OK)
                _pmtbTop->v_ExecItem((int)nCmdExecOpt);
            else if (_pmtbBottom && _pmtbBottom->IsWindowOwner((HWND)pvarargIn->ullVal) == S_OK)
                _pmtbBottom->v_ExecItem((int)nCmdExecOpt);
            _SiteOnSelect(MPOS_EXECUTE);
            break;
        }

        // Don't bother passing CGID_MenuBand commands to CToolBand
        return S_OK;
    }     
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvarargIn, pvarargOut);    
}


/*----------------------------------------------------------
Purpose: IDockingWindow::CloseDW method.

*/
STDMETHODIMP CMenuBand::CloseDW(DWORD dw)
{
    // We don't want to destroy the band if it's cached. 
    // That means it's the caller's respocibility to Unset this bit and call CloseDW explicitly
    if (_dwFlags & SMINIT_CACHED)
        return S_OK;

    // Since we're blowing away all of the menus,
    // Top and bottom are invalid
    _pmtbTracked = _pmtbTop = _pmtbBottom = NULL;

    if (_pmtbMenu)
    {
        _pmtbMenu->v_Close();
    }

    if (_pmtbShellFolder)
    {
        _pmtbShellFolder->v_Close();
    }

    if (_pmpSubMenu)
    {
        _fInSubMenu = FALSE;
        IUnknown_SetSite(_pmpSubMenu, NULL);
        ATOMICRELEASE(_pmpSubMenu);
    }

    // We don't want our base class to blow this window away. It belongs to someone else.
    _hwnd = NULL;
    _fClosing = TRUE;
    
    return SUPERCLASS::CloseDW(dw);
}


/*----------------------------------------------------------
Purpose: IDockingWindow::ShowDW method

Notes:
    for the start menu (non-browser) case, we bracket* the top-level popup
    operation w/ a LockSetForegroundWindow so that another app can't steal
    the foreground and collapse our menu.  (nt5:172813: don't do it for
    the browser case since a) we don't want to and b) ShowDW(FALSE) isn't
    called until exit the browser so we'd be permanently locked!)
*/
STDMETHODIMP CMenuBand::ShowDW(BOOL fShow)
{   
    CMBMsgFilter* pmf = GetMessageFilter();
    // Prevent rentrancy when we're already shown.
    ASSERT((int)_fShow == BOOLIFY(_fShow));
    if ((int)_fShow == BOOLIFY(fShow))
        return NOERROR;

    HRESULT hres = SUPERCLASS::ShowDW(fShow);

    if (!fShow)
    {
        _fShow = FALSE;
        if (_fTopLevel)
        {
            if (_fVertical) 
            {
                // (_fTopLevel && _fVertical) => start menu
                MyLockSetForegroundWindow(FALSE);
            }
            else if (_dwFlags & SMINIT_USEMESSAGEFILTER)
            {
                pmf->SetHook(FALSE, TRUE);
                pmf->SetTopMost(this);
            }

        }

        if ((_fTopLevel || _fParentIsHorizontal) && _pmbState)
        {
            // Reset to not have the drag when we collapse.
            _pmbState->HasDrag(FALSE);
            _pmbState->SetExpand(FALSE);
            _pmbState->SetUEMState(0);
        }

        _CallCB(SMC_EXITMENU);
    }
    else
    {
        _CallCB(SMC_INITMENU);

        _fClosing = FALSE;
        _fShow = TRUE;
        _GetFontMetrics();

        if (_fTopLevel)
        {
            // We set the context here so that the ReEngage causes the message filter
            // to start taking messages on a TopLevel::Show. This prevents a problem
            // where tracking doesn't work when switching between Favorites and Start Menu
            _pmbState->SetContext(this);
            pmf->SetContext(this, TRUE);

            pmf->ReEngage(_pmbState->GetContext());
            if (_hwndMenuOwner && _fVertical)
                SetForegroundWindow(_hwndMenuOwner);

            if (_fVertical) 
            {
                // (_fTopLevel && _fVertical) => start menu
                MyLockSetForegroundWindow(TRUE);
            }
            else if (_dwFlags & SMINIT_USEMESSAGEFILTER)
            {
                pmf->SetHook(TRUE, TRUE);
                pmf->SetTopMost(this);
            }

            _pmbState->CreateFader(_hwndParent);
        }
    }

    if (_pmtbShellFolder)
        _pmtbShellFolder->v_Show(_fShow, _fForceButtonUpdate);

    // Menu needs to be last so that it can update the seperator.
    if (_pmtbMenu)
        _pmtbMenu->v_Show(_fShow, _fForceButtonUpdate);

    if (_fPopupNewItemOnShow)
    {
        HWND hwnd = _pmbState ? _pmbState->GetSubclassedHWND() : NULL;

        if (hwnd || _pmtbMenu)
        {
            PostMessage(hwnd ? hwnd : _pmtbMenu->_hwndMB, g_nMBPopupOpen, 
                _nItemNew, MAKELPARAM(TRUE, TRUE));
        }
        _fPopupNewItemOnShow = FALSE;
    }

    _fForceButtonUpdate = FALSE;
    return hres;
}

void CMenuBand::_GetFontMetrics()
{
    if (_pmbm)
        return;

    if (_fTopLevel)
    {
        ASSERT(_pmtbTop);
        // We need only 1 HWND
        _pmbm = new CMenuBandMetrics(_pmtbTop->_hwndMB);
    }
    else
    {
        AssertMsg(0, TEXT("When this menuband was created, someone forgot to set the metrics"));
        IOleCommandTarget *poct;
    
        HRESULT hres = IUnknown_QueryService(_punkSite, SID_SMenuBandTop, IID_IOleCommandTarget, (LPVOID *)&poct);
        if (SUCCEEDED(hres))
        {
            VARIANTARG vargOut;

            // Ask the toplevel menuband for their font info
            if (SUCCEEDED(poct->Exec(&CGID_MenuBand, MBANDCID_GETFONTS, 0, NULL, &vargOut)))
            {
                if (vargOut.vt == VT_UNKNOWN && vargOut.punkVal)
                {
                    vargOut.punkVal->QueryInterface(CLSID_MenuBandMetrics, (void**)&_pmbm);
                    vargOut.punkVal->Release();
                }
            }
            poct->Release();
        }
    }
}


/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

         This allows the child menubar to tell us when and how
         to bail out of the menu.
*/
STDMETHODIMP CMenuBand::OnSelect(DWORD dwType)
{
    int iIndex;

    switch (dwType)
    {
    case MPOS_CHILDTRACKING:
        // this means that our child did get tracked over it, so we should abort any timeout to destroy it

        if (_pmtbTracked)
        {
            HWND hwnd = _pmtbTracked->_hwndMB;
            if (_nItemTimer) 
            {
                _pmtbTracked->KillPopupTimer();
        
                // Use the command id of the SubMenu that we actually have cascaded out.
                iIndex = ToolBar_CommandToIndex(hwnd, _nItemSubMenu);
                ToolBar_SetHotItem(hwnd, iIndex);
            }
            KillTimer(hwnd, MBTIMER_DRAGOVER);
            _SiteOnSelect(dwType);
        }
        break;
        
    case MPOS_SELECTLEFT:
        if (!_fVertical)
            _OnSelectArrow(-1);
        else
        {
            // Cancel the child submenu.  Hitting left arrow is like
            // hitting escape.
            _SubMenuOnSelect(MPOS_CANCELLEVEL);
        }
        break;

    case MPOS_SELECTRIGHT:
        if (!_fVertical)
            _OnSelectArrow(1);
        else
        {
            // The right arrow gets propagated up to the top, so
            // a fully cascaded menu will be cancelled and the
            // top level menuband will move to the next menu to the
            // right.
            _SiteOnSelect(dwType);
        }
        break;
        
    case MPOS_CANCELLEVEL:
        // Forward onto submenu
        _SubMenuOnSelect(dwType);
        break;

    case MPOS_FULLCANCEL:
    case MPOS_EXECUTE:
        DEBUG_CODE( TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): CMenuToolbarBase received %s", 
                    DBG_THIS, MPOS_FULLCANCEL == dwType ? TEXT("MPOS_FULLCANCEL") : TEXT("MPOS_EXECUTE")); )

        _CancelMode(dwType);
        break;
    }
    return S_OK;    
}    

void CMenuBand::SetTrackMenuPopup(IUnknown* punk)
{ 
    ATOMICRELEASE(_pmpTrackPopup);
    if (punk)
    {
        punk->QueryInterface(IID_IMenuPopup, (void**)&_pmpTrackPopup);
    }
}


/*----------------------------------------------------------
Purpose: Set the currently tracked toolbar.  Only one
         of the toolbars can have the "activation" at one time.
*/
BOOL CMenuBand::SetTracked(CMenuToolbarBase* pmtb)
{
    if (pmtb == _pmtbTracked)
        return FALSE;

    if (_pmtbTracked)
    {
        // Tell the existing toolbar we're leaving him
        SendMessage(_pmtbTracked->_hwndMB, TB_SETHOTITEM2, -1, HICF_LEAVING);
    }

    _pmtbTracked = pmtb;

    if (_pmtbTracked)
    {
        // This is for accessibility.
        HWND hwnd = _pmtbTracked->_hwndMB;
        int iHotItem = ToolBar_GetHotItem(hwnd);

        if (iHotItem >= 0)
        {
            // Toolbar Items are 0 based, Accessibility apps require 1 based
            NotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, 
                GetIndexFromChild(_pmtbTracked->GetFlags() & SMSET_TOP, iHotItem)); 
        }
    }

    return TRUE;
}


void CMenuBand::_OnSelectArrow(int iDir)
{
    _fKeyboardSelected = TRUE;
    int iIndex;

    if (!_pmtbTracked)
    {
        if (iDir < 0)
        {
            SetTracked(_pmtbBottom);
            iIndex = ToolBar_ButtonCount(_pmtbTracked->_hwndMB) - 1;
        }
        else
        {
            SetTracked(_pmtbTop);
            iIndex = 0;
        }

        // This can happen when going to the chevron.
        if (_pmtbTracked)
            _pmtbTracked->SetHotItem(iDir, iIndex, -1, HICF_ARROWKEYS);
    }
    else
    {
        HWND hwnd = _pmtbTracked->_hwndMB;
        iIndex = ToolBar_GetHotItem(hwnd);
        int iCount = ToolBar_ButtonCount(hwnd);
    
        // Set the hot item explicitly since this is invoked by the 
        // keyboard and the mouse could be anywhere.

        // cycle iIndex by iDir (add extra iCount to avoid negative number problems
        iIndex = (iIndex + iCount + iDir) % iCount; 

        ToolBar_SetHotItem(hwnd, iIndex);
    }

    if (_pmtbTracked)
    {
        NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
            GetIndexFromChild(_pmtbTracked->GetFlags() & SMSET_TOP, iIndex));
    }
    _fKeyboardSelected = FALSE;
}

void CMenuBand::_CancelMode(DWORD dwType)
{
    // Tell the hosting site to cancel this level
    if (_fParentIsNotASite)
        UIActivateIO(FALSE, NULL);
    else
        _SiteOnSelect(dwType);
}    

HRESULT CMenuBand::OnPosRectChangeDB (LPRECT prc)
{
    // We want the HMENU portion to ALWAYS have the maximum allowed.
    RECT rcMenu = {0};
    SIZE sizeMenu = {0};
    SIZE sizeSF = {0};
    SIZE sizeMax;

    if (_pmtbMenu)
        _pmtbMenu->GetSize(&sizeMenu);

    if (_pmtbShellFolder)
        _pmtbShellFolder->GetSize(&sizeSF);

    if (sizeSF.cx > sizeMenu.cx)
        sizeMax = sizeSF;
    else
        sizeMax = sizeMenu;

    if (_pmtbMenu)
    {
        if (_pmtbMenu->GetFlags() & SMSET_TOP)
        {

            rcMenu.bottom = sizeMenu.cy;
            rcMenu.right = prc->right;
        }
        else
        {
            rcMenu.bottom = prc->bottom;
            rcMenu.right = prc->right;

            rcMenu.top = prc->bottom - sizeMenu.cy;
            rcMenu.left = 0;
        }

        _pmtbMenu->SetWindowPos(&sizeMax, &rcMenu, 0);
    }

    if (_pmtbShellFolder)
    {
        RECT rc = *prc;

        if (_pmtbShellFolder->GetFlags() & SMSET_TOP)
        {
            rc.bottom = prc->bottom - RECTHEIGHT(rcMenu) + 1;
        }
        else
        {
            rc.top = prc->top + RECTHEIGHT(rcMenu);
        }

        _pmtbShellFolder->SetWindowPos(&sizeMax, &rc, 0);
    }

    return NOERROR;
}


HRESULT IUnknown_OnSelect(IUnknown* punk, DWORD dwType, REFGUID guid)
{
    HRESULT hres;
    IMenuPopup * pmp;

    hres = IUnknown_QueryService(punk, guid, IID_IMenuPopup, 
                                 (LPVOID *)&pmp);
    if (SUCCEEDED(hres))
    {
        pmp->OnSelect(dwType);
        pmp->Release();
    }

    return hres;
}

HRESULT CMenuBand::_SiteOnSelect(DWORD dwType)
{
    return IUnknown_OnSelect(_punkSite, dwType, SID_SMenuPopup);
}

HRESULT CMenuBand::_SubMenuOnSelect(DWORD dwType)
{
    IMenuPopup* pmp = _pmpSubMenu;
    if (_pmpTrackPopup)
        pmp = _pmpTrackPopup;

    return IUnknown_OnSelect(pmp, dwType, SID_SMenuPopup);
}

HRESULT CMenuBand::GetTop(CMenuToolbarBase** ppmtbTop)
{
    *ppmtbTop = _pmtbTop;

    if (*ppmtbTop)
    {
        (*ppmtbTop)->AddRef();
        return NOERROR;
    }

    return E_FAIL;
}

HRESULT CMenuBand::GetBottom(CMenuToolbarBase** ppmtbBottom)
{
    *ppmtbBottom = _pmtbBottom;

    if (*ppmtbBottom)
    {
        (*ppmtbBottom)->AddRef();
        return NOERROR;
    }

    return E_FAIL;

}

HRESULT CMenuBand::GetTracked(CMenuToolbarBase** ppmtbTracked)
{
    *ppmtbTracked = _pmtbTracked;

    if (*ppmtbTracked)
    {
        (*ppmtbTracked)->AddRef();
        return NOERROR;
    }

    return E_FAIL;

}

HRESULT CMenuBand::GetParentSite(REFIID riid, void** ppvObj)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvObj);

    return E_FAIL;
}

HRESULT CMenuBand::GetState(BOOL* pfVertical, BOOL* pfOpen)
{
    *pfVertical = _fVertical;
    *pfOpen = _fMenuMode;
    return NOERROR;
}

HRESULT CMenuBand::DoDefaultAction(VARIANT* pvarChild)
{
    if (pvarChild->lVal != CHILDID_SELF)
    {
        CMenuToolbarBase* pmtb = (pvarChild->lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
        int idCmd = GetButtonCmd(pmtb->_hwndMB, (pvarChild->lVal & ~TOOLBAR_MASK) - 1);

        SendMessage(pmtb->_hwndMB, TB_SETHOTITEM2, idCmd, HICF_OTHER | HICF_TOGGLEDROPDOWN);
    }
    else
    {
        _CancelMode(MPOS_CANCELLEVEL);
    }

    return NOERROR;
}

HRESULT CMenuBand::GetSubMenu(VARIANT* pvarChild, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    CMenuToolbarBase* pmtb = (pvarChild->lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
    int idCmd = GetButtonCmd(pmtb->_hwndMB, (pvarChild->lVal & ~TOOLBAR_MASK) - 1);

    *ppvObj = NULL;

    if (idCmd != -1 && pmtb)
    {
        hres = pmtb->v_GetSubMenu(idCmd, &SID_SMenuBandChild, riid, ppvObj);
    }

    return hres;
}

HRESULT CMenuBand::IsEmpty()
{
    BOOL fReturn = TRUE;
    if (_pmtbShellFolder)
        fReturn = _pmtbShellFolder->IsEmpty();

    if (fReturn && _pmtbMenu)
        fReturn = _pmtbMenu->IsEmpty();

    return fReturn? S_OK : S_FALSE;
}

/*----------------------------------------------------------
Purpose: IShellMenu2::GetSubMenu method
*/

HRESULT CMenuBand::GetSubMenu(UINT idCmd, REFIID riid, void** ppvObj)
{
    return E_NOTIMPL;
}

HRESULT CMenuBand::SetToolbar(HWND hwnd, DWORD dwFlags)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMenuToolbarBase *pmtb = ToolbarMenu_Create(hwnd);
    if (pmtb)
    {
        hr = SetMenuToolbar(SAFECAST(pmtb, IWinEventHandler*), dwFlags);
        // DONT release! The menus break com identity rules because of a foobar when they were
        // initially designed.
    }
    return hr;
}

HRESULT CMenuBand::SetMinWidth(int cxMenu)
{
    return E_NOTIMPL;
}

HRESULT CMenuBand::SetNoBorder(BOOL fNoBorder)
{
    return E_NOTIMPL;
}

HRESULT CMenuBand::SetTheme(LPCWSTR pszTheme)
{
    return E_NOTIMPL;
}


//----------------------------------------------------------------------------
// CMenuBandMetrics
//
//----------------------------------------------------------------------------


COLORREF GetDemotedColor()
{
    WORD iHue;
    WORD iLum;
    WORD iSat;
    COLORREF clr = (COLORREF)GetSysColor(COLOR_MENU);
    HDC hdc = GetDC(NULL);

    // Office CommandBars use this same algorithm for their "intellimenus"
    // colors.  We prefer to call them "expando menus"...

    if (hdc)
    {
        int cColors = GetDeviceCaps(hdc, BITSPIXEL);
        
        ReleaseDC(NULL, hdc);
        
        switch (cColors)
        {
        case 4:     // 16 Colors
        case 8:     // 256 Colors
            // Default to using Button Face
            break;
            
        default:    // 256+ colors
            
            ColorRGBToHLS(clr, &iHue, &iLum, &iSat);
            
            if (iLum > 220)
                iLum -= 20;
            else if (iLum <= 20)
                iLum += 40;
            else
                iLum += 20;
            
            clr = ColorHLSToRGB(iHue, iLum, iSat);
            break;
        }
    }
    
    return  clr;
}


ULONG CMenuBandMetrics::AddRef()
{
    return ++_cRef;
}

ULONG CMenuBandMetrics::Release()
{
    ASSERT(_cRef > 0);
    if (--_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CMenuBandMetrics::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else if (IsEqualIID(riid, CLSID_MenuBandMetrics))
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_FAIL;
    }

    AddRef();
    return S_OK;
}

CMenuBandMetrics::CMenuBandMetrics(HWND hwnd)
                : _cRef(1)
{
    _SetMenuFont();
    _SetArrowFont(hwnd);
    _SetChevronFont(hwnd);
#ifndef DRAWEDGE
    _SetPaintMetrics(hwnd);
#endif
    _SetTextBrush(hwnd);
    _SetColors();

    HIGHCONTRAST hc = {sizeof(HIGHCONTRAST)};

    if (SystemParametersInfoA(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
    {
        _fHighContrastMode = (HCF_HIGHCONTRASTON & hc.dwFlags);
    }
}

CMenuBandMetrics::~CMenuBandMetrics()
{
    if (_hFontMenu)
        DeleteObject(_hFontMenu);

    if (_hFontArrow)
        DeleteObject(_hFontArrow);

    if (_hFontChevron)
        DeleteObject(_hFontChevron);

    if (_hbrText)
        DeleteObject(_hbrText);

#ifndef DRAWEDGE
    if (_hPenHighlight)
        DeleteObject(_hPenHighlight);

    if (_hPenShadow)
        DeleteObject(_hPenShadow);
#endif
}

HFONT CMenuBandMetrics::_CalcFont(HWND hwnd, LPCTSTR pszFont, DWORD dwCharSet, TCHAR ch, int* pcx, 
                                  int* pcy, int* pcxMargin, int iOrientation, int iWeight)
{
    ASSERT(hwnd);

    HFONT hFontOld, hFontRet = NULL;
    TEXTMETRIC tm;
    RECT rect={0};

    int cx = 0, cy = 0, cxM = 0;

    HDC hdc = GetDC(hwnd);

    if (hdc)
    {
        hFontOld = (HFONT)SelectObject(hdc, _hFontMenu);
        GetTextMetrics(hdc, &tm);

        // Set the font height (based on original USER code)
        cy = ((tm.tmHeight + tm.tmExternalLeading + GetSystemMetrics(SM_CYBORDER)) & 0xFFFE) - 1;

        // Use the menu font's avg character width as the margin.
        cxM = tm.tmAveCharWidth; // Not exactly how USER does it, but close

        // Shlwapi wraps the ansi/unicode behavior.
        hFontRet = CreateFontWrap(cy, 0, iOrientation, 0, iWeight, 0, 0, 0, dwCharSet, 0, 0, 0, 0, pszFont);
        if (EVAL(hFontRet))
        {
            // Calc width of arrow using this new font
            SelectObject(hdc, hFontRet);
            if (EVAL(DrawText(hdc, &ch, 1, &rect, DT_CALCRECT | DT_SINGLELINE | DT_LEFT | DT_VCENTER)))
                cx = rect.right;
            else
                cx = tm.tmMaxCharWidth;
        }
        else
        {
            cx = tm.tmMaxCharWidth;
        }
    
        SelectObject(hdc, hFontOld);   
        ReleaseDC(hwnd, hdc);
    }

    *pcx = cx;
    *pcy = cy;
    *pcxMargin = cxM;
    
    return hFontRet;

}


/*
    Call after _SetMenuFont()
*/
void CMenuBandMetrics::_SetChevronFont(HWND hwnd)
{
    ASSERT(!_hFontChevron);
    TCHAR szPath[MAX_PATH];

    NONCLIENTMETRICSA ncm;

    ncm.cbSize = sizeof(ncm);
    // Should only fail with bad parameters...
    EVAL(SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));
   
    // Obtain the font's metrics
    SHAnsiToTChar(ncm.lfMenuFont.lfFaceName, szPath, ARRAYSIZE(szPath));
    _hFontChevron = _CalcFont(hwnd, szPath, DEFAULT_CHARSET, CH_MENUARROW, &_cxChevron, &_cyChevron, 
        &_cxChevron, -900, FW_NORMAL);
}

/*
    Call after _SetMenuFont()
*/
void CMenuBandMetrics::_SetArrowFont(HWND hwnd)
{
    ASSERT(!_hFontArrow);
    ASSERT(_hFontMenu);
   
    // Obtain the font's metrics
    if (_hFontMenu)
    {
        _hFontArrow = _CalcFont(hwnd, szfnMarlett, SYMBOL_CHARSET, CH_MENUARROW, &_cxArrow, &_cyArrow, 
            &_cxMargin, 0, FW_NORMAL);
    }
    else
    {
        _cxArrow = _cyArrow = _cxMargin = 0;
    }
}

void CMenuBandMetrics::_SetMenuFont()
{
    NONCLIENTMETRICSA ncm;

    ncm.cbSize = sizeof(ncm);
    // Should only fail with bad parameters...
    EVAL(SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));
    // Should only fail under low mem conditions...
    
    EVAL(_hFontMenu = CreateFontIndirectA(&ncm.lfMenuFont));
}

void CMenuBandMetrics::_SetColors()
{
    _clrBackground = GetSysColor(COLOR_MENU);
    _clrMenuText = GetSysColor(COLOR_MENUTEXT);
    _clrDemoted = GetDemotedColor();
}


#ifndef DRAWEDGE
// Office "IntelliMenu" style
void CMenuBandMetrics::_SetPaintMetrics(HWND hwnd)
{
    DWORD dwSysHighlight = GetSysColor(COLOR_3DHIGHLIGHT);
    DWORD dwSysShadow = GetSysColor(COLOR_3DSHADOW);

    _hPenHighlight = CreatePen(PS_SOLID, 1, dwSysHighlight);
    _hPenShadow = CreatePen(PS_SOLID, 1, dwSysShadow);
}
#endif

void CMenuBandMetrics::_SetTextBrush(HWND hwnd)
{
    _hbrText = CreateSolidBrush(GetSysColor(COLOR_MENUTEXT));
}


CMenuBandState::CMenuBandState()                
{ 
    // We will default to NOT show the keyboard cues. This
    // is overridden based on the User Settings.
    _fKeyboardCue = FALSE;
}

CMenuBandState::~CMenuBandState()
{
    ATOMICRELEASE(_ptFader);

    ATOMICRELEASE(_pScheduler);

    if (IsWindow(_hwndToolTip))
        DestroyWindow(_hwndToolTip);

    if (IsWindow(_hwndWorker)) // JANK : Fix for bug #101302
        DestroyWindow(_hwndWorker);
}

int CMenuBandState::GetKeyboardCue()
{
    return _fKeyboardCue;
}

void CMenuBandState::SetKeyboardCue(BOOL fKC)
{
    _fKeyboardCue = fKC;
}

IShellTaskScheduler* CMenuBandState::GetScheduler()
{
    if (!_pScheduler)
    {
        CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC,
                               IID_IShellTaskScheduler, (void **) &_pScheduler);
    }

    if (_pScheduler)
        _pScheduler->AddRef();


    return _pScheduler;
}

BOOL CMenuBandState::FadeRect(PRECT prc, PFNFADESCREENRECT pfn, LPVOID pvParam)
{
    BOOL    fFade = FALSE;
    SystemParametersInfo(SPI_GETSELECTIONFADE, 0, &fFade, 0);
    if (g_bRunOnNT5 && _ptFader && fFade)
    {
        // Set the callback into the fader window. Do this each time, as the pane 
        // may have changed between fades
        if (_ptFader->FadeRect(prc, pfn, pvParam))
        {
            IShellTaskScheduler* pScheduler = GetScheduler();
            if (pScheduler)
            {
                fFade = pScheduler->AddTask(_ptFader, TASKID_Fader, 
                    ITSAT_DEFAULT_LPARAM, ITSAT_DEFAULT_PRIORITY) == S_OK;
            }
        }
    }

    return fFade;
}

void CMenuBandState::CreateFader(HWND hwnd)
{
    // We do this on first show, because in the Constuctor of CMenuBandState,
    // the Window classes might not be registered yet (As is the case with start menu).
    if (g_bRunOnNT5 && !_ptFader)
    {
        _ptFader = new CFadeTask();
    }
}


void CMenuBandState::CenterOnButton(HWND hwndTB, BOOL fBalloon, int idCmd, LPTSTR pszTitle, LPTSTR pszTip)
{
    // Balloon style holds presidence over info tips
    if (_fTipShown && _fBalloonStyle)
        return;

    if (!_hwndToolTip)
    {
        _hwndToolTip = CreateWindow(TOOLTIPS_CLASS, NULL,
                                         WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
                                         CW_USEDEFAULT, CW_USEDEFAULT,
                                         CW_USEDEFAULT, CW_USEDEFAULT,
                                         NULL, NULL, g_hinst,
                                         NULL);

        if (_hwndToolTip) 
        {
            // set the version so we can have non buggy mouse event forwarding
            SendMessage(_hwndToolTip, CCM_SETVERSION, COMCTL32_VERSION, 0);
            SendMessage(_hwndToolTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)300);

        }
    }

    if (_hwndToolTip)
    {
        // Collapse the previous tip because we're going to be doing some stuff to it before displaying again.
        SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)FALSE, (LPARAM)0);

        // Balloon tips don't have a border, but regular tips do. Swap now...
        SHSetWindowBits(_hwndToolTip, GWL_STYLE, TTS_BALLOON | WS_BORDER, (fBalloon) ? TTS_BALLOON : WS_BORDER);

        if (pszTip && pszTip[0])
        {
            POINT   ptCursor;
            RECT    rcItemScreen, rcItemTB;
            TOOLINFO ti = {0};
            ti.cbSize = SIZEOF(ti);

            // This was pretty bad: I kept adding tools, but never deleteing them. Now we get rid of the current
            // one then add the new one.
            if (SendMessage(_hwndToolTip, TTM_ENUMTOOLS, 0, (LPARAM)&ti))
            {
                SendMessage(_hwndToolTip, TTM_DELTOOL, 0, (LPARAM)&ti);   // Delete the current tool.
            }

            SendMessage(hwndTB, TB_GETRECT, idCmd, (LPARAM)&rcItemScreen);
            rcItemTB = rcItemScreen;
            MapWindowPoints(hwndTB, HWND_DESKTOP, (POINT*)&rcItemScreen, 2);

            ti.cbSize = IsOS(OS_WHISTLERORGREATER)?SIZEOF(ti):TTTOOLINFOW_V2_SIZE;
            ti.uFlags = TTF_IDISHWND | TTF_TRANSPARENT | (fBalloon? TTF_TRACK : 0);
            
            // Check if the cursor is within the bounds of the hot item.
            // If it is, then proceed as usual.
            // If it isn't, then the hot item was activated via the keyboard, so the tooltip
            // shouldn't be hung from the cursor.  Stick it on the hot item instead.
            
            // Set the vertical offset to use later.
            // Notice the correction for the bottom: gsierra wanted it up a couple of pixels.
            int nOffset; 
            nOffset = -3;
            
            GetCursorPos(&ptCursor);
            if (!PtInRect(&rcItemScreen, ptCursor))
            {
                ti.uFlags |= TTF_TRACK;

                // The tooltip doesn't seem to pick up the hot item's rect right, so
                // do it manually.
                ti.uFlags ^= TTF_IDISHWND;      // turn this off, so ti.rect is used.
                ti.rect = rcItemTB;

                // Force the tool tip to track along the bottom.
                nOffset = 1;
            }

            SendMessage(_hwndToolTip, TTM_TRACKPOSITION, 0, MAKELONG((rcItemScreen.left + rcItemScreen.right)/2, rcItemScreen.bottom + nOffset));

            ti.hwnd = hwndTB;
            ti.uId = (UINT_PTR)hwndTB;
            SendMessage(_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);

            ti.lpszText = pszTip;
            SendMessage(_hwndToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

            SendMessage(_hwndToolTip, TTM_SETTITLE, TTI_INFO, (LPARAM)pszTitle);

            SetWindowPos(_hwndToolTip, HWND_TOPMOST,
                         0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);
            _fTipShown = TRUE;
            _fBalloonStyle = fBalloon;
        }
    }

}

void CMenuBandState::HideTooltip(BOOL fAllowBalloonCollapse)
{
    if (_hwndToolTip && _fTipShown)
    {
        // Now we're going to latch the Balloon style. The rest of menuband blindly
        // collapses the tooltip when selection changes. Here's where we say "Don't collapse
        // the chevron balloon tip because of a selection change."
        if ((_fBalloonStyle && fAllowBalloonCollapse) || !_fBalloonStyle)
        {
            SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)FALSE, (LPARAM)0);
            _fTipShown = FALSE;
        }
    }
}

void CMenuBandState::PutTipOnTop()
{
    // Force the tooltip to the topmost.
    if (_hwndToolTip)
    {
        SetWindowPos(_hwndToolTip, HWND_TOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }
}

HWND CMenuBandState::GetWorkerWindow(HWND hwndParent)
{
    if (!_hwndSubclassed)
        return NULL;

    if (!_hwndWorker)
    {
        // We need a worker window, so that dialogs show up on top of our menus.
        // HiddenWndProc is included from sftbar.h
        _hwndWorker = SHCreateWorkerWindow(HiddenWndProc, _hwndSubclassed, 
            WS_EX_TOOLWINDOW, WS_POPUP, 0, (void*)_hwndSubclassed);
    }

    //hwndParent is unused at this time. I plan on using it to prevent the parenting to the subclassed window.

    return _hwndWorker;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\menubar.cpp ===
#include "priv.h"
#include "sccls.h"
#include "basebar.h"
#include "bands.h"
#include "menubar.h"
#include "menuband.h"
#include "isfband.h"

#include "apithk.h"
// APPCOMPAT (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "oleacc.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

#define THISCLASS CMenuDeskBar
#define SUPERCLASS CBaseBar


// Don't fade the menu if it's larger than this magical number. Based on experiments
// on a Pentium II - 233
#define MAGICAL_NO_FADE_HEIGHT  600

// For TraceMsg
#define DM_POPUP   DM_TRACE

#define UP    0
#define DOWN  1
#define LEFT  2
#define RIGHT 3

#ifdef ENABLE_CHANNELS
IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidl);
#endif  // ENABLE_CHANNELS

// Used by performance timing mode
extern DWORD g_dwStopWatchMode;  // Shell performance mode
extern HMENU g_hmenuStopWatch;
extern UINT g_idCmdStopWatch;

HRESULT CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CMenuDeskBar *pwbar = new CMenuDeskBar();
    if (pwbar)
    {
        *ppunk = SAFECAST(pwbar, IMenuPopup*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


CMenuDeskBar::CMenuDeskBar() : SUPERCLASS()
{
    _dwMode = DBIF_VIEWMODE_VERTICAL; 
    
    _iIconSize = BMICON_SMALL;
}

CMenuDeskBar::~CMenuDeskBar()
{
    SetSite(NULL);
}


STDMETHODIMP CMenuDeskBar::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = {
        QITABENT(THISCLASS, IMenuPopup),
        QITABENT(THISCLASS, IObjectWithSite),
        QITABENT(THISCLASS, IBanneredBar),
        QITABENT(THISCLASS, IInitializeObject),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubmenu method

*/
STDMETHODIMP CMenuDeskBar::SetSubMenu(IMenuPopup* pmp, BOOL fSet)
{
    if (fSet)
    {
        if (_pmpChild)
            _pmpChild->Release();
        
        _pmpChild = pmp;
        _pmpChild->AddRef();    
    }
    else
    {
        if (_pmpChild && SHIsSameObject(pmp, _pmpChild))
        {
            _pmpChild->Release();
            _pmpChild = NULL;
        }
    }
    return S_OK;
}


void CMenuDeskBar::_PopDown()
{
    DAD_ShowDragImage(FALSE);
    if (_pmpChild)
        _pmpChild->OnSelect(MPOS_CANCELLEVEL);
    
//    ShowWindow(_hwnd, SW_HIDE);
    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_HIDEWINDOW);
    ShowDW(FALSE);
    if (_pmpParent)
    {
        _pmpParent->SetSubMenu(this, FALSE);
    }
    UIActivateIO(FALSE, NULL);
    _fActive = FALSE;
    DAD_ShowDragImage(TRUE);
}


/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

*/
STDMETHODIMP CMenuDeskBar::OnSelect(DWORD dwSelectType)
{
    switch (dwSelectType)
    {
    case MPOS_CHILDTRACKING:
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;
        
    case MPOS_SELECTRIGHT:
    case MPOS_SELECTLEFT:
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;

    case MPOS_EXECUTE:
    case MPOS_FULLCANCEL:
        _PopDown();
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;

    case MPOS_CANCELLEVEL:
        _PopDown();
        break;
        
    }
    
    return S_OK;
} 

void SetExpandedBorder(HWND hwnd, BOOL fExpanded)
{
#ifdef MAINWIN
    // IEUNIX : WS_DLGFRAME implementaion looks ugly on UNIX.
    fExpanded = TRUE;
#endif

    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
    DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

    if (fExpanded)
    {
        dwStyle |= WS_BORDER;
        dwStyle &= ~WS_DLGFRAME;
    }
    else
    {
        dwStyle &= ~WS_BORDER;
        dwStyle |= WS_DLGFRAME;
    }

    SetWindowLong(hwnd, GWL_STYLE, dwStyle);
    SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyle);

    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
        SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);
    UpdateWindow(hwnd);
}

void CMenuDeskBar::_OnCreate()
{
    if (!_fFlatMenuMode)
        SetExpandedBorder(_hwnd, _fExpanded);
}


DWORD CMenuDeskBar::_GetClassStyle()
{
    DWORD dwStyle = CS_SAVEBITS; // Faster repaint for menus when they go away
    
    if (IsOS(OS_WHISTLERORGREATER))
    {
        dwStyle |= CS_DROPSHADOW;   // Cool dropshadow effect on whistler....
    }

    return dwStyle;
}

DWORD CMenuDeskBar::_GetExStyle()
{
#ifndef MAINWIN
    return WS_EX_TOOLWINDOW | WS_EX_TOPMOST;
#else
    return WS_EX_TOOLWINDOW | WS_EX_TOPMOST | WS_EX_MW_UNMANAGED_WINDOW;
#endif
}

// We use the following structure to pass a whole bunch of information from 
// the GetPopupWindowPosition to WillFit function. We have WillFit function 
// to cut the amount of duplicate code in getpopup window position. The order 
// in which different the sides are checked is the only difference for popping 
// up a window on a particular side.
//
// Having this function helps us to do that check by means of a parameter instead 
// of repeating portions of code again and again.

typedef struct  {
    RECT rcAvail;           // Available dimensions b/t monitor edge and exclude edge
    SIZE sizeAdjust;          // Size of menu edge
    int  cyMonitor;         // Size of monitor 
    int  cxMonitor;
    int  cx;                // Size of menu
    int  cy;
    int  cyExtendDiff;      // Difference b/t calc'd size and available size
    RECT *prcResult;
    RECT *prcExclude;       // Exclude rect
    RECT *prcMonitor;
} PopupInfo;

#define TOP     0
#define BOTTOM  1
#define LEFT    2
#define RIGHT   3 

/*----------------------------------------------------------
Purpose: Attempt to fit and position a menu in the given direction
         relative to an exclude rect.

         Setting fForce to TRUE will cause the menu size to be adjusted
         to fit, if necessary.

         This function only sets the top and left coords, not the bottom
         and right coords.
         
         Returns TRUE if the desired direction can be accomplished.

*/
BOOL WillFit(PopupInfo * pinfo, int side, BOOL fForce)
{
    BOOL bRet = FALSE;
    LPRECT prcResult = pinfo->prcResult;
    
    pinfo->cyExtendDiff = 0;
    
    switch(side)
    {
    case TOP:
        pinfo->cyExtendDiff = pinfo->cy - pinfo->rcAvail.top;
        if (fForce)
        {
            // Doesn't make sense to subtract a negative value
            ASSERT(pinfo->cyExtendDiff >= 0);    

            // +2 for some breathing room at the edge of the screen
            pinfo->cy -= pinfo->cyExtendDiff + 2;    
        }

        // Can the menu be positioned above?
        if (pinfo->cy <= pinfo->rcAvail.top)
        {
            // Yes
            prcResult->top  = pinfo->prcExclude->top - pinfo->cy;
            
            goto AdjustHorzPos;
        }
        break;
        
    case BOTTOM:
        pinfo->cyExtendDiff = pinfo->cy - pinfo->rcAvail.bottom;
        if (fForce)
        {
            // Doesn't make sense to subtract a negative value
            ASSERT(pinfo->cyExtendDiff >= 0);    
            
            // +2 for some breathing room at the edge of the screen
            pinfo->cy -= pinfo->cyExtendDiff + 2;
        }

        // Can the menu be positioned below?
        if (pinfo->cy <= pinfo->rcAvail.bottom)
        {
            // Yes
            prcResult->top = pinfo->prcExclude->bottom;

AdjustHorzPos:            
            prcResult->left = max(pinfo->prcExclude->left, pinfo->prcMonitor->left);

            // Can the menu be positioned relative to its left edge (hanging right)?
            if (prcResult->left + pinfo->cx >= pinfo->prcMonitor->right)
            {
                // No; move it in so it is on the screen
                //  (cx has already been adjusted to fit inside the monitor dimensions)
                prcResult->left = pinfo->prcMonitor->right - pinfo->cx - 1;
            }
            bRet = TRUE;
        }
        break;
        
    case LEFT:
        // Can the menu be positioned to the left?
        if (pinfo->cx <= pinfo->rcAvail.left || fForce)
        {
            // Yes
            
            // When cascading left, the menu does not overlap.  Also align
            // so the client rect is vertically aligned with the exclude top.
            prcResult->left = pinfo->prcExclude->left - pinfo->cx - 1;

            goto AdjustVerticalPos;
        }
        break;

    case RIGHT:
        // Can the menu be positioned to the right?
        if (pinfo->cx  <=  pinfo->rcAvail.right || fForce)
        {
            // Yes
            
            // Adjust the menu to slightly overlap the parent menu.  Also align
            // so the client rect is vertically aligned with the exclude top.
            prcResult->left = pinfo->prcExclude->right - pinfo->sizeAdjust.cx;

AdjustVerticalPos:            
            prcResult->top = pinfo->prcExclude->top - pinfo->sizeAdjust.cy;

            // Can the menu be positioned relative to its top edge (hanging down)?
            if (prcResult->top + pinfo->cy >= pinfo->prcMonitor->bottom)
            {
                // No; can it be positioned relative to its bottom edge (hanging up)?
                prcResult->top = pinfo->prcExclude->bottom + pinfo->sizeAdjust.cy - pinfo->cy;
                
                if (prcResult->top < pinfo->prcMonitor->top)
                {
                    // No; move the menu so it fits, but isn't vertically snapped.
                    //  (cy has already been adjusted to fit inside the monitor
                    //  dimensions)
                    prcResult->top = pinfo->prcMonitor->bottom - pinfo->cy - 1;
                }
            }
            
            bRet = TRUE;

        }
        break;
    }
    return bRet;

}


void CMenuDeskBar::_GetPopupWindowPosition(RECT* prcDesired, RECT* prcExclude, 
                                           RECT *prcResult, SIZE * psizeAdjust, UINT uSide) 
{
    PopupInfo info;
    MONITORINFO mi;
    HMONITOR hMonitor;
    RECT rcMonitor;
    int cyExtendDiff = 0;

    // Is this going to display the banner bitmap?
    if (_iIconSize == BMICON_LARGE)
    {
        // Yes; add that to the dimensions
        prcDesired->right += _sizeBmp.cx;
    }

    // First get the monitor information
    hMonitor = MonitorFromRect(prcExclude, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    if (GetMonitorInfo(hMonitor, &mi))
    {
        rcMonitor = mi.rcMonitor;

        // Set the result rectangle same as the desired window
        prcResult->left = prcDesired->left;
        prcResult->top  = prcDesired->top;

        // Calculate some sizes needed for calculation
        info.rcAvail.left   = prcExclude->left - rcMonitor.left;
        info.rcAvail.right  = rcMonitor.right - prcExclude->right;
        info.rcAvail.top    = prcExclude->top - rcMonitor.top;
        info.rcAvail.bottom = rcMonitor.bottom - prcExclude->bottom;

        info.sizeAdjust = *psizeAdjust;
    
        info.cyMonitor = RECTHEIGHT(rcMonitor); 
        info.cxMonitor = RECTWIDTH(rcMonitor);

        info.cx  = RECTWIDTH(*prcDesired);
        info.cy = RECTHEIGHT(*prcDesired);

        // If the desired rect is bigger than monitor then clip it to the monitor size
        if (info.cy > info.cyMonitor)
            info.cy = info.cyMonitor;

        if (info.cx > info.cxMonitor)
            info.cx = info.cxMonitor;

        info.prcResult = prcResult;
        info.prcExclude = prcExclude;
        info.prcMonitor = &rcMonitor;

        //Now Adjust the rectangle for the correct position
        switch(uSide)
        {
        int iSide;

        case MENUBAR_TOP:
    
            if (WillFit(&info, TOP, FALSE))
            {
                _uSide = MENUBAR_TOP;
            }
            else 
            {
                // We couldn't fit it above, how badly did we fall short?
                cyExtendDiff = info.cyExtendDiff;
                if (WillFit(&info, BOTTOM, FALSE))
                    _uSide = MENUBAR_BOTTOM;
                // We can't fit it below either, which dir was closest?
                // If they are equal, default to requested direction
                else if (info.cyExtendDiff < cyExtendDiff)
                {
                    _uSide = MENUBAR_BOTTOM;
                    WillFit(&info, BOTTOM, TRUE);
                }
                else
                {
                    _uSide = MENUBAR_TOP;
                    WillFit(&info, TOP, TRUE);
                }
            }
            break;

        case MENUBAR_BOTTOM:
    
            if (WillFit(&info, BOTTOM, FALSE))
            {
                _uSide = MENUBAR_BOTTOM;
            }
            else
            {   
                // We couldn't fit it below, how badly did we fall short?
                cyExtendDiff = info.cyExtendDiff;
                if (WillFit(&info, TOP, FALSE))
                    _uSide = MENUBAR_TOP;

                // We can't fit it above either, which dir was closest?
                // If they are equal, default to requested direction
                else if (info.cyExtendDiff < cyExtendDiff)
                {
                    _uSide = MENUBAR_TOP;
                    WillFit(&info, TOP, TRUE);
                }
                else
                {
                    _uSide = MENUBAR_BOTTOM;
                    WillFit(&info, BOTTOM, TRUE);
                }
            }
            break;

        case MENUBAR_LEFT:

            if (WillFit(&info, LEFT, FALSE))
            {
                _uSide = MENUBAR_LEFT;
            }
            else if (WillFit(&info, RIGHT, FALSE))
            {
                _uSide = MENUBAR_RIGHT;
            }
            else
            {
                // fit where have most room and can show most of menu.

                if ((info.cx - (info.prcExclude)->right) > (info.prcExclude)->left)
                {
                    _uSide = MENUBAR_RIGHT;
                    iSide = RIGHT;
                }
                else
                {
                    _uSide = MENUBAR_LEFT;
                    iSide = LEFT;
                }
                WillFit(&info, iSide, TRUE);
            }
            break;

        case MENUBAR_RIGHT:

            if (WillFit(&info, RIGHT, FALSE))
            {
                _uSide = MENUBAR_RIGHT;
            }
            else if (WillFit(&info, LEFT, FALSE))
            {
                _uSide = MENUBAR_LEFT;
            }
            else
            {
                // fit where have most room and can show most of menu.

                if ((info.cx - (info.prcExclude)->right) >= (info.prcExclude)->left)
                {
                    _uSide = MENUBAR_RIGHT;
                    iSide = RIGHT;
                }
                else
                {
                    _uSide = MENUBAR_LEFT;
                    iSide = LEFT;
                }
                WillFit(&info, iSide, TRUE);
            }
            break;
        }
    
        // Finally set the bottom and right

        if (prcResult->top < rcMonitor.top)
            prcResult->top = rcMonitor.top;
        if (prcResult->left < rcMonitor.left)
            prcResult->left = rcMonitor.left;

        prcResult->bottom = prcResult->top  + info.cy;
        prcResult->right  = prcResult->left + info.cx;

        if (prcResult->bottom > rcMonitor.bottom)
        {
            // -2 for some breathing room at the edge of the screen
            prcResult->bottom = rcMonitor.bottom - 2;
            prcResult->top = prcResult->bottom - info.cy;
        }
    }
}

HRESULT CMenuDeskBar::_PositionWindow(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags)
{
    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));

    BOOL bSetFocus = (dwFlags & MPPF_SETFOCUS);
    RECT rcDesired;
    RECT rcExclude;
    RECT rc;
    SIZE sizeAdjust;
    UINT uAnimateSide;

    BOOL bMirroredWindow=IS_WINDOW_RTL_MIRRORED(_hwnd);

    static const iPosition[] = {MENUBAR_TOP, MENUBAR_LEFT, MENUBAR_RIGHT, MENUBAR_BOTTOM};

    if (dwFlags & MPPF_POS_MASK)
    {
        UINT uPosIndex = ((dwFlags & MPPF_POS_MASK) >> 29) - 1;
        ASSERT(uPosIndex < 4);
        _uSide = iPosition[uPosIndex];
    }

    if (bSetFocus)
        SetForegroundWindow(_hwnd);
    
    _pt = *(POINT*)ppt;

    // Get the size of the ideal client rect of the child
    RECT rcChild = {0};

    // (scotth): This only sets the bottom and the right values
    _pDBC->GetSize(DBC_GS_IDEAL, &rcChild);

    DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    DWORD dwExStyle = GetWindowLong(_hwnd, GWL_EXSTYLE);

    // Adjust for the window border style
    rcDesired = rcChild;        // use rcDesired as a temp variable
    if (!_fNoBorder)
    {
        AdjustWindowRectEx(&rcChild, dwStyle, FALSE, dwExStyle);
    }

    // Calculate the edge of the menu border, and add a fudge factor so
    // left/right-cascaded menus overlap the parent menu a bit and are
    // correctly aligned vertically.

    sizeAdjust.cx = (RECTWIDTH(rcChild) - RECTWIDTH(rcDesired)) / 2;
    sizeAdjust.cy = (RECTHEIGHT(rcChild) - RECTHEIGHT(rcDesired)) / 2;

    if (prcExclude)
    {
        CopyRect(&rcExclude, (RECT*)prcExclude);

        //
        // If mirroring is enabled, let's mirror this guy
        // by simulating a different mirrored rect. This is
        // only for dropdown menus. [samera]
        //  
        if (bMirroredWindow)           
        {
            if ((_uSide != MENUBAR_LEFT)    &&
                (_uSide != MENUBAR_RIGHT) )
            {  
                int x;
                int iW  = rcExclude.right-rcExclude.left;
                int icW = (rcChild.right-rcChild.left);


                if( icW > iW )
                {
                    x = icW - iW;
                    rcExclude.left  -= x ;
                    rcExclude.right -= x ;
                }
                else
                {
                    x = iW - icW;
                    rcExclude.left  += x;
                    rcExclude.right += x;
                }

                ppt->x = rcExclude.left;
            }

        }

        TraceMsg(DM_POPUP, "Parent Side is %d ", _uSide);
        switch(_uSide) 
        {
        case MENUBAR_LEFT :
            rcDesired.left = rcExclude.left - rcChild.right;  // right is width
            rcDesired.top  = rcExclude.top;
            break;

        case MENUBAR_RIGHT :
            rcDesired.left = rcExclude.right;
            rcDesired.top  = rcExclude.top;
            break;
            
        case MENUBAR_TOP:
            rcDesired.left = rcExclude.left;
            rcDesired.top  = rcExclude.top - rcChild.bottom;  // bottom is height
            break;

        case MENUBAR_BOTTOM:
            rcDesired.left = rcExclude.left;
            rcDesired.top  = rcExclude.bottom;
            break;

        default:
            rcDesired.left   = _pt.x;
            rcDesired.top    = _pt.y;
        }
    }
    else
    {
        SetRectEmpty(&rcExclude);

        rcDesired.left   = _pt.x;
        rcDesired.top    = _pt.y;
    }

    rcDesired.right  =  rcDesired.left + RECTWIDTH(rcChild);
    rcDesired.bottom =  rcDesired.top + RECTHEIGHT(rcChild);

    _GetPopupWindowPosition(&rcDesired, &rcExclude, &rc, &sizeAdjust, _uSide);

    UINT uFlags = SWP_NOOWNERZORDER;
    if (!bSetFocus)
        uFlags |= SWP_NOACTIVATE;

    //
    // Open the menus properly. In case of a RTL mirrored window,
    // flip the animation side. [samera]
    //
    if( bMirroredWindow )
    {
        switch( _uSide )
        {
        case MENUBAR_LEFT:
            uAnimateSide = MENUBAR_RIGHT;
        break;
        case MENUBAR_RIGHT:
            uAnimateSide = MENUBAR_LEFT;
        break;
        default:
            uAnimateSide = _uSide;
        }
    }
    else
    {
        uAnimateSide = _uSide;
    }

    TraceMsg(TF_MENUBAND, "CMenuBar::_PositionWindow (%d,%d,%d,%d)",
        rc.left, rc.top, rc.right, rc.bottom);

    // Last minuite tweak. Since we're in large icon, we need to add this
    // so that the bitmap is painted correctly.
    if(_iIconSize == BMICON_LARGE && _fExpanded)
        rc.right += 1;

    // We _DO_ want to do a Z-Order position when this flag is specified. This is
    // for full repositioning where we need to preserve the overlap state of all bands.
    // Otherwize we just want to size the bar without changing it's z-order.
    if (!(dwFlags & MPPF_FORCEZORDER) && 
        (S_OK == IUnknown_QueryServiceExec(_punkChild, SID_SMenuBandChild,
         &CGID_MenuBand, MBANDCID_ISINSUBMENU, 0, NULL, NULL)))
    {
        uFlags |= SWP_NOZORDER;
    }

    // If it's bigger than this magical number, then we don't animate. change to taste
  
    if (RECTHEIGHT(rc) > MAGICAL_NO_FADE_HEIGHT)
        dwFlags |= MPPF_NOANIMATE;

    AnimateSetMenuPos(_hwnd, &rc, uFlags, uAnimateSide, dwFlags & MPPF_NOANIMATE);

    // Save information so we can later resize this window
    // We already have: _pt, _uSide
    if (prcExclude)
    {
        _fExcludeRect = TRUE;
        CopyRect(&_rcExclude, (RECT*)prcExclude);
    }
    else
        _fExcludeRect = FALSE;
    return S_OK;
} 

/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

*/
STDMETHODIMP CMenuDeskBar::Popup(POINTL* ppt, RECTL* prcExclude, DWORD dwFlags)
{
    HRESULT hr;

    // Is the caller telling us to reposition?
    if (dwFlags & MPPF_REPOSITION)
    {
        if (ppt == NULL)
            ppt = (POINTL*)&_pt;

        if (prcExclude == NULL)
            prcExclude = (RECTL*)&_rcExclude;

        // Yes; Then we don't need to do any First show stuff.
        _PositionWindow(ppt, prcExclude, dwFlags);
        return S_OK;
    }

    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));



    if (g_dwProfileCAP & 0x00002000) 
        StartCAP();

    if (g_dwStopWatchMode)
        StopWatch_Start(SWID_MENU, TEXT("Menu Start"), SPMODE_SHELL | SPMODE_DEBUGOUT);
    
    if (_pmpParent) 
    {
        _pmpParent->SetSubMenu(this, TRUE);
    }

    IOleCommandTarget* poct;
    hr = IUnknown_QueryService(_punkChild, SID_SMenuBandChild, IID_PPV_ARG(IOleCommandTarget, &poct));

    if (SUCCEEDED(hr))
    {
        // We need to do this before the ShowDW. This saves us from doing the setting twice
        // Because in the ShowDW of MenuBand, we actually go an initialize the toolbar with
        // the current default setting which should be "No Keyboard Cues." If we set the state
        // here, then the state will be "Show keyboard cues." Then we will update the toolbar. 
        if (dwFlags & MPPF_KEYBOARD)
            poct->Exec(&CGID_MenuBand, MBANDCID_KEYBOARD, 0, NULL, NULL);
    }
    else
    {
        ASSERT(poct == NULL);
    }
    
    _NotifyModeChange(_dwMode);
    hr = ShowDW(TRUE);

    if (SUCCEEDED(hr) && _pmpParent)
    {
        VARIANT varg;
        // If this Exec fails, don't panic; it just means we use the default side
        if (SUCCEEDED(IUnknown_Exec(_pmpParent, &CGID_MENUDESKBAR, MBCID_GETSIDE, 0, NULL, &varg)))
        {
            if (varg.vt == VT_I4)
            {
                _uSide = (UINT) varg.lVal;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        IEPlaySound(TEXT("MenuPopup"), TRUE);

        _PositionWindow(ppt, prcExclude, dwFlags);

        // Set focus
        UIActivateIO(TRUE, NULL);
    
        _fActive = TRUE;

        // Select the first/last item?
        if ((dwFlags & (MPPF_INITIALSELECT | MPPF_FINALSELECT)) && poct)
        {
            DWORD nCmd = (dwFlags & MPPF_INITIALSELECT) ? MBSI_FIRSTITEM : MBSI_LASTITEM;
            poct->Exec(&CGID_MenuBand, MBANDCID_SELECTITEM, nCmd, NULL, NULL);
        }
    }

    ATOMICRELEASE(poct);
    
    if (g_dwStopWatchMode)
    {
        TCHAR szMenu[32];
        TCHAR szText[256];

        *szMenu = '\0';
        if(g_hmenuStopWatch != NULL)
            GetMenuString(g_hmenuStopWatch, 0, szMenu, ARRAYSIZE(szMenu)-1, MF_BYPOSITION);

        wnsprintf(szText, ARRAYSIZE(szText) - 1, TEXT("Menu %d %s%sStop"), g_idCmdStopWatch, szMenu, *szMenu ?TEXT(" ") :TEXT(""));
        StopWatch_Stop(SWID_MENU, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
    }

    if (g_dwProfileCAP & 0x00002000) 
        StopCAP();
        
    return hr;
} 


/*----------------------------------------------------------
Purpose: IInputObjectSite::OnFocusChangeIS

Returns: 
Cond:    --
*/
HRESULT CMenuDeskBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

*/
STDMETHODIMP CMenuDeskBar::SetSite(IUnknown* punkSite)
{
    ASSERT(NULL == punkSite || IS_VALID_CODE_PTR(punkSite, IUnknown));

    if (_fShow)
        _PopDown();

    ATOMICRELEASE(_punkSite);
    ATOMICRELEASE(_pmpParent);
    
    _punkSite = punkSite;
    
    if (_punkSite)
    {    
        _punkSite->AddRef();
        IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &_pmpParent));
    }
    else
    {
        CloseDW(0);
    }
        
    return S_OK;
} 


/*----------------------------------------------------------
Purpose: IObjectWithSite::GetSite method

*/
STDMETHODIMP CMenuDeskBar::GetSite(REFIID riid, LPVOID* ppvSite)
{
    if (_punkSite)
    {
        return _punkSite->QueryInterface(riid, ppvSite);
    }

    *ppvSite = NULL;
    return E_FAIL;
} 

void CMenuDeskBar::AdjustForTheme()
{
    if (_fFlatMenuMode)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, WS_CLIPCHILDREN | WS_DLGFRAME | WS_BORDER, WS_BORDER);
    }
    else if (!_fExpanded)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, WS_CLIPCHILDREN | WS_DLGFRAME | WS_BORDER, WS_CLIPCHILDREN | WS_DLGFRAME);
    }
}


/*----------------------------------------------------------
Purpose: IOleCommandTarget::Exec method

*/
STDMETHODIMP CMenuDeskBar::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        
    } 
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBCID_EMPTY:
            // if we have no bands left, close
            OnSelect(MPOS_FULLCANCEL);
            return S_OK;

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    else if (IsEqualGUID(CGID_MENUDESKBAR, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
            case MBCID_GETSIDE :
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _GetSide();
                return S_OK;

            case MBCID_RESIZE:
                if (_fActive)
                {
                    if (_fExcludeRect)
                        _PositionWindow((POINTL *)&_pt, (RECTL *)&_rcExclude, 0);
                    else
                        _PositionWindow((POINTL *)&_pt, NULL, 0);
                }
                return S_OK;

            case MBCID_SETEXPAND:
                if ((BOOL)_fExpanded != (BOOL)nCmdexecopt && !_fFlatMenuMode)
                {
                    _fExpanded = nCmdexecopt;

                    SetExpandedBorder(_hwnd, _fExpanded);
                }
                return S_OK;

            case MBCID_SETFLAT:
                {
                    _fFlatMenuMode = BOOLIFY(nCmdexecopt);
                    AdjustForTheme();
                }
                break;

            case MBCID_NOBORDER:
                {
                    _fNoBorder = BOOLIFY(nCmdexecopt);
                    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
                }
                break;

            default : 
                return OLECMDERR_E_NOTSUPPORTED;

        }   
    }
    
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}    

    
/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SMenuPopup)) 
    {
        return QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
             IsEqualIID(guidService, SID_SMenuBandBottomSelected)||
             IsEqualIID(guidService, SID_SMenuBandChild))
    {
        // SID_SMenuBandBottom queries down
        return IUnknown_QueryService(_punkChild, guidService, riid, ppvObj);
    }
    else
    {
        HRESULT hres = SUPERCLASS::QueryService(guidService, riid, ppvObj);
        
        if (FAILED(hres))
        {
            hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
        }
        
        return hres;
    }
        
} 

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::SetIconSize(DWORD iIcon)
{
    HRESULT hres;

    _iIconSize = iIcon;

    hres = IUnknown_QueryServiceExec(_punkChild, SID_SMenuBandChild, &CGID_MenuBand, 
        MBANDCID_SETICONSIZE, iIcon == BMICON_SMALL? ISFBVIEWMODE_SMALLICONS: ISFBVIEWMODE_LARGEICONS, NULL, NULL);


    return hres;
}

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::SetBitmap(HBITMAP hBitmap)
{
    ASSERT(hBitmap);
    BITMAP bm;
    _hbmp = hBitmap;

    if (_hbmp)
    {
        if(!GetObject(_hbmp, sizeof(bm), &bm))
            return E_FAIL;
        _sizeBmp.cx = bm.bmWidth;
        _sizeBmp.cy = bm.bmHeight;

        // Hack to get color
        HDC hdc = GetDC(_hwnd);
        if (hdc)
        {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMem, _hbmp);
                _rgb = GetPixel(hdcMem, 0, 0);
                SelectObject(hdcMem, hbmpOld);
                DeleteDC(hdcMem);
            }
            ReleaseDC(_hwnd, hdc);
        }
    }

    return NOERROR;
}

void CMenuDeskBar::_OnSize()
{
    RECT rc;

    if (!_hwndChild)
        return;

    GetClientRect(_hwnd, &rc);

    if(_iIconSize == BMICON_LARGE)
    {
        rc.left += _sizeBmp.cx;
        if (_fExpanded)
            rc.left++;
    }

    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER|SWP_FRAMECHANGED);

    rc.right = rc.left;
    rc.left -= _sizeBmp.cx;
    if (_fShow)
        InvalidateRect(_hwnd, &rc, TRUE);
}

LRESULT CMenuDeskBar::_DoPaint(HWND hwnd, HDC hdc, DWORD dwFlags)
{
    HDC hdcmem;
    HBITMAP hbmpOld;
    RECT rc;
    HBRUSH   hbrush;
    int iDC = SaveDC(hdc);

    GetClientRect(hwnd, &rc);

    //Create a compatable DC
    hdcmem = CreateCompatibleDC(hdc);
    if(hdcmem)
    {
        // Offset the stuff we're paining if we're expanded
        BYTE bOffset = 0;
        // Store this for the Bar fill cycle
        int cyBitmap = 0;

        if (!_fFlatMenuMode)
        {
            bOffset = _fExpanded? 1 : 0;
        }

        if (_sizeBmp.cy <= RECTHEIGHT(rc) + 1)
        {
            //Select the bitmap into the memory DC
            hbmpOld = (HBITMAP)SelectObject(hdcmem, _hbmp);

            //Blit to the window
            BitBlt(hdc, bOffset, rc.bottom - _sizeBmp.cy - bOffset, _sizeBmp.cx, _sizeBmp.cy, hdcmem, 0, 0, SRCCOPY);

            // Ok, We need to subtract this value to see how much we need to paint for the banner.
            cyBitmap = _sizeBmp.cy;

            //Restore the DC
            SelectObject(hdcmem, hbmpOld);
        }

        rc.right = _sizeBmp.cx + bOffset;

        if (_fExpanded && !_fFlatMenuMode && !_fNoBorder)
            DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_LEFT | BF_TOP | BF_BOTTOM);

        //Paint the rest
        hbrush = CreateSolidBrush(_rgb);
        if(hbrush)
        {
            rc.bottom -= cyBitmap + bOffset;

            if (_fExpanded)
            {
                rc.left += bOffset;
                rc.top += bOffset;
            }

            FillRect(hdc, &rc, hbrush);
            DeleteObject(hbrush);
        }


        //Delete the DC.
        DeleteDC(hdcmem);
    }

    RestoreDC(hdc, iDC);
    return 0;
}

void CMenuDeskBar::_DoNCPaint(HWND hwnd, HDC hdc)
{
    if (!_fNoBorder)
    {
        RECT rc;

        // Since we need to paint the border, we get the window rect
        GetWindowRect(hwnd, &rc);
        // then change the rect so that it represents values relative to 
        // the origin.
        OffsetRect(&rc, -rc.left, -rc.top);

        if (hdc)
        {
            if (_fFlatMenuMode)
            {
                SHOutlineRect(hdc, &rc, GetSysColor(COLOR_3DSHADOW));
            }
            else 
                DrawEdge(hdc, &rc, BDR_RAISEDOUTER, BF_RECT);
        }
    }
}


LRESULT CMenuDeskBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    
    LRESULT lres;

    switch (uMsg) 
    {
#ifdef MAINWIN
    case WM_NCPAINTSPECIALFRAME:
        // In  case  of  motif look  the  MwPaintBorder paints a Etched In
        // border if WM_NCPAINTSPECIALFRAME returns FALSE. We are handling
        // this message here and drawing the Etched Out frame explicitly.
        // wParam - HDC
        if (MwCurrentLook() == LOOK_MOTIF)
        {
            MwPaintSpecialEOBorder( hwnd, (HDC)wParam );
            return TRUE;
        }
        break;
#endif

    case WM_GETOBJECT:
        if (lParam == OBJID_MENU)
        {
            IAccessible* pacc;
            if (SUCCEEDED(QueryService(SID_SMenuBandChild, IID_PPV_ARG(IAccessible, &pacc))))
            {
                lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(pacc, IAccessible*));
                pacc->Release();

                return lres;
            }
        }
        break;


    case WM_NCCREATE:
        //
        // Since this is a mirrored menu, then open it
        // on the left (mirrored) edge if possible. WillFit(...) will
        // ensure this for us [samera]
        //
        // Mirror the menu initially if its window is mirrored
        //
        ASSERT(_uSide == 0);
        if (IS_WINDOW_RTL_MIRRORED(_hwnd))
            _uSide = MENUBAR_LEFT;
        else
            _uSide = MENUBAR_RIGHT;
        break;

    case WM_ACTIVATE:
        if (LOWORD(wParam) == WA_INACTIVE) 
        {
            if (_fActive && !_pmpChild) 
            {
                
                // if we were active, and the thing going active now
                // is not one of our parent menubars, then cancel everything.
                
                // if it's a parent of ours going active, assume that
                // they will tell us to die when they want us to...
                if (!_IsMyParent((HWND)lParam))
                    OnSelect(MPOS_FULLCANCEL);
            }
        } 
        else 
        {
            if (_pmpChild) 
            {
                // if we're becoming active, and we have a child, that child should go away
                _pmpChild->OnSelect(MPOS_CANCELLEVEL);
            }
        }
        break;

    case WM_PRINTCLIENT:
        if (_iIconSize == BMICON_LARGE)
        {
            _DoPaint(hwnd, (HDC)wParam, (DWORD)lParam);
            return 0;
        }
        break;

    case WM_PAINT:
        // Paint the banner if we're in showing large icons
        if (_iIconSize == BMICON_LARGE)
        {
            PAINTSTRUCT ps;
            BeginPaint(hwnd, &ps);
            _DoPaint(hwnd, ps.hdc, 0);
            EndPaint(hwnd, &ps);
            return 0;
        }
        break;

   case WM_PRINT:
        if ((_fFlatMenuMode || _fExpanded) && PRF_NONCLIENT & lParam)
        {
            HDC hdc = (HDC)wParam;

            DefWindowProcWrap(hwnd, WM_PRINT, wParam, lParam);

            // Do this after so that we look right...
            _DoNCPaint(hwnd, hdc);

            return 1;
        }
        break;

    case WM_NCCALCSIZE:
        if (_fNoBorder)
        {
            return 0;
        }
        else
        {
            return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
        }
        break;

    case WM_NCPAINT:
        if (_fNoBorder)
        {
            return 0;
        }
        else if (_fExpanded || _fFlatMenuMode)
        {    
            HDC hdc;    
            hdc = GetWindowDC(hwnd);
            if (hdc)
            {
                _DoNCPaint(hwnd, hdc);
                ReleaseDC(hwnd, hdc);
            }
            return 1;
        } 
        break;

    case WM_NCHITTEST:
        lres = SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);

        switch (lres)
        {
        case HTBOTTOM:
        case HTBOTTOMLEFT:
        case HTBOTTOMRIGHT:
        case HTLEFT:
        case HTRIGHT:
        case HTTOP:
        case HTTOPLEFT:
        case HTTOPRIGHT:
            // Don't allow the window to be resized
            lres = HTBORDER;
            break;

        case HTTRANSPARENT:
            // Don't let a click go thru to the window underneath
            lres = HTCLIENT;
            break;

        }
        return lres;

        // HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
        // (lamadio) 1.25.99
        // This hack is here to fix a problem on down level Windows with Integrated
        // IE4.01, IE5 and Office 2000.
        // The bug revolves around Start Menu not being destroyed when Explorer.exe shuts
        // down. Start Menu unregisters itself at CloseDW, but since the menubar never gets
        // destroyed, Start Menu never deregisters itself.
        // When an System service, such as MSTASK.dll keeps shell32 alive in the background,
        // it leaves an outstanding reference to a change notify. When a new user logs in,
        // O2k and IE5 fire up group conv, generating more than 10 change notify events in the
        // start menu. This causes the batching code to be fired up: Which does not really
        // work without the shell started. GroupConv also adds these events using memory 
        // alloced from it's process heap. Since there is an outstanding change notify handler
        // these pidls get forced to be handled. Shell32 then faults derefing a bad pidl.
        // By detecting an Endsession, we can eliminate this problem. Doing a SetClient(NULL)
        // cause Menubar to free it's references to MenuSite. Menusite, calls CloseDW on menuband
        // menuband then causes MNFolder to unregister itself. Since no one is listening any more
        // the crash is avoided.

    case WM_ENDSESSION:
        if (wParam != 0)
        {
            SetClient(NULL);
        }
        break;

    }
    
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
} 

IMenuPopup* CMenuDeskBar::_GetMenuBarParent(IUnknown* punk)
{
    IMenuPopup *pmp = NULL;
    IObjectWithSite* pows;
    punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));

    if (pows)
    {    
        IServiceProvider* psp;
        pows->GetSite(IID_PPV_ARG(IServiceProvider, &psp));
        
        if (psp)
        {    
            psp->QueryService(SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmp));
            psp->Release();
        }
        
        pows->Release();
    }
    
    return pmp;
}


// this assumes that hwnd is a toplevel window and that the menudeskbars are also 
// the only hosts and are themselves toplevel
BOOL CMenuDeskBar::_IsMyParent(HWND hwnd)
{
    BOOL fRet = FALSE;
    if (hwnd)
    {
        HWND hwndMenu;
        
        IMenuPopup *pmpParent = _pmpParent;
        if (pmpParent)
            pmpParent->AddRef();
        
        while (pmpParent && !fRet &&
               SUCCEEDED(IUnknown_GetWindow(pmpParent, &hwndMenu)))
        {
            if (hwndMenu == hwnd)
            {
                fRet = TRUE;
            }
            
            IMenuPopup* pmpNext = _GetMenuBarParent(pmpParent);
            pmpParent->Release();
            pmpParent = pmpNext;
        }
    }

    return fRet;
}

IMenuPopup* CreateMenuPopup(IMenuPopup* pmpParent, IShellFolder* psf, LPCITEMIDLIST pidl, 
                            BANDINFOSFB * pbi, BOOL bMenuBand)
{
    return CreateMenuPopup2(pmpParent, NULL, psf, pidl, pbi, bMenuBand);
}

IMenuPopup* CreateMenuPopup2(IMenuPopup* pmpParent, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, 
                            BANDINFOSFB * pbi, BOOL bMenuBand)
{
    
    ASSERT(pmb == NULL || IS_VALID_CODE_PTR(pmb, IMenuBand));
    ASSERT(psf == NULL || IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(pmpParent == NULL || IS_VALID_CODE_PTR(pmpParent, IMenuPopup));
    ASSERT(pidl && IS_VALID_PIDL(pidl));
    ASSERT(pbi == NULL || IS_VALID_READ_PTR(pbi, BANDINFOSFB));

    IMenuPopup* pmp = NULL;
    IDeskBand *pdb = NULL;
    IBandSite *pbs = NULL;
    HRESULT hres = E_FAIL;

    if (!pdb) 
    {
        TraceMsg(TF_MENUBAND, "CreateMenuPopup2 : Did not find a this (0x%x) band.", pidl);

        if (bMenuBand)
        {
            pdb = CMenuBand_Create(psf, pidl, FALSE);
        }
        else
            pdb = CISFBand_CreateEx(psf, pidl);

        if (pdb) 
        {
            if (pbi) 
            {
                IShellFolderBand *pisfBand;
                if (SUCCEEDED(pdb->QueryInterface(IID_IShellFolderBand, (LPVOID*)&pisfBand))) 
                {
                    pisfBand->SetBandInfoSFB(pbi);
                    pisfBand->Release();
                }
            }

            if (!pmpParent) 
            {
                const CLSID * pclsid;

                if (bMenuBand)
                    pclsid = &CLSID_MenuBandSite;
                else
                    pclsid = &CLSID_RebarBandSite;

                CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER, IID_IBandSite, (LPVOID*)&pbs);

                if (pbs) 
                {

                    if (bMenuBand)
                    {
                        BANDSITEINFO bsinfo;

                        // Don't show the gripper for vertical menubands
                        bsinfo.dwMask = BSIM_STYLE;
                        bsinfo.dwStyle = BSIS_NOGRIPPER | BSIS_NODROPTARGET;
                        pbs->SetBandSiteInfo(&bsinfo);
                    }

                    CMenuDeskBar *pcmdb = new CMenuDeskBar();
                    if (pcmdb)
                    {
                        if (SUCCEEDED(pcmdb->SetClient(pbs))) 
                            pcmdb->QueryInterface(IID_IMenuPopup, (LPVOID *)&pmp);

                        pcmdb->Release();
                    }
                }
            }

            if (pbs) 
            {
                pbs->AddBand(pdb);
            }
        }
    }
    
    ATOMICRELEASE(pdb);
    ATOMICRELEASE(pbs);
    if (!pmp)
        IUnknown_Set((IUnknown**) &pmp, pmpParent);
    

    return pmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\mnbandid.h ===
#define ISFBIDM_LARGE           0x0001
#define ISFBIDM_SMALL           0x0002
#define ISFBIDM_LOGOS           0x0003
#define ISFBIDM_SHOWTEXT        0x0004
#define ISFBIDM_REFRESH         0x0005
#define ISFBIDM_OPEN            0x0006

#define MENU_ISFBAND            0x102
#define MENU_MNFOLDERCONTEXT    0x10D

// mnfolder context menu commands
#define MNIDM_RESORT            0x0001
#define MNIDM_LAST              0x0001

#define IDS_QLINKS              0x3061
#define IDS_EMPTY               0x3251
#define IDS_FAVS_ADDTOFAVORITES 0x3297
#define IDS_FAVS_INVALIDFN      0x329C
#define IDS_LINKSBANDTEXT       0x3352

#define DLG_ISFBANDRENAME       0x102
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\menuisf.h ===
#ifndef _MENUISF_H
#define _MENUISF_H

#include "iface.h"
#include "caggunk.h"
#include "menubar.h"


//  Object that uses TrackPopupMenu as its implementation for IMenuPopup.
//

class CTrackPopupBar : public CMenuDeskBar
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef) () ;
    STDMETHOD_(ULONG,Release) ();

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd) { return E_NOTIMPL; }
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode) { return E_NOTIMPL; }

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
    
    CTrackPopupBar(void* pvContext, int id, HMENU hmenu, HWND hwnd);
    ~CTrackPopupBar();
    
    HMENU GetPopupMenu() { return GetSubMenu(_hmenu, _id); };
    void SelectFirstItem();
    
protected:
    int     _id;
    HMENU   _hmenu;
    HWND    _hwndParent;
    void*   _pvContext;
    
    // Popup message to indicate - "Ignore next MENUSELECT clear msg"
    UINT _nMBIgnoreNextDeselect;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\menusite.h ===
#ifndef _MENUSITE_H_
#define _MENUSITE_H_

//#define WANT_CBANDSITE_CLASS

//#include "bandsite.h"
#include "cwndproc.h"

// MenuSite will never have more than one client.


class CMenuSite : public IBandSite,
                  public IDeskBarClient,
                  public IOleCommandTarget,
                  public IInputObject,
                  public IInputObjectSite,
                  public IWinEventHandler,
                  public IServiceProvider,
                  public CImpWndProc
{

public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IDeskBarClient methods ***
    virtual STDMETHODIMP SetDeskBarSite(IUnknown* punkSite);
    virtual STDMETHODIMP SetModeDBC(DWORD dwMode);
    virtual STDMETHODIMP UIActivateDBC(DWORD dwState);
    virtual STDMETHODIMP GetSize(DWORD dwWhich, LPRECT prc);

    // *** IWinEventHandler Methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IBandSite ***
    virtual STDMETHODIMP AddBand(IUnknown* punk);
    virtual STDMETHODIMP EnumBands(UINT uBand, DWORD* pdwBandID);
    virtual STDMETHODIMP QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName);
    virtual STDMETHODIMP SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState);
    virtual STDMETHODIMP RemoveBand(DWORD dwBandID);
    virtual STDMETHODIMP GetBandObject(DWORD dwBandID, REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP SetBandSiteInfo(const BANDSITEINFO * pbsinfo);
    virtual STDMETHODIMP GetBandSiteInfo(BANDSITEINFO * pbsinfo);


    CMenuSite();
    
protected:
    virtual ~CMenuSite();
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _CreateSite(HWND hwndParent);
    void _CacheSubActiveBand(IUnknown * punk);


    IUnknown*   _punkSite;
    IUnknown*   _punkSubActive;
    IDeskBand*  _pdb;
    IWinEventHandler*   _pweh;
    HWND        _hwndChild;

    int         _cRef;    

    friend HRESULT CMenuBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
};

#endif  // _MENUSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\menusite.cpp ===
#include "priv.h"
#include "sccls.h"
#include "menusite.h"

CMenuSite::CMenuSite() : _cRef(1)
{
}


CMenuSite::~CMenuSite()
{
    // Make sure that SetDeskBarSite(NULL) was called
    ASSERT(_punkSite == NULL);
    ASSERT(_punkSubActive == NULL);
    ASSERT(_pweh == NULL);
    ASSERT(_pdb == NULL);
    ASSERT(_hwnd == NULL);
}


STDAPI CMenuBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CMenuSite *pbs = new CMenuSite();
    if (pbs)
    {
        *ppunk = SAFECAST(pbs, IOleWindow*);
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}


/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CMenuSite::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMenuSite, IBandSite),
        QITABENT(CMenuSite, IDeskBarClient),
        QITABENT(CMenuSite, IOleCommandTarget),
        QITABENT(CMenuSite, IInputObject),
        QITABENT(CMenuSite, IInputObjectSite),
        QITABENT(CMenuSite, IWinEventHandler),
        QITABENT(CMenuSite, IServiceProvider),
        QITABENT(CMenuSite, IOleWindow),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CMenuSite::AddRef(void)
{
    _cRef++;
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CMenuSite::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;

    *ppvObj = NULL;     // assume error

    if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
        IsEqualIID(guidService, SID_SMenuBandBottomSelected)||
        IsEqualIID(guidService, SID_SMenuBandChild))
    {
        if (_punkSubActive)
            hres = IUnknown_QueryService(_punkSubActive, guidService, riid, ppvObj);
    }
    else
    {
        ASSERT(_punkSite);
        hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: IOleCommandTarget::QueryStatus

*/
STDMETHODIMP CMenuSite::QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    ASSERT(_punkSite);

    return IUnknown_QueryStatus(_punkSite, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

/*----------------------------------------------------------
Purpose: IOleCommandTarget::Exec

*/
STDMETHODIMP CMenuSite::Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    ASSERT(_punkSite);

    return IUnknown_Exec(_punkSite, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}


/*----------------------------------------------------------
Purpose: IInputObjectSite::OnFocusChangeIS

         This function is called by the client band to negotiate
         which band in this bandsite gets the focus.  Typically
         this function will then change its focus to the given
         client band.

         CMenuSite only maintains one and only one band, which
         is set at AddBand time, so this function is a nop.

*/
STDMETHODIMP CMenuSite::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    // Return S_OK since the menu site only ever has one band.
    // No need to negotiate which other band in this bandsite 
    // might have the "activation".
    return S_OK;
}


/*----------------------------------------------------------
Purpose: IInputObject::UIActivateIO method

*/
STDMETHODIMP CMenuSite::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    // Forward onto the client band
    return IUnknown_UIActivateIO(_punkSubActive, fActivate, lpMsg);
}


/*----------------------------------------------------------
Purpose: IInputObject::HasFocusIO

         Since the menuband can never have true activation (from
         the browser's perspective) this always returns S_FALSE.

         See comments in CMenuBand::UIActivateIO for more details
         about this.

*/
STDMETHODIMP CMenuSite::HasFocusIO()
{
    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IInputObject::TranslateAcceleratorIO

         Menubands cannot ever have the activation, so this method 
         should never be called.
*/
STDMETHODIMP CMenuSite::TranslateAcceleratorIO(LPMSG lpMsg)
{
    AssertMsg(0, TEXT("Menuband has the activation but it shouldn't!"));

    return S_FALSE;
}


// Utility Functions

void CMenuSite::_CacheSubActiveBand(IUnknown * punk)
{
    if (SHIsSameObject(punk, _punkSubActive))
        return;
    
    IUnknown_SetSite(_punkSubActive, NULL);

    ATOMICRELEASE(_punkSubActive);
    ATOMICRELEASE(_pdb);
    ATOMICRELEASE(_pweh);
    _hwndChild = NULL;

    if (punk != NULL) 
    {
        EVAL(SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IDeskBand, &_pdb))));
        EVAL(SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pweh))));

        IUnknown_SetSite(punk, SAFECAST(this, IOleWindow*));
        IUnknown_GetWindow(punk, &_hwndChild);

        _punkSubActive = punk;
        _punkSubActive->AddRef();
    }
}


/*----------------------------------------------------------
Purpose: IBandSite::AddBand

*/
STDMETHODIMP CMenuSite::AddBand(IUnknown* punk)
{
    _CacheSubActiveBand(punk);

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IBandSite::EnumBands

*/
STDMETHODIMP CMenuSite::EnumBands(UINT uBand, DWORD* pdwBandID)
{
    HRESULT hres = NOERROR;

    // The menusite only holds one band ever
    if (0 == uBand)
        *pdwBandID = 0;
    else
        hres = E_FAIL;

    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::QueryBand

*/
HRESULT CMenuSite::QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName)
{
    HRESULT hres = E_NOINTERFACE;

    ASSERT(dwBandID == 0);
    ASSERT(IS_VALID_WRITE_PTR(ppstb, IDeskBand *));

    if (_punkSubActive && 0 == dwBandID)
    {
        hres = _punkSubActive->QueryInterface(IID_PPV_ARG(IDeskBand, ppstb));
        *pdwState = BSSF_VISIBLE; // Only band....

        if (cchName > 0)
            *pszName = L'\0';
    }
    else
        *ppstb = NULL;

    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandState

*/
HRESULT CMenuSite::SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::RemoveBand

*/
HRESULT CMenuSite::RemoveBand(DWORD dwBandID)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandObject

*/
HRESULT CMenuSite::GetBandObject(DWORD dwBandID, REFIID riid, LPVOID *ppvObj)
{
    HRESULT hres;

    ASSERT(dwBandID == 0);

    if (_punkSubActive && 0 == dwBandID)
        hres = _punkSubActive->QueryInterface(riid, ppvObj);
    else
    {
        *ppvObj = NULL;
        hres = E_NOINTERFACE;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandSiteInfo

*/
HRESULT CMenuSite::SetBandSiteInfo(const BANDSITEINFO * pbsinfo)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandSiteInfo

*/
HRESULT CMenuSite::GetBandSiteInfo(BANDSITEINFO * pbsinfo)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IOleWindow::GetWindow

*/
HRESULT CMenuSite::GetWindow(HWND * lphwnd)
{
    ASSERT(IS_VALID_HANDLE(_hwnd, WND));

    *lphwnd = _hwnd;
    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IOleWindow::ContextSensitiveHelp

*/
HRESULT CMenuSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::SetDeskBarSite

*/
HRESULT CMenuSite::SetDeskBarSite(IUnknown* punkSite)
{
    if (punkSite)
    {
        ATOMICRELEASE(_punkSite);

        HWND hwnd;
        IUnknown_GetWindow(punkSite, &hwnd);

        if (hwnd)
        {
            _CreateSite(hwnd);

            _punkSite = punkSite;
            _punkSite->AddRef();
        }
    }
    else
    {
        if (_pdb)
        {
            _pdb->CloseDW(0);
        }
        _CacheSubActiveBand(NULL);      // This is asymetric by design

        if (_hwnd)
        {
            DestroyWindow(_hwnd);
            _hwnd = NULL;
        }

        ATOMICRELEASE(_punkSite);
    }

    return _hwnd ? NOERROR : E_FAIL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::SetModeDBC

*/
HRESULT CMenuSite::SetModeDBC(DWORD dwMode)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::UIActivateDBC

*/
HRESULT CMenuSite::UIActivateDBC(DWORD dwState)
{
    HRESULT hr = S_OK;

    ASSERT(_pdb);
    if (_pdb)
        hr = _pdb->ShowDW(0 != dwState);

    return hr;
}

/*----------------------------------------------------------
Purpose: IDeskBarClient::GetSize

*/
HRESULT CMenuSite::GetSize(DWORD dwWhich, LPRECT prc)
{
    if (dwWhich == DBC_GS_IDEAL)
    {
        if (_pdb)
        {
            DESKBANDINFO dbi = {0};
            _pdb->GetBandInfo(0, 0, &dbi);
            prc->right = dbi.ptMaxSize.x;
            prc->bottom = dbi.ptMaxSize.y;
        }
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent

*/
HRESULT CMenuSite::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    if (_pweh)
        return _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner

*/
HRESULT CMenuSite::IsWindowOwner(HWND hwnd)
{
    if (_hwnd == hwnd || (_pweh && _pweh->IsWindowOwner(hwnd) != S_FALSE))
        return S_OK;
    else
        return S_FALSE;
}


LRESULT CMenuSite::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    EnterModeless();

    switch(uMsg)
    {
    case WM_SIZE:
        {
            IMenuPopup* pmp;

            if (_punkSubActive && SUCCEEDED(_punkSubActive->QueryInterface(IID_PPV_ARG(IMenuPopup, &pmp))))
            {
                RECT rc = {0};

                GetClientRect(_hwnd, &rc);

                pmp->OnPosRectChangeDB(&rc);
                pmp->Release();
            }
            lres = 1;
        }
        break;

    case WM_NOTIFY:
        hwnd = ((LPNMHDR)lParam)->hwndFrom;
        break;
        
    case WM_COMMAND:
        hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
        
    default:
        ExitModeless();
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
        break;
    }

    if (hwnd && _pweh && _pweh->IsWindowOwner(hwnd) == S_OK) 
    {
        _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, &lres);
    }

    ExitModeless();
    return lres;
}


void CMenuSite::_CreateSite(HWND hwndParent)
{
    if (_hwnd)
    {
        ASSERT(IS_VALID_HANDLE(_hwnd, WND));    // just to be safe...
        return;
    }

    WNDCLASS  wc = {0};
    wc.style            = 0;
    wc.lpfnWndProc      = s_WndProc;
    //wc.cbClsExtra       = 0;
    wc.cbWndExtra       = SIZEOF(CMenuSite*);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_MENU+1);
    //wc.lpszMenuName     =  NULL;
    wc.lpszClassName    = TEXT("MenuSite");
    //wc.hIcon            = NULL;

    SHRegisterClass(&wc);

    _hwnd = CreateWindow(TEXT("MenuSite"), NULL, WS_VISIBLE | WS_CHILD, 0, 0, 0, 0, 
        hwndParent, NULL, HINST_THISDLL, (LPVOID)SAFECAST(this, CImpWndProc*));

    ASSERT(_hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\menuisf.cpp ===
#include "priv.h"
#include "sccls.h"
#include "iface.h"
#include "resource.h"
#include "caggunk.h"
#include "menuisf.h"
#include "menubar.h"
#include "menuband.h"
#include "iaccess.h"
#include "apithk.h"

//=================================================================
// Implementation of CMenuAgent
//
//  The single global object of this class (g_menuagent) is the
//  manager of the message filter proc used to track mouse and
//  keyboard messages on behalf of CTrackPopupBar while a menu is
//  in a modal menu loop in TrackPopupMenu.
//
//  We track these messages so we can pop out of the menu, behaving
//  as if the visual menu bar consisted of a homogeneous menu
//  object.
//
//=================================================================

extern "C" void DumpMsg(LPCTSTR pszLabel, MSG * pmsg);

struct CMenuAgent
{
public:
    HHOOK       _hhookMsg;
    HWND        _hwndSite;          // hwnd to receive forwarded messages
    HWND        _hwndParent;
    CTrackPopupBar * _ptpbar;
    IMenuPopup * _pmpParent;
    void*       _pvContext;
    HANDLE      _hEvent;

    BITBOOL     _fEscHit: 1;

    // we need to keep track of whether the last selected
    // menu item was on a popup or not.  we can do this by storing the 
    // last WM_MENUSELECT flags
    UINT        _uFlagsLastSelected; 
    HMENU       _hmenuLastSelected;
    POINT       _ptLastMove;

    void    Init(void* pvContext, CTrackPopupBar * ptpbar, IMenuPopup * pmpParent, HWND hwndParent, HWND hwndSite);
    void    Reset(void* pvContext);
    void    CancelMenu(void* pvContext);

    static LRESULT CALLBACK MsgHook(int nCode, WPARAM wParam, LPARAM lParam);

//private:
    void _OnMenuSelect(HMENU hmenu, int i, UINT uFlags);
    BOOL _OnKey(WPARAM vkey);
};

// Just one of these, b/c we only need one message filter
CMenuAgent g_menuagent = { 0 };     


/*----------------------------------------------------------
Purpose: Initialize the message filter hook

*/
void CMenuAgent::Init(void* pvContext, CTrackPopupBar * ptpbar, IMenuPopup * pmpParent, 
                      HWND hwndParent, HWND hwndSite)
{
    TraceMsg(TF_MENUBAND, "Initialize CMenuAgent");

    ASSERT(IS_VALID_READ_PTR(ptpbar, CTrackPopupBar));
    ASSERT(IS_VALID_CODE_PTR(pmpParent, IMenuPopup));
    ASSERT(IS_VALID_HANDLE(hwndSite, WND));

    if (_pvContext != pvContext)
    {
        // When switching contexts, we need to collapse the old menu. This keeps us from
        // hosing the menubands when switching from one browser to another.
        CancelMenu(_pvContext);
        ATOMICRELEASE(_ptpbar);
        ATOMICRELEASE(_pmpParent);
        _pvContext = pvContext;
    }

    pmpParent->SetSubMenu(ptpbar, TRUE);

    _hwndSite = hwndSite;
    _hwndParent = hwndParent;

    // Since the message hook wants to forward messages to the toolbar,
    // we need to ask the pager control to do this
    Pager_ForwardMouse(_hwndSite, TRUE);

    _pmpParent = pmpParent;
    _pmpParent->AddRef();

    _ptpbar = ptpbar;
    _ptpbar->AddRef();

    // HACKHACKHACKHACKHACK (lamadio)
    // On Windows 9x kernel can't handle the reentrancy problem where you have two hooks
    // in two separate processes. When one process looses focus, we collapse the Menu.
    // After that we remove our hook. Problem is: Between the Loosing focus and
    // removing the hook, the other IE process popped up a menu and installed a hook
    // the two hooks mutilate each other.
    if (IsOS(OS_WINDOWS))
    {
        ASSERT(_hEvent == NULL);
        
        _hEvent = OpenEventA(EVENT_ALL_ACCESS, FALSE, "Shell.MenuAgent");

        if (!_hEvent)   //event routines return NULL on failure.
            // Don't need to use CreateAllAccessSecurityAttributes since this
            // is Win9x-only code anyway
            _hEvent = CreateEventA(NULL, TRUE, TRUE, "Shell.MenuAgent");

        if (_hEvent)
            WaitForSingleObject(_hEvent, INFINITE);
    }

    if (NULL == _hhookMsg)
    {
        if (_hEvent)
            ResetEvent(_hEvent);
        _hhookMsg = SetWindowsHookEx(WH_MSGFILTER, MsgHook, HINST_THISDLL, 0);
        if (!_hhookMsg && _hEvent)
        {
            SetEvent(_hEvent);
            CloseHandle(_hEvent);
            _hEvent = NULL;
        }
    }

    _fEscHit = FALSE;

    GetCursorPos(&_ptLastMove);
}    


/*----------------------------------------------------------
Purpose: Reset the menu agent; no longer track mouse and keyboard
         messages.  The menuband calls this when it exits menu mode.

*/
void CMenuAgent::Reset(void* pvContext)
{
    if (_pvContext == pvContext)
    {
        _pmpParent->SetSubMenu(_ptpbar, FALSE);

        // The only time to not send MPOS_FULLCANCEL is if the escape
        // key caused the menu to terminate.

        if ( !_fEscHit )
            _pmpParent->OnSelect(MPOS_FULLCANCEL);

        // Eat any mouse-down/up sequence left in the queue.  This is how 
        // we keep the toolbar from getting a mouse-down if the user 
        // clicks on the same menuitem as what is currently popped down.
        // (E.g., click File, then click File again.  W/o this, the menu
        // would never toggle up.)

        MSG msg;

        while (PeekMessage(&msg, _hwndSite, WM_LBUTTONDOWN, WM_LBUTTONUP, PM_REMOVE))
            ;   // Do nothing

        Pager_ForwardMouse(_hwndSite, FALSE);

        _hwndSite = NULL;
        _hwndParent = NULL;

        ATOMICRELEASE(_pmpParent);
        ATOMICRELEASE(_ptpbar);

        if (_hhookMsg)
        {
            TraceMsg(TF_MENUBAND, "CMenuAgent: Hook removed");

            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;

            if (_hEvent)
            {
                SetEvent(_hEvent);
                CloseHandle(_hEvent);
                _hEvent = NULL;
            }
        }

        _pvContext = NULL;
    }
}    


/*----------------------------------------------------------
Purpose: Make the menu go away

*/
void CMenuAgent::CancelMenu(void* pvContext)
{
    if (_pvContext == pvContext)
    {
        if (_hwndParent)
        {
            ASSERT(IS_VALID_HANDLE(_hwndParent, WND));

            TraceMsg(TF_MENUBAND, "Sending cancel mode to menu");

            // Use PostMessage so USER32 doesn't RIP on us in 
            // MsgHook when it returns from the WM_MOUSEMOVE
            // that triggered this code path in the first place.

            PostMessage(_hwndParent, WM_CANCELMODE, 0, 0);

            // Disguise this as if the escape key was hit,
            // since this is called when the mouse hovers over
            // another menu sibling.
            _fEscHit = TRUE;

            _pmpParent->SetSubMenu(_ptpbar, FALSE);
        }
    }
}    

// store away the identity of the selected menu item.
// if uFlags & MF_POPUP then i is the index.
// otherwise it's the command and we need to convert it to the index.
// we store index always because some popups don't have ids

void CMenuAgent::_OnMenuSelect(HMENU hmenu, int i, UINT uFlags)
{
    _uFlagsLastSelected = uFlags;
    _hmenuLastSelected = hmenu;
}

BOOL CMenuAgent::_OnKey(WPARAM vkey)
{
    //
    // If the menu window is RTL mirrored, then the arrow keys should
    // be mirrored to reflect proper cursor movement. [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(_hwndSite))
    {
        switch (vkey)
        {
        case VK_LEFT:
          vkey = VK_RIGHT;
          break;

        case VK_RIGHT:
          vkey = VK_LEFT;
          break;
        }
    }

    switch (vkey)
    {
    case VK_RIGHT:
        if (!_hmenuLastSelected || !(_uFlagsLastSelected & MF_POPUP) || (_uFlagsLastSelected & MF_DISABLED) ) 
        {
            // if the currently selected item does not have a cascade, then 
            // we need to cancel out of all of this and tell the top menu bar to go right
            _pmpParent->OnSelect(MPOS_SELECTRIGHT);
        }
        break;
        
    case VK_LEFT:
        if (!_hmenuLastSelected || _hmenuLastSelected == _ptpbar->GetPopupMenu()) {
            // if the currently selected menu item is in our top level menu,
            // then we need to cancel out of all this menu loop and tell the top menu bar
            // to go left 
            _pmpParent->OnSelect(MPOS_SELECTLEFT);
        }
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
}


/*----------------------------------------------------------
Purpose: Message hook used to track keyboard and mouse messages
         while in a TrackPopupMenu modal loop.

*/
LRESULT CMenuAgent::MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;

    switch (nCode)
    {
    case MSGF_MENU:
#ifdef DEBUG
        if (IsFlagSet(g_dwDumpFlags, DF_MSGHOOK))
            DumpMsg(TEXT("MsgHook"), pmsg);
#endif

        switch (pmsg->message)
        {
        case WM_MENUSELECT:
            // keep track of the items as the are selected.
            g_menuagent._OnMenuSelect(GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam),
                                      GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                                      GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam));
            break;
            
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            // Since we've received this msg, any previous escapes
            // (like escaping out of a cascaded menu) should be cleared
            // to prevent a false reason for termination.
            g_menuagent._fEscHit = FALSE;
            break;

        case WM_KEYDOWN:
            if (g_menuagent._OnKey(pmsg->wParam))
                break;
            
        case WM_SYSKEYDOWN:
            g_menuagent._fEscHit = (VK_ESCAPE == pmsg->wParam);
            break;

        case WM_MOUSEMOVE:
            // HACKHACK (isn't all of this a hack?): ignore zero-move
            // mouse moves, so the mouse does not contend with the keyboard.

            POINT pt;
            
            // In screen coords....
            pt.x = GET_X_LPARAM(pmsg->lParam);
            pt.y = GET_Y_LPARAM(pmsg->lParam);

            if (g_menuagent._ptLastMove.x == pt.x && 
                g_menuagent._ptLastMove.y == pt.y)
            {
                TraceMsg(TF_MENUBAND, "CMenuAgent: skipping dup mousemove");
                break;
            }
            g_menuagent._ptLastMove = pt;

            // Since we got a WM_MOUSEMOVE, we need to tell the Menuband global message hook.
            // We need to do this because this message hook steels all of the messages, and
            // the Menuband message hook never updates it's internal cache for removing duplicate
            // WM_MOUSEMOVE messages which cause problems as outlined in CMsgFilter::_HandleMouseMessages
            GetMessageFilter()->AcquireMouseLocation();

            // Forward the mouse moves to the toolbar so the toolbar still
            // has a chance to hot track.  Must convert the points to the 
            // toolbar's client space.
            
            ScreenToClient(g_menuagent._hwndSite, &pt);

            SendMessage(g_menuagent._hwndSite, pmsg->message, pmsg->wParam, 
                        MAKELPARAM(pt.x, pt.y));
            break;
        }
        break;

    default:
        if (0 > nCode)
            return CallNextHookEx(g_menuagent._hhookMsg, nCode, wParam, lParam);
        break;
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        lRet = CallNextHookEx(g_menuagent._hhookMsg, nCode, wParam, lParam);

    return lRet;
}    



//=================================================================
// Implementation of a menu deskbar object that uses TrackPopupMenu.
//
// This object uses traditional USER32 menus (via TrackPopupMenu)
// to implement menu behavior.  It uses the CMenuAgent object to 
// help get its work done.  Since the menu deskbar site (_punkSite) 
// sits in a modal loop while any menu is up, it needs to know when
// to quit its loop.  The child object accomplishes this by sending
// an OnSelect(MPOS_FULLCANCEL).
//
// The only time that TrackPopupMenu returns (but we don't want to
// send an MPOS_FULLCANCEL) is if it's b/c the Escape key was hit.
// This just means cancel the current level.  Returning from Popup
// is sufficient for this case.  Otherwise, all other cases of
// returning from TrackPopupMenu means we send a MPOS_FULLCANCEL.
//
// Summary:
//
//  1) User clicked outside the menu.  This is a full cancel.
//  2) User hit the Alt key.  This is a full cancel.
//  3) User hit the Esc key.  This just cancels the current level.
//     (TrackPopupMenu handles this fine.  No notification needs
//     to be sent b/c we want the top-level menu to stay in its
//     modal loop.)
//  4) User selected a menu item.  This is a full cancel.
//
//=================================================================


#undef THISCLASS
#undef SUPERCLASS
#define SUPERCLASS  CMenuDeskBar

// Constructor
CTrackPopupBar::CTrackPopupBar(void *pvContext, int id, HMENU hmenu, HWND hwnd)
{
    _hmenu = hmenu;
    _hwndParent = hwnd;
    _id = id;
    _pvContext = pvContext;
    _nMBIgnoreNextDeselect = RegisterWindowMessage(TEXT("CMBIgnoreNextDeselect"));
}

// Destructor
CTrackPopupBar::~CTrackPopupBar()
{
    SetSite(NULL);
}


STDMETHODIMP_(ULONG) CTrackPopupBar::AddRef()
{
    return SUPERCLASS::AddRef();
}

STDMETHODIMP_(ULONG) CTrackPopupBar::Release()
{
    return SUPERCLASS::Release();
}

STDMETHODIMP CTrackPopupBar::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTrackPopupBar, IMenuPopup),
        QITABENT(CTrackPopupBar, IObjectWithSite),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
    {
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CTrackPopupBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SMenuBandChild)) 
    {
        if (IsEqualIID(riid, IID_IAccessible))
        {
            HRESULT hres = E_OUTOFMEMORY;
            CAccessible* pacc = new CAccessible(_hmenu, _id);

            if (pacc)
            {
                hres = pacc->InitAcc();
                if (SUCCEEDED(hres))
                {
                    hres = pacc->QueryInterface(riid, ppvObj);
                }
                pacc->Release();
            }

            return hres;
        }
        else
            return QueryInterface(riid, ppvObj);
    }
    else
        return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}

/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

         This allows the parent menubar to tell us when to
         bail out of the TrackPopupMenu
*/
STDMETHODIMP CTrackPopupBar::OnSelect(DWORD dwType)
{
    switch (dwType)
    {
    case MPOS_CANCELLEVEL:
    case MPOS_FULLCANCEL:
        g_menuagent.CancelMenu(_pvContext);
        break;

    default:
        TraceMsg(TF_WARNING, "CTrackPopupBar doesn't handle this MPOS_ value: %d", dwType);
        break;
    }
    return S_OK;    
}    


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubMenu method

*/
STDMETHODIMP CTrackPopupBar::SetSubMenu(IMenuPopup * pmp, BOOL bSet)
{
    return E_NOTIMPL;
}    

// HACKHACK: DO NOT TOUCH! This is the only way to select
// the first item for a user menu. TrackMenuPopup by default does
// not select the first item. We pump these messages to our window. 
// User snags these messages, and thinks the user pressed the down button
// and selects the first item for us. The lParam is needed because Win95 gold
// validated this message before using it. Another solution would be to listen
// to WM_INITMENUPOPUP and look for the HWND of the menu. Then send that 
// window the private message MN_SELECTFIRSTVALIDITEM. But thats nasty compared 
// to this. - lamadio 1.5.99
void CTrackPopupBar::SelectFirstItem()
{
    HWND hwndFocus = GetFocus();
    // pulled the funny lparam numbers out of spy's butt.
    if (hwndFocus) {
        PostMessage(hwndFocus, WM_KEYDOWN, VK_DOWN, 0x11500001);
        PostMessage(hwndFocus, WM_KEYUP, VK_DOWN, 0xD1500001);
#ifdef UNIX
        /* HACK HACK
         * The above PostMessages were causing the second menu item
         * to be selected if you access the menu from the keyboard.
         * The following PostMessages will nullify the above effect.
         * This is to make sure that menus in shdocvw work properly
         * with user32 menus.
         */
        PostMessage(hwndFocus, WM_KEYDOWN, VK_UP, 0x11500001);
        PostMessage(hwndFocus, WM_KEYUP, VK_UP, 0xD1500001);
#endif /* UNIX */
    }
}
           
DWORD GetBuildNumber()
{
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (GetVersionEx(&osvi))
        return osvi.dwBuildNumber;
    else
        return 0;
}

/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

         Invoke the menu.
*/
STDMETHODIMP CTrackPopupBar::Popup(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags)
{
    static dwBuildNumber = GetBuildNumber();
    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));
    ASSERT(IS_VALID_CODE_PTR(_pmpParent, IMenuPopup));

    // We must be able to talk to the parent menu bar 
    if (NULL == _pmpParent)
        return E_FAIL;

    ASSERT(IS_VALID_HANDLE(_hmenu, MENU));
    ASSERT(IS_VALID_CODE_PTR(_punkSite, IUnknown));
    
    HMENU hmenu = GetSubMenu(_hmenu, _id);
    HWND hwnd;
    TPMPARAMS tpm;
    TPMPARAMS * ptpm = NULL;

    // User32 does not want to fix this for compatibility reasons,
    // but TrackPopupMenu does not snap to the nearest monitor on Single and Multi-Mon
    // systems. This has the side effect that if we pass a non-visible coordinate, then
    // User places menu at a random location on screen. So instead, we're going to bias
    // the point to the monitor.

    MONITORINFO mi = {0};
    mi.cbSize = sizeof(mi);

    HMONITOR hMonitor = MonitorFromPoint(*((POINT*)ppt), MONITOR_DEFAULTTONEAREST);
    GetMonitorInfo(hMonitor, &mi);

    if (ppt->x >= mi.rcMonitor.right)
        ppt->x = mi.rcMonitor.right;

    if (ppt->y >= mi.rcMonitor.bottom)
        ppt->y = mi.rcMonitor.bottom;

    if (ppt->x <= mi.rcMonitor.left)
        ppt->x = mi.rcMonitor.left;

    if (ppt->y <= mi.rcMonitor.top)
        ppt->y = mi.rcMonitor.top;


    if (prcExclude)
    {
        tpm.cbSize = SIZEOF(tpm);
        tpm.rcExclude = *((LPRECT)prcExclude);
        ptpm = &tpm;
    }

    // The forwarding code in CShellBrowser::_ShouldForwardMenu
    // and CDocObjectHost::_ShouldForwardMenu expects the first
    // WM_MENUSELECT to be sent for the top-level menu item.
    // 
    // We need to fake an initial menu select on the top menu band
    // to mimic USER and satisfy this expectation.
    //
    UINT uMSFlags = MF_POPUP;
    SendMessage(_hwndParent, WM_MENUSELECT, MAKEWPARAM(_id, uMSFlags), (LPARAM)_hmenu);
    
    SendMessage(_hwndParent, _nMBIgnoreNextDeselect, NULL, NULL);

    // Initialize the menu agent
    IUnknown_GetWindow(_punkSite, &hwnd);
    
    VARIANTARG v = {0};
    UINT uFlags = TPM_VERTICAL | TPM_TOPALIGN;
    UINT uAnimateFlags = 0;
    if (SUCCEEDED(IUnknown_Exec(_punkSite, &CGID_MENUDESKBAR, MBCID_GETSIDE, 0, NULL, &v))) {
        if (v.vt == VT_I4 && 
            (v.lVal == MENUBAR_RIGHT ||
             v.lVal == MENUBAR_LEFT))
        {
            uFlags = TPM_TOPALIGN;
        }

        switch (v.lVal)
        {
        case MENUBAR_LEFT:      uAnimateFlags = TPM_HORNEGANIMATION;
            break;
        case MENUBAR_RIGHT:     uAnimateFlags = TPM_HORPOSANIMATION;
            break;
        case MENUBAR_TOP:       uAnimateFlags = TPM_VERNEGANIMATION;
            break;
        case MENUBAR_BOTTOM:    uAnimateFlags = TPM_VERPOSANIMATION;
            break;
        }
    }

    g_menuagent.Init(_pvContext, this, _pmpParent, _hwndParent, hwnd);

    ASSERT(IS_VALID_HANDLE(hmenu, MENU));
    if (dwFlags & MPPF_INITIALSELECT)
        SelectFirstItem();

    // This feature only works on build 1794 or greater.
    if (g_bRunOnNT5 && dwBuildNumber >= 1794 && dwFlags & MPPF_NOANIMATE)
        uFlags |= TPM_NOANIMATION;

#ifndef MAINWIN

    if (g_bRunOnMemphis || g_bRunOnNT5)
        uFlags |= uAnimateFlags;

    TrackPopupMenuEx(hmenu, uFlags,
                   ppt->x, ppt->y, _hwndParent, ptpm);
#else
    // Current MainWin's implementation of TrackPopupMenuEx is buggy.
    // I failed to fix it, so I replaced the call by TrackPopupMenu,
    // that provides partial functionality.
    // Hopefully, jluu will be able to fix it.
    TrackPopupMenu(hmenu, uFlags, ppt->x, ppt->y, 0, _hwndParent, 
                   &ptpm->rcExclude);
#endif

    // Tell the parent that the menu is now gone
    SendMessage(_hwndParent, WM_MENUSELECT, MAKEWPARAM(0, 0xFFFF), NULL);

    g_menuagent.Reset(_pvContext);

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\mnbase.cpp ===
#include "priv.h"
#include "sccls.h"
#include "menuband.h"
#include "itbar.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "mnbase.h"
#include "oleacc.h"
#include "apithk.h"
#include "menuisf.h"
#include "iaccess.h"
#include "uemapp.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

// Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"

#define DM_MISC     0               // miscellany

#define MAXUEMTIMEOUT 2000

/*----------------------------------------------------------
Purpose: Return the button command given the position.

*/
int GetButtonCmd(HWND hwnd, int iPos)
{
    ASSERT(IsWindow(hwnd));
    int nRet = -1;          // Punt on failure

    TBBUTTON tbb;
    if (ToolBar_GetButton(hwnd, iPos, &tbb))
    {
        nRet = tbb.idCommand;
    }
    return nRet;
}    



void* ItemDataFromPos(HWND hwndTB, int iPos)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
    if (ToolBar_GetButtonInfo(hwndTB, iPos, &tbbi) >= 0)
    {
        return (void*)tbbi.lParam;
    }

    return NULL;
}

long GetIndexFromChild(BOOL fTop, int iIndex)
{
    return  (fTop? TOOLBAR_MASK: 0) | iIndex + 1;
}

//--------------------------------------------------------------------------------
//
// CMenuToolbarBase
//
//--------------------------------------------------------------------------------

CMenuToolbarBase::CMenuToolbarBase(CMenuBand* pmb, DWORD dwFlags) : _pcmb(pmb)
{
#ifdef DEBUG
    _cRef = 1;
#endif
    _dwFlags = dwFlags;
    _nItemTimer = -1;
    _idCmdChevron = -1;
    _fFirstTime = TRUE;
}

// *** IObjectWithSite methods ***

HRESULT CMenuToolbarBase::SetSite(IUnknown *punkSite)
{
    ASSERT(punkSite && IS_VALID_READ_PTR(punkSite, CMenuBand*));

    // We are guaranteed the lifetime of this object is contained within
    // the menuband, so we don't addref pcmb.
    if (SUCCEEDED(punkSite->QueryInterface(CLSID_MenuBand, (LPVOID*)&_pcmb))) {
        punkSite->Release();
    } else {
        ASSERT(0);
    }

    

    _fVerticalMB = !BOOLIFY(_pcmb->_dwFlags & SMINIT_HORIZONTAL);
    _fTopLevel = BOOLIFY(_pcmb->_dwFlags & SMINIT_TOPLEVEL);
    
    return S_OK;
}

HRESULT CMenuToolbarBase::GetSite(REFIID riid, void ** ppvSite)
{
    if (!_pcmb)
        return E_FAIL;

    return _pcmb->QueryInterface(riid, ppvSite);
}

// *** IUnknown methods ***

STDMETHODIMP_(ULONG) CMenuToolbarBase::AddRef()
{
    DEBUG_CODE(_cRef++);
    if (_pcmb)
    {
        return _pcmb->AddRef();
    }

    return 0;
}


STDMETHODIMP_(ULONG) CMenuToolbarBase::Release()
{
    ASSERT(_cRef > 0);
    DEBUG_CODE(_cRef--);

    if (_pcmb)
    {
        return _pcmb->Release();
    }

    return 0;
}

HRESULT CMenuToolbarBase::QueryInterface(REFIID riid, void** ppvObj)
{
    HRESULT hres;
    if (IsEqualGUID(riid, CLSID_MenuToolbarBase) && ppvObj) 
    {
        AddRef();
        *ppvObj = (LPVOID)this;
        hres = S_OK;
    }
    else
        hres = _pcmb->QueryInterface(riid, ppvObj);

    return hres;
}

void CMenuToolbarBase::SetToTop(BOOL bToTop)
{
    // A menu toolbar can be at the top or the bottom of the menu.
    // This is an exclusive attribute.
    if (bToTop)
    {
        _dwFlags |= SMSET_TOP;
        _dwFlags &= ~SMSET_BOTTOM;
    }
    else
    {
        _dwFlags |= SMSET_BOTTOM;
        _dwFlags &= ~SMSET_TOP;
    }
}


void CMenuToolbarBase::KillPopupTimer()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Killing Popout Timer...", this);
    KillTimer(_hwndMB, MBTIMER_POPOUT);
    _nItemTimer = -1;
}


void CMenuToolbarBase::SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags)
{
    if (_hwndMB)
    {
        ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
        DWORD rectWidth = RECTWIDTH(*prc);
        TraceMsg(TF_MENUBAND, "CMTB::SetWindowPos %d - (%d,%d,%d,%d)", psize?psize->cx:0,
            prc->left, prc->top, prc->right, prc->bottom);
        ::SetWindowPos(_hwndMB, NULL, prc->left, prc->top, 
            rectWidth, RECTHEIGHT(*prc), SWP_NOZORDER | SWP_NOACTIVATE | dwFlags);
        // hackhack:  we only do this when multicolumn.  this call is to facilitate the size negotiation between 
        // static menu and folder menu.  Set the width of the toolbar to the width of the button in case 
        // of non-multicolumn.
        if (!(_fMulticolumnMB) && psize)
            ToolBar_SetButtonWidth(_hwndMB, psize->cx, psize->cx);

        // Force this to redraw. I put this here because the HMenu portion was painting after the shell
        // folder portion was done enumerating the folder, which is pretty slow. I wanted the HMENU portion
        // to paint right away...
        RedrawWindow(_hwndMB, NULL, NULL, RDW_UPDATENOW);
    }
}

// NOTE: if psize is (0,0) we use tb button size as param in figuring out ideal tb size
//   else we use max of psize length and tb button length as our metric
void CMenuToolbarBase::GetSize(SIZE* psize)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    if (EVAL(_hwndMB))
    {
        LRESULT lButtonSize;

        lButtonSize = SendMessage(_hwndMB, TB_GETBUTTONSIZE, 0, 0);
        if (psize->cx || psize->cy) 
        {
            int cx = max(psize->cx, LOWORD(lButtonSize));
            int cy = max(psize->cy, HIWORD(lButtonSize));
            lButtonSize = MAKELONG(cx, cy);
        }

        if (_fVerticalMB)
        {
            psize->cx = LOWORD(lButtonSize);
            SendMessage(_hwndMB, TB_GETIDEALSIZE, TRUE, (LPARAM)psize);
        }
        else
        {
            psize->cy = HIWORD(lButtonSize);
            SendMessage(_hwndMB, TB_GETIDEALSIZE, FALSE, (LPARAM)psize);
        }

        TraceMsg(TF_MENUBAND, "CMTB::GetSize (%d, %d)", psize->cx, psize->cy);
    }
}


/*----------------------------------------------------------
Purpose: Timer handler.  Used to pop open/close cascaded submenus.

*/
LRESULT CMenuToolbarBase::_OnTimer(WPARAM wParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    switch (wParam) 
    {

    case MBTIMER_INFOTIP:
        {
            // Do we have a hot item to display the tooltip for?
            int iHotItem = ToolBar_GetHotItem(_hwndMB);
            KillTimer(_hwndMB, wParam);
            if (iHotItem >= 0)
            {
                // Yep.
                TCHAR szTip[MAX_PATH];
                int idCmd = GetButtonCmd(_hwndMB, iHotItem);

                // Ask the superclass for the tip
                if (S_OK == v_GetInfoTip(idCmd, szTip, ARRAYSIZE(szTip)))
                {
                    // Now display it. Yawn.
                    _pcmb->_pmbState->CenterOnButton(_hwndMB, FALSE, idCmd, NULL, szTip);
                }
            }
        }
        break;

    case MBTIMER_CHEVRONTIP:
        KillTimer(_hwndMB, wParam);
       _pcmb->_pmbState->HideTooltip(TRUE);
       break;
 
    case MBTIMER_FLASH:
        {
            _cFlashCount++;
            if (_cFlashCount == COUNT_ENDFLASH)
            {
                _cFlashCount = 0;
                KillTimer(_hwndMB, wParam);
                ToolBar_MarkButton(_hwndMB, _idCmdChevron, FALSE);
                _SetTimer(MBTIMER_UEMTIMEOUT);

                // Now that we've flashed, let's show the Chevron tip.
                // This is for a confused user: If they've hovered over an item for too long,
                // or this is the first time they've seen intellimenus, then we flash and display
                // the tooltip. We only want to display this if we are shown: We would end up with
                // and dangling tooltip if you happen to move to another menu while it was flashing.
                // Ummm, is the Chevron still visible?
                if (_fShowMB && _idCmdChevron != -1)
                {
                    TCHAR szTip[MAX_PATH];
                    TCHAR szTitle[MAX_PATH];
                    if (S_OK == v_CallCBItem(_idCmdChevron, SMC_CHEVRONGETTIP, (WPARAM)szTitle, (LPARAM)szTip))
                    {
                        _pcmb->_pmbState->CenterOnButton(_hwndMB, TRUE, _idCmdChevron, szTitle, szTip);
                        _SetTimer(MBTIMER_CHEVRONTIP);
                    }
                }
            }
            else
                ToolBar_MarkButton(_hwndMB, _idCmdChevron, (_cFlashCount % 2) == 0);
        }
        break;

    case MBTIMER_UEMTIMEOUT:
        {
            POINT pt;
            RECT rect;

            // Don't fire timeouts when we're in edit mode.
            if (_fEditMode)
            {
                KillTimer(_hwndMB, wParam);
                break;
            }

            GetWindowRect(_hwndMB, &rect);
            GetCursorPos(&pt);
            if (PtInRect(&rect, pt))
            {
                TraceMsg(TF_MENUBAND, "*** UEM TimeOut. At Tick Count (%d) ***", GetTickCount());
                _FireEvent(UEM_TIMEOUT);
            }
            else
            {
                TraceMsg(TF_MENUBAND, " *** UEM TimeOut. At Tick Count (%d)."
                    " Mouse outside menu. Killing *** ", GetTickCount());
                KillTimer(_hwndMB, wParam);
            }
        }
        break;


    case MBTIMER_EXPAND:
        KillTimer(_hwndMB, wParam);
        if (_fShowMB)
        {
            v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
            Expand(TRUE);
            _fClickHandled = TRUE;
            _SetTimer(MBTIMER_CLICKUNHANDLE); 
        }
        break;

    case MBTIMER_DRAGPOPDOWN:
        // There has not been a drag enter in this band for a while, 
        // so we'll try to cancel the menus.
        KillTimer(_hwndMB, wParam);
        PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBDragCancel, 0, 0);
        break;

    case MBTIMER_DRAGOVER:
        {
            TraceMsg(TF_MENUBAND, "CMenuToolbarBase::OnTimer(DRAG)");
            KillTimer(_hwndMB, wParam);
            DAD_ShowDragImage(FALSE);
            // Does this item cascade?
            int idBtn = GetButtonCmd(_hwndMB, v_GetDragOverButton());
            if (v_GetFlags(idBtn) & SMIF_SUBMENU)
            {
                TraceMsg(TF_MENUBAND, "CMenuToolbarBase::OnTimer(DRAG): Is a submenu");
                // Yes; pop it open
                if (!_fVerticalMB)
                    _pcmb->_fInvokedByDrag = TRUE;
                _DoPopup(idBtn, FALSE);
            }
            else if (idBtn == _idCmdChevron)
            {
                Expand(TRUE);

            }
            else
            {
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
            }
        }
        break;

    case MBTIMER_POPOUT:
        {
            int nItemTimer = _nItemTimer;
            KillPopupTimer();

            // Popup a new submenu?
            if (-1 != nItemTimer)
            {
                if (nItemTimer != _pcmb->_nItemCur)
                {
                    // Yes;  post message since the currently expanded submenu
                    // may be a CTrackPopup object, which posts its cancel mode.

                    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Timer went off.  Expanding...", this);
                    PostPopup(nItemTimer, FALSE, FALSE);
                }
            }
            else 
            {
                // No; just collapse the currently open submenu
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnTimer sending MPOS_CANCELLEVEL to submenu popup", this);
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
            }
            break;
        }
    
    case MBTIMER_CLOSE:
        KillTimer(_hwndMB, wParam);

        TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnTimer sending MPOS_FULLCANCEL", this);

        if (_fVerticalMB)
            _pcmb->_SiteOnSelect(MPOS_FULLCANCEL);
        else
        {
            _pcmb->_SubMenuOnSelect(MPOS_FULLCANCEL);
        }
        break;
    }
        
    return 1;
}


void CMenuToolbarBase::_DrawMenuArrowGlyph( HDC hdc, RECT * prc, COLORREF rgbText )
{
    SIZE size = {_pcmb->_pmbm->_cxArrow, _pcmb->_pmbm->_cyArrow};

    //
    // If the DC is mirrred, then the Arrow should be mirrored
    // since it is done thru TextOut, NOT the 2D graphics APIs [samera]
    //

    _DrawMenuGlyph(hdc, 
                   _pcmb->_pmbm->_hFontArrow,
                   prc, 
                   (IS_DC_RTL_MIRRORED(hdc)) ? CH_MENUARROWRTLA :
                   CH_MENUARROWA, 
                   rgbText, 
                   &size);
}


void CMenuToolbarBase::_DrawMenuGlyph( HDC hdc, HFONT hFont, RECT * prc, 
                               CHAR ch, COLORREF rgbText,
                               LPSIZE psize)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_pcmb->_pmbm->_hFontArrow)
    {
        SIZE    size;
        int cx, cy, y, x;
        HFONT hFontOld;
        int iOldBk = SetBkMode(hdc, TRANSPARENT);
        hFontOld = (HFONT)SelectObject(hdc, hFont);
        if (psize == NULL)
        {
            GetTextExtentPoint32A( hdc, &ch, 1, &size);
            psize = &size;
        }

        cy = prc->bottom - prc->top;
        y = prc->top  + ((cy - psize->cy) / 2);

        cx = prc->right - prc->left;
        x = prc->left + ((cx - psize->cx) /2);
    
        COLORREF rgbOld = SetTextColor(hdc, rgbText);

#ifndef UNIX
        TextOutA(hdc, x, y, &ch, 1);
#else
        // Paint motif look arrow.
        PaintUnixMenuArrow( hdc, prc, (DWORD)rgbText );
#endif
    
        SetTextColor(hdc, rgbOld);
        SetBkMode(hdc, iOldBk);
        SelectObject(hdc, hFontOld);
    }
}

void CMenuToolbarBase::SetMenuBandMetrics(CMenuBandMetrics* pmbm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // This can be called before the toolbar is created. 
    // So we'll check this condition. When the toolbar is created, then
    // the toolbar will get the metrics at that point.
    if (!_hwndMB)
        return;

    //Loop through toolbar.
    for (int iButton = ToolBar_ButtonCount(_hwndMB)-1; iButton >= 0; iButton--)
    {
        IOleCommandTarget* poct;

        int idCmd = GetButtonCmd(_hwndMB, iButton);

        // If it's not a seperator, see if there is a sub menu.
        if (idCmd != -1 &&
            SUCCEEDED(v_GetSubMenu(idCmd, NULL, IID_IOleCommandTarget, (void**)&poct)))
        {
            VARIANT Var;
            Var.vt = VT_UNKNOWN;
            Var.punkVal = SAFECAST(pmbm, IUnknown*);

            // Exec to set new Metrics.
            poct->Exec(&CGID_MenuBand, MBANDCID_SETFONTS, 0, &Var, NULL);
            poct->Release();
        }
    }

    _SetFontMetrics();
    // return
}

void CMenuToolbarBase::_SetFontMetrics()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_hwndMB && _pcmb->_pmbm)
    {
        SendMessage(_hwndMB, WM_SETFONT, (WPARAM)_pcmb->_pmbm->_hFontMenu, FALSE);
    }
}


void CMenuToolbarBase::CreateToolbar(HWND hwndParent)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    ASSERT( _hwndMB != NULL );
    DWORD dwToolBarStyle = TBSTYLE_TRANSPARENT;

    // if we're set up as a popup, don't do any transparent stuff
    if (_fVerticalMB) 
    {
        dwToolBarStyle  = TBSTYLE_CUSTOMERASE;    // Vertical Toolbars don't get Transparent
        DWORD dwExtendedStyle = 0;

        // This is for TBMenu which actually has a Horizontal menubar within the 
        // Vertical menuband.
        if (!_fHorizInVerticalMB)
            dwExtendedStyle |= TBSTYLE_EX_VERTICAL;

        if (_fMulticolumnMB)
            dwExtendedStyle |= TBSTYLE_EX_MULTICOLUMN;

        ToolBar_SetExtendedStyle(_hwndMB, 
            dwExtendedStyle, TBSTYLE_EX_VERTICAL | TBSTYLE_EX_MULTICOLUMN);

        ToolBar_SetListGap(_hwndMB, LIST_GAP);
    }

    SHSetWindowBits(_hwndMB, GWL_STYLE, 
        TBSTYLE_TRANSPARENT | TBSTYLE_CUSTOMERASE, dwToolBarStyle );

    ToolBar_SetInsertMarkColor(_hwndMB, GetSysColor(COLOR_MENUTEXT));

    v_UpdateIconSize(_pcmb->_uIconSize, FALSE);
    _SetFontMetrics();
}


HRESULT CMenuToolbarBase::_SetMenuBand(IShellMenu* psm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = E_FAIL;
    IBandSite* pmbs = NULL;
    if (!_pcmb->_pmpSubMenu)
    {
        hres = CoCreateInstance(CLSID_MenuDeskBar, NULL, CLSCTX_INPROC_SERVER, IID_IMenuPopup, (void**)&_pcmb->_pmpSubMenu);
        if (SUCCEEDED(hres))
        {
            IUnknown_SetSite(_pcmb->_pmpSubMenu, SAFECAST(_pcmb, IOleCommandTarget*));
            hres = CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER, IID_IBandSite, (void**)&pmbs);
            if (SUCCEEDED(hres))
            {
                hres = _pcmb->_pmpSubMenu->SetClient(pmbs);
                // Don't release pmbs here. We are using below
            }
            // Menu band will Release _pmpSubMenu.
        }
    }
    else
    {
        IUnknown* punk;
        _pcmb->_pmpSubMenu->GetClient(&punk);
        if (punk)
        {
            hres = punk->QueryInterface(IID_IBandSite, (void**)&pmbs);
            punk->Release();
        }
    }

    if (pmbs)
    {
        if (SUCCEEDED(hres))
            hres = pmbs->AddBand(psm);

        pmbs->Release();
    }
 
    return hres;
}

HRESULT CMenuToolbarBase::GetSubMenu(int idCmd, GUID* pguidService, REFIID riid, void** ppvObj)
{
    // pguidService is for asking a for specifically the Shell Folder portion or the Static portion
    HRESULT hres = E_FAIL;
    if (v_GetFlags(idCmd) & SMIF_TRACKPOPUP ||
        _pcmb->_dwFlags & SMINIT_DEFAULTTOTRACKPOPUP)
    {
        hres = v_CreateTrackPopup(idCmd, riid, (void**)ppvObj);
        if (SUCCEEDED(hres))
        {
            _pcmb->SetTrackMenuPopup((IUnknown*)*ppvObj);
        }
    }
    else
    {
        IShellMenu* psm;
        hres = v_GetSubMenu(idCmd, pguidService, IID_IShellMenu, (void**)&psm);
        if (SUCCEEDED(hres)) 
        {
            TraceMsg(TF_MENUBAND, "GetUIObject psm %#lx", psm);
            _pcmb->SetTracked(this);

            hres = _SetMenuBand(psm);
            psm->Release();

            // Did we succeed in getting a menupopup?
            if (SUCCEEDED(hres))
            {
                // Yep; Sweet!
                _pcmb->_pmpSubMenu->QueryInterface(riid, ppvObj);

                HWND hwnd;
                IUnknown_GetWindow(_pcmb->_pmpSubMenu, &hwnd);
                PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBAutomation, (WPARAM)hwnd, (LPARAM)-1);
            }
        }
    }

    return hres;
}

HRESULT CMenuToolbarBase::PositionSubmenu(int idCmd)
{
    IMenuPopup* pmp = NULL;
    HRESULT hres = E_FAIL;
    DWORD dwFlags = 0;

    if (_pcmb->_fInSubMenu)
    {
        // Since the selection has probrably changed, we use the cached item id
        // to calculate the postion rect
        idCmd = _pcmb->_nItemSubMenu;
        dwFlags = MPPF_REPOSITION | MPPF_NOANIMATE;
        pmp = _pcmb->_pmpSubMenu;
        pmp->AddRef();

        ASSERT(pmp);    // If _fInSubmenu is set, then this must be valid
        hres = S_OK;
    }
    else
    {
        // Only do these when we're not repositioning.
        if (_pcmb->_fInitialSelect)
            dwFlags |= MPPF_INITIALSELECT;

        if (g_bRunOnNT5 && !_pcmb->_fCascadeAnimate)
            dwFlags |= MPPF_NOANIMATE;

        _pcmb->_nItemSubMenu = idCmd;

        hres = GetSubMenu(idCmd, NULL, IID_IMenuPopup, (void**)&pmp);
    }

    ASSERT(idCmd != -1);    // Make sure at this point we have an item.


    if (SUCCEEDED(hres))
    {
        ASSERT(pmp);

        // Make sure the menuitem is pressed
        _PressBtn(idCmd, TRUE);

        RECT rc;
        RECT rcTB;
        RECT rcTemp;
        POINT pt;

        SendMessage(_hwndMB, TB_GETRECT, idCmd, (LPARAM)&rc);
        GetClientRect(_hwndMB, &rcTB);

        // Is the button rect within the boundries of the
        // visible toolbar?
        if (!IntersectRect(&rcTemp, &rcTB, &rc))
        {
            // No; Then we need to bias that rect into
            // the visible region of the toolbar.
            // We only want to bias one side
            if (rc.left > rcTB.right)
            {
                rc.left = rcTB.right - (rc.right - rc.left);
                rc.right = rcTB.right;
            }
        }


        MapWindowPoints(_hwndMB, HWND_DESKTOP, (POINT*)&rc, 2);

        if (_fVerticalMB) 
        {
            pt.x = rc.right;
            pt.y = rc.top;
        } 
        else 
        {
            //
            // If the shell dropdown (toolbar button) menus are mirrored,
            // then take the right edge as the anchor point
            //
            if (IS_WINDOW_RTL_MIRRORED(_hwndMB))
                pt.x = rc.right;
            else
                pt.x = rc.left;
            pt.y = rc.bottom;
        }

        // Since toolbar buttons expand almost to the end of the basebar,
        // shrink the exclude rect so if overlaps.
        // NOTE: the items are GetSystemMetrics(SM_CXEDGE) larger than before. So adjust to that.

        if (_pcmb->_fExpanded)
            InflateRect(&rc, -GetSystemMetrics(SM_CXEDGE), 0);

        // We want to stop showing the chevron tip when we cascade into another menu
        _pcmb->_pmbState->HideTooltip(TRUE);

        // Only animate the first show at this level.
        _pcmb->_fCascadeAnimate = FALSE;

        hres = pmp->Popup((POINTL*)&pt, (RECTL*)&rc, dwFlags);
        pmp->Release();

    }
    return hres;
}
/*----------------------------------------------------------
Purpose: Cascade to the _nItemCur item's menu popup.

         If the popup call was modal, S_FALSE is returned; otherwise
         it is S_OK, or error.

*/
HRESULT CMenuToolbarBase::PopupOpen(int idBtn)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = E_FAIL;


    // Tell the current submenu popup to cancel.  This must be done 
    // before the PostMessage b/c CTrackPopupBar itself posts a message
    // which it must receive before we receive our post.
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): PostPopup sending MPOS_CANCELLEVEL to submenu popup", this);
    if (_pcmb->_fInSubMenu)
        _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);

    hres = PositionSubmenu(idBtn);

    // Modal?
    if (S_FALSE == hres)
    {
        // Yes; take the capture back
        GetMessageFilter()->RetakeCapture();

        // return S_OK so we stay in the menu mode
        hres = S_OK;
    }
    else if (FAILED(hres))
        _PressBtn(idBtn, FALSE);

    // Since CTrackPopupBar is modal, it should be a useless blob 
    // of bits in memory by now...
    _pcmb->SetTrackMenuPopup(NULL);
   
    return hres;
}


/*----------------------------------------------------------
Purpose: Called to hide a modeless menu.

*/
void CMenuToolbarBase::PopupClose(void)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (-1 != _pcmb->_nItemCur)
    {
        _PressBtn(_pcmb->_nItemCur, FALSE);
        NotifyWinEvent(EVENT_OBJECT_FOCUS, _hwndMB, OBJID_CLIENT, 
            GetIndexFromChild(_dwFlags & SMSET_TOP, ToolBar_CommandToIndex(_hwndMB, _pcmb->_nItemCur)));

        _pcmb->_fInSubMenu = FALSE;
        _pcmb->_fInvokedByDrag = FALSE;
        _pcmb->_nItemCur = -1;
    }
}    


LRESULT CMenuToolbarBase::_OnWrapHotItem(NMTBWRAPHOTITEM* pnmwh)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_fProcessingWrapHotItem || 
        (_pcmb->_pmtbTop == _pcmb->_pmtbBottom && !_fHasDemotedItems))
        return 0;

    _fProcessingWrapHotItem = TRUE;


    // If we want ourselves to not be wrapped into (Like for empty items) 
    // Then forward the wrap message to the other toolbar
    if (_pcmb->_pmtbTracked->_dwFlags & SMSET_TOP && !(_pcmb->_pmtbBottom->_fDontShowEmpty))
    {
        _pcmb->SetTracked(_pcmb->_pmtbBottom);
    }
    else if (!(_pcmb->_pmtbTop->_fDontShowEmpty))
    {
        _pcmb->SetTracked(_pcmb->_pmtbTop);
    }

    int iIndex;

    if (pnmwh->iDir < 0)
    {
        HWND hwnd = _pcmb->_pmtbTracked->_hwndMB;
        iIndex = ToolBar_ButtonCount(hwnd) - 1;
        int idCmd = GetButtonCmd(hwnd, iIndex);

        // We do not want to wrap onto a chevron.
        if (idCmd == _idCmdChevron)
            iIndex -= 1;

    }
    else
    {
        iIndex = 0;
    }

    _pcmb->_pmtbTracked->SetHotItem(pnmwh->iDir, iIndex, -1, pnmwh->nReason);


    _fProcessingWrapHotItem = FALSE;

    return 1;
}


LRESULT CMenuToolbarBase::_OnWrapAccelerator(NMTBWRAPACCELERATOR* pnmwa)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    int iHotItem = -1;
    int iNumTopAccel = 0;
    int iNumBottomAccel = 0;

    if (_pcmb->_fProcessingDup)
        return 0;

    // Check to see if there is only one toolbar.
    if (_pcmb->_pmtbTop == _pcmb->_pmtbBottom)
        return 0;

    ToolBar_HasAccelerator(_pcmb->_pmtbTop->_hwndMB, pnmwa->ch, &iNumTopAccel);
    ToolBar_HasAccelerator(_pcmb->_pmtbBottom->_hwndMB, pnmwa->ch, &iNumBottomAccel);

    _pcmb->_fProcessingDup = TRUE;

    CMenuToolbarBase* pmbtb = NULL;
    if (_pcmb->_pmtbTracked->_dwFlags & SMSET_TOP)
    {
        ToolBar_MapAccelerator(_pcmb->_pmtbBottom->_hwndMB, pnmwa->ch, &iHotItem);
        pmbtb = _pcmb->_pmtbBottom;
    }
    else
    {
        ToolBar_MapAccelerator(_pcmb->_pmtbTop->_hwndMB, pnmwa->ch, &iHotItem);
        pmbtb = _pcmb->_pmtbTop;
    }

    _pcmb->_fProcessingDup = FALSE;

    if (iHotItem != -1)
    {
        _pcmb->SetTracked(pmbtb);
        int idCmd = ToolBar_CommandToIndex(pmbtb->_hwndMB, iHotItem);
        DWORD dwFlags = HICF_ACCELERATOR;

        // If either (but not both) toolbars have the accelerator, and it is exactly one,
        // then cause the drop down.
        if ( (iNumTopAccel >= 1) ^ (iNumBottomAccel >= 1) &&
             (iNumTopAccel == 1 || iNumBottomAccel == 1) )
            dwFlags |= HICF_TOGGLEDROPDOWN;

        SendMessage(pmbtb->_hwndMB, TB_SETHOTITEM2, idCmd, dwFlags);
        pnmwa->iButton = -1;
        return 1;
    }

    return 0;
}


LRESULT CMenuToolbarBase::_OnDupAccelerator(NMTBDUPACCELERATOR* pnmda)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_pcmb->_fProcessingDup || (_pcmb->_pmtbBottom == _pcmb->_pmtbTop))
        return 0;

    _pcmb->_fProcessingDup = TRUE;

    int iNumTopAccel = 0;
    int iNumBottomAccel = 0;
    
    if (_pcmb->_pmtbTop)
        ToolBar_HasAccelerator(_pcmb->_pmtbTop->_hwndMB, pnmda->ch, &iNumTopAccel);

    if (_pcmb->_pmtbBottom)
        ToolBar_HasAccelerator(_pcmb->_pmtbBottom->_hwndMB, pnmda->ch, &iNumBottomAccel);


    _pcmb->_fProcessingDup = FALSE;

    if (0 == iNumTopAccel && 0 == iNumBottomAccel)
    {
        // We want to return 1 if Both of them have one. 
        //Otherwise, return 0, and let the toolbar handle it itself.
        return 0;
    }

    pnmda->fDup = TRUE;

    return 1;
}

/*----------------------------------------------------------
Purpose: Handle WM_NOTIFY

*/
LRESULT CMenuToolbarBase::_OnNotify(LPNMHDR pnm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    LRESULT lres = 0;
    CMBMsgFilter* pmf = GetMessageFilter();

    // These are notifies we handle even when disengaged from the message hook.
    switch (pnm->code)
    {
    case NM_CUSTOMDRAW:
        // We now custom draw even the TopLevelMenuBand (for the correct font)
        lres = _OnCustomDraw((NMCUSTOMDRAW*)pnm);
        break;
    }
    
    
    // Is the Global Message filter Disengaged? This will happen when the Subclassed window
    // looses activation to a dialog box of some kind.
    if (lres == 0 && !pmf->IsEngaged())
    {
        // Yes; We've lost activation so we don't want to track like a normal menu...

        // For hot item change, return 1 so that the toolbar does not change the hot item.
        if (pnm->code == TBN_HOTITEMCHANGE && _pcmb->_fMenuMode)
            return 1;

        // For all other items, don't do anything....
        return 0;
    }

    switch (pnm->code)
    {
    case NM_RELEASEDCAPTURE:
        pmf->RetakeCapture();
        break;

    case NM_KEYDOWN:
        BLOCK
        {
            LPNMKEY pnmk = (LPNMKEY)pnm;
            lres = _OnKey(TRUE, pnmk->nVKey, pnmk->uFlags);
        }
        break;

    case NM_CHAR:
        {
            LPNMCHAR pnmc = (LPNMCHAR)pnm;
            if (pnmc->ch == TEXT(' '))
                return TRUE;

            if (pnmc->dwItemNext == -1 &&
                !_pcmb->_fVertical)
            {
                // If it's horizontal, then it must be top level.
                ASSERT(_pcmb->_fTopLevel);
                _pcmb->_CancelMode(MPOS_FULLCANCEL);
            }
        }
        break;

    case TBN_HOTITEMCHANGE:
        lres = _OnHotItemChange((LPNMTBHOTITEM)pnm);
        break;

    case NM_LDOWN:
        // We need to kill the expand timer, because the user might
        // move out of the chevron and accidentally select another item.
        if ( (int)((LPNMCLICK)pnm)->dwItemSpec == _idCmdChevron && _idCmdChevron != -1)
        {
            KillTimer(_hwndMB, MBTIMER_EXPAND);
            _fIgnoreHotItemChange = TRUE;
        }
        break;

    case NM_CLICK:
        {
            int idCmd = (int)((LPNMCLICK)pnm)->dwItemSpec;
            _fIgnoreHotItemChange = FALSE;
            if ( idCmd == -1 )
            {
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
                _pcmb->SetTracked(NULL);
                lres = 1;
            }
            else if ( idCmd == _idCmdChevron )
            {
                // Retake the capture on the button-up, b/c the toolbar took
                // it away for a moment.
                pmf->RetakeCapture();

                v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
                Expand(TRUE);
                _fClickHandled = TRUE;
                _SetTimer(MBTIMER_CLICKUNHANDLE);
                lres = 1;
            }
            else if (!_fEmpty)
            {
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): upclick %d", this, idCmd);

                // Retake the capture on the button-up, b/c the toolbar took
                // it away for a moment.
                pmf->RetakeCapture();

                if (v_GetFlags(idCmd) & SMIF_SUBMENU)     // Submenus support double click
                {
                    if (_iLastClickedTime == 0) // First time it was clicked
                    {
                        _iLastClickedTime = GetTickCount();
                        _idCmdLastClicked = idCmd;
                    }
                    // Did they click on the same item twice?
                    else if (idCmd != _idCmdLastClicked)
                    {
                        _iLastClickedTime = _idCmdLastClicked = 0;
                    }
                    else
                    {
                        // Was this item double clicked on?
                        if ((GetTickCount() - _iLastClickedTime) < GetDoubleClickTime())
                        {
                            // We need to post this back to ourselves, because
                            // the Tray will become in active when double clicking
                            // on something like programs. This happens because the 
                            // Toolbar will set capture back to itself and the tray
                            // doesn't get any more messages.
                            PostMessage(_hwndMB, g_nMBExecute, idCmd, 0);
                            _fClickHandled = TRUE;
                        }

                        _iLastClickedTime = _idCmdLastClicked = 0;
                    }
                }

                // Sent on the button-up.  Handle the same way.
                if (!_fClickHandled && -1 != idCmd)
                    _DropDownOrExec(idCmd, FALSE);

                _fClickHandled = FALSE;
                lres = 1;
            }
        }
        break;

    case TBN_DROPDOWN:
        lres = _OnDropDown((LPNMTOOLBAR)pnm);
        break;

#ifdef UNICODE
    case TBN_GETINFOTIPA:
        {
            LPNMTBGETINFOTIPA pnmTT = (LPNMTBGETINFOTIPA)pnm;
            UINT uiCmd = pnmTT->iItem;
            TCHAR szTip[MAX_PATH];

            if ( S_OK == v_GetInfoTip(pnmTT->iItem, szTip, ARRAYSIZE(szTip)) )
            {
                SHUnicodeToAnsi(szTip, pnmTT->pszText, pnmTT->cchTextMax);
            }
            else
            {
                // Set the lpszText to NULL to prevent the toolbar from setting
                // the button text by default
                pnmTT->pszText = NULL;
            }


            lres = 1;
            break;

        }
#endif
    case TBN_GETINFOTIP:
        {
            LPNMTBGETINFOTIP pnmTT = (LPNMTBGETINFOTIP)pnm;
            UINT uiCmd = pnmTT->iItem;

            if ( S_OK != v_GetInfoTip(pnmTT->iItem, pnmTT->pszText, pnmTT->cchTextMax) )
            {
                // Set the lpszText to NULL to prevent the toolbar from setting
                // the button text by default
                pnmTT->pszText = NULL;
            }
            lres = 1;
            break;
        }

    case NM_RCLICK:
        // When we go into a context menu, stop monitoring.
        KillTimer(_hwndMB, MBTIMER_EXPAND);
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
        break;

    case TBN_WRAPHOTITEM:
        lres = _OnWrapHotItem((NMTBWRAPHOTITEM*)pnm);
        break;

    case TBN_WRAPACCELERATOR:
        lres = _OnWrapAccelerator((NMTBWRAPACCELERATOR*)pnm);
        break;

    case TBN_DUPACCELERATOR:
        lres = _OnDupAccelerator((NMTBDUPACCELERATOR*)pnm);
        break;

    case TBN_DRAGOVER:
        // This message is sent when drag and drop within the toolbar indicates that it
        // is about to mark a button. Since this gets messed up because of LockWindowUpdate
        // we tell it not to do anything.
        lres = 1;
        break;
    }

    return(lres);
}


BOOL CMenuToolbarBase::_SetTimer(int nTimer)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    long lTimeOut;

#ifndef UNIX
    // If we're on NT5 or Win98, use the cool new SPI
    if (SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &g_lMenuPopupTimeout, 0)) {
        // Woo-hoo, all done.
    }
    else if (g_lMenuPopupTimeout == -1)
#endif
    {
        // NT4 or Win95.  Grovel the registry (yuck).
        DWORD dwType;
        TCHAR szDelay[6]; // int is 5 characters + null.
        DWORD cbSize = ARRAYSIZE(szDelay);

        g_lMenuPopupTimeout = MBTIMER_TIMEOUT;

        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"),
            TEXT("MenuShowDelay"), &dwType, (void*)szDelay, &cbSize))
        {
            g_lMenuPopupTimeout = (UINT)StrToInt(szDelay);
        }
    }

    lTimeOut = g_lMenuPopupTimeout;

    switch (nTimer)
    {
    case MBTIMER_EXPAND:
    case MBTIMER_DRAGPOPDOWN:
        lTimeOut *= 2;
        if (lTimeOut < MAXUEMTIMEOUT)
            lTimeOut = MAXUEMTIMEOUT;
        break;

    case MBTIMER_UEMTIMEOUT:
            if (!_fHasDemotedItems || _pcmb->_pmbState->GetExpand() || _fEditMode)
                return TRUE;
            lTimeOut *= 5;

            // We want a minimum of MAXUEMTIMEOUT for people who set the expand rate to zero
            if (lTimeOut < MAXUEMTIMEOUT)
                lTimeOut = MAXUEMTIMEOUT;
            TraceMsg(TF_MENUBAND, "*** UEM SetTimeOut to (%d) milliseconds" 
                "at Tick Count (%d).*** ", GetTickCount());
            break;

    case MBTIMER_CHEVRONTIP:
        lTimeOut = 60 * 1000;    // Please make the intellimenu's balloon tip go 
                                 // away after one minute of no action.
        break;

    case MBTIMER_INFOTIP:
        lTimeOut = 500;    // Half a second hovering over an item?
        break;
    }

    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Setting %d Timer to %d milliseconds at tickcount %d", 
        this, nTimer, lTimeOut, GetTickCount());
    return (BOOL)SetTimer(_hwndMB, nTimer, lTimeOut, NULL);
}

BOOL CMenuToolbarBase::_HandleObscuredItem(int idCmd)
{
    RECT rc;
    GetClientRect(_hwndMB, &rc);

    int iButton = (int)SendMessage(_hwndMB, TB_COMMANDTOINDEX, idCmd, 0);

    if (SHIsButtonObscured(_hwndMB, &rc, iButton)) 
    {
        // clear hot item
        ToolBar_SetHotItem(_hwndMB, -1);

        _pcmb->_SubMenuOnSelect(MPOS_FULLCANCEL);
        _pcmb->_CancelMode(MPOS_FULLCANCEL);        // This is for the track menus.

        HWND hwnd = _pcmb->_pmbState->GetSubclassedHWND();

        PostMessage(hwnd? hwnd: _hwndMB, g_nMBOpenChevronMenu, (WPARAM)idCmd, 0);

        return TRUE;
    }

    return FALSE;
}


LRESULT CMenuToolbarBase::_OnHotItemChange(NMTBHOTITEM * pnmhot)
{
	ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    LRESULT lres = 0;

#ifdef UNIX
    // IEUNIX : If this is a mouse move check if the left button is pressed
    // deviating from Windows behavior to be motif compliant.
    if (_fVerticalMB && (pnmhot->dwFlags & HICF_MOUSE) && !(pnmhot->dwFlags & HICF_LMOUSE))
        return 1;
#endif

    if (_pcmb->_fMenuMode && _pcmb->_fShow && !_fIgnoreHotItemChange)
    {
        // Always kill the expand timer when something changes
        KillTimer(_hwndMB, MBTIMER_EXPAND);
        KillTimer(_hwndMB, MBTIMER_INFOTIP);

        // Is this toolbar being entered?
        if (!(pnmhot->dwFlags & HICF_LEAVING))
        {
            // Yes; set it to be the currently tracking toolbar
            TraceMsg(TF_MENUBAND, "CMTB::OnHotItemChange. Setting Tracked....", this);
            _pcmb->SetTracked(this);

            _pcmb->_pmbState->HideTooltip(FALSE);
            _SetTimer(MBTIMER_INFOTIP);
        }

        // If the Toolbar has keybaord focus, we need to send OBJID_CLIENT so that we track correctly.
        if (!(pnmhot->dwFlags & HICF_LEAVING))
        {
            NotifyWinEvent(EVENT_OBJECT_FOCUS, _hwndMB, OBJID_CLIENT, 
                GetIndexFromChild(_dwFlags & SMSET_TOP, ToolBar_CommandToIndex(_hwndMB, pnmhot->idNew)));
        }

        DEBUG_CODE( TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHANGE (state:%#02lx, %d-->%d)", 
                             this, pnmhot->dwFlags, 
                             (pnmhot->dwFlags & HICF_ENTERING) ? -1 : pnmhot->idOld, 
                             (pnmhot->dwFlags & HICF_LEAVING) ? -1 : pnmhot->idNew); )

        // While in edit mode, we do not automatically cascade 
        // submenus, unless while dropping.  But the dropping case
        // is handled in HitTest, not here.  So don't deal with that
        // here.

        // Is this because an accelerator key was hit?
        if (pnmhot->dwFlags & HICF_ACCELERATOR)
        {
            KillPopupTimer();
            KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
            // Yes; now that TBSTYLE_DROPDOWN is used, let _DropDownOrExec handle it
            // in response to TBN_DROPDOWN.
        }
        // Is this because direction keys were hit?
        else if (pnmhot->dwFlags & HICF_ARROWKEYS)
        {
            // Yes
            KillPopupTimer();
            KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);

            if (!_fVerticalMB && 
                _HandleObscuredItem(pnmhot->idNew))
            {
                lres = 1;
            }
            else
            {
                // It doesn't make sense that we would get these keyboard
                // notifications if there is a submenu open...it should get
                // the messages
                ASSERT(!_pcmb->_fInSubMenu);
                v_SendMenuNotification(pnmhot->idNew, FALSE);

                // Since the only way that the chevron can get the highlight is
                // through a keyboard down, then we expand.
                if (_fHasDemotedItems && pnmhot->idNew == (int)_idCmdChevron)
                {
                    v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
                    Expand(TRUE);
                    lres = 1;       // We already handled the hot item change
                }
            }

            _pcmb->_pmbState->HideTooltip(FALSE);
            _SetTimer(MBTIMER_INFOTIP);
        }
        // Is this because the mouse moved or an explicit sendmessage?
        else if (!(pnmhot->dwFlags & HICF_LEAVING) && 
                 (pnmhot->idNew != _pcmb->_nItemCur || // Ignore if we're moving over same item
                  (_nItemTimer != -1 && _pcmb->_nItemCur == pnmhot->idNew)))     // we need to go through here to reset if the user went back to the cascaded guy
        {
            // Yes
            if (!_fVerticalMB)    // Horizontal menus will always have an underlying hmenu
            {
                if (_HandleObscuredItem(pnmhot->idNew))
                {
                    lres = 1;
                }
                else if (_pcmb->_fInSubMenu)
                {
                    // Only popup a menu since we're already in one (as mouse
                    // moves across bar).

                    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHG: Posting CMBPopup message", this);
                    PostPopup(pnmhot->idNew, FALSE, _pcmb->_fKeyboardSelected);  // Will handle menu notification on receipt of message
                }
                else
                    v_SendMenuNotification(pnmhot->idNew, FALSE);
            }
            else if (!_fEditMode)
            {
                v_SendMenuNotification(pnmhot->idNew, FALSE);

                // check to see if we have just entered a new item and it is a sub-menu...

                // Did we already set a timer?
                if (-1 != _nItemTimer)
                {
                    // Yes; kill it b/c the mouse moved to another item
                    KillPopupTimer();
                }

                // if we're not over the currently expanded guy
                // Have we moved over an item that expands OR
                // are we moving away from a cascaded item?
                DWORD dwFlags = v_GetFlags(pnmhot->idNew);
                // Reset the stupid user timer
                KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);

                // UEMStuff
                if (!(dwFlags & SMIF_SUBMENU))
                {
                    _SetTimer(MBTIMER_UEMTIMEOUT);
                    _FireEvent(UEM_HOT_ITEM);
                }

                if ( (pnmhot->dwFlags & HICF_MOUSE) && _pcmb->_nItemCur != pnmhot->idNew) 
                {
                    if (dwFlags & SMIF_SUBMENU || _pcmb->_fInSubMenu)
                    {
                        // Is this the only item in the menu?
                        if ( _cPromotedItems == 1 && 
                            !(_fHasDemotedItems && _pcmb->_fExpanded) && 
                            dwFlags & SMIF_SUBMENU)
                        {
                            // Yes; Then we want to pop it open immediatly, 
                            // instead of waiting for the timeout
                            PostPopup(pnmhot->idNew, FALSE, FALSE);
                        }
                        else if (_SetTimer(MBTIMER_POPOUT))
                        {
                            // No; fire a timer to open/close the submenu
                            TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHG: Starting timer for id=%d", this, pnmhot->idNew);
                            if (v_GetFlags(pnmhot->idNew) & SMIF_SUBMENU)
                                _nItemTimer = pnmhot->idNew;
                            else
                                _nItemTimer = -1;
                        }
                    }
                    
                    if (_fHasDemotedItems && pnmhot->idNew == (int)_idCmdChevron)
                    {
                        _SetTimer(MBTIMER_EXPAND);
                    }

                    _pcmb->_pmbState->HideTooltip(FALSE);
                    _SetTimer(MBTIMER_INFOTIP);
                }

            }
        }
        else if (pnmhot->dwFlags & HICF_LEAVING)
        {
            v_SendMenuNotification(pnmhot->idOld, TRUE);

            if (-1 != _nItemTimer && !_fEditMode)
            {
                // kill the cascading menu popup timer...
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHG: Killing timer", this);
            
                KillPopupTimer();
            }
            _pcmb->_pmbState->HideTooltip(FALSE);
        }

        if ( !(pnmhot->dwFlags & HICF_LEAVING) )
            _pcmb->_SiteOnSelect(MPOS_CHILDTRACKING);
    }

    return lres;
}    

void CMenuToolbarBase::s_FadeCallback(DWORD dwStep, LPVOID pvParam)
{
    CMenuToolbarBase* pmtb = (CMenuToolbarBase*)pvParam;

    if (pmtb && dwStep == FADE_BEGIN)    // Paranoia
    {
        // Command has been posted.  Exit menu.
        pmtb->_pcmb->_SiteOnSelect(MPOS_EXECUTE);
    }
}   

LRESULT CMenuToolbarBase::_DropDownOrExec(UINT idCmd, BOOL bKeyboard)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _DropDownOrExec %d", this, idCmd);

    // Don't do anything when we're in edit mode
    if (_fEditMode)
        return 0;

    if ( v_GetFlags(idCmd) & SMIF_SUBMENU )
    {
        v_SendMenuNotification(idCmd, FALSE);
        
        PostPopup(idCmd, FALSE, bKeyboard);
    }
    else if (idCmd != -1)
    {
        RECT rc;
        AddRef();   // I might get released in the call.

        // Fading Selection
        IEPlaySound(TEXT("MenuCommand"), TRUE);
        SendMessage(_hwndMB, TB_GETRECT, idCmd, (LPARAM)&rc);
        MapWindowPoints(_hwndMB, HWND_DESKTOP, (POINT*)&rc, 2);

        if (!(GetKeyState(VK_SHIFT) < 0))
        {
            // Were we able to fade?
            if (!_pcmb->_pmbState->FadeRect(&rc, s_FadeCallback, this))
            {
                // No; Then we blow away the menus here instead of the Fade callback
                // Command has been posted.  Exit menu.
                _pcmb->_SiteOnSelect(MPOS_EXECUTE);
            }
        }

        if (g_dwProfileCAP & 0x00002000) 
            StartCAP();
        v_ExecItem(idCmd);
        if (g_dwProfileCAP & 0x00002000) 
            StopCAP();

        Release();
    }
    else
        MessageBeep(MB_OK);

    return 0;
}


/*----------------------------------------------------------
Purpose: Handles TBN_DROPDOWN, which is sent on the button-down.

*/
LRESULT CMenuToolbarBase::_OnDropDown(LPNMTOOLBAR pnmtb)
{
    DWORD dwInput = _fTopLevel ? 0 : -1;    // -1: don't track, 0: do
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    LRESULT lres = 0;

    // Expected behavior with the mouse:
    //
    // 1) For cascading menuitems-
    //    a) expand on button-down
    //    b) collapse on button-up (horizontal menu only)
    //    c) if the button-down occurs on the item that is
    //       already selected, then assume the click indicates
    //       a drag/drop scenario
    // 2) For other menuitems-
    //    a) execute on button-up

#ifdef DEBUG
    if (_fTopLevel) {
        // browser menu comes thru here; start menu goes elsewhere (via tray.c)
        //ASSERT(!_fVertical);
        TraceMsg(DM_MISC, "cmtbb._odd: _fTopLevel(1) mouse=%d", GetKeyState(VK_LBUTTON) < 0);
    }
#endif
    // Is this because the mouse button was used?
    if (GetKeyState(VK_LBUTTON) < 0)
    {
        // Yes

        // Assume it won't be handled.  This will allow the toolbar
        // to see the button-down as a potential drag and drop.
        lres = TBDDRET_TREATPRESSED;

        // Clicking on same item that is currently expanded?
        if (pnmtb->iItem == _pcmb->_nItemCur)
        {

            // Is this horizontal?
            if (!_fVerticalMB)
            {
                // Yes; toggle the dropdown
                _pcmb->_SubMenuOnSelect(MPOS_FULLCANCEL);
                
                // Say it is handled, so the button will toggle
                lres = TBDDRET_DEFAULT;
            }
            
            _fClickHandled = TRUE;
            
            // Otherwise don't do anything more, user might be starting a 
            // drag-drop procedure on the cascading menuitem
        }
        else
        {
            if (v_GetFlags(pnmtb->iItem) & SMIF_SUBMENU)
            {
                // Handle on the button-down
                _fClickHandled = TRUE;
                lres = _DropDownOrExec(pnmtb->iItem, FALSE);
            }
        }

        if (dwInput != -1)
            dwInput = UIBL_INPMOUSE;
    }
    else
    {
        // No; must be the keyboard
        _fClickHandled = TRUE;
        lres = _DropDownOrExec(pnmtb->iItem, TRUE);

        if (dwInput != -1)
            dwInput = UIBL_INPMENU;
    }

    // browser menu (*not* start menu) alt+key, mouse
    if (dwInput != -1)
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, dwInput);

    return lres;
}    


/*----------------------------------------------------------
Purpose: Handle WM_KEYDOWN/WM_KEYUP

Returns: TRUE if handled
*/
BOOL CMenuToolbarBase::_OnKey(BOOL bDown, UINT vk, UINT uFlags)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    int idCmd;
    HWND hwnd = _hwndMB;

    _pcmb->_pmbState->SetKeyboardCue(TRUE);

    //
    // If the menu window is RTL mirrored, then the arrow keys should
    // be mirrored to reflect proper cursor movement. [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwnd))
    {
        switch (vk)
        {
        case VK_LEFT:
          vk = VK_RIGHT;
          break;

        case VK_RIGHT:
          vk = VK_LEFT;
          break;
        }
    }

    switch (vk)
    {
    case VK_LEFT:
        if (_fVerticalMB)
        {
            _pcmb->_SiteOnSelect(MPOS_SELECTLEFT);
            return TRUE;
        }
        break;

    case VK_RIGHT:
        if (_fVerticalMB)
            goto Cascade;
        break;

    case VK_DOWN:
    case VK_UP:
        if (!_fVerticalMB)
        {
Cascade:
            idCmd = GetButtonCmd(hwnd, ToolBar_GetHotItem(hwnd));
            if (v_GetFlags(idCmd) & SMIF_SUBMENU)
            {
                // Enter the submenu
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnKey: Posting CMBPopup message", this);
                
                PostPopup(idCmd, FALSE, TRUE);
            }
            else if (VK_RIGHT == vk)
            {
                // Nothing to cascade to, move to next sibling menu
                _pcmb->_SiteOnSelect(MPOS_SELECTRIGHT);
            }
            return TRUE;
        }
        else
        {
#if 0
            _pcmb->_OnSelectArrow(vk == VK_UP? -1 : 1);
            return TRUE;
#endif
        }
        break;

    case VK_SPACE:

        if (!_pcmb->_fExpanded && _fHasDemotedItems)
        {
            v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
            Expand(TRUE);
        }
        else
        {
            // Toolbars map the spacebar to VK_RETURN.  Menus don't except
            // in the horizontal menubar.
            if (_fVerticalMB)
                MessageBeep(MB_OK);
        }
        return TRUE;

#if 0
    case VK_RETURN:
        // Handle this now, rather than letting the toolbar handle it.
        // This way we don't have to rely on WM_COMMAND, which doesn't
        // convey whether it was invoked by the keyboard or the mouse.
        idCmd = GetButtonCmd(hwnd, ToolBar_GetHotItem(hwnd));
        _DropDownOrExec(idCmd, TRUE);
        return TRUE;
#endif
    }

    return FALSE;
}    

/*----------------------------------------------------------
Purpose: There are two flavors of this function: _DoPopup and
         PostPopup.  Both cancel the existing submenu (relative 
         to this band) and pops open a new submenu.  _DoPopup
         does it atomically.  PostPopup posts a message to
         handle it.

*/
void CMenuToolbarBase::_DoPopup(int idCmd, BOOL bInitialSelect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (-1 != idCmd)
    {
        PopupHelper(idCmd, bInitialSelect);
    }
}    


/*----------------------------------------------------------
Purpose: See the _DoPopup comment
*/
void CMenuToolbarBase::PostPopup(int idCmd, BOOL bSetItem, BOOL bInitialSelect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (-1 != idCmd)
    {
        _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
        _pcmb->SetTracked(this);
        HWND hwnd = _pcmb->_pmbState->GetSubclassedHWND();

        PostMessage(hwnd? hwnd: _hwndMB, g_nMBPopupOpen, idCmd, MAKELPARAM(bSetItem, bInitialSelect));
    }
}    


/*----------------------------------------------------------
Purpose: Helper function to finally invoke submenu.  Use _DoPopup
         or PostPopup
*/
void CMenuToolbarBase::PopupHelper(int idCmd, BOOL bInitialSelect)
{
    // We do not want to pop open a sub menu if we are not displayed. This is especially
    // a problem during drag and drop.
    if (_fShowMB)
    {
        _pcmb->_nItemNew = idCmd;
        ASSERT(-1 != _pcmb->_nItemNew);
        _pcmb->SetTracked(this);
        _pcmb->_fPopupNewMenu = TRUE;
        _pcmb->_fInitialSelect = BOOLIFY(bInitialSelect);
        _pcmb->UIActivateIO(TRUE, NULL);
        _FireEvent(UEM_HOT_FOLDER);
        _SetTimer(MBTIMER_UEMTIMEOUT);
    }
}

void    CMenuToolbarBase::_PaintButton(HDC hdc, int idCmd, LPRECT prc, DWORD dwSMIF)
{
    if (!_pcmb->_fExpanded)
        return;

    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    RECT rcClient;
    GetClientRect(_hwndMB, &rcClient);
#ifndef DRAWEDGE
    // Draw Left Edge
    HPEN hPenOld = (HPEN)SelectObject(hdc, _pcmb->_pmbm->_hPenHighlight);
    MoveToEx(hdc, prc->left, prc->top, NULL);
    LineTo(hdc, prc->left, prc->bottom);
#endif

    if (!(dwSMIF & SMIF_DEMOTED))
    {
#ifdef DRAWEDGE
        DWORD dwEdge = BF_RIGHT;

        // Don't paint the edge next to the bitmap.
        if (_uIconSizeMB == ISFBVIEWMODE_SMALLICONS)
            dwEdge |= BF_LEFT;


        RECT rc = *prc;
#else
        // Draw Right Edge:
        SelectObject(hdc, _pcmb->_pmbm->_hPenShadow);
        MoveToEx(hdc, prc->right-1, prc->top, NULL);
        LineTo(hdc, prc->right-1, prc->bottom);
#endif

        HWND hwnd = _hwndMB;
        int iPos = ToolBar_CommandToIndex(hwnd, idCmd);
        if (iPos == -1)
        {
            iPos = ToolBar_ButtonCount(hwnd) - 1;
        }

        if (iPos >= 0)
        {
            int iNumButtons = ToolBar_ButtonCount(hwnd);
            int idCmd2 = GetButtonCmd(hwnd, iPos + 1);
            CMenuToolbarBase* pmtb = this;
            BOOL    fOverflowed = FALSE;

            // Situations for Drawing the Bottom line
            // 1) This button is at the bottom.
            // 2) This button is at the bottom and the toolbar
            //      below is not visible (_fDontShowEmpty).
            // 3) This button is at the bottom and the button
            //      at the top of the bottom toolbar is demoted.
            // 4) The button below this one in the toolbar is
            //      demoted.
            // 5) The botton below this one is demoted and we're
            //      not expanded
    
            if (iPos + 1 >= iNumButtons)
            {
                if (_pcmb->_pmtbBottom != this &&
                    !_pcmb->_pmtbBottom->_fDontShowEmpty)
                {
                    pmtb = _pcmb->_pmtbBottom;
                    hwnd = pmtb->_hwndMB;
                    idCmd2 = GetButtonCmd(hwnd, 0);
                }
                else
                    fOverflowed = TRUE;
            }
            else if (prc->bottom == rcClient.bottom &&
                _pcmb->_pmtbBottom == this)   // This button is at the top.
                fOverflowed = TRUE;


            DWORD dwFlags = pmtb->v_GetFlags(idCmd2);

            if ((_pcmb->_fExpanded && dwFlags & SMIF_DEMOTED) || 
                 fOverflowed)
            {
#ifdef DRAWEDGE
                dwEdge |= BF_BOTTOM;
#else
                int iLeft = prc->left;
                if (iPos != iNumButtons - 1)   
                    iLeft ++;   // Move the next line in.

                MoveToEx(hdc, iLeft, prc->bottom-1, NULL);
                LineTo(hdc, prc->right-1, prc->bottom-1);
#endif
            }

            // Situations for Drawing the Top line
            // 1) This button is at the top.
            // 2) This button is at the top and the toolbar
            //      above is not visible (_fDontShowEmpty).
            // 3) This button is at the top and the button
            //      at the bottom of the top toolbar is demoted.
            // 4) The button above this one in the toolbar is
            //      demoted.
            // 5) If the button above this is demoted, and we're
            //      not expanded

            fOverflowed = FALSE; 

            if (iPos - 1 < 0)
            {
                if (_pcmb->_pmtbTop != this && 
                    !_pcmb->_pmtbTop->_fDontShowEmpty)
                {
                    pmtb = _pcmb->_pmtbTop;
                    hwnd = pmtb->_hwndMB;
                    idCmd2 = GetButtonCmd(hwnd, ToolBar_ButtonCount(hwnd) - 1);
                }
                else
                    fOverflowed = TRUE; // There is nothing at the top of this menu, draw the line.
            }
            else
            {
                hwnd = _hwndMB;
                idCmd2 = GetButtonCmd(hwnd, iPos - 1);
                pmtb = this;

                if (prc->top == rcClient.top &&
                    _pcmb->_pmtbTop == this)   // This button is at the top.
                    fOverflowed = TRUE;
            }

            dwFlags = pmtb->v_GetFlags(idCmd2);

            if ((_pcmb->_fExpanded && dwFlags & SMIF_DEMOTED) ||
                fOverflowed)
            {
#ifdef DRAWEDGE
                dwEdge |= BF_TOP;
#else
                SelectObject(hdc, _pcmb->_pmbm->_hPenHighlight);
                MoveToEx(hdc, prc->left, prc->top, NULL);
                LineTo(hdc, prc->right-1, prc->top);
#endif
            }
        }

#ifdef DRAWEDGE
        DrawEdge(hdc, &rc, BDR_RAISEDINNER, dwEdge);
#endif
    }

#ifndef DRAWEDGE
    SelectObject(hdc, hPenOld);
#endif
}

LRESULT CMenuToolbarBase::_OnCustomDraw(NMCUSTOMDRAW * pnmcd)
{
    // Make it look like a menu
    NMTBCUSTOMDRAW * ptbcd = (NMTBCUSTOMDRAW *)pnmcd;
    DWORD dwRet = 0;
        
    // Edit mode never hot tracks, and the selected item being
    // moved has a black frame around it.  Items that cascade are 
    // still highlighted normally, even in edit mode.

    DWORD dwSMIF = v_GetFlags((UINT)pnmcd->dwItemSpec);

    switch(pnmcd->dwDrawStage)
    {
    case CDDS_PREPAINT:
        dwRet = CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
        break;

    case CDDS_ITEMPREPAINT:
        if (_fVerticalMB)
        {
            if (pnmcd->dwItemSpec == -1)
            {
                // a -1 is sent with a seperator
                RECT rc = pnmcd->rc;
                rc.top += 3;    // Hard coded in toolbar.
                rc.left += GetSystemMetrics(SM_CXEDGE);
                rc.right -= GetSystemMetrics(SM_CXEDGE);
                DrawEdge(pnmcd->hdc, &rc, EDGE_ETCHED, BF_TOP);

                _PaintButton(pnmcd->hdc, -1, &pnmcd->rc, dwSMIF);

                dwRet = CDRF_SKIPDEFAULT;
            }
            else
            {
                ptbcd->clrText = _pcmb->_pmbm->_clrMenuText;

                // This is for Darwin Ads.
                if (dwSMIF & SMIF_ALTSTATE)
                {
                    ptbcd->clrText = GetSysColor(COLOR_BTNSHADOW);
                }

                ptbcd->rcText.right = ptbcd->rcText.right - _pcmb->_pmbm->_cxMargin;
                ptbcd->clrBtnFace = _pcmb->_pmbm->_clrBackground;
                if (_fHasSubMenu)
                    ptbcd->rcText.right -= _pcmb->_pmbm->_cxArrow;

                if ( _fHasDemotedItems && _idCmdChevron == (int)pnmcd->dwItemSpec)
                {
                    _DrawChevron(pnmcd->hdc, &pnmcd->rc, 
                        (BOOL)(pnmcd->uItemState & CDIS_HOT) ||
                         (BOOL)(pnmcd->uItemState & CDIS_MARKED), 
                        (BOOL)(pnmcd->uItemState & CDIS_SELECTED) );

                    dwRet |= CDRF_SKIPDEFAULT;

                }
                else
                {
#ifdef MARK_DRAGGED_ITEM
                    // We have no good way to undo this on a multi pane drop.
                    if (_idCmdDragging != -1 &&
                        _idCmdDragging == (int)pnmcd->dwItemSpec)
                        pnmcd->uItemState |= CDIS_HOT;
#endif

                    // Yes; draw with highlight
                    if (pnmcd->uItemState & (CDIS_CHECKED | CDIS_SELECTED | CDIS_HOT))
                    {
#ifdef UNIX
                        if( MwCurrentLook() == LOOK_MOTIF )
                            SelectMotifMenu(pnmcd->hdc, &pnmcd->rc, TRUE );
                        else
#endif
                        {
                            ptbcd->clrHighlightHotTrack = GetSysColor(COLOR_HIGHLIGHT);
                            ptbcd->clrBtnFace = GetSysColor(COLOR_HIGHLIGHT);
                            ptbcd->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                            dwRet |= TBCDRF_HILITEHOTTRACK;
                        }
                    }


                    // Is this menu empty?
                    if (_fEmpty)
                    {
                        // Yes, draw the empty string as disabled.
                        pnmcd->uItemState |= CDIS_DISABLED;
                        ptbcd->clrText = ptbcd->clrBtnFace;

                        // Don't draw the etched effect if it is selected
                        if (pnmcd->uItemState & CDIS_HOT)
                            dwRet |= TBCDRF_NOETCHEDEFFECT;
                    }

                    // When this item is demoted, we only want to paint his background
                    // then we are in edit mode _OR_ it is not selected, checked or hot.
                    if (dwSMIF & SMIF_DEMOTED)
                    {
                        BOOL fDrawDemoted = TRUE;
                        if (_fEditMode)
                            fDrawDemoted = TRUE;

                        if (pnmcd->uItemState & (CDIS_CHECKED | CDIS_SELECTED | CDIS_HOT))
                            fDrawDemoted = FALSE;

                        if (fDrawDemoted)
                        {
                            ptbcd->clrBtnFace = _pcmb->_pmbm->_clrDemoted;
                            SHFillRectClr(pnmcd->hdc, &pnmcd->rc, ptbcd->clrBtnFace);
                        }
                    }

                    // We draw our own highlighting
                    dwRet |= (TBCDRF_NOEDGES | TBCDRF_NOOFFSET);
                }
            }
        }
        else
        {
            // If g_fRunOnMemphis or g_fRunOnNT5 are not defined then the menus will
            // never be grey.
            if (!_pcmb->_fAppActive)
                // menus from user use Button Shadow for non active menus
                ptbcd->clrText = GetSysColor(COLOR_3DSHADOW);
            else
                ptbcd->clrText = _pcmb->_pmbm->_clrMenuText;

            // If we're in high contrast mode, make the menu bar look like
            // veritcal items on select.
            if (_pcmb->_pmbm->_fHighContrastMode)
            {
                // Yes; draw with highlight
                if (pnmcd->uItemState & (CDIS_CHECKED | CDIS_SELECTED | CDIS_HOT))
                {
#ifdef UNIX
                    if( MwCurrentLook() == LOOK_MOTIF )
                        SelectMotifMenu(pnmcd->hdc, &pnmcd->rc, TRUE );
                    else
#endif
                    {
                        ptbcd->clrHighlightHotTrack = GetSysColor(COLOR_HIGHLIGHT);
                        ptbcd->clrBtnFace = GetSysColor(COLOR_HIGHLIGHT);
                        ptbcd->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                        dwRet |= TBCDRF_HILITEHOTTRACK;
                    }
                }
            }
        }
        dwRet |= CDRF_NOTIFYPOSTPAINT | TBCDRF_NOMARK;
        break;
    case CDDS_ITEMPOSTPAINT:
        if (_fVerticalMB)
        {
            RECT rc = pnmcd->rc;
            COLORREF rgbText;
            if (pnmcd->uItemState & (CDIS_SELECTED | CDIS_HOT))
                rgbText = GetSysColor( COLOR_HIGHLIGHTTEXT );
            else
                rgbText = _pcmb->_pmbm->_clrMenuText;

            // Is this item Checked?
            if (dwSMIF & SMIF_CHECKED)
            {
                rc.right = rc.left + (rc.bottom - rc.top);
                _DrawMenuGlyph(pnmcd->hdc, _pcmb->_pmbm->_hFontArrow
                    , &rc, CH_MENUCHECKA, rgbText, NULL);
                rc = pnmcd->rc;
            }
    
            // Is this a cascading item?
            if (dwSMIF & SMIF_SUBMENU)
            {
                // Yes; draw the arrow
                RECT rcT = rc;
        
                rcT.left = rcT.right - _pcmb->_pmbm->_cxArrow;
                _DrawMenuArrowGlyph(pnmcd->hdc, &rcT, rgbText);
            }

            _PaintButton(pnmcd->hdc, (UINT)pnmcd->dwItemSpec, &rc, dwSMIF);
        }
        break;
    case CDDS_PREERASE:
        {
            RECT rcClient;
            GetClientRect(_hwndMB, &rcClient);
            ptbcd->clrBtnFace = _pcmb->_pmbm->_clrBackground;
            SHFillRectClr(pnmcd->hdc, &rcClient, _pcmb->_pmbm->_clrBackground);
            dwRet = CDRF_SKIPDEFAULT;
        }
        break;
    }
    return dwRet;
}    



void CMenuToolbarBase::_PressBtn(int idBtn, BOOL bDown)
{
    if (!_fVerticalMB)
    {
        DWORD dwState = ToolBar_GetState(_hwndMB, idBtn);

        if (bDown)
            dwState |= TBSTATE_PRESSED;
        else
            dwState &= ~TBSTATE_PRESSED;

        ToolBar_SetState(_hwndMB, idBtn, dwState);

        // Avoid ugly late repaints
        UpdateWindow(_hwndMB);
    }
}    


/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent method

         Processes messages passed on from the menuband.
*/
STDMETHODIMP CMenuToolbarBase::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = S_FALSE;

    EnterModeless();

    switch (uMsg)
    {
    case WM_SETTINGCHANGE:
        if ((SHIsExplorerIniChange(wParam, lParam) == EICH_UNKNOWN) || 
            (wParam == SPI_SETNONCLIENTMETRICS))
        {
            v_UpdateIconSize(-1, TRUE);
            v_Refresh();
            goto L_WM_SYSCOLORCHANGE;
        }
        break;

    case WM_SYSCOLORCHANGE:
    L_WM_SYSCOLORCHANGE:
        ToolBar_SetInsertMarkColor(_hwndMB, GetSysColor(COLOR_MENUTEXT));
        SendMessage(_hwndMB, uMsg, wParam, lParam);
        InvalidateRect(_hwndMB, NULL, TRUE);
        hres = S_OK;
        break;

    case WM_PALETTECHANGED:
        InvalidateRect( _hwndMB, NULL, FALSE );
        SendMessage( _hwndMB, uMsg, wParam, lParam );
        hres = S_OK;
        break;

    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        hres = S_OK;
        break;
    }

    ExitModeless();

    return hres;
}


void CMenuToolbarBase::v_CalcWidth(int* pcxMin, int* pcxMax)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    ASSERT(IS_VALID_WRITE_PTR(pcxMin, int));
    ASSERT(IS_VALID_WRITE_PTR(pcxMax, int));

     
    *pcxMin = 0;
    *pcxMax = 0;

    if (_fVerticalMB && _pcmb->_pmbm && _pcmb->_pmbm->_hFontMenu)
    {
        HIMAGELIST himl;
        int cel;
        int cxItemMax = 0;
        HWND hwnd = _hwndMB;
        
        ASSERT(hwnd);
        
        HDC hdc = GetDC(hwnd);

        if (hdc)
        {
            HFONT hFontOld = (HFONT) SelectObject(hdc, _pcmb->_pmbm->_hFontMenu);

            if (hFontOld)
            {
                TCHAR sz[MAX_PATH];
                cel = ToolBar_ButtonCount(hwnd);

                // Find the maximum length text
                for(int i = 0; i < cel; i++)
                {
                    int idCmd = GetButtonCmd(hwnd, i);
                    if (_idCmdChevron != idCmd &&
                        !(!_pcmb->_fExpanded && v_GetFlags(idCmd) & SMIF_DEMOTED) &&
                        SendMessage(hwnd, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                    {
                        RECT rect = {0};
                        DWORD dwDTFlags = DT_CALCRECT | DT_SINGLELINE | DT_LEFT | DT_VCENTER;
                        if (ShowAmpersand())
                            dwDTFlags |= DT_NOPREFIX;
                        DrawText(hdc, sz, -1, &rect, dwDTFlags);
                        cxItemMax = max(rect.right, cxItemMax);
                    }
                }

                SelectObject(hdc, hFontOld);
            }
            ReleaseDC(hwnd, hdc);
        }
        
        himl = (HIMAGELIST)SendMessage(hwnd, TB_GETIMAGELIST, 0, 0);
        if (himl)
        {
            int cy;
            
            // Start with the width of the button
            ImageList_GetIconSize(himl, pcxMin, &cy);

            // We want at least a bit of space around the icon
            if (_uIconSizeMB != ISFBVIEWMODE_SMALLICONS)
            {
                // Old FSMenu code took the height of the larger of 
                // the icon and text then added 2.
                ToolBar_SetPadding(hwnd, 0, 0);
                *pcxMin += 10;
            }
            else 
            {
                // Old FSMenu code took the height of the larger of 
                // the icon and text then added cySpacing, which defaults to 6.
                ToolBar_SetPadding(hwnd, 0, 4);
                *pcxMin += 3 * GetSystemMetrics(SM_CXEDGE);
            }
        }

        
        RECT rect = {0};
        int cxDesired = _pcmb->_pmbm->_cxMargin + cxItemMax + _pcmb->_pmbm->_cxArrow;
        int cxMax = 0;
           
        if (SystemParametersInfoA(SPI_GETWORKAREA, 0, &rect, 0))
        {
            // We're figuring a third of the screen is a good max width
            cxMax = (rect.right-rect.left) / 3;
        }

        *pcxMin += min(cxDesired, cxMax) + LIST_GAP;
        *pcxMax = *pcxMin;
    }
    TraceMsg(TF_MENUBAND, "CMenuToolbarBase::v_CalcWidth(%d, %d)", *pcxMin, *pcxMax);
}


void CMenuToolbarBase::_SetToolbarState()
{
    SHSetWindowBits(_hwndMB, GWL_STYLE, TBSTYLE_LIST, TBSTYLE_LIST);
}


void CMenuToolbarBase::v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    POINT pt;
    
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    GetWindowRect(_hwndMB, &rc);

    if (PtInRect(&rc, pt))
    {
        ScreenToClient(_hwndMB, &pt);
        SendMessage(_hwndMB, uMsg, wParam, MAKELONG(pt.x, pt.y));
    }
}

void CMenuToolbarBase::NegotiateSize()
{
    RECT rc;
    GetClientRect(GetParent(_hwndMB), &rc);
    _pcmb->OnPosRectChangeDB(&rc);

    // If we came in here it's because the Menubar did not change sizes or position.

}

void CMenuToolbarBase::SetParent(HWND hwndParent) 
{ 
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (hwndParent)
    {
        if (!_hwndMB)
            CreateToolbar(hwndParent);
    }
    else
    {
        // As an optimization, we implement "disowning" ourselves
        // as just moving ourselves offscreen.  The previous parent
        // still owns us.  The parent is invariably the menusite.
        RECT rc = {-1,-1,-1,-1};
        SetWindowPos(NULL, &rc, 0);
    }

    // We want to set the parent all the time because we don't want to destroy the 
    // window with it's parent..... Sizing to -1,-1,-1,-1 causes it not to be displayed.
    if (_hwndMB)
    {
        ::SetParent(_hwndMB, hwndParent); 
        SendMessage(_hwndMB, TB_SETPARENT, (WPARAM)hwndParent, NULL);
    }
}


void CMenuToolbarBase::v_OnEmptyToolbar()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    for (int iNumButtons = ToolBar_ButtonCount(_hwndMB) -1;
         iNumButtons >= 0; 
         iNumButtons--)
    {
        // HACKHACK (lamadio): For some reason, _fEmptyingToolbar gets set to FALSE.
        // We then Do a TB_DELETEBUTTON, which sends a notify. This does go through on
        // the top level menubands (Start Menu, Browser menu bar), and deletes the 
        // associated data. We then try and delete it again.
        // So now, I set null into the sub menu, so that the other code gracefully fails.

        TBBUTTONINFO tbbi;
        tbbi.cbSize = SIZEOF(tbbi);
        tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
        ToolBar_GetButtonInfo(_hwndMB, iNumButtons, &tbbi);

        LPVOID pData = (LPVOID)tbbi.lParam;
        tbbi.lParam = NULL;

        ToolBar_SetButtonInfo(_hwndMB, iNumButtons, &tbbi);

        SendMessage(_hwndMB, TB_DELETEBUTTON, iNumButtons, 0);
        v_OnDeleteButton(pData);
    }
}

void CMenuToolbarBase::EmptyToolbar()
{
    if (_hwndMB)
    {
        _fEmptyingToolbar = TRUE;
        v_OnEmptyToolbar();
        _fEmptyingToolbar = FALSE;
    }
}

void CMenuToolbarBase::v_Close()
{
    EmptyToolbar();
    if (_hwndMB)
    {
        //Kill timers to prevent race condition
        KillTimer(_hwndMB, MBTIMER_POPOUT);
        KillTimer(_hwndMB, MBTIMER_DRAGOVER);
        KillTimer(_hwndMB, MBTIMER_EXPAND);
        KillTimer(_hwndMB, MBTIMER_ENDEDIT);
        KillTimer(_hwndMB, MBTIMER_CLOSE);
        KillTimer(_hwndMB, MBTIMER_CLICKUNHANDLE);
        KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);

        DestroyWindow(_hwndMB);
        _hwndMB = NULL;
    }
}

void CMenuToolbarBase::Activate(BOOL fActivate)
{
    if (fActivate == FALSE)
    {
        _fEditMode = FALSE;
    }
}

int CMenuToolbarBase::_CalcChevronSize()
{

    int dSeg;
    int dxy = _pcmb->_pmbm->_cyChevron;

    dxy -= 4;
    dSeg = dxy / 4;

    return dSeg * 4 + 4;
}

void CMenuToolbarBase::_DrawChevron(HDC hdc, LPRECT prect, BOOL fFocus, BOOL fSelected)
{
    RECT rcBox = *prect;
    RECT rcDrop;

    const int dExtra = 3;
    int dxy;

    rcBox.left += dExtra;
    rcBox.right -= dExtra;
    dxy = _CalcChevronSize();

    rcDrop.left = ((rcBox.right + rcBox.left) >> 1) - (dxy/4);
    rcDrop.right = rcDrop.left + dxy - 1;

    int dSeg = ((RECTWIDTH(rcDrop) - 2) >> 2);

    rcDrop.top = (rcBox.top + rcBox.bottom)/2 - (2 * dSeg + 1);
    //rcDrop.bottom = rcBox.top;

    if (fFocus)
    {
        InflateRect(&rcBox, 0, -3);
        SHFillRectClr(hdc, &rcBox, _pcmb->_pmbm->_clrDemoted);
        DrawEdge(hdc, &rcBox, fSelected? BDR_SUNKENINNER : BDR_RAISEDINNER, BF_RECT);

        if (fSelected)
        {
            rcDrop.top += 1;
            rcDrop.left += 1;
        }
    }

    HBRUSH hbrOld = SelectBrush(hdc, _pcmb->_pmbm->_hbrText);


    int y = rcDrop.top + 1;
    int xBase = rcDrop.left+ dSeg;

    for (int x = -dSeg; x <= dSeg; x++)
    {
        PatBlt(hdc, xBase + x, y, 1, dSeg, PATCOPY);
        PatBlt(hdc, xBase + x, y+(dSeg<<1), 1, dSeg, PATCOPY);

        y += (x >= 0) ? -1 : 1;
    }

    SelectBrush(hdc, hbrOld);
}


// Takes into accout Separators, hidden and Disabled items
/*----------------------------------------------------------
Purpose: This function sets the nearest legal button to be
         the hot item, skipping over any separators, or hidden
         or disabled buttons.
    

*/

int CMenuToolbarBase::GetValidHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags)
{
    if (iIndex == MBSI_LASTITEM)
    {
        // -2 is special value meaning "last item on toolbar"
        int cButtons = (int)SendMessage(_hwndMB, TB_BUTTONCOUNT, 0, 0);
        iIndex = cButtons - 1;
    }

    while ( (iCount == -1 || iIndex < iCount) && iIndex >= 0)
    {
        TBBUTTON tbb;

        // Toolbar will trap out of bounds condition when iCount is -1
        if (!SendMessage(_hwndMB, TB_GETBUTTON, iIndex, (LPARAM)&tbb))
            return -1;

        int idCmd = GetButtonCmd(_hwndMB, iIndex);


        if (tbb.fsState & TBSTATE_ENABLED && 
            !(tbb.fsStyle & TBSTYLE_SEP || 
              tbb.fsState & TBSTATE_HIDDEN) &&
              !(v_GetFlags(idCmd) & SMIF_DEMOTED && !_pcmb->_fExpanded) )
        {
            return iIndex;
        }
        else
            iIndex += iDir;
    }

    return -1;
}

BOOL CMenuToolbarBase::SetHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags)
{
    int iPos = GetValidHotItem(iDir, iIndex, iCount, dwFlags);
    if (iPos >= 0)
        SendMessage(_hwndMB, TB_SETHOTITEM2, iPos, dwFlags);

    return (BOOL)(iPos >= 0);
}


static const BYTE g_rgsStateMap[][3] = 
{
#if defined(FIRST)
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    {  4,  1,  2},      // State 2
    { 11,  5,  2},      // State 3
    { 10,  1,  6},      // State 4
    {  7,  1,  2},      // State 5
    {  8,  1,  2},      // State 6
    { 11,  9,  2},      // State 7
    { 10,  1, 10},      // State 8
    { 11,  1,  2},      // State 9
    { 10,  1,  2},      // State 10     // End State
    { 12,  1,  2},      // State 11     // Flash.
    { 10,  1,  2},      // State 12
#elif defined(SECOND)
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    {  4,  1,  2},      // State 2
    { 11,  5,  6},      // State 3
    { 10,  5,  6},      // State 4
    {  7,  5,  6},      // State 5
    {  8,  9,  6},      // State 6
    { 11,  9,  8},      // State 7
    { 10,  9, 10},      // State 8
    { 11,  9,  8},      // State 9
    { 10, 10, 10},      // State 10     // End State
    { 10,  9,  8},      // State 11     // Flash.
    { 10,  9,  8},      // State 12
    { 10,  9,  8},      // State 13
#elif defined(THIRD)
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    { 12,  1,  2},      // State 2
    { 11,  5,  6},      // State 3
    { 10,  5,  6},      // State 4
    {  7,  5,  6},      // State 5
    { 13,  5,  6},      // State 6
    { 11,  9,  8},      // State 7
    { 10,  9, 10},      // State 8
    { 11,  9,  8},      // State 9
    { 10, 10, 10},      // State 10     // End State
    { 10,  9,  8},      // State 11     // Flash.
    {  4,  1,  2},      // State 12
    {  8,  5,  6},      // State 13
#else
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    {  4,  1,  2},      // State 2
    { 11,  5,  6},      // State 3
    { 10,  5,  6},      // State 4
    {  7,  5,  6},      // State 5
    {  8,  5,  6},      // State 6
    { 11,  9,  8},      // State 7
    { 10,  9, 10},      // State 8
    { 11,  9,  8},      // State 9
    { 10, 10, 10},      // State 10     // End State
    {  4,  3,  4},      // State 11     // Flash.
#endif
};

#define MAX_STATE 13

void CMenuToolbarBase::_FireEvent(BYTE bEvent)
{
    // We don't want to expand and cover up any dialogs.
    if (_fSuppressUserMonitor)
        return;

    if (!_fHasDemotedItems)
        return;

    if (UEM_RESET == bEvent)
    {
        TraceMsg(TF_MENUBAND, "CMTB::UEM Reset state to 0");
        _pcmb->_pmbState->SetUEMState(0);
        return;
    }

    ASSERT(bEvent >= UEM_TIMEOUT && 
            bEvent <= UEM_HOT_FOLDER);

    BYTE bOldState = _pcmb->_pmbState->GetUEMState();
    BYTE bNewState = g_rgsStateMap[_pcmb->_pmbState->GetUEMState()][bEvent];

    ASSERT(bOldState >= 0 &&  bOldState <= MAX_STATE);

    TraceMsg(TF_MENUBAND, "*** UEM OldState (%d), New State (%d) ***", bOldState, bNewState);

    _pcmb->_pmbState->SetUEMState(bNewState);

    switch (bNewState)
    {
    case 10:    // End State
        TraceMsg(TF_MENUBAND, "*** UEM Entering State 10. Expanding *** ", bOldState, bNewState);
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
        if (_pcmb->_fInSubMenu)
        {
            IUnknown_QueryServiceExec(_pcmb->_pmpSubMenu, SID_SMenuBandChild,
                &CGID_MenuBand, MBANDCID_EXPAND, 0, NULL, NULL);
        }
        else
        {
            Expand(TRUE);
        }
        _pcmb->_pmbState->SetUEMState(0);
        break;

    case 11:   // Flash
        // This gets reset when the flash is done...
        TraceMsg(TF_MENUBAND, "*** UEM Entering State 11 Flashing *** ");
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
        _FlashChevron();
        break;
    }
}


void CMenuToolbarBase::_FlashChevron()
{
    if (_idCmdChevron != -1)
    {
        _cFlashCount = 0;
        ToolBar_MarkButton(_hwndMB, _idCmdChevron, FALSE);
        SetTimer(_hwndMB, MBTIMER_FLASH, MBTIMER_FLASHTIME, NULL);
    }
}


LRESULT CMenuToolbarBase::_DefWindowProcMB(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Are we being asked for the IAccessible for the client?
    if (uMsg == WM_GETOBJECT && (OBJID_CLIENT == lParam))
    {
        // Don't process OBJID_MENU. By the time we get here, we ARE the menu.
        LRESULT lres = 0;
        CAccessible* pacc = new CAccessible(SAFECAST(_pcmb, IMenuBand*));
        if (pacc)
        {
            lres = pacc->InitAcc();
            if (SUCCEEDED((HRESULT)lres))
            {
                lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(pacc, IAccessible*));

                // The correct OLEAcc has been checked into the NT builds, so Oleacc
                // no longer assumes transfer sematics
                if (FAILED((HRESULT)lres))
                    pacc->Release();
            }
            else
            {   // Failed to initialize
                pacc->Release();
            }
        }

        return lres;
    }

    return 0;
}

void CMenuToolbarBase::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    // HACKHACK (lamadio): When we create the menubands, we do not set the
    // TOP level band's fonts until a refresh. This code here fixes it.
    if (_fFirstTime && _pcmb->_fTopLevel)
    {
        SetMenuBandMetrics(_pcmb->_pmbm);
    }

    if (fShow)
    {
        SetKeyboardCue();
        _pcmb->_pmbState->PutTipOnTop();
    }
    else
    {
        _fHasDrop = FALSE;
        KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
        KillTimer(_hwndMB, MBTIMER_INFOTIP);    // Don't show it if we're not displayed :-)
        _pcmb->_pmbState->HideTooltip(TRUE);
    }

    _fSuppressUserMonitor = FALSE;

#ifdef UNIX
    if (_fVerticalMB)
    {
        ToolBar_SetHotItem(_hwndMB, 0);
    }
#endif
}

void CMenuToolbarBase::SetKeyboardCue()
{
    if (_pcmb->_pmbState)
    {
        SendMessage(GetParent(_hwndMB), WM_CHANGEUISTATE, 
            MAKEWPARAM(_pcmb->_pmbState->GetKeyboardCue() ? UIS_CLEAR : UIS_SET,
            UISF_HIDEACCEL), 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\mnstatic.cpp ===
#include "priv.h"
#include "sccls.h"
#include "mnstatic.h"
#include "menuband.h"
#include "itbar.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "mnbase.h"
#include "oleacc.h"
#include "apithk.h"
#include "menuisf.h"

HMENU g_hmenuStopWatch = NULL;
UINT g_idCmdStopWatch = 0;

//***   IDTTOIDM -- convert idtCmd to idmMenu
// NOTES
//  as an optimization, we make the toolbar idtCmd the same as the menu idm.
// this macro (hopefully) makes things a bit clearer in the code by making
// the type conversion explicit.
#define IDTTOIDM(idtBtn)   (idtBtn)

BOOL TBHasImage(HWND hwnd, int iImageIndex);

//------------------------------------------------------------------------
//
// CMenuStaticToolbar::CMenuStaticData class
//
//------------------------------------------------------------------------


CMenuStaticToolbar::CMenuStaticData::~CMenuStaticData()
{
    ATOMICRELEASE(_punkSubMenu);
}


void CMenuStaticToolbar::CMenuStaticData::SetSubMenu(IUnknown* punk)
{
    ATOMICRELEASE(_punkSubMenu);
    _punkSubMenu = punk;
    if (_punkSubMenu)
        _punkSubMenu->AddRef();
}


HRESULT CMenuStaticToolbar::CMenuStaticData::GetSubMenu(const GUID* pguidService, REFIID riid, void** ppvObj)
{
    if (_punkSubMenu)
    {
        if (pguidService)
        {
            return IUnknown_QueryService(_punkSubMenu, *pguidService, riid, ppvObj);
        }
        else
            return _punkSubMenu->QueryInterface(riid, ppvObj);
    }
    else
        return E_NOINTERFACE;
}



//------------------------------------------------------------------------
//
// CMenuStaticToolbar
//
//------------------------------------------------------------------------



CMenuStaticToolbar::CMenuStaticToolbar(CMenuBand* pmb, HMENU hmenu, HWND hwnd, UINT idCmd, DWORD dwFlags)
    : CMenuToolbarBase(pmb, dwFlags)
{
    _hmenu = hmenu;
    _hwndMenuOwner = hwnd;
    _idCmd = idCmd;
    _iDragOverButton = -1;
    _fDirty = TRUE;
}


CMenuStaticToolbar::~CMenuStaticToolbar()
{
    if (!(_dwFlags & SMSET_DONTOWN))
    {
        DestroyMenu(_hmenu);
    }
}


STDMETHODIMP CMenuStaticToolbar::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMenuStaticToolbar, IDropTarget),
        { 0 },
    };

    // BUGBUG: If you QI MenuStatic for a drop target, you get a different
    // one than if you QI MenuShellFolder. This breaks COM identity rules.
    // Proper fix would be to implement a drop target that encapsulates both.
    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = CMenuToolbarBase::QueryInterface(riid, ppvObj);

    return hres;
}

void CMenuStaticToolbar::_CheckSeparators()
{
    if (_fHasTopSep)
    {
        if (_pcmb->_pmtbTop->DontShowEmpty() )
        {
            if (!_fTopSepRemoved)
            {
                SendMessage(_hwndMB, TB_DELETEBUTTON, 0, 0);
                _fTopSepRemoved = TRUE;
            }
        }
        else
        {
            if (_fTopSepRemoved)
            {
                MENUITEMINFO mii = {0};
                mii.cbSize = sizeof(mii);
                mii.fType = MFT_SEPARATOR;
                _Insert(0, &mii);
                _fTopSepRemoved = FALSE;
            }
        }
    }

    if (_fHasBottomSep)
    {
        if (_pcmb->_pmtbBottom->DontShowEmpty() )
        {
            if (!_fBottomSepRemoved)
            {
                SendMessage(_hwndMB, TB_DELETEBUTTON, ToolBar_ButtonCount(_hwndMB) - 1, 0);
                _fBottomSepRemoved = TRUE;
            }
        }
        else
        {
            if (_fBottomSepRemoved)
            {
                MENUITEMINFO mii = {0};
                mii.cbSize = sizeof(mii);
                mii.fType = SMIT_SEPARATOR;
                _Insert(-1, &mii);
                _fBottomSepRemoved = FALSE;
            }
        }
    }
}


void CMenuStaticToolbar::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    CMenuToolbarBase::v_Show(fShow, fForceUpdate);
    _fShowMB = fShow;
    if (fShow)
    {
        _fFirstTime = FALSE;
        _fClickHandled = FALSE;
        _FillToolbar();
        _pcmb->SetTracked(NULL);
        ToolBar_SetHotItem(_hwndMB, -1);

        // Have the menubar think about changing its height
        IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
            MBCID_SETEXPAND, (int)_pcmb->_fExpanded, NULL, NULL);

        if (fForceUpdate)
            v_UpdateButtons(FALSE);
#if 0
        // need top level frame available for D&D if possible.
        _hwndDD = GetParent(_hwndMB);
        IOleWindow *pOleWindow;
        HRESULT hr = IUnknown_QueryService(_pcmb->_punkSite, SID_STopLevelBrowser
                                                , IID_IOleWindow, (void **)&pOleWindow);
        if(SUCCEEDED(hr))
        { 
            ASSERT(pOleWindow);
            pOleWindow->GetWindow(&_hwndDD);
            pOleWindow->Release();
        }
#endif
        CDelegateDropTarget::Init();
    }
    else
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
    // n.b. for !fShow, we don't kill the tracked site chain.  we
    // count on this in startmnu.cpp!CStartMenuCallback::_OnExecItem,
    // where we walk up the chain to find all hit 'nodes'.  if we need
    // to change this we could fire a 'pre-exec' event.
}

void CMenuStaticToolbar::_Insert(int iIndex, MENUITEMINFO* pmii)
{
    CMenuStaticData* pmsd = new CMenuStaticData();
    if (pmsd)
    {
        BYTE bTBStyle = TBSTYLE_BUTTON | TBSTYLE_DROPDOWN;

        SMINFO sminfo = {0};
        sminfo.dwMask = SMIM_TYPE | SMIM_FLAGS | SMIM_ICON;


        // These are somethings that the callback does not fill in:
        if ( pmii->hSubMenu )
            sminfo.dwFlags |= SMIF_SUBMENU;

        if ( pmii->fState & MFS_CHECKED)
            sminfo.dwFlags |= SMIF_CHECKED;

        if (pmii->fState & MFS_DISABLED || pmii->fState & MFS_GRAYED)
            sminfo.dwFlags |= SMIF_DISABLED;

        if ( pmii->fType & MFT_SEPARATOR)
        {
            sminfo.dwType = SMIT_SEPARATOR;
            bTBStyle &= ~TBSTYLE_BUTTON;
            bTBStyle |= TBSTYLE_SEP;
        }
        else
            sminfo.dwType = SMIT_STRING;

        if (!_fVerticalMB)
            bTBStyle |= TBSTYLE_AUTOSIZE;

        if (S_OK != CallCB(pmii->wID, SMC_GETINFO, 0, (LPARAM)&sminfo))
        {
            sminfo.iIcon = -1;
        }

        pmsd->_dwFlags = sminfo.dwFlags;

        // Now add it to the toolbar
        TBBUTTON tbb = {0};

        tbb.iBitmap = sminfo.iIcon;
        tbb.idCommand = pmii->wID;
        tbb.dwData = (DWORD_PTR)pmsd;
        tbb.fsState = (sminfo.dwFlags & SMIF_HIDDEN)?TBSTATE_HIDDEN : TBSTATE_ENABLED;
        tbb.fsStyle = bTBStyle; 

        TCHAR szMenuString[MAX_PATH];

        if (pmii->fType & MFT_OWNERDRAW)
        {
            // dwTypeData is user defined 32 bit value, not a string if MFT_OWNERDRAW is set
            // then the (unicode) string is the very first element in a structure dwItemData
            // points to
            LPWSTR pwsz = (LPWSTR)pmii->dwItemData;
            SHUnicodeToTChar(pwsz, szMenuString, ARRAYSIZE(szMenuString));
            tbb.iString = (INT_PTR)(szMenuString);
        }
        else
            tbb.iString = (INT_PTR)(LPTSTR)pmii->dwTypeData;

        SendMessage(_hwndMB, TB_INSERTBUTTON, iIndex, (LPARAM)&tbb);
    }
}


/*----------------------------------------------------------
Purpose: GetMenu method

*/
HRESULT CMenuStaticToolbar::GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags)
{
    if (phmenu)
        *phmenu = _hmenu;
    if (phwnd)
        *phwnd = _hwndMenuOwner;
    if (pdwFlags)
        *pdwFlags = _dwFlags;

    return NOERROR;
}

HRESULT CMenuStaticToolbar::SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags)
{
    // When we are merging in a new menu, we need to destroy the old one if we own it.
    if (_hmenu && !(_dwFlags & SMSET_DONTOWN))
    {
        DestroyMenu(_hmenu);
    }

    _hmenu = hmenu;
    // If we're processing a change notify, we cannot do anything that will modify state.
    if (_pcmb->_pmbState && 
        _pcmb->_pmbState->IsProcessingChangeNotify())
    {
        _fDirty = TRUE;
    }
    else
    {
        EmptyToolbar();
        _pcmb->_fInSubMenu = FALSE;
        IUnknown_SetSite(_pcmb->_pmpSubMenu, NULL);
        ATOMICRELEASE(_pcmb->_pmpSubMenu);

        if (_fShowMB)
            _FillToolbar();

        BOOL fSmooth = FALSE;
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
        SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fSmooth, 0);
#endif

        // This causes a paint to occur right away instead of waiting until the
        // next message dispatch which could take a noticably long time.
        RedrawWindow(_hwndMB, NULL, NULL, (fSmooth? RDW_ERASE: 0) | RDW_INVALIDATE | RDW_UPDATENOW);  
    }
    return NOERROR;
}


CMenuStaticToolbar::CMenuStaticData* CMenuStaticToolbar::_IDToData(int idCmd)
{
    CMenuStaticData* pmsd= NULL;

    // Initialize to NULL in case the GetButtonInfo Fails. We won't fault because
    // the lParam is just stack garbage. 
    TBBUTTONINFO tbbi = {0};
    int iPos;

    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_LPARAM;

    iPos = ToolBar_GetButtonInfo(_hwndMB, idCmd, &tbbi);
    if (iPos >= 0)
        pmsd = (CMenuStaticData*)tbbi.lParam;

    return pmsd;
}

HRESULT CMenuStaticToolbar::v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj) 
{
    HRESULT hres = E_OUTOFMEMORY;
    int iPos = (int)SendMessage(_hwndMB, TB_COMMANDTOINDEX, idCmd, 0);

    if (iPos >= 0)
    {
        CTrackPopupBar* ptpb = new CTrackPopupBar(_pcmb->_pmbState->GetContext(), iPos, _hmenu, _hwndMenuOwner);

        if (ptpb)
        {
            hres = ptpb->QueryInterface(riid, ppvObj);
            if (SUCCEEDED(hres))
                IUnknown_SetSite(SAFECAST(ptpb, IMenuPopup*), SAFECAST(_pcmb, IMenuPopup*));

            PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBAutomation, (WPARAM)_hmenu, (LPARAM)iPos);
            ptpb->Release();
        }
    }

    return hres;
}

HRESULT CMenuStaticToolbar::v_GetSubMenu(int idCmd, const GUID* pguidService, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    CMenuStaticData* pmsd = _IDToData(idCmd);

    ASSERT(IS_VALID_WRITE_PTR(ppvObj, void*));

    *ppvObj = NULL;

    if (pmsd)
    {
        // Get the cached submenu
        hres = pmsd->GetSubMenu(pguidService, riid, ppvObj);

        // Did that fail?
        if (FAILED(hres) && (pmsd->_dwFlags & SMIF_SUBMENU) && 
            IsEqualGUID(riid, IID_IShellMenu))
        {
            // Yes; ask the callback for it
            hres = CallCB(idCmd, SMC_GETOBJECT, (WPARAM)&riid, (LPARAM)ppvObj);

            if (S_OK != hres)
            {
                hres = E_OUTOFMEMORY;   // Set to error case incase something happens

                // Callback didn't handle it, try and see if we can get it
                MENUITEMINFO mii;
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU | MIIM_ID;
                if (GetMenuItemInfoWrap(_hmenu, idCmd, MF_BYCOMMAND, &mii) && mii.hSubMenu)
                {
                    IShellMenu* psm = (IShellMenu*)new CMenuBand();
                    if (psm)
                    {
                        UINT uIdAncestor = _pcmb->_uIdAncestor;
                        if (uIdAncestor == ANCESTORDEFAULT)
                            uIdAncestor = idCmd;

                        psm->Initialize(_pcmb->_psmcb, idCmd, uIdAncestor, SMINIT_VERTICAL);
                        psm->SetMenu(mii.hSubMenu, _hwndMenuOwner, SMSET_TOP | SMSET_DONTOWN);
                        hres = psm->QueryInterface(riid, ppvObj);
                        psm->Release();
                    }
                }
            }

            if (*ppvObj)
            {
                // Cache it now
                pmsd->SetSubMenu((IUnknown*)*ppvObj);

                // Initialize the fonts
                VARIANT Var;
                Var.vt = VT_UNKNOWN;
                Var.byref = SAFECAST(_pcmb->_pmbm, IUnknown*);
                IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETFONTS, 0, &Var, NULL);

                // Set the CMenuBandState  into the new menuband
                Var.vt = VT_INT_PTR;
                Var.byref = _pcmb->_pmbState;
                IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETSTATEOBJECT, 0, &Var, NULL);

            }
        }
    }

    return hres;
}


HRESULT CMenuStaticToolbar::v_GetInfoTip(int idCmd, LPTSTR psz, UINT cch)
{
    return CallCB(idCmd, SMC_GETINFOTIP, (WPARAM)psz, (LPARAM)cch);
}


HRESULT CMenuStaticToolbar::v_ExecItem(int idCmd)
{
    HRESULT hres = CallCB(idCmd, SMC_EXEC, 0, 0);

    if (S_OK != hres && _hwndMenuOwner)
    {
        PostMessage(_hwndMenuOwner, WM_COMMAND, idCmd, 0);
        hres = NOERROR;
    }

    return hres;
}

DWORD CMenuStaticToolbar::v_GetFlags(int idCmd)
{
    CMenuStaticData* pmsd = _IDToData(idCmd);

    // Toolbar is allowed to pass a bad command in the case of erasing the background
    if (pmsd)
    {
        return pmsd->_dwFlags;
    }
    else
        return 0;
}


void CMenuStaticToolbar::v_SendMenuNotification(UINT idCmd, BOOL fClear)
{
    if (S_FALSE == CallCB(idCmd, SMC_SELECTITEM, (WPARAM)fClear, 0))
    {
        UINT uFlags = (UINT)-1;
        if (v_GetFlags(idCmd) & SMIF_SUBMENU)
             uFlags = MF_POPUP;

        if (!fClear)
            uFlags = MF_HILITE;

        PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), WM_MENUSELECT,
            MAKEWPARAM(idCmd, uFlags), fClear? NULL : (LPARAM)_hmenu);

    }
}

BOOL CMenuStaticToolbar::v_TrackingSubContextMenu()
{
    return (_pcm != NULL);
}

void CMenuStaticToolbar::CreateToolbar(HWND hwndParent)
{
    if (!_hwndMB)
    {
        _hwndMB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, TEXT("Menu"),
                                 WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                                 CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                 CCS_NORESIZE  | TBSTYLE_REGISTERDROP,
                                 0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);

        if (!_hwndMB)
        {
            TraceMsg(TF_MENUBAND, "CMenuStaticToolbar::CreateToolbar: Failed to Create Toolbar");
            return;
        }

        SendMessage(_hwndMB, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndMB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        // Set the format to ANSI or UNICODE as appropriate.
        ToolBar_SetUnicodeFormat(_hwndMB, DLL_IS_UNICODE);

        _SubclassWindow(_hwndMB);
        _RegisterWindow(_hwndMB, NULL, SHCNE_UPDATEIMAGE);
        SIZE size;
        RECT rc;

        SystemParametersInfoA(SPI_GETWORKAREA, SIZEOF(RECT), &rc, FALSE);
        //HACKHACK:  THIS WILL FORCE NO WRAP TO HAPPEN FOR PROPER WIDTH CALC WHEN PAGER IS PRESENT.
        size.cx = RECTWIDTH(rc);
        size.cy = 32000;
        ToolBar_SetBoundingSize(_hwndMB, &size);
        CMenuToolbarBase::CreateToolbar(hwndParent);
    }
    else if (GetParent(_hwndMB) != hwndParent)
    {
        ::SetParent(_hwndMB, hwndParent);
    }
}


STDMETHODIMP CMenuStaticToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (SHCNE_UPDATEIMAGE == lEvent) // global
    {
        if (pidl1)
        {
            int iImage = *(int UNALIGNED *)((BYTE *)pidl1 + 2);

            IEInvalidateImageList();    // We may need to use different icons.
            if ( pidl2 )
            {
                iImage = SHHandleUpdateImage( pidl2 );
                if ( iImage == -1 )
                {
                    return E_FAIL;
                }
            }
            
            if (iImage == -1 || TBHasImage(_hwndMB, iImage))
            {
                v_Refresh();
            }
        } 
        else
        {
            v_Refresh();
        }

        return S_OK;
    }

    return E_FAIL;
}


LRESULT CMenuStaticToolbar::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    switch(uMessage)
    {
    case WM_TIMER:
        if (_OnTimer(wParam)) 
            return 1;
        break;
    case WM_GETOBJECT:
        // Yet another poor design choice on the part of the accessibility team.
        // Typically, if you do not answer a WM_* you return 0. They choose 0 as their success
        // code.
        return _DefWindowProcMB(hwnd, uMessage, wParam, lParam);
        break;

    }

    return CNotifySubclassWndProc::_DefWindowProc(hwnd, uMessage, wParam, lParam);
}


//***
// NOTES
//  idtCmd is currently always -1.  we'll need other values when we're
// called from CallCB.  however we can't do that until we fix mnfolder.cpp.
HRESULT CMenuStaticToolbar::v_GetState(int idtCmd, LPSMDATA psmd)
{
    psmd->dwMask = SMDM_HMENU;

    psmd->hmenu = _hmenu;
    psmd->hwnd = _hwndMenuOwner;
    psmd->uIdParent = _idCmd;
    if (idtCmd == -1)
        idtCmd = GetButtonCmd(_hwndMB, ToolBar_GetHotItem(_hwndMB));
    psmd->uId = IDTTOIDM(idtCmd);
    psmd->punk = SAFECAST(_pcmb, IShellMenu*);
    psmd->punk->AddRef();

    return S_OK;
}

HRESULT CMenuStaticToolbar::CallCB(UINT idCmd, DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    if (!_pcmb->_psmcb)
        return S_FALSE;

    SMDATA smd;
    HRESULT hres = S_FALSE;

    // todo: call v_GetState (but see comment in mnfolder.cpp)
    smd.dwMask = SMDM_HMENU;

    smd.hmenu = _hmenu;
    smd.hwnd = _hwndMenuOwner;
    smd.uIdParent = _idCmd;
    smd.uIdAncestor = _pcmb->_uIdAncestor;
    smd.uId = idCmd;
    smd.punk = SAFECAST(_pcmb, IShellMenu*);
    smd.pvUserData = _pcmb->_pvUserData;

    hres = _pcmb->_psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);

    return hres;
}

HRESULT CMenuStaticToolbar::v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    int idm;

    idm = IDTTOIDM(idtCmd);
    return CallCB(idm, uMsg, wParam, lParam);
}



void CMenuStaticToolbar::v_UpdateButtons(BOOL fNegotiateSize)
{
    if (_hwndMB)
    {
        _SetToolbarState();
        int cxMin, cxMax;
        v_CalcWidth(&cxMin, &cxMax);

        SendMessage(_hwndMB, TB_SETBUTTONWIDTH, 0, MAKELONG(cxMin, cxMax));
        SendMessage(_hwndMB, TB_AUTOSIZE, 0, 0);

        // Should we renegotiate size? AND are we vertical,
        // because we cannot renegoitate when horizontal.
        if (fNegotiateSize && _fVerticalMB)
            NegotiateSize();
    }
}


BOOL CMenuStaticToolbar::v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons)
{
    if (-1 == uIconSize)
        uIconSize = _uIconSizeMB;
    BOOL fChanged = (_uIconSizeMB != uIconSize);
    
    _uIconSizeMB = uIconSize;

    if (_hwndMB)
    {
        HIMAGELIST himl = NULL;
        if (_fVerticalMB)
        {
            HIMAGELIST himlLarge, himlSmall;

            // set the imagelist size
            Shell_GetImageLists(&himlLarge, &himlSmall);
            himl = (_uIconSizeMB == ISFBVIEWMODE_LARGEICONS ) ? himlLarge : himlSmall;
        }

        // sending a null himl is significant..  it means no image list
        SendMessage(_hwndMB, TB_SETIMAGELIST, 0, (LPARAM)himl);
                
        if (fUpdateButtons)
            v_UpdateButtons(TRUE);
    }
    
    return fChanged;
}


void CMenuStaticToolbar::_OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode) 
{
    LPNMTBDISPINFO pdi = (LPNMTBDISPINFO)pnm;
    CMenuStaticData* pdata = (CMenuStaticData*)pdi->lParam;
    
    if(pdi->dwMask & TBNF_IMAGE) 
    {
        if (_fVerticalMB)
        {
            SMINFO smi;
            smi.dwMask = SMIM_ICON;
            if (CallCB(pdi->idCommand, SMC_GETINFO, 0, (LPARAM)&smi) == S_OK)
                pdi->iImage = smi.iIcon;
            else
                pdi->iImage = -1;
        }
        else
            pdi->iImage = -1;

    }
    
    if(pdi->dwMask & TBNF_TEXT) 
    {
        if(pdi->pszText) 
        {
            if(fUnicode) 
            {
                pdi->pszText[0] = TEXT('\0');
            }
            else 
            {
                pdi->pszText[0] = 0;
            }
        }
    }
    pdi->dwMask |= TBNF_DI_SETITEM;

    return;
}

LRESULT CMenuStaticToolbar::_OnGetObject(NMOBJECTNOTIFY* pon)
{
    pon->hResult = QueryInterface(*pon->piid, &pon->pObject);

    return 1;
}


LRESULT CMenuStaticToolbar::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;

    switch (pnm->code)
    {
    case TBN_DRAGOUT:
        lres = 0;
        break;
    
    case TBN_DELETINGBUTTON:
    {
        if (!_fEmptyingToolbar)
        {
            TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
            CMenuStaticData* pmsd = (CMenuStaticData*)ptbn->tbButton.dwData;
            if (pmsd)
                delete pmsd;
        }
        break;    
    }

    case NM_TOOLTIPSCREATED:
        SHSetWindowBits(((NMTOOLTIPSCREATED*)pnm)->hwndToolTips, GWL_STYLE, TTS_ALWAYSTIP | TTS_TOPMOST, TTS_ALWAYSTIP | TTS_TOPMOST);
        SendMessage(((NMTOOLTIPSCREATED*)pnm)->hwndToolTips, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)MAXSHORT);        
        break;

    case NM_RCLICK:
        lres = _OnContextMenu(NULL, GetMessagePos());
        break;

    case NM_CUSTOMDRAW:
        lres =  _OnCustomDraw((NMCUSTOMDRAW*)pnm);
        g_hmenuStopWatch = _hmenu;
        g_idCmdStopWatch = _idCmd;
        break;
    
    case  TBN_GETDISPINFOA:
        _OnGetDispInfo(pnm,  FALSE);
        break;
    
    case  TBN_GETDISPINFOW:
        _OnGetDispInfo(pnm,  TRUE);
        break;

    case TBN_GETOBJECT:
        lres = _OnGetObject((NMOBJECTNOTIFY*)pnm);
        break;

    case TBN_MAPACCELERATOR:
        lres = _OnAccelerator((NMCHAR*)pnm);
        break;

    default:
        lres = CMenuToolbarBase::_OnNotify(pnm);

    }

    return(lres);
}

void CMenuStaticToolbar::_FillToolbar()
{
    if (_fDirty && _hmenu && _hwndMB && !_pcmb->_fClosing)
    {
        EmptyToolbar();
        BOOL_PTR fRedraw = SendMessage(_hwndMB, WM_SETREDRAW, FALSE, 0);

        TCHAR szName[MAX_PATH];
        MENUITEMINFO mii;
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID | MIIM_SUBMENU | MIIM_TYPE | MIIM_STATE | MIIM_DATA;

        int iCount = GetMenuItemCount(_hmenu);
        for (int i = 0; i < iCount; i++)
        {
            mii.dwTypeData = szName;
            mii.cch = ARRAYSIZE(szName);
            if (GetMenuItemInfoWrap(_hmenu, i, MF_BYPOSITION, &mii))
            {
                if (mii.fType & MFT_SEPARATOR)
                {
                    if (i == 0)
                        _fHasTopSep = TRUE;
                    else if (i == iCount - 1)
                        _fHasBottomSep = TRUE;
                }

                _Insert(i, &mii);
            }
        }

        if (iCount == 0)
            _fEmpty = TRUE;

        SendMessage(_hwndMB, WM_SETREDRAW, fRedraw, 0);

        _fDirty = FALSE;
        v_UpdateButtons(FALSE);
        _pcmb->ResizeMenuBar();
    }
}

void CMenuStaticToolbar::v_OnDeleteButton(LPVOID pData)
{
    CMenuStaticData* pmsd = (CMenuStaticData*)pData;
    if (pmsd)
        delete pmsd;
}

void CMenuStaticToolbar::v_OnEmptyToolbar()
{
    CMenuToolbarBase::v_OnEmptyToolbar();
    _fDirty = TRUE;
    _fHasTopSep = FALSE;
    _fHasBottomSep = FALSE;
    _fTopSepRemoved = FALSE;
    _fBottomSepRemoved = FALSE;
}

void CMenuStaticToolbar::v_Close()
{
    if (_hwndMB)
    {
        _UnregisterWindow(_hwndMB);
        _UnsubclassWindow(_hwndMB);
    }
    CMenuToolbarBase::v_Close();
}

void CMenuStaticToolbar::v_Refresh()
{
    EmptyToolbar();
    _FillToolbar();
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner method

         Processes messages passed on from the menuband.
*/
STDMETHODIMP CMenuStaticToolbar::IsWindowOwner(HWND hwnd) 
{ 
    if ( hwnd == _hwndMB || hwnd == HWND_BROADCAST) 
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}




/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetWindowsDDT

*/
HRESULT CMenuStaticToolbar::GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll) 
{ 
    *phwndLock = _hwndMB;
    *phwndScroll = _hwndMB; 
    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::HitTestDDT

*/
HRESULT CMenuStaticToolbar::HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect)
{
    switch (nEvent)
    {
    case HTDDT_ENTER:
        // OLE is in its modal drag/drop loop, and it has the capture.
        // We shouldn't take the capture back during this time.
        if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP))
        {
            _pcmb->_pmbState->HasDrag(TRUE);
            GetMessageFilter()->PreventCapture(TRUE);
            if (_pcmb->_pmtbShellFolder &&
                _pcmb->_pmtbShellFolder->DontShowEmpty())
            {
                DAD_ShowDragImage(FALSE);
                _pcmb->_pmtbShellFolder->DontShowEmpty(FALSE);
                _pcmb->ResizeMenuBar();
                UpdateWindow(_hwndMB);
                DAD_ShowDragImage(TRUE);
            }
            return S_OK;
        }
        else
            return S_FALSE;

    case HTDDT_OVER:
        {
            TBINSERTMARK tbim;
            *pdwEffect = DROPEFFECT_NONE;

            POINT pt = *ppt;

            if (!ToolBar_InsertMarkHitTest(_hwndMB, &pt, &tbim))
            {
                int idCmd = GetButtonCmd(_hwndMB, tbim.iButton);
                if (v_GetFlags(idCmd) & SMIF_DROPCASCADE &&
                    tbim.iButton != _iDragOverButton)
                {
                    DAD_ShowDragImage(FALSE);
                    _pcmb->SetTracked(this);
                    _iDragOverButton = tbim.iButton;
                    SetTimer(_hwndMB, MBTIMER_DRAGOVER, MBTIMER_TIMEOUT, NULL);
                    _pcmb->_SiteOnSelect(MPOS_CHILDTRACKING);
                    BOOL_PTR fOldAnchor = ToolBar_SetAnchorHighlight(_hwndMB, FALSE);
                    ToolBar_SetHotItem(_hwndMB, _iDragOverButton);
                    ToolBar_SetAnchorHighlight(_hwndMB, fOldAnchor);
                    UpdateWindow(_hwndMB);
                    DAD_ShowDragImage(TRUE);
                }
            }
        }
        break;

    case HTDDT_LEAVE:
        // We can take the capture back anytime now
        _pcmb->_pmbState->HasDrag(FALSE);
        _SetTimer(MBTIMER_DRAGPOPDOWN);
        GetMessageFilter()->PreventCapture(FALSE);
        _iDragOverButton = -1;
#if 0
        DAD_ShowDragImage(FALSE);
        ToolBar_SetHotItem(_hwndMB, -1);
        DAD_ShowDragImage(TRUE);
#endif
        break;
    }
    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetObjectDDT

*/
HRESULT CMenuStaticToolbar::GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::OnDropDDT

*/
HRESULT CMenuStaticToolbar::OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, 
                            DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return E_NOTIMPL;
}



HRESULT CMenuStaticToolbar::v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{
    HRESULT hres = S_FALSE;

    if (NULL == psmd)
    {
        if (dwFlags & SMINV_REFRESH)
        {
            // Refresh the whole thing
            v_Refresh();
            hres = TRUE;
        }
    }

    // Are we dealing with an Hmenu?
    // Have we filled it yet?  (If not, then we can skip the invalidate
    // here, because we'll catch it when we fill it.)
    else if ((psmd->dwMask & SMDM_HMENU) && !_fDirty)
    {
        // Yes; What are they asking for?

        int iPos = -1;   // Assume this is a position
        int idCmd = -1;

        // Did they pass an ID instead of a position?
        if (dwFlags & SMINV_ID)
        {
            // Yes; Crack out the position.
            iPos = GetMenuPosFromID(_hmenu, psmd->uId);
            idCmd = psmd->uId;
        }

        if (dwFlags & SMINV_POSITION)
        {
            iPos = psmd->uId;
            idCmd = GetMenuItemID(_hmenu, iPos);
        }


        if (dwFlags & SMINV_REFRESH)
        {
            // Do they want to refresh a sepcific button?
            if (idCmd >= 0)
            {
                // Yes;

                // First delete the old one if it exists.
                int iTBPos = ToolBar_CommandToIndex(_hwndMB, idCmd);

                if (iTBPos >= 0)
                    SendMessage(_hwndMB, TB_DELETEBUTTON, iTBPos, 0);

                // Now Insert a new one
                MENUITEMINFO mii;
                TCHAR szName[MAX_PATH];
                mii.cbSize = sizeof(mii);
                mii.cch = ARRAYSIZE(szName);
                mii.dwTypeData = szName;
                mii.fMask = MIIM_ID | MIIM_SUBMENU | MIIM_TYPE | MIIM_STATE | MIIM_DATA;

                // This can fail...
                if (GetMenuItemInfoWrap(_hmenu, iPos, MF_BYPOSITION, &mii))
                {
                    _Insert(iPos, &mii);
                    hres = S_OK;
                }
            }
            else
            {
                // No; Refresh the whole thing
                v_Refresh();
            }

            if (!_fShowMB)
                _pcmb->_fForceButtonUpdate = TRUE;

            _pcmb->ResizeMenuBar();
        }
    }

    return hres;
}

void CMenuStaticToolbar::GetSize(SIZE* psize)
{
    _CheckSeparators();

    CMenuToolbarBase::GetSize(psize);
}

LRESULT CMenuStaticToolbar::_OnAccelerator(NMCHAR* pnmChar)
{
    SMDATA smdOut = {0};
    SMDATA smd = {0};
    smd.punk = SAFECAST(_pcmb, IShellMenu*);
    smd.uIdParent = _pcmb->_uId;

    if (_pcmb->_psmcb &&
        S_FALSE != _pcmb->_psmcb->CallbackSM(&smd, SMC_MAPACCELERATOR, (WPARAM)pnmChar->ch, (LPARAM)&smdOut))
    {
        pnmChar->dwItemNext = ToolBar_CommandToIndex(_hwndMB, smdOut.uId);;
        return TRUE;
    }

    return FALSE;
}

LRESULT CMenuStaticToolbar::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    MyLockSetForegroundWindow(FALSE);

    if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_CONTEXTMENU))
    {
        RECT rc;
        LPRECT prcExclude = NULL;
        POINT pt;
        int i;

        if (lParam != (LPARAM)-1) 
        {
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);

            POINT pt2 = pt;
            MapWindowPoints(HWND_DESKTOP, _hwndMB, &pt2, 1);

            i = ToolBar_HitTest(_hwndMB, &pt2);
        } 
        else 
        {
            // keyboard context menu.
            i = (int)SendMessage(_hwndMB, TB_GETHOTITEM, 0, 0);
            if (i >= 0) 
            {
                SendMessage(_hwndMB, TB_GETITEMRECT, i, (LPARAM)&rc);
                MapWindowPoints(_hwndMB, HWND_DESKTOP, (LPPOINT)&rc, 2);
                pt.x = rc.left;
                pt.y = rc.bottom;
                prcExclude = &rc;
            }
        }
        if (i >= 0)
        {
            UINT idCmd = GetButtonCmd(_hwndMB, i);
            if (S_OK == CallCB(idCmd, SMC_GETOBJECT, (WPARAM)(GUID*)&IID_IContextMenu, (LPARAM)(VOID**)(&_pcm)))
            {
                TPMPARAMS tpm;
                TPMPARAMS * ptpm = NULL;

                if (prcExclude)
                {
                    tpm.cbSize = SIZEOF(tpm);
                    tpm.rcExclude = *((LPRECT)prcExclude);
                    ptpm = &tpm;
                }
                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    KillTimer(_hwndMB, MBTIMER_INFOTIP);
                    _pcmb->_pmbState->HideTooltip(FALSE);

                    _pcm->QueryContextMenu(hmenu, 0, 0, -1, 0);

                    idCmd = TrackPopupMenuEx(hmenu,
                        TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                        pt.x, pt.y, _hwndMB, ptpm);

                    CMINVOKECOMMANDINFO ici = {
                        SIZEOF(CMINVOKECOMMANDINFO),
                        0,
                        _hwndMB,
                        MAKEINTRESOURCEA(idCmd),
                        NULL, NULL,
                        SW_NORMAL,
                    };

                    _pcm->InvokeCommand(&ici);

                    DestroyMenu(hmenu);
                }

                ATOMICRELEASE(_pcm);
            }
        }

        GetMessageFilter()->RetakeCapture();
    }

    return lres;
}

STDMETHODIMP CMenuStaticToolbar::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    if (WM_CONTEXTMENU == dwMsg)
    {
        *plres = _OnContextMenu(wParam, lParam);
    }
    else
        return CMenuToolbarBase::OnWinEvent(hwnd, dwMsg, wParam, lParam, plres);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\browseui\legacy\mnfolder.cpp ===
#include "priv.h"
#include "sccls.h"
#include "menuband.h"
#include "itbar.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "mnbase.h"
#include "oleacc.h"
#include "apithk.h"
#include "menuisf.h"
#include "mnfolder.h"
#include "icotask.h"
#include "mluisupp.h"

#define PGMP_RECALCSIZE  200

#define SIL_GetType(pidl)       (ILIsEmpty(pidl) ? 0 : (pidl)->mkid.abID[0])


//-------------------------------------------------------------------------
//
//  Non-Member functions
//
//-------------------------------------------------------------------------


HRESULT IUnknown_RefreshParent(IUnknown* punk, LPCITEMIDLIST pidl, DWORD dwFlags)
{
    IShellMenu* psm;
    HRESULT hres = IUnknown_QueryService(punk, SID_SMenuBandParent, 
            IID_IShellMenu, (void **)&psm);
    if (SUCCEEDED(hres))
    {
        LPITEMIDLIST pidlParent = ILClone(pidl);
        if (pidlParent)
        {
            SMDATA smd;
            ILRemoveLastID(pidlParent);
            smd.dwMask = SMDM_SHELLFOLDER;
            smd.pidlFolder = pidlParent;
            smd.pidlItem = ILFindLastID(pidl);
            hres = psm->InvalidateItem(&smd, dwFlags);
            ILFree(pidlParent);
        }
        psm->Release();
    }

    return hres;
}



//-------------------------------------------------------------------------
//
//  CMenuData class
//
//-------------------------------------------------------------------------


void CMenuData::SetSubMenu(IUnknown* punk)
{
    ATOMICRELEASE(_punkSubmenu);
    _punkSubmenu = punk;
    if (_punkSubmenu)
        _punkSubmenu->AddRef();
}

HRESULT CMenuData::GetSubMenu(const GUID* pguidService, REFIID riid, void** ppv)
{
    // pguidService is for asking specifically for the Shell Folder portion or the Static portion
    if (_punkSubmenu)
    {
        if (pguidService)
        {
            return IUnknown_QueryService(_punkSubmenu, *pguidService, riid, ppv);
        }
        else
            return _punkSubmenu->QueryInterface(riid, ppv);
    }
    else
        return E_NOINTERFACE;
}

CMenuData::~CMenuData()
{
    ATOMICRELEASE(_punkSubmenu);
}

STDMETHODIMP CMenuSFToolbar::QueryInterface(REFIID riid, void** ppvObj)
{
    HRESULT hres = CMenuToolbarBase::QueryInterface(riid, ppvObj);
    
    if (FAILED(hres))
        hres = CSFToolbar::QueryInterface(riid, ppvObj); 
    
    return hres;
}

//-------------------------------------------------------------------------
//
//  CMenuSFToolbar class
//
//-------------------------------------------------------------------------


STDMETHODIMP CMenuSFToolbar::SetSite(IUnknown* punkSite)
{
    HRESULT hres = CMenuToolbarBase::SetSite(punkSite);
    if (SUCCEEDED(hres)) 
    {
        _fMulticolumnMB = BOOLIFY(_pcmb->_dwFlags & SMINIT_MULTICOLUMN);
        _fMulticolumn = _fMulticolumnMB;
        _fVertical = _fVerticalMB;
        if (_fVerticalMB)
            _dwStyle |= CCS_VERT;

    }
    return hres;
}

CMenuSFToolbar::CMenuSFToolbar(CMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, HKEY hKey, DWORD dwFlags) 
    : CMenuToolbarBase(pmb, dwFlags)
{
    // Change this to IStream
    _hKey = hKey;

    // Do we have a place to persist our reorder?
    if (_hKey == NULL)
    {
        // No, then don't allow it.
        _fAllowReorder = FALSE;
    }


    _dwStyle |= TBSTYLE_REGISTERDROP;
    _dwStyle &= ~TBSTYLE_TOOLTIPS;      // We handle our own tooltips.

    _iDefaultIconIndex = -1;

    SetShellFolder(psf, pidl);

    _AfterLoad();
}

HRESULT CMenuSFToolbar::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl)
{
    HRESULT hres = CSFToolbar::SetShellFolder(psf, pidl);
    ATOMICRELEASE(_pasf2);

    if (psf)
        psf->QueryInterface(IID_IAugmentedShellFolder2, (void**)&_pasf2);

    return hres;
}


CMenuSFToolbar::~CMenuSFToolbar()
{
    ASSERT(_pcmb->_cRef == 0 || _pcmb->_pmtbShellFolder == NULL);
    _hwndWorkerWindow = NULL;       // This is destroyed by the _pmbState destructor. 
                                    // Prevent a double delete which happens in the base class.
    ATOMICRELEASE(_pasf2);
    if (_hKey)
        RegCloseKey(_hKey);
}


void CMenuSFToolbar::v_Close()
{
    // We should save this so that we know when a new item is added.
    _SaveOrderStream();
    CMenuToolbarBase::EmptyToolbar();
    _UnregisterToolbar();

    if (_hwndPager)
    {
        DestroyWindow(_hwndPager);  // Should Destroy Toolbar.
    }
    else if (_hwndMB)
    {
        // In the MultiColumn case, there is no pager so we have to 
        // manually destroy the Toolbar
        DestroyWindow(_hwndMB);
    }

    _hwndPager = NULL;
    _hwndMB = NULL;
    _hwndTB = NULL;
}


PIBDATA CMenuSFToolbar::_CreateItemData(PORDERITEM poi)
{
    return (PIBDATA)new CMenuData(poi);
}


HRESULT CMenuSFToolbar::_AfterLoad()
{
    HRESULT hres = CSFToolbar::_AfterLoad();

    if (SUCCEEDED(hres))
        _LoadOrderStream();

    return hres;
}


HRESULT CMenuSFToolbar::_LoadOrderStream()
{
    OrderList_Destroy(&_hdpaOrder);
    IStream* pstm;
    HRESULT hres = E_FAIL;

    if (_hKey)
    {
        // We use "Menu" for Backwards compatibility with shdoc401 start menu, but having no
        // sub key is more correct (Other places use it) so on NT5 we use the new method.
        pstm = SHOpenRegStream(_hKey, (_pcmb->_dwFlags & SMINIT_LEGACYMENU) ? TEXT("Menu") : TEXT(""), 
            TEXT("Order"), STGM_READ);
    }
    else
    {
        if (S_FALSE == CallCB(NULL, SMC_GETSFOBJECT, (WPARAM)(GUID*)&IID_IStream, (LPARAM)(void**)&pstm))
            pstm = NULL;
    }

    if (pstm)
    {
        hres = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);
        _fHasOrder = FALSE;
        _fAllowReorder = TRUE;

        // Check to see if we have a persisted order. If we don't have a persisted order,
        // then all of the items are -1. If just one of those has a number other than
        // -1, then we do have "Order" and should use that instead of alphabetizing.
        if (_hdpaOrder)
        {
            for (int i = 0; !_fHasOrder && i < DPA_GetPtrCount(_hdpaOrder); i++) 
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpaOrder, i);
                if (poi->nOrder != MNFOLDER_NORODER)
                    _fHasOrder = TRUE;
            }
        }
        pstm->Release();
    }
    return hres;
}

HRESULT CMenuSFToolbar::_SaveOrderStream()
{
    IStream* pstm;
    HRESULT hres = E_FAIL;

    // Persist the new order out to the registry
    // It is reasonable to assume that if we don't have an _hdpa we have
    // not filled the toolbar yet. Since we have not filled it, we haven't changed
    // the order, so we don't need to persist out that order information.
    if(_hdpa)
    {
        // Always save this information
        _FindMinPromotedItems(TRUE);

        // Did we load an order stream when we initialized this pane?
        if (!_fHasOrder)
        {
            // No; Then we do not want to persist the order. We will initialize
            // all of the order items to -1. This is backward compatible because
            // IE 4 will merge alphabetically, but revert to a persited order when saving.
            for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++) 
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);
                poi->nOrder = MNFOLDER_NORODER;
            }
        }

        if (_hKey)
        {
            pstm = SHOpenRegStream(_hKey, (_pcmb->_dwFlags & SMINIT_LEGACYMENU) ? TEXT("Menu") : TEXT(""), 
                TEXT("Order"), STGM_CREATE | STGM_WRITE);
        }
        else
        {
            if (S_OK != CallCB(NULL, SMC_GETSFOBJECT, (WPARAM)(GUID*)&IID_IStream, (LPARAM)(void**)&pstm))
                pstm = NULL;
        }

        if (pstm)
        {
            hres = OrderList_SaveToStream(pstm, _hdpaOrder ? _hdpaOrder : _hdpa, _psf);
            if (SUCCEEDED(hres))
            {
                CallCB(NULL, SMC_SETSFOBJECT, (WPARAM)(GUID*)&IID_IStream, (LPARAM)(void**)&pstm);
            }
            pstm->Release();
        }
    }

    if (SUCCEEDED(hres))
        hres = CSFToolbar::_SaveOrderStream();

    return hres;
}


void CMenuSFToolbar::_Dropped(int nIndex, BOOL fDroppedOnSource)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    ASSERT(_fDropping);

    CSFToolbar::_Dropped(nIndex, fDroppedOnSource);

    IEPlaySound(TEXT("MoveMenuItem"), FALSE);

    // Set this to false here because it is ugly that we don't behave like a menu right after a drop.
    _fEditMode = FALSE;

    // Notify the toplevel menuband of the drop in case it was popped open
    // because of the drag/drop event.  
    //
    // (There are some functionality/activation problems if we keep the
    // menu up after this case.  So to avoid those things at this late date,
    // we're going to cancel the menu after a timeout.)

    IOleCommandTarget * poct;
    
    _pcmb->QueryService(SID_SMenuBandTop, IID_IOleCommandTarget, (LPVOID *)&poct);

    if (poct)
    {
        poct->Exec(&CGID_MenuBand, MBANDCID_ITEMDROPPED, 0, NULL, NULL);
        poct->Release();
    }

    _pcmb->_fDragEntered = FALSE;
}


HMENU CMenuSFToolbar::_GetContextMenu(IContextMenu* pcm, int* pid)
{
    *pid += MNIDM_LAST;
    HMENU hmenu = CSFToolbar::_GetContextMenu(pcm, pid);
    HMENU hmenu2 = LoadMenuPopup_PrivateNoMungeW(MENU_MNFOLDERCONTEXT);
    
    // now find the properties insertion point and 
    int iCount = GetMenuItemCount(hmenu);
    for (int i = 0; i < iCount; i++) {
        TCHAR szCommand[40];
        UINT id = GetMenuItemID(hmenu, i);
        if (IsInRange(id, *pid, 0x7fff )) {
            id -= *pid;
            ContextMenu_GetCommandStringVerb(pcm, id, szCommand, ARRAYSIZE(szCommand));
            if (!lstrcmpi(szCommand, TEXT("properties"))) {
                break;
            }
        }
    }
    Shell_MergeMenus(hmenu, hmenu2, i, 0, 0x7FFF, 0);
    DestroyMenu(hmenu2);
    return hmenu;
}

void CMenuSFToolbar::_OnDefaultContextCommand(int idCmd)
{
    switch (idCmd) 
    {
    case MNIDM_RESORT:
        {
            // We used to blow away the order stream and refill, but since we use the order stream
            // for calculating the presence of new items, this promoted all of the items were were 
            // sorting.

            HDPA hdpa = _hdpa;

            // For some reason we have an _hdpaOrder, so use that for persisting out
            // to the registry..
            if (_hdpaOrder)
                hdpa = _hdpaOrder;

            _SortDPA(hdpa);
            OrderList_Reorder(hdpa);
            _fChangedOrder = TRUE;

            // This call knows about _hdpa and _hdpaOrder
            _SaveOrderStream();
            // MIKESH: this is needed because otherwise FillToolbar will use the current _hdpa
            // and nothing gets changed...  I think it's because OrderItem_Compare returns failure on some of the pidls
            CMenuToolbarBase::EmptyToolbar();
            _SetDirty(TRUE);
            _LoadOrderStream();
            if (_fShow)
            {
                _FillToolbar();
            }
            break;
        }
    }
}

LRESULT CMenuSFToolbar::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    //
    // When the NoSetTaskbar restriction is set, this code will disallow 
    // Context menus. It querys up to the Start menu to ask for permission
    // to set.
    LRESULT lres = 0;

    //  No UEM on Context Menus. This avoids the problem where we expand the menubands
    // with a context menu present.
    _fSuppressUserMonitor = TRUE;

    // Allow the selected item to blow away the menus. This is explicitly for the Verbs "Open"
    // "Print" and such that launch another process. Inprocess commands are unaffected by this.
    MyLockSetForegroundWindow(FALSE);

    BOOL fOwnerIsTopmost = (WS_EX_TOPMOST & GetWindowLong(_pcmb->_pmbState->GetSubclassedHWND(), GWL_EXSTYLE));

    if (fOwnerIsTopmost)
    {
        ::SetWindowPos(_pcmb->_pmbState->GetSubclassedHWND(), HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    KillTimer(_hwndMB, MBTIMER_INFOTIP);
    _pcmb->_pmbState->HideTooltip(FALSE);

    if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_CONTEXTMENU))
        lres = CSFToolbar::_OnContextMenu(wParam, lParam);

    if (fOwnerIsTopmost)
    {
        ::SetWindowPos(_pcmb->_pmbState->GetSubclassedHWND(), HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        IUnknown_QueryServiceExec(SAFECAST(_pcmb, IOleCommandTarget*), SID_SMenuBandTop,
            &CGID_MenuBand, MBANDCID_REPOSITION, TRUE, NULL, NULL);
    }

    // Take the capture back after the context menu
    GetMessageFilter()->RetakeCapture();
    return lres;
}


HRESULT CMenuSFToolbar::_GetInfo(LPCITEMIDLIST pidl, SMINFO* psminfo)
{
    HRESULT hres;

    if (psminfo->dwMask & SMIM_TYPE)
    {
        psminfo->dwType = SMIT_STRING;
    }

    if (psminfo->dwMask & SMIM_FLAGS)
    {
        psminfo->dwFlags = SMIF_ICON | SMIF_DROPTARGET;
    }

    if (psminfo->dwMask & SMIM_ICON)
    {
        psminfo->dwMask &= ~SMIM_ICON;
        psminfo->iIcon = -1;
    }

    DWORD dwAttr = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_BROWSABLE;

    // Folders that behave like shortcuts should not be considered 
    // as cascading menu items.  Channels are an example.

    // HACKHACK: to detect channels, we originally planned to GetUIObject
    // IShellLink.  But this doesn't work on browser-only b/c it doesn't
    // pipe down to the shell extension.   So as a hack, we'll key off
    // the absence of SFGAO_FILESYSTEM.

    // Is this a folder?
    // And is it NOT a browseable folder? If it's a Browseable folder, this means that it's a namespace
    // such as the Internet Namespace. The Internet name space's shell folder does not return real items, so it
    // makes it useless in menus. So, filter it out, and treat it like an item.
    hres = _psf->GetAttributesOf(1, &pidl, &dwAttr);
    if (SUCCEEDED(hres) && 
        IsFlagSet(dwAttr, SFGAO_FOLDER) && 
        !IsFlagSet(dwAttr, SFGAO_BROWSABLE))
    {
        // Since SHIsExpandableFolder is such an expensive call, and we only need
        // it for legacy Channels support, only do this call where channels are:
        // Favorites menu and Start Menu | Favorites.
        if (_dwFlags & SMSET_HASEXPANDABLEFOLDERS)
        {
            // on integrated install, check to see if the item supports 
            // is an expandable folder.  
            if (WhichPlatform() == PLATFORM_INTEGRATED) 
            {

                // Yes; but does it also behave like a shortcut?
                if (SHIsExpandableFolder(_psf, pidl))
                    psminfo->dwFlags |= SMIF_SUBMENU;

            } 
            else if (IsFlagSet(dwAttr, SFGAO_FILESYSTEM)) 
            {

                // On browse only, we don't rev the shell, so we rely upon
                // the filesystem bit...
                // this is a bit of a hack, and then disallows you from
                // doing things like having controlpanel be in the menu
                // but it's the best we can do.
                psminfo->dwFlags |= SMIF_SUBMENU;

            }
        }
        else
        {
            // We're going to assume that if it's a folder, it really is a folder.
            psminfo->dwFlags |= SMIF_SUBMENU;
        }
    }

    CallCB(pidl, SMC_GETSFINFO, 0, (LPARAM)psminfo);

    return hres;
}


/*----------------------------------------------------------
Purpose: This function determines the toolbar button style for the
         given pidl.  

         Returns S_OK if pdwMIFFlags is also set (i.e., the object
         supported IMenuBandItem to provide more info).  S_FALSE if only
         *pdwStyle is set.

*/
HRESULT CMenuSFToolbar::_TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwStyle, DWORD* pdwState, DWORD * pdwMIFFlags, int * piIcon)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    HRESULT hres = S_FALSE;
    DWORD dwStyle = TBSTYLE_BUTTON | TBSTYLE_DROPDOWN | TBSTYLE_NOPREFIX;

    *pdwState = TBSTATE_ENABLED;
    *pdwMIFFlags = 0;
    *piIcon = -1;

    if (pidl)
    {
        SMINFO sminfo;
        sminfo.dwMask = SMIM_TYPE | SMIM_FLAGS | SMIM_ICON;

        if (SUCCEEDED(_GetInfo(pidl, &sminfo)))
        {
            *pdwMIFFlags = sminfo.dwFlags;

            if (sminfo.dwFlags & SMIF_ACCELERATOR)
                dwStyle &= ~TBSTYLE_NOPREFIX;

            if (sminfo.dwType & SMIT_SEPARATOR)
            {
                dwStyle &= ~TBSTYLE_BUTTON;
                dwStyle |= TBSTYLE_SEP;
            }

            if (sminfo.dwFlags & SMIF_ICON)
                *piIcon = sminfo.iIcon;

            if (sminfo.dwFlags & SMIF_DEMOTED &&
                !_pcmb->_fExpanded)
            {
                *pdwState |= TBSTATE_HIDDEN;
                _fHasDemotedItems = TRUE;
            }

            if (sminfo.dwFlags & SMIF_HIDDEN)
                *pdwState |= TBSTATE_HIDDEN;

            hres = S_OK;
        }
    }
    else
    {
        // For null pidls ("empty" menuitems), there is no icon. 
        // SMIF_DROPTTARGET is set so the user can drop into an empty submenu.
        *pdwMIFFlags = SMIF_DROPTARGET;

        // Return S_OK so the pdwMIFFlags is examined.  
        hres = S_OK;
    }
    *pdwStyle = dwStyle;

    return hres;
}


BOOL CMenuSFToolbar::_FilterPidl(LPCITEMIDLIST pidl)
{
    // BUGBUG raymondc PERF?  Can we short-circuit the filter?
    return S_OK == CallCB(pidl, SMC_FILTERPIDL, 0, 0);
}


void CMenuSFToolbar::_FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags)
{
    _fHasSubMenu = FALSE;

    CallCB(NULL, SMC_BEGINENUM, (WPARAM)&dwEnumFlags, 0);
    CSFToolbar::_FillDPA(hdpa, hdpaSort, dwEnumFlags);
    CallCB(NULL, SMC_ENDENUM, 0, 0);
    if (0 == DPA_GetPtrCount(hdpa) && _psf)
    {
        OrderList_Append(hdpa, NULL, -1);     // Add a bogus pidl
        _fEmpty = TRUE;
        _fHasDemotedItems = FALSE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = TRUE;

    }
    else
    {
        _fEmpty = FALSE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = FALSE;
    }
}

void CMenuSFToolbar::_AddChevron()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // Does this menu get a chevron button?
    if (_fHasDemotedItems && !_pcmb->_fExpanded && _idCmdChevron == -1)
    {
        // Yes; (we shouldn't get here if the menu is empty)
        ASSERT(!_fEmpty);   

        // Add the chevron to the top or the bottom
        if (_dwFlags & SMSET_TOP && _pcmb->_pmtbTop != _pcmb->_pmtbBottom)
            _AddOrderItemTB(NULL, 0, NULL);      // add to top
        else
            _AddOrderItemTB(NULL, -1, NULL);     // append to bottom
    }
}

void CMenuSFToolbar::_RemoveChevron()
{
    if (-1 != _idCmdChevron)
    {
        // Yes; remove the chevron
        int iPos = ToolBar_CommandToIndex(_hwndTB, _idCmdChevron);
        InlineDeleteButton(iPos);
        _idCmdChevron = -1;
    }
}


void CMenuSFToolbar::_ToolbarChanged()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _pcmb->_fForceButtonUpdate = TRUE;
    // We shouldn't change the size of the menubar while we're in the middle
    // of a delete. Wait until we're done...
    if (!_fPreventToolbarChange && _fShow && !_fEmptyingToolbar)
    {
        RECT rcOld;
        RECT rcNew;
        HWND hwndP;



        // Resize the MenuBar
        hwndP = _hwndPager ? GetParent(_hwndPager): GetParent(_hwndTB);
        GetClientRect(hwndP, &rcOld);
        _pcmb->ResizeMenuBar();
        GetClientRect(hwndP, &rcNew);

        // If the rect sizes haven't changed, then we need to re-layout the
        // band because the button widths may have changed.
        if (EqualRect(&rcOld, &rcNew))
            NegotiateSize();

        // This pane may have changed sizes. If there is a sub menu, then
        // we need to have them reposition themselves
        if (_pcmb->_fInSubMenu && _pcmb->_pmtbTracked)
        {
            _pcmb->_pmtbTracked->PositionSubmenu(-1);
            IUnknown_QueryServiceExec(_pcmb->_pmpSubMenu, SID_SMenuBandChild,
                &CGID_MenuBand, MBANDCID_REPOSITION, 0, NULL, NULL);
        }
    }
}

void CMenuSFToolbar::_FillToolbar()
{
    // Don't fill the toolbar if we're not dirty or we're emptying the toolbar
    // If we try and fill the toolbar while we're emptying we enter a race condition
    // where we could AV. This fixes a bug where when dragging a folder into the
    // start menu, and cascade a menu, we empty one toolbar, which causes the
    // other toolbar to get destroyed, unregister itself, flush the change notify
    // queue, causing the original window to empty again... (lamadio) 7.16.98
    if (_fDirty && !_fEmptyingToolbar)
    {
        LPITEMIDLIST pidlItem = NULL;
        IShellMenu* psmSubMenu = NULL;
        // Populating the menu will take a long time since we're hitting
        // the disk.  Give the user some feedback if the cursor is
        // IDC_ARROW.  (If the cursor is something else, then don't
        // mess with it.)  Note that we have to use (HCURSOR)-1 as a
        // sentinel, because it's possible that the current cursor is NULL.

        // Prevent _ToolbarChanged from Doing things. (Perf)
        _fPreventToolbarChange = TRUE;

        // Are we in a sub menu? If we are, then we don't want to blow away
        // that menu, so we save it away do the fill and put it back in.
        // This is so that if it's displayed we won't collapse it unless absoluley
        // necessary.
        if (_pcmb->_fInSubMenu)
        {
            CMenuData* pdata = (CMenuData*)_IDToPibData(_pcmb->_nItemSubMenu);

            // This can be null if the fill toolbar was because you right clicked this item and clicked
            // delete...
            if (pdata)
            {
                // If we hit this, then _nItemSubMenu is out of sync. Figure out how
                // that got set to a non-sub menu item...
                ASSERT(pdata->GetFlags() & SMIF_SUBMENU);

                // Hold onto this shell menu. We'll try and reuse it...
                pdata->GetSubMenu(NULL, IID_IShellMenu, (void**)&psmSubMenu);
                pidlItem = ILClone(pdata->GetPidl());
            }
        }

        // Remove the chevron...
        _RemoveChevron();

        // Reset this bit. Fill toolbar will set it if there are items.
        _fHasDemotedItems = FALSE;

        CSFToolbar::_FillToolbar();


        // If we had a Chevron before we refreshed the toolbar, 
        // then we need to add it back. To Short circuit the add
        // we need to set the id to -1
        _idCmdChevron = -1;
        _AddChevron();
        if (_hwndPager)
            SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);

        _fPreventToolbarChange = FALSE;

        // Are we lucky?
        if (pidlItem)
        {
            if (psmSubMenu)
            {
                // BUGBUG(lamadio): Unify this code with _ReBindToFolder.

                // Great, we have all of the information we need. Now see if this pidl wasn't
                // one slated for death: Is it now in the toolbar?
                TBBUTTONINFO tbinfo = {0};
                tbinfo.dwMask = TBIF_COMMAND | TBIF_LPARAM;
                LPCITEMIDLIST pcidl = _GetButtonFromPidl(pidlItem, &tbinfo, NULL);
                if (pcidl)
                {
                    LPITEMIDLIST pidlFull = NULL;
                    IShellFolder* psf;
                    if(_pasf2)
                    {
                        LPITEMIDLIST pidlFolder, pidlChild;
                        _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlChild, NULL);
                        pidlFull = ILCombine(pidlFolder, pidlChild);
                        ILFree(pidlChild);
                        ILFree(pidlFolder);
                    }
                    else 
                    {
                        pidlFull = ILCombine(_pidl, pcidl);
                    }

                    // We need to bind to this pidl because it may have become merged. This will 
                    // spontaniously show both namespaces. Pretty cool huh? Love object reuse...

                    _psf->BindToObject(pidlItem, NULL, IID_IShellFolder, (void**)&psf);

                    if (psf)
                    {
                        if (pidlFull)
                        {
                            // Force the New information into the Sub Menu. This will cause a reenum.
                            if (SUCCEEDED(psmSubMenu->SetShellFolder(psf, pidlFull, NULL, 0)))
                            {
                                // If this Eval fires, then this item was inserted into the
                                // toolbar with a null pointer, or it was in the process of being
                                // removed.
                                CMenuData* pmd = (CMenuData*)tbinfo.lParam;
                                if (EVAL(pmd))
                                {
                                    // Make sure to store the Sub menu pointer back in the item it came from.
                                    pmd->SetSubMenu(psmSubMenu);
                                    _pcmb->_nItemSubMenu = tbinfo.idCommand;
                                }
                            }
                        }

                        psf->Release();
                    }

                    ILFree(pidlFull);
                }
                else
                {
                    _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
                }
                psmSubMenu->Release();
            }
            ILFree(pidlItem);
        }



        _ToolbarChanged();
    }
}

void CMenuSFToolbar::v_OnDeleteButton(LPVOID pData)
{
    CMenuData* pmd = (CMenuData*)pData;
    ASSERT(pmd && IS_VALID_CODE_PTR(pmd, CMenuData));

    if (pmd)
        delete pmd;
}

void CMenuSFToolbar::v_OnEmptyToolbar()
{
    CMenuToolbarBase::v_OnEmptyToolbar();
    OrderList_Destroy(&_hdpa);
    _fDirty = TRUE;
    _nNextCommandID = 0;
}


void CMenuSFToolbar::_ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax)
{
    // We overload this function because a NULL pidl is a place hold for
    // (Empty) When there are no items, or the Chevron when there are items.

    if (pidl)
    {
        CSFToolbar::_ObtainPIDLName(pidl, psz, cchMax);
    }
    else if (_fHasDemotedItems) // Chevron Case.
    {
        StrCpyN(psz, TEXT(">>"), cchMax);
    }
    else    // Empty Case
    {
        MLLoadString(IDS_EMPTY, psz, cchMax);
    }
}        


void CMenuSFToolbar::v_NewItem(LPCITEMIDLIST pidl)
{
    // This is called when an item is present in the filesystem
    // that is not in the order stream. This occurs when an item is
    // created when the menu is not up.

    // BUGBUG (lamadio): IntelliMenus: New items are going to have a weird Promotion state
    // if there are multiple clients. Each client is going to be the create, and try to increment this.
    // We have to syncronize access to this. I'm not sure how to do this.

    // New items get promoted.
    CallCB(pidl, SMC_NEWITEM, 0, 0);

    // Since this is a new item, we want to increment the promoted items
    // so that we can do chevron tracking.
    _cPromotedItems++;
}

void CMenuSFToolbar::_SetDirty(BOOL fDirty)
{
    if (fDirty)
        _pcmb->_fForceButtonUpdate = TRUE;

    CSFToolbar::_SetDirty(fDirty);
}

void CMenuSFToolbar::_OnFSNotifyAdd(LPCITEMIDLIST pidl)
{
    DWORD dwEnumFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _RemoveChevron();
    CallCB(NULL, SMC_BEGINENUM, (WPARAM)&dwEnumFlags, 0);
    CSFToolbar::_OnFSNotifyAdd(pidl);
    CallCB(NULL, SMC_ENDENUM, 0, 0);
    _AddChevron();

    // When we add something to this, we want to promote our parent.
    IUnknown_RefreshParent(_pcmb->_punkSite, _pidl, SMINV_PROMOTE);

    _SaveOrderStream();
}

UINT ToolBar_GetVisibleCount(HWND hwnd)
{
    UINT cVis = 0;
    int cItems = ToolBar_ButtonCount(hwnd) - 1;
    for (; cItems >= 0; cItems--)
    {
        TBBUTTONINFO tbinfo;
        tbinfo.cbSize = sizeof(tbinfo);
        tbinfo.dwMask = TBIF_BYINDEX | TBIF_STATE;
        if (ToolBar_GetButtonInfo(hwnd, cItems, &tbinfo))
        {
            if (!(tbinfo.fsState & TBSTATE_HIDDEN))
            {
                cVis ++;
            }
        }
    }

    return cVis;
}

void CMenuSFToolbar::_OnFSNotifyRemove(LPCITEMIDLIST pidl)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    int i;
    _RemoveChevron();
    // Check to see if this item is a promoted guy...
    LPITEMIDLIST pidlButton = _GetButtonFromPidl(pidl, NULL, &i);
    if (pidlButton)
    {
        int idCmd = GetButtonCmd(_hwndMB, i);

        // Is he promoted?
        if (!(v_GetFlags(idCmd) & SMIF_DEMOTED))
        {
            // Yes, then we need to decrement the promoted count because
            // we are removing a promoted guy.
            _cPromotedItems--;

            // We should expand if we go to zero
            if (_cPromotedItems == 0)
            {
                // Demote the parent
                IUnknown_RefreshParent(_pcmb->_punkSite, _pidl, SMINV_DEMOTE | SMINV_NEXTSHOW);
                Expand(TRUE);
            }
        }

        if (_pcmb->_fInSubMenu && _pcmb->_nItemSubMenu == idCmd)
            _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
    }

    CSFToolbar::_OnFSNotifyRemove(pidl);

    //Oooppsss, we removed the only string. Replace with our "(Empty)"
    // handler....
    if (0 == DPA_GetPtrCount(_hdpa) && _psf && _fVerticalMB)
    {
        ASSERT(_fEmpty == FALSE);
        // If we are Empty, then we cannot have any demoted items
        // NOTE: We can have no demoted items and not be empty, so one does
        // not imply the other.
        _fHasDemotedItems = FALSE;
        _AddPidl(NULL, 0);
        _fEmpty = TRUE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = TRUE;
    }

    if (_dwFlags & SMSET_COLLAPSEONEMPTY &&
        ToolBar_GetVisibleCount(_hwndMB) == 0)
    {
        // When we don't want to be shown when empty, collapse.
        _pcmb->_SiteOnSelect(MPOS_FULLCANCEL);
    }
    _AddChevron();
}


void CMenuSFToolbar::NegotiateSize()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    RECT rc;
    HWND hwndP;

    hwndP = _hwndPager ? GetParent(_hwndPager): GetParent(_hwndTB);
    GetClientRect(hwndP, &rc);
    _pcmb->OnPosRectChangeDB(&rc);
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::DragEnter

       Informs Menuband that a drag has entered it's window.

*/
STDMETHODIMP CMenuSFToolbar::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _pcmb->_fDragEntered = TRUE;
    IOleCommandTarget * poct;
    
    _pcmb->QueryService(SID_SMenuBandTop, IID_IOleCommandTarget, (LPVOID *)&poct);

    if (poct)
    {
        poct->Exec(&CGID_MenuBand, MBANDCID_DRAGENTER, 0, NULL, NULL);
        poct->Release();
    }

    return CSFToolbar::DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::DragLeave

        Informs Menuband that a drag has left it's window.

*/
STDMETHODIMP CMenuSFToolbar::DragLeave(void)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _pcmb->_fDragEntered = FALSE;
    IOleCommandTarget * poct;
    
    _pcmb->QueryService(SID_SMenuBandTop, IID_IOleCommandTarget, (LPVOID *)&poct);

    if (poct)
    {
        poct->Exec(&CGID_MenuBand, MBANDCID_DRAGLEAVE, 0, NULL, NULL);
        poct->Release();
    }

    return CSFToolbar::DragLeave();
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::HitTestDDT

         Returns the ID to pass to GetObject.
30
*/
HRESULT CMenuSFToolbar::HitTestDDT(UINT nEvent, LPPOINT ppt, DWORD_PTR *pdwId, DWORD *pdwEffect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    TBINSERTMARK tbim;
    DWORD dwFlags = 0;
    BOOL fOnButton = FALSE;

    // If we're in drag and drop, Take UEM out of the picture
    _fSuppressUserMonitor = TRUE;

    // Unlike the CISFBand implementation, we always want to insert 
    // b/t the menu items.  So we return a negative index so the
    // GetObject method will treat all the drops as if we're dropping
    // in b/t the items, even if the cursor is over a menuitem.

    switch (nEvent)
    {
    case HTDDT_ENTER:
        // OLE is in its modal drag/drop loop, and it has the capture.
        // We shouldn't take the capture back during this time.
        if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) &&
            (S_FALSE == CallCB(NULL, SMC_SFDDRESTRICTED, NULL, NULL)))
        {
            // Since we've been entered, set the global state as
            // having the drag. If at some point the whole menu
            // heirarchy does not have the drag inside of it, we want to 
            // collapse the menu. This is to prevent the hanging menu syndrome.
            _pcmb->_pmbState->HasDrag(TRUE);
            KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
            GetMessageFilter()->PreventCapture(TRUE);
            return S_OK;
        }
        else
            return S_FALSE;

    case HTDDT_OVER:
        BLOCK
        {
            int iButton;

            *pdwEffect = DROPEFFECT_NONE;

            POINT pt = *ppt;
            ClientToScreen(_hwndTB, &pt);
            if (WindowFromPoint(pt) == _hwndPager ) 
            {
                iButton = IBHT_PAGER;
            } 
            else 
            {
                // Are we sitting BETWEEN buttons?
                if (ToolBar_InsertMarkHitTest(_hwndTB, ppt, &tbim))
                {
                    // Yes.

                    // Is this on the source button?
                    if (!(tbim.dwFlags & TBIMHT_BACKGROUND) && 
                        tbim.iButton == _iDragSource)
                    {
                        iButton = IBHT_SOURCE; // Yes; don't drop on the source button
                    }
                    else
                    {
                        iButton = tbim.iButton;
                    }
                }
                // No we're either sitting on a button or the background. Button?
                else if (tbim.iButton != -1 && !(tbim.dwFlags & TBIMHT_BACKGROUND))
                {
                    // On a Button. Cool.
                    iButton = tbim.iButton;
                    fOnButton = TRUE;
                }

                // Can this drop target even accept the drop?
                int idBtn = GetButtonCmd(_hwndTB, tbim.iButton);
                dwFlags = v_GetFlags(idBtn);
                if ( _idCmdChevron != idBtn &&
                    !(dwFlags & (SMIF_DROPTARGET | SMIF_DROPCASCADE)) ||
                    ((_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) ||
                    (S_OK == CallCB(NULL, SMC_SFDDRESTRICTED, NULL, NULL))))
                {
                    // No
                    return E_FAIL;
                }
            }
            *pdwId = iButton;
        }
        break;

    case HTDDT_LEAVE:
        // If the dropped occured in this band, then we don't want to collapse the menu
        if (!_fHasDrop)
        {
            // Since we've been left, set the global state. If moving between panes
            // then the pane that will be entered will reset this within the timeout period
            _pcmb->_pmbState->HasDrag(FALSE);
            _SetTimer(MBTIMER_DRAGPOPDOWN);
        }

        // We can take the capture back anytime now
        GetMessageFilter()->PreventCapture(FALSE);

        if (!_fVerticalMB)
        {
            tbim = _tbim;
        }
        else
        {
            // Turn off the insertion mark
            tbim.iButton = -1;
            tbim.dwFlags = 0;
            DAD_ShowDragImage(FALSE);
            ToolBar_SetInsertMark(_hwndTB, &tbim);
            UpdateWindow(_hwndTB);
            DAD_ShowDragImage(TRUE);
        }
        break;
    }

    // Did the drop target change?
    if (tbim.iButton != _tbim.iButton || tbim.dwFlags != _tbim.dwFlags)
    {
        DAD_ShowDragImage(FALSE);
        // Yes

        // If we're sitting on a button, highlight it. Otherwise remove the hightlight.
        //ToolBar_SetHotItem(_hwndTB, fOnButton? tbim.iButton : -1);

        // No.
        // We pop open submenus here during drag and drop.  But only
        // if the button has changed (not the flags).  Otherwise we'd
        // get flashing submenus as the cursor moves w/in a single item.
        if (tbim.iButton != _tbim.iButton)
        {
            _SetTimer(MBTIMER_DRAGOVER);
            BOOL_PTR fOldAnchor = ToolBar_SetAnchorHighlight(_hwndTB, FALSE);
            ToolBar_SetHotItem(_hwndTB, -1);
            _pcmb->_SiteOnSelect(MPOS_CHILDTRACKING);
            ToolBar_SetAnchorHighlight(_hwndTB, fOldAnchor);
        }

        // for now I don't want to rely on non-filesystem IShellFolder
        // implementations to call our OnChange method when a drop occurs,
        // so don't even show the insert mark.
        // We do not want to display the Insert mark if we do not allow reorder.
        if ((_fFSNotify || _iDragSource >= 0) && (dwFlags & SMIF_DROPTARGET) && _fAllowReorder)
        {
            ToolBar_SetInsertMark(_hwndTB, &tbim);
        }

        if (ppt)
            _tbim = tbim;

        UpdateWindow(_hwndTB);
        DAD_ShowDragImage(TRUE);
    }

    if (!_fVerticalMB && HTDDT_LEAVE == nEvent)
    {
        // Cursor leaving menuband, reset
        _tbim.iButton = -1;
        _iDragSource = -1;
    }

    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetObjectDDT

*/
HRESULT CMenuSFToolbar::GetObjectDDT(DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = E_NOINTERFACE;
    int nID = (int)dwId;

    *ppvObj = NULL;

    if (nID == IBHT_PAGER)
    {
        SendMessage(_hwndPager, PGM_GETDROPTARGET, 0, (LPARAM)ppvObj);
    }
    // Is the target the source?
    else if (IBHT_SOURCE != nID && IBHT_BACKGROUND != nID)
    {
        // No; does the shellfolder support IDropTarget?
        // We want to pass the subclassed HWND, because all we want the parent of the context menus to be
        // the Subclassed window. This is so we don't loose focus and collapse.
        hres = _psf->CreateViewObject(_pcmb->_pmbState->GetWorkerWindow(_hwndMB), riid, ppvObj);
    }

    if (*ppvObj)
        hres = S_OK;

    //TraceMsg(TF_BAND, "ISFBand::GetObject(%d) returns %x", dwId, hres);

    return hres;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::OnDropDDT

Returns: S_OK if the drop was handled.  Otherwise S_FALSE.
*/
HRESULT CMenuSFToolbar::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // Since the modal drag-drop loop released the capture, take it
    // back so we behave properly.
    KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
    HRESULT hres = S_FALSE;

    // We need to say that the last drag leave is really the drop.
    _fHasDrop = TRUE;
    _idCmdDragging = -1;
    MyLockSetForegroundWindow(TRUE);

    // Only send an hwnd to the callback if the drop source is external
    if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) &&
        (S_FALSE == CallCB(NULL, SMC_SFDDRESTRICTED, (WPARAM)pdtobj,
                           (LPARAM)(_iDragSource < 0 ? GetHWNDForUIObject() : NULL)) ))
    {

        _RemoveChevron();
        hres = CSFToolbar::OnDropDDT(pdt, pdtobj, pgrfKeyState, pt, pdwEffect);
        _AddChevron();
    }

    return hres;
}


PIBDATA CMenuSFToolbar::_AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb)
{
    PIBDATA pibd = CSFToolbar::_AddOrderItemTB(poi, index, ptbb);

    if (pibd)
    {
        if (pibd->GetFlags() & SMIF_SUBMENU) 
        {
            _fHasSubMenu = TRUE;
        }

        // A null pidl means one of two things:
        //   1) a menu item called "(Empty)", or
        //   2) a chevron button

        // Are we adding the chevron button?
        if (!pibd->GetPidl() && _fHasDemotedItems)
        {
            // Yes; the chevron is either the first item in the toolbar or the last item.
            int iPos = (index == 0) ? 0 : ToolBar_ButtonCount(_hwndTB) - 1;

            _idCmdChevron = GetButtonCmd(_hwndTB, iPos);
        }
    }

    return pibd;
}


BOOL CMenuSFToolbar::_AddPidl(LPITEMIDLIST pidl, int index)
{
    BOOL bRet;
    
    // Is this item being added to an empty menu?
    if (_fEmpty)
    {
        // Yes; remove the empty menu item
        InlineDeleteButton(0);
        DPA_DeletePtr(_hdpa, 0);
        _fEmpty = FALSE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = FALSE;

        bRet = CSFToolbar::_AddPidl(pidl, index);

        // Failed to add new item?
        if (!bRet)
        {
            // Yes; add the empty menu item back
            OrderList_Append(_hdpa, NULL, -1);     // Add a bogus pidl
            _fEmpty = TRUE;
            _fHasDemotedItems = FALSE;
            if (_dwFlags & SMSET_NOEMPTY)
                _fDontShowEmpty = TRUE;
        }
        
    }
    else
        bRet = CSFToolbar::_AddPidl(pidl, index);

    return bRet;
}

BOOL CMenuSFToolbar::_ReBindToFolder(LPCITEMIDLIST pidl)
{

    // We may be able to share this code with the code in _FillToolbar, but the difference is,
    // in Fill Toolbar, the Toolbar Button does not have a Sub Menu. We reinitialize one we save away,
    // and force it back into the child button. Here, we have the luxury of having the Sub Menu still
    // in the toolbar button. I may be able to extract common code into a separate function. Left
    // as an exercise to the reader.

    // Need special Handling for this. We need to free the sub menu and
    // rebind to it ifit's up.
    BOOL fBound = FALSE;
    TBBUTTONINFO tbinfo = {0};
    tbinfo.dwMask = TBIF_COMMAND | TBIF_LPARAM;
    LPCITEMIDLIST pidlItem = _GetButtonFromPidl(ILFindLastID(pidl), &tbinfo, NULL);
    if (pidlItem)
    {
        CMenuData* pmd = (CMenuData*)tbinfo.lParam;
        if (EVAL(pmd))
        {
            IShellFolderBand* psfb;

            // We have the Toolbar button into, we should see if it has a sub menu associated with it.
            if (SUCCEEDED(pmd->GetSubMenu(&SID_MenuShellFolder, IID_IShellFolderBand, (void**)&psfb)))
            {
                // It does. Then reuse!
                LPITEMIDLIST pidlFull = NULL;
                IShellFolder* psf = NULL;
                if(_pasf2)
                {
                    LPITEMIDLIST pidlFolder, pidlChild;
                    // Remember: Folder pidls must be unwrapped. 
                   _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlChild, NULL);
                   pidlFull = ILCombine(pidlFolder, pidlChild);
                   ILFree(pidlChild);
                   ILFree(pidlFolder);
                }
                else
                {
                    // Not a wrapped guy, Sweet!
                    pidlFull = ILCombine(_pidl, pidlItem);
                }

                _psf->BindToObject(pidlItem, NULL, IID_IShellFolder, (void**)&psf);

                if (psf)
                {
                    if (pidlFull)
                    {
                        fBound = SUCCEEDED(psfb->InitializeSFB(psf, pidlFull));
                        if (fBound)
                        {
                            _pcmb->_nItemSubMenu = tbinfo.idCommand;
                        }
                    }

                    psf->Release();
                }
                ILFree(pidlFull);
                psfb->Release();
            }
        }
    }

    return fBound;
}


HRESULT CMenuSFToolbar::OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = CSFToolbar::OnTranslatedChange(lEvent, pidl1, pidl2);
    

    // Deal with SubMenus:

    if (SUCCEEDED(hres))
    {
        switch(lEvent)
        {
        case SHCNE_RENAMEFOLDER:
            if (_IsChildID(pidl2, TRUE))
            {
                _ReBindToFolder(pidl2);
            }
            break;

        case SHCNE_RMDIR:
            if (_IsChildID(pidl1, TRUE))
            {
                _ReBindToFolder(pidl1);
            }
            break;

        case SHCNE_EXTENDED_EVENT:
            {
                SHChangeDWORDAsIDList UNALIGNED * pdwidl = (SHChangeDWORDAsIDList UNALIGNED *)pidl1;
                if (pidl2 && _IsChildID(pidl2, TRUE))
                {
                    if (!SHChangeMenuWasSentByMe(this, pidl1))
                    {
                        DWORD dwFlags = SMINV_NOCALLBACK;   // So that we don't doubly increment
                        SMDATA smd = {0};
                        smd.dwMask = SMDM_SHELLFOLDER;
                        smd.pidlFolder = _pidl;
                        smd.pidlItem = ILFindLastID(pidl2);


                        // Syncronize Promotion state.
                        if (pdwidl->dwItem1 == SHCNEE_PROMOTEDITEM)
    