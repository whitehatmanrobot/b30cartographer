 {
        DbgLog((LOG_TRACE,2,TEXT("IAMVideoStreamConfig::SetFormat rejected")));
        return hr;
    }

    // If we are connected to somebody, make sure they like it
    if (IsConnected()) {
        hr = GetConnected()->QueryAccept(pmt);
        if (hr != NOERROR)
            return VFW_E_INVALIDMEDIATYPE;
    }

    LPWAVEFORMATEX lpwfx = (LPWAVEFORMATEX)pmt->pbFormat;

    // verify we can open the device for real with this format
    hr = m_pFilter->OpenWaveDevice( lpwfx );
    if( SUCCEEDED( hr ) )
    {
        m_pFilter->CloseWaveDevice( );

        // OK, we're using it
        hr = SetMediaType((CMediaType *)pmt);

        // make this the default format to offer from now on
        if (lpwfx->cbSize > 0 || 0 == m_pFilter->m_cTypes)
        {
            if (m_pFilter->m_lpwfxArray[0])
                QzTaskMemFree(m_pFilter->m_lpwfxArray[0]);
            m_pFilter->m_lpwfxArray[0] = (LPWAVEFORMATEX)QzTaskMemAlloc(
                            sizeof(WAVEFORMATEX) + lpwfx->cbSize);
            if (m_pFilter->m_lpwfxArray[0] == NULL)
                return E_OUTOFMEMORY;
        }
        CopyMemory(m_pFilter->m_lpwfxArray[0], lpwfx, sizeof(WAVEFORMATEX) + lpwfx->cbSize);

        if (m_pFilter->m_cTypes == 0) {
            m_pFilter->m_cTypes = 1;
        }

        // Changing the format means reconnecting if necessary
        if (hr == NOERROR)
            Reconnect();
    }
    return hr;
}


HRESULT CWaveInOutputPin::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetFormat")));

    if (ppmt == NULL)
    return E_POINTER;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
    return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(0, (CMediaType *)*ppmt);
    if (hr != NOERROR) {
    CoTaskMemFree(*ppmt);
    *ppmt = NULL;
    return hr;
    }
    return NOERROR;
}


HRESULT CWaveInOutputPin::GetNumberOfCapabilities(int *piCount, int *piSize)
{
    if (piCount == NULL || piSize == NULL)
    return E_POINTER;

    HRESULT hr = InitMediaTypes();
    if (FAILED(hr))
        return hr;

    *piCount = m_pFilter->m_cTypes;
    *piSize = sizeof(AUDIO_STREAM_CONFIG_CAPS);

    return NOERROR;
}


HRESULT CWaveInOutputPin::GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC)
{
    BOOL fDoesStereo, fDoes96, fDoes48, fDoes44, fDoes22, fDoes16;
    AUDIO_STREAM_CONFIG_CAPS *pASCC = (AUDIO_STREAM_CONFIG_CAPS *)pSCC;

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetStreamCaps")));

    if (i < 0)
        return E_INVALIDARG;
    if (pSCC == NULL || ppmt == NULL)
        return E_POINTER;

    if (i >= m_pFilter->m_cTypes)
        return S_FALSE;


    HRESULT hr = InitWaveCaps(&fDoesStereo, &fDoes96, &fDoes48, &fDoes44, &fDoes22, &fDoes16);
    if (FAILED(hr))
        return hr;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    hr = GetMediaType(i, (CMediaType *) *ppmt);
    if (hr != NOERROR) {
        CoTaskMemFree(*ppmt);
        *ppmt = NULL;
        return hr;
    }

    // !!! We might support more than this, and I won't admit to it
    // !!! We could be more accurate if we wanted

    pASCC->guid = MEDIATYPE_Audio;
    pASCC->MinimumChannels = 1;
    pASCC->MaximumChannels = fDoesStereo ? 2 : 1;
    pASCC->ChannelsGranularity = 1;
    pASCC->MinimumSampleFrequency = 11025;
    pASCC->MaximumSampleFrequency = fDoes44 ? 44100 : (fDoes22 ? 22050 : 11025);
    pASCC->SampleFrequencyGranularity = 11025; // bogus, really...
    pASCC->MinimumBitsPerSample = 8;
    pASCC->MaximumBitsPerSample = fDoes16 ? 16 : 8;
    pASCC->BitsPerSampleGranularity = 8;

    return NOERROR;
}


HRESULT CWaveInOutputPin::InitMediaTypes(void)
{
    DWORD dw;
    WAVEINCAPS caps;

    HRESULT hr = S_OK;
    if ( 1 < m_pFilter->m_cTypes )
    {
        return NOERROR;         // our type list is already initialized
    }
    else if( 0 == m_pFilter->m_cTypes )
    {
        // we haven't been initialized with a default type yet, do this first
        hr = m_pFilter->LoadDefaultType();
        if( FAILED( hr ) )
            return hr;
    }
    ASSERT (1 == m_pFilter->m_cTypes); // should have just the single default type

    // build the type list
    ASSERT(m_pFilter->m_WaveDeviceToUse.fSet);
    dw = waveInGetDevCaps(m_pFilter->m_WaveDeviceToUse.devnum, &caps,
                            sizeof(caps));
    if (dw != 0)
    {
        m_pFilter->NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_GetCaps, dw );
        DbgLog((LOG_ERROR,1,TEXT("waveInGetDevCaps returned error: %u"), dw));
        return E_FAIL;
    }

    // Now build our type list, but note that we always offer our default type
    // first (element 0).
    for (int i = 0; i < g_cMaxFormats; i ++)
    {
        if (caps.dwFormats & g_afiFormats[i].dwType)
        {
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes] = (LPWAVEFORMATEX) QzTaskMemAlloc(
                                                            sizeof (WAVEFORMATEX));
            if (!m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes])
                return E_OUTOFMEMORY;

            ZeroMemory(m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes], sizeof (WAVEFORMATEX));

            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->wFormatTag      = WAVE_FORMAT_PCM;
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->wBitsPerSample  = g_afiFormats[i].wBitsPerSample;
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->nChannels       = g_afiFormats[i].nChannels;
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->nSamplesPerSec  = g_afiFormats[i].nSamplesPerSec;
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->nBlockAlign     = g_afiFormats[i].nChannels *
                                                                            ((g_afiFormats[i].wBitsPerSample + 7)/8);
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->nAvgBytesPerSec = g_afiFormats[i].nSamplesPerSec *
                                                                            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->nBlockAlign;
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->cbSize          = 0;

            m_pFilter->m_cTypes++;
        }
        else if (NO_CAPS_FLAG_FORMAT == g_afiFormats[i].dwType)
        {
            // we must query for this one directly
            WAVEFORMATEX wfx;
            wfx.wFormatTag          = WAVE_FORMAT_PCM;
            wfx.nSamplesPerSec      = g_afiFormats[i].nSamplesPerSec;
            wfx.nChannels           = g_afiFormats[i].nChannels;
            wfx.wBitsPerSample      = g_afiFormats[i].wBitsPerSample;
            wfx.nBlockAlign         = g_afiFormats[i].nChannels *
                                      ((g_afiFormats[i].wBitsPerSample + 7)/8);
            wfx.nAvgBytesPerSec     = g_afiFormats[i].nSamplesPerSec * wfx.nBlockAlign;
            wfx.cbSize              = 0;

            MMRESULT mmr = waveInOpen( NULL
                                     , m_pFilter->m_WaveDeviceToUse.devnum
                                     , &wfx
                                     , 0
                                     , 0
                                     , WAVE_FORMAT_QUERY );
            if( MMSYSERR_NOERROR == mmr )
            {
                // type is supported, so add to our list
                m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes] = (LPWAVEFORMATEX) QzTaskMemAlloc(
                                                                sizeof (WAVEFORMATEX));
                if (!m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes])
                    return E_OUTOFMEMORY;

                ZeroMemory(m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes], sizeof (WAVEFORMATEX));

                *m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes] = wfx;
                m_pFilter->m_cTypes++;
            }
        }
    }

    return NOERROR;
}


HRESULT CWaveInOutputPin::InitWaveCaps(BOOL *pfDoesStereo, BOOL *pfDoes96, BOOL *pfDoes48,
                        BOOL *pfDoes44, BOOL *pfDoes22, BOOL *pfDoes16)
{
    DWORD dw;
    WAVEINCAPS caps;

    if (pfDoesStereo == NULL || pfDoes44 == NULL || pfDoes22 == NULL ||
        pfDoes48 == NULL || pfDoes96 == NULL || pfDoes16 == NULL)
    return E_POINTER;

    ASSERT(m_pFilter->m_WaveDeviceToUse.fSet);
    dw = waveInGetDevCaps(m_pFilter->m_WaveDeviceToUse.devnum, &caps,
                            sizeof(caps));
    if (dw != 0)
    {
        m_pFilter->NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_GetCaps, dw );
        DbgLog((LOG_ERROR,1,TEXT("waveInGetDevCaps returned error: %u"), dw));

        return E_FAIL;
    }

    *pfDoesStereo = (caps.wChannels > 1);

    //
    // note that the 96 and 48kHz format flags were added in Whistler
    // so the reported freq range may be incomplete on legacy platforms
    //
    *pfDoes96 = (caps.dwFormats & WAVE_FORMAT_96S16 ||
                caps.dwFormats & WAVE_FORMAT_96M16);

    *pfDoes48 = (caps.dwFormats & WAVE_FORMAT_48S16 ||
                caps.dwFormats & WAVE_FORMAT_48M16);

    *pfDoes44 = (caps.dwFormats & WAVE_FORMAT_4M08 ||
                caps.dwFormats & WAVE_FORMAT_4S08 ||
                    caps.dwFormats & WAVE_FORMAT_4M16 ||
                caps.dwFormats & WAVE_FORMAT_4S16);
    *pfDoes22 = (caps.dwFormats & WAVE_FORMAT_2M08 ||
                caps.dwFormats & WAVE_FORMAT_2S08 ||
                    caps.dwFormats & WAVE_FORMAT_2M16 ||
                caps.dwFormats & WAVE_FORMAT_2S16);
    *pfDoes16 = (caps.dwFormats & WAVE_FORMAT_1M16 ||
                caps.dwFormats & WAVE_FORMAT_1S16 ||
                    caps.dwFormats & WAVE_FORMAT_2M16 ||
                caps.dwFormats & WAVE_FORMAT_2S16 ||
                    caps.dwFormats & WAVE_FORMAT_4M16 ||
                caps.dwFormats & WAVE_FORMAT_4S16);
    return NOERROR;
}



///////////////////////////////
// IAMBufferNegotiation methods
///////////////////////////////

HRESULT CWaveInOutputPin::SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES *pprop)
{
    DbgLog((LOG_TRACE,2,TEXT("SuggestAllocatorProperties")));

    // to make sure we're not in the middle of connecting
    CAutoLock cObjectLock(m_pFilter);

    if (pprop == NULL)
	return E_POINTER;

    // sorry, too late
    if (IsConnected())
        return VFW_E_ALREADY_CONNECTED;

    m_propSuggested = *pprop;

    DbgLog((LOG_TRACE,2,TEXT("cBuffers-%d  cbBuffer-%d  cbAlign-%d  cbPrefix-%d"),
        pprop->cBuffers, pprop->cbBuffer, pprop->cbAlign, pprop->cbPrefix));

    return NOERROR;
}


HRESULT CWaveInOutputPin::GetAllocatorProperties(ALLOCATOR_PROPERTIES *pprop)
{
    DbgLog((LOG_TRACE,2,TEXT("GetAllocatorProperties")));

    // to make sure we're not in the middle of connecting
    CAutoLock cObjectLock(m_pFilter);

    if (!IsConnected())
    return VFW_E_NOT_CONNECTED;

    if (pprop == NULL)
    return E_POINTER;

    if (m_fUsingOurAllocator) {
        pprop->cbBuffer = m_pOurAllocator->m_lSize;
        pprop->cBuffers = m_pOurAllocator->m_lCount;
        pprop->cbAlign = m_pOurAllocator->m_lAlignment;
        pprop->cbPrefix = m_pOurAllocator->m_lPrefix;
    } else {
    ASSERT(FALSE);
    return E_FAIL;    // won't happen
    }

    return NOERROR;
}

//-----------------------------------------------------------------------------
//                  IAMPushSource implementation
//-----------------------------------------------------------------------------

HRESULT CWaveInOutputPin::SetPushSourceFlags(ULONG Flags)
{
    m_pFilter->m_ulPushSourceFlags = Flags;
    return S_OK;

} // SetPushSourceFlags

HRESULT CWaveInOutputPin::GetPushSourceFlags(ULONG *pFlags)
{
    *pFlags = m_pFilter->m_ulPushSourceFlags;
    return S_OK;

} // GetPushSourceFlags

HRESULT CWaveInOutputPin::GetLatency( REFERENCE_TIME  *prtLatency )
{
    *prtLatency = m_rtLatency;
    return S_OK;
}

HRESULT CWaveInOutputPin::SetStreamOffset( REFERENCE_TIME  rtOffset )
{
    HRESULT hr = S_OK;
    //
    // if someone attempts to set an offset larger then our max assert
    // in debug for the moment...
    //
    // it may be ok to set a larger offset than we know we can handle, if
    // there's sufficient downstream buffering. but we'll return S_FALSE
    // in that case to warn the user in that case that they need to handle
    // this themselves.
    //
    ASSERT( rtOffset <= m_rtMaxStreamOffset );
    if( rtOffset > m_rtMaxStreamOffset )
    {
        DbgLog( ( LOG_TRACE
              , 1
              , TEXT("CWaveInOutputPin::SetStreamOffset trying to set offset of %dms when limit is %dms")
              , rtOffset
              , m_rtMaxStreamOffset ) );
        hr = S_FALSE;
        // but set it anyway
    }
    m_rtStreamOffset = rtOffset;

    return hr;
}

HRESULT CWaveInOutputPin::GetStreamOffset( REFERENCE_TIME  *prtOffset )
{
    *prtOffset = m_rtStreamOffset;
    return S_OK;
}

HRESULT CWaveInOutputPin::GetMaxStreamOffset( REFERENCE_TIME  *prtMaxOffset )
{
    *prtMaxOffset = m_rtMaxStreamOffset;
    return S_OK;
}

HRESULT CWaveInOutputPin::SetMaxStreamOffset( REFERENCE_TIME  rtMaxOffset )
{
    m_rtMaxStreamOffset = rtMaxOffset; // we don't really care about this at this point
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////


void CWaveInFilter::MakeSomeInputPins(int waveID, HRESULT *phr)
{
    // this doesn't appear to work for wave mapper. oh uh.
    ASSERT(waveID != WAVE_MAPPER);

    // get an ID to talk to the Mixer APIs.  They are BROKEN if we don't do
    // it this way!
    HMIXEROBJ ID;
    UINT IDtmp;
    DWORD dw = mixerGetID((HMIXEROBJ)IntToPtr(waveID), &IDtmp, MIXER_OBJECTF_WAVEIN);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("ERROR getting mixer ID")));
	return;
    }
    ID = (HMIXEROBJ)UIntToPtr(IDtmp);

    // find out how many sources we can mix (that's how many pins we need)
    MIXERLINE mixerline;
    mixerline.cbStruct = sizeof(MIXERLINE);
    mixerline.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;
    dw = mixerGetLineInfo(ID, &mixerline,
                    MIXER_GETLINEINFOF_COMPONENTTYPE);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot get info for WAVE INPUT dst")));
	*phr = E_FAIL;
	return;
    }
    int iPinCount = mixerline.cConnections;
    DWORD dwDestination = mixerline.dwDestination;
    DbgLog((LOG_TRACE,1,TEXT("Destination %d has %d sources"), dwDestination,
                                iPinCount));
    if (iPinCount > MAX_INPUT_PINS) {
        DbgLog((LOG_ERROR,1,TEXT("ACK!! Too many input lines!")));
	iPinCount = MAX_INPUT_PINS;
    }

    m_dwDstLineID = mixerline.dwLineID;

    // see if this device supports a Mux control on its input lines
    MIXERCONTROLDETAILS_LISTTEXT *pmxcd_lt = NULL;
    int cChannels;
    MIXERCONTROL mc;
    MIXERCONTROLDETAILS mixerdetails;
    DWORD dwMuxDetails = -1;

    dw = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MUX, &ID, &cChannels, &mc);

    if (dw == NOERROR) {

        // yes, it does, so we'll use this info when we create our input pins
        pmxcd_lt = new MIXERCONTROLDETAILS_LISTTEXT[mc.cMultipleItems];

        if (pmxcd_lt) {
            mixerdetails.cbStruct = sizeof(mixerdetails);
            mixerdetails.dwControlID = mc.dwControlID;
            mixerdetails.cChannels = 1;
            mixerdetails.cMultipleItems = mc.cMultipleItems;
            mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXT);
            mixerdetails.paDetails = pmxcd_lt;

            dwMuxDetails = mixerGetControlDetails(ID, &mixerdetails, MIXER_GETCONTROLDETAILSF_LISTTEXT);
        }
    }

    // Now make that many pins
    int i;
    for (i = 0; i < iPinCount; i++) {
        WCHAR wszPinName[MIXER_LONG_NAME_CHARS];

        // what is this input line's name in UNICODE?
        ZeroMemory(&mixerline, sizeof(mixerline));
        mixerline.cbStruct = sizeof(mixerline);
        mixerline.dwDestination = dwDestination;
        mixerline.dwSource = i;
        dw = mixerGetLineInfo(ID, &mixerline, MIXER_GETLINEINFOF_SOURCE);
        if (dw == 0) {
#ifdef UNICODE
            lstrcpyW(wszPinName, mixerline.szName);
#else
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, mixerline.szName,
                    -1, wszPinName, MIXER_LONG_NAME_CHARS);
#endif
        } else {
            DbgLog((LOG_ERROR,1,TEXT("Can't get pin#%d's name - %d"), i, dw));
            lstrcpyW(wszPinName, L"Unknown");
        }

        DWORD dwMuxIndex = 0xffffffff;
        if (pmxcd_lt && ( 0 == dwMuxDetails ) ) {
            // then this device supports a mux control so see if one of the mux inputs matches
            // the current line. if so, use this info when we create the pin.
            for (DWORD dwMux = 0; dwMux < mixerdetails.cMultipleItems; dwMux++) {
                if (!lstrcmp(mixerline.szName,pmxcd_lt[dwMux].szName)) {
                    dwMuxIndex = dwMux;
                    break;
                }
            }
        }
        DbgLog((LOG_TRACE, 1, TEXT("Pin %d: mux index %d"), i, dwMuxIndex));
	
        m_pInputPin[i] = new CWaveInInputPin(NAME("WaveIn Input Line"), this, mixerline.dwLineID,
                        dwMuxIndex, phr, wszPinName);
        if (!m_pInputPin[i])
            *phr = E_OUTOFMEMORY;

        if (FAILED(*phr)) {
            DbgLog((LOG_ERROR,1,TEXT("ACK!! Can't create all inputs!")));
            break;
        }
        m_cInputPins++;
    }

    // delete any memory we may have allocated for a Mux control
    delete[] pmxcd_lt;

    return;
}

#define MAX_TREBLE 6.0        // !!! I HAVE NO IDEA HOW MANY dB THE RANGE IS!
#define MAX_BASS   6.0        // !!! I HAVE NO IDEA HOW MANY dB THE RANGE IS!


//============================================================================

/////////////////////
// IAMAudioInputMixer
/////////////////////


// Get info about a control for this pin... eg. volume, mute, etc.
// Also get a handle for calling further mixer APIs
// Also get the number of channels for this pin (mono vs. stereo input)
//
HRESULT CWaveInFilter::GetMixerControl(DWORD dwControlType, HMIXEROBJ *pID,
                int *pcChannels, MIXERCONTROL *pmc)
{
    int i, waveID;
    HMIXEROBJ ID;
    DWORD dw;
    MIXERLINE mixerinfo;
    MIXERLINECONTROLS mixercontrol;

    if (pID == NULL || pmc == NULL || pcChannels == NULL)
	return E_POINTER;

    if(!m_WaveDeviceToUse.fSet)
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("CWaveInFilter:GetMixerControl called before Load")));
        return E_UNEXPECTED;
    }

    // !!! this doesn't appear to work for wave mapper. oh uh.
    waveID = m_WaveDeviceToUse.devnum;
    ASSERT(waveID != WAVE_MAPPER);

    // get an ID to talk to the Mixer APIs.  They are BROKEN if we don't do
    // it this way!
    UINT IDtmp;
    dw = mixerGetID((HMIXEROBJ)IntToPtr(waveID), &IDtmp, MIXER_OBJECTF_WAVEIN);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*ERROR getting mixer ID")));
	return E_FAIL;
    }
    ID = (HMIXEROBJ)UIntToPtr(IDtmp);

    *pID = ID;

    // get info about the overall WAVE INPUT destination channel
    mixerinfo.cbStruct = sizeof(mixerinfo);
    mixerinfo.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;
    dw = mixerGetLineInfo(ID, &mixerinfo,
                    MIXER_GETLINEINFOF_COMPONENTTYPE);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot get info for WAVE INPUT dst")));
	return E_FAIL;
    }

    // make sure this destination supports some controls
    if( 0 == mixerinfo.cControls )
    {
        DbgLog((LOG_TRACE,2,TEXT("This mixer destination line supports no controls")));
        return E_FAIL;
    }

    *pcChannels = mixerinfo.cChannels;

#if 1
    MIXERCONTROL mxc;

    DbgLog((LOG_TRACE,1,TEXT("Trying to get line control"), dwControlType));
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = mixerinfo.dwLineID;
    mixercontrol.dwControlID = dwControlType;
    mixercontrol.cControls = 1;
    mixercontrol.pamxctrl = &mxc;
    mixercontrol.cbmxctrl = sizeof(mxc);

    mxc.cbStruct = sizeof(mxc);

    dw = mixerGetLineControls(ID, &mixercontrol, MIXER_GETLINECONTROLSF_ONEBYTYPE);

    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting line controls"), dw));
    } else {
	*pmc = mxc;
	
	return NOERROR;
    }
#else
    // Get info about ALL the controls on this destination.. stuff that is
    // filter-wide
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = mixerinfo.dwLineID;
    mixercontrol.cControls = mixerinfo.cControls;
    mixercontrol.pamxctrl = (MIXERCONTROL *)QzTaskMemAlloc(mixerinfo.cControls *
                            sizeof(MIXERCONTROL));
    if (mixercontrol.pamxctrl == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot allocate control array")));
	return E_OUTOFMEMORY;
    }
    mixercontrol.cbmxctrl = sizeof(MIXERCONTROL);
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
	mixercontrol.pamxctrl[i].cbStruct = sizeof(MIXERCONTROL);
    }
    dw = mixerGetLineControls(ID, &mixercontrol, MIXER_GETLINECONTROLSF_ALL);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %d getting line controls"), dw));
	QzTaskMemFree(mixercontrol.pamxctrl);
	return E_FAIL;
    }

    // Now find the control they are interested in and return it
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
// !!! TEST ONLY
#if 0
            DbgLog((LOG_TRACE,1,TEXT("Found %x '%s' control"),
                mixercontrol.pamxctrl[i].dwControlType,
                mixercontrol.pamxctrl[i].szName));
            DbgLog((LOG_TRACE,1,TEXT("Range %d-%d by %d"),
                mixercontrol.pamxctrl[i].Bounds.dwMinimum,
                mixercontrol.pamxctrl[i].Bounds.dwMaximum,
                mixercontrol.pamxctrl[i].Metrics.cSteps));
#endif
    if (mixercontrol.pamxctrl[i].dwControlType == dwControlType) {
            DbgLog((LOG_TRACE,1,TEXT("Found %x '%s' control"),
                mixercontrol.pamxctrl[i].dwControlType,
                mixercontrol.pamxctrl[i].szName));
            DbgLog((LOG_TRACE,1,TEXT("Range %d-%d by %d"),
                mixercontrol.pamxctrl[i].Bounds.dwMinimum,
                mixercontrol.pamxctrl[i].Bounds.dwMaximum,
                mixercontrol.pamxctrl[i].Metrics.cSteps));
        CopyMemory(pmc, &mixercontrol.pamxctrl[i],
                    mixercontrol.pamxctrl[i].cbStruct);
            QzTaskMemFree(mixercontrol.pamxctrl);
            return NOERROR;
    }
    }
    QzTaskMemFree(mixercontrol.pamxctrl);
#endif
    return E_NOTIMPL;    // ???
}


HRESULT CWaveInFilter::put_Mono(BOOL fMono)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_Mono %d"), fMono));

    // Get the Mono switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MONO, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mono control"), hr));
    return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    mixerbool.fValue = fMono;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting mono control"), dw));
	return E_FAIL;
    }
    return NOERROR;
}


HRESULT CWaveInFilter::get_Mono(BOOL *pfMono)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_Mono")));

    if (pfMono == NULL)
	return E_POINTER;

    // Get the mono switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MONO, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mono control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting mono control"), dw));
	return E_FAIL;
    }
    *pfMono = mixerbool.fValue;
    DbgLog((LOG_TRACE,1,TEXT("Mono = %d"), *pfMono));
    return NOERROR;
}


HRESULT CWaveInFilter::put_Loudness(BOOL fLoudness)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_Loudness %d"), fLoudness));

    // Get the loudness switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_LOUDNESS,&ID,&cChannels,&mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting loudness control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    mixerbool.fValue = fLoudness;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting loudness control"), dw));
	return E_FAIL;
    }
    return NOERROR;
}


HRESULT CWaveInFilter::get_Loudness(BOOL *pfLoudness)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_Loudness")));

    if (pfLoudness == NULL)
	return E_POINTER;

    // Get the loudness switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_LOUDNESS,&ID,&cChannels,&mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting loudness control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting loudness"), dw));
	return E_FAIL;
    }
    *pfLoudness = mixerbool.fValue;
    DbgLog((LOG_TRACE,1,TEXT("Loudness = %d"), *pfLoudness));
    return NOERROR;
}


HRESULT CWaveInFilter::put_MixLevel(double Level)
{
    HMIXEROBJ ID;
    DWORD dw, volume;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROL mc;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;
    double Pan;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_MixLevel to %d"),(int)(Level * 10.)));

    // !!! make this work - double/int problem
    if (Level == AMF_AUTOMATICGAIN)
	return E_NOTIMPL;

    if (Level < 0. || Level > 1.)
	return E_INVALIDARG;

    // Get the volume control
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    volume = (DWORD)(Level * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting volume to %d"), volume));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    // if it's not stereo, I don't understand how to pan, so the mix level
    // is simply the value of the volume control
    if (cChannels != 2) {
        DbgLog((LOG_TRACE,1,TEXT("Not stereo - treat as mono")));
        mixerdetails.cChannels = 1;    // sets all channels to same value
        mixerdetails.cbDetails = sizeof(mu.muL);
        mixerdetails.paDetails = &mu.muL;
        mu.muL.dwValue = volume;
        dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    // Stereo.  If we're panned, the channel favoured gets the value we're
    // setting, and the other channel is attenuated
    } else {
	hr = get_Pan(&Pan);
	// I don't know how to pan, so looks like we pretend we're mono
	if (hr != NOERROR || Pan == 0.) {
            DbgLog((LOG_TRACE,1,TEXT("Centre pan - treat as mono")));
            mixerdetails.cChannels = 1;    // sets all channels to same value
            mixerdetails.cbDetails = sizeof(mu.muL);
            mixerdetails.paDetails = &mu.muL;
            mu.muL.dwValue = volume;
            dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	} else {
	    if (Pan < 0.) {
                DbgLog((LOG_TRACE,1,TEXT("panned left")));
                mixerdetails.cChannels = 2;
                mixerdetails.cbDetails = sizeof(mu.muL);
                mixerdetails.paDetails = &mu;
                mu.muL.dwValue = volume;
                mu.muR.dwValue = (DWORD)(volume * (1. - (Pan * -1.)));
                dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	    } else {
                DbgLog((LOG_TRACE,1,TEXT("panned right")));
                mixerdetails.cChannels = 2;
                mixerdetails.cbDetails = sizeof(mu.muL);
                mixerdetails.paDetails = &mu;
                mu.muL.dwValue = (DWORD)(volume * (1. - Pan));
                mu.muR.dwValue = volume;
                dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	    }
	}
    }

    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting volume"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInFilter::get_MixLevel(double FAR* pLevel)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_MixLevel")));

    // !!! detect if we're using AGC?

    if (pLevel == NULL)
	return E_POINTER;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, pretend it's mono
    if (cChannels != 2)
	cChannels = 1;

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = cChannels;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // what I consider the current volume is the highest of the channels
    // (pan may attenuate one channel)
    dw = mu.muL.dwValue;
    if (cChannels == 2 && mu.muR.dwValue > dw)
	dw = mu.muR.dwValue;
    *pLevel = (double)dw / mc.Bounds.dwMaximum;
    DbgLog((LOG_TRACE,1,TEXT("Volume: %dL %dR is %d"), mu.muL.dwValue,
                        mu.muR.dwValue, dw));
    return NOERROR;
}


HRESULT CWaveInFilter::put_Pan(double Pan)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_Pan %d"), (int)(Pan * 10.)));

    if (Pan < -1. || Pan > 1.)
	return E_INVALIDARG;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, we can't pan
    if (cChannels != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*Can't pan: not stereo!")));
	return E_NOTIMPL;
    }

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 2;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // To pan, the favoured side gets the highest of the 2 current values and
    // the other is attenuated
    dw = max(mu.muL.dwValue, mu.muR.dwValue);
    if (Pan == 0.) {
	mu.muL.dwValue = dw;
	mu.muR.dwValue = dw;
    } else if (Pan < 0.) {
	mu.muL.dwValue = dw;
	mu.muR.dwValue = (DWORD)(dw * (1. - (Pan * -1.)));
    } else {
	mu.muL.dwValue = (DWORD)(dw * (1. - Pan));
	mu.muR.dwValue = dw;
    }
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting volume"), dw));
	return E_FAIL;
    }
    m_Pan = Pan;    // remember it
    return NOERROR;
}


HRESULT CWaveInFilter::get_Pan(double FAR* pPan)
{
    HMIXEROBJ ID;
    DWORD dw, dwHigh, dwLow;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_Pan")));

    if (pPan == NULL)
	return E_POINTER;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, we can't pan
    if (cChannels != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*Can't pan: not stereo!")));
	return E_NOTIMPL;
    }

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 2;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // The pan is the ratio of the lowest channel to highest channel
    dwHigh = max(mu.muL.dwValue, mu.muR.dwValue);
    dwLow = min(mu.muL.dwValue, mu.muR.dwValue);
    if (dwHigh == dwLow && dwLow == 0) {    // !!! dwMinimum?
	if (m_Pan != 64.)
	    *pPan = m_Pan;    // !!! try to be clever when both are zero?
	else
	    *pPan = 0.;
    } else {
    *pPan = 1. - ((double)dwLow / dwHigh);
    // negative means favouring left channel
    if (dwHigh == mu.muL.dwValue && dwLow != dwHigh)
        *pPan *= -1.;
    }
    DbgLog((LOG_TRACE,1,TEXT("Pan: %dL %dR is %d"), mu.muL.dwValue,
                    mu.muR.dwValue, (int)(*pPan * 10.)));
    return NOERROR;
}


HRESULT CWaveInFilter::put_Treble(double Treble)
{
    HMIXEROBJ ID;
    DWORD dw, treble;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_Treble to %d"), (int)(Treble * 10.)));

    if (Treble < MAX_TREBLE * -1. || Treble > MAX_TREBLE)
	return E_INVALIDARG;

    // Get the treble control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting treble control"), hr));
	return hr;
    }

    treble = (DWORD)(Treble / MAX_TREBLE * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting treble to %d"), treble));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    mixerdetails.cChannels = 1;    // sets all channels to same value
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    mu.dwValue = treble;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting treble"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInFilter::get_Treble(double FAR* pTreble)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_Treble")));

    if (pTreble == NULL)
	return E_POINTER;

    // Get the treble control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting treble control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cChannels = 1;    // treat as mono
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting treble"), dw));
	return E_FAIL;
    }
    *pTreble = (mu.dwValue / mc.Bounds.dwMaximum * MAX_TREBLE);
    DbgLog((LOG_TRACE,1,TEXT("treble is %d"), (int)*pTreble));

    return NOERROR;
}


HRESULT CWaveInFilter::get_TrebleRange(double FAR* pRange)
{
    HRESULT hr;
    MIXERCONTROL mc;
    HMIXEROBJ ID;
    int cChannels;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_TrebleRange")));

    if (pRange == NULL)
	return E_POINTER;

    // Do we even have a treble control?
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if(FAILED(hr))
        return hr;

    *pRange = MAX_TREBLE;
    DbgLog((LOG_TRACE,1,TEXT("Treble range is %d.  I'M LYING !"),
                                (int)*pRange));
    return NOERROR;
}


HRESULT CWaveInFilter::put_Bass(double Bass)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;
    DWORD bass;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_Bass to %d"), (int)(Bass * 10.)));

    if (Bass < MAX_BASS * -1. || Bass > MAX_BASS)
	return E_INVALIDARG;

    // Get the Bass control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting Bass control"), hr));
	return hr;
    }

    bass = (DWORD)(Bass / MAX_BASS * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting Bass to %d"), bass));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    mixerdetails.cChannels = 1;    // sets all channels to same value
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    mu.dwValue = bass;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting Bass"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInFilter::get_Bass(double FAR* pBass)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_Bass")));

    if (pBass == NULL)
	return E_POINTER;

    // Get the Bass control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting Bass control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cChannels = 1;    // treat as mono
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting Bass"), dw));
	return E_FAIL;
    }
    *pBass = mu.dwValue / mc.Bounds.dwMaximum * MAX_BASS;
    DbgLog((LOG_TRACE,1,TEXT("Bass is %d"), (int)*pBass));

    return NOERROR;
}


HRESULT CWaveInFilter::get_BassRange(double FAR* pRange)
{
    HRESULT hr;
    MIXERCONTROL mc;
    HMIXEROBJ ID;
    int cChannels;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_BassRange")));

    if (pRange == NULL)
	return E_POINTER;

    // Do we even have a bass control?
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if(FAILED(hr))
        return hr;

    *pRange = MAX_BASS;
    DbgLog((LOG_TRACE,1,TEXT("Bass range is %d.  I'M LYING !"),
                                (int)*pRange));
    return NOERROR;
}

STDMETHODIMP CWaveInFilter::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock cObjectLock(this);
    if(m_State != State_Stopped)
    {
        return VFW_E_WRONG_STATE;
    }
    if (m_pOutputPin)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    HRESULT hr = S_OK;

    if(pPropBag == 0)
    {
        DbgLog((LOG_TRACE,2,TEXT("wavein::Load: defaulting to 0")));
        m_WaveDeviceToUse.devnum = 0;
        m_WaveDeviceToUse.fSet = TRUE;
        hr = CreatePinsOnLoad();
        if (FAILED(hr)) {
            m_WaveDeviceToUse.fSet = FALSE;
        }
    }
    else
    {

        VARIANT var;
        var.vt = VT_I4;
        hr = pPropBag->Read(L"WaveInId", &var, 0);
        if(SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE,2,TEXT("wavein::Load: %d"),
                    var.lVal));
            m_WaveDeviceToUse.devnum = var.lVal;
            m_WaveDeviceToUse.fSet = TRUE;
            hr = CreatePinsOnLoad();
            if (FAILED(hr)) {
                m_WaveDeviceToUse.fSet = FALSE;
            }
        }
        else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

	// BPC hack for SeanMcD - talk to the mixer APIs differently
        var.vt = VT_I4;
	// don't mess with hr
        HRESULT hrT = pPropBag->Read(L"UseMixer", &var, 0);
        if(SUCCEEDED(hrT))
	    m_fUseMixer = TRUE;
	else
	    m_fUseMixer = FALSE;

    }
    return hr;
}

STDMETHODIMP CWaveInFilter::Save(
    LPPROPERTYBAG pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CWaveInFilter::InitNew()
{
   if(m_pOutputPin)
   {
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }
   else
   {
       return S_OK;
   }
}

STDMETHODIMP CWaveInFilter::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = m_clsid;
    return S_OK;
}

struct WaveInPersist
{
    DWORD dwSize;
    DWORD dwWavDevice;
};

HRESULT CWaveInFilter::WriteToStream(IStream *pStream)
{
    WaveInPersist wip;
    wip.dwSize = sizeof(wip);
    wip.dwWavDevice = m_WaveDeviceToUse.devnum;
    return pStream->Write(&wip, sizeof(wip), 0);
}



HRESULT CWaveInFilter::ReadFromStream(IStream *pStream)
{
    if (m_pOutputPin)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }
    ASSERT(!m_WaveDeviceToUse.fSet);

    WaveInPersist wip;
    HRESULT hr = pStream->Read(&wip, sizeof(wip), 0);
    if(FAILED(hr))
        return hr;

    if(wip.dwSize != sizeof(wip))
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    m_WaveDeviceToUse.devnum = wip.dwWavDevice;
    m_WaveDeviceToUse.fSet = TRUE;

    hr = CreatePinsOnLoad();
    if (FAILED(hr)) {
        m_WaveDeviceToUse.fSet = FALSE;
    }
    return hr;
}

int CWaveInFilter::SizeMax()
{
    return sizeof(WaveInPersist);
}

STDMETHODIMP CWaveInFilter::Reserve(
    /*[in]*/ DWORD dwFlags,          //  From _AMRESCTL_RESERVEFLAGS enum
    /*[in]*/ PVOID pvReserved        //  Must be NULL
)
{
    if (pvReserved != NULL || (dwFlags & ~AMRESCTL_RESERVEFLAGS_UNRESERVE)) {
        return E_INVALIDARG;
    }
    HRESULT hr = S_OK;
    CAutoLock lck(this);
    if (dwFlags & AMRESCTL_RESERVEFLAGS_UNRESERVE) {
        if (m_dwLockCount == 0) {
            DbgBreak("Invalid unlock of audio device");
            hr =  E_UNEXPECTED;
        } else {
            m_dwLockCount--;
            if (m_dwLockCount == 0 && m_State == State_Stopped) {
                ASSERT(m_hwi);
                CloseWaveDevice();
            }
        }
    } else  {
        if (m_dwLockCount != 0 || m_hwi) {
        } else {
            hr = OpenWaveDevice();
        }
        if (SUCCEEDED(hr)) {
            m_dwLockCount++;
        }
    }
    return hr;
}

//-----------------------------------------------------------------------------
//                  ISpecifyPropertyPages implementation
//-----------------------------------------------------------------------------


//
// GetPages
//
// Returns the clsid's of the property pages we support
//
STDMETHODIMP CWaveInFilter::GetPages(CAUUID *pPages) {

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_AudioInputMixerProperties;

    return NOERROR;

} // GetPages




//
// PIN CATEGORIES - let the world know that we are a CAPTURE pin
//

HRESULT CWaveInOutputPin::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
{
    return E_NOTIMPL;
}

// To get a property, the caller allocates a buffer which the called
// function fills in.  To determine necessary buffer size, call Get with
// pPropData=NULL and cbPropData=0.
HRESULT CWaveInOutputPin::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    if (guidPropSet != AMPROPSETID_Pin)
    return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
    return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL && pcbReturned == NULL)
    return E_POINTER;

    if (pcbReturned)
    *pcbReturned = sizeof(GUID);

    if (pPropData == NULL)
    return S_OK;

    if (cbPropData < sizeof(GUID))
    return E_UNEXPECTED;

    *(GUID *)pPropData = PIN_CATEGORY_CAPTURE;
    return S_OK;
}


// QuerySupported must either return E_NOTIMPL or correctly indicate
// if getting or setting the property set and property is supported.
// S_OK indicates the property set and property ID combination is
HRESULT CWaveInOutputPin::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    if (guidPropSet != AMPROPSETID_Pin)
    return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
    return E_PROP_ID_UNSUPPORTED;

    if (pTypeSupport)
    *pTypeSupport = KSPROPERTY_SUPPORT_GET;
    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\audprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// Audio Renderer properties page
//
// This file is entirely concerned with the implementation of the
// properties page.

#include "audprop.rc"
class CWaveOutFilter;

class CAudioRendererProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown * punk);
    HRESULT OnDisconnect();

    // This is where we should make changes due to user action.
    // As the user cannot change anything in the property dialog
    // we have nothing to do.  Leave the skeleton here as a placeholder.
    //HRESULT OnApplyChanges();
    HRESULT OnActivate();

    CAudioRendererProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CAudioRendererProperties();

private:
    INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    CWaveOutFilter * m_pFilter;

#if 0
    // while the property page is read only we do not need this
    // if the property page ever becomes read/write the member
    // variable will have to be initialised
    BOOL m_bInitialized;
    void SetDirty()
    {
        ASSERT(m_pPageSite);
        if (m_bInitialized)
        {
           m_bDirty = TRUE;
           m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    }
#endif

};


class CAudioRendererAdvancedProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown * punk);
    HRESULT OnDisconnect();
    HRESULT OnActivate();

    CAudioRendererAdvancedProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CAudioRendererAdvancedProperties();

private:
    INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    IAMAudioRendererStats * m_pStats;

    void UpdateSettings(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\basicaud.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// Implements audio control interface

#ifndef __AUDCTL__
#define __AUDCTL__

// OLE Automation has different ideas of TRUE and FALSE

#define OATRUE (-1)
#define OAFALSE (0)

// This class implements the IBasicAudio interface

#define QZ_MIN_VOLUME 0		// mute
#define QZ_MAX_VOLUME 0xFFFF	// full on

class CBasicAudioControl : public CBasicAudio
{
    CWaveOutFilter *m_pAudioRenderer;         // The renderer that owns us

public:

    CBasicAudioControl(TCHAR *pName,               // Object description
                  LPUNKNOWN pUnk,             // Normal COM ownership
                  HRESULT *phr,               // OLE failure return code
                  CWaveOutFilter *pAudioRenderer); // our owner

    // These are the properties we support

    STDMETHODIMP get_Volume(long *plVolume);
    STDMETHODIMP put_Volume(long lVolume);

    STDMETHODIMP get_Balance(long *plBalance);
    STDMETHODIMP put_Balance(long lBalance);

    // And these are the methods for our friend classes - no parameter validation
    friend class CWaveOutFilter;

private:
    // Get current settings from the hardware and set member variables
    HRESULT GetVolume();

    // Put current settings to the hardware using member variables
    HRESULT PutVolume();

    // Set up right/left amp factors
    void SetBalance();

    // volume is in the range -10000 to 0 (100th DB units)
    LONG        m_lVolume;
};

#endif // __AUDCTL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\dsr.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _AUDIO_DSR_H_
#define _AUDIO_DSR_H_

extern AMOVIESETUP_FILTER dsFilter;

#define DXMPERF

#ifdef DEBUG
    void  DbgLogWaveFormat(DWORD Level, WAVEFORMATEX *pwfx);
#endif

//-----------------------------------------------------------------------------
// Implements the CDSoundDevice class based on DSound.
//-----------------------------------------------------------------------------

typedef void (CALLBACK *PWAVEOUTCALLBACK) (HWAVEOUT hwo, UINT uMsg,
		DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2) ;

typedef HRESULT  (WINAPI *PDSOUNDCREATE) (GUID FAR * lpGUID, LPDIRECTSOUND * ppDS,
		    IUnknown FAR *pUnkOuter );


//-----------------------------------------------------------------------------
// a class to deal with circular buffer.
//
// This assumes the following:
//
// a) Nothing is more than one iteration away.
// b) size of the buffer would be same for all tuples.
//-----------------------------------------------------------------------------
class Tuple
{

    public:

    Tuple () {
        m_itr = 0 ;
        m_offset = 0 ;
        m_size = 0 ; }

    // t1 = t2 ;
    Tuple& operator = (const Tuple &t)
    {
        ASSERT (t.m_size) ;

        m_itr = t.m_itr ;
        m_offset = t.m_offset ;
        m_size = t.m_size ;
        return *this ;
    }

    // t1 == t2 ;
    BOOL operator == (const Tuple& t) const
    {
        ASSERT (m_size) ;
        ASSERT (m_size == t.m_size) ;
        return ((m_itr == t.m_itr) && (m_offset == t.m_offset)) ;
    }

    // t1 += length ;
    // Assuming that length would never be more than size of buffer.
    Tuple& operator += (DWORD offset)
    {
        ASSERT (m_size) ;
        m_offset += offset ;
        if (m_offset >= m_size)
        {
            m_offset -= m_size ;
            ASSERT (m_offset < m_size) ;
            m_itr++ ;
        } ;
        return *this ;
    }

    // length = t1 - t2 ;
    // Assuming that t1 is known to be logically greater than t2
    DWORD operator - (const Tuple& t) const
    {
        ASSERT (m_size) ;
        ASSERT (m_size == t.m_size) ;

#if 0
        if (m_itr == t.m_itr)
        {
            ASSERT (m_offset >= t.m_offset) ;
            return (m_offset - t.m_offset) ;
        }
        else
        {
            ASSERT (m_itr == (t.m_itr + 1)) ;
            return (m_offset + m_size - t.m_offset) ;
        } ;
#else
        return m_size * (m_itr - t.m_itr) + (LONG)(m_offset - t.m_offset);
#endif
    }

    // t1 > t2
    BOOL operator > (const Tuple& t) const
    {
        ASSERT (m_size) ;
        ASSERT (m_size == t.m_size) ;

        return ((m_itr > t.m_itr)
                || ((m_itr == t.m_itr) && (m_offset > t.m_offset))) ;
    }

    // t1 < t2
    BOOL operator < (const Tuple& t) const
    {
        ASSERT (m_size) ;
        ASSERT (m_size == t.m_size) ;

        return ((m_itr < t.m_itr)
                || ((m_itr == t.m_itr) && (m_offset < t.m_offset))) ;
    }

    // t1 >= t2
    BOOL operator >= (const Tuple& t) const
    {
        return ( (*this > t) || (*this == t)) ;
    }

    // t1 <= t2
    BOOL operator <= (const Tuple& t) const
    {
        return ( (*this < t) || (*this == t)) ;
    }

    // Makes a tuple current based on a offset
    void MakeCurrent (DWORD offset)
    {
        ASSERT (m_size) ;
        if (offset < m_offset)
            m_itr++ ;
        m_offset = offset ;
    }

    // Makes a tuple current based on another tuples offset. Overloaded.
    void MakeCurrent (Tuple& t, DWORD offset)
    {
        ASSERT (m_size) ;

        if (offset < t.m_offset)
            m_itr = (t.m_itr + 1) ;
        else
            m_itr = t.m_itr ;
        m_offset = offset ;
    }

    // Linear length of a tuple
    DWORDLONG LinearLength ()
    {
        ASSERT (m_size) ;
        return UInt32x32To64 (m_itr,m_size) + m_offset ;
    }

    // Initializes a tuple
    void Init (DWORD itr, DWORD offset, DWORD size)
    {
        m_itr = itr ;
        m_offset = offset ;
        m_size = size ;
    }

    // data. Defined to be public for direct access.

    DWORD m_itr ;               // 0 based iteration number
    DWORD m_offset ;            // 0 based offset in above iteration.
    DWORD m_size ;              // size of the buffer.

} ;


class CDSoundDevice : public CSoundDevice
{

    friend class CWaveOutFilter;
    friend class CWaveOutFilter::CDS3D;
    friend class CWaveOutFilter::CDS3DB;

public:
    // define the public functions that this class exposes. These are all
    // modeled on the waveOut APIs. Only the APIs that are used by the
    // Quartz wave renderer are declared and defined. We may have to
    // progressively add to this list.

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // called at quartz.dll load/unload time
    static void InitClass(BOOL, const CLSID *);

    MMRESULT amsndOutClose () ;
    MMRESULT amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc) ;
    MMRESULT amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText) ;
    MMRESULT amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos) ;
    MMRESULT amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
			   double dRate, DWORD *pnAvgBytesPerSec,
			   DWORD_PTR dwCallBack, DWORD_PTR dwCallBackInstance, DWORD fdwOpen) ;
    MMRESULT amsndOutPause () ;
    MMRESULT amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutReset () ;
    MMRESULT amsndOutBreak () ; 
    MMRESULT amsndOutRestart () ;
    MMRESULT amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, const REFERENCE_TIME *pStart, BOOL bIsDiscontinuity) ;

    // Routines required for initialisation and volume/balance handling
    // These are not part of the Win32 waveOutXxxx api set
    HRESULT  amsndOutCheckFormat (const CMediaType *pmt, double dRate);
    LPCWSTR  amsndOutGetResourceName () ;
    HRESULT  amsndOutGetBalance (LPLONG plBalance) ;
    HRESULT  amsndOutGetVolume (LPLONG plVolume) ;
    HRESULT  amsndOutSetBalance (LONG lVolume) ;
    HRESULT  amsndOutSetVolume (LONG lVolume) ;

#if 0
    HRESULT  amsndGetDirectSoundInterface(LPDIRECTSOUND *lplpds);
    HRESULT  amsndGetPrimaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb);
    HRESULT  amsndGetSecondaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb);
#endif
    HRESULT  amsndSetFocusWindow (HWND hwnd, BOOL bMixingOnOrOff) ;
    HRESULT  amsndGetFocusWindow (HWND * phwnd, BOOL * pbMixingOnOrOff) ;

    HRESULT  amsndOutLoad(IPropertyBag *pPropBag) ;

    HRESULT  amsndOutWriteToStream(IStream *pStream);
    HRESULT  amsndOutReadFromStream(IStream *pStream);
    int      amsndOutSizeMax();

    CDSoundDevice () ;
    ~CDSoundDevice () ;

    HRESULT  SetRate(DOUBLE dRate, DWORD nSamplesPerSec, LPDIRECTSOUNDBUFFER pBuffer = NULL);
    void     CleanUp (BOOL bBuffersOnly = FALSE) ;
    HRESULT  RecreateDSoundBuffers(double dRate = -1.0);

    // ?? don't see how to get around making this public, since CWaveOutFilter
    // can't access it otherwise, even though the classes are friends
    LONGLONG m_llSilencePlayed;             // total amount of silence played
    LONGLONG            m_llAdjBytesPrevPlayed;

    // make public to expose to waveout filter for unmarked gap detection
    REFERENCE_TIME m_rtLastSampleEnd;

private:
    PWAVEOUTCALLBACK    m_pWaveOutProc ;        // call back for waveOut
    DWORD_PTR           m_dwCallBackInstance ;  // call back instance.
    CWaveOutFilter *    m_pWaveOutFilter;
    HWND                m_hFocusWindow ;        // the focus windows
    bool                m_fAppSetFocusWindow ;  // app has set the focus window
    bool                m_fMixing;              // global focus is on
    bool                m_bBufferLost;
    bool                m_bIsTSAudio;           // Are we a terminal server client and remoting audio? 
                                                // If so, use a larger buffer size to avoid skipping/looping.
    //BOOL              m_fEmulationMode;       // we're using DSOUND in emulation mode
    DWORD               m_dwEmulationLatencyPad;// used for emulation mode clock latency compensation
    DWORD               m_dwMinOptSampleSize;

    //=====================  Thread support  =========================

    DWORD_PTR    m_callbackAdvise;          // token associated with callback object
    typedef enum
    {
        WAVE_CLOSED,
        WAVE_PLAYING,
        WAVE_PAUSED,
    }   WaveState ;
    WaveState   m_WaveState;                // State of the wave device
    bool        m_bDSBPlayStarted ;         // play start on buffer or not
    HRESULT     m_hrLastDSoundError ;

    HRESULT StartCallingCallback();
    bool IsCallingCallback();
    void StopCallingCallback();

    void    ZeroLockedSegment (LPBYTE lpWrite, DWORD dwLength );
    DWORD   FillSoundBuffer( LPBYTE lpWrite, DWORD dwLength, DWORD dwPlayPos );
    HRESULT StreamData( BOOL bFromWrite, BOOL bUseLatencyPad = FALSE );
    void    StreamHandler( void );
    void    FlushSamples () ;
    LONGLONG GetPlayPosition (BOOL bUseAdjustedPos = FALSE) ;
    HRESULT CreateDSound(BOOL bQueryOnly = FALSE);
    HRESULT CreateDSoundBuffers(double dRate = -1.0);
    HRESULT GetDSBPosition () ;
    void    AddAudioBreak (Tuple& t1, Tuple& t2) ;
    void    RefreshAudioBreaks (Tuple& t) ;
    BOOL    RestoreBufferIfLost(BOOL bRestore);
    HRESULT SetPrimaryFormat( LPWAVEFORMATEX pwfx, BOOL bRetryOnFailure = FALSE);

    HRESULT SetFocusWindow(HWND hwnd);
    HRESULT SetMixing(BOOL bMixingOnOrOff);
    DWORD   GetCreateFlagsSecondary( WAVEFORMATEX * pwfx );
    HRESULT SetBufferVolume( LPDIRECTSOUNDBUFFER lpDSB, WAVEFORMATEX * pwfx );
    HRESULT SetSRCQuality( DWORD dwQuality );
    HRESULT GetSRCQuality( DWORD *pdwQuality );


    static  void __stdcall StreamingThreadCallback( DWORD_PTR lpvThreadParm );
    CCritSec  m_cDSBPosition ;              // locks access to StreamData


    HRESULT NotifyFullDuplexController();   // pass the FullDuplexController configuration info

    //====================  DirectSound access ======================

#define THREAD_WAKEUP_INT_MS 100            // wakeup every 100ms.
#define OUR_HANDLE (HWAVEOUT) 0x9999        // dummy handle value that we use.

    HINSTANCE           m_hDSoundInstance;  // instance handle to dsound.dll
protected:
    LPDIRECTSOUND       m_lpDS;             // DirectSound object
    LPDIRECTSOUNDBUFFER m_lpDSBPrimary;     // DirectSoundBuffer primary buffer
    LPDIRECTSOUNDBUFFER m_lpDSB;            // DirectSoundBuffer looping buffer

    IDirectSound3DListener *m_lp3d;	    // used for 3D calls
    IDirectSound3DBuffer   *m_lp3dB;	    // used for 3D calls

private:
#if 0
    DWORD   m_dwFillThreshold;              // how empty our buffer must be before we attempt to write
#endif
    DWORD   m_dwBufferSize;                 // length of m_lpDSB in bytes
    DWORD   m_dwBitsPerSample;              // sample size
    DWORD   m_nAvgBytesPerSec;

    //  helper
    DWORD   AdjustedBytesPerSec() const
    {
        return m_dRate == 1.0 ? m_nAvgBytesPerSec : (DWORD)(m_nAvgBytesPerSec * m_dRate);
    }
    DWORD   m_dwRipeListPosition;           // bytes position for nodes in ripe list

    GUID    m_guidDSoundDev;                // guid of selected dsound device

    double  m_dRate;                        // the requested playback rate

    class CRipe
    //  These don't need to be objects in retail because their lifetime
    //  is controlled by the filter
#ifdef DEBUG
    : CBaseObject
#endif
    {
        friend class CDSoundDevice ;
        CRipe(TCHAR *pName)
#ifdef DEBUG
        : CBaseObject(pName)
#endif
        {};

        DWORD           dwLength;           // Bytes left in lpBuffer
        DWORD           dwPosition;         // The end byte position for this stream
        LPBYTE          lpBuffer;           // Data bytes
        DWORD_PTR       dwSample;               // passed in CMediaSample*
        BOOL            bCopied;            // copied to DSB or not.
        DWORD           dwBytesToStuff;     // Total bytes when started
#ifdef DXMPERF
        BOOL                    bFresh;                         // true = no data has been copied out
        REFERENCE_TIME  rtStart;                        // reference time from the original IMediaSample
#endif // DXMPERF
    };



#ifdef DEBUG
    DWORD   m_NumSamples ;                  // number of samples
    DWORD   m_NumCallBacks ;                // number of callbacks
    DWORD   m_NumCopied ;                   // number of samples copied
    DWORD   m_cbStreamDataPass ;            // Number of times thru StreamData
#endif

    class CAudBreak
    //  These don't need to be objects in retail because their lifetime
    //  is controlled by the filter
#ifdef DEBUG
    : CBaseObject
#endif
    {
        friend class CDSoundDevice ;
        CAudBreak (TCHAR *pName)
#ifdef DEBUG
        : CBaseObject(pName)
#endif
        {};

        Tuple           t1 ;                // break starts here
        Tuple           t2 ;                // break ends here
    };


    Tuple   m_tupPlay ;                     // play cursor
    Tuple   m_tupWrite ;                    // write cursor
    Tuple   m_tupNextWrite ;                // next write position.

    long     m_lStatFullness;
    long     m_lStatBreaks;                 // Audio breaks
    long     m_lPercentFullness;            // keep track of sound buffer fullness


#ifdef DEBUG
    DWORD   m_lastThWakeupTime ;            // last time thread woke up.
    DWORD   m_NumBreaksPlayed ;             // number of breaks played
    DWORD   m_dwTotalWritten ;              // total number of bytes written
#endif
    DWORD   m_NumAudBreaks ;                // number of Audio Breaks


#ifdef PERF
    //====================  Perf loggig  ============================
    int     m_idDSBWrite ;                  // MSR_id for writing to DSB memory
    int     m_idThreadWakeup ;              // MSR_id for thread wake up times.
    int     m_idGetCurrentPosition ;        // MSR_id for GetCurrentPosition times
    int     m_idWaveOutGetNumDevs ;         // MSR_id for waveOutGetNumDevs
#endif

    //====================  Ripe buffer list  ======================
    CCritSec  m_cRipeListLock ;             // serializes access to Ripe List

    // Typed advise holder list derived from the generic list template

    typedef CGenericList<CRipe> CRipeList;
    CRipeList m_ListRipe;                   // List of ripe buffers

    //====================  Audio Break list  ======================
    //  Serialized with m_cDSBPosition

    // Typed advise holder list derived from the generic list template

    typedef CGenericList<CAudBreak> CAudBreakList;
    CAudBreakList m_ListAudBreak;           // List of audio breaks

    //====================  Volume/Balance  ======================

    LONG m_lBalance;        // last set balance -10,000 to 10,000
    LONG m_lVolume; // last set volume -10,000 to 0

    //==================== Error Recovery ========================

#ifdef ENABLE_10X_FIX
    void Reset10x();

    UCHAR   m_ucConsecutiveStalls;  // The number of consecutive times we receive a zero-lock size from DSOUND
    BOOL    m_fRestartOnPause;              // TRUE => shutdown all DSOUND buffers on next pause (force restart on pause)
#endif // 10x


    //==================== Handle gaps ============================
    DWORD          m_dwSilenceWrittenSinceLastWrite;

#ifdef PERF
    int     m_idAudioBreak;
#endif
};

typedef CDSoundDevice *PDSOUNDDEV;

inline bool CDSoundDevice::IsCallingCallback()
{
    // m_callbackAdvise only equals 0 if the callback function
    // has not been started.
    return (0 != m_callbackAdvise);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\basicaud.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Implements audio control interface

#include <streams.h>
#define _AMOVIE_DB_
#include <decibels.h>
#include <mmsystem.h>
#include "waveout.h"

// This class implements the IBasicAudio control functions (dual interface).
// We support some methods that duplicate the properties but provide a
// more direct mechanism.

CBasicAudioControl::CBasicAudioControl(TCHAR *pName,           // Object description
                             LPUNKNOWN pUnk,         // Normal COM ownership
                             HRESULT *phr,           // OLE failure code
                             CWaveOutFilter *pAudioRenderer) : // Main renderer object
      CBasicAudio(pName,pUnk)
    , m_pAudioRenderer(pAudioRenderer)


{
    ASSERT(pUnk);
    ASSERT(m_pAudioRenderer);
}

//
// This returns the current Audio volume. We remember that we have been called
// and therefore we should set the volume in future.
//
// The structure has a public dual interface method which will lock and
// validate the parameter.  This calls a private method shared with the
// waveout filter to talk to the device.

STDMETHODIMP CBasicAudioControl::get_Volume(long *plVolume)
{
    CheckPointer(plVolume,E_POINTER);
    ValidateReadWritePtr(plVolume,sizeof(long *));

    CAutoLock cInterfaceLock(m_pAudioRenderer);

    HRESULT hr = GetVolume () ;     // gets and sets internal variable
    *plVolume = m_lVolume ;
    if ((S_OK == hr) && (m_pAudioRenderer->m_hwo))
	m_pAudioRenderer->m_fVolumeSet = TRUE; // in future set the volume
    return hr ;
}

HRESULT CBasicAudioControl::GetVolume()
{
    return m_pAudioRenderer->m_pSoundDevice->amsndOutGetVolume(&m_lVolume);
}

//
// Set the volume.  This is a public method so we should validate
// the input parameter.  If the device is not connected, remember the
// volume setting and we will set it later
//

STDMETHODIMP
CBasicAudioControl::put_Volume(long lVolume)
{
    CAutoLock cInterfaceLock(m_pAudioRenderer);
    HRESULT hr;

    if ((AX_MAX_VOLUME < lVolume) || (AX_MIN_VOLUME > lVolume)) {
	hr = E_INVALIDARG;
    }
    else {
	m_lVolume = lVolume ;
	hr = PutVolume () ;
	if (S_OK == hr) {
	    m_pAudioRenderer->m_fVolumeSet = TRUE;
	}
    }
    return hr;
}

HRESULT CBasicAudioControl::PutVolume()
{
    return m_pAudioRenderer->m_pSoundDevice->amsndOutSetVolume(m_lVolume);
}

STDMETHODIMP CBasicAudioControl::get_Balance(long *plBalance)
{
    CheckPointer(plBalance,E_POINTER);
    ValidateReadWritePtr(plBalance,sizeof(long *));

    CAutoLock cInterfaceLock(m_pAudioRenderer);
    HRESULT hr;

    if (!(m_pAudioRenderer->m_fHasVolume & (WAVECAPS_LRVOLUME))) {
        // mono cards: cannot support balance
        hr = VFW_E_MONO_AUDIO_HW;
    } else {
	hr = m_pAudioRenderer->m_pSoundDevice->amsndOutGetBalance(plBalance);
	if ((S_OK == hr) && (m_pAudioRenderer->m_hwo))
	    m_pAudioRenderer->m_fVolumeSet = TRUE; // in future set the volume
    }
    return hr;
}


//
// Set the Balance.  This is a public method so we should validate
// the input parameter.  If the device is not connected, remember the
// Balance setting and we will set it later
//

STDMETHODIMP
CBasicAudioControl::put_Balance(long lBalance)
{
    CAutoLock cInterfaceLock(m_pAudioRenderer);
    HRESULT hr;

    if (!(m_pAudioRenderer->m_fHasVolume & (WAVECAPS_LRVOLUME))) {
        // mono cards: cannot support balance
        hr = VFW_E_MONO_AUDIO_HW;
    }
    else if ((AX_BALANCE_RIGHT < lBalance) || (AX_BALANCE_LEFT > lBalance)) {
	    return E_INVALIDARG;
    }
    else {
	hr = m_pAudioRenderer->m_pSoundDevice->amsndOutSetBalance(lBalance);
	if (S_OK == hr) {
	    m_pAudioRenderer->m_fVolumeSet = TRUE; // in future set the volume
	}
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\midiout.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// Implements the CMidiOutDevice class based on midiOut APIs.
//----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Includes.
//-----------------------------------------------------------------------------
#include <streams.h>
#define _AMOVIE_DB_
#include <decibels.h>
#include "waveout.h"
#include "midiout.h"
#include "midif.h"

#define IntToPtr_(T, i) ((T)IntToPtr(i))

//
// Define the dynamic setup structure for filter registration.  This is
// passed when instantiating an audio renderer in its midiOut guise.
//

const AMOVIESETUP_MEDIATYPE
midiOpPinTypes = { &MEDIATYPE_Midi, &MEDIASUBTYPE_NULL };

const AMOVIESETUP_PIN
midiOutOpPin = { L"Input"
               , TRUE    	   // bRendered
               , FALSE		   // bOutput
               , FALSE		   // bZero
               , FALSE		   // bMany
               , &CLSID_NULL	   // clsConnectToFilter
               , NULL	           // strConnectsToPin
               , 1	           // nMediaTypes
               , &midiOpPinTypes }; // lpMediaTypes

const AMOVIESETUP_FILTER midiFilter = { &CLSID_AVIMIDIRender	// filter class id
                                     , L"Midi Renderer"		// filter name
                                     , MERIT_DO_NOT_USE  		// dwMerit
                                     , 1
                                     , &midiOutOpPin };


//-----------------------------------------------------------------------------
// CreateInstance for the MidiOutDevice. This will create a new MidiOutDevice
// and a new CWaveOutFilter, passing it the sound device.
//-----------------------------------------------------------------------------
CUnknown *CMidiOutDevice::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    // make sure that there is at least one midiOut device in the system. Fail
    // the create instance if not.
    if (0 == midiOutGetNumDevs ())
    {
        *phr = VFW_E_NO_AUDIO_HARDWARE ;
        return NULL ;
    }

    return CreateRendererInstance<CMidiOutDevice>(pUnk, &midiFilter, phr);
}

//-----------------------------------------------------------------------------
// CMidiOutDevice constructor.
//-----------------------------------------------------------------------------
CMidiOutDevice::CMidiOutDevice ()
    : m_lVolume ( 0 )
    , m_lBalance ( 0 )
    , m_wLeft ( 0xFFFF )
    , m_wRight ( 0xFFFF )
    , m_dwWaveVolume ( 0 )
    , m_fHasVolume ( 0 )
    , m_hmidi ( 0 )
    , m_fDiscontinuity( TRUE )
	, m_fBalanceSet (FALSE)
	, m_ListVolumeControl(NAME("CMidiOutFilter volume control list"))
	, m_iMidiOutId( MIDI_MAPPER )

{
    
}

//-----------------------------------------------------------------------------
// CMidiOutDevice destructor.
//
//-----------------------------------------------------------------------------
CMidiOutDevice::~CMidiOutDevice ()
{
   	CVolumeControl *pVolume;
	while(pVolume = m_ListVolumeControl.RemoveHead())
		delete pVolume;

	ASSERT(m_ListVolumeControl.GetCount() == 0);

}

//-----------------------------------------------------------------------------
// midiOutClose.
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutClose ()
{
    // some validation.

    if (m_hmidi == 0)
    {
        DbgBreak("Called to close when not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutClose - device is not open")));
        return MMSYSERR_ERROR ;
    }

    MMRESULT mmr = ::midiStreamClose (m_hmidi) ;
    m_hmidi = 0;
    return mmr;
}

//-----------------------------------------------------------------------------
// midiOutDoesRSMgmt.
//-----------------------------------------------------------------------------
LPCWSTR CMidiOutDevice::amsndOutGetResourceName ()
{
    return m_wszResourceName;
}

//-----------------------------------------------------------------------------
// waveGetDevCaps
//
//-----------------------------------------------------------------------------

MMRESULT CMidiOutDevice::amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc)
{
	if(!pwoc)
		return MMSYSERR_INVALPARAM;
	pwoc->dwSupport = 0;

   	MMRESULT mmr;
	
	if(m_ListVolumeControl.GetCount())
	{
		pwoc->dwSupport = m_fHasVolume & (WAVECAPS_VOLUME | WAVECAPS_LRVOLUME);
		return MMSYSERR_NOERROR;
	}

	// do our mixer line detection
	if((mmr = DoDetectVolumeControl()) == MMSYSERR_NOERROR) // we won't succeed unless there is a valid balance control
	{
		if(!m_ListVolumeControl.GetCount())
			return mmr;

		pwoc->dwSupport |= WAVECAPS_VOLUME;
		
		POSITION pos = m_ListVolumeControl.GetHeadPosition();
		while(pos)
		{
			CVolumeControl *pVolume = m_ListVolumeControl.GetNext(pos);
			if(pVolume->dwChannels == 2)
			{
				pwoc->dwSupport |= WAVECAPS_LRVOLUME;
				break;
			}
		}

		//save volume capabilities
		m_fHasVolume = pwoc->dwSupport & (WAVECAPS_VOLUME | WAVECAPS_LRVOLUME);
	}

	return mmr;
}

//-----------------------------------------------------------------------------
// midiOutGetErrorText
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText)
{
    return ::midiOutGetErrorText (mmrE, pszText, cchText) ;
}

//-----------------------------------------------------------------------------
// midiOutGetPosition
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos)
{
    pmmt->wType = TIME_MS;

    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutGetPosition - device is not open")));
        return MMSYSERR_NODRIVER ;
    }

    const MMRESULT mmr = ::midiStreamPosition (m_hmidi, pmmt, cbmmt) ;
    if (MMSYSERR_NOERROR != mmr) {
        DbgLog((LOG_ERROR,0,TEXT("midiOutGetPosition - FAILED")));
        DbgBreak("Failed to get the device position.");
    }
    return mmr;
}

//-----------------------------------------------------------------------------
// midiOutGetBalance
//
//-----------------------------------------------------------------------------
HRESULT CMidiOutDevice::amsndOutGetBalance (LPLONG plBalance)
{
    // some validation.
#if 0 // use the mixer
    if (m_hmidi == 0)
    {
        DbgLog((LOG_ERROR,2,TEXT("midiOutGetBalance - device is not open")));
	*plBalance = 0;
        return MMSYSERR_NODRIVER ;
    }
#endif
    HRESULT hr = GetVolume();
	if(FAILED(hr))
	{
        DbgLog((LOG_ERROR, 2, TEXT("amsndOutgetVolume: GetVolume failed %u"), hr & 0x0ffff));
	}
    *plBalance = m_lBalance;
    return hr ;
}

//-----------------------------------------------------------------------------
// midiOutGetVolume
//
//-----------------------------------------------------------------------------
HRESULT CMidiOutDevice::amsndOutGetVolume (LPLONG plVolume)
{
    // some validation.
#if 0 // use the mixer
    if (m_hmidi == 0)
    {
        DbgLog((LOG_ERROR,2,TEXT("midiOutGetVolume - device is not open")));
	*plVolume = 0;
        return MMSYSERR_NODRIVER ;
    }
#endif
    HRESULT hr = GetVolume();
	if(FAILED(hr))
	{
        DbgLog((LOG_ERROR, 2, TEXT("amsndOutgetVolume: GetVolume failed %u"), hr & 0x0ffff));
	}
    *plVolume = m_lVolume;
    return hr ;
}


HRESULT CMidiOutDevice::amsndOutCheckFormat(const CMediaType *pmt, double dRate)
{
    if (pmt->majortype != MEDIATYPE_Midi) {
	return E_INVALIDARG;
    }

    if (pmt->FormatLength() < sizeof(PCMWAVEFORMAT)) {
        return E_INVALIDARG;
    }

    // somewhere between 20 and 98 we overflow and play really slowly
    if (dRate < 0.01 || dRate > 20) {
        return VFW_E_UNSUPPORTED_AUDIO;
    }


    return S_OK;
}



MMRESULT CMidiOutDevice::DoOpen()
{

    DbgLog((LOG_TRACE,1,TEXT("calling midiStreamOpen")));
    UINT err = midiStreamOpen(&m_hmidi,
                           &m_iMidiOutId,
                           1,
                           m_dwCallBack,
                           m_dwCallBackInstance,
                           CALLBACK_FUNCTION);

    if (err != MMSYSERR_NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("Error %u in midiStreamOpen"), err));
	m_hmidi = NULL;
        return E_FAIL;
    }

    // The format of a MIDI stream is just the time division (the tempo).
    // Set the proper tempo.
    MIDIPROPTIMEDIV mptd;
    mptd.cbStruct  = sizeof(mptd);
    mptd.dwTimeDiv = m_dwDivision;
    DbgLog((LOG_TRACE,1,TEXT("Setting time division to %ld"),mptd.dwTimeDiv));
    if (midiStreamProperty(m_hmidi, (LPBYTE)&mptd,
			MIDIPROP_SET|MIDIPROP_TIMEDIV) != MMSYSERR_NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("Error setting time division, closing device")));
	midiStreamClose(m_hmidi);
	m_hmidi = NULL;
	return E_FAIL;
    }

	GetVolume();
	GetBalance();

    return err;
}
//-----------------------------------------------------------------------------
// midiOutOpen
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
				       double dRate, DWORD *pnAvgBytesPerSec, DWORD_PTR dwCallBack,
				       DWORD_PTR dwCallBackInstance, DWORD fdwOpen)
{
    // some validation.  If the device is already open we have an error,
    // with the exception that QUERY calls are permitted.

    if (fdwOpen & WAVE_FORMAT_QUERY) {
	return MMSYSERR_NOERROR;
    }

    else if (m_hmidi != 0)
    {
        DbgBreak("Invalid - device ALREADY open - logic error");
        DbgLog((LOG_ERROR,1,TEXT("midiOutOpen - device is already open")));
        return MMSYSERR_ERROR ;
    }

    // report adjusted nAvgBytesPerSec
    if(pnAvgBytesPerSec) {
        *pnAvgBytesPerSec = pwfx->nAvgBytesPerSec;
    }

    MIDIFORMAT *pmf = (MIDIFORMAT *) pwfx;
    m_dwDivision = (DWORD) (pmf->dwDivision * dRate);
    m_dwCallBack = dwCallBack;
    m_dwCallBackInstance = dwCallBackInstance;

    DWORD err =  DoOpen();

    if (MMSYSERR_NOERROR == err && phwo && !(fdwOpen & WAVE_FORMAT_QUERY)) {
        *phwo = (HWAVEOUT) m_hmidi;
    }

    return err;
}
//-----------------------------------------------------------------------------
// midiOutPause
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutPause ()
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutPause - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::midiStreamPause (m_hmidi) ;
}

//-----------------------------------------------------------------------------
// midiOutPrepareHeader
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutPrepareHeader - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::midiOutPrepareHeader ((HMIDIOUT) m_hmidi, (LPMIDIHDR) pwh, cbwh) ;
}

//-----------------------------------------------------------------------------
// midiOutReset
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutReset ()
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutReset - device is not open")));
        return MMSYSERR_NODRIVER ;
    }

    m_fDiscontinuity = TRUE;

    //return ::midiOutReset ((HMIDIOUT) m_hmidi) ;
    MMRESULT err = ::midiOutReset((HMIDIOUT) m_hmidi);

    // !!! work around midiStreamOut bug in Win95 and NT3, need to re-open
    // device, otherwise playing n seconds of a MIDI file, and seeking will
    // result in n seconds of silence before playback resumes.
    // This kills performance, so only do this if necessary
    BOOL fNeedHack = (g_amPlatform == VER_PLATFORM_WIN32_WINDOWS &&
	(g_osInfo.dwMajorVersion < 4 || (g_osInfo.dwMajorVersion == 4 &&
	 g_osInfo.dwMinorVersion < 10))) ||
    	(g_amPlatform == VER_PLATFORM_WIN32_NT && g_osInfo.dwMajorVersion < 4);

    if (fNeedHack) {
        //DbgLog((LOG_ERROR,0,TEXT("*** NEED RESTART HACK")));
        amsndOutClose();
        DoOpen();
    }

    return err;
}

//-----------------------------------------------------------------------------
// midiOutRestart
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutRestart ()
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutRestart - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    DbgLog((LOG_TRACE, 3, "calling midistreamrestart"));
    return ::midiStreamRestart (m_hmidi) ;
}
//-----------------------------------------------------------------------------
// midiOutSetBalance
//
//-----------------------------------------------------------------------------
HRESULT CMidiOutDevice::amsndOutSetBalance (LONG lBalance)
{
	HRESULT hr = S_OK;

	m_lBalance = lBalance;
	m_fBalanceSet = TRUE;

	// go and calculate the channel attenuation
	SetBalance();
	hr = PutVolume();
	if(FAILED(hr))
	{
        DbgLog((LOG_ERROR, 2, TEXT("amsndOutSetBalance: PutVolume failed %u"), hr & 0x0ffff));
	}
	return hr;
}
//-----------------------------------------------------------------------------
// midiOutSetVolume
//
//-----------------------------------------------------------------------------
HRESULT CMidiOutDevice::amsndOutSetVolume (LONG lVolume)
{
	HRESULT hr = S_OK;

	// map volume onto decibel range
	DWORD dwAmp = DBToAmpFactor( lVolume );
	m_lVolume = lVolume;

    // now that the absolute volume has been set we should adjust
    // the balance to maintain the same DB separation
    SetBalance ();
	hr = PutVolume();
	if(FAILED(hr))
	{
        DbgLog((LOG_ERROR, 2, TEXT("amsndOutSetVolume: PutVolume failed %u"), hr & 0x0ffff));
	}
	return hr;

}
//-----------------------------------------------------------------------------
// midiOutUnprepareHeader
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutUnprepareHeader - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::midiOutUnprepareHeader((HMIDIOUT) m_hmidi, (LPMIDIHDR) pwh, cbwh) ;
}

//-----------------------------------------------------------------------------
// midiOutWrite
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, const REFERENCE_TIME *pStart, BOOL bIsDiscontinuity)
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutWrite - device is not open")));
        return MMSYSERR_NODRIVER ;
    }


    // !!! need to hack midi data into shape.

    MIDIHDR *pmh = (MIDIHDR *) pwh->lpData;

    DWORD dwCopy = pmh->dwBufferLength;

    pmh = (MIDIHDR *) (pwh->lpData + sizeof(MIDIHDR) + dwCopy);

    if (m_fDiscontinuity) {
	m_fDiscontinuity = FALSE;

	memmoveInternal(pwh->lpData, pwh->lpData + sizeof(MIDIHDR), dwCopy);
    } else {
	dwCopy = 0;
    }

    pwh->dwBufferLength = pmh->dwBufferLength + dwCopy;
    pwh->dwBytesRecorded = pmh->dwBufferLength + dwCopy;

    memmoveInternal(pwh->lpData + dwCopy, (pmh + 1), pmh->dwBufferLength);

    DWORD err = ::midiStreamOut(m_hmidi, (LPMIDIHDR) pwh, cbwh) ;

    return err;
}

//-----------------------------------------------------------------------------
// Internal function to get volume.
//-----------------------------------------------------------------------------

HRESULT CMidiOutDevice::GetVolume()
{
    // Write out the current Audio volume
    // ...query the device
    // assumes the device is connected...
    // if not we will query the volume from the mixer (probably)

    DWORD 		amp = 0;
    HMIDIOUT 	hDevice;

	MMRESULT err = MMSYSERR_NOERROR;

	if(!m_ListVolumeControl.GetCount())
	{
		DbgLog((LOG_ERROR, 1, TEXT("CMidiDevice::GetVolume:  no volume controls available")));
		return E_FAIL;
	}

	// for now, simply return the first volume control setting
	err = DoGetVolumeControl(
				m_ListVolumeControl.Get(m_ListVolumeControl.GetHeadPosition()),
				&m_wLeft,
				&m_wRight);

	if(err != MMSYSERR_NOERROR)
	{
		DbgLog((LOG_ERROR, 1, TEXT("CMidiDevice::GetVolume:  DoGetVolumControl failed")));
		return E_FAIL;
	}

	amp  = m_wLeft;
	amp |= m_wRight << 16;

	if(!(m_fHasVolume & (WAVECAPS_LRVOLUME)))
    {
	    // for mono cards map Left to Right
#ifdef DEBUG
	    // assert that the volume we want is in the low word
	    if (amp)
        {
			ASSERT(m_wLeft);
	    }
#endif
	    m_wRight = m_wLeft;
	}
    m_dwWaveVolume = amp;
	
	// map volume onto decibel range
	DWORD dwAmp = max(m_wLeft, m_wRight);
	m_lVolume = AmpFactorToDB( dwAmp );

	// remember to adjust the Balance value...
	if(m_fBalanceSet)
		SetBalance();
	else
		GetBalance();

	return err == MMSYSERR_NOERROR ? S_OK : S_FALSE;

}

//-----------------------------------------------------------------------------
// Internal routine to set the volume.  No parameter checking...
//-----------------------------------------------------------------------------
HRESULT CMidiOutDevice::PutVolume ()
{
	if(!m_ListVolumeControl.GetCount())
	{
		DbgLog((LOG_ERROR, 1, TEXT("CMidiDevice::GetVolume:  no volume controls available")));
		return E_FAIL;
		
	}
	MMRESULT mmr = 0;
	POSITION pos = m_ListVolumeControl.GetHeadPosition();
	while(pos)
	{
		mmr |= DoSetVolumeControl( m_ListVolumeControl.GetNext(pos), m_wLeft, m_wRight );

	}
	return mmr == MMSYSERR_NOERROR ? S_OK : E_FAIL;

}
//-----------------------------------------------------------------------------
// Internal routine to set the Balance.
//-----------------------------------------------------------------------------
void CMidiOutDevice::SetBalance ()
{
    //
    // Calculate scaling factors for midiOut API
    //
    LONG lTotalLeftDB, lTotalRightDB ;

    if (m_lBalance >= 0)
    {
	// left is attenuated
	lTotalLeftDB	= m_lVolume - m_lBalance ;
	lTotalRightDB	= m_lVolume;
    }
    else
    {
	// right is attenuated
	lTotalLeftDB	= m_lVolume;
	lTotalRightDB	= m_lVolume - (-m_lBalance);
    }

    DWORD dwLeftAmpFactor, dwRightAmpFactor;
    dwLeftAmpFactor   = DBToAmpFactor(lTotalLeftDB);
    dwRightAmpFactor  = DBToAmpFactor(lTotalRightDB);

    if (m_fHasVolume & (WAVECAPS_LRVOLUME))
    {
	// Set stereo volume
	m_dwWaveVolume = dwLeftAmpFactor;
	m_dwWaveVolume |= dwRightAmpFactor << 16;
    }
    else
    {
	// Average the volume
	m_dwWaveVolume = dwLeftAmpFactor;
	m_dwWaveVolume += dwRightAmpFactor;
	m_dwWaveVolume /= 2;
    }
    m_wLeft = WORD(dwLeftAmpFactor);
    m_wRight = WORD(dwRightAmpFactor);
}

//-----------------------------------------------------------------------------
// Internal routine to compute the Balance given right/left amp factors
//-----------------------------------------------------------------------------
void CMidiOutDevice::GetBalance()
{
	if (m_wLeft == m_wRight)
    {
	    m_lBalance = 0;
	}
    else
    {
	    // map Balance onto decibel range
	    LONG lLDecibel = AmpFactorToDB( m_wLeft );
		LONG lRDecibel = AmpFactorToDB( m_wRight );

	    // note: m_lBalance < 0:  right is quieter
	    //       m_lBalance > 0:  left is quieter
	    m_lBalance = lRDecibel - lLDecibel;
	}
}

//-----------------------------------------------------------------------------
// Internal routine used to get a mixer line balance control value
//-----------------------------------------------------------------------------

MMRESULT CMidiOutDevice::DoGetVolumeControl(CVolumeControl *pControl, WORD *pwLeft, WORD *pwRight)
{
	if(!pControl || !pwLeft || !pwRight)
	{
		DbgLog((LOG_ERROR,1,TEXT("DoGetVolumeControl::invalid parameter: pControl=%u, dwLeft=%u, dwRight=%u"),
			pControl, pwLeft, pwRight));
		return MMSYSERR_INVALPARAM;
	}

	MMRESULT mmr;

	DWORD adwVolume[2];
	adwVolume[0] = 0;
	adwVolume[1] = 0;

   	MIXERCONTROLDETAILS mxcd;

	mxcd.cbStruct = sizeof(mxcd);
	mxcd.dwControlID = pControl->dwControlID;
	mxcd.cChannels = pControl->dwChannels;
	mxcd.cMultipleItems = 0;
	mxcd.cbDetails = sizeof(2 * sizeof(DWORD));
	mxcd.paDetails = (LPVOID)adwVolume;

	mmr = mixerGetControlDetails(IntToPtr_(HMIXEROBJ, pControl->dwMixerID), &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);

	*pwLeft = (WORD)adwVolume[0];
	*pwRight = (WORD)adwVolume[1];

    DbgLog((LOG_TRACE,1,TEXT("DoGetVolumeControl::mixerGetControlDetails: err=%u, midiOutMixerID=%u, midiOutVolControlID=%u, left=%u, right=%u"),
		mmr, pControl->dwMixerID, pControl->dwControlID, *pwLeft, *pwRight));

	return mmr;
}

//-----------------------------------------------------------------------------
// Internal routine used to set a mixer line balance control
//-----------------------------------------------------------------------------

MMRESULT CMidiOutDevice::DoSetVolumeControl(CVolumeControl *pControl, DWORD dwLeft, DWORD dwRight)
{
	if(dwLeft > 65536 || dwRight > 65536 || !pControl)
	{
		DbgLog((LOG_ERROR,1,TEXT("DoSetVolumeControl::invalid parameter: pControl=%u, dwLeft=%u, dwRight=%u"),
			pControl, dwLeft, dwRight));
		return MMSYSERR_INVALPARAM;
	}

	MMRESULT mmr;

	DWORD adwVolume[2];
	adwVolume[0] = dwLeft;
	adwVolume[1] = dwRight;

   	MIXERCONTROLDETAILS mxcd;

	mxcd.cbStruct = sizeof(mxcd);
	mxcd.dwControlID = pControl->dwControlID;
	mxcd.cChannels = pControl->dwChannels;
	mxcd.cMultipleItems = 0;
	mxcd.cbDetails = sizeof(2 * sizeof(DWORD));
	mxcd.paDetails = (LPVOID)adwVolume;

	mmr = mixerSetControlDetails(IntToPtr_(HMIXEROBJ,pControl->dwMixerID), &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);

    DbgLog((LOG_TRACE,1,TEXT("DoSetVolumeControl::mixerSetControlDetails: err=%u, midiOutMixerID=%u, midiOutVolControlID=%u, left=%u, right=%u"),
		mmr, pControl->dwMixerID, pControl->dwControlID, dwLeft, dwRight));

	return mmr;
}

//-----------------------------------------------------------------------------
// Internal routine used to initialize all mixer line balance controls
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::DoDetectVolumeControl()
{
	MMRESULT mmr = MMSYSERR_NOERROR;

	if(m_ListVolumeControl.GetCount())
		return m_fHasVolume & WAVECAPS_VOLUME ?  MMSYSERR_NOERROR : MMSYSERR_NOTSUPPORTED;

    DbgLog((LOG_TRACE,1,TEXT("CMidiOutDevice::DoDetectVolume: Scanning for line controls..........")));

	UINT cMixers = ::mixerGetNumDevs();
	if(cMixers == 0)
		return MMSYSERR_NOTSUPPORTED;

	MIXERCAPS *pmxcaps;
	pmxcaps = new MIXERCAPS[ cMixers * sizeof(MIXERCAPS) ];
	if(!pmxcaps)
		return MMSYSERR_NOMEM;

	// loop over each mixer
	for(UINT iMixer = 0; iMixer < cMixers; iMixer++)
	{
		mmr = mixerGetDevCaps(iMixer, &(pmxcaps[iMixer]), sizeof(MIXERCAPS));

        DbgLog((LOG_TRACE,1,TEXT("DoDetectVolumeControl::mixerGetDevCaps: err=%u, mixerId=%ul, mixerName=%s"), mmr, iMixer, pmxcaps->szPname));

		if(mmr != MMSYSERR_NOERROR)
			continue;
					
    	MIXERLINE   mlDest;

		// loop over each mixer output looking for the one connected to the speaker jack
		for(UINT iDest = 0; iDest < pmxcaps[iMixer].cDestinations; iDest++)
		{
    		ZeroMemory(&mlDest, sizeof(mlDest));
    		mlDest.cbStruct = sizeof(mlDest);
   			mlDest.dwDestination = iDest;

    		mmr = mixerGetLineInfo(IntToPtr_(HMIXEROBJ, iMixer), &mlDest, MIXER_GETLINEINFOF_DESTINATION);

            DbgLog((LOG_TRACE,1,TEXT("DoDetectVolumeControl::mixerGetLineInfo(DESTINATION): err=%u, lineName=%s, componentType=%u"),
        				mmr, mlDest.szName, mlDest.dwComponentType));

			if(mmr != MMSYSERR_NOERROR)
				continue;

			// we've found the mixer connected to the speaker jack
			if(mlDest.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS)	
 			{
				MIXERLINE mlSrc;

				for(UINT iSrc = 0; iSrc < mlDest.cConnections; iSrc++)
				{
					ZeroMemory(&mlSrc, sizeof(mlSrc));
        			mlSrc.cbStruct = sizeof(mlSrc);
        			mlSrc.dwDestination = iDest;
        			mlSrc.dwSource = iSrc;

        			mmr = mixerGetLineInfo(IntToPtr_(HMIXEROBJ,iMixer), &mlSrc, MIXER_GETLINEINFOF_SOURCE);

	          		DbgLog((LOG_TRACE,1,TEXT("DoDetectVolumeControl::mixerGetLineInfo(SOURCE): err=%u, lineName=%s, componentType=%u"),
        				mmr, mlSrc.szName, mlSrc.dwLineID, mlSrc.dwComponentType ));

					if(mmr != MMSYSERR_NOERROR)
						continue;

					if(mlSrc.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER)
					{
						MIXERLINECONTROLS   mxlc;
						MIXERCONTROL		mxc;
						CVolumeControl		*pControl;

    					mxlc.cbStruct       = sizeof(mxlc);
    					mxlc.dwLineID       = mlSrc.dwLineID;
    					mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_VOLUME;
    					mxlc.cControls      = 1;
    					mxlc.cbmxctrl       = sizeof(mxc);
    					mxlc.pamxctrl       = &mxc;	 // the control description

						mmr = mixerGetLineControls(IntToPtr_(HMIXEROBJ,iMixer), &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE);
						if(mmr != MMSYSERR_NOERROR)
							continue;

    					DbgLog((LOG_TRACE,1,TEXT("DoDetectVolumeControl::mixerGetLineControl: err=%u, midiOutLineID=%u, midiOutVolControlID=%u, midiOutVolControlName=%s, midiOutChannels=%u, midiOutVolControlMinBounds=%u, midiOutVolControlMaxBounds=%u"),
    						mmr, mlSrc.dwLineID, mxlc.pamxctrl->dwControlID, mxlc.pamxctrl->szName, mlSrc.cChannels, mxlc.pamxctrl->Bounds.dwMinimum, mxlc.pamxctrl->Bounds.dwMaximum));
		
						pControl = new CVolumeControl(NAME("CMidiDevice volume control"));
						if(!pControl)
						{
							if(pmxcaps) delete pmxcaps;
							return MMSYSERR_NOMEM;
						}
						pControl->dwMixerID = iMixer;
						pControl->dwControlID = mxlc.pamxctrl->dwControlID;
						pControl->dwChannels = mlSrc.cChannels;

						m_ListVolumeControl.AddTail(pControl);

					} // MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER
				
				} // iSrc
				
			} // MIXERLINE_COMPONENTTYPE_DST_SPEAKERS

	  	} // iDest

	} // iMixer

	if(pmxcaps)
		delete pmxcaps;

	return mmr;

}

//-----------------------------------------------------------------------------

HRESULT CMidiOutDevice::amsndOutLoad(IPropertyBag *pPropBag)
{
    if(m_hmidi != 0)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    // caller makes sure we're not running

    VARIANT var;
    var.vt = VT_I4;
    HRESULT hr = pPropBag->Read(L"MidiOutId", &var, 0);
    if(SUCCEEDED(hr))
    {
        m_iMidiOutId = var.lVal;
        SetResourceName();
    }
    else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    return hr;
}

// use a version number instead of size to reduce chances of picking
// an invalid device from a 1.0 grf file
struct MidiOutPersist
{
    DWORD dwVersion;
    LONG iMidiOutId;
};


HRESULT  CMidiOutDevice::amsndOutWriteToStream(IStream *pStream)
{
    MidiOutPersist mop;
    mop.dwVersion = 200;
    mop.iMidiOutId = m_iMidiOutId;
    return pStream->Write(&mop, sizeof(mop), 0);
}

HRESULT  CMidiOutDevice::amsndOutReadFromStream(IStream *pStream)
{
    if(m_hmidi != 0)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    // on any error, default to the wave mapper because we may have
    // found the old audio renderer which has the same guid
    m_iMidiOutId = MIDI_MAPPER;

    // caller makes sure we're not running
    MidiOutPersist mop;
    HRESULT hr = pStream->Read(&mop, sizeof(mop), 0);
    if(SUCCEEDED(hr))
    {
        if(mop.dwVersion == 200)
        {
            m_iMidiOutId = mop.iMidiOutId;
        }
    }

    hr = S_OK;
    SetResourceName();

    return hr;
}

int CMidiOutDevice::amsndOutSizeMax()
{
    return sizeof(MidiOutPersist);
}

void CMidiOutDevice::SetResourceName()
{
    wsprintfW(m_wszResourceName, L".\\MidiOut\\%08x", m_iMidiOutId);
}

#if 0
// LEGACY, we don't need to send notes off messages, as the streaming API already keeps track of active notes
// under the covers.  keeping code in place for now.
typedef struct
{
    BYTE    status;
    BYTE    byte2;
    BYTE    byte3;
    BYTE    time;
} FOURBYTEEVENT;

typedef union
{
    DWORD         wordMsg;
    FOURBYTEEVENT byteMsg;
} SHORTEVENT;

MMRESULT CMidiOutDevice::DoAllNotesOff()
{
    ASSERT(m_hmidi != 0);

    SHORTEVENT shortMidiEvent;
    UINT uiChannel;
    UINT uiKey;

    for(uiChannel = 0; uiChannel < 16; uiChannel++)
    {
        // sustain pedal off for all uiChannels
        shortMidiEvent.byteMsg.status= (BYTE) (0xB0 + uiChannel);
        shortMidiEvent.byteMsg.byte2 = (BYTE) 0x40;
        shortMidiEvent.byteMsg.byte3 = 0x0;
        ::midiOutShortMsg(HMIDIOUT(m_hmidi), shortMidiEvent.wordMsg);

        // now do note offs
        shortMidiEvent.byteMsg.status= (BYTE) (0x80 + uiChannel);
        shortMidiEvent.byteMsg.byte3 = 0x40;  // release velocity
        for(uiKey = 0; uiKey < 128; uiKey++)
        {
            shortMidiEvent.byteMsg.byte2 = (BYTE) uiKey;
            // turn it off
            ::midiOutShortMsg(HMIDIOUT(m_hmidi), shortMidiEvent.wordMsg);
        }
    }
    return MMSYSERR_NOERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\midif.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// The MIDI format consists of the time division of the file.  This is found
// in the header of an smf file.  It doesn't change and needs to be sent to
// MMSYSTEM before we play the file.
typedef struct _MIDIFORMAT {
    DWORD		dwDivision;
    DWORD		dwReserved[7];
} MIDIFORMAT, FAR * LPMIDIFORMAT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\midiout.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// Implements the CMidiOutDevice class based on midiOut APIs
//-----------------------------------------------------------------------------

extern const AMOVIESETUP_FILTER midiFilter;

class CMidiOutDevice : public CSoundDevice
{

public:
    // define the public functions that this class exposes. These are all
    // straight calls to the corresponding waveOut APIs. Only the APIs that are
    // used by the Quartz wave renderer are declared and defined. We may have
    // to progressively add to this list.

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    MMRESULT amsndOutClose () ;
    MMRESULT amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc) ;
    MMRESULT amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText) ;
    MMRESULT amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos) ;
    MMRESULT amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
                           double dRate, DWORD *pnAvgBytesPerSec,
                           DWORD_PTR dwCallBack, DWORD_PTR dwCallBackInstance, DWORD fdwOpen) ;
    MMRESULT amsndOutPause () ;
    MMRESULT amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutReset () ;
    MMRESULT amsndOutBreak () { return NOERROR; };
    MMRESULT amsndOutRestart () ;
    MMRESULT amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, REFERENCE_TIME const *pStart, BOOL bIsDiscontinuity) ;

    // Routines required for initialisation and volume/balance handling
    // These are not part of the Win32 waveOutXxxx api set
    HRESULT  amsndOutCheckFormat (const CMediaType *pmt, double dRate);
    void     amsndOutGetFormat (CMediaType *pmt)
    {
        pmt->SetType(&MEDIATYPE_Midi);
    }
    LPCWSTR  amsndOutGetResourceName () ;
    HRESULT  amsndOutGetBalance (LPLONG plBalance) ;
    HRESULT  amsndOutGetVolume (LPLONG plVolume) ;
    HRESULT  amsndOutSetBalance (LONG lVolume) ;
    HRESULT  amsndOutSetVolume (LONG lVolume) ;

    HRESULT  amsndOutLoad(IPropertyBag *pPropBag) ;

    HRESULT  amsndOutWriteToStream(IStream *pStream);
    HRESULT  amsndOutReadFromStream(IStream *pStream);
    int      amsndOutSizeMax();
    bool     amsndOutCanDynaReconnect() { return false; } // MIDI renderer doesn't support dynamic reconnection

    CMidiOutDevice () ;
    ~CMidiOutDevice () ;

private:
    // Get current settings from the hardware and set member variables
    HRESULT GetVolume ();

    // Put current settings to the hardware using member variables
    HRESULT PutVolume();

    // Set up right/left amp factors
    void SetBalance();

	// Get the current balance from right/left amp factors
	void GetBalance();

	class CVolumeControl : CBaseObject
	{
	    friend class CMidiOutDevice ;
		CVolumeControl(TCHAR *pName) : CBaseObject(pName) {};

		DWORD dwMixerID;
		DWORD dwControlID;
		DWORD dwChannels;
	};

    // volume is in the range -10000 to 0 (100th DB units)
    // amplitude and Balance are cumulative
    LONG	m_lVolume;
    LONG	m_lBalance;

    WORD	m_wLeft;		// Left channel volume
    WORD	m_wRight;		// Right channel volume
    DWORD	m_dwWaveVolume;
    BOOL	m_fHasVolume;		// wave device can set the volume

    HMIDISTRM	m_hmidi;		// remember the handle of the open device

	UINT	m_iMidiOutId;		// output device to open

    BOOL	m_fDiscontinuity;

    DWORD	m_dwDivision;
    DWORD_PTR   m_dwCallBack;
    DWORD_PTR   m_dwCallBackInstance;

	BOOL		    m_fBalanceSet;				// remember if the balance was explictly set at least once

	typedef CGenericList<CVolumeControl> CVolumeControlList;
	CVolumeControlList m_ListVolumeControl;

	MMRESULT		DoDetectVolumeControl();		// enumerate over all mixers, lines, and line controls, looking for line supporting MIDI balance
	MMRESULT		DoSetVolumeControl(CVolumeControl *pControl, DWORD dwLeft, DWORD dwRight);  	// set a balance control
	MMRESULT		DoGetVolumeControl(CVolumeControl *pControl, WORD *pwLeft, WORD *pwRight); // get a balance control
    	MMRESULT		DoOpen();

    static void MIDICallback(HDRVR hdrvr, UINT uMsg, DWORD_PTR dwUser,
					DWORD_PTR dw1, DWORD_PTR dw2);

	WCHAR	m_wszResourceName[100]; // for resource manager
	void	SetResourceName();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\passthru.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

//-----------------------------------------------------------------------------
// Implements a CPosPassThru object specific to the audio renderer that
// adds the ability to monitor the rate being set
//-----------------------------------------------------------------------------

#include <streams.h>
#include "waveout.h"

CARPosPassThru::CARPosPassThru( CWaveOutFilter *pWaveOutFilter, HRESULT*phr, CWaveOutInputPin *pPin )
    : CPosPassThru (NAME("Audio Render CPosPassThru"),
		    pWaveOutFilter->GetOwner(), phr, pPin)
    , m_pFilter (pWaveOutFilter)
    , m_pPin    (pPin)
{};

STDMETHODIMP CARPosPassThru::SetRate( double dRate )
{
    // if our filter accepts the rate, then call the base class
    // otherwise return the error from the filter.

    HRESULT hr = m_pPin->SetRate(dRate);
    if( S_FALSE == hr )
    {
        //
        // S_FALSE means that the audio renderer input pin doesn't
        // think its rate needs to be changed. Make sure the inherited 
        // class (the upstream filter), since the renderer might not be handling 
        // the rate change (i.e. for MIDI the parser will handle the change)
        //
        double dInheritedRate;
        hr = inherited::GetRate( &dInheritedRate );
        if( ( S_OK == hr ) && ( dInheritedRate == dRate ) )
        {
            // change hr to S_OK to force the upcoming SetRate call
            hr = S_OK;         
        }        
    }    
    
    if (S_OK == hr) {
        //
        // this will cause the upstream filter to notify us via NewSegment
        // of the rate change
        //
	hr = inherited::SetRate(dRate);
    } else if (S_FALSE == hr) {
	// ?? Should we return S_FALSE or change it to S_OK ??
	hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CARPosPassThru::put_Rate( double dRate )
{
    // if our filter accepts the rate, then call the base class
    // otherwise return the error from the filter.

    HRESULT hr = m_pPin->SetRate(dRate);
    if (S_OK == hr) {
	hr = inherited::put_Rate(dRate);
    } else if (S_FALSE == hr) {
	// ?? Should we return S_FALSE or change it to S_OK ??
	hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\dsr.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// Implements the CDSoundDevice class based on DSound.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Includes.
//-----------------------------------------------------------------------------
#include <streams.h>
#include <dsound.h>
#include <mmreg.h>
#include <malloc.h>
#ifndef FILTER_DLL
#include <stats.h>
#endif
#include "waveout.h"
#include "dsr.h"
#include <limits.h>
#include <measure.h>        // Used for time critical log functions
#include <ks.h>
#include <ksmedia.h>

#ifdef DXMPERF
#include <dxmperf.h>
#endif // DXMPERF

#define _AMOVIE_DB_
#include "decibels.h"

#ifdef DETERMINE_DSOUND_LATENCY
extern LONGLONG BufferDuration(DWORD nAvgBytesPerSec, LONG lData);
#else
#ifdef DXMPERF
extern LONGLONG BufferDuration(DWORD nAvgBytesPerSec, LONG lData);
#endif // DXMPERF
#endif // DETERMIN_DSHOW_LATENCY

#ifdef PERF
#define AUDRENDPERF(x) x
#else
#define AUDRENDPERF(x)
#endif

//
// Define the dynamic setup structure for filter registration.  This is
// passed when instantiating an audio renderer in its direct sound guise.
// Note: waveOutOpPin is common to direct sound and waveout renderers.
//

AMOVIESETUP_FILTER dsFilter = { &CLSID_DSoundRender     // filter class id
                    , L"DSound Audio Renderer"  // filter name
                    , MERIT_PREFERRED-1         // dwMerit
                    , 1
                    , &waveOutOpPin };


// formerly DSBCAPS_CNTRLDEFAULT
const DWORD gdwDSBCAPS_CTRL_PAN_VOL_FREQ = DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY;

const MAJOR_ERROR = 5 ;
const MINOR_ERROR = 10 ;
const TRACE_THREAD_STATUS = 100 ;
const TRACE_TIME_REPORTS = 100;
const TRACE_FOCUS = 100 ;
const TRACE_FORMAT_INFO = 15 ;
const TRACE_SYSTEM_INFO = 10 ;
const TRACE_STATE_INFO = 10 ;
const TRACE_CALL_STACK = 10 ;
const TRACE_CALL_TIMING = 1 ;
const TRACE_SAMPLE_INFO = 20 ;
const TRACE_STREAM_DATA = 5 ;
const TRACE_BREAK_DATA = 5 ;
const TRACE_THREAD_LATENCY = 5 ;
const TRACE_CLEANUP = 100 ;
const TRACE_BUFFER_LOSS = 3 ;

const DWORD EMULATION_LATENCY_DIVISOR = 8;    // Emulation mode clock latency may be as
                                              // great as 80ms. We'll pick 1/8sec to be safe.

const DWORD MIN_SAMPLE_DUR_REQ_FOR_OPT = 50;  // Only use buffer optimization if sample duration
                                              // is greater than this millisec value.
const DWORD OPTIMIZATION_FREQ_LIMIT = 1000 / MIN_SAMPLE_DUR_REQ_FOR_OPT; // our divisor to find buffer size for opt

//  Helpers to round dsound buffer sizes etc
DWORD BufferSize(const WAVEFORMATEX *pwfx, BOOL bUseLargeBuffer)
{
    if (pwfx->nBlockAlign == 0) {
        return pwfx->nAvgBytesPerSec;
    }
    DWORD dw = pwfx->nAvgBytesPerSec + pwfx->nBlockAlign - 1;
    DWORD dwSize = dw - (dw % pwfx->nBlockAlign); 
    if(bUseLargeBuffer)
    {
        dwSize *= 3; // use 3 second buffer in these cases
    }
    return dwSize;
}

bool IsNativelySupported( PWAVEFORMATEX pwfx );
bool CanWriteSilence( PWAVEFORMATEX pwfx );


//-----------------------------------------------------------------------------
// CreateInstance for the DSoundDevice. This will create a new DSoundDevice
// and a new CWaveOutFilter, passing it the sound device.
//-----------------------------------------------------------------------------
CUnknown *CDSoundDevice::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
#ifdef PERF
    int m_idWaveOutGetNumDevs   = MSR_REGISTER("waveOutGetNumDevs");
#endif

    // make sure that there is at least one audio card in the system. Fail
    // the create instance if not.
    DbgLog((LOG_TRACE, 2, TEXT("Calling waveOutGetNumDevs")));
    AUDRENDPERF(MSR_START(m_idWaveOutGetNumDevs));
    MMRESULT mmr = waveOutGetNumDevs();
    AUDRENDPERF(MSR_STOP(m_idWaveOutGetNumDevs));
    if (0 == mmr)
    {
        *phr = VFW_E_NO_AUDIO_HARDWARE ;
        return NULL ;
    }
    DbgLog((LOG_TRACE, 2, TEXT("Called waveOutGetNumDevs")));

    return CreateRendererInstance<CDSoundDevice>(pUnk, &dsFilter, phr);
}

//-----------------------------------------------------------------------------
// CDSoundDevice constructor.
//
// This simply gets the default window for later use and intialized some
// variable. It also saves the passed in values for the filtergraph and filter
//-----------------------------------------------------------------------------
CDSoundDevice::CDSoundDevice ()
  : m_ListRipe(NAME("CDSoundFilter ripe list"))
  , m_ListAudBreak (NAME("CDSoundFilter Audio Break list"))
  , m_WaveState ( WAVE_CLOSED )
  , m_lpDS ( NULL )
  , m_lpDSBPrimary ( NULL )
  , m_lpDSB ( NULL )
  , m_lp3d ( NULL )
  , m_lp3dB ( NULL )
  , m_hDSoundInstance ( NULL )
  , m_pWaveOutFilter ( NULL )
  , m_callbackAdvise ( 0 )
  , m_hFocusWindow (NULL)
  , m_fAppSetFocusWindow (FALSE)
  , m_fMixing (TRUE)
  , m_lBalance (AX_BALANCE_NEUTRAL)
  , m_lVolume (AX_MAX_VOLUME)
  , m_guidDSoundDev (GUID_NULL)
  , m_dRate(1.0)
  , m_bBufferLost(FALSE)
  , m_pWaveOutProc(NULL)
  , m_bDSBPlayStarted(FALSE)
#ifndef FILTER_DLL
  , m_lStatFullness(g_Stats.Find(L"Sound buffer percent fullness", true))
  , m_lStatBreaks(g_Stats.Find(L"Audio Breaks", true))
#endif
//  , m_fEmulationMode(FALSE)  //removing after discovering WDM latency
  , m_dwSilenceWrittenSinceLastWrite(0)
  , m_NumAudBreaks( 0 )
  , m_lPercentFullness( 0 )
  , m_hrLastDSoundError( S_OK )
  , m_bIsTSAudio( FALSE )
{
#ifdef ENABLE_10X_FIX
    Reset10x();
#endif

#ifdef PERF
    m_idDSBWrite            = MSR_REGISTER("Write to DSB");
    m_idThreadWakeup        = MSR_REGISTER("Thread wake up time");
    m_idAudioBreak          = MSR_REGISTER("Audio break (ms)");
    m_idGetCurrentPosition  = MSR_REGISTER("GetCurrentPosition");
#endif

    if( GetSystemMetrics( SM_REMOTESESSION ) ) // flag supported on NT4 sp4 and later, should just fail otherwise
    {
        DbgLog((LOG_TRACE, 2, TEXT("** Using remote audio **")) );
        m_bIsTSAudio = TRUE;
    }
}

//-----------------------------------------------------------------------------
// CDSoundDevice destructor.
//
// Just makes sure that the DSound device has been closed. It also frees the
// ripe list
//-----------------------------------------------------------------------------

CDSoundDevice::~CDSoundDevice ()
{
    // the DirectSound object itself may have lived around till this point
    // because we may have just called QUERY_FORMAT and then dismantled the
    // graph. If it is still around, get rid of it now.
    if (m_lpDS)
    {
        HRESULT hr = m_lpDS->Release();
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("~CDSoundDevice: Release of lpDS failed: %u"), hr & 0x0ffff));
        }
        m_lpDS = NULL;
    }

    ASSERT (m_lpDSBPrimary == NULL) ;
    ASSERT (m_lpDSB == NULL) ;
    ASSERT (m_ListRipe.GetCount () == 0) ;
    ASSERT (m_ListAudBreak.GetCount () == 0) ;

}

//-----------------------------------------------------------------------------
// amsndOutClose.
//
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutClose ()
{
    // if the wave device is still playing, return error
    if (m_WaveState == WAVE_PLAYING)
    {
        DbgLog((LOG_ERROR,MINOR_ERROR,TEXT("amsndOutClose called when device is playing")));

#ifdef BUFFERLOST_FIX
        if (!RestoreBufferIfLost(FALSE))
        {
            // if we've lost the buffer allow cleanup to continue
            DbgLog((LOG_TRACE,TRACE_BUFFER_LOSS,TEXT("amsndOutClose: We've lost the dsound buffer, but we'll cleanup anyway")));
        }
        else
        {
#endif BUFFERLOST_FIX
            DbgLog((LOG_ERROR,MINOR_ERROR,TEXT("amsndOutClose called when device is playing")));
            return WAVERR_STILLPLAYING ;
#ifdef BUFFERLOST_FIX
        }
#endif BUFFERLOST_FIX
    }

    StopCallingCallback();

     // clean up all the DSound objets.
    CleanUp();

#ifdef ENABLE_10X_FIX
    Reset10x();
#endif

    // make the WOM_CLOSE call back

    if (m_pWaveOutProc)
        (* m_pWaveOutProc) (OUR_HANDLE, WOM_CLOSE, m_dwCallBackInstance, 0, 0) ;
    return MMSYSERR_NOERROR ;
}
//-----------------------------------------------------------------------------
// amsndOutDoesRSMgmt.
//-----------------------------------------------------------------------------
LPCWSTR CDSoundDevice::amsndOutGetResourceName ()
{
    return NULL;
}

//-----------------------------------------------------------------------------
// waveGetDevCaps
//
// Currently this is being used in the waveRenderer to simply figure out whether
// the device will support volume setting.
//
// As we create the secondary buffer to have CTRLVOLUME and CTRLPAN. These will
// always be there. So we will not even call DSound on this call.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc)
{
    // if not enough memory has been returned to set the dwSupport field (which
    // also happens to be the last field in the structure) return error.
    // This is a bit of a difference from the actual waveOut APIs. However,
    // as I said, this is specific to what the waveRenderer needs.

    if (cbwoc != sizeof (WAVEOUTCAPS))
    {
        DbgLog((LOG_ERROR, MINOR_ERROR,TEXT("waveGetDevCaps called with not enough return buffer")));
        return MMSYSERR_NOMEM ;
    }

    pwoc->dwSupport |= (WAVECAPS_VOLUME | WAVECAPS_LRVOLUME) ;

    return MMSYSERR_NOERROR ;
}

#ifdef DEBUG
char errText[] = "DirectSound error: no additional information";
#endif

//-----------------------------------------------------------------------------
// amsndOutGetErrorText
//
// This code currently does not do any thing. A reasonable thing to do would
// be to keep track of all the errors that this file returns and to return
// those via strings in the .RC file. Since this is currently being used in
// DEBUG only code in the waveRenderer, I have not bothered to do this extra
// bit of work.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText)
{
#ifdef DEBUG
    memcpy(pszText, errText, min(cchText, sizeof(errText)) * sizeof(TCHAR));
#else
    *pszText = 0;
#endif
    return MMSYSERR_NOERROR ;
}

//-----------------------------------------------------------------------------
// amsndOutGetPosition
//
// This function will ALWAYS return the position as a BYTE offset from the
// beginning of the stream. It will not bother to check the requested format
// for this information (we are legitimately allowed to do so.)
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos)
{

    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR,TEXT("amsndOutGetPosition called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    if (cbmmt < sizeof (MMTIME))
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR,TEXT("amsndOutGetPosition called with small time buffer")));
        return MMSYSERR_NOMEM ;
    }

    // we will always return time as bytes.
    pmmt->wType = TIME_BYTES ;

    *(UNALIGNED LONGLONG *)&pmmt->u.cb = GetPlayPosition(bUseUnadjustedPos);

    DbgLog((LOG_TRACE, TRACE_TIME_REPORTS, TEXT("Reported Time = %u"), pmmt->u.cb));
    return MMSYSERR_NOERROR ;
}

//-----------------------------------------------------------------------------
// amsndOutGetBalance
//
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::amsndOutGetBalance (LPLONG plBalance)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR, MINOR_ERROR,TEXT("amsndOutGetPosition called when lpDSB is NULL")));
        *plBalance = m_lBalance;

        return MMSYSERR_NOERROR ;
    }

    HRESULT hr = m_lpDSB->GetPan (plBalance) ;
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutGetBalance: GetPan failed %u"), hr & 0x0ffff));
    }
    else
    {
        m_lBalance = *plBalance;
    }
    return hr ;
}
//-----------------------------------------------------------------------------
// amsndOutGetVolume
//
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::amsndOutGetVolume (LPLONG plVolume)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR,TEXT("amGetVolume called when lpDSB is NULL")));
        *plVolume = m_lVolume;
        return MMSYSERR_NOERROR ;
    }

    HRESULT hr = m_lpDSB->GetVolume (plVolume) ;
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutGetVolume: GetVolume failed %u"), hr & 0x0ffff));
    }
    else
    {
        m_lVolume = *plVolume;
    }
    return hr ;
}


HRESULT CDSoundDevice::amsndOutCheckFormat(const CMediaType *pmt, double dRate)
{
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Entering CDSoundDevice::amsndOutCheckFormat")));

    // reject non-Audio type
    if (pmt->majortype != MEDIATYPE_Audio) {
        return E_INVALIDARG;
    }

    // if it's MPEG audio, we want it without packet headers.
    if (pmt->subtype == MEDIASUBTYPE_MPEG1Packet) {
        return E_INVALIDARG;
    }

    if (pmt->formattype != FORMAT_WaveFormatEx &&
        pmt->formattype != GUID_NULL) {
        return E_INVALIDARG;
    }

    //
    // it would always be safer to explicitly check for those formats
    // we support rather than tossing out the ones we know are not
    // supported.  Otherwise, if a new format comes along we could
    // accept it here but barf later.
    //

    if (pmt->FormatLength() < sizeof(PCMWAVEFORMAT))
        return E_INVALIDARG;

    {
        // if filter's running prevent it from getting stopped in the middle of this
        CAutoLock lock(m_pWaveOutFilter);

        UINT err = amsndOutOpen(NULL,
                                (WAVEFORMATEX *) pmt->Format(),
                                dRate,
                                0,   // pnAvgBytesPerSec
                                0,
                                0,
                                WAVE_FORMAT_QUERY);

        if (err != 0) {
#ifdef DEBUG
            TCHAR message[100];
            waveOutGetErrorText(err, message, sizeof(message)/sizeof(TCHAR));
            DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("Error checking wave format: %u : %s"), err, message));
#endif
            if (WAVERR_BADFORMAT == err) {
                return VFW_E_UNSUPPORTED_AUDIO;
            } else {
                return VFW_E_NO_AUDIO_HARDWARE;
            }
        }
    }
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Exiting CDSoundDevice::amsndOutCheckFormat")));

    return S_OK;
}


HRESULT CDSoundDevice::CreateDSound(BOOL bQueryOnly)
{
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Entering CDSoundDevice::CreateDSound")));

    HRESULT hr = S_OK;
    
    // already open
    if (m_lpDS)
        goto set_coop ;         // set the cooperative level and return
        
    if (!m_pWaveOutFilter->m_pAudioDuplexController)
    {
        // We're not set to use the DuplexController object so
        // create the DSound object now.  We LoadLibrary DSOUND and use
        // GetProcAddress instead of static linking so that our dll will
        // still load on platforms that do not have DSound yet.

        if(!m_hDSoundInstance)
        {
            DbgLog((LOG_TRACE, 2, TEXT("Loading DSound.DLL")));
            m_hDSoundInstance = LoadLibrary (TEXT("DSOUND.DLL")) ;
            DbgLog((LOG_TRACE, 2, TEXT("Loaded DSound.DLL")));
            if (m_hDSoundInstance == NULL) {
                DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("DSOUND.DLL not in the system!")));
                return MMSYSERR_NODRIVER ;
            }
        }
        PDSOUNDCREATE       pDSoundCreate;    // ptr to DirectSoundCreate
        DbgLog((LOG_TRACE, 2, TEXT("Calling DirectSoundCreate")));
        pDSoundCreate = (PDSOUNDCREATE) GetProcAddress (m_hDSoundInstance,
                            "DirectSoundCreate") ;
        DbgLog((LOG_TRACE, 2, TEXT("Called DirectSoundCreate")));
        if (pDSoundCreate == NULL) {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("DirectSoundCreate not exported by DSOUND.DLL!")));
            return MMSYSERR_NODRIVER ;
        }

        hr = (*pDSoundCreate)( m_guidDSoundDev == GUID_NULL ? 0 : &m_guidDSoundDev, &m_lpDS, NULL );
        if( hr != DS_OK ) {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("*** DirectSoundCreate failed! %u"), hr & 0x0ffff));

            // If the create failed because the device is allocated, return
            // the corresponding MMSYSERR message, else the generic message
            if (hr == DSERR_ALLOCATED)
                return MMSYSERR_ALLOCATED ;
            else
                return MMSYSERR_NODRIVER ;
        }
      
        // after this point m_lpDS is valid and we will not try and
        // load DSound again
        ASSERT(m_lpDS);

set_coop:

        if (!bQueryOnly)
        {
            // If the application has set a focus windows, use that, or else
            // we will just pick the foreground window and do global focus.
            HWND hFocusWnd ;
            if (m_hFocusWindow)
                hFocusWnd = m_hFocusWindow ;
            else
                hFocusWnd = GetForegroundWindow () ;
            if (hFocusWnd == NULL)
                hFocusWnd = GetDesktopWindow () ;

            // Set the cooperative level
            DbgLog((LOG_TRACE, TRACE_FOCUS, TEXT(" hWnd for SetCooperativeLevel = %x"), hFocusWnd));
            hr = m_lpDS->SetCooperativeLevel( hFocusWnd, DSSCL_PRIORITY );
            if( hr != DS_OK )
            {
                DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("*** Warning: SetCooperativeLevel failed 1st attempt! %u"), hr & 0x0ffff));
                if (!m_fAppSetFocusWindow)
                {
                    //
                    // only do when we weren't explicitly given an hwnd
                    //
                    // It's possible that we got the wrong window on the GetForegroundWindow
                    // call (and even worse, we got some other window that's been destroyed),
                    // so if this failed we will try the
                    // GetForegroundWindow()/SetCooperativeLevel() pair of calls a few more
                    // times in hopes of getting a valid hwnd.
                    //
                    const int MAX_ATTEMPTS_AT_VALID_HWND = 10;
                    int cRetry = 0;

                    while (cRetry < MAX_ATTEMPTS_AT_VALID_HWND)
                    {
                        hFocusWnd = GetForegroundWindow () ;
                        if (!hFocusWnd)
                            hFocusWnd = GetDesktopWindow () ;

                        hr = m_lpDS->SetCooperativeLevel( hFocusWnd, DSSCL_PRIORITY );
                        if ( DS_OK == hr )
                            break;

                        cRetry++;
                    }
                    if ( DS_OK != hr )
                    {
                        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("*** SetCooperativeLevel failed after multiple attempts! %u"), hr & 0x0ffff));
                    }
                }
            }
        }            
    }
    else
    {
        //
        // otherwise we've been set to use the Full Duplex Controller object,
        // so we use the DSound object we get back from that
        //
        
        // tell the FullDuplexController object the device and buffer size we're using
        hr = NotifyFullDuplexController();
        if( S_OK != hr )
        {
            return hr;
        }
        // need a critsec?
        
        // now get the dsound object and buffer for the AEC render side
        hr = m_pWaveOutFilter->m_pAudioDuplexController->GetRenderDevice(
            &m_lpDS,
            &m_lpDSBPrimary
            );

        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT(" IAudioDuplexController::GetRenderDevice failed (0x%08lx)"), hr));
            return hr;
        }
    }
   
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Exiting CDSoundDevice::CreateDSound")));

    return NOERROR;
}

HRESULT CDSoundDevice::CreateDSoundBuffers(double dRate)
{

    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Entering CDSoundDevice::CreateDSoundBuffers")));

    WAVEFORMATEX *pwfx = m_pWaveOutFilter->WaveFormat();
    DSBUFFERDESC dsbd;
    HRESULT hr = S_OK;
    
    if (!m_pWaveOutFilter->m_pAudioDuplexController)
    {
        // don't create a sound buffer and set primary format if we're using the AudioDuplexController
        
        // already made
        if (m_lpDSBPrimary)
            return NOERROR;

        // can't do this until somebody calls CreateDSound
        if (m_lpDS == NULL)
            return E_FAIL;

        memset( &dsbd, 0, sizeof(dsbd) );
        dsbd.dwSize  = sizeof(dsbd);
        // Just in case we want to do neat 3D stuff
        //
        dsbd.dwFlags = DSBCAPS_PRIMARYBUFFER;

        // If we want to use 3D, we need to create a special primary buffer, and
        // make sure it's stereo
        if (m_pWaveOutFilter->m_fWant3D) {
            DbgLog((LOG_TRACE,3,TEXT("*** Making 3D primary")));
            dsbd.dwFlags |= DSBCAPS_CTRL3D;
        }
        hr = m_lpDS->CreateSoundBuffer( &dsbd, &m_lpDSBPrimary, NULL );

        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: Primary buffer can't be created: %u"), hr &0x0ffff));
            CleanUp () ;
            return MMSYSERR_ALLOCATED ;
        }

        // set the format. This is a hint and may fail. DSound will do the right
        // thing if this fails.
        // and do a retry with a smart rate if it fails?
        hr = SetPrimaryFormat( pwfx, TRUE );
        if (DS_OK != hr)
        {
            CleanUp();
            return hr;
        }

        // if it fails, we won't use it
        if (m_pWaveOutFilter->m_fWant3D) {
            hr = m_lpDSBPrimary->QueryInterface(IID_IDirectSound3DListener,
                            (void **)&m_lp3d);
            if (hr == DS_OK)
                DbgLog((LOG_TRACE,3,TEXT("*** got LISTENER interface")));
            else
                DbgLog((LOG_TRACE,3,TEXT("*** ERROR: no LISTENER interface")));
        }
    }
    
    memset( &dsbd, 0, sizeof(dsbd) );
    dsbd.dwSize        = sizeof(dsbd);
    dsbd.dwFlags       = GetCreateFlagsSecondary( pwfx );
    dsbd.dwBufferBytes = BufferSize(pwfx, m_bIsTSAudio);  // one second buffer size
    dsbd.lpwfxFormat   = pwfx;                            // format information

    DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" DSB Size = %u" ), BufferSize(pwfx, m_bIsTSAudio)));

    // Dump the contents of the WAVEFORMATEX type-specific format structure
    DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" Creating Secondary buffer for the following format ..." )));
#ifdef DEBUG
    DbgLogWaveFormat( TRACE_FORMAT_INFO, pwfx );
#endif

    hr = m_lpDS->CreateSoundBuffer( &dsbd, &m_lpDSB, NULL );
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: Secondary buffer can't be created: %u"), hr &0x0ffff));
        CleanUp () ;
        return MMSYSERR_ALLOCATED ;
    }
    m_bBufferLost = FALSE;
    m_llAdjBytesPrevPlayed = 0;

    // if we're slaving we need to use the lower quality SRC to have finer frequency change granularity
    if( m_pWaveOutFilter->m_fFilterClock == WAVE_OTHERCLOCK )
    {
        // if we fail just keep going (call will log result)
        HRESULT hrTmp = SetSRCQuality( KSAUDIO_QUALITY_PC );
    }    
    
#ifdef DEBUG
    //
    // if we switch from a slaved graph to one where we're the master clock we really
    // should switch back to the OS/user default SRC, but we're going to punt that to later...
    //
    //
    // call this for debug logging of the current SRC setting
    DWORD dwSRCQuality = 0;
    GetSRCQuality( &dwSRCQuality );
#endif

    if (! m_pWaveOutFilter->m_pAudioDuplexController)
    {
        // disable SetRate calls when using AEC, correct?
        hr = SetRate((dRate == -1.0 ? m_dRate : dRate), pwfx->nSamplesPerSec, m_lpDSB);
        if(hr != DS_OK)
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: SetFrequency failed: %u"), hr &0x0ffff));
            CleanUp();
            return hr;
        }
    }
               
    // set the current position to be at 0
    hr = m_lpDSB->SetCurrentPosition( 0) ;
    if (hr != DS_OK)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: error in lpDSB->SetCurrentPosition! hr = %u"), hr & 0x0ffff));
        CleanUp () ;
        return MMSYSERR_ALLOCATED ;
    }

    // if it fails, we won't use it
    if (m_pWaveOutFilter->m_fWant3D) {
        hr = m_lpDSB->QueryInterface(IID_IDirectSound3DBuffer,
                            (void **)&m_lp3dB);
        if (hr == DS_OK)
            DbgLog((LOG_TRACE,3,TEXT("*** got 3DBUFFER interface")));
        else
            DbgLog((LOG_TRACE,3,TEXT("*** ERROR: no 3DBUFFER interface")));
    }

    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Exiting CDSoundDevice::CreateDSoundBuffers")));
    return NOERROR;
}

HRESULT CDSoundDevice::NotifyFullDuplexController()
{
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Entering CDSoundDevice::NotifyFullDuplexController")));

    // we will just pick the foreground window and do global focus.
    HWND hFocusWnd = GetForegroundWindow () ;
    if (hFocusWnd == NULL)
        hFocusWnd = GetDesktopWindow () ;

    DSBUFFERDESC BufferDescription;
    memset( &BufferDescription, 0, sizeof(BufferDescription) );
    BufferDescription.dwSize  = sizeof(BufferDescription);
    
    //    
    // we can't use the DSBCAPS_PRIMARYBUFFER flag for AEC
    //
    BufferDescription.dwFlags    = 
        DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_GETCURRENTPOSITION2;


    WAVEFORMATEX *pwfx = m_pWaveOutFilter->WaveFormat();

    BufferDescription.dwBufferBytes = BufferSize(pwfx, m_bIsTSAudio); 
    BufferDescription.lpwfxFormat   = pwfx; 

    HRESULT hr = m_pWaveOutFilter->m_pAudioDuplexController->SetRenderBufferInfo(
        &m_guidDSoundDev,
        &BufferDescription,
        hFocusWnd,
        DSSCL_PRIORITY
        );

    return hr ;
}


//-----------------------------------------------------------------------------
// RecreateDSoundBuffers
//
// Used to perform dynamic changes. The steps we take here are:
//
// a) Reset the current primary buffer format to the new.
// b) Prepare a new secondary buffer with the new format.
// c) Lock the DSBPosition critical section and reset our circular buffer
//    sizes and other buffer data.
// d) If we were previously playing:
//          1) Flush the current buffers
//          2) Add the current byte offset to any previous value.
//          3) Start playing the new secondary buffer.
//          4) Stop playing the old secondary buffer.
// e) Set our current secondary buffer to the new one.
// f) Unlock the critical section.
// g) Release the old buffer.
//
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::RecreateDSoundBuffers(double dRate)
{
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Entering CDSoundDevice::RecreateDSoundBuffers")));

    HRESULT hr = S_OK;

    WAVEFORMATEX *pwfx = m_pWaveOutFilter->WaveFormat();

    // already made
    if (!m_lpDSBPrimary)
    {
        DbgLog((LOG_TRACE,4,TEXT("RecreateDSoundBuffers: No primary buffer was created")));
        return NOERROR;
    }

    // can't do this until somebody calls CreateDSound
    if (m_lpDS == NULL)
    {
        DbgLog((LOG_TRACE,4,TEXT("RecreateDSoundBuffers: m_lpDS was NULL")));
        return E_FAIL;
    }

    // Reset the primary format
    hr = SetPrimaryFormat( pwfx, TRUE ); // and do a retry with a smart rate if it fails
    if (DS_OK != hr)
    {
        CleanUp();
        return hr;
    }

    ASSERT (m_lpDSB);
    if( !m_lpDSB )
        return E_FAIL;

    DSBUFFERDESC dsbd;
    memset( &dsbd, 0, sizeof(dsbd) );
    dsbd.dwSize        = sizeof(dsbd);
    dsbd.dwFlags       = GetCreateFlagsSecondary( pwfx );
    dsbd.dwBufferBytes = BufferSize(pwfx, m_bIsTSAudio); // one second buffer size
    dsbd.lpwfxFormat   = pwfx;                           // format information

    DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" DSB Size = %u" ), BufferSize(pwfx, m_bIsTSAudio)));

    // Dump the contents of the WAVEFORMATEX type-specific format structure
    DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" Creating Secondary buffer for the following format ..." )));
#ifdef DEBUG
    DbgLogWaveFormat( TRACE_FORMAT_INFO, pwfx );
#endif

    // create a new secondary buffer
    LPDIRECTSOUNDBUFFER lpDSB2 = NULL;

    hr = m_lpDS->CreateSoundBuffer( &dsbd, &lpDSB2, NULL );
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: Secondary buffer can't be created: %u"), hr &0x0ffff));
        CleanUp () ;
        return MMSYSERR_ALLOCATED ;
    }

    hr = SetRate((dRate == -1.0 ? m_dRate : dRate), pwfx->nSamplesPerSec, lpDSB2);
    if(hr != DS_OK)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: SetFrequency failed: %u"), hr &0x0ffff));
        if (lpDSB2) // do tidier cleanup of new buffer!!
            lpDSB2->Release();
        CleanUp();
        return hr;
    }
    // set the current position to be at 0
    hr = lpDSB2->SetCurrentPosition( 0) ; // we should be more careful here
    if (hr != DS_OK)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: error in lpDSB->SetCurrentPosition! hr = %u"), hr & 0x0ffff));
        if (lpDSB2) // again do tidier cleanup of new buffer
            lpDSB2->Release();
        CleanUp () ;
        return MMSYSERR_ALLOCATED ;
    }

    LPDIRECTSOUNDBUFFER lpPrevDSB = m_lpDSB; // prepare to switch buffers
    {
        CAutoLock lock(&m_cDSBPosition);

        hr = SetBufferVolume( lpDSB2, pwfx );
        if( NOERROR != hr )
        {
            return hr;
        }
        
        // The secondary buffer was created using the pwfx, since that hasn't
        // changed since we were connected

        DWORD dwPrevBufferSize = m_dwBufferSize;

        // Update our buffer information for the new format
        m_dwBufferSize    = BufferSize(pwfx, m_bIsTSAudio);

        m_dwMinOptSampleSize = m_dwBufferSize / OPTIMIZATION_FREQ_LIMIT; //byte size
        DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOpen - m_dwMinOptSampleSize = %u"), m_dwMinOptSampleSize));

        m_dwEmulationLatencyPad = m_dwBufferSize / EMULATION_LATENCY_DIVISOR;


#ifdef ENABLE_10X_FIX
        Reset10x();
#endif 

        m_dwRipeListPosition = 0;
        //m_llSilencePlayed = 0; // reset rather than adjust
        m_dwBitsPerSample = (DWORD)pwfx->wBitsPerSample;
        m_nAvgBytesPerSec = pwfx->nAvgBytesPerSec;

#ifdef DEBUG
        m_cbStreamDataPass = 0 ;    // number of times thru StreamData
        m_NumSamples = 0 ;          // number of samples received
        m_NumCallBacks = 0 ;        // number of call back's done.
        m_NumCopied = 0 ;           // number of samples copied to DSB memory
        m_NumBreaksPlayed = 0 ;     // number of audio breaks played
        //m_dwTotalWritten = 0 ;      // Total number of data bytes written
#endif
        m_NumAudBreaks = 0 ;        // number of audio breaks logged

        if (m_bDSBPlayStarted)
        {
            // Since we reset our position buffers save the current byte position
            // and add this to our position reporting.
            // Note that we make the NextWrite position our new current position
            // since this should be contiguous with the next sample data we receive.
            ASSERT (dwPrevBufferSize);

            m_llAdjBytesPrevPlayed = llMulDiv (m_tupNextWrite.LinearLength() -
                                                   m_llSilencePlayed +
                                                   m_llAdjBytesPrevPlayed,
                                               m_dwBufferSize,
                                               dwPrevBufferSize,
                                               0);

            m_llSilencePlayed = llMulDiv (m_llSilencePlayed,
                                          m_dwBufferSize,
                                          dwPrevBufferSize,
                                          0);

            // amsndOutReset will reinitialize the tuples
            // to 0 offset and new buffer size
            amsndOutReset ();

            // start playing new secondary buffer
            hr = lpDSB2->Play( 0, 0, DSBPLAY_LOOPING );
            if( DS_OK == hr )
            {
                m_WaveState = WAVE_PLAYING ;    // state is now playing.
            }
            else
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_lpDSB->Play failed!(0x%08lx)"), hr ));

                //
                // if play failed we should signal abort
                // should we only do this if the error isn't BUFFERLOST, since that can
                // happen when coming out of hibernation?
                // at this point our main goal here is to be sure we abort in response to a NODRIVER error
                //
                m_hrLastDSoundError = hr;
                if( DSERR_BUFFERLOST != hr )
                {
                    m_pWaveOutFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
                }
            }

            // stop the currently playing secondary buffer
            hr = m_lpDSB->Stop();
            if (DS_OK != hr)
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_lpDSB->Stop failed!")));
            }
        }
        else
        {
            m_tupPlay.Init (0, 0, m_dwBufferSize) ;
            m_tupWrite.Init (0, 0, m_dwBufferSize) ;
            m_tupNextWrite.Init (0, 0, m_dwBufferSize) ;
        }
        m_lpDSB = lpDSB2;               // make the new buffer the current one
    }
    lpPrevDSB->Release();

    // if it fails, we won't use it
    if (m_pWaveOutFilter->m_fWant3D) {
        hr = m_lpDSB->QueryInterface(IID_IDirectSound3DBuffer,
							(void **)&m_lp3dB);
        if (hr == DS_OK)
    	    DbgLog((LOG_TRACE,3,TEXT("*** got 3DBUFFER interface")));
        else
    	    DbgLog((LOG_TRACE,3,TEXT("*** ERROR: no 3DBUFFER interface")));
    }

    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Exiting CDSoundDevice::RecreateDSoundBuffers")));
    return NOERROR;
}

//-----------------------------------------------------------------------------
// SetPrimaryFormat
//
// Used to call SetFormat on the primary buffer. If bRetryOnFailure is TRUE an
// additional SetFormat call will be tried made if the first fails, using a
// sample rate more likely to succeed and as close as we can get to the stream's
// native format (to reduce resampling artifacts).
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::SetPrimaryFormat ( LPWAVEFORMATEX pwfx, BOOL bRetryOnFailure )
{
    HRESULT hr;

    ASSERT (m_lpDSBPrimary);
    ASSERT (pwfx);

    if (!m_lpDSBPrimary || !pwfx )
        return E_FAIL;

    DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" Primary format being set to the following format ..." )));
#ifdef DEBUG
    DbgLogWaveFormat( TRACE_FORMAT_INFO, pwfx );
#endif

    // We need a stereo primary for 3D to work
    if (m_pWaveOutFilter->m_fWant3D && pwfx->wFormatTag == WAVE_FORMAT_PCM &&
                                                pwfx->nChannels == 1) {
        WAVEFORMATEX wfx = *pwfx;       // !!! only works for PCM!
        wfx.nChannels = 2;
        wfx.nAvgBytesPerSec *= 2;
        wfx.nBlockAlign *= 2;
        hr = m_lpDSBPrimary->SetFormat(&wfx);
        DbgLog((LOG_TRACE,3,TEXT("*** Making stereo primary for 3D")));
        if (hr != DS_OK) {
            DbgLog((LOG_ERROR,1,TEXT("*** ERROR! no stereo primary for 3D")));
            hr = m_lpDSBPrimary->SetFormat(pwfx);
        }
    } else {
        hr = m_lpDSBPrimary->SetFormat(pwfx);
    }

    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: SetFormat failed: %u"), hr &0x0ffff));

        if (bRetryOnFailure)
        {
            // try once more to set the primary buffer to a frequency likely to be
            // supported and as close as we can get to this stream's frequency rate,
            // in attempt to lessen sloppy resampling artifacts, otherwise it'll
            // just get set to DSound's 22k, 8 bit, mono default.
            LPWAVEFORMATEX pwfx2 = (LPWAVEFORMATEX) CoTaskMemAlloc(sizeof(WAVEFORMATEX));
            if (pwfx2 && pwfx->nSamplesPerSec > 11025)
            {
                memcpy( pwfx2, pwfx, sizeof (WAVEFORMATEX) );

                if ( (pwfx->nSamplesPerSec % 11025) || (pwfx->nSamplesPerSec > 44100) )
                {
                    DWORD nNewFreq = min( ((pwfx->nSamplesPerSec / 11025) * 11025), 44100 ) ; // round to multiple of 11025

                    DbgLog((LOG_TRACE, 1, TEXT("CreateDSoundBuffers: SetFormat failed, but trying once more with frequency: %u"), nNewFreq));

                    pwfx2->nSamplesPerSec = nNewFreq;
                    pwfx2->nAvgBytesPerSec = pwfx2->nSamplesPerSec *
                                                 pwfx2->nChannels *
                                                 pwfx2->wBitsPerSample/8 ;
                    hr = m_lpDSBPrimary->SetFormat( pwfx2 );
                    if( hr != DS_OK )
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("CreateDSoundBuffers: 2nd SetFormat attempt failed: %u"), hr &0x0ffff));
                    }
                    else
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("CreateDSoundBuffers: 2nd SetFormat attempt succeeded (freq=%d)"), pwfx2->nSamplesPerSec));
                    }
                }
            }
            CoTaskMemFree(pwfx2);
        }
    }
    return hr;
}


//-----------------------------------------------------------------------------
// amsndOutOpen
//
// Once again, based on how the Quartz wave renderer works today, this code
// currently supports only two possible uses:
//
// a) when fdwOpen is CALLBACK_FUNCTION we actually create DSound buffers and
//    objects and get the secoundary buffer going.
//
// b) when fdwOpen is WAVE_FORMAT_QUERY we create temporary DSound objects to
//    figure out if the waveformat passed in is accepted or not.
//
// When the device is actually opened, we actually start the primary buffer
// playing. It will actually play silence. Doing this makes it really cheap
// to stop/play the secondary buffer.
//-----------------------------------------------------------------------------

MMRESULT CDSoundDevice::amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
              double dRate, DWORD *pnAvgBytesPerSec, DWORD_PTR dwCallBack,
              DWORD_PTR dwCallBackInstance, DWORD fdwOpen)
{

    if( WAVE_FORMAT_EXTENSIBLE == pwfx->wFormatTag )
    {
        if( ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  != MEDIASUBTYPE_PCM &&
            ((PWAVEFORMATIEEEFLOATEX)pwfx)->SubFormat != MEDIASUBTYPE_IEEE_FLOAT &&
            ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  != MEDIASUBTYPE_DOLBY_AC3_SPDIF &&
            ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  != MEDIASUBTYPE_RAW_SPORT &&
            ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  != MEDIASUBTYPE_SPDIF_TAG_241h )
        {
            // only allow uncompressed and float extensible formats. oh, and ac3 over s/pdif
            return WAVERR_BADFORMAT;
        }
    }
    else if( WAVE_FORMAT_PCM != pwfx->wFormatTag &&
#ifdef WAVE_FORMAT_DRM
             WAVE_FORMAT_DRM != pwfx->wFormatTag &&
#endif
             WAVE_FORMAT_IEEE_FLOAT != pwfx->wFormatTag &&
             //
             // from the Non-pcm audio white paper:
             // "Wave format tags 0x0092, 0x0240 and 0x0241 are identically defined as 
             // AC3-over-S/PDIF (these tags are treated completely identically by many 
             // DVD applications)."
             //
             WAVE_FORMAT_DOLBY_AC3_SPDIF != pwfx->wFormatTag &&
             WAVE_FORMAT_RAW_SPORT != pwfx->wFormatTag &&
             0x241 != pwfx->wFormatTag ) 
    {
        return WAVERR_BADFORMAT;
    }

    // report adjusted nAvgBytesPerSec
    if(pnAvgBytesPerSec) {

        *pnAvgBytesPerSec = (dRate != 0.0 && dRate != 1.0) ?
            (DWORD)(pwfx->nAvgBytesPerSec * dRate) :
            pwfx->nAvgBytesPerSec;
    }

    //  Reset sample stuffing info
    m_rtLastSampleEnd = 0;
    m_dwSilenceWrittenSinceLastWrite = 0;

    HRESULT hr = S_OK;

    // separate out the two uses of fdwOpen flags.
    if (fdwOpen & WAVE_FORMAT_QUERY)
    {   
        if( m_pWaveOutFilter->m_pAudioDuplexController )
            return S_OK;
            
        hr = CreateDSound(TRUE);    // create the DSOUND object for query only
        if (hr != NOERROR)
            return hr;

        // Are we in emulation mode ? For now just log this information.

        //DSCAPS  dsCaps ;
        //memset( &dsCaps, 0, sizeof(DSCAPS) );
        //dsCaps.dwSize = sizeof(DSCAPS);

        //hr = m_lpDS->GetCaps ( &dsCaps) ;
        //if( hr != DS_OK )
        //{
        //   DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("*** waveOutOpen : DSound fails to return caps, %u"), hr & 0x0ffff));
        //}
        //if (dsCaps.dwFlags & DSCAPS_EMULDRIVER)
        //{
        //    m_fEmulationMode = TRUE;
        //    DbgLog((LOG_TRACE,TRACE_SYSTEM_INFO,TEXT("*** waveOutOpen : DSound in emulation mode.")));
        //}

        // Dump the contents of the WAVEFORMATEX type-specific format structure
        DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" Quering for the following format ..." )));
#ifdef DEBUG
        DbgLogWaveFormat( TRACE_FORMAT_INFO, pwfx );
#endif

        // now call DSOUND to see if it will accept the format
        {
            HRESULT             hr;
            DSBUFFERDESC        dsbd;
            LPDIRECTSOUNDBUFFER lpDSB = NULL;

            // first check to see if we can create a primary with this format, if we fail, we will rely on acmwrapper do to format conversions
            memset( &dsbd, 0, sizeof(dsbd) );
            dsbd.dwSize  = sizeof(dsbd);

            if( IsNativelySupported( pwfx ) )
            {     
                // explicity check that we can create a buffer for these formats
             
                dsbd.dwFlags = DSBCAPS_PRIMARYBUFFER;
                hr = m_lpDS->CreateSoundBuffer( &dsbd, &lpDSB, NULL );
                if(FAILED(hr))
                {
                    DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("*** amsndOutOpen : CreateSoundBuffer failed on primary buffer creation, %u"), hr & 0x0ffff));
                    return MMSYSERR_ALLOCATED;
                }
            }
            //
            // Since calling DSound's SetFormat (and also SetCooperativeLevel)
            // causes an audible break (pop) in any other audio currently playing
            // through DSound at a different format, we'll refrain from doing this
            // on the graph building. We still make the SetFormat call on the
            // actual open, but there the effects are much less noticeable. DSound
            // should still do the right thing if the SetFormat fails.
            //
            //    hr = lpDSB->SetFormat( pwfx );
            //    if(FAILED(hr))
            //    {
            //        DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("*** amsndOutOpen : CreateSoundBuffer failed on primary buffer set format, %u"), hr & 0x0ffff));
            //        lpDSB->Release();
            //        return WAVERR_BADFORMAT ;
            //    }
            if( lpDSB )
            {            
                lpDSB->Release();
            }
                
            // now check to see if we can create a secondary with this format
            memset( &dsbd, 0, sizeof(dsbd) );
            dsbd.dwSize        = sizeof(dsbd);
            dsbd.dwFlags       = GetCreateFlagsSecondary( pwfx );
            dsbd.dwBufferBytes = BufferSize(pwfx, m_bIsTSAudio); // one second buffer size
            dsbd.lpwfxFormat   = pwfx;                           // format information

            hr = m_lpDS->CreateSoundBuffer( &dsbd, &lpDSB, NULL );

            if( hr != DS_OK )
            {
                DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("*** amsndOutOpen : CreateSoundBuffer failed on secondary buffer creation, %u"), hr & 0x0ffff));
                return WAVERR_BADFORMAT ;
            }

            hr = SetRate(dRate, pwfx->nSamplesPerSec);  // check to see if we support this rate
            lpDSB->Release();

            if(hr != DS_OK)
            {
                DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutOpen: SetFrequency failed: %u"), hr &0x0ffff));
                return WAVERR_BADFORMAT;
            }
            return MMSYSERR_NOERROR ;
        }
    }
    else if (fdwOpen == CALLBACK_FUNCTION)
    {
        hr = CreateDSound();    // create the DSOUND object
        if (hr != NOERROR)
            return hr;

        // if we are already open, return error
        ASSERT (m_WaveState == WAVE_CLOSED) ;
        if (m_WaveState != WAVE_CLOSED)
        {
            return MMSYSERR_ALLOCATED ;
        }

        // we may have already created this by QI for the buffers
#if 0
        if( m_lpDSB )
        {
            // !!! Should this fail or should this succeed ?
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutOpen called when already open")));
            return MMSYSERR_ALLOCATED ;
        }
#endif

        hr = CreateDSoundBuffers(dRate);
        if (hr != NOERROR)
            return hr;
        
        hr = SetBufferVolume( m_lpDSB, pwfx );
        if( NOERROR != hr )
        {
            CleanUp ();
            return hr;
        }
        
        // The secondary buffer was created using the pwfx, since that hasn't
        // changed since we were connected

        m_dwBufferSize    = BufferSize(pwfx, m_bIsTSAudio);

        m_dwMinOptSampleSize = m_dwBufferSize / OPTIMIZATION_FREQ_LIMIT; //byte size
        DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOpen - m_dwMinOptSampleSize = %u"), m_dwMinOptSampleSize));

        //if (m_fEmulationMode)
            m_dwEmulationLatencyPad = m_dwBufferSize / EMULATION_LATENCY_DIVISOR;

#define FRACTIONAL_BUFFER_SIZE  4 // performance tuning parameter
        // a measure of how empty our buffer must be before we attempt to copy anything to it
        //m_dwFillThreshold = DWORD(m_dwBufferSize / FRACTIONAL_BUFFER_SIZE);
        m_tupPlay.Init (0,0,m_dwBufferSize) ;
        m_tupWrite.Init (0,0,m_dwBufferSize) ;
        m_tupNextWrite.Init (0,0,m_dwBufferSize) ;

#ifdef ENABLE_10X_FIX
        Reset10x();
#endif

        m_dwRipeListPosition = 0;
        m_llSilencePlayed = 0;
        m_dwBitsPerSample = (DWORD)pwfx->wBitsPerSample;
        m_nAvgBytesPerSec = pwfx->nAvgBytesPerSec;
        m_bDSBPlayStarted   = FALSE ;

#ifdef DEBUG
        m_cbStreamDataPass = 0 ;    // number of times thru StreamData
        m_NumSamples = 0 ;          // number of samples received
        m_NumCallBacks = 0 ;        // number of call back's done.
        m_NumCopied = 0 ;           // number of samples copied to DSB memory
        m_NumBreaksPlayed = 0 ;     // number of audio breaks played
        m_dwTotalWritten = 0 ;      // Total number of data bytes written
#endif
        m_NumAudBreaks = 0 ;        // number of audio breaks logged

        // never used, and blows up when no clock
#if 0
        IReferenceClock * pClock;
        hr = m_pWaveOutFilter->GetSyncSource(&pClock);
        ASSERT(pClock);
        LONGLONG rtNow;
        pClock->GetTime(&rtNow);
        pClock->Release() ;
#endif

        hr = StartCallingCallback();
        if (hr != NOERROR) {
            CleanUp () ;
            return hr;
        }

        // now set the Primary buffer into play. This will play silence unless
        // the secondary buffer is set playing. However, this will also make
        // play and stop of the secondary buffers really cheap.

        if( !m_pWaveOutFilter->m_pAudioDuplexController )
        {
            DbgLog((LOG_TRACE, TRACE_STATE_INFO, TEXT("PLAYING the PRIMARY buffer")));
            hr = m_lpDSBPrimary->Play( 0, 0, DSBPLAY_LOOPING );
            if( hr != DS_OK )
            {
                m_hrLastDSoundError = hr;
                DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("error in lpDSBPrimary->Play! hr = %u"), hr & 0x0ffff));
                StopCallingCallback();
                CleanUp () ;
                return MMSYSERR_ALLOCATED ;
            }
        }
        
        m_WaveState = WAVE_PAUSED ;
        *phwo = OUR_HANDLE ;
        m_pWaveOutProc = (PWAVEOUTCALLBACK) dwCallBack ;
        m_dwCallBackInstance = dwCallBackInstance ;


        // make the WOM_OPEN call back now.
        // !!! is it legit to call back right away ?
        if (m_pWaveOutProc)
            (* m_pWaveOutProc) (OUR_HANDLE, WOM_OPEN, m_dwCallBackInstance,
                        0, 0) ;

        return MMSYSERR_NOERROR ;
    }
    else
    {
        // some other form of call that is not supported yet.
        DbgBreak ("CDSoundDevice: Unsupported Open call.") ;
        DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("amsndOutOpen: unsupported call = %u"), fdwOpen));
        return MMSYSERR_ALLOCATED ;
    }
}


//-----------------------------------------------------------------------------
// amsndOutPause
//
// This simply stops the secondary buffer.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutPause ()
{
#ifdef ENABLE_10X_FIX
    if(m_fRestartOnPause
#ifdef BUFFERLOST_FIX
        // Note: only do this if we've got a valid dsound buffer! Also
        // note this can block for 1 second
        && RestoreBufferIfLost(TRUE)
#endif
    )
    {
        FlushSamples();  // flush everything

        // shock the dsound driver, by shutting it down.....
        CleanUp();
        
        // and then reinitializing it
         
        CreateDSound();
        CreateDSoundBuffers();
        
        if( m_lpDSB )
        {
            // since on a restart we don't check that the CreateDSoundBuffers succeeded,
            // we need to verify we have one before calling SetBufferVolume()!!
            HRESULT hrTmp = SetBufferVolume( m_lpDSB, m_pWaveOutFilter->WaveFormat() ); // ignore any error since we never even set volume here previously
            if( NOERROR != hrTmp )
            {
                DbgLog((LOG_TRACE,2,TEXT("CDSoundDevice::SetBufferVolume failed on buffer restart!( 0x%08lx )"), hrTmp ));
            }        
        }            
    }
#endif

#ifdef ENABLE_10X_FIX
    // always reset 10x counter on a pause, since we could artificially accumulate stalls doing 
    // quick play->pause->play transitions, if device takes too long to get moving
    Reset10x();
#endif

    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("amsndOutPause called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    if (m_WaveState == WAVE_PAUSED)
    {
        DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("amsndOutPause called when already paused")));
        return MMSYSERR_NOERROR ;
    }

    // stop the play of the secondary buffer.
    HRESULT hr = m_lpDSB->Stop();

#ifdef BUFFERLOST_FIX
    if( hr != DS_OK && hr != DSERR_BUFFERLOST)
#else
    if( hr != DS_OK )
#endif
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutPause: Stop of lpDSB failed: %u"), hr & 0x0ffff));
        return MMSYSERR_NOTSUPPORTED ;
    }

    m_bDSBPlayStarted = FALSE ;

    // reset last sample end time on a pause, since on a restart 
    // Run already blocks until its time to start
    // (Actually it only blocks if there's no data queued)
    m_rtLastSampleEnd = 0;

    m_WaveState = WAVE_PAUSED ;         // state is now paused.

    return MMSYSERR_NOERROR ;
}
//-----------------------------------------------------------------------------
// amsndOutPrepareHeader
//
// This funtion really does nothing. Most of the action is initiated in
// amsndOutWrite. For consistency sake we will do handle validation.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("amPrepareHeader called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    return MMSYSERR_NOERROR ;
}

//-----------------------------------------------------------------------------
// amsndOutReset
//
// calls pause to stop the secondary buffer and sets the current position to 0
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutReset ()
{
    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutReset called")));

    m_rtLastSampleEnd = 0;

    // If we get flushed while we're running stream time does not get
    // reset to 0 so we have to track from NOW - ie where we flushed to
    // Flushing while running is very unusual generally but DVD does it
    // all the time
    if (m_WaveState == WAVE_PLAYING) {
        CRefTime rt;
        m_pWaveOutFilter->StreamTime(rt);
        m_rtLastSampleEnd = rt;
    }
    // Flush all the queued up samples.
    FlushSamples () ;

    if (NULL != m_lpDSB) {
        // set the current position to be at 0
        HRESULT hr = m_lpDSB->SetCurrentPosition( 0) ;
        if (hr != DS_OK)
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutReset: error in lpDSB->SetCurrentPosition! hr = %u"), hr & 0x0ffff));
            return MMSYSERR_ALLOCATED ;
        }
    }

    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutReset done")));

    return MMSYSERR_NOERROR ;
}

//-----------------------------------------------------------------------------
// waveOutBreak
//
// The waveout from end code calls this function when there is an audio break.
// For the waveout rendere, this function calls waveOutReset. However, in the
// Dsound case, just calling xxxReset is not enough. We also call xxxRestart
// so that a subsequent xxxoutWrite will know to start the play of the sound
// buffer.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutBreak ()
{
    amsndOutReset () ;
    return amsndOutRestart () ;
}

//-----------------------------------------------------------------------------
// amsndOutRestart
//
// Sets the state of the background thread to Stream_Playing. The StreamData
// funtion will actually 'Play' the secondary buffer after it has ensured
// that there is some data in the buffer.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutRestart ()
{
    HWND hwndFocus;

    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutRestart called")));

    HRESULT hr ;
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("amOutRestart called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    // we automatically figure out what window to use as the focus window
    // until the app tells us which one to use, then we always use that
    if (!m_fAppSetFocusWindow) {
        hwndFocus = GetForegroundWindow();
        if (hwndFocus) {
            SetFocusWindow(hwndFocus);
            m_fAppSetFocusWindow = FALSE;   // will have been set above
            // but we aren't the app
        }
    }

    m_WaveState = WAVE_PLAYING ;         // state is now paused.

    // if there is data in the buffer then start the secondary buffer playing
    // and transition to the next state. Else continue in this state.

    ASSERT (!m_bDSBPlayStarted) ;

    if (m_tupNextWrite > m_tupPlay)
    {
        DbgLog((LOG_TRACE, TRACE_STATE_INFO, TEXT("StreamHandler: Stream_Starting->Stream_Playing")));

        // DWORD dwTime = timeGetTime () ;
        // DbgLog((LOG_TRACE, TRACE_CALL_TIMING, TEXT("DSound Play being called at: %u"), dwTime));


        // pre-emptive attempt to restore buffer. buffer loss seen
        // here occasionally in WinME hibernation/standby (but not
        // NT/win98se). note this can take upto 1 second.
        if(RestoreBufferIfLost(TRUE))
        {
            hr = m_lpDSB-> Play( 0, 0, DSBPLAY_LOOPING );
        }
        else
        {
            hr = DSERR_BUFFERLOST;
        }

        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("error in lpDSB->Play! hr = %u"), hr & 0x0ffff ));

            m_hrLastDSoundError = hr;
            if( DSERR_BUFFERLOST != hr )
            {
                //
                // if play failed we should signal abort
                // should we only do this if the error isn't BUFFERLOST, since that can
                // happen when coming out of hibernation?
                //
                m_pWaveOutFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
            }

#ifdef ENABLE_10X_FIX
            m_WaveState = WAVE_CLOSED;
            return E_FAIL;
#endif
        }
        m_bDSBPlayStarted = TRUE ;

    }
    else
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("waveOutRestart called yet no data")));
    }

    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutRestart done")));

    return MMSYSERR_NOERROR ;
}
//-----------------------------------------------------------------------------
// amsndOutSetBalance
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::amsndOutSetBalance (LONG lBalance)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("amSetBalance called when lpDSB is NULL")));
        m_lBalance = lBalance;

        return MMSYSERR_NOERROR ;
    }

    HRESULT hr = m_lpDSB->SetPan (lBalance) ;
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("amsndOutSetBalance: SetPan failed %u"), hr & 0x0ffff));
    }
    else
    {
        m_lBalance = lBalance;
    }
#ifdef DEBUG
    {
        LONG lBalance1 ;
        HRESULT hr = m_lpDSB->GetPan (&lBalance1) ;
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("waveOutGetBalance: GetPan failed %u"), hr & 0x0ffff));
        }
        DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("waveOutSetBalance log: desired = %d, actual = %d"),
            lBalance, lBalance1));
    }
#endif


    return hr ;
}
//-----------------------------------------------------------------------------
// amsndOutSetVolume
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::amsndOutSetVolume (LONG lVolume)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MINOR_ERROR,TEXT("amSetVolume called when lpDSB is NULL")));
        m_lVolume = lVolume;

        return MMSYSERR_NOERROR;
    }

    HRESULT hr = m_lpDSB->SetVolume (lVolume) ;
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("amsndOutSetVolume: SetVolume failed %u"), hr & 0x0ffff));
    }
    else
    {
        m_lVolume = lVolume;
    }
    return hr ;
}
//-----------------------------------------------------------------------------
// amsndOutUnprepareHeader
//
// This funtion really does nothing. Most of the action is initiated in
// amsndOutWrite. For consistency sake we will do handle validation.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MINOR_ERROR,TEXT("amsndOutUnprepareHeader called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    return MMSYSERR_NOERROR ;
}

//-----------------------------------------------------------------------------
// amsndOutWrite
//
// Queues up the data and lets the background thread write it out to the
// sound buffer.
//
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, const REFERENCE_TIME *pTimeStamp, BOOL bIsDiscontinuity)
{
    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutWrite called")));

    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MINOR_ERROR,TEXT("amsndOutWrite called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    {
#ifdef DEBUG
        m_NumSamples ++ ;
        DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOutWrite: Sample # %u"), m_NumSamples));
#endif
        CRipe     *pRipe;
        CAutoLock lock(&m_cRipeListLock);        // lock the list

        pRipe = new CRipe(NAME("CDSoundDevice ripe buffer"));
        if( !pRipe )
        {
            DbgLog((LOG_ERROR,MINOR_ERROR, TEXT("amsndOutWrite: new CRipe failed!")));
            return MMSYSERR_NOMEM ;
        }
        pRipe->dwLength = pwh->dwBufferLength ;

        pRipe->dwBytesToStuff = 0;
        
        // Keep track of timestamp gaps in case we need to stuff silence.
        // But don't stuff silence for 'live' or compressed data.
        if( pTimeStamp &&
            0 == ( AM_AUDREND_SLAVEMODE_LIVE_DATA & m_pWaveOutFilter->m_pInputPin->m_Slave.m_fdwSlaveMode ) &&
            CanWriteSilence( (PWAVEFORMATEX) m_pWaveOutFilter->WaveFormat() ) )
        {
            //  Don't stuff for the first timestamp after 'run' because
            //  we already block until it's time to play
            if( 0 != m_rtLastSampleEnd )
            {
                //  See if this is a discontinuity and there's a gap > 20ms
                //  Also, don't stuff if we just chose to drop late audio.
                if( bIsDiscontinuity && 
                    !m_pWaveOutFilter->m_pInputPin->m_bTrimmedLateAudio &&
                    ( *pTimeStamp - m_rtLastSampleEnd > 20 * (UNITS / MILLISECONDS) ) )
                {
                    pRipe->dwBytesToStuff = (DWORD)llMulDiv(
                                                   AdjustedBytesPerSec(),
                                                   *pTimeStamp - m_rtLastSampleEnd,
                                                   UNITS,
                                                   0);
                                           
                    //  Round down to nearest nBlockAlignment
                    WAVEFORMATEX *pwfx = m_pWaveOutFilter->WaveFormat();
                    pRipe->dwBytesToStuff -= pRipe->dwBytesToStuff % pwfx->nBlockAlign;
                
                    DbgLog((LOG_TRACE, 2, TEXT("Discontinuity of %dms detected - adding %d to stuff(%d per sec)"),
                           (LONG)((*pTimeStamp - m_rtLastSampleEnd) / 10000),
                           pRipe->dwBytesToStuff, AdjustedBytesPerSec()));
                
                    //  Adjust for stuffing already written
                    CAutoLock lck(&m_cDSBPosition);
                    if (m_dwSilenceWrittenSinceLastWrite >= pRipe->dwBytesToStuff) {
                        pRipe->dwBytesToStuff = 0;
                    } else {
                        pRipe->dwBytesToStuff -= m_dwSilenceWrittenSinceLastWrite;
                    }
                    m_dwSilenceWrittenSinceLastWrite = 0;

                    //  Adjust so that it looks like this time is
                    //  included in our current position for the timestamp
                    //  of this buffer
                    DbgLog((LOG_TRACE, 8, TEXT("Stuffing silence - m_llSilencePlayed was %d"),
                            (DWORD) m_llSilencePlayed));
                    m_llSilencePlayed += pRipe->dwBytesToStuff;
                    DbgLog((LOG_TRACE, 8, TEXT("Stuffing silence - m_llSilencePlayed is now %d"),
                            (DWORD) m_llSilencePlayed));
                }
            }
            
            // now update the last sample end time that we use to keep track of gaps.
            // We update this on discontinuities and if this is the first sample since we were run.
            if( bIsDiscontinuity || 0 == m_rtLastSampleEnd )
            {
                m_rtLastSampleEnd = *pTimeStamp;        
            }
        }
        
        //  Work out the end time of this sample - note we accumulate
        //  errors a little here which we could avoid
        m_rtLastSampleEnd += MulDiv(pRipe->dwLength, UNITS, AdjustedBytesPerSec());
        DbgLog((LOG_TRACE, 8, TEXT("amsndOutWrite - m_rtLastSampleEnd(adjusted) = %dms"),
                        (LONG) (m_rtLastSampleEnd / 10000 )));
        pRipe->lpBuffer = (LPBYTE) pwh->lpData ;
        pRipe->dwSample = (m_pWaveOutFilter->m_fUsingWaveHdr) ?
               (DWORD_PTR)pwh :  // a wavehdr has been allocated on our allocator, so cache it
               pwh->dwUser;  // no wavehdr has been allocated on our allocator, so cache the supplied CSample*
        // add in length to m_dwRipeListPosition to calculate where in the
        // stream (in bytes) this sample end

        // if this buffer is discontiguous from the last m_dwSilenceNeeded
        // will be non-0 and the value in time UNITS of how much silence to
        // be played.


        m_dwRipeListPosition += pwh->dwBufferLength ;
        pRipe->dwPosition = m_dwRipeListPosition ;    // end of the sample in bytes
        DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOutWrite: Sample = %u, Position = %u"), pwh, pRipe->dwPosition));
        pRipe->bCopied = FALSE ;                    // data has not been copied

#ifdef DXMPERF
		pRipe->bFresh  = TRUE;
		pRipe->rtStart = m_pWaveOutFilter->m_llLastPos;
#endif // DXMPERF

        m_ListRipe.AddTail( pRipe );             // Add to ripe list
    }

    // call StreamData to write out data to the circular buffer. This will
    // make sure that we will have data when we get to starting the play
    // on the sound buffer.
    //
    //
    // But first check the duration of audio data in this sample, and if it's
    // especially small ( <= ~50ms) then we'll need to use latency pad
    // in optimization code.
    //
    if (pwh->dwBufferLength > m_dwMinOptSampleSize)
    {
        StreamData ( TRUE ) ;    // will force data to get into the buffer
    }
    else
    {
        // use latency padding in the short buffer duration case
        StreamData ( TRUE, TRUE );
    }

    // It is possible that amsndoutRestart was called before amsndOutWrite
    // is called. In this case, we need to start play on the dsound buffer here.
    // However, it is also possible to get NULL buffers delivered so we may
    // have to wait till another amsndoutWrite.

    if (!m_bDSBPlayStarted && (m_WaveState == WAVE_PLAYING))
    {
        if (m_tupNextWrite > m_tupPlay)
        {
            DbgLog((LOG_TRACE, TRACE_STATE_INFO, TEXT("Starting play from amsndOutWrite")));

            // DWORD dwTime = timeGetTime () ;
            // DbgLog((LOG_TRACE, TRACE_CALL_TIMING, TEXT("DSound Play being called at: %u"), dwTime));


            HRESULT hr = m_lpDSB->Play( 0, 0, DSBPLAY_LOOPING );
            if( hr == DS_OK )
            {
                m_bDSBPlayStarted = TRUE ;
            }
            else
            {
                DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("error in lpDSB->Play! from amsndOutWrite. hr = %u"), hr & 0x0ffff));

                //
                // if play failed we should signal abort
                // should we only do this if the error isn't BUFFER_LOST, since that can
                // happen when coming out of hibernation?
                //
                m_hrLastDSoundError = hr;
                if( DSERR_BUFFERLOST != hr )
                {
                    m_pWaveOutFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
                }
                // we are ignoring the propagation back of the error
            }

        }
    }

    return NOERROR;
    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutWrite done")));

}

HRESULT CDSoundDevice::amsndOutLoad(IPropertyBag *pPropBag)
{
    // caller makes sure we're not running

    if(m_lpDS)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    DbgLog((LOG_TRACE, 2, TEXT("DSR::Load enter")));

    VARIANT var;
    var.vt = VT_BSTR;
    HRESULT hr = pPropBag->Read(L"DSGuid", &var, 0);
    if(SUCCEEDED(hr))
    {
        CLSID clsidDsDev;
        hr = CLSIDFromString(var.bstrVal, &clsidDsDev);
        if(SUCCEEDED(hr))
        {
            m_guidDSoundDev = clsidDsDev;
        }

        SysFreeString(var.bstrVal);
    } else {
        hr = S_OK;
        m_guidDSoundDev = GUID_NULL;
    }

    DbgLog((LOG_TRACE, 2, TEXT("DSR::Load exit")));
    return hr;
}

HRESULT  CDSoundDevice::amsndOutWriteToStream(IStream *pStream)
{
    return pStream->Write(&m_guidDSoundDev, sizeof(m_guidDSoundDev), 0);
}

HRESULT  CDSoundDevice::amsndOutReadFromStream(IStream *pStream)
{
    if(m_lpDS)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    // caller makes sure we're not running
    return pStream->Read(&m_guidDSoundDev, sizeof(m_guidDSoundDev), 0);
}

int CDSoundDevice::amsndOutSizeMax()
{
    return sizeof(m_guidDSoundDev);
}

//-----------------------------------------------------------------------------
//
// FillSoundBuffer()
//
// Fills the lpWrite buffer with as much data it will take or is ripe and
// returns the amount written.
//
// Code is pretty piggy with all those += dwWrite, but the compiler
// usually does a good job at minimizing redundancies.
//
// Also as it goes through the list it will see which ripe buffers that were
// already copied, have also been played completely and will delete those (and
// do the WOM_DONE call back. For this purpose, the passed in dwPlayPos is
// used.
//
// Additional Note: For buffers which are copied we try to make the callbacks
// even if they have not been played provided that the buffer is not the
// last one we have received. This way we can let the flow of buffers coming
// in to continue. To figure out the last received buffer we use the
// m_dwRipeListPosition variable.
//-----------------------------------------------------------------------------
DWORD CDSoundDevice::FillSoundBuffer( LPBYTE lpWrite, DWORD dwLength, DWORD dwPlayPos )
{
    DWORD dwWritten, dwWrite;
    CAutoLock lock(&m_cRipeListLock);         // lock the list

    // dwPlayPos is the amount that has been played so far. This will be used
    // to free nodes that were already copied.

    dwWritten = 0;

    POSITION pos, posThis;
    CRipe    *pRipe;

    pos = m_ListRipe.GetHeadPosition();     // Get head entry
    while (pos && dwLength > 0)
    {
        posThis = pos ;                     // remember current pos, if we delete
        pRipe = m_ListRipe.GetNext(pos);    // Get list entry

        // if this node has been already copied, see if we can free it
        if (pRipe->bCopied)
        {
            // is the play position past the position marked for this sample ?
            // do signed math to take care of overflows. Also include the
            // buffers which are not the last one.
            if (((LONG)(dwPlayPos - pRipe->dwPosition) >= 0) ||
            ((LONG)((m_dwRipeListPosition) - pRipe->dwPosition) > 0))
            {
#ifdef DEBUG
                m_NumCallBacks ++ ;
                DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOutWrite: CallBack # %u"), m_NumCallBacks));
#endif

                DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("Callback: Sample = %u, Position = %u, Time = %u"), pRipe->dwSample, pRipe->dwPosition, dwPlayPos));

                if (m_pWaveOutProc)
                    (* m_pWaveOutProc ) (OUR_HANDLE, WOM_DONE, m_dwCallBackInstance, pRipe->dwSample, 0) ;
                // yes, this ripe node is done. Do the WOM_DONE call back for it and release it. Then move on.


                m_ListRipe.Remove( posThis );       // Remove entry from ripe list
                delete pRipe;                       // Free entry
            }
            continue ;                              // skip this node.
        }
        //  See if there are bytes to stuff
        if (pRipe->dwBytesToStuff) {
            //??pRipe->dwBytesToStuff -= m_dwSilenceWrittenSinceLastWrite;
            dwWrite = min(pRipe->dwBytesToStuff, dwLength);
            DbgLog((LOG_TRACE, 2, TEXT("Stuffing %d bytes"), dwWrite));
            FillMemory( lpWrite+dwWritten,
                        dwWrite,
                        m_dwBitsPerSample == 8 ? 0x80 : 0);

            pRipe->dwBytesToStuff -= dwWrite;             //
        } else {
            dwWrite=min(pRipe->dwLength,dwLength);  // Figure out how much to copy

#ifdef DXMPERF
			if (pRipe->bFresh) {
				__int64	i64CurrClock = m_pWaveOutFilter->m_pRefClock ? m_pWaveOutFilter->m_pRefClock->GetLastDeviceClock() : 0;
				__int64	i64ByteDur = BufferDuration( m_nAvgBytesPerSec, dwWrite );
				PERFLOG_AUDIOREND( i64CurrClock, pRipe->rtStart, m_pWaveOutFilter->m_fUsingWaveHdr ? NULL : pRipe->dwSample, i64ByteDur, dwWrite );
				pRipe->bFresh = FALSE;
			}
#endif // DXMPERF

            CopyMemory( lpWrite+dwWritten,          // Move bits
                        pRipe->lpBuffer,            //
                        dwWrite );                  //
            pRipe->dwLength -= dwWrite;             //
            pRipe->lpBuffer += dwWrite;             // Advance buffer
        }
        m_dwSilenceWrittenSinceLastWrite = 0;
        if( pRipe->dwLength == 0 && pRipe->dwBytesToStuff == 0)  // If done with buffer
        {
#ifdef DEBUG
            m_NumCopied ++ ;
            DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOutWrite: Copied # %u"), m_NumCopied));
#endif

            // simply mark it as done. It will get freed on a later pass
            // when we know that it has been played.
            pRipe->bCopied = TRUE ;

            DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("Callback: Done copying. Sample = %u"), pRipe->dwSample));
            if(!m_pWaveOutFilter->m_fUsingWaveHdr)
            {
                IMediaSample *pSample = (IMediaSample *)pRipe->dwSample;
                pSample->Release();
                pRipe->dwSample  = NULL;
            }
        }

        dwWritten += dwWrite;                   // Accumulate total written
        dwLength  -= dwWrite;                   // Adjust write buffer length
    }

    return dwWritten;
}
//-----------------------------------------------------------------------------
// StreamData()
//
//  Gets current sound buffer cursors, locks the buffer, and fills in
//  as much queued data as possible. If no data was available, it will
//  fill the entire available space with silence.
//
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::StreamData( BOOL bFromRun, BOOL bUseLatencyPad )
{
    // The caller must hold the filter lock because this function uses
    // variables which are protected by the filter lock.  Also,
    // StopCallingCallback() does not work correctly if the caller does 
    // not hold the filter lock.
    ASSERT(CritCheckIn(m_pWaveOutFilter));

    CAutoLock lock(&m_cDSBPosition);           // lock access to function

    HRESULT hr;
    DWORD   dwPlayPos;
    DWORD   dwLockSize;

    LPBYTE  lpWrite1, lpWrite2;
    DWORD   dwLength1, dwLength1Done, dwLength2, dwLength2Done;

#ifdef DEBUG
    m_cbStreamDataPass++ ;
    DbgLog((LOG_TRACE, TRACE_STREAM_DATA, TEXT("StreamData Pass # %u"),
            m_cbStreamDataPass));
#endif


    if( !m_lpDSB )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("  no m_lpDSB or buffers to stream")));
        return E_FAIL;
    }

//  This is broken because the logic says we only start filling the buffer when
//  it's got down to being 1 / FRACTIONAL_BUFFER_SIZE full.
//  The 'savings' were most likely because we actually looped the buffer
//  sometimes effectively slowing the clock
#if 1
    // check to see if the dsound buffer is empty enough to warrant the high overhead involved with filling it.
    // the idea here is that we want to minimize the number of times we call fillsoundbuffer(), but when we do call
    // it, we want to maximize the amount of copying done each time.  this holds for zerolockedsegment(), as well.
    // profiling has verified that this results in significant saving. however, we must be extremely paranoid about
    // when we apply it
    if(
        bFromRun
    )
    {
        // dwLength1 = dsound play cursor, we ignore the write cursor here
        // dwLength1 = dsound write cursor, we ignore the play cursor here
        hr = m_lpDSB->GetCurrentPosition(&dwLength1, &dwLength2);

#ifdef DETERMINE_DSOUND_LATENCY
#ifdef DEBUG
        LONG lDelta = (LONG) ( dwLength2 - dwLength1 );
        if( dwLength2 < dwLength1 )
            lDelta +=  m_dwBufferSize;

        REFERENCE_TIME rtDelta = BufferDuration( m_nAvgBytesPerSec, lDelta );

        // just log this to see the latency between p/w cursors
        DbgLog((LOG_TRACE, 10, TEXT("dsr:GetCurrentPosition p/w delta = %dms (Play = %ld, Write = %ld)"),
                (LONG) (rtDelta/10000), dwLength1, dwLength2 ) ) ;
#endif
#endif
        //if (m_fEmulationMode)
        if (bUseLatencyPad)
        {
            // instead if our buffers are small...
            // dwLength1 = dsound write cursor, we ignore the play cursor here
            //
            // Note: This should also be the case always, but we're taking
            // the low risk (and more tested) path and only doing this
            // in the exceptional case.
            dwLength1 = dwLength2;
        }
        if(FAILED(hr))
        {
            return hr;
        }
        // dwLength2 is the difference between our last valid write position and the dsound play cursor
        dwLength2 = m_tupNextWrite.m_offset >= dwLength1 ?
                    m_tupNextWrite.m_offset - dwLength1 :
                    m_tupNextWrite.m_offset + m_dwBufferSize - dwLength1;

            // is the delta between the cursors to large to warrant copying ?
        if(dwLength2 > (m_dwBufferSize / 4 + (bUseLatencyPad ? m_dwEmulationLatencyPad : 0)))
        {
            DbgLog((LOG_TRACE, TRACE_STREAM_DATA, TEXT("dsr:StreamData - Skipping buffer write (delta = %ld)"), dwLength2)) ;
            return S_OK;  // no, so do not work this time around
        }
    }
#endif  // #if 0

    // get the current playposition. Thsi will also update the m_tupPlay,
    // m_tupWrite and m_tupNextWrite tuples.
    //
    // Caution: Make sure that No one else calls GetDSBPosition or GetPlayPosition
    // while we are in StreamData because these functions update the tuples
    // as does StreamData. The functions are protected by the same critical
    // section that StreamData uses so the above two functions will be
    // protected from being called from another thread. Thus in StreamData
    // we will call GetPlayPosition at the begining and then make sure
    // that we do not call these functions anymore while we are adjusting
    // the tuples.

    // get the current playposition so that we can pass it to FillSoundBuffer.
    // Also this function will internally call GetDBPosition which will update
    // our tuples.

    dwPlayPos = (DWORD)GetPlayPosition () ;    // get position in DSB


    // figure out the amount of space in the buffer that we can lock. This
    // really corresponds to the logical interval [dwWritePos to dwPlay] in
    // the circular buffer.


    // make certain that pointers are consistent. The next write pointer
    // should be ahead of the play cursor, but should not lap it.
    ASSERT (m_tupNextWrite >= m_tupPlay) ;
    ASSERT ((m_tupNextWrite - m_tupPlay) <= m_dwBufferSize) ;


    // figure out the amount of space available to write. It would be
    // the complete buffer if we have not written anything yet.
    const dwFullness =  m_tupNextWrite - m_tupPlay;
    dwLockSize = m_dwBufferSize - dwFullness ;
    m_lPercentFullness = (LONG)MulDiv(dwFullness, 100, m_dwBufferSize );
#ifdef ENABLE_10X_FIX

    if(m_bDSBPlayStarted)
    {
#ifndef FILTER_DLL
        //  Log buffer fullness
        g_Stats.NewValue(m_lStatFullness, (LONGLONG)m_lPercentFullness);
#endif
#ifdef ENABLE_10X_TEST_RESTART

        // we're testing to see if EC_NEED_RESTART affects audio/video synchronization, this is not the typical case
#define CURSOR_STALL_THRESHOLD  254
        m_ucConsecutiveStalls = m_ucConsecutiveStalls < 255 ? ++m_ucConsecutiveStalls : 0;
#else

        // we're counting the number of zero locks which occur consecutively, a sign that DSOUND has stalled and is no longer consuming samples
#define CURSOR_STALL_THRESHOLD  100
        m_ucConsecutiveStalls = dwLockSize == 0 ? ++m_ucConsecutiveStalls : 0;
#endif  // ENABLE_10X_TEST_RESTART

        if(m_ucConsecutiveStalls)
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("Consecutive Stalls = %u"), m_ucConsecutiveStalls));

            if(m_ucConsecutiveStalls > CURSOR_STALL_THRESHOLD)
            {
                DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("StreamData: EC_NEED_RESTART")));
                m_pWaveOutFilter->NotifyEvent(EC_NEED_RESTART, 0, 0);   // signal restart

                m_fRestartOnPause = TRUE;  // reinitialize dsound on the next pause

                return E_FAIL;
            }
        }
    }
#endif  // ENABLE_10X_FIX

    if( dwLockSize == 0 )
        return DS_OK;                       // Return if none available


    ASSERT (dwLockSize <= m_dwBufferSize) ;


    // lock down all the unused space in the buffer.

    DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("calling lpDSB->Lock: m_offset = %u:%u, dwLockSize = %u "),
           m_tupNextWrite.m_itr, m_tupNextWrite.m_offset,
           dwLockSize));

    hr = m_lpDSB->Lock( m_tupNextWrite.m_offset, dwLockSize, (PVOID *) &lpWrite1, &dwLength1, (PVOID *) &lpWrite2, &dwLength2, 0 );
    if (hr != DS_OK)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("error in lpDSB->Lock! hr = %u"), hr & 0x0ffff));
        return hr ;
    }

    // Fill in as much of actual data as we can, upto the sizes being
    // passed in. dwLength1Done and dwLength2Done return the amount written.

    dwLength1Done = FillSoundBuffer( lpWrite1, dwLength1, dwPlayPos ); // Fill first part
    ASSERT (dwLength1Done <= dwLength1) ;

    // Try to write in wrapped part only if 1st part was fully written
    if (dwLength1Done == dwLength1)
    {
        dwLength2Done = FillSoundBuffer( lpWrite2, dwLength2, dwPlayPos ); // Fill wrapped part
        ASSERT (dwLength2Done <= dwLength2) ;
    }
    else
        dwLength2Done = 0 ;


    DbgLog((LOG_TRACE, TRACE_STREAM_DATA, TEXT("data at = %u:%u, length = %u, lock = %u"),
            m_tupNextWrite.m_itr, m_tupNextWrite.m_offset,
            (dwLength1Done+dwLength2Done), dwLockSize));

    m_tupNextWrite += (dwLength1Done + dwLength2Done) ;

    ASSERT ((m_tupNextWrite - m_tupPlay) <= m_dwBufferSize) ;

#ifdef DEBUG
    m_dwTotalWritten += (dwLength1Done + dwLength2Done) ;
    if ((dwLength1Done) > 0)
    {
        DbgLog((LOG_TRACE, TRACE_STREAM_DATA, TEXT("Total Data written = %u"),
                m_dwTotalWritten));
    }
#endif

    // fill silence if no data written. We do not write silence if even a bit
    // of data was written. Maybe we can add some heuristics here.
    if (dwLength1Done == 0)
    {
        ZeroLockedSegment (lpWrite1, dwLength1) ;
        ZeroLockedSegment (lpWrite2, dwLength2) ;
        dwLength1Done = dwLength1 ;
        dwLength2Done = dwLength2 ;
    }


    // unlock the buffer.
    m_lpDSB->Unlock( lpWrite1, dwLength1Done, lpWrite2, dwLength2Done );
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("error in lpDSB->Unlock! hr = %u"), hr & 0x0ffff));
        hr = DS_OK;  // note the problem, continue without error???
    }


    return hr;
}


//-----------------------------------------------------------------------------
//
// ZeroLockedSegment ()
//
// Fills silence in a locked segment of the dsound buffer.
//-----------------------------------------------------------------------------
void CDSoundDevice::ZeroLockedSegment ( LPBYTE lpWrite, DWORD dwLength )
{
    if (dwLength != 0 && lpWrite != NULL)
    {
        if( m_dwBitsPerSample == 8 )
            FillMemory( lpWrite, dwLength, 0x080 );
        else
            ZeroMemory( lpWrite, dwLength );
    }
}
//-----------------------------------------------------------------------------
//
// StreamingThread()
//
//   Critical buffer scheduling thread. It wakes up periodically
//     to stream more data to the directsoundbuffer. It sleeps on an
//     event with a timeout so that others can wake it.
//
//-----------------------------------------------------------------------------

void __stdcall CDSoundDevice::StreamingThreadCallback( DWORD_PTR lpvThreadParm )
{
    //DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("CDSoundDevice::StreamingThreadSetup")));

    CDSoundDevice    *pDevice;
    pDevice = (CDSoundDevice *)lpvThreadParm;

#ifdef DEBUG
    DWORD dwt = timeGetTime () ;
    if (pDevice->m_lastThWakeupTime != 0)
    {
        DWORD dwtdiff = dwt - pDevice->m_lastThWakeupTime ;
        DbgLog((LOG_TRACE, TRACE_THREAD_LATENCY, TEXT("Thread wakes up after %u ms"), dwtdiff));
        if (dwtdiff > THREAD_WAKEUP_INT_MS * 5)
        {
            DbgLog((LOG_TRACE,TRACE_THREAD_LATENCY, TEXT("Lookey! Thread waking up late. actual = %u, need = %u"),
              dwtdiff, THREAD_WAKEUP_INT_MS));
        }
    }
    pDevice->m_lastThWakeupTime = dwt ;
#endif

    pDevice->StreamData ( FALSE );
}

HRESULT CDSoundDevice::StartCallingCallback()
{
    // The caller must hold the filter lock because it protects
    // m_callbackAdvise and m_lastThWakeupTime.
    ASSERT(CritCheckIn(m_pWaveOutFilter));

    DbgLog((LOG_TRACE, TRACE_THREAD_STATUS, TEXT("Setting the ADVISE for the thread")));

#ifdef DEBUG
    m_lastThWakeupTime = 0 ;
#endif

    if (IsCallingCallback()) {
        return S_OK;
    }

    CCallbackThread* pCallbackThreadObject = m_pWaveOutFilter->GetCallbackThreadObject();

    HRESULT hr = pCallbackThreadObject->AdvisePeriodicWithEvent(
                                                        CDSoundDevice::StreamingThreadCallback,  // callback function
                                                        (DWORD_PTR) this,   // user token passed to callback
                                                        THREAD_WAKEUP_INT_MS * (UNITS / MILLISECONDS),
                                                        NULL,
                                                        &m_callbackAdvise);
    if (hr != NOERROR)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("ADVISE FAILED! hr=%x"), hr));
        return hr;
    }

    // 0 is not a valid advise token.
    ASSERT(0 != m_callbackAdvise);

    return S_OK;
}

void CDSoundDevice::StopCallingCallback()
{
    // The caller must hold the filter lock because this function uses
    // m_lastThWakeupTime and m_callbackAdvise.  The caller must
    // also hold the filter lock because the filter lock synchronizes 
    // access to the callback thread.  The callback thread will not call 
    // CDSoundDevice::StreamingThreadCallback() while another thread holds
    // the filter lock.  The callback thread will not call 
    // StreamingThreadCallback() because the callback object 
    // (CWaveOutFilter::m_callback) holds the filter lock when it decides 
    // whether it should call the callback function and when it actually 
    // calls the callback function.  We can safely cancel the callback advise
    // because the callback object will not call StreamingThreadCallback() 
    // while we are holding the filter lock.  We do not want to cancel the 
    // callback advise while StreamingThreadCallback() is being called 
    // because StreamingThreadCallback() might use the CDSoundDevice object 
    // after we delete it.  See bug 298993 in the Windows Bugs database for 
    // more information.  Bug 298993's title is "STRESS: DSHOW: The Direct 
    // Sound Renderer crashes if the CDSoundDevice object is destroyed before 
    // the callback thread terminates".
    ASSERT(CritCheckIn(m_pWaveOutFilter));

    // Cancel the advise only if we have an advise to cancel.
    if  (IsCallingCallback()) {
        CCallbackThread* pCallbackThreadObject = m_pWaveOutFilter->GetCallbackThreadObject();

        HRESULT hr = pCallbackThreadObject->Cancel(m_callbackAdvise);

        // Cancel() always succeeds if m_callbackAdvise is a valid advise
        // token.
        ASSERT(SUCCEEDED(hr));

        m_callbackAdvise = 0;

        #ifdef DEBUG
        m_lastThWakeupTime = 0;
        #endif
    }
}

//-----------------------------------------------------------------------------
// BOOL RestoreBufferIfLost(BOOL bRestore)
//
// Checks the status code for dsound to see if it's DSBTATUS_BUFFERLOST.
// If so and if bRestore is TRUE, it attempts to Restore the buffer.
// Returns TRUE if buffer is valid at exit, else FALSE.
//
// keeps retrying for upto 1 second because we see long delays on
// WinME when resuming from standby/hibernation
//-----------------------------------------------------------------------------
BOOL CDSoundDevice::RestoreBufferIfLost(BOOL bRestore)
{
    if (m_lpDSB)
    {
        DWORD dwStatus = 0;
        HRESULT hr = m_lpDSB->GetStatus (&dwStatus);
        if (SUCCEEDED(hr))
        {
            if ((DSBSTATUS_BUFFERLOST & dwStatus) == 0)
            {
                return TRUE;
            }

#ifdef DEBUG
            if (!m_bBufferLost)
            {
                DbgLog((LOG_TRACE, TRACE_BUFFER_LOSS,TEXT("DSoundBuffer was lost...")));
            }
            m_bBufferLost = TRUE;
#endif

            if (bRestore)
            {
                hr = m_lpDSB->Restore();
                for(int i = 0; hr == DSERR_BUFFERLOST && i < 30; i++)
                {
                    Sleep(30);
                    hr = m_lpDSB->Restore();
                }
                DbgLog((LOG_TRACE, TRACE_BUFFER_LOSS,
                        TEXT("DSound buffer restore %08x, %d iterations"), hr, i));
                if (DS_OK == hr)
                {
#ifdef DEBUG
                    m_bBufferLost = FALSE;
#endif
                    return TRUE;
                }
            }
        }
        else
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR,TEXT("lpDSB->GetStatus returned 0x%08lx"),hr));
        }
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
//
// FlushSamples ()
//
// Flushes all the samples from the Ripe list. Called during BeginFlush
// or from Inactive
//
//-----------------------------------------------------------------------------
void CDSoundDevice::FlushSamples ()
{
    DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("  Flushing pending samples")));
    // flush the queued up samples
    {
        CRipe    *pRipe;

        CAutoLock lock(&m_cRipeListLock);        // lock list

        while(1)
        {
            pRipe = m_ListRipe.RemoveHead();       // Get head entry
            if( pRipe == NULL ) break;              // Exit if no more

#ifdef DEBUG
            m_NumCallBacks ++ ;
            DbgLog((LOG_TRACE,TRACE_SAMPLE_INFO, TEXT("waveOutWrite: Flush CallBack # %u"), m_NumCallBacks));
#endif
            // make the WOM_DONE call back here
                if (m_pWaveOutProc)
            (* m_pWaveOutProc) (OUR_HANDLE, WOM_DONE, m_dwCallBackInstance, pRipe->dwSample, 0) ;
            delete pRipe;                          // Free entry
        }
    }

    // flush the queued up audio breaks
    {
        CAudBreak    *pAB;

        CAutoLock lock(&m_cDSBPosition);        // lock list

        while(1)
        {
            pAB = m_ListAudBreak.RemoveHead();       // Get head entry
            if( pAB == NULL ) break;                 // Exit if no more

#ifdef DEBUG
            m_NumBreaksPlayed ++ ;
            DbgLog((LOG_TRACE,TRACE_SAMPLE_INFO, TEXT("Flushing Audio Break Node %u"), m_NumBreaksPlayed));
#endif
            delete pAB;                          // Free entry
        }
    }

    {
        // Initialize all variables
        CAutoLock lock(&m_cDSBPosition);           // lock access to function

#ifdef DEBUG
        DbgLog((LOG_TRACE,TRACE_SAMPLE_INFO, TEXT("Clearing audio break stats")));
        m_NumBreaksPlayed =  0 ;
        m_NumSamples = 0 ;
        m_NumCallBacks = 0 ;
        m_cbStreamDataPass = 0 ;    // number of times thru StreamData
#endif

        m_NumAudBreaks = 0;


        // initilize variables
        m_tupPlay.Init (0,0,m_dwBufferSize) ;   // set to start
        m_tupWrite.Init (0,0,m_dwBufferSize);   // set to start
        m_tupNextWrite.Init (0,0,m_dwBufferSize) ; // set to start
        m_dwRipeListPosition = 0 ;
        m_llSilencePlayed = 0 ;

        //  Reset sample stuffing info
        m_dwSilenceWrittenSinceLastWrite = 0;

#ifdef ENABLE_10X_FIX
        Reset10x();
#endif

#ifdef DEBUG
        m_dwTotalWritten = 0 ;
#endif
    }
}
//-----------------------------------------------------------------------------
// GetPlayPosition.
//
// Returns the current position based on the amount of data that has been played
// so far.
//-----------------------------------------------------------------------------
LONGLONG CDSoundDevice::GetPlayPosition (BOOL bUseUnadjustedPos)
{
    LONGLONG llTime = 0 ;

    HRESULT hr = GetDSBPosition () ;   // get position in DSb
    if( hr == DS_OK )
    {
        // Refresh the audio break list to account for any silence that has
        // been played.

        RefreshAudioBreaks (m_tupPlay) ;

        if( bUseUnadjustedPos )
        {
            llTime = m_tupPlay.LinearLength() + m_llAdjBytesPrevPlayed;
        }
        else
        {
            // Time is based on current position, number of iterations through the
            // buffer and the amount of silence played.

            llTime = (m_tupPlay.LinearLength() - m_llSilencePlayed) + m_llAdjBytesPrevPlayed;

            //  NOTE llTime can be negative in the case that we stuffed a lot
            //  of silence.
        }

    }
    else if (DSERR_BUFFERLOST == hr)
    {
#ifdef DEBUG
        if (!m_bBufferLost)
        {
            DbgLog((LOG_TRACE, TRACE_BUFFER_LOSS, TEXT("waveOutGetPlayPosition: DSound buffer lost")));
        }
        m_bBufferLost = TRUE;
#endif

        // if we've lost the dsound buffer, attempt to restore it
        hr = m_lpDSB->Restore();
#ifdef DEBUG
        if (DS_OK == hr)
        {
            DbgLog((LOG_TRACE, TRACE_BUFFER_LOSS, TEXT("waveOutGetPosition: DSound buffer restored")));
            m_bBufferLost = FALSE;
        }
#endif
    }
    else
    {
        // abort if we hit any other error
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("waveOutGetPosition: error from GetDSBPosition! hr = %u"), hr & 0x0ffff));
        m_pWaveOutFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
    }
    DbgLog((LOG_TRACE, TRACE_TIME_REPORTS, TEXT("Reported Time = %u"), (LONG)llTime)) ;
    return llTime ;
}
//-----------------------------------------------------------------------------
// AddAudioBreak
//
// Adds another one or two nodes to the audio break list.
//-----------------------------------------------------------------------------
void CDSoundDevice::AddAudioBreak (Tuple& t1, Tuple& t2)
{
    CAutoLock lock(&m_cDSBPosition);     // lock the list

    // Test for null node & ignore.
    if (t1 == t2)
        return ;

    ASSERT (t1 < t2) ;

    CAudBreak    *pAB;
    pAB = new CAudBreak(NAME("CDSoundDevice Audio Break Node"));
    if( !pAB )
    {
        // too bad. There is not much we can do, this audio break will not
        // get registered.
        DbgLog((LOG_ERROR,MINOR_ERROR, TEXT("AddAudioBreak: new CAudBreak failed!")));
        return ;
    }

    DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Adding audio break node: %u:%u to %u:%u"),
       t1.m_itr, t1.m_offset, t2.m_itr, t2.m_offset));

    pAB->t1 = t1 ;
    pAB->t2 = t2 ;

#ifdef DXMPERF
	PERFLOG_AUDIOBREAK( t1.LinearLength(), t2.LinearLength(), MulDiv( (DWORD) (t2 - t1), 1000, m_pWaveOutFilter->WaveFormat()->nAvgBytesPerSec ) );
#endif // DXMPERF

    m_NumAudBreaks ++ ;
#ifndef FILTER_DLL
    g_Stats.NewValue(m_lStatBreaks, (LONGLONG)m_NumAudBreaks);
#endif
    m_ListAudBreak.AddTail( pAB );           // Add to Audio Break

#ifdef PERF
    MSR_INTEGER(m_idAudioBreak,
                MulDiv((DWORD)(t2 - t1), 1000,
                       m_pWaveOutFilter->WaveFormat()->nAvgBytesPerSec));
#endif


#ifdef DEBUG

    // dump the list of nodes.
    POSITION pos ;
    int i = 1 ;

    Tuple t ;
    t.Init (0,0,m_dwBufferSize) ;


    pos = m_ListAudBreak.GetHeadPosition();      // Get head entry
    while (pos)
    {
        pAB = m_ListAudBreak.GetNext(pos);      // Get list entry

        DbgLog((LOG_TRACE,TRACE_BREAK_DATA, TEXT("Break #%u %u:%u to %u:%u"),
           i, pAB->t1.m_itr, pAB->t1.m_offset,
           pAB->t2.m_itr, pAB->t2.m_offset));
        i++ ;

        // make sure nodes don't overlap.
        ASSERT (pAB->t1 >=  t) ;
        t = pAB->t2 ;
    }

#endif
    return ;

}
//-----------------------------------------------------------------------------
// RefreshAudioBreaks
//
// This function, given the current play position, walks through the audio break
// list and figure out which breaks we have already played and if we are playing
// one currently. It updates the m_llSilencePlayed field based on this. It
// deletes nodes that have already been played. If it is currently playing
// a break, it will account for the amount played and adjust the node to
// account for the unplayed portion.
//-----------------------------------------------------------------------------
void CDSoundDevice::RefreshAudioBreaks (Tuple& t)
{
    CAutoLock lock(&m_cDSBPosition);         // lock the list

    POSITION pos, posThis;
    CAudBreak    *pAB;

    pos = m_ListAudBreak.GetHeadPosition();      // Get head entry
    while (pos)
    {
        posThis = pos ;                         // remember current pos, if we delete
        pAB = m_ListAudBreak.GetNext(pos);      // Get list entry

        // see if we are past this break.
        if (pAB->t2 <= t)
        {
            // we must have played this node completely. Accumulate its
            // length and get rid of it.
            ASSERT (pAB->t2 > pAB->t1) ;
            m_llSilencePlayed += (pAB->t2 - pAB->t1) ;
            DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Silence Played = %u"), m_llSilencePlayed));

#ifdef DEBUG
            m_NumBreaksPlayed ++ ;
#endif
            m_ListAudBreak.Remove( posThis );       // Remove entry from AudBreak list
            delete pAB;                             // Free entry
            continue ;
        }

        // see if we are actually playing silence
        if ((pAB->t1 < t) && (pAB->t2 > t))
        {
            // we are part way through this node. Accumulate the portion
            // that we have played and alter the node to account for the
            // unplayed portion.


            m_llSilencePlayed += (t - pAB->t1) ;
            DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Silence Played = %u"), m_llSilencePlayed));
            DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Breaking up unplayed audio node")));
            pAB->t1 = t ;

            DbgLog((LOG_TRACE,TRACE_BREAK_DATA, TEXT("Changing  audio break node: %u:%u to %u:%u"),
            pAB->t1.m_itr, pAB->t1.m_offset,
            pAB->t2.m_itr, pAB->t2.m_offset));

        }

        // no need to go through further nodes.
        break ;
    }

#ifdef DEBUG
    DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Breaks Logged = %u, Breaks Played = = %u"),
       m_NumAudBreaks, m_NumBreaksPlayed));
#endif

    return ;
}
//-----------------------------------------------------------------------------
// GetDSBPosition
//
// Gets current position in the DSB and updates the iteration that we are on
// in the play buffer. We maintain separate iteration indices for the play
// and write cursors.
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::GetDSBPosition ()
{
    CAutoLock lock(&m_cDSBPosition);           // lock access to function
    DWORD dwPlay, dwWrite ;

    AUDRENDPERF(MSR_INTEGER(m_idAudioBreak,
                  MulDiv((DWORD)(t2 - t1), 1000,
                         m_pWaveOutFilter->WaveFormat()->nAvgBytesPerSec)));

    AUDRENDPERF(MSR_START(m_idGetCurrentPosition));
    HRESULT hr = m_lpDSB->GetCurrentPosition( &dwPlay, &dwWrite );
    AUDRENDPERF(MSR_STOP(m_idGetCurrentPosition));
    if (FAILED (hr))
    {
        m_hrLastDSoundError = hr;
        return hr ;
    }
    DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("GetDSB: GetCurrentPos.  p  = %u, n = %u"), dwPlay, dwWrite));

#ifdef ENABLE_10X_FIX

    if(m_bDSBPlayStarted)
    {
        // check to see if DSOUND has reported bogus play/write positions.  if so, DSOUND is now in an unstable (likely frozen) state.
        if((dwWrite > m_dwBufferSize) || (dwPlay > m_dwBufferSize))
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("GetDSB:  Out of Bounds Write = %u, Play = %u, BufferSize = %u"), dwWrite, dwPlay, m_dwBufferSize));

            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("GetDSB: EC_NEED_RESTART")));
            m_pWaveOutFilter->NotifyEvent(EC_NEED_RESTART, 0, 0);   // signal a restart

            m_fRestartOnPause = TRUE;  // restart dsound on the next pause

            return E_FAIL;
        }
    }

#endif  // if 10x

    // Make sure that the play tuple is updated 1st as the write tuple
    // will be uodated based on the play tuple.
    m_tupPlay.MakeCurrent (dwPlay) ;
    m_tupWrite.MakeCurrent (m_tupPlay, dwWrite) ;

    ASSERT (m_tupWrite >= m_tupPlay) ;

    // check for ovverun and add silence node if we get one.
    if (m_tupWrite > m_tupNextWrite)
    {
        DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Silence Node.  p = %u:%u, w = %u:%u,  n = %u:%u "),
                m_tupPlay.m_itr, m_tupPlay.m_offset,
                m_tupWrite.m_itr, m_tupWrite.m_offset,
                m_tupNextWrite.m_itr, m_tupNextWrite.m_offset));

        AddAudioBreak (m_tupNextWrite, m_tupWrite) ;

        // go past the audio break (that will happen) ;
        m_dwSilenceWrittenSinceLastWrite += m_tupWrite - m_tupNextWrite;
        m_tupNextWrite = m_tupWrite ;
    }

    DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("GetDSB: p = %u:%u, w = %u:%u, n = %u:%u"),
            m_tupPlay.m_itr, m_tupPlay.m_offset,
            m_tupWrite.m_itr, m_tupWrite.m_offset,
            m_tupNextWrite.m_itr, m_tupNextWrite.m_offset));

    return S_OK ;
}
//-----------------------------------------------------------------------------
// DSCleanUp.
//
// Cleans up all the DSound objects. Called from amsndOutClose or when wavOutOpen
// fails.
//-----------------------------------------------------------------------------
void CDSoundDevice::CleanUp (BOOL bBuffersOnly)
{
    HRESULT hr ;

    // clean up the secondary buffer.

    if( m_lpDSB )
    {
        DbgLog((LOG_TRACE, TRACE_CLEANUP, TEXT("  cleaning up lpDSB")));
        if (m_lp3dB)
	    m_lp3dB->Release();
	m_lp3dB = NULL;
        hr = m_lpDSB->Release();
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("CDSoundDevice::Cleanup: Release failed: %u"), hr & 0x0ffff));
        }
        m_lpDSB = NULL;
    }

    // stop and clean up the primary buffer
    if( m_lpDSBPrimary )
    {
        DbgLog((LOG_TRACE, TRACE_CLEANUP, TEXT("  cleaning up lpDSBPrimary")));
        hr = m_lpDSBPrimary->Stop();
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CDSoundDevice::Cleanup: Stop of lpDSBPrimary failed: %u"), hr & 0x0ffff));
        }

        if (m_lp3d)
	    m_lp3d->Release();
	m_lp3d = NULL;
        hr = m_lpDSBPrimary->Release();
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CDSoundDevice::Cleanup: Release of lpDSBPrimary failed: %u"), hr & 0x0ffff));
        }

        m_lpDSBPrimary = NULL;
    }

    // clean up the DSound object itself.
    if (m_lpDS && !bBuffersOnly)
    {
        hr = m_lpDS->Release();
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CDSoundDevice::Cleanup: Release of lpDS failed: %u"), hr & 0x0ffff));
        }
        m_lpDS = NULL;
    }

    // Set state back
    m_WaveState = WAVE_CLOSED;
}

//
// CDSoundDevice::SetBufferVolume()
//
// Wraps the initial volume and pan setting done after we create a buffer
//
HRESULT CDSoundDevice::SetBufferVolume( LPDIRECTSOUNDBUFFER lpDSB, WAVEFORMATEX * pwfx )
{
    ASSERT( lpDSB );
    if( !IsNativelySupported( pwfx ) || m_pWaveOutFilter->m_pAudioDuplexController )
    {        
        // don't set a start volume for non-native formats or if running with AEC
        return S_OK;
    }            
        
    // set to current volume and balance settings
    HRESULT hr = lpDSB->SetVolume(m_lVolume);
    if( S_OK == NOERROR )
    {    
        hr = lpDSB->SetPan(m_lBalance);
    }
    return hr;
}

// 
// SetSRCQuality 
//
// When slaving we need to assure that frequency changes will be subtle and currently we get
// finer granularity when kmixer's using the lower quality SRC, so we make a SNR sacrifice.
//
// kernel mixer SRC quality levels are: 
//      KSAUDIO_QUALITY_WORST
//      KSAUDIO_QUALITY_PC
//      KSAUDIO_QUALITY_BASIC
//      KSAUDIO_QUALITY_ADVANCED
//
HRESULT CDSoundDevice::SetSRCQuality( DWORD dwQuality )
{
    ASSERT( m_lpDSB ); // should only be called when paused or running
        
    // avoid ks/dsound IKsPropertySet mismatch
    IDSPropertySet *pKsProperty;
    HRESULT hr = m_lpDSB->QueryInterface( IID_IKsPropertySet, (void **) &pKsProperty );
    if( SUCCEEDED( hr ) )
    {
        hr = pKsProperty->Set( KSPROPSETID_Audio
                             , KSPROPERTY_AUDIO_QUALITY
                             , (PVOID) &dwQuality
                             , sizeof( dwQuality )
                             , (PVOID) &dwQuality
                             , sizeof( dwQuality ) );
        if( FAILED( hr ) )
        {
            DbgLog(( LOG_TRACE, 2, TEXT( "ERROR SetSRCQuality: IKsPropertySet->Set() KSPROPERTY_AUDIO_QUALITY returned 0x%08X" ), hr ));
        }            
        pKsProperty->Release();
    }        
    return hr;
}    

// 
// GetSRCQuality 
//
// Get current SRC quality
//
HRESULT CDSoundDevice::GetSRCQuality( DWORD *pdwQuality )
{
    ASSERT( pdwQuality );
    ASSERT( m_lpDSB ); // should only be called when paused or running
        
    // avoid ks/dsound IKsPropertySet mismatch
    IDSPropertySet *pKsProperty;
    HRESULT hr = m_lpDSB->QueryInterface( IID_IKsPropertySet, (void **) &pKsProperty );
    if( SUCCEEDED( hr ) )
    {
        ULONG   cbSize = sizeof( DWORD );
    
        hr = pKsProperty->Get( KSPROPSETID_Audio
                             , KSPROPERTY_AUDIO_QUALITY
                             , (PVOID) pdwQuality
                             , sizeof( DWORD )
                             , (PVOID) pdwQuality
                             , sizeof( DWORD ) 
                             , &cbSize );
        if( FAILED( hr ) )
        {
            DbgLog(( LOG_TRACE, 2, TEXT( "ERROR! GetSRCQuality: IKsPropertySet->Get() KSPROPERTY_AUDIO_QUALITY returned 0x%08X" ), hr ));
        }
        else
        {
            DbgLog(( LOG_TRACE, 3, TEXT( "** SRC Quality setting is %hs **" ), 
                     *pdwQuality == KSAUDIO_QUALITY_WORST ? "KSAUDIO_QUALITY_WORST" :
                     ( *pdwQuality == KSAUDIO_QUALITY_PC    ? "KSAUDIO_QUALITY_PC" :
                      ( *pdwQuality == KSAUDIO_QUALITY_BASIC  ? "KSAUDIO_QUALITY_BASIC" :
                       ( *pdwQuality == KSAUDIO_QUALITY_ADVANCED ? "KSAUDIO_QUALITY_ADVANCED" :
                        ( *pdwQuality == KSAUDIO_QUALITY_ADVANCED  ? "KSAUDIO_QUALITY_ADVANCED" : 
                          "Unknown KMixer Quality!" ) ) ) ) ));
        }        
        pKsProperty->Release();
    }        
    return hr;
}    

// If you want to do 3D sound, you should use the IDirectSound3DListener
// and IDirectSound3DBuffer interfaces.  IAMDirectSound never worked, so I
// am removing support for it. - DannyMi 5/6/98

#if 0
// Give the IDirectSound interface to anyone who wants it
//
HRESULT CDSoundDevice::amsndGetDirectSoundInterface(LPDIRECTSOUND *lplpds)

{
    // If we don't have the object around yet, make it
    if (m_lpDS == NULL)
    CreateDSound();

    if (lplpds && m_lpDS) {
        HRESULT hr = m_lpDS->AddRef();
        *lplpds = m_lpDS;
        DbgLog((LOG_TRACE,MAJOR_ERROR,TEXT("Giving/AddRef'ing the IDirectSound object")));
        return NOERROR;
    } else {
        return E_FAIL;
    }
}


// Give the IDirectSoundBuffer interface of the primary to anyone who wants it
//
HRESULT CDSoundDevice::amsndGetPrimaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb)
{

    // If we don't have the objects around yet, make them
    if (m_lpDSBPrimary == NULL) {
        CreateDSound();
        CreateDSoundBuffers();
    }

    if (lplpdsb && m_lpDSBPrimary) {
        m_lpDSBPrimary->AddRef();
        *lplpdsb = m_lpDSBPrimary;
        DbgLog((LOG_TRACE,MAJOR_ERROR,TEXT("Giving/AddRef'ing the primary IDirectSoundBuffer object")));
        return NOERROR;
    } else {
        return E_FAIL;
    }
}


// Give the IDirectSoundBuffer interface of the secondary to anyone who wants it
//
HRESULT CDSoundDevice::amsndGetSecondaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb)
{
    // If we don't have the objects around yet, make them
    if (m_lpDSB == NULL) {
        CreateDSound();
        CreateDSoundBuffers();
    }

    if (lplpdsb && m_lpDSB) {
        WAVEFORMATEX wfx;
        DWORD dw;
        m_lpDSB->AddRef();
        *lplpdsb = m_lpDSB;
        m_lpDSBPrimary->GetFormat(&wfx, sizeof(wfx), &dw);
        // This will slow performance down!  The app will have to do this
#if 0
        if (wfx.nChannels == 1) {
            // Right now we're using mono sound, and if the app wants
            // to be able to use 3D effects, we need to have a stereo primary.
            // We either trust the app to do it itself, or do it for them.
            wfx.nChannels = 2;
            wfx.nBlockAlign *= 2;
            wfx.nAvgBytesPerSec *= 2;
            m_lpDSBPrimary->SetFormat(&wfx);
                DbgLog((LOG_TRACE,MAJOR_ERROR,TEXT("Changing to stereo PRIMARY for 3D effects")));
        }
#endif
        DbgLog((LOG_TRACE,MAJOR_ERROR,TEXT("Giving/AddRef'ing the secondary IDirectSoundBuffer object")));
        return NOERROR;
    } else {
        return E_FAIL;
    }
}
#endif

// helper function, set the focus window
HRESULT CDSoundDevice::SetFocusWindow(HWND hwnd)
{
    HRESULT hr = S_OK;

    // save the passed in hwnd, we will use it when the device is
    // opened.

    m_hFocusWindow = hwnd ;
    DbgLog((LOG_TRACE,TRACE_FOCUS,TEXT("Focus set to %x"), hwnd));

    // now change the focus window
    HWND hFocusWnd ;
    if (m_hFocusWindow) {
        hFocusWnd = m_hFocusWindow ;
        m_fAppSetFocusWindow = TRUE;
    } else {
        hFocusWnd = GetForegroundWindow () ;
        if (!hFocusWnd)
            hFocusWnd = GetDesktopWindow () ;
        m_fAppSetFocusWindow = FALSE;
    }

    // we don't have a dsound object yet, so we'll set the cooperative level
    // later, as soon as we make one
    if (!m_lpDS)
        return S_OK;

    // Set the cooperative level
    DbgLog((LOG_TRACE, TRACE_FOCUS, TEXT(" hWnd for SetCooperativeLevel = %x"), hFocusWnd));
    hr = m_lpDS->SetCooperativeLevel( hFocusWnd, DSSCL_PRIORITY );
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("*** SetCooperativeLevel failed! %u"), hr & 0x0ffff));
    }

    return hr;
}

// helper function, turn GLOBAL_FOCUS on or off
HRESULT CDSoundDevice::SetMixing(BOOL bMixingOnOrOff)
{
    HRESULT hr = S_OK;

    BOOL fMixPolicyChanged = ( (BOOL)m_fMixing != bMixingOnOrOff );
    m_fMixing = !!bMixingOnOrOff;

    DbgLog((LOG_TRACE,TRACE_FOCUS,TEXT("Mixing set to %x"), bMixingOnOrOff));

    // we'll do this work later
    if(!m_lpDSB || (m_WaveState == WAVE_PLAYING))
        return hr;

    // set the focus now only if the mixing policy changed, and we have a valid secondary (otherwise, one will be created later)
    if(fMixPolicyChanged)
    {
        //  Save wave state because Cleanup sets it to WAVE_CLOSED
        const WaveState WaveStateSave = m_WaveState;
        // release all our buffers (technically, we should need to only release the secondary, but this is insurance against DSOUND flakiness)
        CleanUp(TRUE);  // TRUE => release only our primary and secondary, not the dsound object

        // now recreate our buffers with the GLOBAL_FOCUS on or off
        hr = CreateDSoundBuffers();

    	// This function assumes that a non-zero value returned by 
        // CreateDSoundBuffers() is an error because the function
        // returns MMRESULTs and HRESULTs.  All failure MMRESULTs 
        // are greater than 0 and all failure HRESULTs are less than
        // 0.
        if (S_OK == hr) {
            m_WaveState = WaveStateSave;
        } else {
            hr = E_FAIL;
        }	
    }

    return hr;
}


// Set the focus window and mixing policy for the dsound renderer.
HRESULT CDSoundDevice::amsndSetFocusWindow (HWND hwnd, BOOL bMixingOnOrOff)
{
    HRESULT hr;
    hr = SetFocusWindow(hwnd);
    if(FAILED(hr))
        return hr;
    hr = SetMixing(bMixingOnOrOff);
    return hr;
}

// Get the focus window for the dsound renderer.
HRESULT CDSoundDevice::amsndGetFocusWindow (HWND *phwnd, BOOL *pbMixingOnOrOff)
{
   if (phwnd == NULL || pbMixingOnOrOff == NULL)
       return E_POINTER ;
   if (m_fAppSetFocusWindow)
       *phwnd = m_hFocusWindow ;
   else
       *phwnd = NULL ;
    *pbMixingOnOrOff = m_fMixing;
   return S_OK ;
}

#ifdef ENABLE_10X_FIX
// reset all statistics gathering for 10x bug
void CDSoundDevice::Reset10x()
{
    m_fRestartOnPause = FALSE;
    m_ucConsecutiveStalls = 0;
}

#endif // 10x

// set the playback rate (may be called dynamically)
HRESULT CDSoundDevice::SetRate(DOUBLE dRate, DWORD nSamplesPerSec, LPDIRECTSOUNDBUFFER pBuffer)
{
    const DWORD dwNewSamplesPerSec = (DWORD)(nSamplesPerSec * dRate);  // truncate
    if(dwNewSamplesPerSec < 100 || dwNewSamplesPerSec > 100000)
    {
        DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT("SetRate: Bad Rate specified %d at %d samples per sec"),
            (int)dRate, dwNewSamplesPerSec ));
        return WAVERR_BADFORMAT;
    }

    HRESULT hr = S_OK;

    if(!pBuffer)
        pBuffer = m_lpDSB; // we should be able to make this assumption in the case
                           // where we weren't explicitly passed a buffer (slaving case)

    if(pBuffer)
    {
        DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT("SetRate: Playing at %d%% of normal speed"), (int)(dRate * 100) ));
        hr = pBuffer->SetFrequency( dwNewSamplesPerSec );
        DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT("SetRate: SetFrequency on Secondary buffer, %d samples per sec"), dwNewSamplesPerSec));

        if(hr == S_OK)
            m_dRate = dRate;  // update rate only if we succeed in changing it
        else
            DbgLog((LOG_TRACE,3,TEXT("SetRate: SetFrequency failed with hr = 0x%lx"), hr));
    }
    
    if( FAILED( hr ) && !IsNativelySupported( m_pWaveOutFilter->WaveFormat() ) )
    {
        return S_OK;
    }
    else        
        return hr;
}

void CDSoundDevice::InitClass(BOOL fLoad, const CLSID *pClsid)
{
    if(fLoad)
    {
        // see if 1.0 setup removed some keys we care about: dsr
        // renderer (and the midi renderer)
        HKEY hkdsr;
        if(RegOpenKey(HKEY_CLASSES_ROOT,
                  TEXT("CLSID\\{79376820-07D0-11CF-A24D-0020AFD79767}"),
                  &hkdsr) ==
           ERROR_SUCCESS)
        {
            EXECUTE_ASSERT(RegCloseKey(hkdsr) == ERROR_SUCCESS);
        }
        else
        {
            // were we registered at all (check for CLSID_FilterGraph)
            HKEY hkfg;
            if(RegOpenKey(HKEY_CLASSES_ROOT,
                  TEXT("CLSID\\{e436ebb3-524f-11ce-9f53-0020af0ba770}"),
                  &hkfg) ==
               ERROR_SUCCESS)
            {
                EXECUTE_ASSERT(RegCloseKey(hkfg) == ERROR_SUCCESS);

                // just re-register everything! should we check for
                // another key in case this breaks something?
                DbgLog((LOG_ERROR, 0,
                    TEXT("quartz.dll noticed that 1.0 runtime removed some stuff")
                    TEXT("from the registry; re-registering quartz")));
                EXECUTE_ASSERT(AMovieDllRegisterServer2(TRUE) == S_OK);
            }
        }
    }
}

DWORD CDSoundDevice::GetCreateFlagsSecondary( WAVEFORMATEX *pwfx)
{
    ASSERT( pwfx );
    DWORD dwFlags   = m_fMixing ?
                DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_GLOBALFOCUS :
                DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_STICKYFOCUS ;
                
    // compressed formats don't support volume control
    if( IsNativelySupported( pwfx ) )
    {
        dwFlags |= gdwDSBCAPS_CTRL_PAN_VOL_FREQ;
        
        if( m_pWaveOutFilter->m_fFilterClock == WAVE_OTHERCLOCK )
        {
            //
            // Use s/w buffers when slaving to avoid inconsistencies with allowing 
            // h/w to do rate changes. Assumption is that compressed formats like AC3-S/PDIF 
            // won't work with s/w buffers, but natively supported formats like DRM will.
            //
            DbgLog((LOG_TRACE,5,TEXT("*** specifying software dsound secondary buffer (slaving)")));
            dwFlags |= DSBCAPS_LOCSOFTWARE;
        }
    }
    
    if (m_pWaveOutFilter->m_fWant3D) {
    	DbgLog((LOG_TRACE,3,TEXT("*** making 3D secondary")));
        dwFlags |= DSBCAPS_CTRL3D;
    }
    
    return dwFlags;
}    

#ifdef DEBUG
void DbgLogWaveFormat( DWORD Level, WAVEFORMATEX * pwfx )
{
    ASSERT( pwfx );
    DbgLog((LOG_TRACE,Level,TEXT("  wFormatTag           %u" ), pwfx->wFormatTag));
    DbgLog((LOG_TRACE,Level,TEXT("  nChannels            %u" ), pwfx->nChannels));
    DbgLog((LOG_TRACE,Level,TEXT("  nSamplesPerSec       %lu"), pwfx->nSamplesPerSec));
    DbgLog((LOG_TRACE,Level,TEXT("  nAvgBytesPerSec      %lu"), pwfx->nAvgBytesPerSec));
    DbgLog((LOG_TRACE,Level,TEXT("  nBlockAlign          %u" ), pwfx->nBlockAlign));
    DbgLog((LOG_TRACE,Level,TEXT("  wBitsPerSample       %u" ), pwfx->wBitsPerSample));
    if( WAVE_FORMAT_EXTENSIBLE == pwfx->wFormatTag )
    {
        DbgLog((LOG_TRACE,Level,TEXT("  dwChannelMask        %08lx" ), ((PWAVEFORMATEXTENSIBLE)pwfx)->dwChannelMask));
        if( pwfx->wBitsPerSample )
        {
            DbgLog((LOG_TRACE,Level,TEXT("  wValidBitsPerSample  %u" ), ((PWAVEFORMATEXTENSIBLE)pwfx)->Samples.wValidBitsPerSample));
        }
        else if( ((PWAVEFORMATEXTENSIBLE)pwfx)->Samples.wSamplesPerBlock )
        {
            DbgLog((LOG_TRACE,Level,TEXT("  wSamplesPerBlock     %u" ), ((PWAVEFORMATEXTENSIBLE)pwfx)->Samples.wSamplesPerBlock));
        }
        else
        {
            DbgLog((LOG_TRACE,Level,TEXT("  wReserved            %u" ), ((PWAVEFORMATEXTENSIBLE)pwfx)->Samples.wReserved));
        }
        OLECHAR strSubFormat[CHARS_IN_GUID];
        ASSERT( StringFromGUID2(((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat
              , strSubFormat
              , CHARS_IN_GUID) == CHARS_IN_GUID);
        DbgLog((LOG_TRACE,Level,TEXT("  SubFormat %ls" ), strSubFormat));
    }
}
#endif

bool IsNativelySupported( PWAVEFORMATEX pwfx )
{
    // formats not natively supported by kmixer require us to actually query the driver
    if( pwfx )
    {
        // of course these are natively supported on wdm only, but this is how this has been done up to now
        if( WAVE_FORMAT_EXTENSIBLE == pwfx->wFormatTag )
        {
            if( ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  == MEDIASUBTYPE_PCM ||
                ((PWAVEFORMATIEEEFLOATEX)pwfx)->SubFormat == MEDIASUBTYPE_IEEE_FLOAT ||
                ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  == MEDIASUBTYPE_DRM_Audio )
            {
                return true;
            }
        }
        else if( WAVE_FORMAT_PCM == pwfx->wFormatTag ||
                 WAVE_FORMAT_DRM == pwfx->wFormatTag ||
                 WAVE_FORMAT_IEEE_FLOAT == pwfx->wFormatTag )
        {
            return true;
        }
    }
            
    // so far, WAVE_FORMAT_DOLBY_AC3_SPDIF (and it's equivalents) is the only one that we 
    // allow through that isn't natively supported by kmixer
    return false;
}

//
// CanWriteSilence - do we know how to write silence for this format?
// 
bool CanWriteSilence( PWAVEFORMATEX pwfx )
{
    if( pwfx )
    {
        if( WAVE_FORMAT_EXTENSIBLE == pwfx->wFormatTag )
        {
            //
            // from the Non-pcm audio white paper:
            // "Wave format tags 0x0092, 0x0240 and 0x0241 are identically defined as 
            // AC3-over-S/PDIF (these tags are treated completely identically by many 
            // DVD applications)."
            //
            if( ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat == MEDIASUBTYPE_PCM ||
                ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat == MEDIASUBTYPE_DOLBY_AC3_SPDIF ||
                ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat == MEDIASUBTYPE_RAW_SPORT ||
                ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat == MEDIASUBTYPE_SPDIF_TAG_241h )
            {
                return true;
            }
        }
        else if( WAVE_FORMAT_PCM == pwfx->wFormatTag ||
                 WAVE_FORMAT_DOLBY_AC3_SPDIF == pwfx->wFormatTag ||
                 WAVE_FORMAT_RAW_SPORT == pwfx->wFormatTag ||
                 0x241 == pwfx->wFormatTag )
        {
            return true;
        }
    }        
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\passthru.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

//-----------------------------------------------------------------------------
// declares a CPosPassThru object specific to the audio renderer that
// adds the ability to monitor the rate being set
//-----------------------------------------------------------------------------

#ifndef _CARPOSPASSTHRU_H_
#define _CARPOSPASSTHRU_H_

class CWaveOutInputPin;

// Adds the ability to monitor rate setting

class CARPosPassThru : public CPosPassThru
{
private:
    typedef CPosPassThru inherited;

    CWaveOutFilter      *const m_pFilter;
    CWaveOutInputPin    *const m_pPin;

public:

    CARPosPassThru( CWaveOutFilter *pWaveOutFilter, HRESULT*phr, CWaveOutInputPin *pPin);

    // we override rate handling so that our filter can verify what is
    // going on

    // From IMediaSeeking
    STDMETHODIMP SetRate( double dRate );

    // From IMediaPosition
    STDMETHODIMP put_Rate( double dRate );

};

#endif // _CARPOSPASSTHRU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\wave.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// Implements the CWaveOutDevice class based on waveOut APIs.
//----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Includes.
//-----------------------------------------------------------------------------
#include <streams.h>
#define _AMOVIE_DB_
#include <decibels.h>
#include "waveout.h"
#include "wave.h"
#include <limits.h>
#include <mmreg.h>

//
// Define the dynamic setup structure for filter registration.  This is
// passed when instantiating an audio renderer in its waveout guise.
// Note: waveOutOpPin is common to direct sound and waveout renderers.
//

// marked MERIT_DO_NOT_USE because we don't want RenderFile to try
// this filter in an upgrade over AM 1.0; we want it to use the audio
// renderer category.
AMOVIESETUP_FILTER wavFilter = { &CLSID_AudioRender	// filter class id
                                 , L"Audio Renderer"	// filter name
                                 , MERIT_DO_NOT_USE  	// dwMerit
                                 , 1
                                 , &waveOutOpPin };


//-----------------------------------------------------------------------------
// CreateInstance for the WaveOutDevice. This will create a new WaveOutDevice
// and a new CWaveOutFilter, passing it the sound device.
//-----------------------------------------------------------------------------
CUnknown *CWaveOutDevice::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    // make sure that there is at least one audio card in the system. Fail
    // the create instance if not.
    if (0 == waveOutGetNumDevs ())
    {
        *phr = VFW_E_NO_AUDIO_HARDWARE ;
        return NULL ;
    }

    return CreateRendererInstance<CWaveOutDevice>(pUnk, &wavFilter, phr);
}

//-----------------------------------------------------------------------------
// CWaveOutDevice constructor.
//-----------------------------------------------------------------------------
CWaveOutDevice::CWaveOutDevice ()
    : m_lVolume ( 0 )
    , m_lBalance ( 0 )
    , m_wLeft ( 0xFFFF )
    , m_wRight ( 0xFFFF )
    , m_dwWaveVolume ( 0 )
    , m_fHasVolume ( 0 )
    , m_hWaveDevice ( 0 )
	, m_fBalanceSet ( FALSE )
    , m_iWaveOutId ( WAVE_MAPPER )
{
    SetResourceName();
}

//-----------------------------------------------------------------------------
// CWaveOutDevice destructor.
//
//-----------------------------------------------------------------------------
CWaveOutDevice::~CWaveOutDevice ()
{
}

//-----------------------------------------------------------------------------
// waveOutClose.
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutClose ()
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Called to close when not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveOutClose - device is not open")));
        return MMSYSERR_ERROR ;
    }

    MMRESULT mmr = ::waveOutClose (m_hWaveDevice) ;
    m_hWaveDevice = 0;
    return mmr;
}
//-----------------------------------------------------------------------------
// waveOutDoesRSMgmt.
//-----------------------------------------------------------------------------
LPCWSTR CWaveOutDevice::amsndOutGetResourceName ()
{
    return m_wszResourceName;
}
//-----------------------------------------------------------------------------
// waveGetDevCaps
//
//-----------------------------------------------------------------------------

BOOL fGetCaps = TRUE;
WAVEOUTCAPS caps1;
WAVEOUTCAPS caps2;

MMRESULT CWaveOutDevice::amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc)
{
    if (fGetCaps) {
	fGetCaps = FALSE;
	::waveOutGetDevCaps (m_iWaveOutId, &caps1, sizeof(caps1)) ;
	::waveOutGetDevCaps (0, &caps2, sizeof(caps2)) ;
    }
    MMRESULT mmr = ::waveOutGetDevCaps (m_iWaveOutId, pwoc, cbwoc) ;
    if (0 == mmr )
    {
        //save volume capabilities
        m_fHasVolume = pwoc->dwSupport & (WAVECAPS_VOLUME | WAVECAPS_LRVOLUME);
    }
    return mmr ;
}

//-----------------------------------------------------------------------------
// waveOutGetErrorText
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText)
{
    return ::waveOutGetErrorText (mmrE, pszText, cchText) ;
}

//-----------------------------------------------------------------------------
// waveOutGetPosition
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos)
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutGetPosition - device is not open")));
        return MMSYSERR_NODRIVER ;
    }

    const MMRESULT mmr = ::waveOutGetPosition (m_hWaveDevice, pmmt, cbmmt) ;
    if (MMSYSERR_NOERROR != mmr) {
        DbgLog((LOG_ERROR,0,TEXT("waveoutGetPosition - FAILED")));
        DbgBreak("Failed to get the device position.");
    }
    return mmr;
}

//-----------------------------------------------------------------------------
// waveOutGetBalance
//
//-----------------------------------------------------------------------------
HRESULT CWaveOutDevice::amsndOutGetBalance (LPLONG plBalance)
{
    // some validation.
#if 0 // use the mixer
    if (m_hWaveDevice == 0)
    {
        DbgLog((LOG_ERROR,2,TEXT("waveoutGetBalance - device is not open")));
	*plBalance = 0;
        return MMSYSERR_NODRIVER ;
    }
#endif
    HRESULT hr = GetVolume();
    *plBalance = m_lBalance;
    return hr ;
}

//-----------------------------------------------------------------------------
// waveOutGetVolume
//
//-----------------------------------------------------------------------------
HRESULT CWaveOutDevice::amsndOutGetVolume (LPLONG plVolume)
{
    // some validation.
#if 0 // use the mixer
    if (m_hWaveDevice == 0)
    {
        DbgLog((LOG_ERROR,2,TEXT("waveoutGetVolume - device is not open")));
	*plVolume = 0;
        return MMSYSERR_NODRIVER ;
    }
#endif
    HRESULT hr = GetVolume();
    *plVolume = m_lVolume;
    return hr ;
}

HRESULT CWaveOutDevice::amsndOutCheckFormat(const CMediaType *pmt, double dRate)
{
    // reject non-Audio type
    if (pmt->majortype != MEDIATYPE_Audio) {
	return E_INVALIDARG;
    }

    // if it's MPEG audio, we want it without packet headers.
    if (pmt->subtype == MEDIASUBTYPE_MPEG1Packet) {
	return E_INVALIDARG;
    }

    if (pmt->formattype != FORMAT_WaveFormatEx &&
        pmt->formattype != GUID_NULL) {
        return E_INVALIDARG;
    }

    //
    // it would always be safer to explicitly check for those formats
    // we support rather than tossing out the ones we know are not
    // supported.  Otherwise, if a new format comes along we could
    // accept it here but barf later.
    //

    if (pmt->FormatLength() < sizeof(PCMWAVEFORMAT))
	return E_INVALIDARG;

    // adjust based on rate that has been chosen, or don't bother?
    UINT err = amsndOutOpen(
        NULL,
        (WAVEFORMATEX *) pmt->Format(),
        dRate,
        0,                      // pnAvgBytesPerSec
        0,                      // dwCallback
        0,                      // dwCallBackInstance
        WAVE_FORMAT_QUERY);

    if (err != 0) {
#ifdef DEBUG
	TCHAR message[100];
	waveOutGetErrorText(err, message, sizeof(message)/sizeof(TCHAR));
	DbgLog((LOG_ERROR,1,TEXT("Error checking wave format: %u : %s"), err, message));
#endif
	if (WAVERR_BADFORMAT == err) {
	    return VFW_E_UNSUPPORTED_AUDIO;
	} else {
	    return VFW_E_NO_AUDIO_HARDWARE;
	}

    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// waveOutOpen
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
				       double dRate, DWORD *pnAvgBytesPerSec, DWORD_PTR dwCallBack,
				       DWORD_PTR dwCallBackInstance, DWORD fdwOpen)
{
    WAVEFORMATEX wfxPCM;
    
#ifdef TEST_SLOWFAST_WAVEOUT_RATES
    // for testing only
    if(pnAvgBytesPerSec) {
        *pnAvgBytesPerSec = pwfx->nAvgBytesPerSec;
    }

    double dAdjust = GetProfileIntA("wave", "Percent", 0) / 100.;
    if( 1 == GetProfileIntA("wave", "Slower", 0) )
        dAdjust *= -1;
        
    dRate = 1.0 + dAdjust;
#endif
    
    if (dRate != 1.0)
    {
	if (!(pwfx->wFormatTag == WAVE_FORMAT_PCM || 
	      pwfx->wFormatTag == WAVE_FORMAT_MULAW || 
	      pwfx->wFormatTag == WAVE_FORMAT_ALAW)) 
		return WAVERR_BADFORMAT;

	DbgLog((LOG_TRACE,1,TEXT("Waveout: Playing at %d%% of normal speed"), (int) (dRate * 100) ));
	wfxPCM = *pwfx;
	pwfx = &wfxPCM;

	const double dSamplesPerSecond = wfxPCM.nSamplesPerSec * dRate;
	if (dSamplesPerSecond / wfxPCM.nBlockAlign > ULONG_MAX - 1) return WAVERR_BADFORMAT;
	wfxPCM.nSamplesPerSec = (DWORD) dSamplesPerSecond;
	//  Make sure it's exactly right for PCM or it won't work
	wfxPCM.nAvgBytesPerSec = wfxPCM.nSamplesPerSec * wfxPCM.nBlockAlign;
    }
    
#ifndef TEST_SLOWFAST_WAVEOUT_RATES
    // always do this except when testing with different rates

    // report adjusted nAvgBytesPerSec
    if(pnAvgBytesPerSec) {
        *pnAvgBytesPerSec = pwfx->nAvgBytesPerSec;
    }
#endif    

    // some validation.  If the device is already open we have an error,
    // with the exception that QUERY calls are permitted.

#if 0
!! We do not use WAVE_FORMAT_DIRECT at present.  More work is required.
!! The problem manifests itself with 8 bit sound cards, and uncompressed
!! 16 bit PCM data.  The ACM wrapper gets inserted but does NOT get around
!! to proposing an 8 bit format.

	// use WAVE_FORMAT_DIRECT to make use of the ACM mapper explicit
	// if we are on a level of the OS that supports that flag
        if (g_osInfo.dwMajorVersion >= 4) {
            fdwOpen |= WAVE_FORMAT_DIRECT;
        }
#endif
    
    if (!(fdwOpen & WAVE_FORMAT_QUERY) && (m_hWaveDevice != 0))
    {
        DbgBreak("Invalid - device ALREADY open - logic error");
        DbgLog((LOG_ERROR,1,TEXT("waveoutOpen - device is already open")));
        return MMSYSERR_ERROR ;
    }


    MMRESULT mmr =
           ::waveOutOpen (phwo, m_iWaveOutId, pwfx, dwCallBack, dwCallBackInstance, fdwOpen) ;

    if (MMSYSERR_NOERROR == mmr && phwo && !(fdwOpen & WAVE_FORMAT_QUERY)) {
        m_hWaveDevice = *phwo;
    }

    return mmr;
}
//-----------------------------------------------------------------------------
// waveOutPause
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutPause ()
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutPause - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutPause (m_hWaveDevice) ;
}

//-----------------------------------------------------------------------------
// waveOutPrepareHeader
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutPrepareHeader - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutPrepareHeader (m_hWaveDevice, pwh, cbwh) ;
}

//-----------------------------------------------------------------------------
// waveOutReset
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutReset ()
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutReset - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutReset (m_hWaveDevice) ;
}

//-----------------------------------------------------------------------------
// waveOutBreak
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutBreak ()
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutBreak - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutReset (m_hWaveDevice) ;
}

//-----------------------------------------------------------------------------
// waveOutRestart
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutRestart ()
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutRestart - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutRestart (m_hWaveDevice) ;
}
//-----------------------------------------------------------------------------
// waveOutSetBalance
//
//-----------------------------------------------------------------------------
HRESULT CWaveOutDevice::amsndOutSetBalance (LONG lBalance)
{
    HRESULT hr ;
    if (lBalance == m_lBalance)
    {
	hr = NOERROR;  // no change
    }
    else
    {
	// Save the new setting
	m_lBalance = lBalance;
	m_fBalanceSet = TRUE;
	// go and calculate the channel attenuation
	SetBalance();
	hr = PutVolume(); // Talks to the device... if it is open
    }
    return hr;
}
//-----------------------------------------------------------------------------
// waveOutSetVolume
//
//-----------------------------------------------------------------------------
HRESULT CWaveOutDevice::amsndOutSetVolume (LONG lVolume)
{
    // map volume onto decibel range
    DWORD dwAmp = DBToAmpFactor( lVolume );
    m_lVolume = lVolume;

    // now that the absolute volume has been set we should adjust
    // the balance to maintain the same DB separation
    SetBalance ();
    return PutVolume (); // Talks to the device... if it is open
}
//-----------------------------------------------------------------------------
// waveOutUnprepareHeader
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutUnprepareHeader - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutUnprepareHeader (m_hWaveDevice, pwh, cbwh) ;
}

//-----------------------------------------------------------------------------
// waveOutWrite
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, REFERENCE_TIME const *pStart, BOOL bIsDiscontinuity)
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutWrite - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutWrite (m_hWaveDevice, pwh, cbwh) ;
}

HRESULT CWaveOutDevice::amsndOutLoad(IPropertyBag *pPropBag)
{
    if(m_hWaveDevice != 0)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    // caller makes sure we're not running
    
    VARIANT var;
    var.vt = VT_I4;
    HRESULT hr = pPropBag->Read(L"WaveOutId", &var, 0);
    if(SUCCEEDED(hr))
    {
        m_iWaveOutId = var.lVal;
        SetResourceName();
    }
    else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    return hr;
}

// use a version number instead of size to reduce chances of picking
// an invalid device from a 1.0 grf file
struct WaveOutPersist
{
    DWORD dwVersion;
    LONG iWaveOutId;
};


HRESULT  CWaveOutDevice::amsndOutWriteToStream(IStream *pStream)
{
    WaveOutPersist wop;
    wop.dwVersion = 200;
    wop.iWaveOutId = m_iWaveOutId;
    return pStream->Write(&wop, sizeof(wop), 0);
}

HRESULT  CWaveOutDevice::amsndOutReadFromStream(IStream *pStream)
{
    if(m_hWaveDevice != 0)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    // on any error, default to the wave mapper because we may have
    // found the old audio renderer which has the same guid
    m_iWaveOutId = WAVE_MAPPER;

    // caller makes sure we're not running
    WaveOutPersist wop;
    HRESULT hr = pStream->Read(&wop, sizeof(wop), 0);
    if(SUCCEEDED(hr))
    {
        if(wop.dwVersion == 200)
        {
            m_iWaveOutId = wop.iWaveOutId;
        }
    }

    hr = S_OK;
    SetResourceName();

    return hr;
}

int CWaveOutDevice::amsndOutSizeMax()
{
    return sizeof(WaveOutPersist);
}


//-----------------------------------------------------------------------------
// Internal function to get volume.
//-----------------------------------------------------------------------------

HRESULT CWaveOutDevice::GetVolume()
{
    // Write out the current Audio volume
    // ...query the device
    // assumes the device is connected...
    // if not we will query the volume from the mixer (probably)

    HRESULT hr ;
    DWORD amp = 0;
    HWAVEOUT hWaveDevice ;

    // if the wave device has not been opened yet, we should use the WAVE_MAPPER
    // as the handle instead of 0.

    hWaveDevice = (m_hWaveDevice) ? m_hWaveDevice : ((HWAVEOUT)IntToPtr(m_iWaveOutId)) ;
    DWORD err = ::waveOutGetVolume(hWaveDevice, (LPDWORD)&amp);

    // if we are on NT 3.51 and the device is not open we get an error
    // when using an ID == WAVE_MAPPER to read the volume.  Retry with
    // device 0
    if (err == MMSYSERR_NOTSUPPORTED && !m_hWaveDevice) {
	err = ::waveOutGetVolume(0, (LPDWORD)&amp);
    }

    DbgLog((LOG_TRACE, 5, TEXT("waveOutGetVolume: vol = %lx"), amp));

    if (MMSYSERR_NOERROR == err)
    {
        hr = NOERROR ;
	m_wLeft = LOWORD(amp);
	m_wRight = HIWORD(amp);
	if (!(m_fHasVolume & (WAVECAPS_LRVOLUME)))
        {
	    // for mono cards map Left to Right
#ifdef DEBUG
	    // assert that the volume we want is in the low word
	    if (amp)
            {
		ASSERT(m_wLeft);
	    }
#endif
	    m_wRight = m_wLeft;
	}
	m_dwWaveVolume = amp;
	
	// map volume onto decibel range
	DWORD dwAmp = max(m_wLeft, m_wRight);
	m_lVolume = AmpFactorToDB( dwAmp );

	// remember to adjust the Balance value...
	if(m_fBalanceSet)
		SetBalance();
	else
		GetBalance();

    }
    else
    {
	DbgLog((LOG_ERROR, 5, "Error %d from waveoutGetVolume", err));
        hr = E_FAIL ;
    }
    return hr ;
}

//-----------------------------------------------------------------------------
// Internal routine to set the volume.  No parameter checking...
//-----------------------------------------------------------------------------
HRESULT CWaveOutDevice::PutVolume ()
{
    if (m_hWaveDevice)
    {
	DWORD Volume = MAKELONG(m_wLeft, m_wRight);
	if (!(m_fHasVolume & (WAVECAPS_LRVOLUME)))
        {
	    // mono cards: LEFT volume only - HIWORD might be ignored... but
	    Volume = m_wLeft;
	}

        DbgLog((LOG_TRACE, 5, TEXT("waveOutSetVolume: vol = %lx"), Volume));

        MMRESULT mmr = ::waveOutSetVolume(m_hWaveDevice, Volume);
        if (mmr == MMSYSERR_NOERROR)
            return NOERROR ;
        else
            return E_FAIL ;
    }
    else
    {
	// no current wave device.  We have remembered the volume values
	return(NOERROR);
    }
}

//-----------------------------------------------------------------------------
// Internal routine to get the Balance given right/left amp factors
//-----------------------------------------------------------------------------
void CWaveOutDevice::GetBalance()
{
	if (m_wLeft == m_wRight)
    {
	    m_lBalance = 0;
	}
    else
    {
	    // map Balance onto decibel range
	    LONG lLDecibel = AmpFactorToDB( m_wLeft );    
		LONG lRDecibel = AmpFactorToDB( m_wRight );

	    // note: m_lBalance < 0:  right is quieter
	    //       m_lBalance > 0:  left is quieter
	    m_lBalance = lRDecibel - lLDecibel;
	}
}

//-----------------------------------------------------------------------------
// Internal routine to set the Balance.
//-----------------------------------------------------------------------------
void CWaveOutDevice::SetBalance ()
{
    //
    // Calculate scaling factors for waveout API
    //
    LONG lTotalLeftDB, lTotalRightDB ;

    if (m_lBalance >= 0)
    {
	// left is attenuated
	lTotalLeftDB	= m_lVolume - m_lBalance ;
	lTotalRightDB	= m_lVolume;
    }
    else
    {
	// right is attenuated
	lTotalLeftDB	= m_lVolume;
	lTotalRightDB	= m_lVolume - (-m_lBalance);
    }

    DWORD dwLeftAmpFactor, dwRightAmpFactor;
    dwLeftAmpFactor   = DBToAmpFactor(lTotalLeftDB);
    dwRightAmpFactor  = DBToAmpFactor(lTotalRightDB);

    if (m_fHasVolume & (WAVECAPS_LRVOLUME))
    {
	// Set stereo volume
	m_dwWaveVolume = dwLeftAmpFactor;
	m_dwWaveVolume |= dwRightAmpFactor << 16;
    }
    else
    {
	// Average the volume
	m_dwWaveVolume = dwLeftAmpFactor;
	m_dwWaveVolume += dwRightAmpFactor;
	m_dwWaveVolume /= 2;
    }
    m_wLeft = WORD(dwLeftAmpFactor);
    m_wRight = WORD(dwRightAmpFactor);
}

//-----------------------------------------------------------------------------

void CWaveOutDevice::SetResourceName()
{
    wsprintfW(m_wszResourceName, L".\\WaveOut\\%08x", m_iWaveOutId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\slave.cpp ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved
// Slaving class for DirectShow audio renderer

#include <streams.h>

#include "waveout.h"
#include "dsr.h"

// ks headers only needed for KSAUDFNAME_WAVE_OUT_MIX hack for Brooktree
#include <ks.h>                
#include <ksmedia.h>                

//#pragma message (REMIND("Turn down clock slave debug level!!"))

#ifdef DEBUG
const DWORD DBG_LEVEL_CLOCK_SYNC_DETAILS     = 8;
const DWORD DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS = 4;
#endif

extern LONGLONG BufferDuration(DWORD nAvgBytesPerSec, LONG lData);

// allow tuning via registry while best settings are being ironed out
const TCHAR g_szhkSlaveSettings[] =                   TEXT( "Software\\Microsoft\\DirectShow\\ClockSlave");
const TCHAR g_szSlaveSettings_ThresholdMS[] =         TEXT( "ThresholdMS" );
const TCHAR g_szSlaveSettings_PercentErrorDecay[] =   TEXT( "PercentErrorDecay" );
const TCHAR g_szSlaveSettings_ClockAdjustLimit[] =    TEXT( "MaxClockAdjustDivisor" );
const TCHAR g_szSlaveSettings_ClockAdjustStepSize[] = TEXT( "ClockAdjustStepSize" );
const TCHAR g_szSlaveSettings_woLatencyThresholdMS[] = TEXT( "woLatencyThresholdMS" );



//-----------------------------------------------------------------------------
//
// Audio Renderer Slaving class
//
//-----------------------------------------------------------------------------

// default frequency adjustment constants
#define MIN_MAX_CLOCK_DIVISOR    80      // (1/160) * 2 = .00625*2 = .0125 (1.25%)
#define CLOCK_ADJUST_RESOLUTION  (160*2*2) // use a 1/720th granularity
                                         // (Eventually will be determined via an API or property set)
                                         // kmixer's resolution for high quality SRC is 160th of the sample rate.
                                         // For "PC" quality SRC, it's 1/1096 the native sample rate.
                                         // For minimizing pitch change we force the PC SRC and  a 1/(160*4) step size.
#define ERROR_DECAY_FACTOR       .99     // used to bring the last max or min error which
                                         // initiated a freq adjustment back down

#define SLAVE_ADJUST_THRESHOLD          200000  // 20ms tolerance
#define WAVEOUT_SLAVE_LATENCY_THRESHOLD 800000  // latency goal for waveOut slaving, for non-WDM devices
                                                // seems like we need to use ~80ms


//-----------------------------------------------------------------------------
//
// CWaveSlave
//
// Constructor 
//
//-----------------------------------------------------------------------------
CWaveSlave::CWaveSlave
(
    CWaveOutFilter *pWaveOutFilter,
    CWaveOutInputPin *pWaveOutInputPin
) :
    m_pFilter(pWaveOutFilter),
    m_pPin(pWaveOutInputPin),
    m_rtAdjustThreshold( SLAVE_ADJUST_THRESHOLD ),
    m_fltAdjustStepFactor( (float) 1.0 / CLOCK_ADJUST_RESOLUTION ), 
    m_fltMaxAdjustFactor( (float) 1.0 / MIN_MAX_CLOCK_DIVISOR ),
    m_fltErrorDecayFactor( (float) ERROR_DECAY_FACTOR ),
    m_rtWaveOutLatencyThreshold( WAVEOUT_SLAVE_LATENCY_THRESHOLD )
{
    ASSERT(pWaveOutFilter != NULL);
    ASSERT(pWaveOutInputPin != NULL);

    // allow for the ability to tweak some of the params from the registry
    HKEY hkSlaveParams;
    LONG lResult = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        g_szhkSlaveSettings,
        0,                      
        KEY_READ,
        &hkSlaveParams);
    if(lResult == ERROR_SUCCESS)
    {
        DWORD dwType, dwVal, dwcb;
        
        // error decay
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkSlaveParams,
            g_szSlaveSettings_PercentErrorDecay,
            0,               
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            ASSERT( 0 < dwVal && 100 > dwVal );
            if( 0 < dwVal && 100 > dwVal )
            {
                m_fltErrorDecayFactor = dwVal / (float)100.;
            }
        }
        
        // threshold for when to adjust frequency
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkSlaveParams,
            g_szSlaveSettings_ThresholdMS,
            0,                
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            if( 0 < dwVal )
            {
                m_rtAdjustThreshold = ( dwVal * ( UNITS / MILLISECONDS ) );
            }
        }
        
        // frequency adjustment step size
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkSlaveParams,
            g_szSlaveSettings_ClockAdjustStepSize,
            0,                
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            if( 0 < dwVal )
            {
                m_fltAdjustStepFactor = (float)1.0 / dwVal;
            }
        }

        // limit on frequency adjustments
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkSlaveParams,
            g_szSlaveSettings_ClockAdjustLimit,
            0,              
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            if( 0 < dwVal )
            {
                m_fltMaxAdjustFactor = (float) 1.0 / dwVal;
            }
        }
      
        // maximum waveOut device latency
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkSlaveParams,
            g_szSlaveSettings_woLatencyThresholdMS,
            0,              
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            if( 0 < dwVal )
            {
                m_rtWaveOutLatencyThreshold = ( dwVal * ( UNITS / MILLISECONDS ) );
            }
        }
                            
        EXECUTE_ASSERT(RegCloseKey(hkSlaveParams) == ERROR_SUCCESS);
    }
    
    DbgLog((LOG_TRACE, 4, TEXT("wo:Slaving - Clock slave parameters:") ) );
    DbgLog((LOG_TRACE, 4, TEXT("     Error threshold - %dms"), m_rtAdjustThreshold/10000 ) );
    DbgLog((LOG_TRACE, 4, TEXT("     Clock adjustment step - %s"), CDisp(m_fltAdjustStepFactor) ) );
    DbgLog((LOG_TRACE, 4, TEXT("     Clock adjustment limit - %s"), CDisp(m_fltMaxAdjustFactor) ) );
    DbgLog((LOG_TRACE, 4, TEXT("     Percent Error Decay - %s"), CDisp(m_fltErrorDecayFactor) ) );
    DbgLog((LOG_TRACE, 4, TEXT("     Latency threshold for WaveOut slaving - %dms"), m_rtWaveOutLatencyThreshold/10000 ) );

    ResumeSlaving( TRUE ); // reset all params
}

//-----------------------------------------------------------------------------
//
// CWaveSlave::GetMasterClockTime
//
// Get the current master clock time by using the slave mode to determine how to read
// this time.
//
//-----------------------------------------------------------------------------
REFERENCE_TIME CWaveSlave::GetMasterClockTime
(
    REFERENCE_TIME rtStart, 
    BOOL bReset
)
{
    REFERENCE_TIME rtMasterClockTime = 0;
    if( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS )
    {
        // slave to buffer fullness
        
        // start time for this sample, based on bytes delivered and default rate
        if( bReset )
            rtMasterClockTime = 0;
        else                
            rtMasterClockTime = m_rtLastMasterClockTime + m_pPin->m_Stats.m_rtLastBufferDur;
            
        m_rtLastMasterClockTime = rtMasterClockTime; // remember this, is this already saved somewhere else??
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slaving to buffer fullness") ) );
    }                
    else if( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_TIMESTAMPS )
    {
        // slave to incoming timestamps
   
        // start time for this sample
        rtMasterClockTime = rtStart;
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slaving to input timestamps") ) );
    }
    else if( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_GRAPH_CLOCK )
    {
        // slave to external clock times
        HRESULT hr = m_pFilter->m_pClock->GetTime(&rtMasterClockTime);
        rtMasterClockTime -= m_pFilter->m_tStart;
        ASSERT(SUCCEEDED(hr));
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slaving to external clock times") ) );
    }
    else
        ASSERT( FALSE );
        
    return rtMasterClockTime;
}

//-----------------------------------------------------------------------------
//
// CWaveSlave::GetSlaveClockTime
//
// Get the current slave clock time by using the slave mode to determine how to read
// this time. 
//
//  slave mode                  slave time                  1st slave time
//  ---------------------------------------------------------------------------------
//  LIVEFULLNESS                wave device position        current device position
//                              including silence written   including silence
//
//  EXTERNALCLOCK_LIVE          same as LIVEFULLNESS
//                              (problems arise handling 
//                              silence gaps when using 
//                              audio clock generated from
//                              timestamps)
//                                      
//  EXTERNALCLOCK               audio clock generated from  timestamp of current
//                              timestamps                  sample to be played
//
//  LIVETIMESTAMPS              ?later
//  
//-----------------------------------------------------------------------------
REFERENCE_TIME CWaveSlave::GetSlaveClockTime
(
    REFERENCE_TIME rtStart, 
    BOOL bReset
)
{
    REFERENCE_TIME rtSlaveClockTime = 0;
    if( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS )
    {
        // use bytes played as device clock position
        rtSlaveClockTime = m_pFilter->m_pRefClock->ReadDevicePosition( TRUE );
        if( bReset )
        {   
            m_rtInitSlaveClockTime = rtSlaveClockTime;
            rtSlaveClockTime = 0;
            DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - Reset, slave clock time %dms, InitSlaveClockTime %dms"),
                    (LONG)( rtSlaveClockTime / 10000 ), (LONG)( m_rtInitSlaveClockTime / 10000 ) ) );
        }            
        else
        {
            rtSlaveClockTime -= m_rtInitSlaveClockTime;
        }            
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slave clock reflects bytes played (including silence)") ) );
    }                
    else if( ( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_GRAPH_CLOCK ) &&
             ( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA   ) )
    {
        //
        // use bytes played as well in this case, since capture timestamps
        // tend to fluctuate enough to make using a clock generated from
        // timestamps less accurate. Also there are problems when silence gets
        // inserted into the stream (we notice silence added because of starvation, but
        // we don't notice when we're playing too fast).
        //
        // we're keeping this case separate from the buffer fullness case
        // (which is handled the same way), because we may want to reconsider whether 
        // to the clock generated from timestamps at a later time
        //
        if( bReset )
        {       
            m_bLiveButDataPrequeued = FALSE; // reset
        
            // make sure device position reflects any data already queued
            rtSlaveClockTime = m_pFilter->m_pRefClock->ReadDevicePosition( );
            if ( ( 0 == m_pFilter->m_lBuffers ) && ( rtSlaveClockTime == 0 ) )
            {            
                //
                // Expected case for live data - i.e., no data was prequeued
                //
                // use this sample's rtStart as the starting device position
                //
                m_rtInitSlaveClockTime = rtSlaveClockTime - rtStart;
                DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - Reset1, slave clock time %dms, InitSlaveClockTime %dms"),
                        (LONG)( rtSlaveClockTime / 10000 ), (LONG)( m_rtInitSlaveClockTime / 10000 ) ) );
            }
            else
            {
                //
                // The abnormal case! Where an upstream filter marked itself as live (by
                // supporting IAMPushSource) but then went and delivered data in pause mode.
                // Unfortunately the wmp source filter does this and we'll try to work with it.
                //
                // So in this case rtSlaveClockTime reflects the starting time of any pre-Run data
                //
                m_rtInitSlaveClockTime = rtSlaveClockTime; 
                m_bLiveButDataPrequeued = TRUE;
            
                DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - Reset2, slave clock time %dms, InitSlaveClockTime %dms"),
                        (LONG)( rtSlaveClockTime / 10000 ), (LONG)( m_rtInitSlaveClockTime / 10000 ) ) );
                
            }                        
        }
        else if( !m_bLiveButDataPrequeued )
        {        
            rtSlaveClockTime = m_pFilter->m_pRefClock->ReadDevicePosition( TRUE );
            DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slave clock time %dms, InitSlaveClockTime %dms"),
                    (LONG)( rtSlaveClockTime / 10000 ), (LONG)( m_rtInitSlaveClockTime / 10000 ) ) );
            rtSlaveClockTime -= m_rtInitSlaveClockTime;
        }            
        else
        {
            //
            // Again, the exceptional case, where a live source sent data in pause (wmp)
            //
            rtSlaveClockTime = m_pFilter->m_pRefClock->ReadDevicePosition( );
            DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slave clock time %dms, InitSlaveClockTime %dms"),
                    (LONG)( rtSlaveClockTime / 10000 ), (LONG)( m_rtInitSlaveClockTime / 10000 ) ) );
        }        
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slave clock reflects bytes played (including silence)") ) );
    }
    else if( m_fdwSlaveMode & ( AM_AUDREND_SLAVEMODE_GRAPH_CLOCK | AM_AUDREND_SLAVEMODE_TIMESTAMPS ) )
    {
        // use the clock that we generate based on incoming timestamps
        
        // make sure device position reflects any data already queued
        rtSlaveClockTime = m_pFilter->m_pRefClock->ReadDevicePosition( );
        if( bReset && 
            ( 0 == m_pFilter->m_lBuffers ) && 
            ( rtSlaveClockTime == 0 ) )
        {            
            // if no data has been queued at all then use this tStart as 
            // the starting device position, since we haven't yet updated our
            // generated clock with this timestamp
            rtSlaveClockTime = rtStart; 
        }
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slave clock reflects timestamp generated clock") ) );
    }
    else
        ASSERT( FALSE );
        
    return rtSlaveClockTime;
}

//-----------------------------------------------------------------------------
//
// CWaveSlave::AdjustSlaveClock
//
// Check the device clock progress against the master clock and determine if any
// adjustment is required. For the dsound renderer this attempts to match the
// device clock's rate to the master clock rate by varying the audio playback
// rate. In the waveOut renderer case, if the device gets too far behind we drop 
// samples to try to keep up.
// 
// Details about the frequency slaving algorithm, taken from the DirectShow PushClk spec:
//
// At a given time t we have 2 clocks:
//
// S(t) - the source clock
// R(t) - the renderer clock.
//
// For simplification of notation the time the clock shows is just the clock name.  
// We can use the differential operator to describe the current clock rate - eg D(R)(t).
// 
// The current algorithm applies a rate correction when the accumulated clock difference 
// reaches an adaptive threshold. The rate change is a fixed increment irrespective of 
// the relative clock rates:
// 
// Cumulative clock difference:  C(t) = (R(t) - S(t)) - (R(0) - S(0))
// High threshold:  H(t) (>= 0)
// Low threshold: L(t) (<= 0)
// Rate of R - D(R)
// If  C(t) < L(t) - adjustthreshold 
// then D(R) -= adjuststep, L(t) = C(t) 
// else L(t) *= errordecay
// Else if C(t) > H(t) + adjustthreshold 
// then D(R) += adjuststep, H(t) = C(t)
// else H(t) *= errordecay
//
// Example values are:
// adjustthreshold = .002 seconds
// adjuststep = 1/1000
// errordecay = .99
// L(0) = H(0) = 0
// 
// Note how the thresholds are adjusted to try and pull in the error over time but 
// relaxed when we step outside the current thresholds to avoid too rapid frequency 
// switching.
//
// Parameters:
//      const REFERENCE_TIME& tStart  - start time for current sample
//      LONG  *pcbData,               - size of current buffer, UPDATED to amount of
//                                      of buffer data to use (when data is to be 
//                                      dropped)
//      BOOL  bDiscontinuity          - does current sample have discontinuity bit set?
//  
// 
// Returns:
//      S_OK    - if no error. Note that pcbData may be updated if data is to be dropped.
//      S_FALSE - if entire buffer is to be dropped
//
//      error code, otherwise
//
// Arguments:
//    tStart
//    *pcbData, 
//    bDiscontinuity
//
//-----------------------------------------------------------------------------

HRESULT CWaveSlave::AdjustSlaveClock
( 
    const REFERENCE_TIME& tStart, 
    LONG  *pcbData,               
    BOOL  bDiscontinuity          
)
{
    ASSERT( m_fdwSlaveMode & ( AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS |
                               AM_AUDREND_SLAVEMODE_GRAPH_CLOCK    |
                               AM_AUDREND_SLAVEMODE_TIMESTAMPS ) );

    ASSERT( pcbData );
    
    WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();
    HRESULT hr = S_OK;
    
#ifdef DEBUG    
    if (m_pFilter->m_fDSound)
    {
        REFERENCE_TIME rtSilence = 0;
        // convert silence bytes to time
        if( 0 < (LONG) PDSOUNDDEV(m_pFilter->m_pSoundDevice)->m_llSilencePlayed )
            rtSilence = BufferDuration( m_pPin->m_nAvgBytesPerSec, (DWORD) PDSOUNDDEV(m_pFilter->m_pSoundDevice)->m_llSilencePlayed );
    
        DbgLog( (LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - Total silence written = %dms")
              , (LONG) (rtSilence/10000) ) );
    }              
#endif  
    if( bDiscontinuity )
    {   
        ResumeSlaving( FALSE );
        DbgLog( ( LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - discontinuity seen") ) );
    }
    
    // get current slave clock time
    REFERENCE_TIME rtSlaveClockTime = GetSlaveClockTime( tStart, bDiscontinuity || m_bResumeSlaving );
     
    // get current master clock time        
    REFERENCE_TIME rtMasterClockTime = GetMasterClockTime( tStart, bDiscontinuity || m_bResumeSlaving );
    DbgLog( ( LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - master clock time %dms, slave time %dms")
          , (LONG)(rtMasterClockTime / 10000)
          , (LONG)(rtSlaveClockTime   / 10000) ) );
          
    if( rtSlaveClockTime < ( 1000 * ( UNITS / MILLISECONDS ) ) || 
        bDiscontinuity || 
        m_bResumeSlaving )
    {
        // initialize slaving parameters until the device makes some progress
        // 'some progress' is defined here as one seconds worth of data
        if( m_bResumeSlaving )
        {   
            // only initialize rate params if we're resuming or beginning
            // note that it may be better to not re-initialize the slave rate
            // on a resume, since we may have already locked in on a better one
            m_dwCurrentRate = pwfx->nSamplesPerSec;
            DWORD dwAdj = (DWORD)( m_dwCurrentRate * m_fltMaxAdjustFactor );
            m_dwMaxClockRate = m_dwCurrentRate + dwAdj ;
            m_dwMinClockRate = m_dwCurrentRate - dwAdj;

            // compute the step size to be used for frequency adjustments (Hz)
            m_dwClockStep = (DWORD)( m_dwCurrentRate * m_fltAdjustStepFactor );
            DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - Slave step size = %d Hz. ")
                  , m_dwClockStep ) );
        }
        
#ifdef CALCULATE_AUDBUFF_JITTER
        RecordBufferLateness( 0 );
#endif        
        m_bResumeSlaving = FALSE; // we're ready to go, turn off resume flag now
                                  // to slave on next sample

        m_rtLastMasterClockTime = rtMasterClockTime;
            
        // don't start adjusting until either the device has made some progress 
        // or we've finished preparing to resume slaving
        return S_OK;
    }     
    
#ifdef LOG_CLOCK_DELTAS
    // compute clock deltas since last buffer, useful for debugging
    REFERENCE_TIME rtMasterClockDelta = rtMasterClockTime - m_rtLastMasterClockTime;
    REFERENCE_TIME rtSlaveClockDelta = rtSlaveClockTime - m_rtLastSlaveClockTime; 
    DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - Slave Clock change = %dms, Master Clock change = %dms"), 
        (LONG)(rtSlaveClockDelta / 10000),
        (LONG)(rtMasterClockDelta/10000) ) );
        
    m_rtLastSlaveClockTime = rtSlaveClockTime;
#endif

    // now get the difference between the 2 clocks
    m_rtErrorAccum = rtMasterClockTime - rtSlaveClockTime;
    if( !m_pFilter->m_fDSound )
    { 
        // if this is waveOut and we're slaving via dropping then advance 
        // the slave clock by the amount of audio we've dropped
        m_rtErrorAccum -= m_rtDroppedBufferDuration;
    }   
    
    DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - m_llAccumError = %dms, High Error = %dms, Low Error = %dms"), 
        (LONG)(m_rtErrorAccum / 10000), 
        (LONG)(m_rtLastHighErrorSeen / 10000),
        (LONG)(m_rtLastLowErrorSeen / 10000) ) );
    
#ifdef CALCULATE_AUDBUFF_JITTER 
    // warning: we may need this, so don't throw away just yet
    hr = RecordBufferLateness( rtMasterClockDelta );
    if( S_FALSE == hr )
    {
        DbgLog( (LOG_TRACE
              , DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS
              , TEXT( "wo:Slaving - buffer is too late or early to use for adjustments" ) ) );
    
        hr = S_OK; // don't act on this buffer, it's way too early or late to use
    }
    else 
#endif    

    if( m_pFilter->m_fDSound )
    {
        // For DSound renderer slave via rate matching
        if( m_rtLastLowErrorSeen - m_rtErrorAccum >= m_rtAdjustThreshold )
        {
            m_rtLastLowErrorSeen = m_rtErrorAccum;
            if( m_rtLastLowErrorSeen < m_rtLowestErrorSeen )
                m_rtLowestErrorSeen = m_rtLastLowErrorSeen;

            m_rtLastHighErrorSeen = 0;
        
            // device is ahead of external clock, slow it down
            if( m_dwCurrentRate > m_dwMinClockRate )
            {
                m_dwCurrentRate -= (LONG) m_dwClockStep;
                        
                DbgLog((LOG_TRACE, 2, TEXT("wo:Slaving - Error is %dms. Decreasing clock rate to = %d")
                      , (LONG)(m_rtErrorAccum / 10000)
                      , (LONG)(m_dwCurrentRate) ) );
              
                PDSOUNDDEV(m_pFilter->m_pSoundDevice)->SetRate(1, m_dwCurrentRate);
            }      
            else
            {
                DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - clock rate already at minimum of %d, but error is %d!")
                      , (LONG)(m_dwCurrentRate)
                      , (LONG)(m_rtErrorAccum / 10000) ) );
            } 
        }      
        else if( m_rtErrorAccum - m_rtLastHighErrorSeen >= m_rtAdjustThreshold )
        {
            m_rtLastHighErrorSeen = m_rtErrorAccum;
            if( m_rtLastHighErrorSeen > m_rtHighestErrorSeen )
                m_rtHighestErrorSeen = m_rtLastHighErrorSeen;

            m_rtLastLowErrorSeen = 0;
        
            // the device is behind, speed it up
            if( m_dwCurrentRate < m_dwMaxClockRate )
            {
                m_dwCurrentRate += (LONG) m_dwClockStep;
            
                DbgLog((LOG_TRACE, 2, TEXT("wo:Slaving - Error is %d ms. Increasing clock rate to = %d")
                      , (LONG)(m_rtErrorAccum / 10000)
                      , (LONG)(m_dwCurrentRate) ) );
                PDSOUNDDEV(m_pFilter->m_pSoundDevice)->SetRate(1, m_dwCurrentRate);
            }            
            else
            {
                DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - clock rate already at maximum of %d, but error is %d")
                      , (LONG)(m_dwCurrentRate)
                      , (LONG)(m_rtErrorAccum / 10000) ) );
            }            
        }
        else if( m_rtLastHighErrorSeen > 0 )
        {
            m_rtLastHighErrorSeen = (LONGLONG)( m_fltErrorDecayFactor * m_rtLastHighErrorSeen );
        }
        else if( m_rtLastLowErrorSeen < 0 )
        {
            m_rtLastLowErrorSeen = (LONGLONG)( m_fltErrorDecayFactor * m_rtLastLowErrorSeen );
        }       
    } // end dsound slaving path
    else 
    {
        ASSERT( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA );
        //
        // Note: waveOut slaving is only supported for live graphs.
        //
        // For waveOut we only attempt to handle the case where we're running too slowly relative to the
        // graph clock, since in the worst case, sync will drift 'out' to the maximum bufferring used. That's 
        // a problem for live graphs that need low latency. The opposite problem of sync drifting too far 'in'
        // is not a big problem for live graphs, unless a large latency is desired (which is rarely the case
        // for live graphs).
        //
        // One problem is that in some scenarios the case where we're running too FAST relative to the graph
        // clock can look a lot like the case where we're too slow, since we don't try to account for silence 
        // gaps. To avoid falling into our data dropping path when we're really running too quickly we add an 
        // additional check to make sure we really have written more actual bytes to the device then we've played. 
        // The additional complication is that I've noticed when we're being sourced by some legacy capture devices 
        // our playback clock position doesn't match the bytes that we've queued, EVEN though we're running way too 
        // fast. So the m_rtWaveOutLatencyThreshold check was added to avoid dropping data when we shouldn't be.
        // Note that I didn't notice this problem when the source was a WDM capture device (??).
        //
        
        DbgLog( (LOG_TRACE
              , DBG_LEVEL_CLOCK_SYNC_DETAILS
              , TEXT( "wo:Slaving : m_rtDroppedBufferDuration: %dms" )
              , (LONG) ( m_rtDroppedBufferDuration / 10000 ) ) );
        
        LONGLONG llTruncBufferDur = BufferDuration(m_pPin->m_nAvgBytesPerSec, *pcbData);
        m_rtDroppedBufferDuration += ( m_pPin->m_Stats.m_rtLastBufferDur - llTruncBufferDur );
        
        //
        // use time since last buffer to determine how much of the last buffer queued to the device
        // we should expect the device to have played
        //
        REFERENCE_TIME rtSinceLastBuffer = rtMasterClockTime - m_rtLastMasterClockTime;
        
        //
        // GetBytesPlayed() gives us the amount of data written to the device before we wrote
        // the previous buffer. GetBytesInLastWrite() tells us how big that last buffer was.
        //
        LONGLONG llPredictedBytesPlayed  = m_pFilter->m_pRefClock->GetBytesProcessed() + 
                                           min( (LONGLONG) m_pFilter->m_pRefClock->GetBytesInLastWrite(), 
                                                (LONGLONG) ( m_pPin->m_nAvgBytesPerSec * rtSinceLastBuffer ) / UNITS );
        LONGLONG llActualBytesPlayed     = m_pFilter->m_pRefClock->GetBytesPlayed();
        
        //        
        // this is how many written bytes we've yet to play        
        //
        REFERENCE_TIME rtBytesWrittenNotPlayed = BufferDuration( m_pPin->m_nAvgBytesPerSec,
                                                                 (LONG) (llPredictedBytesPlayed - llActualBytesPlayed ) );
    
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving : rtBytesWrittenNotPlayed = %dms")
              , (LONG)( rtBytesWrittenNotPlayed / 10000 ) ) );
    
        // 
        // now use the 2 thresholds to decide if we need to drop any data
        //    
        if( ( m_rtErrorAccum > m_rtAdjustThreshold ) &&
            ( rtBytesWrittenNotPlayed > m_rtWaveOutLatencyThreshold ) )
        {
            m_rtLastHighErrorSeen = m_rtErrorAccum;
            if( m_rtLastHighErrorSeen > m_rtHighestErrorSeen )
                m_rtHighestErrorSeen = m_rtLastHighErrorSeen;

            m_rtLastLowErrorSeen = 0;
            
            DbgLog( ( LOG_TRACE
                  , DBG_LEVEL_CLOCK_SYNC_DETAILS
                  , "Too far behind. Need to truncate or drop...") );
        
            if( m_rtErrorAccum >= m_pPin->m_Stats.m_rtLastBufferDur )
            {
                // drop the whole buffer
                m_rtDroppedBufferDuration += m_pPin->m_Stats.m_rtLastBufferDur;
                DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, "***WAY behind...Dropping the whole buffer"));
                *pcbData = 0;
            }
            else
            {
                // else consider truncating...
                // first convert to bytes and gauge if this makes sense
                LONG lTruncBytes = (LONG) ( ( (m_rtErrorAccum/10000) * m_pPin->m_nAvgBytesPerSec ) /1000 ) ; 

                //  round up to block align boundary
                LONG lRoundedUpTruncBytes = lTruncBytes;
                if (pwfx->nBlockAlign > 1) {
                    lRoundedUpTruncBytes += pwfx->nBlockAlign - 1;
                    lRoundedUpTruncBytes -= lRoundedUpTruncBytes % pwfx->nBlockAlign;
                }
            
                if( lRoundedUpTruncBytes < *pcbData )
                {
                    // lets truncate
#ifdef DEBUG                        
                    LONG lOriginalLength = *pcbData;
#endif                    
                    *pcbData -= lRoundedUpTruncBytes ;
                    DbgLog( (LOG_TRACE
                          , DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS
                          , TEXT( "***Truncating %ld bytes of %ld byte buffer (%ld left)" )
                          , lRoundedUpTruncBytes
                          , lOriginalLength
                          , *pcbData ) );
                  
                    LONGLONG llTruncBufferDur = BufferDuration(m_pPin->m_nAvgBytesPerSec, *pcbData);
                    m_rtDroppedBufferDuration += ( m_pPin->m_Stats.m_rtLastBufferDur - llTruncBufferDur );
                }
                else
                {
                    m_rtDroppedBufferDuration += m_pPin->m_Stats.m_rtLastBufferDur;
                    DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, "***Considered truncating but dropping the whole buffer"));
                    *pcbData = 0;
                }                                                            
            }
        }
        else if( m_rtErrorAccum < -m_rtAdjustThreshold )
        {
            m_rtLastLowErrorSeen = m_rtErrorAccum;
            if( m_rtLastLowErrorSeen < m_rtLowestErrorSeen )
                m_rtLowestErrorSeen = m_rtLastLowErrorSeen;

            m_rtLastHighErrorSeen = 0;
            
            DbgLog( ( LOG_TRACE
                  , DBG_LEVEL_CLOCK_SYNC_DETAILS
                  , "waveOut clock is running fast relative to graph clock...") );
        }   
        else if( m_rtLastHighErrorSeen > 0 )
        {
            m_rtLastHighErrorSeen = (LONGLONG)( m_fltErrorDecayFactor * m_rtLastHighErrorSeen );
        }
        else if( m_rtLastLowErrorSeen < 0 )
        {
            m_rtLastLowErrorSeen = (LONGLONG)( m_fltErrorDecayFactor * m_rtLastLowErrorSeen );
        }       
             
    } // end waveOut slaving path   

    // save the current time
    m_rtLastMasterClockTime = rtMasterClockTime;
     
    return hr;
}

//-----------------------------------------------------------------------------
//
// CWaveSlave::ResumeSlaving
//
// Reset slaving parameters
// Prepare to pick up slaving where we left off, not necessarily from a clean start,
// so save running results.
// Combine this with Reset instead?? keeping separate for now, for clarity
//
// Parameters:
//      BOOL bReset - If TRUE then all parameters will be reset. Used when initializing
//                    the slave structure and when transitioning to Pause from a Stopped 
//                    state.
//
//                    If FALSE then it is assumed that we're picking up slaving from 
//                    an already Running state, in which case we'd like to save slaving 
//                    parameters that we may have already zeroed in on, like the slave 
//                    rate. FALSE is used when:
//                          resuming slaving after seeing a discontinuity
//                          resuming slaving after dropping silence in live stream
// 
//-----------------------------------------------------------------------------
void CWaveSlave::ResumeSlaving( BOOL bReset )
{
    // first reset paramaters that apply to either a full reset 
    // or a slaving resume
    m_rtLastMasterClockTime = 0;
    m_rtErrorAccum = 0;
    m_rtLastHighErrorSeen = 0;
    m_rtLastLowErrorSeen = 0;
    
    // reset dropped buffer duration for the waveOut slaving case
    m_rtDroppedBufferDuration = 0;
    
    if( bReset )
    {    
        m_bLiveButDataPrequeued = FALSE;
        
        
        m_bResumeSlaving = TRUE;
        
        // we're starting from scratch so reset everything else as well
        m_rtDroppedBufferDuration  = 0;  
        m_dwMinClockRate = 0;
        m_dwMaxClockRate = 0;
        m_dwClockStep = 0; 

        m_dwCurrentRate = 0;
        m_fdwSlaveMode = 0;
        m_rtHighestErrorSeen = 0;
        m_rtLowestErrorSeen = 0;

        m_bRefreshMode   = TRUE;

#ifdef LOG_CLOCK_DELTAS
        m_rtLastSlaveClockTime = 0;
#endif
        
#ifdef CALCULATE_AUDBUFF_JITTER
        // for jitter calc
        m_cBuffersReceived = 0;
        m_iTotAcc = 0;
        m_iSumSqAcc = 0;
        m_rtLastSysTimeBufferTime = 0;
#endif
    }
}

//-----------------------------------------------------------------------------
//
// CWaveSlave::RefreshModeOnNextSample
//
// Set flag to indicate that we need to update our slaving mode on reception
// of next sample. This will require a rescan on the upstream filter chain
// for an IAMPushSource filter.
//
//-----------------------------------------------------------------------------
void CWaveSlave::RefreshModeOnNextSample( BOOL bRefresh )
{
    m_bRefreshMode = bRefresh;
}


//-----------------------------------------------------------------------------
//
// CWaveSlave::UpdateSlaveMode - determine if we've entered a new slaving mode 
//                               returns TRUE if we're slaving, FALSE if not
//
//-----------------------------------------------------------------------------
BOOL CWaveSlave::UpdateSlaveMode( BOOL bSync )
{
    // only slave when we're running with a clock
    if( m_pFilter->m_fFilterClock == WAVE_NOCLOCK )
        return FALSE;
        
    BOOL bSlaving = FALSE;    
    if( m_bRefreshMode )
    {
        ULONG ulPushSourceFlags = 0 ;
        RefreshModeOnNextSample( FALSE );
        
        m_fdwSlaveMode = 0;
        //
        // Determine if we're being sourced by a 'live' data source
        // To do this we check if there's an upstream source filter which supports IAMPushSource
        //
        ASSERT( m_pFilter->m_pGraph );
        ASSERT( m_pFilter->m_pGraphStreams );
        
        if( m_pFilter->m_pGraphStreams )
        {        
            IAMPushSource *pPushSource = NULL;
            HRESULT hr = m_pFilter->m_pGraphStreams->FindUpstreamInterface( m_pPin
                                               , IID_IAMPushSource
                                               , (void **) &pPushSource
                                               , AM_INTF_SEARCH_OUTPUT_PIN ); 
            if( SUCCEEDED( hr ) )
            {
            
                hr = pPushSource->GetPushSourceFlags(&ulPushSourceFlags);
                ASSERT( SUCCEEDED( hr ) );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found push source (ulPushSourceFlags = 0x%08lx)")
                          , ulPushSourceFlags ) );
                    if( 0 == ( AM_PUSHSOURCECAPS_NOT_LIVE & ulPushSourceFlags ) )
                    {
                        // yes, this is live data so turn on the bit
                        m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_LIVE_DATA;
                    }                    
                }
                pPushSource->Release();         
            }
            else
            {
                // workaround for live graphs where the audio capture pin doesn't yet
                // support IAMPushSource
                IKsPropertySet * pKs;
                hr = m_pFilter->m_pGraphStreams->FindUpstreamInterface( m_pPin
                                               , IID_IKsPropertySet
                                               , (void **) &pKs
                                               , AM_INTF_SEARCH_OUTPUT_PIN ); // search output pins
                // this will only find the first one so beware!!
                if( SUCCEEDED( hr ) )             
                {   
                    GUID guidCategory;
                    DWORD dw;
                    hr = pKs->Get( AMPROPSETID_Pin
                                 , AMPROPERTY_PIN_CATEGORY
                                 , NULL
                                 , 0
                                 , &guidCategory
                                 , sizeof(GUID)
                                 , &dw );
                    if( SUCCEEDED( hr ) )                         
                    {
                        DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found IKsPropertySet pin. Checking pin category...")
                              , ulPushSourceFlags ) );
                        if( guidCategory == PIN_CATEGORY_CAPTURE )
                        {
                        
                            DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found capture pin even though no IAMPushSource support") ) );

                            // live data, turn on the bit
                            m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_LIVE_DATA;
                        } 
                        else
                        {
                            DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - not a capture filter")
                                  , ulPushSourceFlags ) );
                        }                       
                    }                    
                    pKs->Release();
                }                
            }
        }            
        
#ifdef TEST_MODE
        // use to test various sources
        ulPushSourceFlags = (BOOL) GetProfileIntA("PushSource", "Flags", ulPushSourceFlags);
#endif        
        //
        // Finish setting our internal slave mode state, using push source, timestamp,
        // and clock information.
        //
        if( AM_PUSHSOURCECAPS_INTERNAL_RM & ulPushSourceFlags )
        {
            // source does its own rate matching so don't try to slave to it
            DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Source provides its own rate matching support. Slaving disabled.") ) );
        }
        else if( AM_AUDREND_SLAVEMODE_LIVE_DATA & m_fdwSlaveMode )
        {        
            if( ( AM_PUSHSOURCECAPS_PRIVATE_CLOCK & ulPushSourceFlags ) && bSync )
            {
                //
                // source data is timestamped to a internal clock that
                // we don't have access to, so the best we can do is to
                // slave to the input timestamps. we do this regardless of
                // who the clock is.
                //
                DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Audio renderer slaving to timestamps of live source with its own clock") ) );
                m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_TIMESTAMPS;
                bSlaving = TRUE;
            }                
            else if( m_pFilter->m_fFilterClock == WAVE_OTHERCLOCK ) 
            {
                // we're not the not clock, now decide what to slave to
                if( AM_PUSHSOURCEREQS_USE_STREAM_CLOCK & ulPushSourceFlags ) // does bSync state matter?
                {
                    // 
                    // here we'd query the push source for it's clock via GetSyncSource
                    // and slave to that
                    //
                    //
                    // LATER...
                    //                    
                    ASSERT( FALSE );
                }
                else if( bSync )
                {                    
                    // live graph and slave to graph clock
                    DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Audio renderer is slaving to graph clock with live source") ) );
                    m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_GRAPH_CLOCK;
                    bSlaving = TRUE;
        
                }        
                else 
                {
                    // no timestamps so slave to buffer fullness
                    DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Audio renderer is slaving to buffer fullness of live source") ) );
                    m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS;
                    bSlaving = TRUE;
                }
            }                                
            else 
            {
                // else data is live and we're the clock, so we're forced to slave to buffer fullness
                DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Audio renderer is slaving to buffer fullness of live source") ) );
                m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS;
                bSlaving = TRUE;
            }
        }                    
        else if( m_pFilter->m_fFilterClock == WAVE_OTHERCLOCK && m_pFilter->m_fDSound )
        {
            //
            // slave to graph clock (source data isn't 'live')
            //
            // non-live slaving is NOT supported for the waveOut path
            //
            DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Audio renderer slaving to external clock") ) );
            m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_GRAPH_CLOCK;
            bSlaving = TRUE;
        }
        // else we're not slaving 
        
    } // end refresh slaving settings
    else 
        bSlaving = ( 0 == m_fdwSlaveMode ) ? FALSE : TRUE;
        
    return bSlaving;
}


#ifdef CALCULATE_AUDBUFF_JITTER

extern int isqrt(int x); // defined in renbase.cpp

// if buffer is earlier or later than this, don't use it for clock adjustments
// !NOTE: Make this a value proportional to the buffer duration, i.e. like .8 * duration?
static const LONGLONG  BUFFER_TIMELINESS_TOLERANCE = (40 * (UNITS / MILLISECONDS));

//-----------------------------------------------------------------------------
//
// CWaveSlave::RecordBufferLateness
//
// update stats on how timely buffers arrive, use it to calculate the jitter 
//
// update the statistics:
// m_iTotAcc, m_iSumSqAcc, m_iSumSq (buffer time), m_cBuffersReceived
//
//-----------------------------------------------------------------------------
HRESULT CWaveSlave::RecordBufferLateness(REFERENCE_TIME rtBufferDiff)
{
    HRESULT hr = S_OK;
    int trLate = 0;
    
    // Record how timely input buffers arrive and update jitter calculation
    REFERENCE_TIME rtCurrent = (REFERENCE_TIME)10000 * timeGetTime();
    if( !m_bResumeSlaving )
    {
        REFERENCE_TIME rtSysTimeBufferDiff = rtCurrent - m_rtLastSysTimeBufferTime;
        REFERENCE_TIME rtBufferLateness = rtBufferDiff - rtSysTimeBufferDiff;
    
        DbgLog( (LOG_TRACE
              , DBG_LEVEL_CLOCK_SYNC_DETAILS
              , TEXT( "wo:Slaving - timeGetTime buffer diff: %dms, BufferLateness: %dms" )
              , (LONG)(rtSysTimeBufferDiff/10000)
              , (LONG)(rtBufferLateness/10000) ) );
    
        trLate = (int) (rtBufferLateness/10000);
        
        // ignore 1st buffer 
        if ( m_cBuffersReceived>1 ) 
        {
        	m_iTotAcc += trLate;
	        m_iSumSqAcc += (trLate*trLate);
            
            // when slaving to buffer fullness don't try to slave to
            // buffers which are delivered unreasonably late or early.            
            if( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS &&
                ( rtBufferLateness > BUFFER_TIMELINESS_TOLERANCE ||
                rtBufferLateness < -BUFFER_TIMELINESS_TOLERANCE ) )
            {
                DbgLog( (LOG_TRACE
                      , DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS
                      , TEXT( "wo:Slaving - Ignoring too late or early buffer" )
                      , (LONG)(rtSysTimeBufferDiff/10000)
                      , (LONG)(rtBufferLateness/10000) ) );
                hr = S_FALSE;
            }           
        }            
    }
    m_rtLastSysTimeBufferTime = rtCurrent;
    ++m_cBuffersReceived;
    
    return hr;
    
} // RecordBufferLateness

//-----------------------------------------------------------------------------
//
//  Do estimates for standard deviations for per-buffer
//  statistics. Code taken from renbase.cpp.
//
//-----------------------------------------------------------------------------
HRESULT GetStdDev(
    int nBuffers,
    int *piResult,
    LONGLONG llSumSq,
    LONGLONG iTot
)
{
    CheckPointer(piResult,E_POINTER);

    // If S is the Sum of the Squares of observations and
    //    T the Total (i.e. sum) of the observations and there were
    //    N observations, then an estimate of the standard deviation is
    //      sqrt( (S - T**2/N) / (N-1) )

    if (nBuffers<=1) {
	*piResult = 0;
    } else {
	LONGLONG x;
	// First frames have bogus stamps, so we get no stats for them
	// So we need 2 frames to get 1 datum, so N is cFramesDrawn-1

	// so we use m_cFramesDrawn-1 here
	x = llSumSq - llMulDiv(iTot, iTot, nBuffers, 0);
	x = x / (nBuffers-1);
	ASSERT(x>=0);
	*piResult = isqrt((LONG)x);
    }
    return NOERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\wave.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// Implements the CWaveOutDevice class based on waveOut APIs
//-----------------------------------------------------------------------------

extern AMOVIESETUP_FILTER wavFilter;

class CWaveOutDevice :
    public CSoundDevice
{

public:
    // define the public functions that this class exposes. These are all
    // straight calls to the corresponding waveOut APIs. Only the APIs that are
    // used by the Quartz wave renderer are declared and defined. We may have
    // to progressively add to this list.

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    MMRESULT amsndOutClose () ;
    MMRESULT amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc) ;
    MMRESULT amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText) ;
    MMRESULT amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseAdjustedPos) ;
    MMRESULT amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
                           double dRate, DWORD *pnAvgBytesPerSec,
                           DWORD_PTR dwCallBack, DWORD_PTR dwCallBackInstance, DWORD fdwOpen) ;
    MMRESULT amsndOutPause () ;
    MMRESULT amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutReset () ;
    MMRESULT amsndOutBreak () ;
    MMRESULT amsndOutRestart () ;
    MMRESULT amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, REFERENCE_TIME const *pStart, BOOL bIsDiscontinuity) ;

    // Routines required for initialisation and volume/balance handling
    // These are not part of the Win32 waveOutXxxx api set
    HRESULT  amsndOutCheckFormat (const CMediaType *pmt, double dRate);
    LPCWSTR  amsndOutGetResourceName () ;
    HRESULT  amsndOutGetBalance (LPLONG plBalance) ;
    HRESULT  amsndOutGetVolume (LPLONG plVolume) ;
    HRESULT  amsndOutSetBalance (LONG lVolume) ;
    HRESULT  amsndOutSetVolume (LONG lVolume) ;

    HRESULT  amsndOutLoad(IPropertyBag *pPropBag) ;

    HRESULT  amsndOutWriteToStream(IStream *pStream);
    HRESULT  amsndOutReadFromStream(IStream *pStream);
    int      amsndOutSizeMax();
    
    bool     amsndOutCanDynaReconnect() { return false; } // The wave out filter does not support dynamic reconnection

    CWaveOutDevice () ;
    ~CWaveOutDevice () ;

private:
    // Get current settings from the hardware and set member variables
    HRESULT GetVolume ();

    // Put current settings to the hardware using member variables
    HRESULT PutVolume();

    // Set up right/left amp factors
    void SetBalance();

	// Get the current balance from right/left amp factors
	void GetBalance();

    // volume is in the range -10000 to 0 (100th DB units)
    // amplitude and Balance are cumulative
    LONG        m_lVolume;
    LONG        m_lBalance;

    WORD	m_wLeft;		// Left channel volume
    WORD	m_wRight;		// Right channel volume
    DWORD   m_dwWaveVolume;
    BOOL	m_fHasVolume;		// wave device can set the volume
	BOOL	m_fBalanceSet;	// remember if the balance was explicitly set at least once

    HWAVEOUT    m_hWaveDevice;		// remember the handle of the open device

    UINT        m_iWaveOutId;           // output device to open

    WCHAR       m_wszResourceName[100]; // for resource manager
    void        SetResourceName();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\waveclk.cpp ===
// Copyright (c) 1995 - 2000  Microsoft Corporation.  All Rights Reserved.
// Digital wave clock, Steve Davies, January 1996

#include <streams.h>
#include "waveout.h"
#include <mmreg.h>
#include <seqhdr.h>  // MPEG stuff

/* Constructor */

CWaveOutClock::CWaveOutClock(
    CWaveOutFilter *pFilter,
    LPUNKNOWN pUnk,
    HRESULT *phr,
    CAMSchedule * pShed)
    : CBaseReferenceClock(NAME("WaveOut device clock"), pUnk, phr, pShed)
    , m_pFilter(pFilter)
    , m_fAudioStarted(FALSE)
{
    // Compute perf counter difference
#ifdef USE_PERF_COUNTER_TO_SYNC
    LARGE_INTEGER liFreq;
    QueryPerformanceFrequency(&liFreq);

    // Set Threshold to 0.5ms
    m_llSyncClockThreshold = liFreq.QuadPart / (LONGLONG)2000;
    // this is the time within which we need to read both the device and
    // system clock in order to believe the two times are in sync
#else

    // Set Threshold to 1 ms (a single clock tick)
    m_llSyncClockThreshold = (UNITS / MILLISECONDS);

#endif
}

/* Called on RUN.  The wave device will be in a paused state with
 * buffers queued.  We query the wave position and add that to the
 * start time in order to get a system time position
 */
void CWaveOutClock::AudioStarting(REFERENCE_TIME tStart)
{
    if (m_pFilter->m_fFilterClock != WAVE_OURCLOCK &&
        m_pFilter->m_fFilterClock != WAVE_OTHERCLOCK ) {
    	return;
    }
    
    // !!! lock
    CAutoLock lck(this);
    WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();
    ASSERT(pwfx != NULL);
    m_rtRunStart = tStart;

    // get the audio position from the device
    // if tStart == -1 we are restarting the audio after a break
    // in which case we want to take the current audio position
    // and adjust its timing to match the current system clock value.
    // If the audio sample is far too late... we should have dropped it
    // which is bad news....
        
    //ASSERT(!m_fAudioStarted);
    m_fAudioStarted = TRUE;  // I would prefer this next to waveOutRestart.

    //  Make sure the clock is now in sync
    AdjustClock();

#ifdef DEBUG
    REFERENCE_TIME rtCurrentRefTime;
    GetTime(&rtCurrentRefTime);

    DbgLog((LOG_TIMING, 1, TEXT("Audio starting, requested at time %s, now %s (diff %d)"),
        (LPCTSTR)CDisp(tStart, CDISP_DEC), (LPCTSTR)CDisp(rtCurrentRefTime, CDISP_DEC),
        (LONG)(rtCurrentRefTime-tStart)));
#endif

}

/* Called on filter PAUSE and from the wavecallback if no more
 * data is queued.
 */
void CWaveOutClock::AudioStopping()
{
    if (m_pFilter->m_fFilterClock != WAVE_OURCLOCK &&
        m_pFilter->m_fFilterClock != WAVE_OTHERCLOCK ) {
    	return;
    }

    // only if we are started do we stop, otherwise do nothing
    if (InterlockedExchange((PLONG)&m_fAudioStarted,0)) {
	CAutoLock lck(this);
	// we use the lock to synchronise stopping with starting
#ifdef DEBUG
        REFERENCE_TIME m_CurrentRefTime;
        GetTime(&m_CurrentRefTime);

	DbgLog((LOG_TIMING, 1, TEXT("Audio stopping, time now %s"), (LPCTSTR)CDisp(m_CurrentRefTime, CDISP_DEC)));
#endif
	// by using the lock we guarantee that when we return everything
	// has been done to stop the audio
    }
}


//
//  Set the clock adjustment when we're running
//
void CWaveOutClock::AdjustClock()
{
    LONGLONG sysTime, devTime;

    ReadClockTimes(&sysTime, &devTime);

    /*  Now work out what the current time ought to be
        m_rtRunStart is ONLY valid when m_fAudioStarted is TRUE
    */
    ASSERT(m_fAudioStarted);

    /*  Basically validate the equation that

        (Reference Time) == (Stream Time) + (The tStart parameter passed to Run())
    */
#ifdef DEBUG
    LONG lTimeDelta = (LONG)((devTime + m_rtRunStart - sysTime) / (UNITS / MILLISECONDS));
    DbgLog((LOG_TRACE, 8, TEXT("devTime = %s, m_rtRunStart = %s, sysTime = %s"), 
            (LPCTSTR)CDisp(devTime, CDISP_DEC),
            (LPCTSTR)CDisp(m_rtRunStart, CDISP_DEC),
            (LPCTSTR)CDisp(sysTime, CDISP_DEC)
            ));
    if (lTimeDelta) {
	DbgLog((LOG_TRACE, 3, TEXT("Setting time delta %ldms"), (LONG) (lTimeDelta / 10000)));
    }
#endif

    REFERENCE_TIME rt =  devTime + m_rtRunStart - sysTime ;
    SetTimeDelta( rt);

}

void CWaveOutClock::UpdateBytePositionData(DWORD nPrevAvgBytesPerSec, DWORD nCurAvgBytesPerSec)
{
    DbgLog((LOG_TRACE, 8, TEXT("CWaveOutClock::UpdateBytePositionData")));
    DbgLog((LOG_TRACE, 8, TEXT("m_llBytesInLast was %s, m_llBytesProcessed was %s"), 
            (LPCTSTR)CDisp(m_llBytesInLast, CDISP_DEC),
            (LPCTSTR)CDisp(m_llBytesProcessed, CDISP_DEC) ));
            
    DbgLog((LOG_TRACE, 8, TEXT("nPrevAveBytesPerSec: %d, nNewAveBytesPerSec: %d"), 
            nPrevAvgBytesPerSec,
            nCurAvgBytesPerSec));
                
    m_llBytesInLast = llMulDiv((LONG)m_llBytesInLast,
                             nCurAvgBytesPerSec,
                             nPrevAvgBytesPerSec,
                             0);

    m_llBytesProcessed = llMulDiv((LONG)m_llBytesProcessed,
                             nCurAvgBytesPerSec,
                             nPrevAvgBytesPerSec,
                             0);

    DbgLog((LOG_TRACE, 8, TEXT("New m_llBytesInLast: %s, New m_llBytesProcessed: %s"), 
            (LPCTSTR)CDisp(m_llBytesInLast, CDISP_DEC),
            (LPCTSTR)CDisp(m_llBytesProcessed, CDISP_DEC) ));

}


//  Reset the buffer statistics
//  If bResetToZero is false assume the next buffer starts after these,
//  otherwise assume it starts at 0
void CWaveOutClock::ResetPosition(BOOL bResetToZero) {

    ASSERT(CritCheckIn(m_pFilter));
    if (!bResetToZero) {
        m_stBufferStartTime =
            m_stBufferStartTime +
            MulDiv((LONG)m_llBytesInLast,
                   (LONG)UNITS,
                   m_pFilter->m_pInputPin->m_nAvgBytesPerSec);
    } else {
        m_stBufferStartTime = 0;
        m_llBytesPlayed = 0;
    }
#ifdef DEBUG    
    m_llEstDevRateStartTime  = 0;
    m_llEstDevRateStartBytes = 0;
#endif    
    m_llBytesInLast          = 0;
    m_llBytesProcessed       = 0;
}

#ifdef DEBUG

const DWORD DEVICE_RATE_ESTIMATE_WEIGHT_FACTOR = 5;

DWORD CWaveOutClock::EstimateDevClockRate
(
    const LONGLONG llTime, 
    BOOL           bInit
) 
{
    DWORD nAvgBytesPerSec = 0;
    
    if( bInit )
    {
        // initialize start time and byte count
        m_llEstDevRateStartTime = llTime;
        m_llEstDevRateStartBytes = m_llBytesPlayed;
    }        
    else
    {
        LONGLONG llBytesConsumed      = m_pFilter->m_pRefClock->m_llBytesPlayed - 
                                        m_llEstDevRateStartBytes +
                                        DEVICE_RATE_ESTIMATE_WEIGHT_FACTOR * m_pFilter->m_pInputPin->m_nAvgBytesPerSec; 
        LONGLONG llTimeSpentConsuming = llTime - m_llEstDevRateStartTime +
                                        DEVICE_RATE_ESTIMATE_WEIGHT_FACTOR * UNITS; 
        DbgLog((LOG_TRACE
              , 8
              , TEXT("llTimeSpentConsuming = %dms, llBytesConsumed = %d")
              , (LONG)(llTimeSpentConsuming / 10000)
              , (LONG)(llBytesConsumed) ) );
              
        nAvgBytesPerSec = (LONG) llMulDiv( llBytesConsumed
                                         , UNITS
                                         , llTimeSpentConsuming
                                         , 0 );
        DbgLog( (LOG_TRACE
              , 5
              , TEXT("*** Estimated device clock rate: = %ld bytes per sec")
              , nAvgBytesPerSec ) );
              
    }    

    return nAvgBytesPerSec;            
}
#endif

//  Process timing information in a wave header
//  return the time when the data would all be played
//
LONGLONG CWaveOutClock::NextHdr(
    PBYTE pbData,
    DWORD cbData,
    BOOL bSync,
    IMediaSample *pSample
)
{
    CAutoLock lck(this);
    WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();
    ASSERT(pwfx != NULL);

    // use the rate at which the wave device is consuming data
    // which may be different from the rate in the format block
    DWORD nAvgBytesPerSec = m_pFilter->m_pInputPin->m_nAvgBytesPerSec;
    if (bSync) {

        //  Do something a bit different for MPEG because the time stamp
        //  refers to the first frame
        if ((pwfx->wFormatTag == WAVE_FORMAT_MPEG) &&
            (((MPEG1WAVEFORMAT *)pwfx)->fwHeadFlags & ACM_MPEG_ID_MPEG1)) {
            DWORD dwFrameOffset = MPEG1AudioFrameOffset(
                                      pbData,
                                      cbData);
            if (dwFrameOffset != (DWORD)-1) {
                ASSERT(dwFrameOffset < cbData);
                m_llBytesProcessed += m_llBytesInLast + dwFrameOffset;
                m_llBytesInLast = cbData - dwFrameOffset;
            } else {
                m_llBytesInLast += cbData;
		DbgLog((LOG_ERROR, 0, TEXT("Bad Mpeg timing data")));
		return m_stBufferStartTime + (((LONGLONG)m_llBytesInLast * UNITS) / nAvgBytesPerSec);
            }
        } else {

            //  Upgrade the number of bytes processed now and the bytes in the
            //  'next' block.  The data is contiguous
#ifdef CHECK_TIMESTAMPS
            {
                REFERENCE_TIME tStart, tStop;
                pSample->GetTime(&tStart, &tStop);
                REFERENCE_TIME rtPredicted =
                    m_rtBufferStartTime +
                    MulDiv((LONG)m_llBytesInLast, UNITS, pwfx->nAvgBytesPerSec);
                LONG lDiff = (LONG)(rtPredicted - tStart) / 10000;
                if (abs(lDiff) > 3) {
                    DbgLog((LOG_TRACE, 0,
                            TEXT("Sample start discrepancy > 3 ms - expected %d, actual %d"),
                            (LONG)(rtPredicted / 10000),
                            (LONG)(tStart / 10000)));

                }
            }
#endif
            m_llBytesProcessed += m_llBytesInLast;
            m_llBytesInLast     = cbData;
        }


        //  Get the start & stop times of the next buffer
        pSample->GetTime(&m_stBufferStartTime, &m_stBufferStopTime);

#ifdef DEBUG
	//LONGLONG rtLengthLastBuffer = ((LONGLONG)m_llBytesInLast * UNITS) / nAvgBytesPerSec;
	//LONGLONG overlap = m_stBufferStopTime - m_stBufferStartTime + rtLengthLastBuffer;
	//ASSERT( overlap < (1 * (UNITS/MILLISECONDS)));
#endif
	// If we are running bring the system and wave clocks closer together
        // NB: it would be invalid to do this if m_fAudioStarted was false
	// if we are using an external clock then m_fAudioStarted will ALWAYS be FALSE
	// this prevents us from having to check if we are using OUR clock
	if (State_Running == m_pFilter->m_State && m_fAudioStarted) AdjustClock();

    } else {
        m_llBytesInLast += cbData;
    }


    // !!! MIDI HACK
    if (nAvgBytesPerSec == 0)
	return m_stBufferStopTime;

    // we can calculate the "end" of the queue of data written to the
    // device by taking m_stBufferStartTime and adding m_llBytesInLast
    // (converted to time obviously).  This will be an approximation for
    // compressed audio

    return m_stBufferStartTime + (((LONGLONG)m_llBytesInLast * UNITS) / nAvgBytesPerSec);
}


// !!! the following two functions are almost identical, could they be combined?

// return the time at which the device is currently playing
LONGLONG CWaveOutClock::ReadDevicePosition(BOOL bAbsoluteDevTime)
{
    MMTIME	mmtime;
    LONGLONG rt;

    // we should be holding the device lock at this point
    ASSERT(CritCheckIn(m_pFilter));

    // Get the average rate at which the device is consuming data
    DWORD nAvgBytesPerSec = m_pFilter->m_pInputPin->m_nAvgBytesPerSec;

    mmtime.wType = TIME_BYTES;
    m_pFilter->m_pSoundDevice->amsndOutGetPosition(&mmtime, sizeof(mmtime), bAbsoluteDevTime);
    if (mmtime.wType == TIME_MS) {
	// !!! MIDI HACK, return milliseconds without converting
	if (nAvgBytesPerSec == 0)
	    return (mmtime.u.ms * UNITS / MILLISECONDS);
	
        //  Convert to bytes - we have to do this so we can
        //  rebase on the time stamps and byte count.
        mmtime.u.cb = MulDiv(mmtime.u.ms, nAvgBytesPerSec, 1000);

    } else {
        ASSERT(mmtime.wType == TIME_BYTES);

	ASSERT(nAvgBytesPerSec != 0);
    }

    // update and cache the device position
    DbgLog( ( LOG_TRACE
          , 15
          , TEXT("mmtime.u.cb indicates the waveout device has played %ld bytes (%ld since last read)")
          , (LONG)(mmtime.u.cb)
          , (LONG)(mmtime.u.cb - (DWORD)m_llBytesPlayed) ) );
    m_llBytesPlayed += (LONGLONG) ((DWORD)(mmtime.u.cb - m_llBytesPlayed)); 

    if( bAbsoluteDevTime )
    {
        // return the zero based time (independent of stream time)
        // that the device has played to
        rt = llMulDiv( m_llBytesPlayed, UNITS, nAvgBytesPerSec, 0 );
    }
    else
    {        
        //  First work out how many bytes have been processed since
        //  the start of this buffer
        //
    
        LONG lProcessed = (LONG)(mmtime.u.cb - (DWORD)m_llBytesProcessed);

        //  Use this as an offset from the start of the buffer (stream time)
        //
        rt = m_stBufferStartTime +
             (((LONGLONG)lProcessed * UNITS) / nAvgBytesPerSec);
             
    }
    return(rt);
}

LONGLONG CWaveOutClock::ReadDeviceClock()
{
    // We should only be called if we are active

    // lock device to prevent losing wave device
    ASSERT(CritCheckIn(m_pFilter));

    if (m_pFilter->m_bHaveWaveDevice && m_fAudioStarted) {
        ASSERT(m_pFilter->m_hwo);

	MMTIME	mmtime;
        LONGLONG rt;

	// Get the average rate at which the device is consuming data
	DWORD nAvgBytesPerSec = m_pFilter->m_pInputPin->m_nAvgBytesPerSec;

	mmtime.wType = TIME_BYTES;
        //  Clear out high DWORD so we can interpret the amswer as signed
        //  and at least DSOUND can return the proper result
        *((DWORD *)&mmtime.u.cb + 1) = 0;

	m_pFilter->m_pSoundDevice->amsndOutGetPosition(&mmtime, sizeof(mmtime), FALSE);

        if (mmtime.wType == TIME_MS) {
	
	    // !!! MIDI HACK, return milliseconds without converting
	    if (nAvgBytesPerSec == 0)
		return (mmtime.u.ms * UNITS / MILLISECONDS);
	
            //  Convert to bytes - we have to do this so we can
            //  rebase on the time stamps and byte count.
            mmtime.u.cb = MulDiv(mmtime.u.ms, nAvgBytesPerSec, 1000);
        } else {
	    ASSERT(mmtime.wType == TIME_BYTES);

	    ASSERT(nAvgBytesPerSec != 0);
        }

        //  First work out how many bytes have been processed since
        //  the start of this buffer
        //
        LONGLONG llProcessed;
        if( m_pFilter->m_fDSound )
        {
            // only dsr reports LONGLONG position
            llProcessed = *(UNALIGNED LONGLONG *)&mmtime.u.cb - m_llBytesProcessed;
        }
        else
        {
            llProcessed = (LONGLONG) (LONG)(mmtime.u.cb - (DWORD)m_llBytesProcessed);
        }
        
        //  Use this as an offset from the start of the buffer (stream time)
        //
        rt = m_stBufferStartTime +
             llMulDiv(llProcessed, UNITS, nAvgBytesPerSec, 0);

        m_llLastDeviceClock = rt;
    }
    return m_llLastDeviceClock;  // if the audio is stopped the device clock is 0
}

// ReadClockTimes:
//
// The problem with having two clocks running is keeping them in sync.  This
// is what ReadClockTimes does.
//
// Both the system and device clocks are read within a "short" space of time.
// In an ideal world a short space of time is such that the fastest incrementing
// clock does not update.  We assume the system clock is very fast to query
// and bracket a call to the device clock with 2 calls to the system clock.
// If the two system clock calls show no difference we know that the time
// returned by the device clock can be mapped to system time.  On slow
// machines, and with some devices, it may take a significant piece of time
// to read the device clock.  We make ourselves slightly adaptive and
// use a variable to judge "short space".  The alternative is that we spin
// for ever trying to sync up the two clocks and make no progress at all.
//
//
void CWaveOutClock::ReadClockTimes(LONGLONG *pllSystem, LONGLONG *pllDeviceTime)
{
    DWORD dwCurrentPriority = GetThreadPriority(GetCurrentThread());
    if (dwCurrentPriority != THREAD_PRIORITY_TIME_CRITICAL) {
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    }

    // If we cannot sync both clocks within 50 cycles give up.  This is
    // highly unlikely on fast machines, but is possible on slower
    // machines when, for example, reading the wave device position might
    // be relatively slow.
    int i = 50;

    // Get times from both clocks.  Ensure we read both clocks within
    // the same system tick.  However if it looks like we are taking
    // forever to do this... give up.  We can resync more closely at
    // a later attempt.

#ifdef USE_PERF_COUNTER_TO_SYNC
    while (i--) {
        LARGE_INTEGER liStart, liStop;
        QueryPerformanceCounter(&liStart);
        *pllDeviceTime = ReadDeviceClock();
        *pllSystem = CSystemClock::GetTimeInternal();
        QueryPerformanceCounter(&liStop);
        if (liStop.QuadPart - liStart.QuadPart < m_llSyncClockThreshold) {
            break;
        }
    }
#else
    // We assume that reading the system clock is FAST and
    // spin until the system clock time before and after
    // reading the device clock is unchanged (or little changed).
    while (i--) {
        REFERENCE_TIME liStart;
        liStart = GetPrivateTime();
        *pllDeviceTime = ReadDeviceClock();
        *pllSystem = GetPrivateTime();

	// Are we within a 0.5 ms threshold?
	// note: with the current implementation of the system
	// clock (using timeGetTime) this means "Did the two
	// reads of the system clock return the same value
        if (*pllSystem - liStart <= m_llSyncClockThreshold) {
            break;
        }
    }
#endif
    if (i<=0) {
	// we ran through the whole loop... try not to do so again
	m_llSyncClockThreshold *= 2;
	DbgLog((LOG_TRACE, 5, TEXT("Increasing clock synchronization threshold to %d"), m_llSyncClockThreshold));
    } else {		
	DbgLog((LOG_TRACE, 5, TEXT("Clock synchronized after %d iterations"), 50-i));
    }

    if (dwCurrentPriority != THREAD_PRIORITY_TIME_CRITICAL) {
        SetThreadPriority(GetCurrentThread(), dwCurrentPriority);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\slave.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// CWaveSlave - audio renderer slaving class
//
//
// CWaveSlave 
//
// Class which supports slaving for an input stream to the audio renderer
//

#ifdef CALCULATE_AUDBUFF_JITTER
HRESULT GetStdDev( int nBuffers, int *piResult, LONGLONG llSumSq, LONGLONG iTot );
#endif

class CWaveSlave
{
    friend class CWaveOutFilter;
    friend class CWaveOutInputPin;	
    friend class CWaveOutClock;	
    friend class CDSoundDevice;

public:

    CWaveSlave( 
        CWaveOutFilter *pWaveOutFilter, 
        CWaveOutInputPin *pWaveOutInputPin );

    ~CWaveSlave() {}

protected:

    // Returns: S_OK - carry on; any necessary adjustments were made successfully 
    //		    S_FALSE - drop this buffer; we are too far behind
    HRESULT AdjustSlaveClock(
        const REFERENCE_TIME &tStart, 
        LONG * pcbData, 
        BOOL bDiscontinuity);

    void ResumeSlaving( BOOL bReset );    // prepare to resume or reset slaving
    void RefreshModeOnNextSample( BOOL bRefresh ); // prepare to resume slaving for the current playback
    BOOL UpdateSlaveMode( BOOL bSync );

    REFERENCE_TIME GetMasterClockTime
    (
        REFERENCE_TIME rtStart, 
        BOOL           bReset
    );

    REFERENCE_TIME GetSlaveClockTime
    (
        REFERENCE_TIME rtStart, 
        BOOL           bReset
    );

    HRESULT RecordBufferLateness(REFERENCE_TIME rtBufferDiff);
    
private:
    DWORD    m_dwConsecutiveBuffersNotDropped;

    CWaveOutInputPin *m_pPin;           // The renderer input pin that owns us
    CWaveOutFilter *m_pFilter;	        // The renderer that owns the input pin that owns us


    REFERENCE_TIME m_rtAdjustThreshold;
    REFERENCE_TIME m_rtWaveOutLatencyThreshold;
    FLOAT          m_fltAdjustStepFactor; 
    FLOAT          m_fltMaxAdjustFactor;
    FLOAT          m_fltErrorDecayFactor;   // probably can be global, but for the moment this allows different
                                            // different values on separate renderer instances running at the same time


    REFERENCE_TIME m_rtLastMasterClockTime; // last master master clock time (100ns)
    REFERENCE_TIME m_rtInitSlaveClockTime;  // used to reset slave time in some slaving modes
    REFERENCE_TIME m_rtErrorAccum;          // accumulated error between clock differences (100ns)
                                            //   + values => faster master clock 
                                            //   - values => faster device clock
    REFERENCE_TIME m_rtLastHighErrorSeen;   // last high error which triggered upward device rate adjustment (100ns)
    REFERENCE_TIME m_rtLastLowErrorSeen;    // last low error which triggered downward device rate adjustment (100ns)
    REFERENCE_TIME m_rtHighestErrorSeen;    // highest error seen since starting playback (100ns)
    REFERENCE_TIME m_rtLowestErrorSeen;     // lowest error seen since starting playback (100ns)

    DWORD    m_dwCurrentRate;               // current device clock frequency (Hz)
    DWORD    m_dwMinClockRate;              // lower limit on clock rate adjustments (Hz)
    DWORD    m_dwMaxClockRate;              // upper limit on clock rate adjustments (Hz)
    DWORD    m_fdwSlaveMode;                // slave mode
    DWORD    m_dwClockStep;                 // clock step size in Hz (calculated based on stream frequency)

    REFERENCE_TIME m_rtDroppedBufferDuration; // total duration of buffers dropped for clock slaving

    BOOL    m_bResumeSlaving;           // set when the graph is paused from run
                                        // to signal the slaving code to ignore
                                        // the first sample sent if the graph is
                                        // re-run directly from pause (i.e. no stop called).
    BOOL    m_bRefreshMode;             // refresh slaving mode on next sample if TRUE

    BOOL    m_bLiveButDataPrequeued;


#ifdef LOG_CLOCK_DELTAS
    REFERENCE_TIME m_rtLastSlaveClockTime;  // last slave clock time measurement (100ns)
#endif


#ifdef CALCULATE_AUDBUFF_JITTER

    // buffer jitter measurement parameters
    DWORD           m_cBuffersReceived;     // total buffers received
    int             m_iTotAcc;              // total accumulated buffer lateness error
    DWORD           m_iSumSqAcc;            // sum of squared buffer latenesses
#endif    
    REFERENCE_TIME  m_rtLastSysTimeBufferTime; // clock time of last buffer (100ns)
    

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\sounddev.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// declars a virtual CSoundDevice class that will abstract the sound device.
// The actual implementation will be based on CWaveOutDevice or CDSoundDevice
//-----------------------------------------------------------------------------

#ifndef _CSOUNDDEVICE_H_
#define _CSOUNDDEVICE_H_

class AM_NOVTABLE CSoundDevice
{

public:
    virtual MMRESULT amsndOutClose () PURE ;
    virtual MMRESULT amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc) PURE ;
    virtual MMRESULT amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText) PURE ;
    virtual MMRESULT amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos) PURE ;

    // pnAvgBytesPerSec: can be null. should be filled with the actual
    // # of bytes per second at which data is consumed otherwise (see
    // amsndOutGetPosition) .
    virtual MMRESULT amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx ,
				   double dRate, DWORD *pnAvgBytesPerSec, DWORD_PTR dwCallBack,
				   DWORD_PTR dwCallBackInstance, DWORD fdwOpen) PURE ;
    virtual MMRESULT amsndOutPause () PURE ;
    virtual MMRESULT amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh) PURE ;
    virtual MMRESULT amsndOutReset () PURE ;
    virtual MMRESULT amsndOutBreak () PURE ;
    virtual MMRESULT amsndOutRestart () PURE ;
    virtual MMRESULT amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh) PURE ;
    virtual MMRESULT amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, REFERENCE_TIME const *pStart, BOOL bIsDiscontinuity) PURE ;

    // Routines required for initialisation and volume/balance handling
    // These are not part of the Win32 waveOutXxxx api set
    virtual HRESULT  amsndOutCheckFormat (const CMediaType *pmt, double dRate) PURE;
    virtual void     amsndOutGetFormat (CMediaType *pmt)
    {
        pmt->SetType(&MEDIATYPE_Audio);
    }
    virtual LPCWSTR  amsndOutGetResourceName () PURE ;
    virtual HRESULT  amsndOutGetBalance (LPLONG plBalance) PURE ;
    virtual HRESULT  amsndOutGetVolume (LPLONG plVolume) PURE ;
    virtual HRESULT  amsndOutSetBalance (LONG lVolume) PURE ;
    virtual HRESULT  amsndOutSetVolume (LONG lVolume) PURE ;

    virtual HRESULT  amsndOutLoad (IPropertyBag *pPropBag) { return S_OK; }

    virtual HRESULT amsndOutWriteToStream(IStream *pStream) { return E_NOTIMPL; }
    virtual HRESULT amsndOutReadFromStream(IStream *pStream)  { return E_NOTIMPL; }
    virtual int     amsndOutSizeMax()  { return E_NOTIMPL; }
    virtual bool    amsndOutCanDynaReconnect() { return true ; }

    // Let the underlying device stuff silence if it can
    // It is given the length of time it should insert silence.
    // This silence may be deferred by the device until the next amsndOutWrite
    // The device is allowed to NOT support silence stuffing
    //
    // Return: S_OK - I have written the silence
    //		S_FALSE - I cannot, you must
    // virtual HRESULT  amsndOutSilence   (LONGLONG llTime) { return S_FALSE; };
    // NOT YET

    virtual ~CSoundDevice () {} ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\waveclk.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifdef	_MSC_VER
   #pragma warning(disable:4511) // disable C4511 - no copy constructor
   #pragma warning(disable:4512) // disable C4512 - no assignement operator
   #pragma warning(disable:4514) // disable C4514 -  "unreferenced inline function has been removed"
#endif	// MSC_VER

typedef void (PASCAL *CLOCKCALLBACK)(DWORD dwParm);

class CWaveOutClock : public CBaseReferenceClock
{
private:
    CWaveOutFilter *m_pFilter;

    // A copy of the reference time at which we should start to run
    LONGLONG    m_rtRunStart;

    /*  Sample time stamp tracking stuff */

    //  Bytes before last buffer that started playing which was
    //  a sync point
    LONGLONG    m_llBytesProcessed;

    //  bytes actually consumed by device (using GetPosition)
    LONGLONG    m_llBytesPlayed;

    //  Bytes in the pipe after that buffer (above)
    //
    LONGLONG    m_llBytesInLast;

    // Stream time of buffer starting
    // m_llBytesProcessed into the stream
    REFERENCE_TIME m_stBufferStartTime;
    REFERENCE_TIME m_stBufferStopTime;

    LONGLONG 	m_llLastDeviceClock;

#ifdef DEBUG
    LONGLONG    m_llEstDevRateStartTime;
    LONGLONG    m_llEstDevRateStartBytes;
#endif

public:
    BOOL	m_fAudioStarted;

    CWaveOutClock(
        CWaveOutFilter *pWaveOutFilter,
	LPUNKNOWN pUnk,
        HRESULT *phr,
	CAMSchedule * pShed
	);

    void AudioStarting(REFERENCE_TIME tStart);
    void AudioStopping();

    // update timing and position information.  returns the end of the
    // queue (the time when the data would finish playing)
    LONGLONG NextHdr(PBYTE pbData, DWORD cbData, BOOL bSync, IMediaSample *pSample);

    //  Reset the buffer statistics
    //  If bResetToZero is false assume the next buffer starts after these,
    //  otherwise assume it starts at 0
    void ResetPosition(BOOL bResetToZero = TRUE);

    void UpdateBytePositionData(DWORD nPrevAvgBytesPerSec, DWORD nCurAvgBytesPerSec);

    LONGLONG GetBytesProcessed( void ) { return m_llBytesProcessed ; }
    LONGLONG GetBytesInLastWrite( void ) { return m_llBytesInLast ; }
    LONGLONG GetBytesPlayed( void ) { return m_llBytesPlayed ; }
    LONGLONG GetLastDeviceClock( void ) { return m_llLastDeviceClock; }

    // Get the current position from the device
    // only used by the wave out filter
    // If bAbsoluteDevTime is true, return the total time played,
    // independent of stream or sample time.
    LONGLONG ReadDevicePosition(BOOL bAbsoluteDevTime = FALSE);
#ifdef DEBUG
    // estimate the actual rate at which the device is consuming data
    DWORD EstimateDevClockRate( const LONGLONG llTime, BOOL bInit = FALSE );
#endif

protected:
    // Base class virtual routines that we need to implement

    // Get the position (thus the time) from the wave device
    // This routine will only be called AFTER we have called PLAY
    // in the device clock class.  It will not be called after
    // we call STOP.
    LONGLONG ReadDeviceClock();

    // time within which to sync the system and device clocks
    LONGLONG m_llSyncClockThreshold;
    void ReadClockTimes(LONGLONG *pllSystem, LONGLONG *pllDevice);

    // Do the clock adjustment when we're running
    void AdjustClock();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\waveout.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// Digital audio renderer, David Maymudes, January 1995

#include <streams.h>
#include <mmreg.h>
#include <math.h>

#ifdef DSRENDER
#include <initguid.h>
#else
#ifdef FILTER_DLL
#include <initguid.h>
#endif
#endif

#include "waveout.h"
#include "wave.h"
#include "dsr.h"
#include "midiout.h"
#include "audprop.h"

#ifndef DSRENDER
#ifndef FILTER_DLL
#include <initguid.h>
#endif
#endif

#ifdef DEBUG
#include <stdio.h>
static int g_WaveOutFilterTraceLevel = 2;

const DWORD DBG_LEVEL_LOG_SNDDEV_ERRS        = 5;
#endif

//  Compensate for Windows NT wave mapper bug
//  The WHDR_INQUEUE bit can get left set so turn it off
inline void FixUpWaveHeader(LPWAVEHDR lpwh)
{
    //  If it accidentally got left on the DONE bit will also be set
    ASSERT(!(lpwh->dwFlags & WHDR_INQUEUE) || (lpwh->dwFlags & WHDR_DONE));
    lpwh->dwFlags &= ~WHDR_INQUEUE;
}

#ifdef FILTER_DLL
/* List of class IDs and creator functions for class factory */

CFactoryTemplate g_Templates[] = {
    {L"", &CLSID_DSoundRender, CDSoundDevice::CreateInstance},
    {L"", &CLSID_AudioRender, CWaveOutDevice::CreateInstance},
    {L"", &CLSID_AVIMIDIRender, CMidiOutDevice::CreateInstance},
    {L"Audio Renderer Property Page", &CLSID_AudioProperties, CAudioRendererProperties::CreateInstance},
    {L"Audio Renderer Advanced Properties", &CLSID_AudioRendererAdvancedProperties, CAudioRendererAdvancedProperties::CreateInstance},
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif

// If the following is defined, we pretend that the wave device plays at this fraction of
// the requested rate, to test our synchronization code....
// #define SIMULATEBROKENDEVICE 0.80

// setup data to allow our filter to be self registering

const AMOVIESETUP_MEDIATYPE
wavOpPinTypes = { &MEDIATYPE_Audio, &MEDIASUBTYPE_NULL };

const AMOVIESETUP_PIN
waveOutOpPin = { L"Input"
               , TRUE          // bRendered
               , FALSE         // bOutput
               , FALSE         // bZero
               , FALSE         // bMany
               , &CLSID_NULL       // clsConnectToFilter
               , NULL              // strConnectsToPin
               , 1             // nMediaTypes
               , &wavOpPinTypes }; // lpMediaTypes

// IBaseFilter stuff

/* Return our single input pin - not addrefed */

CBasePin *CWaveOutFilter::GetPin(int n)
{
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: GetPin, %d"), n));
    /* We only support one input pin and it is numbered zero */
    return n==0 ? m_pInputPin : NULL;
}


// switch the filter into stopped mode.
STDMETHODIMP CWaveOutFilter::Stop()
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: STOP")));

    // limit the scope of the critical section as
    // we may need to call into the resource manager in which case
    // we must NOT hold our critical section
    BOOL bCancel = FALSE;
    BOOL bNotify = FALSE;
    {
        CAutoLock lock(this);

        if (m_State == State_Stopped) return NOERROR;

        DbgLog((LOG_TRACE, 4, "wo: STOPping"));

        // transitions to STOP from RUN must go through PAUSE
        // pause the device if we were running
        if (m_State == State_Running) {
            hr = Pause();
        }

        // reset the EC_COMPLETE flag as we will need to send another if
        // we re-enter run mode.
        m_bHaveEOS = FALSE;
        m_eSentEOS = EOS_NOTSENT;
        DbgLog((LOG_TRACE, 4, "Clearing EOS flags in STOP"));

        // If we paused the system then carry on and STOP
        if (!FAILED(hr)) {

            DbgLog((LOG_TRACE,1,TEXT("Waveout: Stopping....")));

            // need to make sure that no more buffers appear in the queue
            // during or after the reset process below or the buffer
            // count may get messed up - currently Receive holds the
            // filter-wide critsec to ensure this

            // force end-of-stream clear
            // this means that if any buffers complete the callback will
            // not signal EOS
            InterlockedIncrement(&m_lBuffers);

            if (m_hwo) {
                // Remember the volume when we Stop.  We do not do this when we
                // release the wave device as CWaveAllocator does not have
                // access to our variables.  And rather than linking the two
                // classes any more closely we check on the closing volume now.

                // See if we are setting the volume on this stream.  If so,
                // grab the current volume so we can reset it when we regain
                // the wave device.
                if (m_fVolumeSet) {
                    m_BasicAudioControl.GetVolume();
                }
                amsndOutReset();
                DbgLog((LOG_TRACE, 4, "Resetting the wave device in STOP, filter is %8x", this));
            }

            // now force the buffer count back to the normal (non-eos) 0.
            // at this point, we are sure there are no more buffers coming in
            // and no more buffers waiting for callbacks.
            ASSERT(m_lBuffers >= 0);
            m_lBuffers = 0;

            // base class changes state and tells pin to go to inactive
            // the pin Inactive method will decommit our allocator, which we
            // need to do before closing the device.
            hr =  CBaseFilter::Stop();

            // Make sure Inactive() is called.  CBaseFilter::Stop() does not call Inactive() if the
            // input pin is not connected.
            hr = m_pInputPin->Inactive();

        } else {
            DbgLog((LOG_ERROR, 1, "FAILED to Pause waveout when trying to STOP"));
        }


        // call the allocator and see if it has finished with the device
        if (!m_hwo) {
            bCancel = TRUE;

            ASSERT(!m_bHaveWaveDevice);
#if 0
        } else if (m_cDirectSoundRef || m_cPrimaryBufferRef ||
                            m_cSecondaryBufferRef) {
            DbgLog((LOG_TRACE, 2, "Stop - can't release wave device yet!"));
            DbgLog((LOG_TRACE, 2, "Some app has a reference count on DSound"));
            // Sorry, we can't give up the wave device yet, some app has a
            // reference count on DirectSound
#endif
        } else if (m_dwLockCount == 0) /* ZoltanS fix 1-20-98 */ {
            // stop using the wave device
            m_bHaveWaveDevice = FALSE;

            if(m_pInputPin->m_pOurAllocator)
                hr = m_pInputPin->m_pOurAllocator->ReleaseResource();

            // this returns S_OK if the allocator has finished with the
            // device already, or otherwise it will call back to our
            // OnReleaseComplete when the last buffer is freed
            if (S_OK == hr) {
                // release done - close device
                CloseWaveDevice();

                // notify the resource manager -- outside the critsec
                bNotify = TRUE;
            }
        } // end if (!m_hwo)

        // We have now completed our transition into "paused" state
        // (i.e. we don't need to wait for any more data, we're gonna stop instead)
        m_evPauseComplete.Set();
    } // end of autolock scope

    ASSERT(CritCheckOut(this));
    if (m_pResourceManager) {
         if (bCancel) {
             // we're no longer waiting for the device
             m_pResourceManager->CancelRequest(
                         m_idResource,
                         (IResourceConsumer*)this);
         } else if (bNotify) {
             // we've finished with the device now
             m_pResourceManager->NotifyRelease(
                         m_idResource,
                         (IResourceConsumer*)this,
                         FALSE);
         }
    }

    return hr;
}

STDMETHODIMP CWaveOutFilter::Pause()
{
    {
        CAutoLock lck(&m_csComplete);
        m_bSendEOSOK = false;
    }

    /*  Do the main function and see what happens */
    HRESULT hr;
    {
        CAutoLock lck(this);
        hr = DoPause();
    }
    if (FAILED(hr)) {

        /*  Fool stop into doing something */
        m_State = State_Paused;
        Stop();
    }
    return hr;
}

HRESULT CWaveOutFilter::DoPause()
{
    HRESULT hr = S_OK;
    HRESULT hrIncomplete = S_OK;
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: PAUSE")));

    // cancel any outstanding EOS callback
    CancelEOSCallback();

    m_pInputPin->m_Slave.ResumeSlaving( FALSE );
    m_pInputPin->m_bPrerollDiscontinuity = FALSE;

    /* Check we can PAUSE given our current state */

    if (m_State == State_Running) {
        DbgLog((LOG_TRACE,2,TEXT("Waveout: Running->Paused")));
        m_evPauseComplete.Set();   // We have end of stream - transition is complete
        DbgLog((LOG_TRACE, 3, "Completing transition to Pause from RUN"));

        if (m_hwo) {

            // If we have a pending callback to restart the wave device
            // then blow it away.  Using m_dwAdviseCookie is reasonable as this
            // value is only set if we get a deferred wave start.

            // must hold dev critsec to close window between him testing
            // and him setting this or he could read it before we reset it
            // and then restart after we pause.

            DWORD_PTR dwCookie;

            { // scope for lock
                ASSERT(CritCheckIn(this));
                dwCookie = m_dwAdviseCookie;
                m_dwAdviseCookie = 0;
            }

            // Clean up if necessary to prevent the (unusual?) case of
            // the next RUN command arriving before the existing callback
            // fires.
            if (dwCookie) {
                // There was a pending callback waiting just a moment ago...
                // Clear it now.  Note: if the unadvise fires at any time
                // the call back routine will do nothing as we have cleared
                // m_dwAdviseCookie.  We call Unadvise now to prevent any
                // such callback from here on.
                // We can call Unadvise as we hold no relevant locks

                // we know we have a clock otherwise the cookie would
                // not have been set
                DbgLog((LOG_TRACE, 3, "Cancelling callback in ::Pause"));
                m_callback.Cancel(dwCookie);
                // we cannot hold the device lock while calling UnAdvise,
                // but by setting m_dwAdviseCookie to 0 above IF the
                // call back fires it will be benign.
            }


            // we will enter here with the device when we are doing
            // a restart to regain the audio. In this case, we did not
            // start the wave clock, and hence should not stop it.
            if (m_pRefClock) {
                m_pRefClock->AudioStopping();
            }
            amsndOutPause();
            SetWaveDeviceState(WD_PAUSED);

            // IF there are no buffers queued, i.e. everything has been
            // played, AND we have had an EOS then we reset the EOS flag
            // so that the next time we enter RUN we will send EOS
            // immediately.  If there are still buffers queued, then
            // we do not want to reset the state of the EOS flag.
            // We rely on the fact that the callback code will set
            // m_eSentEOS to EOS_SENT from EOS_PENDING once it gets the
            // last buffer.
            // We also rely on the amsndOutPause being synchronous.
            if (m_eSentEOS == EOS_SENT) {
                // we have, or had, an EOS in the queue.
                m_eSentEOS = EOS_NOTSENT;
            } else {
                // if we have received EOS the state should be EOS_PENDING
                // if we have not received EOS the state should be NOTSENT
                ASSERT(!m_bHaveEOS || m_eSentEOS == EOS_PENDING);
            }

        } else {
            // Next time we enter RUN we want to send EOS again... if the
            // data has run out, so remember that we have left RUNNING state.
            m_eSentEOS = EOS_NOTSENT;
        }
    }
    else if (m_State == State_Stopped)
    {
        // Any EOS received while stopped are thrown away.
        // Upstream filters must EOS us again if / when required.
        m_bHaveEOS = FALSE;
        // don't open the wave device if no connection
        if (m_pInputPin->IsConnected())
        {
            DbgLog((LOG_TRACE,2,TEXT("Waveout: Stopped->Paused")));
            m_evPauseComplete.Reset();   // We have no data
            hrIncomplete = S_FALSE;
            // or we have already received End Of Stream


            // open the wave device. We keep it open until the
            // last buffer using it is released and the allocator
            // goes into Decommit mode (unless the resource
            // manager calls ReleaseResource).
            // We will not close it as long as an app has a reference on the
            // DirectSound interface
            // We may already have it open if an app has asked us for the
            // DirectSound interfaces, and that's OK
            if (!m_bHaveWaveDevice) AcquireWaveDevice();
            hr = S_OK;

            // failing to get the wave device is not an error - we still
            // continue to work, but with no sound (ie we need to do the
            // CBaseFilter::Pause below).

            if (m_pRefClock) m_pRefClock->ResetPosition();

            // reset slaving and other stat parameters when making a transition from stop to pause
            m_pInputPin->m_Slave.ResumeSlaving( TRUE ); // reset everything
            m_pInputPin->m_Stats.Reset();

        } else {
            // not connected.  Set the event so that we do not
            // wait around in GetState()
            DbgLog((LOG_TRACE,2,TEXT("Waveout: Inactive->Paused, not connected")));
            m_evPauseComplete.Set();   // We do not need data
        }
    } else {
        ASSERT(m_State == State_Paused);
    }

    // tell the pin to go inactive and change state
    if (SUCCEEDED(hr) && SUCCEEDED(hr = CBaseFilter::Pause())) {

        // we complete the transition when we get data or EOS
        // (this might already be so if we get 2 pause commands)
        // OR we are not connected.
        hr = hrIncomplete;
    }

    return hr;
}


STDMETHODIMP CWaveOutFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock lock(this);
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: RUN")));

    HRESULT hr = NOERROR;

    FILTER_STATE fsOld = m_State;  // changed by CBaseFilter::Run

    // this will call Pause if currently Stopped
    hr = CBaseFilter::Run(tStart);
    if (FAILED(hr)) {
        return hr;
    }

    MSR_START(m_idStartRunning);

    if (fsOld != State_Running) {

        // If m_eSentEOS is set it means that data is/was queued
        // up.  We still need to run to push the data through the wave
        // device.

        DbgLog((LOG_TRACE,2,TEXT("Waveout: Paused->Running")));

        LONG buffercount;
        {
            CAutoLock lck(&m_csComplete);
            m_bSendEOSOK = true;

            // we should not open the device if we have no input connection
            if (!m_pInputPin->IsConnected()) {
                ASSERT(!m_bHaveWaveDevice);
                SendComplete(FALSE);
                MSR_STOP(m_idStartRunning);
                return S_OK;
            }

            // If we have been sent EOS then we will not get any more data.
            // But we have transitioned to RUN and therefore need to send
            // another EC_COMPLETE.
            if (m_bHaveEOS && !m_eSentEOS) {
                SendComplete(FALSE);
                DbgLog((LOG_TRACE, 3, "Sending EOS in RUN as no more data will arrive"));
                MSR_STOP(m_idStartRunning);
                return S_OK;
            }

            // the queued data might be just an end of
            // stream - in which case, signal it here
            // since we are not running, we know there are no wave
            // callbacks happening, so we are safe to check this value

            // if we are not connected, then we will never get any data
            // so in this case too, don't start the wave device and
            // signal EC_COMPLETE - but succeed the Run command
            //
            // ** Done in paragraph above.  From here on we ARE connected
            //
            // if we have no wave device, then we process EOS in the
            // receive call when we reject it. This is based on the assumption
            // that we must get either a Receive or a EndofStream call (until
            // we have rejected a Receive the upstream filter has no way of knowing
            // anything is different).
            buffercount = m_lBuffers;
        }

        if (buffercount < 0) {

            // do an EC_COMPLETE right now

            //  This is where an EC_COMPLETE scheduled when were were
            //  in State_Paused state gets picked up

            SendComplete(buffercount < 0);

        } else if (!m_bHaveWaveDevice) {

            // try and get the wave device again... as we are about to run
            // our priority will have increased, except we cannot request
            // the resource while we have the filter locked.

#if 0
            hr = m_pResourceManager->RequestResource(
                        m_idResource,
                        GetOwner(),
                        (IResourceConsumer*)this);
            if (S_OK == hr) {
                // we can get it immediately...
                hr = AcquireResource(m_idResource);
            }

            if (S_OK != hr) QueueEOS();
#else
            // schedule a delayed EOS if we have no wave device --
            // but not if we are not connected since in that case we have no
            // idea about the segment length
            // delayed EC_COMPLETE
            QueueEOS();
#endif
        } else if (buffercount == 0 && !m_bHaveEOS) {
            // do nothing?

            DbgLog((LOG_TRACE, 1, "Run with no buffers present, doing nothing."));

        } else {

            // we're about to Run, so set the Slave class to recheck on reception
            // of the next sample whether we're being sourced by a push source in
            // case we need to slave to live data.
            m_pInputPin->m_Slave.RefreshModeOnNextSample( TRUE );

            // The restart is postponed until the correct start time.
            // If there is less than 5ms until the start we go
            // immediately, otherwise we get the clock to call us back
            // and start the wave device (more or less) on time.

            MSR_START(m_idRestartWave);

            // tell our reference clock that we're playing now....
            // the filter graph might be using someone else's clock
            // hence calls to get the time should be against the FILTER
            // clock (which is given to us by the filter graph)
            if (m_pRefClock && m_pClock) {

                // If there is still a significant portion of time
                // that should run before we start playing, get the
                // clock to call us back.  Otherwise restart the
                // wave device now.
                // we can only do this by using our own clock

                REFERENCE_TIME now;
                m_pClock->GetTime(&now);

                DbgLog((LOG_TIMING, 2, "Asked to run at %s.  Time now %s",
                    (LPCTSTR)CDisp(tStart, CDISP_DEC), (LPCTSTR)CDisp(now, CDISP_DEC)));

                // Take account of non-zero start times on the first received buffer.
                // Remove our lock for a while and hope the transition to pause completes.
                {
    #if 0           // We need extra checks if we're going to unlock
                    Unlock();
                    ASSERT( CritCheckOut(this) );
                    // Can't wait too long here....  If we don't get data, we'll just
                    // end up with GetFirstBufferStartTime == 0;
                    m_evPauseComplete.Wait(200);
                    Lock();
    #endif
                    // If the wait timed out, GetFirstBufferStartTime will be zero.  Well, we tried....
                    tStart += m_pInputPin->GetFirstBufferStartTime();
                }
                // If we need to wait more than 5ms do the wait, otherwise
                // start immediately.

                const LONGLONG rtWait = tStart - now - (5* (UNITS/MILLISECONDS));

                // Do we need to wait ?
                if (rtWait > 0) {

                    { // scope for lock

                        // have to ensure that AdviseCallback is atomic
                        // or the callback could happen before
                        // m_dwAdviseCookie is set

                        ASSERT(CritCheckIn(this));
                        ASSERT(0 == m_dwAdviseCookie);

                        // Set up a new advise callback
                        DbgLog((LOG_TRACE, 2, TEXT("Scheduling RestartWave for %dms from now"), (LONG) (rtWait/10000) ));
                        HRESULT hr = m_callback.Advise(
                            RestartWave,    // callback function
                            (DWORD_PTR) this,   // user token passed to callback
                            now+rtWait,
                            &m_dwAdviseCookie);
                        ASSERT( SUCCEEDED( hr ) );
                        ASSERT(m_dwAdviseCookie);

                        // if for some reason we failed to set up the
                        // advise we must start the device running now
                        if (!m_dwAdviseCookie) {
                            if (MMSYSERR_NOERROR == amsndOutRestart()) {
                                SetWaveDeviceState(WD_RUNNING);
                            } else {
                                SetWaveDeviceState(WD_ERROR_ON_RESTART);
                            }
                        }
                    }
                } else {
                    // we can startaudio now... the time interval is small
                    m_pRefClock->AudioStarting(m_tStart);
                    DWORD mmr = amsndOutRestart();
                    ASSERT(MMSYSERR_NOERROR == mmr);
                    SetWaveDeviceState(WD_RUNNING);
                    if (mmr) {
                        SetWaveDeviceState(WD_ERROR_ON_RESTARTA);
                    }
                }
            } else {
                // no clock... simply restart the wave device
                // we have not created our clock
                // naughty...
                DWORD mmr = amsndOutRestart();
                SetWaveDeviceState(WD_RUNNING);
                ASSERT(MMSYSERR_NOERROR == mmr);
                if (mmr) {
                    SetWaveDeviceState(WD_ERROR_ON_RESTARTB);
                }
            }
            MSR_STOP(m_idRestartWave);
        }
    }
    MSR_STOP(m_idStartRunning);

    return S_OK;
}

// We were asked to run in advance of the real start time.  Hence we set
// up an Advise on the m_callback CCallbackThread object.  All we
// need to do is start the wave device rolling.  NOTE: IF some
// event means that ::Stop has been called we do not want to restart
// the wave device.  Indeed, we may not have a wave device...
void CALLBACK CWaveOutFilter::RestartWave(DWORD_PTR thispointer)
{
    CWaveOutFilter* pFilter = (CWaveOutFilter *) thispointer;
    ASSERT(pFilter);
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: RESTARTWAVE")));

    // The pFilter lock will (should!) have been taken by the CCallbackThread before it called us.
    ASSERT(CritCheckIn(pFilter));

    if (pFilter->m_dwAdviseCookie) {

        // have we lost the device ?
        pFilter->RestartWave();
    }
}


void CWaveOutFilter::RestartWave()
{
    if (m_bHaveWaveDevice) {
        // This callback should only be called if the filter is running and it
        // is not being flushed.  The filter can prevent the callback from being 
        // called by canceling the advise associated with m_dwAdviseCookie.  The
        // advise should be canceled if the filter's input pin is going to be flushed
        // and if the filter's run-pause-stop state is being changed.
        ASSERT((m_State == State_Running) && !m_pInputPin->IsFlushing());
        ASSERT(m_pRefClock);
        DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wave advise callback fired for filter %8x"), this));
        m_dwAdviseCookie = 0;
        m_pRefClock->AudioStarting(m_tStart);
        MSR_START(m_idRestartWave);
        DWORD mmr = amsndOutRestart();
        ASSERT(MMSYSERR_NOERROR == mmr);
        SetWaveDeviceState(mmr ? WD_ERROR_ON_RESTARTC : WD_RUNNING);
        MSR_STOP(m_idRestartWave);
    }
}

//
// We only complete the transition to pause if we have data
// and we are expecting data (i.e. connected)
//

HRESULT CWaveOutFilter::GetState(DWORD dwMSecs,FILTER_STATE *State)
{
    CheckPointer(State,E_POINTER);
    HRESULT hr = NOERROR;
    if (State_Paused == m_State)
    {
        // if we are waiting for data we return VFW_S_STATE_INTERMEDIATE
        // if we have had EOS we are not in an intermediate state

        if (m_evPauseComplete.Wait(dwMSecs) == FALSE) {
            // no data queued (the event is not set)

            // the normal case is that no buffers have been queued
            // (otherwise the event would have been triggered) but as
            // we have no interlock we cannot check that there are no
            // queued buffers.  We CAN check that we are connected.
            ASSERT(m_pInputPin->IsConnected());
            hr = VFW_S_STATE_INTERMEDIATE;
        }
    }
    *State = m_State;

    return hr;
}


// attempt to acquire the wave device. Returns S_FALSE if it is busy.
HRESULT
CWaveOutFilter::AcquireWaveDevice(void)
{
    // have we registered the device?
    HRESULT hr;

    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: AcquireWaveDevice")));
    // this is the one location when we can have the filter locked
    // while calling the resource manager.  even this is a bit iffy...
    ASSERT(CritCheckIn(this));

    if (m_pResourceManager) {
        if (m_idResource == 0) {
            hr = m_pResourceManager->Register(m_pSoundDevice->amsndOutGetResourceName(),
                              1, &m_idResource);
            if (FAILED(hr)) {
                return hr;
            }
        }

        ASSERT(!m_bHaveWaveDevice);
        ASSERT(!m_hwo);

        // attempt to acquire the resource - focus object is the
        // outer unknown for this filter.
        hr = m_pResourceManager->RequestResource(
                    m_idResource,
                    GetOwner(),
                    (IResourceConsumer*)this);
        if (S_OK != hr) {
            return S_FALSE;
        }
    }
    // else if no resource manager, carry on anyway

    // returns S_OK or an error
    hr = OpenWaveDevice();

    // tell the resource manager if we succeeded or failed (but not if
    // we postponed it)
    if (S_FALSE != hr) {

        if (m_pResourceManager) {
            m_pResourceManager->NotifyAcquire(
                        m_idResource,
                        (IResourceConsumer*) this,
                        hr);
        }
    }

    return hr;
}


inline HRESULT CWaveOutFilter::CheckRate(double dRate)
{
    ASSERT(CritCheckIn(this));      // must be in the filter critical section
    ASSERT(dRate > 0.0);

    // safe to do even if we're not connected
    return m_pSoundDevice->amsndOutCheckFormat(&m_pInputPin->m_mt, dRate);
}


//
// CWaveOutFilter::ReOpenWaveDevice - reopen the wave the device using a new format
//
// Here's how we deal with this:
//
// 1. If we're using WaveOut...
//
//      i.  If the graph is not stopped...
//              a. Reset the waveout device to release any queued buffers.
//              b. Unprepare all wave buffers.
//
//      ii. Close the wave device.
//
// 2. Set the new media type.
//
// 3.If we're using DSound...
//
//      i.   Save the current wave state.
//      ii.  Call RecreateDSoundBuffers() to create a new secondary buffer and
//              update the primary format.
//      iii. Update the wave clock's byte position data so that offsets are
//              adjusted for the new rate.
//      iv.  Set the current wave state back to the original.
//
//   Else if we're using waveout...
//
//      i. Open the waveout device with the new format.
//
// 4. Reprepare the allocator's buffers.
//
HRESULT CWaveOutFilter::ReOpenWaveDevice(CMediaType *pNewFormat)
{
    HRESULT hr = S_OK;
    waveDeviceState  wavestate = m_wavestate; // save the current wavestate

    if( !m_fDSound )
    {
        if (m_State != State_Stopped)
        {
            // we're going to stay in this state and reopen the waveout device
            // we need to make sure that no more buffers appear in the queue
            // during or after the reset process below or the buffer
            // count may get messed up - currently Receive holds the
            // filter-wide critsec to ensure this

            InterlockedIncrement(&m_lBuffers);

            if (m_hwo)
            {
                DbgLog((LOG_TRACE, 4, "Resetting the wave device in ReOpenWaveDevice, filter is %8x", this));

                amsndOutReset();
            }

            // now force the buffer count back to the normal (non-eos) 0.
            // at this point, we are sure there are no more buffers coming in
            // and no more buffers waiting for callbacks.
            ASSERT(m_lBuffers >= 0);
            m_lBuffers = 0;

            if(m_pInputPin->m_pOurAllocator)
                hr = m_pInputPin->m_pOurAllocator->ReleaseResource();

        }
        EXECUTE_ASSERT(MMSYSERR_NOERROR == amsndOutClose());
        SetWaveDeviceState(WD_CLOSED);

        m_hwo = 0;        // no longer have a wave device
    }

    if(FAILED(hr))
        return hr;

    // save the previous rate before setting the new
    DWORD dwPrevAvgBytesPerSec = m_pInputPin->m_nAvgBytesPerSec;

    m_pInputPin->SetMediaType(pNewFormat);  // set the new media type

    if (m_bHaveWaveDevice)
    {
        if (m_fDSound)
        {
            ASSERT(m_State != State_Stopped);
            ((CDSoundDevice *) m_pSoundDevice)->RecreateDSoundBuffers();

            if (m_pRefClock) {
                m_pRefClock->UpdateBytePositionData(
                                        dwPrevAvgBytesPerSec,
                                        WaveFormat()->nAvgBytesPerSec);
            }
            // Is this needed? Check.
            m_pInputPin->m_nAvgBytesPerSec = WaveFormat()->nAvgBytesPerSec;

            SetWaveDeviceState (wavestate);
        }
        else
        {
            hr = DoOpenWaveDevice();
            if (!m_hwo)
            {

                // Failed to get the device... use the resource manager
                // to try and recover?  Probably not feasible as no-one
                // within quartz would have been allowed to pick up the
                // device without the OK of the resource manager.
                DbgLog((LOG_ERROR, 1, "ReOpenWaveDevice: Failed to open device with new format"));
                return hr;
             }
             else
             {
                // if Paused we need to Pause the wave device
                if (m_State == State_Paused)
                {
                    amsndOutPause();
                    SetWaveDeviceState(WD_PAUSED);
                } else
                {
                    ASSERT(m_State == State_Running);
                    //DbgLog((LOG_TRACE, 2, "ReOpenWaveDevice: Change of format while running"));
                    SetWaveDeviceState (wavestate);
                }

            }
        }

        if( SUCCEEDED( hr ) )
        {
            //
            // reset slaving parameters after a dynamic format change!
            // in dv capture graphs, for instance, we may get dynamic format changes
            // while we're slaving
            //
            m_pInputPin->m_Slave.ResumeSlaving( TRUE ); // (TRUE = reset all slave params)
        }

        // If we do this for DSound we need to correctly release too!
        if(m_pInputPin->m_pOurAllocator)
            // reprepare our allocator's buffers
            hr = m_pInputPin->m_pOurAllocator->OnAcquire((HWAVE) m_hwo);

    }

    return hr;
}


//
// get the wave device if not already open, taking account of
// playback rate
//

HRESULT CWaveOutFilter::DoOpenWaveDevice(void)
{
    WAVEFORMATEX *pwfx = WaveFormat();
    UINT err;

    // m_pInputPin->m_dRate (and the m_dRate it shadows) are set in
    // NewSegment independent of m_dRate. if we can't open the wave
    // device at a particular rate they are different. Receive will
    // eventually fail in this case
    //
    // ASSERT( m_pInputPin->CurrentRate() == m_dRate ); // paranoia

    if (!pwfx)
    {
        DbgLog((LOG_ERROR, 0, TEXT("CWaveOutFilter::DoOpenWaveDevice !pwfx")));
        return (S_FALSE);  // not properly connected.  Ignore this non existent wave data
    }

    // !!! adjust based on speed?
    // !!! for the moment, only for PCM!!!
    double dRate = 1.0;
    if (m_pImplPosition) {
        // First use IMediaSeeking
        HRESULT hr = m_pImplPosition->GetRate(&dRate);
        if (FAILED(hr)) {
            // if that fails, try IMediaPosition
            hr = m_pImplPosition->get_Rate(&dRate);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("Waveout: Failed to get playback rate")));
                ASSERT(dRate == 1.0);
            }
        }
    }

#ifdef SIMULATEBROKENDEVICE
    dRate *= SIMULATEBROKENDEVICE;
#endif

    DWORD nAvgBytesPerSecAdjusted;

    ASSERT(CritCheckIn(this));       // must be in the filter critical section
    ASSERT(!m_hwo);
    err = amsndOutOpen(
        &m_hwo,
        pwfx,
        dRate,
        &nAvgBytesPerSecAdjusted,
        (DWORD_PTR) &CWaveOutFilter::WaveOutCallback,
        (DWORD_PTR) this,
        CALLBACK_FUNCTION);

    // !!! if we can't open the wave device, should we do a
    // sndPlaySound(NULL) and try again? -- now done by MMSYSTEM!

    if (MMSYSERR_NOERROR != err) {
#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText(err, message, sizeof(message)/sizeof(TCHAR));
        DbgLog((LOG_ERROR,0,TEXT("Error opening wave device: %u : %s"), err, message));
#endif
        m_hwo = NULL;
        SetWaveDeviceState(WD_ERROR_ON_OPEN);
        m_lastWaveError = err;
        if(m_fDSound)
            return E_FAIL;
        else
            return err == MMSYSERR_ALLOCATED ? S_FALSE : E_FAIL;
    }

    if(dRate == 1.0)
    {
        ASSERT(nAvgBytesPerSecAdjusted == (DWORD)(pwfx->nAvgBytesPerSec));
    }

    //  Cache the bytes per second we set for the clock to use
    SetWaveDeviceState(WD_OPEN);
    m_pInputPin->m_nAvgBytesPerSec = nAvgBytesPerSecAdjusted;

    m_dRate = dRate;

    ASSERT(m_hwo);
    DbgLog((LOG_TRACE,1,TEXT("Have wave out device: %u"), m_hwo));
    if (m_pRefClock) m_pRefClock->ResetPosition();
        return S_OK;
}


// open the wave device if not already open
// called by the wave allocator at Commit time
// returns S_OK if opened successfully, or an error if not.
HRESULT
CWaveOutFilter::OpenWaveDevice(void)
{
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: OpenWaveDevice")));
    ASSERT(!m_hwo);

#ifdef LATER  // bug 26045 - potential reason
    if (m_hwo) {
        // the most likely cause for the device still being open is that we
        // lost the device (via ReleaseResource) and were then told to
        // reacquire the device before actually releasing it.
        m_bHaveWaveDevice = TRUE;   // we will still need to restart
        return S_FALSE;
    }
#endif

    //  If application has forced acquisition of resources just return
    if (m_dwLockCount != 0) {
        ASSERT(m_hwo);
        return S_OK;
    }

    HRESULT hr = DoOpenWaveDevice();
    if (S_OK != hr) {
        DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: OpenWaveDevice: DoOpenWaveDevice returned 0x%08X"), hr));
        return hr;
    }
    // pause the device even if we decide to postpone the rest of the open
    amsndOutPause();
    SetWaveDeviceState(WD_PAUSED);

    if (m_fVolumeSet) {
        m_BasicAudioControl.PutVolume();
    }

    // tell the allocator to PrepareHeader its buffers
    if(m_pInputPin->m_pOurAllocator) {
        hr = m_pInputPin->m_pOurAllocator->OnAcquire((HWAVE) m_hwo);
        DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: OpenWaveDevice: OnAcquire returned 0x%08X"), hr));

        if (FAILED(hr)) {
            amsndOutClose();
            SetWaveDeviceState(WD_CLOSED);
            m_hwo = 0;
            ASSERT(!m_bHaveWaveDevice);
            return hr;
        } else {
            ASSERT(S_OK == hr);
        }
    }

    // now we can accept receives
    m_bHaveWaveDevice = TRUE;

    return S_OK;
}

// close the wave device
//
// should only be called when wave device is open
HRESULT
CWaveOutFilter::CloseWaveDevice(void)
{
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: CloseWaveDevice")));
    ASSERT(m_hwo);
    if (m_hwo && m_dwLockCount == 0) {
#ifdef THROTTLE
        // turn off video throttling
        SendForHelp(m_nMaxAudioQueue);
#endif // THROTTLE
        EXECUTE_ASSERT(MMSYSERR_NOERROR == amsndOutClose());
        SetWaveDeviceState(WD_CLOSED);
        m_hwo = NULL;
    }

    return NOERROR;
}

// Send EC_COMPLETE to the filter graph if we haven't already done so
//
// bRunning is TRUE if we've actually got a wave device we're sending
// data to
void CWaveOutFilter::SendComplete(BOOL bRunning, BOOL bAbort)
{
    CAutoLock lck(&m_csComplete);

    if (bAbort)
    {
        // In this case signal an abort (but we still send EC_COMPLETE
        // in case some app doesn't handle the abort).
        NotifyEvent(EC_ERRORABORT, VFW_E_NO_AUDIO_HARDWARE, 0);
    }

    if (bRunning) {
        EXECUTE_ASSERT(InterlockedIncrement(&m_lBuffers) == 0);
    }

    if (m_bSendEOSOK) {
        //  Balance count
        ASSERT(m_State == State_Running);
        m_eSentEOS = EOS_SENT;
        NotifyEvent(EC_COMPLETE, S_OK, (LONG_PTR)(IBaseFilter *)this);
    }
}

//
//  Schedule a 'complete' and send it if suitable
//
HRESULT CWaveOutFilter::ScheduleComplete(BOOL bAbort)
{
    //
    //  Can only be called when we're synchronized
    //
    ASSERT(CritCheckIn(this));

    HRESULT hr = m_pInputPin->CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }

    //
    //  Check we didn't do it already
    //
    if (m_eSentEOS) {
        return VFW_E_SAMPLE_REJECTED_EOS;
    }

    //
    //  Don't allow any more.  Set it now in case decrementing the buffer
    //  count causes the callback code to send EOS
    //
    m_eSentEOS = EOS_PENDING;

    // The EC_COMPLETE WILL now be sent.  Either immediately if we have
    // no data queued, or when the last buffer completes its callback.
    // We will NOT get any more data.

    //
    //  Tell the wave device to do it
    //
    if (InterlockedDecrement(&m_lBuffers) < 0 && m_State == State_Running) {
        // no buffers queued, and we are running, so send it now

        SendComplete(TRUE, bAbort);

    }
    return S_OK;
}

#ifdef THROTTLE

// Send quality notification to m_piqcSink when we run short of buffers
// n is the number of buffers left
HRESULT CWaveOutFilter::SendForHelp(int n)
{
    if (m_eSentEOS) {

        // we expect to run out of data at EOS, but we have to send
        // a quality message to stop whatever throttling is going on
        // Thus, if we had previously sent a message, send another now
        // to undo the throttling

        if (m_nLastSent && m_nLastSent<m_nMaxAudioQueue) {
            n=m_nMaxAudioQueue;
        } else {
            return NOERROR; // we expect to run out of data at EOS
        }

    }

    // This is heuristricky

#if 0
// don't look at the allocator.  We maintain the maximum size the
// queue gets to, which means that if a source only sends us a few
// buffers we do not think we are starving.
    ALLOCATOR_PROPERTIES AlProps;
    HRESULT hr = m_pInputPin->m_pOurAllocator->GetProperties(&AlProps);
    int nMaxBuffers = AlProps.cBuffers;    // number of buffers in a full queue
#endif

    // No "Mark Twain".
    // Don't bother shouting the same number continuously.
    // If we are equal or only one worse than last thing sent, and we're not getting
    // too near the bottom (last 1/4), just go home.
    // We expect continual +/-1 fluctuation anyway.

    if (  (n==m_nLastSent)
       || ((n==m_nLastSent-1) &&  (4*n > m_nMaxAudioQueue))
       )
    {
        return NOERROR;
    }

    Quality q;
    q.Type = Famine;
    q.TimeStamp = 0;               // ??? a lie
    q.Late = 0;                // ??? a lie

    m_nLastSent = n;
    ASSERT(m_nMaxAudioQueue);
    q.Proportion = (n>=m_nMaxAudioQueue-1 ? 1100 : (1000*n)/m_nMaxAudioQueue);

    if (m_piqcSink) {
        DbgLog((LOG_TRACE, 0, TEXT("Sending for help n=%d, max = %d"),
                n, m_nMaxAudioQueue));
        // By the way - IsEqualObject(m_pGraph, m_piqSink) can be quite expensive.
        // and simple equality does not hack it.
        m_piqcSink->Notify(this, q);
    }
    return NOERROR;
}

#endif // THROTTLE



// If you want to do 3D sound, you should use the IDirectSound3DListener
// and IDirectSound3DBuffer interfaces.  IAMDirectSound never worked, so I
// am removing support for it. - DannyMi 5/6/98

// Give the IDirectSound interface to anyone who wants it
//
HRESULT CWaveOutFilter::GetDirectSoundInterface(LPDIRECTSOUND *lplpds)
{
    return E_NOTIMPL;

#if 0
    // only for DSound
    if (!m_fDSound) {
        return E_NOTIMPL;
        // should probably create a new error message
    }

    // We have to be connected first to know our format
    if (!m_pInputPin->IsConnected())
        return E_UNEXPECTED;

// we can't open the wave device until pause - bad things happen
// Don't worry, the device will handle this
#if 0
    // They are asking for the direct sound interface before we've opened
    // DirectSound.  Better open it now.
    if (!m_bHaveWaveDevice) {
        CAutoLock lock(this);   // doing something real... better take critsect
    if (AcquireWaveDevice() != S_OK)
        return E_FAIL;
    }
#endif

    if (lplpds) {
        // See if the sound device we're using can give us the interface
        HRESULT hr = ((CDSoundDevice*)m_pSoundDevice)->amsndGetDirectSoundInterface(lplpds);
        if (SUCCEEDED(hr)) {
            DbgLog((LOG_TRACE,1,TEXT("*** GotDirectSoundInterface")));
            m_cDirectSoundRef++;
        } else {
            DbgLog((LOG_ERROR,1,TEXT("*** Sound device can't provide DirectSound interface")));
        }
        return hr;
    }
    return E_INVALIDARG;
#endif
}


// Give the IDirectSoundBuffer interface of the primary to anyone who wants it
//
HRESULT CWaveOutFilter::GetPrimaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb)
{
    return E_NOTIMPL;

#if 0
    // only for DSound
    if (!m_fDSound) {
        return E_NOTIMPL;
        // should probably create a new error message
    }

    // We have to be connected first to know our format
    if (!m_pInputPin->IsConnected())
        return E_UNEXPECTED;

// we can't open the wave device until pause - bad things happen
// Don't worry, the device will handle this
#if 0
    // They are asking for the direct sound interface before we've opened
    // DirectSound.  Better open it now.
    if (!m_bHaveWaveDevice) {
        CAutoLock lock(this);   // doing something real... better take critsect
    if (AcquireWaveDevice() != S_OK)
        return E_FAIL;
    }
#endif

    if (lplpdsb) {
        // See if the sound device we're using can give us the interface
        HRESULT hr = ((CDSoundDevice*)m_pSoundDevice)->amsndGetPrimaryBufferInterface(lplpdsb);
        if (SUCCEEDED(hr)) {
            DbgLog((LOG_TRACE,1,TEXT("*** Got PrimaryBufferInterface")));
            m_cPrimaryBufferRef++;
        } else {
            DbgLog((LOG_ERROR,1,TEXT("*** Sound device can't provide primary buffer interface")));
        }
        return hr;
    }
    return E_INVALIDARG;
#endif
}


// Give the IDirectSoundBuffer interface of the secondary to anyone who wants it
//
HRESULT CWaveOutFilter::GetSecondaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb)
{
    return E_NOTIMPL;

#if 0
    // only for DSound
    if (!m_fDSound) {
        return E_NOTIMPL;
        // should probably create a new error message
    }

    // We have to be connected first to know our format
    if (!m_pInputPin->IsConnected())
        return E_UNEXPECTED;

// we can't open the wave device until pause - bad things happen
// Don't worry, the device will handle this
#if 0
    // They are asking for the direct sound interface before we've opened
    // DirectSound.  Better open it now.
    if (!m_bHaveWaveDevice) {
        CAutoLock lock(this);   // doing something real... better take critsect
    if (AcquireWaveDevice() != S_OK)
        return E_FAIL;
    }
#endif

    if (lplpdsb) {
        // See if the sound device we're using can give us the interface
        HRESULT hr = ((CDSoundDevice*)m_pSoundDevice)->amsndGetSecondaryBufferInterface(lplpdsb);
        if (SUCCEEDED(hr)) {
            DbgLog((LOG_TRACE,1,TEXT("*** Got SecondaryBufferInterface")));
            m_cSecondaryBufferRef++;
        } else {
            DbgLog((LOG_ERROR,1,TEXT("*** Sound device can't provide secondary buffer interface")));
        }
        return hr;
    }
    return E_INVALIDARG;
#endif
}


// App wants to release the IDirectSound interface
//
HRESULT CWaveOutFilter::ReleaseDirectSoundInterface(LPDIRECTSOUND lpds)
{
    return E_NOTIMPL;

#if 0
    if (lpds) {
        if (m_cDirectSoundRef <= 0) {
            DbgLog((LOG_ERROR,1,TEXT("Releasing DirectSound too many times!")));
            return E_FAIL;
        } else {
            lpds->Release();
            m_cDirectSoundRef--;
            return NOERROR;
        }
    }
    return E_INVALIDARG;
#endif
}


// App wants to release the IDirectSoundBuffer interface of the primary
//
HRESULT CWaveOutFilter::ReleasePrimaryBufferInterface(LPDIRECTSOUNDBUFFER lpdsb)
{
    return E_NOTIMPL;

#if 0
    if (lpdsb) {
        if (m_cPrimaryBufferRef <= 0) {
                DbgLog((LOG_ERROR,1,TEXT("Releasing Primary Buffer too many times!")));
            return E_FAIL;
        } else {
            lpdsb->Release();
            m_cPrimaryBufferRef--;
            return NOERROR;
        }
    }
    return E_INVALIDARG;
#endif
}


// App wants to release the IDirectSoundBuffer interface of the secondary
//
HRESULT CWaveOutFilter::ReleaseSecondaryBufferInterface(LPDIRECTSOUNDBUFFER lpdsb)
{
    return E_NOTIMPL;

#if 0
    if (lpdsb) {
        if (m_cSecondaryBufferRef <= 0) {
                DbgLog((LOG_ERROR,1,TEXT("Releasing Secondary Buffer too many times!")));
            return E_FAIL;
        } else {
            lpdsb->Release();
            m_cSecondaryBufferRef--;
            return NOERROR;
        }
    }
    return E_INVALIDARG;
#endif
}

// App wants to set the focus window for the DSound based renderer
//
HRESULT CWaveOutFilter::SetFocusWindow (HWND hwnd, BOOL bMixingOnOrOff)
{
   CAutoLock lock(this);
   // handle the call only if DSound is the renderer we are using
   if (m_fDSound)
       return ((CDSoundDevice*)m_pSoundDevice)->amsndSetFocusWindow (hwnd, bMixingOnOrOff);
   else
       return E_FAIL ;
}

// App wants to get the focus window for the DSound based renderer
//
HRESULT CWaveOutFilter::GetFocusWindow (HWND * phwnd, BOOL * pbMixingOnOrOff)
{
   // handle the call only if dsound is the renderer we are using
   if (m_fDSound)
       return ((CDSoundDevice*)m_pSoundDevice)->amsndGetFocusWindow (phwnd, pbMixingOnOrOff);
   else
       return E_FAIL ;
}


/* Constructor */

#pragma warning(disable:4355)
CWaveOutFilter::CWaveOutFilter(
    LPUNKNOWN pUnk,
    HRESULT *phr,
    const AMOVIESETUP_FILTER* pSetupFilter,
    CSoundDevice *pDevice)
    : CBaseFilter(NAME("WaveOut Filter"), pUnk, (CCritSec *) this, *(pSetupFilter->clsID))
    , m_DS3D(this, phr)
    , m_DS3DB(this, phr)
    , m_fWant3D(FALSE)
    , m_BasicAudioControl(NAME("Audio properties"), GetOwner(), phr, this)
    , m_pImplPosition(NULL)
    , m_lBuffers(0)
    , m_hwo(NULL)
    , m_fVolumeSet(FALSE)
    , m_fHasVolume(FALSE)
    , m_dwAdviseCookie(0)
    , m_pResourceManager(NULL)
    , m_idResource(0)
    , m_bHaveWaveDevice(FALSE)
    , m_bActive(FALSE)
    , m_evPauseComplete(TRUE)    // Manual reset
    , m_eSentEOS(EOS_NOTSENT)
    , m_bHaveEOS(FALSE)
    , m_bSendEOSOK(false)
    , m_fFilterClock(WAVE_NOCLOCK)
    , m_pRefClock(NULL)     // we start off without a clock
    , m_llLastPos(0)
    , m_pSoundDevice (pDevice)
    , m_callback((CCritSec *) this)
    , m_dwEOSToken(0)
#ifdef THROTTLE
    , m_piqcSink(NULL)
    , m_nLastSent(0)
    , m_nMaxAudioQueue(0)
#endif
    , m_pSetupFilter(pSetupFilter)
    , m_dRate(1.0)
    , m_wavestate( WD_UNOWNED )
    , m_fDSound( FALSE )
#if 0
    , m_cDirectSoundRef( 0 )
    , m_cPrimaryBufferRef( 0 )
    , m_cSecondaryBufferRef( 0 )
#endif
    , m_dwScheduleCookie(0)
    , CPersistStream(pUnk, phr)
    , m_fUsingWaveHdr( FALSE )
    , m_dwLockCount( 0 )
    , m_pGraphStreams( NULL )
    , m_pAudioDuplexController( NULL )
    , m_pInputPin(NULL)
    , m_lastWaveError(MMSYSERR_NOERROR)
{
     if (!FAILED(*phr)) {
#ifdef PERF
        m_idStartRunning  = MSR_REGISTER("WaveOut device transition to run");
        m_idRestartWave   = MSR_REGISTER("Restart Wave device");
        m_idReleaseSample = MSR_REGISTER("Release wave sample");
#endif
        if (pDevice) {

            // Needs to be updated if we add a new MidiRenderer filter!
            if (IsEqualCLSID(*pSetupFilter->clsID, CLSID_AVIMIDIRender))
            {
                m_lHeaderSize = sizeof(MIDIHDR);
            }
            else
            {
                // Now that we've found one device which fails if WAVEHDR size
                // not explicitly set (as opposed to using a MIDIHDR size as we
                // were doing)
                m_lHeaderSize = sizeof(WAVEHDR);
            }

            if (IsEqualCLSID(*pSetupFilter->clsID, CLSID_DSoundRender))
            {
                /* Create the single input pin */
                m_fDSound = TRUE;
                CDSoundDevice* pDSoundDevice = static_cast<CDSoundDevice*>( pDevice );
                pDSoundDevice->m_pWaveOutFilter = this;
            }

            m_pInputPin = new CWaveOutInputPin(
                    this,           // Owning filter
                    phr);           // Result code

            ASSERT(m_pInputPin);
            if (!m_pInputPin)
                *phr = E_OUTOFMEMORY;
            else {
                // this should be delayed until we need it
                // except... we need to know how many bytes are outstanding
                // in the device queue
                m_pRefClock = new CWaveOutClock( this, GetOwner(), phr, new CAMSchedule(CreateEvent(NULL, FALSE, FALSE, NULL)) );
                // what should we do if we fail to create a clock


                // even on systems where symbols are haphazard
                // give ourselves a fighting chance of locating
                // the wave device variables
                m_debugflag = FLAG('hwo>');
                m_debugflag2 = FLAG('eos>');

            }
        } else {
            DbgLog((LOG_ERROR, 1, TEXT("No device instantiated when creating waveout filter")));
            *phr = E_OUTOFMEMORY;
        }
    }
}

#pragma warning(default:4355)

/* Destructor */

CWaveOutFilter::~CWaveOutFilter()
{
    ASSERT((m_hwo == NULL) == (m_dwLockCount == 0));

    if (m_dwLockCount != 0) {
        m_dwLockCount = 1;
        Reserve(AMRESCTL_RESERVEFLAGS_UNRESERVE, NULL);
    }
    ASSERT(m_hwo == NULL);
    ASSERT( m_pGraphStreams == NULL );

    if (m_pAudioDuplexController) 
    {
        m_pAudioDuplexController->Release();
    }

    /* Release our reference clock if we have one */

    SetSyncSource(NULL);
    // This would be done in the base class, but we should get
    // rid of it in case it is us.
    // I think we can assert that m_pClock (the base member) IS null

    if (m_pRefClock) {
        CAMSchedule *const pSched = m_pRefClock->GetSchedule();
        delete m_pRefClock;
        EXECUTE_ASSERT(
            CloseHandle(pSched->GetEvent())
        );
        delete pSched;
        m_pRefClock = NULL;
    }
    // The clock in the base filter class will be destroyed with the base class
    // It had better not be pointing to us...
    
    // CancelAllAdvises() must be called before m_pSoundDevice is deleted.  The 
    // Direct Sound Renderer can crash if the advises are canceled after
    // m_pSoundDevice is destroyed.  For more information, see bug 270592 
    // "The (MMSYSERR_NOERROR == amsndOutClose()) ASSERT fired in 
    // CWaveOutFilter::CloseWaveDevice()".  This bug is in the Windows Bugs
    // database.
    m_callback.CancelAllAdvises();

    /* Delete the contained interfaces */

    delete m_pInputPin;

    delete m_pImplPosition;

    delete m_pSoundDevice;

#ifdef THROTTLE
    if (m_piqcSink) {
        m_piqcSink->Release();
    }
#endif // THROTTLE
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP CWaveOutFilter::NonDelegatingQueryInterface(REFIID riid,
                            void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    if (IID_IReferenceClock == riid) {

        // !!! need to check here that we have a good wave device....
        // !!! unfortunately, they'll ask for a clock before we can
        // check our wave device!
        //...should not be necessary.  If we do not have a good wave device
        //we will revert to using system time.

        if (!m_pRefClock) {
            DbgLog((LOG_TRACE, 2, TEXT("Waveout: Creating reference clock...")));
            HRESULT hr = S_OK;
            m_pRefClock = new CWaveOutClock( this, GetOwner(), &hr, new CAMSchedule(CreateEvent(NULL, FALSE, FALSE, NULL)) );

            if (m_pRefClock == NULL) {
                return E_OUTOFMEMORY;
            }

            if (FAILED(hr)) {
                delete m_pRefClock;
                m_pRefClock = NULL;
                return hr;
            }
            // now... should we also SetSyncSource?
        }
        return m_pRefClock->NonDelegatingQueryInterface(riid, ppv);
    }

    else if (IID_IMediaPosition == riid || riid == IID_IMediaSeeking) {
    if (!m_pImplPosition) {
        HRESULT hr = S_OK;
        m_pImplPosition = new CARPosPassThru(
                    this,
                    &hr,
                    m_pInputPin);
        if (!m_pImplPosition || (FAILED(hr))) {
            if (m_pImplPosition) {
                delete m_pImplPosition;
                m_pImplPosition = NULL;
            } else {
                if (!(FAILED(hr))) {
                hr = E_OUTOFMEMORY;
                }
            }
            return hr;
        }
    }
    return m_pImplPosition->NonDelegatingQueryInterface(riid, ppv);

    } else if (IID_IBasicAudio == riid) {
        return m_BasicAudioControl.NonDelegatingQueryInterface(riid, ppv);

    } else if (IID_IQualityControl == riid) {
        return GetInterface((IQualityControl*)this, ppv);

    } else if (IID_IAMDirectSound == riid) {
        DbgLog((LOG_TRACE, 3, TEXT("*** QI CWaveOutDevice for IAMDirectSound")));
        return GetInterface((IAMDirectSound*)this, ppv);

    } else if (IID_IDirectSound3DListener == riid) {
        DbgLog((LOG_TRACE,3,TEXT("*** QI for IDirectSound3DListener")));
    m_fWant3D = TRUE;    // they asked for it!
        return GetInterface((IDirectSound3DListener *)&(this->m_DS3D), ppv);

    } else if (IID_IDirectSound3DBuffer == riid) {
        DbgLog((LOG_TRACE,3,TEXT("*** QI for IDirectSound3DBuffer")));
    m_fWant3D = TRUE;    // they asked for it!
        return GetInterface((IDirectSound3DBuffer *)&(this->m_DS3DB), ppv);

    } else if ((*m_pInputPin->m_mt.FormatType() == FORMAT_WaveFormatEx) &&
           (riid == IID_ISpecifyPropertyPages) ) {
    return GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv);

    } else  if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag *)this, ppv);

    } else  if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *)this, ppv);

    } else  if (riid == IID_IAMResourceControl) {
        return GetInterface((IAMResourceControl *)this, ppv);

    } else if (riid == IID_IAMAudioRendererStats) {
        return GetInterface((IAMAudioRendererStats *)this, ppv);

    } else if (riid == IID_IAMAudioDeviceConfig && m_fDSound) {
        return GetInterface((IAMAudioDeviceConfig *)(this), ppv);

    } else if (riid == IID_IAMClockSlave) {
        return GetInterface((IAMClockSlave *)(this), ppv);

    } else {
    
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

#ifdef COMMENTARY

How to run with external clocks:

All the discussion below assumes that WAVE_OTHERCLOCK is in effect.

Setup:

The wave device remembers how much data it has played (see NextHdr()).

It does this by storing m_stBufferStart - the stream time of a buffer
passed to the audio device - and remembering how much data has been
played.  From this the device can be queried for its position, and the
current stream time calculated.

We assume that the external clock is running at approximately the
same rate as wall clock time, which approximately matches the rate
of the audio device itself.  On this basis adjustments should be
fairly small.

When a buffer is received in Pause we simply add it to the device
queue.  At this point the device is static and we have no timing
information.  The longer this queue the more inexact any adjustment
will be.

When a buffer is received while running we have 3 possibilities
1.  write it to the device - it will be played contiguously
2.  drop it
3.  write silence

If the buffer is not a sync point (does not have valid time
stamps) we always take option 1.

Otherwise, to decide which option we take we:

A:  get the time from the current clock
B:  get the current wave position
C:  subtract from the "last" written position to get an estimate of
    how much data is left in the device queue, and thus the
    approximate time at which sound would stop playing

D:  calculate the overlap/underlap.  If it is not significant
    take option 1, ELSE

E:  IF there is a gap (the time for this buffer is later than the
    current end point) we write silence by pausing the device
F:  ELSE we drop this buffer

#endif

STDMETHODIMP CWaveOutFilter::SetSyncSource(IReferenceClock *pClock)
{
    // if there is really no change, ignore...

    DbgLog((LOG_TRACE, 3, "wo: SetSyncSource to clock %8x", pClock));

    if (pClock == m_pClock) {
        return S_OK;
    }

    // Previously we only allowed dynamic clock changes if we weren't the clock,
    // but this causes problems if a slaving and non-slaving renderer are in the
    // same graph, so only allow clock changes while we're stopped.
    if ( State_Stopped != m_State ) {
        return VFW_E_NOT_STOPPED;
    }
    //    
    // Remember that when we're using dsound AND slaving we need to explicitly set 
    // dsound to use software buffers, so if the clock is ever allowed to be changed 
    // dynamically the dsound buffer will need to be recreated if the clock change 
    // moves to/from slaving.
    //

    HRESULT hr;

    { // scope for autolock
        CAutoLock serialize(this);

        if (!pClock) {
            // no clock...
            m_fFilterClock = WAVE_NOCLOCK;
            if (m_dwScheduleCookie)
            {
                m_callback.Cancel( m_dwScheduleCookie );
                m_dwScheduleCookie = 0;
            }
        } else {

            m_fFilterClock = WAVE_OTHERCLOCK;     // assume not our clock
            if (m_pRefClock) {
                // we have a clock... is this now the filter clock?
                DbgLog((LOG_TRACE, 2, "wo: SetSyncSource to clock %8x (%8x)",
                        pClock, m_pRefClock));
                if (IsEqualObject(pClock, (IReferenceClock *)m_pRefClock)) 
                {
                    m_fFilterClock = WAVE_OURCLOCK;
                }
                else if (m_dwScheduleCookie)
                {
                    m_callback.Cancel( m_dwScheduleCookie );
                    m_dwScheduleCookie = 0;
                }

                //
                // Need to run even when not we're not the clock, in case the app 
                // wants to use our clock for slaving video to audio, independent of 
                // who is the graph clock (wmp8 slaves this way for network content?). 
                //
                EXECUTE_ASSERT(SUCCEEDED(
                    m_callback.ServiceClockSchedule( m_pRefClock,
                        m_pRefClock->GetSchedule(), &m_dwScheduleCookie )
                ));
            }
        }

        hr = CBaseFilter::SetSyncSource(pClock);

        // if we have an existing advise with the callback object we cannot
        // cancel it while holding the filter lock.  because if the callback
        // fires it will attempt to grab the filter lock in its processing.
        // setting a new clock will reset the advise time

    }    // end of autolock scope

    m_callback.SetSyncSource(pClock);
    return hr;
}

// you may acquire the resource specified.
// return values:
//  S_OK    -- I have successfully acquired it
//  S_FALSE -- I will acquire it and call NotifyAcquire afterwards
//  VFW_S_NOT_NEEDED: I no longer need the resource
//  FAILED(hr)-I tried to acquire it and failed.

STDMETHODIMP
CWaveOutFilter::AcquireResource(LONG idResource)
{
    HRESULT hr;
    CAutoLock lock(this);
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: AcquireResource")));

    // if stopped, or actually stopping now, then don't need it
    // or if we have cancelled our request we no longer want it
    if ((m_State == State_Stopped) ||
    (!m_bActive))
    {
        hr = VFW_S_RESOURCE_NOT_NEEDED;
    } else {

        if (m_bHaveWaveDevice) {
            // actually we have it thanks
            hr = S_OK;
        } else {
            ASSERT(!m_hwo);

            // it is possible that we lost the device, rejected a sample
            // and so will not get any more data until we restart.  BUT
            // before the last sample was freed we have been told that we
            // should get the device again.  So... we still have the actual
            // device open, but still need to restart the graph in order
            // to push data again.  This will be indicated if OpenWaveDevice
            // returns S_FALSE

            hr = OpenWaveDevice();

            if (S_OK == hr) {

            // the wave device is left in PAUSED state

            // need to restart pushing on this stream
            NotifyEvent(EC_NEED_RESTART, 0, 0);

            // if we have not yet rejected a sample we do not need
            // to restart the graph.  This is an optimisation that
            // we can add

            } else {
            DbgLog((LOG_ERROR, 1, "Error from OpenWaveDevice"));
            }
        }
    }

    return hr;
}

// Please release the resource.
// return values:
//  S_OK    -- I have released it (and want it again when available)
//  S_FALSE -- I will call NotifyRelease when I have released it
//  other   something went wrong.
STDMETHODIMP
CWaveOutFilter::ReleaseResource(LONG idResource)
{
    // force a release of the wave device
    CAutoLock lock(this);
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: ReleaseResource")));
    HRESULT hr;

    if ((idResource != m_idResource) ||
        (m_hwo == NULL)) {

        // that's not the one we've got - done with it
        // -- we may have validly just released it
        hr = S_OK;
#if 0
    } else if (m_cDirectSoundRef || m_cPrimaryBufferRef ||
                            m_cSecondaryBufferRef) {
        // This will never happen.  Resource manager is not used when
        // using the DSound renderer
        DbgBreak("*** THIS SHOULD NEVER HAPPEN ***");
        DbgLog((LOG_TRACE, 2, "Told to release wave device - but I can't!"));
        DbgLog((LOG_TRACE, 2, "Some app has a reference count on DSound"));
        // Sorry, we can't give up the wave device yet, some app has a reference
        // count on DirectSound
        hr = S_FALSE;
#endif
    } else if (m_dwLockCount == 0) {
        DbgLog((LOG_TRACE, 2, "Told to release wave device"));

        // block receives
        m_bHaveWaveDevice = FALSE;
        // no more wave data will be accepted

        // prevent anyone using the wave clock
        if (m_pRefClock) {
            m_pRefClock->AudioStopping();
        }

        // if there was a callback pending to restart the wave device
        // remove it now
        if (m_dwAdviseCookie) {
            m_callback.Cancel(m_dwAdviseCookie);
            m_dwAdviseCookie = 0;
        }

        //  This will send EC_COMPLETE if we have received EndOfStream
        //  Otherwise we may not be in running state
        //  Might as well make sure we get an EC_COMPLETE anyway
        //  provided we're running
        if (m_State != State_Running) {
            InterlockedIncrement(&m_lBuffers);
        }
        amsndOutReset();
        if (m_State != State_Running) {
            InterlockedDecrement(&m_lBuffers);
        }
        DbgLog((LOG_TRACE, 3, "Resetting the wave device in RELEASE RESOURCE, filter is %8x", this));

        if(m_pInputPin->m_pOurAllocator) {
            hr = m_pInputPin->m_pOurAllocator->ReleaseResource();
        } else {
            hr = S_OK;
        }
        if (S_OK == hr) {
            // release done - close device
            CloseWaveDevice();
        }
    } else {
        //  Locked
        ASSERT(m_hwo);
        hr = S_FALSE;
    }
    return hr;
}

// if our AcquireResource method is called when there are unlocked samples
// still outstanding, we will get S_FALSE from the allocator's OnAcquire.
// When all buffers are then freed, it will complete the acquire and then
// call back here for us to finish the AcquireResource job.
HRESULT
CWaveOutFilter::CompleteAcquire(HRESULT hr)
{
    CAutoLock lock(this);
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: CompleteAcquire")));

    ASSERT(!m_bHaveWaveDevice);

    // since we released the allocator critsec a moment ago, the state
    // may have been changed by a stop, in which case the device will have been
    // closed
    if (!m_hwo) {
        return S_FALSE;
    }

    if (S_OK == hr) {
        amsndOutPause();
        SetWaveDeviceState(WD_PAUSED);

        // now we can accept receives
        m_bHaveWaveDevice = TRUE;

        // need to restart pushing on this stream
        NotifyEvent(EC_NEED_RESTART, 0, 0);
    } else {
        if (FAILED(hr)) {
            ASSERT(!m_bHaveWaveDevice);
            CloseWaveDevice();
        }
    }

    if (m_pResourceManager) {
        m_pResourceManager->NotifyAcquire(
                    m_idResource,
                    (IResourceConsumer*) this,
                    hr);
    }
    return S_OK;
}

//
// override JoinFilterGraph method to allow us to get an IResourceManager
// interface
STDMETHODIMP
CWaveOutFilter::JoinFilterGraph(
    IFilterGraph* pGraph,
    LPCWSTR pName)
{
    CAutoLock lock(this);

    // if the sound device does its own resource management, do not try to
    // do our own. DSound based device will do its own.

    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);

    // cache the IAMGraphStreams interface on the way in
    if( SUCCEEDED( hr ) )
    {
        if( pGraph )
        {
            HRESULT hrInt = pGraph->QueryInterface( IID_IAMGraphStreams, (void **) &m_pGraphStreams );
            ASSERT( SUCCEEDED( hrInt ) ); // shouldn't ever fail
            if( SUCCEEDED( hrInt ) )
            {
                // don't hold a refcount or it will be circular. we will
                // be called JoinFilterGraph(NULL) before it goes away
                m_pGraphStreams->Release();
            }
        }
        else
        {
            m_pGraphStreams = NULL;
        }
    }

    if (m_pSoundDevice->amsndOutGetResourceName() == NULL)
        return hr ;

    if (SUCCEEDED(hr)) {
        if (pGraph) {
            HRESULT hr1 = pGraph->QueryInterface(
                        IID_IResourceManager,
                        (void**) &m_pResourceManager);
            if (SUCCEEDED(hr1)) {
                // don't hold a refcount or it will be circular. we will
                // be called JoinFilterGraph(NULL) before it goes away
                m_pResourceManager->Release();
            }
        } else {
            // leaving graph - interface not valid
            if (m_pResourceManager) {

                // we may not yet have cancelled the request - do it
                // now - but don't close the device since the
                // allocator is still using it.
                // it's safe to call this even if we have cancelled the
                // request.
                m_pResourceManager->CancelRequest(
                            m_idResource,
                            (IResourceConsumer*)this);
            }

            m_pResourceManager = NULL;
        }
    }
    return hr;
}

// called by CWaveAllocator when it has finished with the device
void
CWaveOutFilter::OnReleaseComplete(void)
{

    // remember whether to cancel or release
    BOOL bShouldRelease = FALSE;
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: OnReleaseComplete")));

    {
        CAutoLock lock(this);

        // if this was not a forced-release, this will not have been set yet
        m_bHaveWaveDevice = FALSE;

        // we can close the device now
        if (m_hwo) {
            CloseWaveDevice();
            bShouldRelease = TRUE;
        } else {
            // if we're cancelling without the wave device we can't be active
            ASSERT(!m_bActive);
        }

        // must release the filter critsec before calling the resource
        // manager as he could be calling us with the mutex and filter lock
        // in the reverse order. Releasing here is safe because:

        // 1. if we have the device and are releasing it voluntarily, then
        // m_bActive must be false and hence if he calls back at this
        // moment our ReleaseResource will see we don't have it.

        // 2. if we are releasing involuntarily, the resource manager
        // will not call us back until we call NotifyRelease.

        // 3. if we don't have the device and are calling cancel, then we are not
        // active and hence our AcquireResource will report that
        // we don't want the device.

        // 4. releasing or cancelling on a resource we don't have (because
        // an intervening callback got a "don't want" return) is safe.

    }

    // tell the resource manager we've released it
    if (m_pResourceManager) {
        if (bShouldRelease) {
            // do we want it back when it becomes available?
            // - only if m_bActive

            m_pResourceManager->NotifyRelease(
                        m_idResource,
                        (IResourceConsumer*)this,
                        m_bActive);
        } else {
            m_pResourceManager->CancelRequest(
                        m_idResource,
                        (IResourceConsumer*)this);
        }
    }
}

#ifdef DEBUG
BOOL IsPreferredRendererWave(void)
{
    // read the registry to override the default ??
    extern const TCHAR * pBaseKey;
    TCHAR szInfo[50];
    HKEY hk;
    BOOL fReturn = FALSE;
    DWORD lReturn;
    /* Construct the global base key name */
    wsprintf(szInfo,TEXT("%s\\%s"),pBaseKey,TEXT("AudioRenderer"));

    /* Create or open the key for this module */
    lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,   // Handle of an open key
                 szInfo,         // Address of subkey name
                 (DWORD) 0,      // Special options flags
                 KEY_READ,       // Desired security access
                 &hk);       // Opened handle buffer

    if (lReturn != ERROR_SUCCESS) {
        DbgLog((LOG_ERROR,1,TEXT("Could not access AudioRenderer key")));
        return FALSE;
    }

    DWORD dwType;
    BYTE  data[10];
    DWORD cbData = sizeof(data);
    lReturn = RegQueryValueEx(hk, TEXT("PreferWaveRenderer"), NULL, &dwType,
                data, &cbData);
    if (ERROR_SUCCESS == lReturn) {
        if (dwType == REG_DWORD) {
            fReturn = *(DWORD*)&data;
        } else if (dwType==REG_SZ) {
#ifdef UNICODE
            fReturn = atoiW((WCHAR*)data);
#else
            fReturn = atoi((char*)data);
#endif
        }
    }
    RegCloseKey(hk);
    return fReturn;
}

#endif

//
// GetPages
//

STDMETHODIMP CWaveOutFilter::GetPages(CAUUID * pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(2 * sizeof(GUID));
    if (pPages->pElems == NULL) {
    return E_OUTOFMEMORY;
    }
    pPages->pElems[0] = CLSID_AudioProperties;
    pPages->pElems[pPages->cElems++] = CLSID_AudioRendererAdvancedProperties;

    return NOERROR;

} // GetPages


// IAMAudioRendererStats
STDMETHODIMP CWaveOutFilter::GetStatParam( DWORD dwParam, DWORD *pdwParam1, DWORD *pdwParam2 )
{
    if( NULL == pdwParam1 )
        return E_POINTER;

    HRESULT hr = E_FAIL;
    *pdwParam1 = 0;

    switch( dwParam )
    {
        case AM_AUDREND_STAT_PARAM_SLAVE_MODE:
            *pdwParam1 = m_pInputPin->m_Slave.m_fdwSlaveMode;
            hr = S_OK;
            break;

        case AM_AUDREND_STAT_PARAM_SLAVE_RATE:
            if( m_pInputPin->m_Slave.m_fdwSlaveMode && m_fDSound )
            {
                // only valid when we're slaving via rate adjustment
                *pdwParam1 = m_pInputPin->m_Slave.m_dwCurrentRate ;
                hr = S_OK;
            }
            break;
        case AM_AUDREND_STAT_PARAM_JITTER:
#ifdef CALCULATE_AUDBUFF_JITTER
            if( m_pInputPin->m_Slave.m_fdwSlaveMode )
            {
                hr = GetStdDev( m_pInputPin->m_Slave.m_cBuffersReceived
                              , (int *) pdwParam1
                              , m_pInputPin->m_Slave.m_iSumSqAcc
                              , m_pInputPin->m_Slave.m_iTotAcc );
            }
#else
            hr = E_NOTIMPL;
#endif
            break;

        case AM_AUDREND_STAT_PARAM_SILENCE_DUR:
            if( m_fDSound )
            {
                hr = S_OK;
                if( 0 == m_pInputPin->m_nAvgBytesPerSec )
                    *pdwParam1 = 0;
                else
                    *pdwParam1 = (DWORD) ( (PDSOUNDDEV(m_pSoundDevice)->m_llSilencePlayed * 1000) / m_pInputPin->m_nAvgBytesPerSec);
            }

            break;

        case AM_AUDREND_STAT_PARAM_BREAK_COUNT:
            if( m_fDSound )
            {
                *pdwParam1 = (LONG) (PDSOUNDDEV(m_pSoundDevice)->m_NumAudBreaks);
                hr = S_OK;
            }
            break;

        case AM_AUDREND_STAT_PARAM_BUFFERFULLNESS:
            if( m_fDSound )
            {
                *pdwParam1 = (LONG) (PDSOUNDDEV(m_pSoundDevice)->m_lPercentFullness);
                hr = S_OK;
            }
            break;

        case AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR:
            *pdwParam1 = (DWORD) ( m_pInputPin->m_Stats.m_rtLastBufferDur / 10000 );
            hr = S_OK;
            break;

        case AM_AUDREND_STAT_PARAM_DISCONTINUITIES:
            *pdwParam1 = m_pInputPin->m_Stats.m_dwDiscontinuities;
            hr = S_OK;
            break;

        case AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR:
            if( NULL == pdwParam2 )
            {
                return E_INVALIDARG;
            }
            else if( m_pInputPin->m_Slave.m_fdwSlaveMode && !m_fDSound )
            {
                // only valid for waveOut
                // dropped sample or paused duration
                *pdwParam1 = (DWORD) (m_pInputPin->m_Slave.m_rtDroppedBufferDuration / 10000) ;
                *pdwParam2 = 0 ; // Silence writing not implemented currently
                hr = S_OK;
            }
            break;

        case AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR:
            if( NULL == pdwParam2 )
            {
                return E_INVALIDARG;
            }
            else if( m_pInputPin->m_Slave.m_fdwSlaveMode )
            {
                *pdwParam1 = (DWORD) (m_pInputPin->m_Slave.m_rtHighestErrorSeen / 10000) ;
                *pdwParam2 = (DWORD) (m_pInputPin->m_Slave.m_rtLowestErrorSeen / 10000) ;
                hr = S_OK;
            }
            break;

        case AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR:
            if( m_pInputPin->m_Slave.m_fdwSlaveMode )
            {
                *pdwParam1 = (DWORD) (m_pInputPin->m_Slave.m_rtErrorAccum / 10000) ;
                hr = S_OK;
            }
            break;

        case AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR:
            if( NULL == pdwParam2 )
            {
                return E_INVALIDARG;
            }
            else if( m_pInputPin->m_Slave.m_fdwSlaveMode )
            {
                *pdwParam1 = (DWORD) (m_pInputPin->m_Slave.m_rtLastHighErrorSeen / 10000) ;
                *pdwParam2 = (DWORD) (m_pInputPin->m_Slave.m_rtLastLowErrorSeen / 10000) ;
                hr = S_OK;
            }
            break;

        default:
            hr = E_INVALIDARG;
    }
    return hr;
}

// IAMClockSlave
STDMETHODIMP CWaveOutFilter::SetErrorTolerance( DWORD dwTolerance )
{
    ASSERT( m_pInputPin );
    if ( State_Stopped != m_State ) 
    {
        return VFW_E_NOT_STOPPED;
    }
    // allowed range is 1 to 1000ms
    if( 0 == dwTolerance || 1000 < dwTolerance )
    {
        DbgLog((LOG_TRACE, 2, TEXT("ERROR: CWaveOutFilter::SetErrorTolerance failed because app tried to set a value outside the 1 - 1000ms range!")));
        return E_FAIL;
    }    
    m_pInputPin->m_Slave.m_rtAdjustThreshold = dwTolerance * 10000;
    DbgLog((LOG_TRACE, 3, TEXT("*** New slaving tolerance set on audio renderer = %dms ***"),
            (LONG) (m_pInputPin->m_Slave.m_rtAdjustThreshold/10000) ) ) ;
    
    return S_OK;
}

STDMETHODIMP CWaveOutFilter::GetErrorTolerance( DWORD * pdwTolerance )
{
    ASSERT( m_pInputPin );
    if( NULL == pdwTolerance )
        return E_POINTER;

    *pdwTolerance = (DWORD) ( m_pInputPin->m_Slave.m_rtAdjustThreshold / 10000 );
    return S_OK;
}

#if 0

LPAMOVIESETUP_FILTER
CWaveOutFilter::GetSetupData()
{
#if 0
    if (g_amPlatform == VER_PLATFORM_WIN32_NT) {
    // On NT we make the wave renderer the preferred filter
    // if we are running on a system without Direct Sound
    if (g_osInfo.dwMajorVersion == 3
#ifdef DEBUG
        || IsPreferredRendererWave()
#endif
    ) {

        // change the default to have wave out preferred
        wavFilter.dwMerit = MERIT_PREFERRED;
        dsFilter.dwMerit  = MERIT_PREFERRED-1;

    }
    }
#endif
    return const_cast<LPAMOVIESETUP_FILTER>(m_pSetupFilter);
}

#endif


// this is the EOS function that m_callback will callback to.
// It is called back to deliver an EOS when we have no audio device.
// the param is the this pointer. It will deliver EOS
// to the input pin
void
CWaveOutFilter::EOSAdvise(DWORD_PTR dw)
{
    CWaveOutFilter* pThis = (CWaveOutFilter*)dw;
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: EOSAdvise")));

    // make it clear there is no longer an outstanding callback
    pThis->m_dwEOSToken = 0;

    // deliver EOS to the input pin
    pThis->m_pInputPin->EndOfStream();
}

// queue an EOS for when the end of the current segment should appear.
// If we have no audio device we will fail receive and so the upstream filter
// will never send us an EOS. We can't send EOS now or we will terminate early
// when we might be about to get the device, so we have a thread (inside
// the m_callback object) that will be created to wait for when the
// current segment should terminate, and then call our EndOfStream method.
//
HRESULT
CWaveOutFilter::QueueEOS()
{
    //CAutoLock lock(this);
    ASSERT(CritCheckIn(this));
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: QueueEOS")));

    REFERENCE_TIME tStop;

    // stop time in reference time is end of segment plus stream time offset
    // End of segment in stream time is (stop - start) using the stop and start
    // times passed to the pin's NewSegment method
    tStop = (m_pInputPin->m_tStop - m_pInputPin->m_tStart);

    if (m_dwEOSToken) {
        if (tStop == m_tEOSStop) {
            // we already have a callback for this time
            return S_OK;
        }
        CancelEOSCallback();
    }

    // if no base time yet, wait until run
    if (m_State != State_Running) {
        return S_FALSE;
    }

    m_tEOSStop = tStop;

    // calculate the end time
    tStop += m_tStart;

#ifdef DEBUG
    // in the debug build there are occasions when Advise will FAIL because
    // the segment time has not yet been set and we end up requesting an
    // advise in the past (because tStop+m_tStart will wrap).  This causes
    // an assert in callback.cpp.  We deliberately - IN THE DEBUG BUILD
    // ONLY - avoid that here.  If NewSegment is called we will reset
    // the advise.
    if (tStop < m_tStart) {
        // error...
        DbgLog((LOG_TRACE, 2, "EOSAdvise being fired now as calculated stop time is in the past"));
        EOSAdvise( (DWORD_PTR) this);
        return S_OK;
    }
#endif


    // we set the advise for tStop (stream time of end of segment) plus
    // the stream time offset - this should give us the absolute reference
    // time when the end of stream should happen.

    DbgLog((LOG_TRACE, 2, "Setting advise in QueueEOS"));
    HRESULT hr = m_callback.Advise(
        EOSAdvise,  // callback function
        (DWORD_PTR) this,   // user token passed to callback
        tStop,
        &m_dwEOSToken);

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("EOS Callback failed")));
        // we won't get a callback so do it now
        EOSAdvise( (DWORD_PTR) this);
    }
    return S_OK;
}



// cancel the EOS callback if there is one outstanding
HRESULT
CWaveOutFilter::CancelEOSCallback()
{
    ASSERT(CritCheckIn(this));
    HRESULT hr = S_FALSE;
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: CancelEOScallback")));

    if (m_dwEOSToken) {
        DbgLog((LOG_TRACE, 3, "Cancelling callback in CancelEOScallback"));
        m_callback.Cancel(m_dwEOSToken);
        m_dwEOSToken = 0;
        hr = S_OK;
    }
    return hr;
}


// --- Pin Methods --------------------------------------------------------


/* Constructor */
#pragma warning(disable:4355)
CWaveOutInputPin::CWaveOutInputPin(
    CWaveOutFilter *pFilter,
    HRESULT *phr)
    : CBaseInputPin(NAME("WaveOut Pin"), pFilter, pFilter, phr, L"Audio Input pin (rendered)")
    , m_pFilter(pFilter)
    , m_pOurAllocator(NULL)
    , m_fUsingOurAllocator(FALSE)
    , m_llLastStreamTime(0)
    , m_nAvgBytesPerSec(0)
    , m_evSilenceComplete(TRUE)  // manual reset
    , m_bSampleRejected(FALSE)
    , m_hEndOfStream(0)
    , m_pmtPrevious(0)
    , m_Slave( pFilter, this )
    , m_bPrerollDiscontinuity( FALSE )
    , m_bReadOnly( FALSE )
    , m_bTrimmedLateAudio( FALSE )
#ifdef DEBUG
    , m_fExpectNewSegment (TRUE)
#endif
{
    SetReconnectWhenActive( m_pFilter->m_pSoundDevice->amsndOutCanDynaReconnect() );
    m_Stats.Reset();

#ifdef PERF
    m_idReceive       = MSR_REGISTER("WaveOut receive");
    m_idAudioBreak    = MSR_REGISTER("WaveOut audio break");
    m_idDeviceStart   = MSR_REGISTER("WaveOut device start time");
    m_idWaveQueueLength = MSR_REGISTER("WaveOut device queue length");
#endif
}
#pragma warning(default:4355)

CWaveOutInputPin::~CWaveOutInputPin()
{
    /* Release our allocator if we made one */

    if (m_pOurAllocator) {
        // tell him we're going away
        m_pOurAllocator->ReleaseFilter();

        m_pOurAllocator->Release();
        m_pOurAllocator = NULL;
    }

    DestroyPreviousType();
}

HRESULT CWaveOutInputPin::NonDelegatingQueryInterface(
    REFIID riid, void **ppv)
{
    if( riid == IID_IPinConnection && CanReconnectWhenActive() )
    {
        return GetInterface((IPinConnection *)this, ppv);
    }
    else
    {
        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


//  Do you accept this type change in your current state?
STDMETHODIMP CWaveOutInputPin::DynamicQueryAccept(const AM_MEDIA_TYPE *pmt)
{
    // waveout filter can do dynamic format changes but not
    // seamlessly. ::QueryAccept will succeed
    return E_FAIL;
}

//  Set event when EndOfStream receive - do NOT pass it on
//  This condition is cancelled by a flush or Stop
STDMETHODIMP CWaveOutInputPin::NotifyEndOfStream(HANDLE hNotifyEvent)
{
    //  BUGBUG - what locking should we do?
    m_hEndOfStream = hNotifyEvent;
    return S_OK;
}

//  Disconnect without freeing your resources - prepares
//  to reconnect
STDMETHODIMP CWaveOutInputPin::DynamicDisconnect()
{
    HRESULT hr =S_OK;
    CAutoLock cObjectLock(m_pLock);

    // not a valid assertion... we just want m_mt to be valid
    // ASSERT(m_Connected);
    if(!m_pFilter->IsStopped() && m_Connected)
    {
        DestroyPreviousType();
        m_pmtPrevious = CreateMediaType(&m_mt);
        if(!m_pmtPrevious) {
            hr =  E_OUTOFMEMORY;
        }
    }
    if(SUCCEEDED(hr)) {
        hr = CBaseInputPin::DisconnectInternal();
    }
    return hr;
}

//  Are you an 'end pin'
STDMETHODIMP CWaveOutInputPin::IsEndPin()
{
    //  BUGBUG - what locking should we do?
    return E_NOTIMPL;
}

//
// Create a wave out allocator using the input format type
//
HRESULT CWaveOutInputPin::CreateAllocator(LPWAVEFORMATEX lpwfx)
{
    HRESULT hr = S_OK;

    m_pOurAllocator = new CWaveAllocator(
                NAME("WaveOut allocator"),
                lpwfx,
                m_pFilter->m_pRefClock,
                m_pFilter,
                &hr);

    if (FAILED(hr) || !m_pOurAllocator) {
        DbgLog((LOG_ERROR,1,TEXT("Failed to create new wave out allocator!")));
        if (m_pOurAllocator) {
            // we got the memory, but some higher class must
            // have signalled an error
            delete m_pOurAllocator;
            m_pOurAllocator = NULL;
        } else {
            hr = E_OUTOFMEMORY;
        }
    } else {
        // ensure the thing has an extra refcount
        m_pOurAllocator->AddRef();
    }
    return hr;
}

// return the allocator interface that this input pin
// would like the output pin to use
STDMETHODIMP
CWaveOutInputPin::GetAllocator(
    IMemAllocator ** ppAllocator)
{
    HRESULT hr = NOERROR;

    *ppAllocator = NULL;

    if (m_pAllocator) {
        // we've already got an allocator....
        /* Get a reference counted IID_IMemAllocator interface */
        return m_pAllocator->QueryInterface(IID_IMemAllocator,
                                            (void **)ppAllocator);
    } else {
        if (!m_pOurAllocator) {

            if(m_pFilter->m_fDSound)
            {            
                return CBaseInputPin::GetAllocator(ppAllocator);
            }
            // !!! Check if format set?
            ASSERT(m_mt.Format());

            m_nAvgBytesPerSec = m_pFilter->WaveFormat()->nAvgBytesPerSec;
            DbgLog((LOG_MEMORY,1,TEXT("Creating new WaveOutAllocator...")));
            hr = CreateAllocator((WAVEFORMATEX *) m_mt.Format());
            if (FAILED(hr)) {
                return(hr);
            }
        }

        /* Get a reference counted IID_IMemAllocator interface */
        return m_pOurAllocator->QueryInterface(IID_IMemAllocator,
                                               (void **)ppAllocator);
    }
}


STDMETHODIMP CWaveOutInputPin::NotifyAllocator(
    IMemAllocator *pAllocator,
    BOOL bReadOnly)
{
    HRESULT hr;         // General OLE return code

    // Make sure the renderer can change its'
    // allocator while the filter graph is running.
    ASSERT(CanReconnectWhenActive() || IsStopped());

    /* Make sure the base class gets a look */

    hr = CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly);
    if (FAILED(hr)) {
        return hr;
    }

    WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();

    /* See if the IUnknown pointers match */

    // remember if read-only, since pre-roll is only removed on read-writers buffers
    m_bReadOnly = bReadOnly;
    
    // !!! what if our allocator hasn't been created yet? !!!
    if(m_pFilter->m_fDSound)
    {
        // this is DSOUND, we should never use our own allocator;
        // however, it may have been previously created
        m_pFilter->m_fUsingWaveHdr  = FALSE;
        m_fUsingOurAllocator    = FALSE;
        if(m_pOurAllocator)
        {
            DbgLog((LOG_ERROR,1,TEXT("Waveout: NotifyAllocator: Releasing m_pOurAllocator for DSOUND")));

            m_pOurAllocator->Release();
            m_pOurAllocator = NULL;
        }
        return NOERROR;
    }
    if (!m_pOurAllocator) {
         ASSERT(pwfx);
         m_nAvgBytesPerSec = pwfx->nAvgBytesPerSec;
         hr = CreateAllocator(pwfx);
         if (FAILED(hr))
              return hr;
    }

    m_fUsingOurAllocator = ((IMemAllocator *)m_pOurAllocator == pAllocator);
    // m_fUsingWaveHdr == TRUE IFF someone has allocated a WaveHdr.  this is not true for the DSOUND renderer.
    m_pFilter->m_fUsingWaveHdr  = ! m_pFilter->m_fDSound || m_fUsingOurAllocator;

    DbgLog((LOG_TRACE,1,TEXT("Waveout: NotifyAllocator: UsingOurAllocator = %d"), m_fUsingOurAllocator));

    if (!m_fUsingOurAllocator) {

        // somebody else has provided an allocator, so we need to
        // make a few buffers of our own....
        // use the information from the other allocator

        ALLOCATOR_PROPERTIES Request,Actual;
        Request.cbBuffer = 4096;
        Request.cBuffers = 4;

        hr = pAllocator->GetProperties(&Request);
        // if this fails we carry on regardless...
        // we do not need a prefix when we copy to our code so
        // ignore that field, neither do we worry about alignment
        Request.cbAlign = 1;
        Request.cbPrefix = 0;

        //
        // Don't allocate too much (ie not > 10 seconds worth)
        //
        if ((pwfx->nAvgBytesPerSec > 0) &&
            ((DWORD)Request.cbBuffer * Request.cBuffers > pwfx->nAvgBytesPerSec * 10))
        {
            //  Do something sensible - 8 0.5 second buffers
            Request.cbBuffer = pwfx->nAvgBytesPerSec / 2;

            //  Round up a bit
            Request.cbBuffer = (Request.cbBuffer + 7) & ~7;
            if (pwfx->nBlockAlign > 1) {
                Request.cbBuffer += pwfx->nBlockAlign - 1;
                Request.cbBuffer -= Request.cbBuffer % pwfx->nBlockAlign;
            }
            Request.cBuffers = 8;
        }

        hr = m_pOurAllocator->SetProperties(&Request,&Actual);
        DbgLog((LOG_TRACE,1,
                TEXT("Allocated %d buffers of %d bytes from our allocator"),
                Actual.cBuffers, Actual.cbBuffer));
        if (FAILED(hr))
            return hr;
    }

    return NOERROR;
}


//
// Called when a buffer is received and we are already playing
// but the queue has expired.  We are given the start time
// of the sample.  We are only called for a sync point and only
// if we have a wave device.
//
HRESULT CWaveOutFilter::SetUpRestartWave(LONGLONG rtStart, LONGLONG rtEnd)
{
    // If there is still a significant portion of time
    // that should run before we start playing, get the
    // clock to call us back.  Otherwise restart the
    // wave device now.
    // we can only do this on our own clock

    REFERENCE_TIME now;
    if (m_pClock) {
        m_pClock->GetTime(&now);    // get the time from the filter clock
        rtStart -= now;     // difference from now
        
        DbgLog((LOG_TRACE, 5, TEXT("SetupRestartWave: rtStart is %dms from now"), (LONG) (rtStart/10000) ));
        
    }

    // Do we need to wait ?
    if (m_pClock && rtStart > (5* (UNITS/MILLISECONDS))) {

        // delay until we should start
        now += rtStart - (5 * (UNITS/MILLISECONDS));

        { // scope for lock
            ASSERT(CritCheckOut((CCritSec*)m_pRefClock));

            // have to ensure that AdviseCallback is atomic
            // or the callback could happen before
            // m_dwAdviseCookie is set

            // we can only do this if there is no current callback
            // pending.  For example if this is the first buffer
            // we may well have set up a RestartWave on ::Run, and
            // we do not want to override that callback.
            // BUT we cannot hold the device lock while we call
            // AdviseCallback.

            {
                ASSERT(CritCheckIn(this));
                if (m_dwAdviseCookie) {
                    // yes... let the first one fire
                    DbgLog((LOG_TRACE, 4, "advise in SetupRestartWave not needed - one already present"));
                    return S_OK;
                }
            }

            // Set up a new advise callback
            DbgLog((LOG_TRACE, 3, "Setting advise for %s in SetupRestartWave", CDisp(CRefTime(now))));
            HRESULT hr = m_callback.Advise(
                            RestartWave,    // callback function
                            (DWORD_PTR) this,   // user token passed to callback
                            now,
                            &m_dwAdviseCookie);
            ASSERT( SUCCEEDED( hr ) );
            {
                // Now check that the advise has been set up correctly
                ASSERT(CritCheckIn(this));
                if (m_dwAdviseCookie) {
                    // yes... we can pause the device
                    amsndOutPause();
                    SetWaveDeviceState(WD_PAUSED);
                }
            }
        }

    } else {
        DbgLog((LOG_TRACE, 5, "SetupRestartWave: starting immediately" ));
        RestartWave();
    }
    return(S_OK);
}

// *****
//
// Stuff we need out of dsprv.h
//
// *****

typedef enum
{
    DIRECTSOUNDDEVICE_TYPE_EMULATED,
    DIRECTSOUNDDEVICE_TYPE_VXD,
    DIRECTSOUNDDEVICE_TYPE_WDM
} DIRECTSOUNDDEVICE_TYPE;

typedef enum
{
    DIRECTSOUNDDEVICE_DATAFLOW_RENDER,
    DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE
} DIRECTSOUNDDEVICE_DATAFLOW;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
{
    GUID                        DeviceId;               // DirectSound device id
    CHAR                        DescriptionA[0x100];    // Device description (ANSI)
    WCHAR                       DescriptionW[0x100];    // Device description (Unicode)
    CHAR                        ModuleA[MAX_PATH];      // Device driver module (ANSI)
    WCHAR                       ModuleW[MAX_PATH];      // Device driver module (Unicode)
    DIRECTSOUNDDEVICE_TYPE      Type;                   // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;               // Device dataflow
    ULONG                       WaveDeviceId;           // Wave device id
    ULONG                       Devnode;                // Devnode (or DevInst)
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPSTR                       Description;    // Device description
    LPSTR                       Module;         // Device driver module
    LPSTR                       Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPWSTR                      Description;    // Device description
    LPWSTR                      Module;         // Device driver module
    LPWSTR                      Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#endif // DIRECTSOUND_VERSION >= 0x0700

// DirectSound Private Component GUID {11AB3EC0-25EC-11d1-A4D8-00C04FC28ACA}
DEFINE_GUID(CLSID_DirectSoundPrivate, 0x11ab3ec0, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

//
// DirectSound Device Properties {84624F82-25EC-11d1-A4D8-00C04FC28ACA}
//

DEFINE_GUID(DSPROPSETID_DirectSoundDevice, 0x84624f82, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE
} DSPROPERTY_DIRECTSOUNDDEVICE;

// *****

typedef HRESULT (WINAPI *GETCLASSOBJECTFUNC)( REFCLSID, REFIID, LPVOID * );

// we override this just for the dsound renderer case
HRESULT CWaveOutInputPin::CompleteConnect(IPin *pPin)
{
    if(m_pFilter->m_fDSound && !m_pmtPrevious)
    {
        // release the dsound object at this point, a non-dsound app
        // might be contending for the device. (only if we're not
        // doing a dynamic reconnect which is when m_pmtPrevious is
        // set.)
        CDSoundDevice *pDSDev = (CDSoundDevice *)m_pFilter->m_pSoundDevice;

        DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA    description;
        // Set all fields of description to 0 (makes DeviceId == GUID_NULL).
        memset( (void *) &description, 0, sizeof( description ) );

        // Get handle to DSOUND.DLL
        // ***** This should be painless as we know that we have DSOUND.DLL loaded because we just checked
        // ***** m_pFilter->m_fDSound.  However, the handle to DSOUND.DLL in the CDSoundDevice is protected
        // ***** from us, so we'll get our own.  Initial perf. testing verified this.
        HINSTANCE hDSound = LoadLibrary( TEXT( "DSOUND.DLL" ) );
        if (NULL != hDSound) {
            // Get DllGetClassObject address w/GetProcAddress
            GETCLASSOBJECTFUNC DllGetClassObject = (GETCLASSOBJECTFUNC) GetProcAddress( hDSound, "DllGetClassObject" );

            if (NULL != DllGetClassObject) {
                // Get class factory w/DllGetClassObject
                HRESULT hr = S_OK;
                IClassFactory * pClassFactory;
                if (S_OK == (hr = (*DllGetClassObject)( CLSID_DirectSoundPrivate, IID_IClassFactory, (void **) &pClassFactory ))) {
                    // Create a DirectSoundPrivate object with the class factory
                    IDSPropertySet * pPropertySet;
                    if (S_OK == (hr = pClassFactory->CreateInstance( NULL, IID_IKsPropertySet, (void **) &pPropertySet ))) {
                        // Get information
                        HRESULT hr = 0;
                        ULONG   bytes = 0;
                        ULONG   support = 0;
#ifdef DEBUG
                        hr = pPropertySet->QuerySupport( DSPROPSETID_DirectSoundDevice,
                                                         DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1,
                                                         &support );
                        DbgLog(( LOG_TRACE, 1, TEXT( "IKsPropertySet->QuerySupport() returned 0x%08X, support = %d" ), hr, support ));
#endif // DEBUG
                        hr = pPropertySet->Get( DSPROPSETID_DirectSoundDevice,
                                                DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1,
                                                 (PVOID) &description,
                                                 sizeof( description ),
                                                 (PVOID) &description,
                                                 sizeof( description ),
                                                &bytes );
                        DbgLog(( LOG_TRACE, 1, TEXT( "IKsPropertySet->Get( DESCRIPTION ) returned 0x%08X, type = %d" ), hr, description.Type ));

                        // Release DirectSoundPrivate object
                        pPropertySet->Release();
                        } // if (S_OK == (hr = pClassFactory->CreateInstance( ... )))
                    else
                        DbgLog(( LOG_ERROR, 1, TEXT( "DirectSoundPrivate ClassFactory->CreateInstance( IKsPropertySet ) failed (0x%08X)." ), hr ));

                    // Release class factory
                    pClassFactory->Release();
                    } // if (S_OK == (hr = (*DllGetClassObject)( ... )))
                else
                    DbgLog(( LOG_ERROR, 1, TEXT( "DllGetClassObject( DirectSoundPrivate ) failed (0x%08X)."), hr ));
                } // if (NULL != DllGetClassObject)
            else
                DbgLog(( LOG_ERROR, 1, TEXT( "GetProcAddress( DllGetClassObject ) failed (0x%08X)."), GetLastError() ));

            // Cleanup DLL
            FreeLibrary( hDSound );
            } // if (NULL != (hDSound = LoadLibrary( ... )))
        else
            DbgLog(( LOG_ERROR, 1, TEXT( "LoadLibrary( DSOUND.DLL ) failed (0x%08X)."), GetLastError() ));

        if (DIRECTSOUNDDEVICE_TYPE_WDM != description.Type)
            pDSDev->CleanUp();
    }

    return S_OK;
}

/* This is called when a connection or an attempted connection is terminated
   and allows us to reset the connection media type to be invalid so that
   we can always use that to determine whether we are connected or not. We
   leave the format block alone as it will be reallocated if we get another
   connection or alternatively be deleted if the filter is finally released */

HRESULT CWaveOutInputPin::BreakConnect()
{
    if (m_pFilter->m_State != State_Stopped) {
        return CBaseInputPin::BreakConnect();
    }

    // an app had a reference on the DSound interfaces when we stopped, so
    // we haven't actually closed the wave device yet!  Do it now.
    // I'm assuming the app will release its references before breaking the
    // connections of this graph.
    if (m_pFilter->m_bHaveWaveDevice) {
        ASSERT(m_pFilter->m_hwo);

#if 0
        if (m_pFilter->m_cDirectSoundRef || m_pFilter->m_cPrimaryBufferRef ||
                    m_pFilter->m_cSecondaryBufferRef) {
            DbgLog((LOG_ERROR,0,TEXT("***STUPID APP did not release DirectSound stuff!")));
            ASSERT(FALSE);
        }
#endif

        DbgLog((LOG_TRACE, 1, TEXT("Wave device being closed in BreakConnect")));
        m_pFilter->m_bHaveWaveDevice = FALSE;
        HRESULT hr = S_OK;
        if(m_pOurAllocator)
            hr = m_pOurAllocator->ReleaseResource();

        // !!! I'm assuming that the allocator will be decommitted already!
        ASSERT(hr == S_OK);
        if (S_OK == hr) {
            // release done - close device
            m_pFilter->CloseWaveDevice();
            // This will always be NULL when using DSound renderer
            if (m_pFilter->m_pResourceManager) {
                // ZoltanS fix 1-28-98:
                // DbgBreak("*** THIS SHOULD NEVER HAPPEN ***");
                DbgLog((LOG_ERROR, 1,
                        TEXT("Warning: BreakConnect before reservation release; this may be broken!")));
                // we've finished with the device now
                m_pFilter->m_pResourceManager->NotifyRelease(
                                                            m_pFilter->m_idResource,
                                                            (IResourceConsumer*)m_pFilter,
                                                            FALSE);
            }
        } else {
            DbgLog((LOG_ERROR, 1, TEXT("Can't close wave device! Oh no!")));
        }
    }

    // !!! Should we check that all buffers have been freed?
    // --- should be done in the Decommit ?

    /* Set the CLSIDs of the connected media type */

    m_mt.SetType(&GUID_NULL);
    m_mt.SetSubtype(&GUID_NULL);

    // no end of stream received or sent
    m_pFilter->m_eSentEOS = EOS_NOTSENT;

    return CBaseInputPin::BreakConnect();
}


/* Check that we can support a given proposed type */

HRESULT CWaveOutInputPin::CheckMediaType(const CMediaType *pmt)
{
    if (m_pmtPrevious) {
        return *pmt == *m_pmtPrevious ? S_OK : VFW_E_TYPE_NOT_ACCEPTED;
    }
    if ( m_pFilter->m_bActive &&
         m_pFilter->m_lBuffers != 0 &&
         pmt &&
         (pmt->majortype != MEDIATYPE_Audio) &&
         (pmt->formattype != FORMAT_WaveFormatEx) )
    {
        // only allow dynamic format changes for pcm right now
        DbgLog((LOG_TRACE,1,TEXT("*** CheckMediaType: dynamic change is only supported for pcm wave audio")));

        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    HRESULT hr = m_pFilter->m_pSoundDevice->amsndOutCheckFormat(pmt, m_dRate);

    if (FAILED(hr)) {
        return hr;
    }

    // we should now check whether we can set the volume or not
    WAVEOUTCAPS wc;
    memset(&wc,0,sizeof(wc));
    DWORD err = m_pFilter->amsndOutGetDevCaps(&wc, sizeof(wc));
    if (0 == err ) {
        //save volume capabilities
        m_pFilter->m_fHasVolume = wc.dwSupport & (WAVECAPS_VOLUME | WAVECAPS_LRVOLUME);
    }

    return NOERROR;
}



//
// Calculate how long this buffer should last (in 100NS units)
//
LONGLONG BufferDuration(DWORD nAvgBytesPerSec, LONG lData)
{
    if (nAvgBytesPerSec == 0) {
        // !!!!!!!!!! TEMP MIDI HACK, return 1 second.
        return UNITS; // !!!!!!!!!!!!!!!!!!!!!!!
    }

    return (((LONGLONG)lData * UNITS) / nAvgBytesPerSec);
}


/* Implements the remaining IMemInputPin virtual methods */

// Here's the next block of data from the stream
// We need to AddRef it if we hold onto it. This will then be
// released in the WaveOutCallback function.


#ifdef PERF
// Bracket code with calls to performance logger
HRESULT CWaveOutInputPin::Receive(IMediaSample * pSample)
{
    HRESULT hr;

    // if stop time is before start time, forget this
    REFERENCE_TIME tStart, tStop;
    BOOL bSync = S_OK == pSample->GetTime(&tStart, &tStop);
    if (bSync && tStop <= tStart) {
        if (tStop<tStart) {
            DbgLog((LOG_ERROR, 1, TEXT("waveoutReceive: tStop < tStart")));
        } else {
            DbgLog((LOG_TRACE, 1, TEXT("waveoutReceive: tStop == tStart")));
        }
        // tStop==tStart is OK... that can mean the position thumb is
        // being dragged around
        return S_OK;
    }

    // MSR_START(m_idReceive);

    if (m_pFilter->m_State == State_Running && m_pFilter->m_lBuffers <= 0) {
        MSR_NOTE(m_idAudioBreak);
        // at this point we should resync the audio and system clocks
    }

    hr = SampleReceive(pSample);
    // MSR_STOP(m_idReceive);
    return(hr);

}

HRESULT CWaveOutInputPin::SampleReceive(IMediaSample * pSample)
{
    HRESULT hr;
    // in non PERF builds we have access to tStart and tStop
    // without querying the times again
    REFERENCE_TIME tStart, tStop;
    BOOL bSync = S_OK == pSample->GetTime((REFERENCE_TIME*)&tStart,
                                          (REFERENCE_TIME*)&tStop);
    BOOL bStop;
#else     // !PERF built version
HRESULT CWaveOutInputPin::Receive(IMediaSample * pSample)
{
    HRESULT hr;
    BOOL bSync, bStop;

#endif

    // From media sample, need to get back our WAVEOUTHEADER
    BYTE *pData;        // Pointer to image data
    LONG lData;
    WAVEFORMATEX *pwfx;

    {
        // lock this with the filter-wide lock
        CAutoLock lock(m_pFilter);

        // bump up the thread priority for smoother audio (especially for mp3 content)
        DWORD dwPriority = GetThreadPriority( GetCurrentThread() );
        if( dwPriority < THREAD_PRIORITY_ABOVE_NORMAL ) {
            SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );
        }
        // we have received a data sample - complete Pause transition
        // do this within the lock so we know that the state cannot change
        // underneath us, and more importantly, that if a RUN command arrives
        // before we complete this Receive() that it will block.
        //
        // There is an argument that we should delay setting the Pause
        // complete event until just before the return from ::Receive().
        // That might make sense but leads to code bloat as we have
        // multiple return points. By grabbing the filter lock BEFORE setting
        // the event we at least serialise our activity.

        // If we have received a sample then we should not block
        // transitions to pause.  The order in which the commands get
        // distributed to filters in the graph is important here as we (a
        // renderer) get told to ::Pause before the source.  Until the
        // source sends us data we will not complete the Pause transition

        if (m_pFilter->m_State == State_Paused) {
            m_pFilter->m_evPauseComplete.Set();
            DbgLog((LOG_TRACE, 3, "Completing transition into Pause from Receive"));
        }

        if (m_pFilter->m_eSentEOS) {
            return VFW_E_SAMPLE_REJECTED_EOS;
        }


        // check all is well with the base class - do this before
        // checking for a wave device as we don't want to schedule an
        // EC_COMPLETE
        hr = CBaseInputPin::Receive(pSample);


        // S_FALSE means we are not accepting samples. Errors also mean
        // we reject this
        if (hr != S_OK)
            return hr;

        //  Handle dynamic format changes sometimes - actually we could
        //  do it always if we just waited for the pipe to empty and
        //  did the change then
        //  Note that the base class has already verified the type change
        //  m_lBuffers really is the number of buffers outstanding here
        //  because we won't get here if we've already had EndOfStream

        if ( (SampleProps()->dwSampleFlags & AM_SAMPLE_TYPECHANGED) )
        {
            ASSERT(SampleProps()->pMediaType->pbFormat != NULL);
            DbgLog((LOG_TRACE, 4, TEXT("Receive: Dynamic format change. First verifying that format is different...")));
            CMediaType *pmtSample = (CMediaType *)SampleProps()->pMediaType;

            WAVEFORMATEX *pwfxInput = m_pFilter->WaveFormat();
            if(pmtSample->cbFormat !=
                    sizeof(WAVEFORMATEX) + pwfxInput->cbSize ||
                0 != memcmp(pmtSample->pbFormat, pwfxInput, pmtSample->cbFormat))
            {
                DbgLog((LOG_TRACE, 1, TEXT("Receive: Dynamic format change")));

                hr = m_pFilter->ReOpenWaveDevice(pmtSample);
                if(hr != S_OK)
                    return hr;

            }
        }
        
        bSync = 0 != (SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID);
        bStop = 0 != (SampleProps()->dwSampleFlags & AM_SAMPLE_STOPVALID);

        if( bSync && bStop )
        {    
            // check if there's any preroll to remove
            hr = RemovePreroll( pSample );     
            if ( m_bTrimmedLateAudio )
            {
                //
                // If we trimmed, mark the next sample we deliver (which may be this one
                // if we haven't dropped it all) as a discontinuity. This is required for 
                // the m_rtLastSampleEnd time in the dsound renderer to be correctly updated.
                //
                m_bPrerollDiscontinuity = TRUE;
            }
                            
            if( S_FALSE == hr )
            {
                // drop whole buffer, but check if we need to remember a discontinuity
                // (alternatively we could set this one to 0-length and continue?)
                if (S_OK == pSample->IsDiscontinuity())
                {
                    m_bPrerollDiscontinuity = TRUE;
                }                
                return S_OK;
            }
            else if( FAILED( hr ) )
            {
                return hr;
            }    
        }

        pData = SampleProps()->pbBuffer;
        lData = SampleProps()->lActual;

#ifdef DEBUG
        if (!bSync) {
            DbgLog((LOG_TRACE, 2, TEXT("Sample length %d with no timestamp"),
                    lData));
        }
#endif

#ifndef PERF
        REFERENCE_TIME tStart = SampleProps()->tStart;
        REFERENCE_TIME tStop = SampleProps()->tStop;
#else
        tStart = SampleProps()->tStart;
#endif
        // save local state of this before we update member var
        BOOL bPrerollDiscontinuity = m_bPrerollDiscontinuity; 
        
        // update m_Stats - discontinuities and last buffer duration
        if (S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity )
        {
            m_Stats.m_dwDiscontinuities++;
            m_bPrerollDiscontinuity = FALSE; // in case we get a real discontinuity after a drop
        }
        
        m_Stats.m_rtLastBufferDur = BufferDuration(m_nAvgBytesPerSec, lData);


#ifdef DEBUG
        if (bSync) 
        {
            if (m_pFilter->m_State == State_Running) 
            {
                CRefTime rt;
                HRESULT hr = m_pFilter->StreamTime(rt);
                if( bStop )
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Sample start time %dms, stop time %dms, Stream time %dms, discontinuity %d"), 
                            (LONG)(tStart / 10000),
                            (LONG)(tStop / 10000),
                            (LONG)(rt / 10000),
                            S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity));
                }
                else
                {                
                    DbgLog((LOG_TRACE, 3, TEXT("Sample time %dms, Stream time %dms, discontinuity %d"), (LONG)(tStart / 10000),
                            (LONG)(tStart / 10000),
                            (LONG)(rt / 10000),
                            S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity));
                }
            } 
            else 
            {
                if( bStop )
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Sample start time %dms, stop time %dms, discontinuity %d"), 
                            (LONG)(tStart / 10000),
                            (LONG)(tStop / 10000),
                            S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity));
                }
                else
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Sample time %dms, discontinuity %d"), (LONG)(tStart / 10000),
                            (LONG)(tStart / 10000),
                            S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity));
                }                
            }
        } 
        else 
        {
            if (S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity) 
            {
                DbgLog((LOG_TRACE, 3, TEXT("Sample with discontinuity and no timestamp")));
            }
        }
#endif
        ASSERT(pData != NULL);

        // have we got a wave device available?
        if (!m_pFilter->m_bHaveWaveDevice) {
            // no wave device, so we can't do much....
            m_pFilter->QueueEOS();

            // note: from this point on there is a small timing hole.
            // If we set m_bHaveWaveDevice==FALSE due to a ReleaseResource
            // call, but not have yet really closed the device because there
            // were outstanding buffers (probably the one we are just about
            // to reject) then we could be told to re-Acquire the device
            // before the buffer is released and before we really close
            // the device.  Yet there will be no EC_NEEDRESTART and nothing
            // to kick the source into sending us more data.
            // The hole is closed when the buffer is released.


            m_bSampleRejected = TRUE;
            return S_FALSE; // !!! after this we get no more data
        }

        ASSERT(m_pFilter->m_hwo);

        if (m_pFilter->m_lBuffers == 0)
        {
            if (bSync)
            {
                m_rtActualSegmentStartTime = tStart;
            }
            else if ( m_pFilter->m_fFilterClock == WAVE_OTHERCLOCK && ( pSample->IsDiscontinuity() != S_OK && !bPrerollDiscontinuity ))
            {
                m_rtActualSegmentStartTime = m_llLastStreamTime;
            }
            else m_rtActualSegmentStartTime = 0;
        }

        if ( m_pFilter->m_fFilterClock == WAVE_OTHERCLOCK ) {
            pwfx = m_pFilter->WaveFormat();
            ASSERT(pwfx);
            if (bSync) {
#ifdef DEBUG
                LONGLONG diff = m_llLastStreamTime + m_Stats.m_rtLastBufferDur - SampleProps()->tStop;
                if (diff < 0) {
                    diff = -diff;
                }
                if (diff > (2* (UNITS/MILLISECONDS))) {
                    DbgLog((LOG_TRACE, 3, "buffer end (bytes) and time stamp not in accord"));
                }
#endif
                m_llLastStreamTime = tStart + m_Stats.m_rtLastBufferDur;
            }
            else {
                m_llLastStreamTime += m_Stats.m_rtLastBufferDur;
                DbgLog((LOG_TRACE, 4, ".....non sync buffer, length %d", lData));
            }
        }

        BOOL bUnmarkedGapWhileSlaving = FALSE;
        if ( m_pFilter->m_State == State_Running &&
             m_pFilter->m_fFilterClock != WAVE_NOCLOCK &&
             !m_bTrimmedLateAudio ) // don't adjust if we've just dropped late audio (could lead to invalid err between clocks)
        {
            if( m_Slave.UpdateSlaveMode( bSync ) && 
                // for non-live slaving don't adjust if device isn't yet running!
                ( m_pFilter->m_wavestate == WD_RUNNING || m_Slave.m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA ) )
            {
                if( m_pFilter->m_fDSound && 
                    ( 0 == ( m_Slave.m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA ) ) &&
                    !( S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity ) )
                {                
                    // for non-live graphs if this isn't already a discontinuity check to see if it's an unmarked one
                    if( ( tStart > ( ( CDSoundDevice * ) m_pFilter->m_pSoundDevice )->m_rtLastSampleEnd ) &&
                        ( tStart - ( ( CDSoundDevice * ) m_pFilter->m_pSoundDevice )->m_rtLastSampleEnd  
                            > 30 * ( UNITS / MILLISECONDS ) ) )
                    {
                        DbgLog((LOG_TRACE,7, TEXT("Slaving DSound renderer detected unmarked discontinuity!") ) );
                        bUnmarkedGapWhileSlaving = TRUE;
                    }
                }   

                // yes, we are slaving so determine whether we need to make an adjustment
                hr = m_Slave.AdjustSlaveClock( ( REFERENCE_TIME ) tStart
                                             , &lData
                                             , S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity 
                                               || bUnmarkedGapWhileSlaving );
                if (S_FALSE == hr)
                {
                    // dropping buffer
                    return S_OK;
                }
                else if( FAILED( hr ) )
                    return hr;
            }
        } // state_running

        if( m_fUsingOurAllocator || m_pFilter->m_fDSound ) {

            // addref pointer since we will keep it until the wave callback
            // - MUST do this before the callback releases it!
            pSample->AddRef();

            WAVEHDR *pwh;
            WAVEHDR wh;
            if(!m_pFilter->m_fUsingWaveHdr)
            {
                // we're not relying on a persistent waveHdr, nor has our sample allocated one, so we can simply cache it on the stack
                pwh = &wh;
                pwh->lpData = (LPSTR)pData;       // cache our buffer
                pwh->dwUser = (DWORD_PTR)pSample; // cache our CSample*
            }
            else
            {
                pwh = (LPWAVEHDR)(pData - m_pFilter->m_lHeaderSize);  // the waveHdr was part of the sample, legacy case
            }
            // need to adjust to actual bytes written
            pwh->dwBufferLength = lData;

            // note that we have added another buffer
            InterlockedIncrement(&m_pFilter->m_lBuffers);

// #ifdef PERF
#ifdef THROTTLE
            // there is a small timing hole here in that the callback
            // could decrement the count before we read it.  However
            // the trace should allow this anomaly to be identified.
            LONG buffercount = m_pFilter->m_lBuffers;
            // remember the maximum queue length reached.
            if (buffercount > m_pFilter->m_nMaxAudioQueue) {
                m_pFilter->m_nMaxAudioQueue = buffercount;
                DbgLog((LOG_TRACE, 0, TEXT("Max Audio queue = %d"), buffercount));
            }
#endif // THROTTLE
// #endif

            DbgLog((LOG_TRACE,5,
                    TEXT("SoundDeviceWrite: sample %X, %d bytes"),
                    pSample, pwh->dwBufferLength));

            // Compensate for Windows NT wave mapper bug (or should we
            // just use the ACM wrapper?).
            if(m_pFilter->m_fUsingWaveHdr)
                FixUpWaveHeader(pwh);

            UINT err = m_pFilter->amsndOutWrite(
                pwh,
                m_pFilter->m_lHeaderSize,
                (0 == (~SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID))? &tStart : NULL,
                0 == (~SampleProps()->dwSampleFlags & AM_SAMPLE_DATADISCONTINUITY) || bPrerollDiscontinuity
                || bUnmarkedGapWhileSlaving );
                
            //                
            // Don't unset this until after amsndOutWrite, to avoid incorrectly 
            // inserting silence due to dropping late audio (when slaving).
            // Used in dsound path only.
            //
            if( pwh->dwBufferLength > 0 )
            {            
                m_bTrimmedLateAudio = FALSE; 
            }                

            if (err > 0) {
                // device error: PCMCIA card removed?
                DbgLog((LOG_ERROR,1,TEXT("Error from amsndOutWrite: %d"), err));

                // release it here since the callback will never happen
                // and reduce the buffer count
                InterlockedDecrement(&m_pFilter->m_lBuffers);

                //  We now own the responsibility of scheduling end of
                //  stream because we're going to fail Receive
                if (MMSYSERR_NODRIVER == err)
                    m_pFilter->ScheduleComplete(TRUE);  // send EC_ERRORABORT also if dev was removed
                else
                    m_pFilter->ScheduleComplete();

                pSample->Release();

                // we do not bother with bytes in queue.  By returning an
                // error we are not going to receive any more data
                return E_FAIL;
            } else {
                CheckPaused();
            }

#ifdef THROTTLE

            m_pFilter->SendForHelp(buffercount);

            MSR_INTEGER(m_idWaveQueueLength, buffercount);
#endif // THROTTLE

            if (m_pFilter->m_pRefClock) {
                m_pFilter->m_llLastPos = m_pFilter->m_pRefClock->NextHdr(pData,
                                (DWORD)lData,
                                bSync,
                                pSample);
            }
            return NOERROR;
        }

        // NOT using our allocator

        if (m_pFilter->m_pRefClock) {
            m_pFilter->m_llLastPos = m_pFilter->m_pRefClock->NextHdr(pData,
                            (DWORD)lData,
                            bSync,
                            pSample);
        }
    }   // scope for autolock


    // When here we are not using our own allocator and
    // therefore need to copy the data

    // We have released the filter-wide lock so that GetBuffer will not
    // cause a deadlock when we go from Paused->Running or Paused->Playing

    IMediaSample * pBuffer;

    while( lData > 0 && hr == S_OK ){
        // note: this blocks!
        hr = m_pOurAllocator->GetBuffer(&pBuffer,NULL,NULL,0);

        { // scope for Autolock
            CAutoLock Lock( m_pFilter );

            if (FAILED(hr)) {
                m_pFilter->ScheduleComplete();
                break;  // return hr
            }

            // hold filter-wide critsec across CopyToOurSample
            // (more efficient than inside Copy method as there are multiple
            // return paths
            // this will addref sample if needed
            hr = CopyToOurSample(pBuffer, pData, lData);
        }

        // Copy will have addrefed sample if needed. We can release our
        // refcount *outside the critsec*
        pBuffer->Release();
    }

    /* Return the status code */
    return hr;
} // Receive

// use a preroll time between -10 and 0ms as the cutoff limit
#define PREROLL_CUTOFF_REFTIME ( -10 * ( UNITS/MILLISECONDS ) )

// don't attempt to trim tiny amounts
#define MINIMUM_TRIM_AMOUNT_REFTIME ( 5 * ( UNITS/MILLISECONDS ) )

// drop late audio when slaving if its really late
#define LATE_AUDIO_PAD_REFTIME ( 80 * ( UNITS/MILLISECONDS ) )

HRESULT CWaveOutInputPin::RemovePreroll( IMediaSample * pSample )
{
    if( m_mt.majortype != MEDIATYPE_Audio)
    {
        // no need to do this for MIDI at this point...
        return S_OK;
    }
    
    ASSERT( SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID  &&
            SampleProps()->dwSampleFlags & AM_SAMPLE_STOPVALID );
    
    REFERENCE_TIME tStart = SampleProps()->tStart;
    REFERENCE_TIME tStop = SampleProps()->tStop;
    
    REFERENCE_TIME rtCutoff = PREROLL_CUTOFF_REFTIME;
    
    if( tStart >= PREROLL_CUTOFF_REFTIME )
    {
        //
        // no preroll to trim
        //
        // next check if we're slaving and this is really late audio
        //
        // *** Note ***
        // We'll only do this for non-live graphs, since filters like the waveIn audio capture
        // filter use a default 1/2 second buffer and so in effect deliver everything late.
        // 
        //
        if ( m_pFilter->m_State == State_Running && 
             m_Slave.UpdateSlaveMode( TRUE ) &&
             ( 0 == ( m_Slave.m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA ) ) )
        {
            // yes, we are slaving and running, so drop any really late audio
            HRESULT hrTmp = m_pFilter->m_pClock->GetTime(&rtCutoff);
            ASSERT( SUCCEEDED( hrTmp ) );
            //
            // add in tolerance factor
            //
            rtCutoff -= ( m_pFilter->m_tStart + LATE_AUDIO_PAD_REFTIME );
            if( tStart >= rtCutoff )
            {
                // not late, drop nothing
                return S_OK;
            }
            else if( tStop < rtCutoff )
            {
                // completely late, drop it all 
                m_bTrimmedLateAudio = TRUE;
                
                DbgLog((LOG_TRACE, 3, TEXT("CWaveOutInputPin::RemovePreroll: Dropping Late Audio! (Sample start time %dms, sample stop time %dms)"), 
                        (LONG)(tStart / 10000),
                        (LONG)(tStop / 10000) ));
                return S_FALSE;
            }
            else 
            {                    
                // partially late, we may have to drop something...
                DbgLog((LOG_TRACE, 3, TEXT("CWaveOutInputPin::RemovePreroll: Considering trimming Late Audio! (Sample start time %dms, sample stop time %dms)"), 
                        (LONG)(tStart / 10000),
                        (LONG)(tStop / 10000) ));
            }
        }
        else
        {        
            // we're not slaving and there's no preroll to trim
            DbgLog((LOG_TRACE, 15, TEXT("CWaveOutInputPin::RemovePreroll: not preroll data") ));
            return S_OK;
        }            
    }        
    else if( tStop < PREROLL_CUTOFF_REFTIME )
    {
        m_bTrimmedLateAudio = TRUE; 
        
        // drop it all 
        DbgLog((LOG_TRACE, 3, TEXT("CWaveOutInputPin::RemovePreroll: Dropping Early Sample (Sample start time %dms, sample stop time %dms)"), 
                (LONG)(tStart / 10000),
                (LONG)(tStop / 10000) ));
        return S_FALSE;
    }   
                
    // we need to trim off something...
    
    DbgLog((LOG_TRACE, 3, TEXT("CWaveOutInputPin::RemovePreroll: Sample start time %dms, sample stop time %dms"), 
            (LONG)(tStart / 10000),
            (LONG)(tStop / 10000) ));
    
    if( m_bReadOnly )
    {
        // we won't do this for read-only buffers
        DbgLog((LOG_TRACE, 3, TEXT("CWaveOutInputPin::RemovePreroll: Uh-oh, it's a read-only buffer. Don't trim preroll!") ));
        return S_OK;
    }            
        
    //    
    // the assumption is, as long as we only operate on block aligned boundaries 
    // and remove data up front, we should be able trim any audio data we receive
    //
    ASSERT( rtCutoff > tStart );
    REFERENCE_TIME rtTrimAmount = rtCutoff - tStart;
    
#ifdef DEBUG    
    LONG lData = 0;
    
    // log original buffer length before removing pre-roll
    lData = pSample->GetActualDataLength();
    DbgLog((LOG_TRACE, 5, TEXT("CWaveOutInputPin::RemovePreroll: Original Preroll buffer length is %d"), lData ));
#endif    
    HRESULT hr = S_OK;
    
    // make sure it's worth trimming first    
    if( rtTrimAmount > MINIMUM_TRIM_AMOUNT_REFTIME )
    {
        hr = TrimBuffer( pSample, rtTrimAmount, rtCutoff, TRUE ); // trim from front

#ifdef DEBUG    
        if( SUCCEEDED( hr ) )
        {
            //
            // log updated buffer length
            // remember, we skip read-only buffers at this time
            //
            lData = pSample->GetActualDataLength();
            DbgLog((LOG_TRACE, 5, TEXT("CWaveOutInputPin:RemovePreroll: new buffer length is %d"), lData ));
        }        
#endif    
    }
#ifdef DEBUG
    else
    {
        DbgLog((LOG_TRACE, 5, TEXT("CWaveOutInputPin:RemovePreroll: Nevermind, not worth trimming...")));
    }
#endif        
    return hr;
}

//
// TrimBuffer - generic function to trim from front or back of audio buffer
//
HRESULT CWaveOutInputPin::TrimBuffer( IMediaSample * pSample, REFERENCE_TIME rtTrimAmount, REFERENCE_TIME rtCutoff, BOOL bTrimFromFront )
{
    ASSERT( bTrimFromFront ); // only support front end trimming right now
    ASSERT( !m_bReadOnly );
    
    DbgLog( (LOG_TRACE
          , 3
          , TEXT( "TrimBuffer preparing to trim %dms off %hs of buffer" )
          , (LONG) ( rtTrimAmount / 10000 ), bTrimFromFront ? "front" : "back" ) );
    
    // convert to bytes
    LONG lTruncBytes = (LONG) ( ( ( rtTrimAmount/10000) * m_nAvgBytesPerSec ) /1000 ) ; 

    WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();

    //  round up to block align boundary
    LONG lRoundedUpTruncBytes = lTruncBytes;
    if (pwfx->nBlockAlign > 1) {
        lRoundedUpTruncBytes += pwfx->nBlockAlign - 1;
        lRoundedUpTruncBytes -= lRoundedUpTruncBytes % pwfx->nBlockAlign;
    }
        
    BYTE * pData = NULL;
    LONG cbBuffer = 0;
    
    HRESULT hr = pSample->GetPointer( &pData );
    ASSERT( SUCCEEDED( hr ) );
    
    cbBuffer = pSample->GetActualDataLength( );
    ASSERT( SUCCEEDED( hr ) );
    
    if( lRoundedUpTruncBytes >= cbBuffer )
    {
        // can't trim anything
        // so let's try rounding down then
        if( ( lRoundedUpTruncBytes -= pwfx->nBlockAlign ) <= 0 )
        {
            DbgLog( (LOG_TRACE, 3, TEXT( "TrimBuffer can't trim anything" ) ));
            return S_OK;
        }
        else if( lRoundedUpTruncBytes > cbBuffer )
        {
            //
            // If we wound up here then the possiblities are:
            //
            // a. We were passed a sample with bad timestamps (marked valid)
            //    Something external's broken, so just leave the buffer as is.
            // b. the buffer size is smaller than the absolute value of the preroll size
            //    Since we can't tell the difference between a. and b. (here) handle same as a.
            //
            return S_OK;
        }        
        else
        {
            DbgLog( (LOG_TRACE, 3, TEXT( "TrimBuffer rounding down instead to trim..." ) ));
        }        
    }
    
    //
    // so it still makes sense to trim rather than just drop 
    // TODO: might want to ensure we don't trim if amount is 
    //  a) too small or 
    //  b) too close to actual buffer size
    //
#ifdef DEBUG                        
    LONG lOriginalLength = cbBuffer;
#endif          
    // calculate new buffer size          
    cbBuffer -= lRoundedUpTruncBytes ;
    DbgLog( (LOG_TRACE
          , 3
          , TEXT( "***Truncating %ld bytes of %ld byte buffer (%ld left)" )
          , lRoundedUpTruncBytes
          , lOriginalLength
          , cbBuffer ) );
    
    ASSERT( cbBuffer > 0 );
        
    // shift out the preroll data    
    MoveMemory( pData, pData + lRoundedUpTruncBytes, cbBuffer );
    
    // need to adjust to actual bytes written
    hr = pSample->SetActualDataLength( cbBuffer );
    ASSERT( SUCCEEDED( hr ) );
    
    // update time stamp
    REFERENCE_TIME tStart = rtCutoff;
    REFERENCE_TIME tStop  = SampleProps()->tStop;

    hr = pSample->SetTime(
        (REFERENCE_TIME*)&tStart, 
        (REFERENCE_TIME*)&tStop);
    ASSERT( SUCCEEDED( hr ) );        
        
    // update SampleProps separately        
    SampleProps()->tStart    = rtCutoff;
    SampleProps()->lActual   = cbBuffer;
    
    m_bTrimmedLateAudio = TRUE; 
    
    return S_OK;    
}        

//  Helper to restart the device if necessary
void CWaveOutInputPin::CheckPaused()
{
    if (m_pFilter->m_wavestate == WD_PAUSED &&
        m_pFilter->m_State == State_Running) {
        // Restart the device

        REFERENCE_TIME rtStart = m_pFilter->m_tStart;
        REFERENCE_TIME rtStop = rtStart;
        if( SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID )
        {
            rtStart += SampleProps()->tStart;
            rtStop  = rtStart;
        }
        if( SampleProps()->dwSampleFlags & AM_SAMPLE_STOPVALID )
        {
            // although rtStop isn't even used by SetUpRestartWave, so this isn't necessary
            rtStop += SampleProps()->tStop;
        }
        m_pFilter->SetUpRestartWave( rtStart, rtStop );
    }
}


// incoming samples are not on our allocator, so copy the contents of this
// sample to our sample.
HRESULT
CWaveOutInputPin::CopyToOurSample(
    IMediaSample* pBuffer,
    BYTE* &pData,
    LONG &lData
    )
{
    if (m_pFilter->m_eSentEOS) {
        return VFW_E_SAMPLE_REJECTED_EOS;
    }

    HRESULT hr = CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }

    if (!m_pFilter->m_bHaveWaveDevice) {
        // no wave device, so we can't do much....

        // tell the upstream filter that actually we don't want any
        // more data on this stream.
        m_pFilter->QueueEOS();
        return S_FALSE;
    }

    // addref the sample - we'll release it if we don't use it
    pBuffer->AddRef();


    BYTE * pBufferData;
    pBuffer->GetPointer(&pBufferData);
    LONG cbBuffer = min(lData, pBuffer->GetSize());

    DbgLog((LOG_TRACE,8,TEXT("Waveout: Copying %d bytes of data"), cbBuffer));

    CopyMemory(pBufferData, pData, cbBuffer);
    pBuffer->SetActualDataLength(cbBuffer);

    lData -= cbBuffer;
    pData += cbBuffer;

    LPWAVEHDR pwh = (LPWAVEHDR) (pBufferData - m_pFilter->m_lHeaderSize);

    // need to adjust to actual bytes written
    pwh->dwBufferLength = cbBuffer;

    // note that we have added another buffer.  We do it
    // here to guarantee that the callback sees the correct value
    // If we do it after the write the callback may have happened
    // which means that if the Write fails we must decrement
    InterlockedIncrement(&m_pFilter->m_lBuffers);
// #ifdef PERF
    // there is a small timing hole here in that the callback
    // could decrement the count before we read it.  However
    // the trace should allow this anomaly to be identified.
    LONG buffercount = m_pFilter->m_lBuffers;
// #endif

#ifdef THROTTLE
    // remember the maximum queue length reached.
    if (buffercount > m_pFilter->m_nMaxAudioQueue) {
        m_pFilter->m_nMaxAudioQueue = buffercount;
    }
#endif // THROTTLE

    UINT err = m_pFilter->amsndOutWrite(pwh, m_pFilter->m_lHeaderSize, NULL, NULL);
    if (err > 0) {
        // device error: PCMCIA card removed?
        DbgLog((LOG_ERROR,1,TEXT("Error from waveOutWrite: %d"), err));
        pBuffer->Release();

        // make the buffer count correct again
        InterlockedDecrement(&m_pFilter->m_lBuffers);

        m_pFilter->ScheduleComplete();
        // no more data will come.  ignore bytes in queue count
        return E_FAIL;
    } else {
        CheckPaused();
    }
#ifdef THROTTLE
    m_pFilter->SendForHelp(buffercount);
    MSR_INTEGER(m_idWaveQueueLength, buffercount);
#endif // THROTTLE

    return S_OK;
}


// no more data is coming. If we have samples queued, then store this for
// action in the last wave callback. If there are no samples, then action
// it now by notifying the filtergraph.
//
// we communicate with the wave callback using InterlockedDecrement on
// m_lBuffers. This is normally 0, and is incremented for each added buffer.
// At eos, we decrement this, so on the last buffer, the waveout callback
// will be decrementing it to -1 rather than 0 and can signal EC_COMPLETE.

STDMETHODIMP
CWaveOutInputPin::EndOfStream(void)
{
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("CWaveOutInputPin::EndOfStream()")));
    // lock this with the filter-wide lock
    CAutoLock lock(m_pFilter);

    if (m_hEndOfStream) {
        EXECUTE_ASSERT(SetEvent(m_hEndOfStream));
        return S_OK;
    }

    HRESULT hr = CheckStreaming();
    if (S_OK == hr) {
        m_pFilter->m_bHaveEOS = TRUE;
        if (m_pFilter->m_State == State_Paused) {
            m_pFilter->m_evPauseComplete.Set();   // We have end of stream - transition is complete
            DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel + 1, "Completing transition into Pause due to EOS"));
        }
        hr = m_pFilter->ScheduleComplete();
    }
    return hr;
}


// enter flush state - block receives and free queued data
STDMETHODIMP
CWaveOutInputPin::BeginFlush(void)
{
    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive
    CAutoLock lock(m_pFilter);
    DbgLog((LOG_TRACE, 2, "wo: BeginFlush, filter is %8x", m_pFilter));

    m_hEndOfStream = 0;

    // block receives
    HRESULT hr = CBaseInputPin::BeginFlush();
    if (!FAILED(hr)) {

        // discard queued data

        // force end-of-stream clear - this is to make sure
        // that a queued end-of-stream does not get delivered by
        // the wave callback when the buffers are released.
        InterlockedIncrement(&m_pFilter->m_lBuffers);

        // EOS cleared
        m_pFilter->m_eSentEOS    = EOS_NOTSENT;
        m_pFilter->m_bHaveEOS    = FALSE;

        // release all buffers from the wave driver

        if (m_pFilter->m_hwo) {

            ASSERT(CritCheckIn(m_pFilter));

            // amsndOutReset and ResetPosition are split in time
            // but consistency is guaranteed as we hold the filter
            // lock.

            m_pFilter->amsndOutReset();
            DbgLog((LOG_TRACE, 3, "Resetting the wave device in BEGIN FLUSH, state=%d, filter is %8x", m_pFilter->m_State, m_pFilter));

            if(m_pFilter->m_fDSound)
            {
                // for dsound renderer clear any adjustments needed for dynamic format changes
                // this is needed for seeks that may occur after or over format changes
                PDSOUNDDEV(m_pFilter->m_pSoundDevice)->m_llAdjBytesPrevPlayed = 0;
            }

            if (m_pFilter->m_State == State_Paused) {
                // and re-cue the device so that the next
                // write does not start playing immediately
                m_pFilter->amsndOutPause();
                m_pFilter->SetWaveDeviceState(WD_PAUSED);
            }

            // the wave clock tracks current position to base it's timing on.
            // we need to reset where it thinks it is through the data.
            if (m_pFilter->m_pRefClock) {
                m_pFilter->m_pRefClock->ResetPosition();
            }
        }

        // now force the buffer count back to the normal (non-eos) case.
        // at this point, we are sure there are no more buffers coming in
        // and no more buffers waiting for callbacks.
        m_pFilter->m_lBuffers = 0;

        // free anyone blocked on receive - not possibly in this filter

        // call downstream -- no downstream pins

    }
    return hr;
}

// leave flush state - ok to re-enable receives
STDMETHODIMP
CWaveOutInputPin::EndFlush(void)
{
    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive
    CAutoLock lock(m_pFilter);

    // EOS cleared in BeginFlush
    ASSERT(m_pFilter->m_eSentEOS == EOS_NOTSENT &&
           m_pFilter->m_bHaveEOS == FALSE &&
           m_pFilter->m_lBuffers == 0);

    m_bSampleRejected = FALSE;
    DbgLog((LOG_TRACE, 3, "EndFlush - resetting EOS flags, filter=%8x",m_pFilter));

    // Assert that BeginFlush has been called?

    // sync with pushing thread -- we have no worker thread

    // ensure no more data to go downstream
    // --- we did this in BeginFlush()

    // call EndFlush on downstream pins -- no downstream pins

    // unblock Receives
    return CBaseInputPin::EndFlush();
}


// NewSegment notifies of the start/stop/rate applying to the data
// about to be received. Default implementation records data and
// returns S_OK.
// We also reset any pending "callback advise"
STDMETHODIMP CWaveOutInputPin::NewSegment(
        REFERENCE_TIME tStart,
        REFERENCE_TIME tStop,
        double dRate)
{
    DbgLog((LOG_TRACE, 3, "Change of segment data: new Start %10.10s  new End %s", (LPCTSTR)CDisp(tStart, CDISP_DEC), (LPCTSTR)CDisp(tStop, CDISP_DEC)));
    DbgLog((LOG_TRACE, 3, "                        old Start %10.10s  old End %s", (LPCTSTR)CDisp(m_tStart, CDISP_DEC), (LPCTSTR)CDisp(m_tStop, CDISP_DEC)));
    DbgLog((LOG_TRACE, 3, "                        new Rate  %s       old Rate %s", (LPCTSTR)CDisp(dRate), (LPCTSTR)CDisp(m_dRate)));
    HRESULT hr;

    // lock this with the filter-wide lock - synchronize with starting
    CAutoLock lock(m_pFilter);

    // Change the rate in the base pin first so that the member variables
    // get set up correctly
    hr = CBaseInputPin::NewSegment(tStart, tStop, dRate);
    if (S_OK == hr) {

        // if there is a pending EOS advise callback - reset it.
        if (m_pFilter->m_dwEOSToken) {
            DbgLog((LOG_TRACE, 2, "Resetting queued EOS"));
            m_pFilter->QueueEOS();
        }

#ifdef ENABLE_DYNAMIC_RATE_CHANGE
        // when the gremlins associated with dynamic rate changes have
        // been sorted out this line should be reinserted and ReOpenWaveDevice
        // reinspected.
        if (IsConnected()) {

            if(m_pFilter->m_fDSound)
            {
                hr = PDSOUNDDEV(m_pFilter->m_pSoundDevice)->SetRate(dRate);
            }
            else
            {
                hr = m_pFilter->ReOpenWaveDevice(dRate);
            }
        }
#endif

    }
    return hr;
}

//  Suggest a format
HRESULT CWaveOutInputPin::GetMediaType(
    int iPosition,
    CMediaType *pMediaType
)
#ifdef SUGGEST_FORMAT
{
    if (iPosition < 0 || iPosition >= 12) {
        return VFW_S_NO_MORE_ITEMS;
    }

    /*  Do 11, 22, 44 Khz, 8/16 bit mono/stereo */
    iPosition = 11 - iPosition;
    WAVEFORMATEX Format;
    Format.nSamplesPerSec = 11025 << (iPosition / 4);
    Format.nChannels = (iPosition % 4) / 2 + 1;
    Format.wBitsPerSample = ((iPosition % 2 + 1)) * 8;

    Format.nBlockAlign = Format.nChannels * Format.wBitsPerSample / 8;
    Format.nAvgBytesPerSec = Format.nSamplesPerSec *
                             Format.nBlockAlign;
    Format.wFormatTag = WAVE_FORMAT_PCM;
    Format.cbSize = 0;

    pMediaType->SetType(&MEDIATYPE_Audio);
    pMediaType->SetSubtype(&MEDIATYPE_NULL);
    pMediaType->SetFormatType(&FORMAT_WaveFormatEx);
    pMediaType->SetTemporalCompression(FALSE);
    pMediaType->SetSampleSize(Format.nBlockAlign);
    pMediaType->SetFormat((PBYTE)&Format, sizeof(Format));
    return S_OK;
}
#else
//  Just suggest audio - otherwise the filter graph searching is often
//  broken - all the types we support here are
{
    if (iPosition != 0) {
        return VFW_S_NO_MORE_ITEMS;
    }
    m_pFilter->m_pSoundDevice->amsndOutGetFormat(pMediaType);
    return S_OK;
}
#endif


STDMETHODIMP CWaveOutInputPin::SetRate(double dNewRate)
{
    CAutoLock Lock( m_pFilter );

    if( m_pFilter->m_dRate == m_dRate && m_dRate == dNewRate )
    {
        // no change
        return S_FALSE;
    }

    // If rate is negative, we rely on some upstream filter
    // to reverse the data, so just check abs(rate).
    const HRESULT hr = m_pFilter->CheckRate( fabs(dNewRate) );
    return hr;
}

HRESULT
CWaveOutInputPin::Active(void)
{
    m_bSampleRejected = FALSE;

    m_pFilter->m_bActive = TRUE;

    // Reset this.
    m_rtActualSegmentStartTime = 0;

    m_hEndOfStream = 0;

    if(!m_pOurAllocator)
        return S_OK;

    // commit and prepare our allocator. Needs to be done
    // if he is not using our allocator, and in any case needs to be done
    // before we complete our close of the wave device.
    return m_pOurAllocator->Commit();
}

HRESULT
CWaveOutInputPin::Inactive(void)
{
    m_pFilter->m_bActive = FALSE;
    m_bReadOnly = FALSE;

    DestroyPreviousType();

    if (m_pOurAllocator == NULL) {
        return S_OK;
    }
    // decommit the buffers - normally done by the output
    // pin, but we need to do it here ourselves, before we close
    // the device, and in any case if he is not using our allocator.
    // the output pin will also decommit the allocator if he
    // is using ours, but that's not a problem

    // once all buffers are freed (which may be immediately during the Decommit
    // call) the allocator will call back to OnReleaseComplete for us to close
    // the wave device.
    HRESULT hr = m_pOurAllocator->Decommit();

    return hr;
}

void
CWaveOutInputPin::DestroyPreviousType(void)
{
    if(m_pmtPrevious) {
        DeleteMediaType(m_pmtPrevious);
        m_pmtPrevious = 0;
    }
}

// dwUser parameter is the CWaveOutFilter pointer

void CALLBACK CWaveOutFilter::WaveOutCallback(HDRVR hdrvr, UINT uMsg, DWORD_PTR dwUser,
                          DWORD_PTR dw1, DWORD_PTR dw2)
{
    switch (uMsg) {
    case WOM_DONE:
    case MOM_DONE:
      {

        // is this the end of stream?
        CWaveOutFilter* pFilter = (CWaveOutFilter *) dwUser;
        ASSERT(pFilter);

        CMediaSample *pSample;
        if(pFilter->m_fUsingWaveHdr)
        {
            // legacy case, or, we happen to be using an unfriendly parser, sample has been wrapped by the waveHdr
            LPWAVEHDR lpwh = (LPWAVEHDR)dw1;
            ASSERT(lpwh);
            pSample = (CMediaSample *)lpwh->dwUser;
        }
        else
        {
            // optimized case, we simply pass the sample on the stack
            pSample = (CMediaSample *)dw1;
        }

        DbgLog((LOG_TRACE,3, TEXT("WaveOutCallback: sample %X"), pSample));

        // note that we have finished with a buffer, and
        // look for eos
        LONG value = InterlockedDecrement(&pFilter->m_lBuffers);
        if (value <= 0) {

            // signal that we're done
            // either the audio has broken up or we have
            // naturally come to the end of the stream.

#ifdef THROTTLE
            MSR_INTEGER(pFilter->m_pInputPin->m_idWaveQueueLength, 0);
            pFilter->SendForHelp(0);
#endif // THROTTLE

            if (value < 0) {
                // EOS case - send EC_COMPLETE
                ASSERT(pFilter->m_eSentEOS == EOS_PENDING);

                //  This is where an EC_COMPLETE
                //  gets sent if we process it while we're running
                //
                //  warning, there's still a small timing hole here where
                //  the device could get paused just after we call into this...
                pFilter->SendComplete( pFilter->m_wavestate == WD_RUNNING );
            }

#ifdef THROTTLE
        } else {
#ifdef PERF
            LONG buffercount = pFilter->m_lBuffers;
            MSR_INTEGER(pFilter->m_pInputPin->m_idWaveQueueLength, buffercount);
#endif
            pFilter->SendForHelp(pFilter->m_lBuffers);
#endif // THROTTLE
        }

        if(pSample)
        {
            MSR_START(pFilter->m_idReleaseSample);
            pSample->Release(); // we're done with this buffer....
            MSR_STOP(pFilter->m_idReleaseSample);
        }
      }
        break;

    case WOM_OPEN:
    case WOM_CLOSE:
    case MOM_OPEN:
    case MOM_CLOSE:
        break;

    default:
        DbgLog((LOG_ERROR,2,TEXT("Unexpected wave callback message %d"), uMsg));
        break;
    }
}

STDMETHODIMP CWaveOutFilter::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock lock(this);
    if(IsStopped())
    {
        return m_pSoundDevice->amsndOutLoad(pPropBag);
    }
    else
    {
        return VFW_E_WRONG_STATE;
    }
}

STDMETHODIMP CWaveOutFilter::Save(
    LPPROPERTYBAG pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CWaveOutFilter::InitNew()
{
    return S_OK;
}

STDMETHODIMP CWaveOutFilter::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);;
}

HRESULT CWaveOutFilter::WriteToStream(IStream *pStream)
{
    return m_pSoundDevice->amsndOutWriteToStream(pStream);
}

HRESULT CWaveOutFilter::ReadFromStream(IStream *pStream)
{
    CAutoLock lock(this);
    if(IsStopped())
    {
        return m_pSoundDevice->amsndOutReadFromStream(pStream);
    }
    else
    {
        return VFW_E_WRONG_STATE;
    }
}

int CWaveOutFilter::SizeMax()
{
    return m_pSoundDevice->amsndOutSizeMax();
}


STDMETHODIMP CWaveOutFilter::Reserve(
    /*[in]*/ DWORD dwFlags,          //  From _AMRESCTL_RESERVEFLAGS enum
    /*[in]*/ PVOID pvReserved        //  Must be NULL
)
{
    if (pvReserved != NULL || (dwFlags & ~AMRESCTL_RESERVEFLAGS_UNRESERVE)) {
        return E_INVALIDARG;
    }
    HRESULT hr = S_OK;
    CAutoLock lck(this);
    if (dwFlags & AMRESCTL_RESERVEFLAGS_UNRESERVE) {
        if (m_dwLockCount == 0) {
            DbgBreak("Invalid unlock of audio device");
            hr =  E_UNEXPECTED;
        } else {
            m_dwLockCount--;
            if (m_dwLockCount == 0 && m_State == State_Stopped) {
                ASSERT(m_hwo);

                // stop using the wave device
                m_bHaveWaveDevice = FALSE;

                HRESULT hr1 = S_OK;
                if(m_pInputPin->m_pOurAllocator) {
                    HRESULT hr1 = m_pInputPin->m_pOurAllocator->ReleaseResource();
                }

                if (SUCCEEDED(hr1)) {
                    CloseWaveDevice();
                }
                m_bHaveWaveDevice = FALSE;
            }
        }
    } else  {
        if (m_dwLockCount != 0 || m_hwo) {
        } else {
            hr = OpenWaveDevice();
        }
        if (hr == S_OK) { // ZoltanS fix 1-28-98
            m_dwLockCount++;
        }
    }
    return hr;
}

// IAMAudioDeviceConfig methods
STDMETHODIMP CWaveOutFilter::SetDeviceID( REFGUID pDSoundGUID, UINT uiWaveID  )
{
    //
    // although the dsound capture filter supports device selection via this method
    // the dsound renderer doesn't at this time. 
    //
    return E_NOTIMPL;
}

STDMETHODIMP CWaveOutFilter::SetDuplexController( IAMAudioDuplexController * pAudioDuplexController )
{
    CAutoLock lock(this);

    if (m_pAudioDuplexController != NULL)
    {
        m_pAudioDuplexController->Release();
    }

    pAudioDuplexController->AddRef();
    m_pAudioDuplexController = pAudioDuplexController;

    return S_OK;
}

// --- Allocator Methods --------------------------------------------------------


// CWaveAllocator

/* Constructor must initialise the base allocator */

CWaveAllocator::CWaveAllocator(
    TCHAR *pName,
    LPWAVEFORMATEX lpwfx,
    IReferenceClock* pRefClock,
    CWaveOutFilter* pFilter,
    HRESULT *phr)
    : CBaseAllocator(pName, NULL, phr)
    , m_fBuffersLocked(FALSE)
    , m_hAudio(0)
    , m_pAllocRefClock(pRefClock)
    , m_dwAdvise(0)
    , m_pAFilter(pFilter)
#ifdef DEBUG
    , m_pAFilterLockCount(0)
#endif
    , m_nBlockAlign(lpwfx->nBlockAlign)
    , m_pHeaders(NULL)
{
    // !!! for MIDI, this will be zero, but it's only used to align buffer sizes,
    // so it's not a real problem.
    if (m_nBlockAlign < 1)
        m_nBlockAlign = 1;

    if (!FAILED(*phr)) {

        // IF we have a clock, we create an event to allow buffers
        // to be Release'd evenly.  If anything fails we will carry
        // on, but buffers might be released in a rush and disturb
        // the even running of the system.
        if (m_pAllocRefClock) {

            // DO NOT Addref the clock - we end up with a circular
            // reference with the clock (filter) and allocator
            // holding references on each other, and neither gets
            // deleted.
            // m_pAllocRefClock->AddRef();
        }
    }
}


// Called from destructor and also from base class

// all buffers have been returned to the free list and it is now time to
// go to inactive state. Unprepare all buffers and then free them.
void CWaveAllocator::Free(void)
{
    // lock held by base class CBaseAllocator

    // unprepare the buffers
    OnDeviceRelease();

    delete [] m_pHeaders;
    m_pHeaders = NULL;

    CMediaSample *pSample;  // Pointer to next sample to delete

    /* Should never be deleting this unless all buffers are freed */

    ASSERT(m_lAllocated == m_lFree.GetCount());
    ASSERT(!m_fBuffersLocked);

    DbgLog((LOG_MEMORY,1,TEXT("Waveallocator: Destroying %u buffers (%u free)"), m_lAllocated, m_lFree.GetCount()));

    /* Free up all the CMediaSamples */

    while (m_lFree.GetCount() != 0) {

        /* Delete the CMediaSample object but firstly get the WAVEHDR
           structure from it so that we can clean up it's resources */

        pSample = m_lFree.RemoveHead();

        BYTE *pBuf;
        pSample->GetPointer(&pBuf);

        pBuf -= m_pAFilter->m_lHeaderSize;

#ifdef DEBUG
        WAVEHDR wh;         // used to verify it is our object
        // !!! Is this really one of our objects?
        wh = *(WAVEHDR *) pBuf;
        // what should we look at?
#endif

        // delete the actual memory buffer
        delete[] pBuf;

        // delete the CMediaSample object
        delete pSample;
    }

    /* Empty the lists themselves */

    m_lAllocated = 0;

    // audio device is only ever released when we're told to by ReleaseResource
}


STDMETHODIMP CWaveAllocator::LockBuffers(BOOL fLock)
{
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("Allocator::LockBuffers(BOOL fLock(%i))"), fLock));

    // All three of these "return NOERROR" _ARE_ used.

    if (m_fBuffersLocked == fLock) return NOERROR;
    ASSERT(m_pHeaders != NULL || m_lAllocated == 0);

    // do not set the lock flag unless we actually do the lock/unlock.
    // we can be called to lock buffers before the allocator has
    // been committed in which case there is no device and no buffers.
    // When we are set up this routine will be called again.

    if (!m_hAudio) return NOERROR;

    if (m_lAllocated == 0) return NOERROR;

    /* Should never be doing this unless all buffers are freed */
#ifdef DEBUG
    if (m_pAFilter->AreThereBuffersOutstanding()) {
        DbgLog((LOG_TRACE, 0, TEXT("filter = %8.8X, m_lBuffers = %d, EOS state = %d, m_bHaveEOS = %d"),
                m_pAFilter, m_pAFilter->m_lBuffers, m_pAFilter->m_eSentEOS, m_pAFilter->m_bHaveEOS));
        DebugBreak();
    }
#endif

    DbgLog((LOG_TRACE,2,TEXT("Calling wave%hs%hsrepare on %u buffers"), "Out" , fLock ? "P" : "Unp", m_lAllocated));
    UINT err;

    /* Prepare/unprepare all the CMediaSamples */

    for (int i = 0; i < m_lAllocated; i++) {

        LPWAVEHDR pwh = m_pHeaders[i];

        // need to ensure that buffer length is the same as the max size of
        // the sample. We will have reduced this length to actual data length
        // during running, but to un/prepare (eg on re-acquire of device) it
        // needs to be reset.

        if (fLock)
        {
            ASSERT(pwh->dwBufferLength == (DWORD)m_lSize);
            err = m_pAFilter->amsndOutPrepareHeader (pwh, m_pAFilter->m_lHeaderSize) ;
            if (err > 0) {
                DbgLog((LOG_TRACE, 0, TEXT("Prepare header failed code %d"),
                        err));
                for (int j = 0; j < i; j++) {
                    LPWAVEHDR pwh = m_pHeaders[j];
                    m_pAFilter->amsndOutUnprepareHeader(
                        pwh, m_pAFilter->m_lHeaderSize);
                }
            }
        }
        else
        {
            pwh->dwBufferLength = m_lSize;
            FixUpWaveHeader(pwh);
            err = m_pAFilter->amsndOutUnprepareHeader (pwh, m_pAFilter->m_lHeaderSize) ;

        }

        if (err > 0) {
            DbgLog((LOG_ERROR,1,TEXT("Error in wave%hs%hsrepare: %u"), "Out" , fLock ? "P" : "Unp", err));

            // !!! Need to unprepare everything....
            return E_FAIL; // !!!!
        }
    }

    m_fBuffersLocked = fLock;

    return NOERROR;
}


/* The destructor ensures the shared memory DIBs are deleted */

CWaveAllocator::~CWaveAllocator()
{
    // go to decommit state here. the base class can't do it in its
    // destructor since its too late by then - we've been destroyed.
    Decommit();

    if (m_pAllocRefClock)
    {
        if (m_dwAdvise) {
            m_pAllocRefClock->Unadvise(m_dwAdvise);
        }
        // See comments in wave allocator constructor as to why we do
        // not need to hold a reference count on the wave clock.
        // m_pAllocRefClock->Release();
    }
    ASSERT(m_pHeaders == NULL);
}


// Agree the number and size of buffers to be used. No memory
// is allocated until the Commit call.
STDMETHODIMP CWaveAllocator::SetProperties(
            ALLOCATOR_PROPERTIES* pRequest,
            ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pRequest,E_POINTER);
    CheckPointer(pActual,E_POINTER);

    //  Fix up different formats - note that this really needs adjusting
    //  for the rate too!

    // We really should rely on the source providing us with the right
    // buffering.  To avoid total disaster we insist on an 1/8 second.
    LONG MIN_BUFFER_SIZE = (m_pAFilter->m_pInputPin->m_nAvgBytesPerSec / 8);
    // this will be 11K at 44KHz, 16 bit stereo

    if (MIN_BUFFER_SIZE < 1024)
        MIN_BUFFER_SIZE = 1024;

    ALLOCATOR_PROPERTIES Adjusted = *pRequest;

    if (Adjusted.cbBuffer < MIN_BUFFER_SIZE)
        Adjusted.cbBuffer = MIN_BUFFER_SIZE;

    // waveout has trouble with 4 1/30th second buffers which is what
    // we end up with for certain files. if the buffers are really
    // small (less than 1/17th of a second), go for 8 buffers instead
    // of 4.
    if((LONG)m_pAFilter->m_pInputPin->m_nAvgBytesPerSec > pRequest->cbBuffer * 17)
    {
        Adjusted.cBuffers = max(8, Adjusted.cBuffers);
    }
    else if (Adjusted.cBuffers < 4) {
        Adjusted.cBuffers = 4;
    }

    // round the buffer size up to the requested alignment
    Adjusted.cbBuffer += m_nBlockAlign - 1;
    Adjusted.cbBuffer -= (Adjusted.cbBuffer % m_nBlockAlign);

    if (Adjusted.cbBuffer <= 0) {
        return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE,5,TEXT("waveOut: Num = %u, Each = %u, Total buffer size = %u"),
    Adjusted.cBuffers, Adjusted.cbBuffer, (Adjusted.cBuffers * Adjusted.cbBuffer)));

    /* Pass the amended values on for final base class checking */
    return CBaseAllocator::SetProperties(&Adjusted,pActual);
}


// allocate and prepare the buffers

// called from base class to alloc memory when moving to commit state.
// object locked by base class
HRESULT
CWaveAllocator::Alloc(void)
{
    /* Check the base class says it's ok to continue */

    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
        return hr;
    }

    CMediaSample *pSample;  // Pointer to the new sample

    /* We create a new memory block large enough to hold our WAVEHDR
       along with the actual wave data */

    DbgLog((LOG_MEMORY,1,TEXT("Allocating %d wave buffers, %d bytes each"), m_lCount, m_lSize));

    ASSERT(m_lAllocated == 0 && m_pHeaders == NULL);
    m_pHeaders = new LPWAVEHDR[m_lCount];
    if (m_pHeaders == NULL) {
        return E_OUTOFMEMORY;
    }
    for (; m_lAllocated < m_lCount; m_lAllocated++) {
        /* Create and initialise a buffer */
        BYTE * lpMem = new BYTE[m_lSize + m_pAFilter->m_lHeaderSize];
        WAVEHDR * pwh = (WAVEHDR *) lpMem;

        if (lpMem == NULL) {
            hr = E_OUTOFMEMORY;
            break;
        }

        /* The address we give the sample to look after is the actual address
           the audio data will start and so does not include the prefix.
           Similarly, the size is of the audio data only */

        pSample = new CMediaSample(NAME("Wave audio sample"), this, &hr, lpMem + m_pAFilter->m_lHeaderSize, m_lSize);

        pwh->lpData = (char *) (lpMem + m_pAFilter->m_lHeaderSize);
        pwh->dwBufferLength = m_lSize;
        pwh->dwFlags = 0;
        pwh->dwUser = (DWORD_PTR) pSample;
        m_pHeaders[m_lAllocated] = pwh;

        /* Clean up the resources if we couldn't create the object */

        if (FAILED(hr) || pSample == NULL) {
            delete[] lpMem;
            break;
        }

        /* Add the completed sample to the available list */

        m_lFree.Add(pSample);
    }

    if (SUCCEEDED(hr)) {
        hr = LockBuffers(TRUE);
    }


    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("LockBuffers failed, hr=%x"), hr));
        Free();
        return hr;
    }

#ifdef DEBUG
    if (m_hAudio) {
        ASSERT(m_fBuffersLocked == TRUE);
    }
#endif

    return NOERROR;
}


// we have the wave device - prepare headers and start allowing GetBuffer
HRESULT
CWaveAllocator::OnAcquire(HWAVE hw)
{
    CAutoLock lock(this);

    // must not have the device
    ASSERT(!m_hAudio);

    // until we release the device we hold a reference count on the filter
    ASSERT(m_pAFilter);

    m_hAudio = hw;

    HRESULT hr;

    hr = LockBuffers(TRUE);

    if (SUCCEEDED(hr)) {
        // the reference count is kept while m_hAudio is valid
        m_pAFilter->AddRef();
#ifdef DEBUG
        m_pAFilterLockCount++;
#endif
    } else {
        m_hAudio = NULL;
    }

    return hr;
}

// please unprepare all samples  - return S_OK if this can be done
// straight away, or S_FALSE if needs to be done async. If async,
// will call CWaveOutFilter::OnReleaseComplete when done.
HRESULT
CWaveAllocator::ReleaseResource()
{
    CAutoLock lock(this);
    HRESULT hr = S_OK;

    if (m_hAudio) {
        DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("Allocator::ReleaseResource: m_hAudio is set.")));

        // can do it now and return S_OK (don't call OnReleaseComplete)

        // we may have done the decommit already - but won't have
        // released the device yet
        LockBuffers(FALSE);
        m_hAudio = NULL;

        // release the filter reference count
        ASSERT(m_pAFilter);
        m_pAFilter->Release();
#ifdef DEBUG
        ASSERT(m_pAFilterLockCount);
        --m_pAFilterLockCount;
#endif
    } else {
        DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("Allocator::ReleaseResource: Nothing to do.")));
        // don't have the device now
    }
    return hr;
}

// Called from Free to unlock buffers on last release. Don't call back to
// filter since we have the critsecs in the wrong order.
//
// Once the decommit is complete, the filter will call back on our
// ReleaseResource method to check that all buffers were freed and the device is
// released
HRESULT
CWaveAllocator::OnDeviceRelease(void)
{
    LockBuffers(FALSE);

    // device is actually released now only when we are told to via
    // a call to ReleaseResource

    return S_OK;
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// Wrappers for device control calls
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutOpen
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutOpen
(
    LPHWAVEOUT phwo,
    LPWAVEFORMATEX pwfx,
    double dRate,
    DWORD *pnAvgBytesPerSec,
    DWORD_PTR dwCallBack,
    DWORD_PTR dwCallBackInstance,
    DWORD fdwOpen,
    BOOL  bNotifyOnFailure
)
{
    MMRESULT mmr = m_pSoundDevice->amsndOutOpen( phwo
                                               , pwfx
                                               , dRate
                                               , pnAvgBytesPerSec
                                               , dwCallBack
                                               , dwCallBackInstance
                                               , fdwOpen );
    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Open, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutOpen failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOut
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutClose( BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutClose();

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Close, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutClose failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutGetDevCaps
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutGetDevCaps
(
    LPWAVEOUTCAPS pwoc,
    UINT cbwoc,
    BOOL bNotifyOnFailure
)
{
    MMRESULT mmr = m_pSoundDevice->amsndOutGetDevCaps( pwoc, cbwoc);

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_GetCaps, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutGetDevCaps failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutGetPosition
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutGetPosition ( LPMMTIME pmmt, UINT cbmmt, BOOL bUseAbsolutePos, BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutGetPosition( pmmt, cbmmt, bUseAbsolutePos);

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_GetPosition, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutGetPosition failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutPause
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutPause( BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutPause();

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Pause, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutPause failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutPrepareHeader
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutPrepareHeader( LPWAVEHDR pwh, UINT cbwh, BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutPrepareHeader( pwh, cbwh );

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_PrepareHeader, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutPrepareHeader failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutUnprepareHeader
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutUnprepareHeader( LPWAVEHDR pwh, UINT cbwh, BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutUnprepareHeader( pwh, cbwh );

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_UnprepareHeader, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutUnprepareHeader failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutReset
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutReset( BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutReset();

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Reset, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutReset failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutRestart
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutRestart( BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutRestart();

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Restart, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutRestart failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutWrite
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutWrite
(
    LPWAVEHDR pwh,
    UINT cbwh,
    REFERENCE_TIME const *pStart,
    BOOL bIsDiscontinuity,
    BOOL bNotifyOnFailure
)
{
    MMRESULT mmr = m_pSoundDevice->amsndOutWrite( pwh, cbwh, pStart, bIsDiscontinuity );

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Write, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutWrite failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}




//////////////
// 3D STUFF //
//////////////


HRESULT CWaveOutFilter::CDS3D::GetAllParameters(LPDS3DLISTENER lpds3d)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener *lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetAllParameters(lpds3d);
}

HRESULT CWaveOutFilter::CDS3D::GetDistanceFactor(LPD3DVALUE pf)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetDistanceFactor(pf);
}

HRESULT CWaveOutFilter::CDS3D::GetDopplerFactor(LPD3DVALUE pf)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetDopplerFactor(pf);
}

HRESULT CWaveOutFilter::CDS3D::GetOrientation(LPD3DVECTOR pv1, LPD3DVECTOR pv2)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetOrientation(pv1, pv2);
}

HRESULT CWaveOutFilter::CDS3D::GetPosition(LPD3DVECTOR pv)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetPosition(pv);
}

HRESULT CWaveOutFilter::CDS3D::GetRolloffFactor(LPD3DVALUE pf)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetRolloffFactor(pf);
}

HRESULT CWaveOutFilter::CDS3D::GetVelocity(LPD3DVECTOR pv)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetVelocity(pv);
}

HRESULT CWaveOutFilter::CDS3D::SetAllParameters(LPCDS3DLISTENER lpds3d, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetAllParameters(lpds3d, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetDistanceFactor(D3DVALUE f, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetDistanceFactor(f, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetDopplerFactor(D3DVALUE f, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetDopplerFactor(f, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetOrientation(D3DVALUE x1, D3DVALUE y1, D3DVALUE z1, D3DVALUE x2, D3DVALUE y2, D3DVALUE z2, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetOrientation(x1, y1, z1, x2, y2, z2, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetPosition(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetPosition(x, y, z, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetRolloffFactor(D3DVALUE f, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetRolloffFactor(f, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetVelocity(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetVelocity(x, y, z, dw);
}

HRESULT CWaveOutFilter::CDS3D::CommitDeferredSettings()
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->CommitDeferredSettings();
}





HRESULT CWaveOutFilter::CDS3DB::GetAllParameters(LPDS3DBUFFER lpds3db)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetAllParameters(lpds3db);
}

HRESULT CWaveOutFilter::CDS3DB::GetConeAngles(LPDWORD pdw1, LPDWORD pdw2)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetConeAngles(pdw1, pdw2);
}

HRESULT CWaveOutFilter::CDS3DB::GetConeOrientation(LPD3DVECTOR pv)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetConeOrientation(pv);
}

HRESULT CWaveOutFilter::CDS3DB::GetConeOutsideVolume(LPLONG pl)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetConeOutsideVolume(pl);
}

HRESULT CWaveOutFilter::CDS3DB::GetMaxDistance(LPD3DVALUE pf)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetMaxDistance(pf);
}

HRESULT CWaveOutFilter::CDS3DB::GetMinDistance(LPD3DVALUE pf)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetMinDistance(pf);
}

HRESULT CWaveOutFilter::CDS3DB::GetMode(LPDWORD pdw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetMode(pdw);
}

HRESULT CWaveOutFilter::CDS3DB::GetPosition(LPD3DVECTOR pv)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetPosition(pv);
}

HRESULT CWaveOutFilter::CDS3DB::GetVelocity(LPD3DVECTOR pv)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetVelocity(pv);
}

HRESULT CWaveOutFilter::CDS3DB::SetAllParameters(LPCDS3DBUFFER lpds3db, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetAllParameters(lpds3db, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetConeAngles(DWORD dw1, DWORD dw2, DWORD dw3)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetConeAngles(dw1, dw2, dw3);
}

HRESULT CWaveOutFilter::CDS3DB::SetConeOrientation(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetConeOrientation(x, y, z, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetConeOutsideVolume(LONG l, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetConeOutsideVolume(l, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetMaxDistance(D3DVALUE f, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetMaxDistance(f, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetMinDistance(D3DVALUE p, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetMinDistance(p, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetMode(DWORD dw1, DWORD dw2)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetMode(dw1, dw2);
}

HRESULT CWaveOutFilter::CDS3DB::SetPosition(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetPosition(x, y, z, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetVelocity(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetVelocity(x, y, z, dw);
}

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\xmlgraph\qxmlhelp.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.

BSTR FindAttribute(IXMLElement *p, LPWSTR name);
DWORD ParseNum(LPWSTR p);
LONG ReadNumAttribute(IXMLElement *p, LPWSTR attrName, LONG lDefault = 0);
LONGLONG ParseTime(LPWSTR p);
LONGLONG ReadTimeAttribute(IXMLElement *p, LPWSTR attrName, LONGLONG llDefault = 0);
BOOL ReadBoolAttribute(IXMLElement *p, LPWSTR attrName, BOOL bDefault);

class CFakePropertyBag : public IPropertyBag, public CUnknown
{
public:
    DECLARE_IUNKNOWN

    CGenericList<WCHAR> m_listNames;
    CGenericList<WCHAR> m_listValues;

    CFakePropertyBag() :
	    CUnknown(NAME("property bag"), NULL),
	    m_listNames(NAME("names")), m_listValues(NAME("values"))
	    {  }

    ~CFakePropertyBag() { EmptyBag(); };
    
    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv) {
	if (riid == IID_IPropertyBag) {
	    return GetInterface((IPropertyBag *) this, ppv);
	} else {
	    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
	}
    };

    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog* pErrorLog);
    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar);

    
    void EmptyBag() {
	// delete the stored strings....
	BSTR p;

	do {
	    p = m_listValues.RemoveHead();
	    if (p)
		SysFreeString(p);
	} while (p);
	
	do {
	    p = m_listNames.RemoveHead();
	    if (p)
		SysFreeString(p);
	} while (p);
    }
};


HRESULT HandleParamTags(IXMLElement *p, IUnknown *punk);
HRESULT GetFilterFromCategory(REFCLSID clsidCategory, WCHAR *lpwInstance, IBaseFilter **ppf);

#ifndef NO_QXMLHELP_IMPL
BSTR FindAttribute(IXMLElement *p, LPWSTR name)
{
    VARIANT v;

    VariantInit(&v);
    
    HRESULT hr = p->getAttribute(name, &v);

    if (FAILED(hr))
	return NULL;

    return V_BSTR(&v);

}

DWORD ParseNum(LPWSTR p)
{
    DWORD dwRet = 0;

    WCHAR c;
    while (((c = *p++) >= L'0') && (c <= L'9') )
	dwRet = (dwRet * 10) + (c - L'0');

    return dwRet;
}

LONG ReadNumAttribute(IXMLElement *p, LPWSTR attrName, LONG lDefault /* = 0 */)
{
    BSTR val = FindAttribute(p, attrName);

    LONG lRet = lDefault;

    if (val) {
	lRet = ParseNum(val);

	SysFreeString(val);
    }

    return lRet;
}


LONGLONG ParseTime(LPWSTR p)
{
    DbgLog((LOG_TRACE, 4, TEXT("ParseTime: parsing '%hs'"), p));
    
    WCHAR c = *p++;

    // !!! could handle SMPTE frames here?
    DWORD	dwSec = 0;
    DWORD	dwMin = 0;
    DWORD	dwFrac = 0;
    int		iFracPlaces = -1;
    while (c != L'\0') {
	if (c >= L'0' && c <= L'9') {
	    if (iFracPlaces >= 0) {
		++iFracPlaces;
		dwFrac = dwFrac * 10 + (c - L'0');
	    } else {
		dwSec = dwSec * 10 + (c - L'0');
            }
	} else if (iFracPlaces >= 0) {
            break;
        } else if (c == L':') {
	    dwMin = dwMin * 60 + dwSec;
	    dwSec = 0;
	} else if (c == L'.') {
	    iFracPlaces = 0;
	} else
	    break;	// !!! allow for skipping whitespace?

	c = *p++;
    }

    LONGLONG llRet = (LONGLONG) dwFrac * UNITS;
    while (iFracPlaces-- > 0) {
	llRet /= 10;
    }

    llRet += (LONGLONG) dwMin * 60 * UNITS + (LONGLONG) dwSec * UNITS;

    DbgLog((LOG_TRACE, 4, TEXT("ParseTime: returning %d ms"), (DWORD) (llRet / 10000)));
    
    return llRet;
}

LONGLONG ReadTimeAttribute(IXMLElement *p, LPWSTR attrName, LONGLONG llDefault /* = 0 */)
{
    BSTR val = FindAttribute(p, attrName);

    LONGLONG llRet = llDefault;

    if (val) {
	llRet = ParseTime(val);

	SysFreeString(val);
    }

    return llRet;
}

BOOL ReadBoolAttribute(IXMLElement *p, LPWSTR attrName, BOOL bDefault)
{
    BSTR val = FindAttribute(p, attrName);

    if (val) {
	WCHAR c = *val;
	if (c == L'y' || c == L'Y' || c == L't' || c == L'T' || c == L'1')
	    bDefault = TRUE;
	else if (c == L'n' || c == L'N' || c == L'f' || c == L'F' || c == L'0')
	    bDefault = FALSE;
	else {
	    DbgLog((LOG_ERROR, 1, TEXT("Looking for yes/no value, found '%ls'"), val));
	}

	SysFreeString(val);
    }

    return bDefault;
}



STDMETHODIMP CFakePropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pvar,
				    IErrorLog* pErrorLog)
{
    USES_CONVERSION;
    
    if(pvar && pvar->vt != VT_EMPTY && pvar->vt != VT_BSTR)
	return E_INVALIDARG;

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    POSITION pos1, pos2;
    for(pos1 = m_listNames.GetHeadPosition(),
	pos2 = m_listValues.GetHeadPosition();
	pos1;
	pos1 = m_listNames.Next(pos1),
	pos2 = m_listValues.Next(pos2))
    {
	WCHAR *pName = m_listNames.Get(pos1);

	if (lstrcmpW(pName, pszPropName) == 0)
	{
	    WCHAR *pValue = m_listValues.Get(pos2);
	    hr = S_OK;

	    if(pvar)
	    {
		V_VT(pvar) = VT_BSTR;

		V_BSTR(pvar) = ::SysAllocString(pValue);

		if (!V_BSTR(pvar))
		    hr = E_OUTOFMEMORY;

		return hr;
	    }
	}
    }

    if(pos1 == 0)
    {
	ASSERT(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

    return hr;
};

STDMETHODIMP CFakePropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pvar)
{
    // !!! look in list of values to see if it's already there?
    BSTR bstrName = SysAllocString(pszPropName);
    if (!bstrName)
        return E_OUTOFMEMORY;

    BSTR bstrValue;
    
    if (V_VT(pvar) == VT_BSTR) {
        bstrValue = SysAllocString(V_BSTR(pvar));
        if (!bstrValue)
            return E_OUTOFMEMORY;
    } else {
        VARIANT v;
        V_VT(&v) = VT_EMPTY;
        HRESULT hr = VariantChangeType(&v, pvar, 0, VT_BSTR);

        if (FAILED(hr))
            return hr;

        bstrValue = V_BSTR(&v);
    }

    m_listNames.AddTail(bstrName);
    m_listValues.AddTail(bstrValue);

    return S_OK;
}

HRESULT HandleParamTags(IXMLElement *p, IUnknown *punk)
{
    HRESULT hr = S_OK;

    CFakePropertyBag bag;

    IXMLElementCollection *pcoll;

    hr = p->get_children(&pcoll);

    if (hr == S_FALSE)
	return S_OK; // nothing to do
    
    long lChildren;
    hr = pcoll->get_length(&lChildren);

    int iParamsFound = 0;

    VARIANT var;

    var.vt = VT_I4;
    var.lVal = 0;                    
    
    for (SUCCEEDED(hr); var.lVal < lChildren; (var.lVal)++) {
	IDispatch *pDisp;
	hr = pcoll->item(var, var, &pDisp);

	if (SUCCEEDED(hr) && pDisp) {
	    IXMLElement *pelem;
	    hr = pDisp->QueryInterface(__uuidof(IXMLElement), (void **) &pelem);

	    if (SUCCEEDED(hr)) {
		BSTR bstrName;
		hr = pelem->get_tagName(&bstrName);

		if (SUCCEEDED(hr)) {
		    if (!lstrcmpiW(bstrName, L"param")) {
			BSTR bstrName = FindAttribute(pelem, L"name");

			if (bstrName) {
			    BSTR bstrValue = FindAttribute(pelem, L"value");

			    if (!bstrValue) {
				hr = pelem->get_text(&bstrValue);
			    }

			    if (bstrValue) {
				// add this name/value pair to bag
				bag.m_listNames.AddTail(bstrName);
				bag.m_listValues.AddTail(bstrValue);

				++iParamsFound;
				SysFreeString(bstrValue);
			    }

			    SysFreeString(bstrName);
			} else {
			    hr = VFW_E_INVALID_FILE_FORMAT;
			}

		    } else {
			// !!! unknown other subtag?

		    }

		    SysFreeString(bstrName);
		}
		pelem->Release();
	    }
	    pDisp->Release();
	}
    }

    pcoll->Release();


    if (SUCCEEDED(hr) && iParamsFound) {
	// load properties from the bag
	IPersistPropertyBag *pPPB;
        HRESULT hr2 = punk->QueryInterface(IID_IPersistPropertyBag,
						    (void **) &pPPB);

        if (SUCCEEDED(hr2)) {
            if (iParamsFound == 1 && !lstrcmpW(L"data", bag.m_listNames.GetHead())) {
		DbgLog((LOG_TRACE, 1, TEXT("Using IPersistStream instead of IPersistPropertyBag")));
                hr2 = E_NOINTERFACE;
            } else {
                hr2 = pPPB->Load(&bag, NULL);

                if (FAILED(hr2)) {
                    DbgLog((LOG_ERROR, 1, TEXT("Error %x loading parameters"), hr2));
                }
            }
            
	    pPPB->Release();
        }
        
	if (FAILED(hr2)) {
	    DbgLog((LOG_ERROR, 1, TEXT("Filter doesn't take parameters?")));

	    // !!! loop through properties handling special cases?
	    // if there's an "src" param, send it to IFileSource/Sink

	    VARIANT v;
	    v.vt = VT_BSTR;
	    hr2 = bag.Read(L"src", &v, NULL);

	    if (SUCCEEDED(hr2)) {
		IFileSourceFilter *pFSF;
		hr2 = punk->QueryInterface(IID_IFileSourceFilter,
						    (void **) &pFSF);

		if (SUCCEEDED(hr2)) {
		    hr = pFSF->Load(V_BSTR(&v), NULL);

		    pFSF->Release();
		} else {

		    IFileSinkFilter *pFSF;
		    hr2 = punk->QueryInterface(IID_IFileSinkFilter,
							(void **) &pFSF);

		    if (SUCCEEDED(hr2)) {
			hr = pFSF->SetFileName(V_BSTR(&v), NULL);

			pFSF->Release();
		    }

		}

		SysFreeString(V_BSTR(&v));
	    }

	    v.vt = VT_BSTR;
	    hr2 = bag.Read(L"data", &v, NULL);

	    if (SUCCEEDED(hr2)) {
		BSTR bstr = V_BSTR(&v);

		IPersistStream *pPS;

		hr2 = punk->QueryInterface(IID_IPersistStream,
						    (void **) &pPS);

		if (SUCCEEDED(hr2)) {
		    // convert hex data into an IStream....
		    UINT dwLen = SysStringLen(bstr);
		    HGLOBAL h = GlobalAlloc(GHND, dwLen + 1);

		    if (h) {
			LPBYTE p = (LPBYTE) GlobalLock(h);
			for (UINT i = 0; i < dwLen / 2; i++) {
			    WCHAR wch = bstr[i * 2];
			    if (wch >= L'0' && wch <= L'9')
				p[i] = (BYTE) (wch - L'0') * 16;
			    else if (wch >= L'A' && wch <= L'F')
				p[i] = (BYTE) (wch - L'A' + 10) * 16;

			    wch = bstr[i * 2 + 1];
			    if (wch >= L'0' && wch <= L'9')
				p[i] += (BYTE) (wch - L'0');
			    else if (wch >= L'A' && wch <= L'F')
				p[i] += (BYTE) (wch - L'A' + 10);
			}

			IStream *ps;
			hr2 = CreateStreamOnHGlobal(h, TRUE, &ps);
			if (SUCCEEDED(hr2)) {
			    hr2 = pPS->Load(ps);
			    ps->Release();
			}
		    }

		    pPS->Release();
		}
		SysFreeString(bstr);
	    }
	}
    }

    return hr;
}




HRESULT GetFilterFromCategory(REFCLSID clsidCategory, WCHAR *lpwInstance, IBaseFilter **ppf)
{
    ICreateDevEnum *pCreateDevEnum;
    HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
				  IID_ICreateDevEnum, (void**)&pCreateDevEnum);
    if (hr != NOERROR)
	return hr;

    IEnumMoniker *pEm;
    hr = pCreateDevEnum->CreateClassEnumerator(clsidCategory, &pEm, 0);
    pCreateDevEnum->Release();
    if (hr != NOERROR)
	return hr;

    pEm->Reset(); // !!! needed?

    ULONG cFetched;
    IMoniker *pM;
    while(hr = pEm->Next(1, &pM, &cFetched), hr==S_OK)
    {
	if (lpwInstance) {
	    IPropertyBag *pBag;
	    hr = pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
	    if(SUCCEEDED(hr)) {
		VARIANT var;
		var.vt = VT_BSTR;
		hr = pBag->Read(L"FriendlyName", &var, NULL);
		pBag->Release();
		if (hr == NOERROR) {
		    if (lstrcmpiW(var.bstrVal, lpwInstance) != 0) {				   
			SysFreeString(var.bstrVal);
			pM->Release();
			continue;
		    }
		    SysFreeString(var.bstrVal);
		} else
		    continue;
	    }
	}

	hr = pM->BindToObject(0, 0, IID_IBaseFilter, (void**)ppf);
	pM->Release();
	break;
    }
    pEm->Release();

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\xmlgraph\xmlgraph.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
// {1BB05960-5FBF-11d2-A521-44DF07C10000}
DEFINE_GUID(IID_IXMLGraphBuilder, 
0x1bb05960, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);

interface IXMLGraphBuilder : IUnknown
{
    STDMETHOD(BuildFromXML) (IGraphBuilder *pGraph, IXMLElement *pxml) = 0;
    STDMETHOD(SaveToXML) (IGraphBuilder *pGraph, BSTR *pbstrxml) = 0;
    STDMETHOD(BuildFromXMLFile) (IGraphBuilder *pGraph, WCHAR *wszFileName, WCHAR *wszBaseURL) = 0;
};

// CLSID_XMLGraphBuilder
// {1BB05961-5FBF-11d2-A521-44DF07C10000}
DEFINE_GUID(CLSID_XMLGraphBuilder, 
0x1bb05961, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);

CUnknown *CreateXMLGraphInstance(LPUNKNOWN, HRESULT *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdaca.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"



///////////////////////////////////////////////////////////////////////////////
CBdaConditionalAccess::CBdaConditionalAccess (
    IUnknown *              pUnkOuter,
    CBdaControlNode *       pControlNode
    ) :
    CUnknown( NAME( "CBdaConditionalAccess"), pUnkOuter, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;

    ASSERT( pUnkOuter);

    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaConditionalAccess: No parent specified.\n")
              );

        return;
    }

    //  Initialize Members
    //
    m_pUnkOuter = pUnkOuter;
    m_pControlNode = pControlNode;
}

///////////////////////////////////////////////////////////////////////////////
CBdaConditionalAccess::~CBdaConditionalAccess ( )
///////////////////////////////////////////////////////////////////////////////
{
    m_pUnkOuter = NULL;
    m_pControlNode = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaConditionalAccess::put_TuneRequest (
    ITuneRequest *      pTuneRequest
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaConditionalAccess::put_Locator (
    ILocator *          pLocator
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaConditionalAccess::AddComponent (
    IComponent *        pComponent
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaConditionalAccess::RemoveComponent (
    IComponent *        pComponent
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaConditionalAccess::PutTableSection (
    PBDA_TABLE_SECTION  pBdaTableSection
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = NOERROR;

    DbgLog( ( LOG_TRACE,
              0,
              "CBdaConditionalAccess: Putting table section.\n")
          );

    if (m_pControlNode)
    {
        hrStatus = m_pControlNode->put_BdaNodeProperty(
                                KSPROPSETID_BdaTableSection,
                                KSPROPERTY_BDA_TABLE_SECTION,
                                (UCHAR *) pBdaTableSection,
                                sizeof( BDA_TABLE_SECTION) + pBdaTableSection->ulcbSectionLength + 3
                                );
    }
    else
    {
        hrStatus = E_NOINTERFACE;
    }

    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaConditionalAccess: Can't put table section (0x%08x).\n", hrStatus)
              );
    }

    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    sources.inc

Abstract:

    Common makefile for ActiveMovie filters.

Revision History:

    06-Nov-1996 DonRyan
        Created.
    25-Nov-1996 TomOR
        Modified for Ks stuff.
    10-Oct-1999 Jaybo
	Added FILTER_DLL; define this in your environment to create separate
	DLLs instead of one massive ksproxy.ax.  This turns off the definition
	of FILTER_LIB in various sources files.

!ENDIF

###############################################################################
#                                                                             #
#  Private Definitions                                                        #
#                                                                             #
###############################################################################

!ifdef FILTER_LIB
TARGETTYPE=LIBRARY
#TARGETPATH=$(PROJECT_LIB_PATH) DOESN'T WORK HERE!  YOU GET i386\i386 TWICE!!!
C_DEFINES=$(C_DEFINES) -DFILTER_LIB
!else
TARGETTYPE=DYNLINK
TARGETEXT=ax
C_DEFINES=$(C_DEFINES) -DFILTER_DLL
!endif

###############################################################################
#                                                                             #
#  Debug Support                                                              #
#                                                                             #
###############################################################################

!IF ("$(NTDEBUG)" != "") && ("$(NTDEBUG)" != "ntsdnodbg") && ("$(NTDEBUG)" != "retail")
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

###############################################################################
#                                                                             #
#  Profile Support                                                            #
#                                                                             #
###############################################################################

!IF "$(NTPROFILE)" == ""
STRM_PROFILE_FLAG=
STRM_PROFILE_LIB=
!ELSE
!    IF "$NTPROFILE)" == "cap"
STRM_PROFILE_FLAG=-Gp
STRM_PROFILE_LIB=$(SDK_LIB_PATH)\cap.lib
!    ELSE
!        IF "$(NTPROFILE)" == "wst"
STRM_PROFILE_FLAG=-Gp
STRM_PROFILE_LIB=$(SDK_LIB_PATH)\wst.lib
!        ELSE
!            error NTPROFILE macro can be either "", "cap", or "wst"
!        ENDIF
!    ENDIF
!ENDIF

###############################################################################
#                                                                             #
#  Global Definitions                                                         #
#                                                                             #
###############################################################################

DLLENTRY=DllEntryPoint
MSC_WARNING_LEVEL=/W3 /WX
NOT_LEAN_AND_MEAN=1
USE_CRTDLL=1
386_FLAGS=$(STRM_PROFILE_FLAG)

#Compatibility with Memphis
SUBSYSTEM_VERSION=4.00

###############################################################################
#                                                                             #
#  Includes                                                                   #
#                                                                             #
###############################################################################

INCLUDES=\
    $(SDK_PATH)\amovie\inc

###############################################################################
#                                                                             #
#  Link Libraries                                                             #
#                                                                             #
###############################################################################

!IFNDEF FILTER_LIB

STRMBASE_LIB=$(PROJECT_ROOT)\published\dxmdev\dshowdev\base\$(O)\strmbase.lib

LINKLIBS=\
    $(STRMBASE_LIB)

###############################################################################
#                                                                             #
#  Target Libraries                                                           #
#                                                                             #
###############################################################################

TARGETLIBS= $(TARGETLIBS) \
    $(SDK_LIB_PATH)\vfw32.lib    \
    $(SDK_LIB_PATH)\winmm.lib    \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\version.lib  \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\ole32.lib    \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\uuid.lib     \
    $(STRM_PROFILE_LIB)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\waveout.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
/*  Implements a digital audio renderer using waveOutXXX apis */
/*            David Maymudes          */
/*              January 1995            */

#define FLAG(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                   (((DWORD)(ch4) & 0xFF00) << 8) |    \
                   (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                   (((DWORD)(ch4) & 0xFF000000) >> 24))

//
// forward declaration of the main Filter class.  Used in everything else below
//

class CWaveOutFilter;

#include <callback.h>

#include <dsound.h>
#include <dshowaec.h>

// Get the definition for our pass through class
#include "passthru.h"

// Get the AM sound interface defintion
#include "amaudio.h"

// Get the basic sound device definition
#include "sounddev.h"

// Declare the BasicAudio control properties/methods
#include "basicaud.h"

#include "waveclk.h"
#include "slave.h"
//
// Make visible the pin structure for dynamic filter registration.  This is
// common to both waveout and direct sound renderers and is used when they
// pass a AMOVIESETUP_FILTER* to the waveoutFilter constructor.

extern const AMOVIESETUP_PIN waveOutOpPin;

// Static function for calculating a rate adjusted wave format block.
// Includes an exception handler for over/under/flow errors.
// Returns 0 for success.
//
DWORD SetwfxPCM(WAVEFORMATEX& wfxPCM, double dRate);

// *****
//
// We need this private declaration of IKsPropertySet (renamed to IDSPropertySet)
// because of the inconsistency between the declarations in KSPROXY.H and DSOUND.H
//
// *****
struct IDSPropertySet;

#undef INTERFACE
#define INTERFACE IDSPropertySet

DECLARE_INTERFACE_(IDSPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID, ULONG, PULONG) PURE;
};

// This is an allocator based on the abstract CBaseAllocator class
// that allocates sample buffers. We have our own allocator so we can have
// WaveHdr's associated with every sample - the sample's data pointer points
// to just after the wave hdr.
//
// We need to use the wave device to prepare and unprepare buffers. We don't
// open it or close it. It is valid from OnAcquire until we call
// OnReleaseComplete() in the filter. It will be NULL at other times.
//
// On Unprepare, we wait until all samples are released.
// On last release to the allocator of a sample, we
// complete the unprepare operation.
//
// Similarly with prepare, we may need to wait until all buffers are back.
// This should not be problematic as the filter itself will reject them in
// Receive() if there is no wave device, so they will not get queued.
//
// Whether on demand or on Decommit, once we have unprepared all headers we
// call back to the filter for it to complete the close and notify the
// resource manager.
//
// We thus need a pointer to the filter, but we cannot hold a refcount since
// that would be circular. We are guaranteed that the filter will call us
// before exiting.
//
// The exception to this is when the audio device is active.  We need to
// call the filter to close the device, but the filter can be destroyed
// before the allocator.  Hence once the last wave buffer has been released
// we must know that the filter is active, otherwise it will be unsafe to
// call OnReleaseComplete().  While the wave device is active we keep a
// refcount on the filter.

class CWaveAllocator : public CBaseAllocator
{
    // wave device handle
    HWAVE               m_hAudio;

    // if non-null, pointer to creating filter
    // this will normally NOT be a reference counted pointer (see comments
    // at top) except a reference count is kept while m_hAudio is valid
    CWaveOutFilter*     m_pAFilter;
#ifdef DEBUG
    int                 m_pAFilterLockCount;
#endif

    DWORD               m_nBlockAlign;     // From wave format

    BOOL                m_fBuffersLocked;
    DWORD_PTR           m_dwAdvise;

    WAVEHDR           **m_pHeaders;

    IReferenceClock*    m_pAllocRefClock;

    // override this to free the memory when we are inactive
    void Free(void);

    // override this to allocate and prepare memory when we become active
    HRESULT Alloc(void);

    // Prepare/Unprepare wave headers for each sample
    // Needs to be called from ReopenWaveDevice
    STDMETHODIMP LockBuffers(BOOL fLock = TRUE);

    // finished with the wave device on last release of buffer
    HRESULT OnDeviceRelease(void);

public:

    /* Constructors and destructors */

    CWaveAllocator(
        TCHAR *pName,
        LPWAVEFORMATEX lpwfx,
        IReferenceClock* pRefClock,
        CWaveOutFilter* pFilter,
        HRESULT *phr);
    ~CWaveAllocator();

    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES* pRequest,
        ALLOCATOR_PROPERTIES* pActual
    );

    // please unprepare all samples  - return S_OK if this can be done
    // straight away, or S_FALSE if needs to be done async. If async,
    // will call CWaveOutFilter::OnReleaseComplete() when done.
    HRESULT ReleaseResource(void);

    // filter is going away - set pointer to null
    // this is called when the waveout input pin is destroyed.
    // we do NOT want to kill our pointer to the filter as we need
    // it when we are being destroyed
    void ReleaseFilter(void)
    {
        m_pAFilter = NULL;
        ASSERT(NULL == m_hAudio);
        DbgLog((LOG_TRACE, 1, "waveoutFilter input pin died"));
    }

    // we have the wave device - prepare headers.
    // -- Note that if some samples are outstanding, this will fail.
    HRESULT OnAcquire(HWAVE hw);

};

// WaveOutInputPin


/* Class supporting the renderer input pin */

//
// This pin is still a separate object in case it wants to have a distinct
// IDispatch....
//
class CWaveOutInputPin :
    public CBaseInputPin,
    public IPinConnection
{
    typedef CBaseInputPin inherited;

    friend class CWaveOutFilter;
    friend class CWaveOutClock; 
    friend class CWaveAllocator;       // needs the input pin
    friend class CWaveSlave;
    friend class CDSoundDevice;

    DECLARE_IUNKNOWN;

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

private:

    CWaveOutFilter *m_pFilter;         // The renderer that owns us
    CAMEvent    m_evSilenceComplete;   // used to pause device for a "silence" period

    CWaveAllocator  * m_pOurAllocator;
    BOOL        m_fUsingOurAllocator;
    HRESULT     CreateAllocator(LPWAVEFORMATEX m_lpwfx);

    CWaveSlave      m_Slave;

    LONGLONG        m_llLastStreamTime;

    // This is the start time of the first received buffer after an audio break
    // (includes the one at the VERY beginning).  If the first received buffer is
    // not a sync'ed sample, this may be reset to zero.
    REFERENCE_TIME m_rtActualSegmentStartTime;

    // TRUE after returning S_FALSE in Receive, and until we are stopped
    // FALSE otherwise
    BOOL m_bSampleRejected;
    BOOL m_bPrerollDiscontinuity;   // remember discontinuity if we drop a pre-roll sample
    BOOL m_bReadOnly;               // we don't trim preroll if using read-only buffer
    BOOL m_bTrimmedLateAudio;       // set when we drop late audio when slaving, to avoid inserting silence


#ifdef PERF
    int m_idReceive;                   // MSR_id for time data received
    int m_idAudioBreak;
    int m_idDeviceStart;               // time to move the wave device to running
    int m_idWaveQueueLength;           // length of wave device queue
    STDMETHODIMP SampleReceive(IMediaSample *pSample);
#endif

    // incoming samples are not on our allocator, so copy the contents of this
    // sample to our sample.
    HRESULT CopyToOurSample(
                IMediaSample* pBuffer,
                BYTE* &pData,
                LONG &lData);

    DWORD       m_nAvgBytesPerSec;      // rate at which the device will consume our data

#ifdef DEBUG
    // we expect to see a rate change followed by a NewSegment call before
    // data restarts streaming
    BOOL        m_fExpectNewSegment;
#endif

    // statistics class for waveout renderer
    class CWaveOutStats
    {

    public:

        DWORD          m_dwDiscontinuities;
        REFERENCE_TIME m_rtLastBufferDur;

        void Reset() {
            m_dwDiscontinuities = 0;
            m_rtLastBufferDur = 0;
        }
    };

    friend class CWaveOutStats;

    CWaveOutStats m_Stats;

public:

    CWaveOutInputPin(
        CWaveOutFilter *pWaveOutFilter,
        HRESULT *phr);

    ~CWaveOutInputPin();

    // return the rate at which data is being consumed
    DWORD GetBytesPerSec()
    {
        return m_nAvgBytesPerSec;       // rate at which the device will consume our data
    }

    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator,BOOL bReadOnly);

    /* Lets us know where a connection ends */
    HRESULT BreakConnect();

        /* Let's us know when a connection is completed */
        HRESULT CompleteConnect(IPin *pPin);

    /* Check that we can support this output type */
    HRESULT CheckMediaType(const CMediaType *pmt);

    /* IMemInputPin virtual methods */

    /* Here's the next block of data from the stream.
       AddRef it if you are going to hold onto it. */
    STDMETHODIMP Receive(IMediaSample *pSample);

#ifdef LATER  // Need to fix toy.mpg first then this saves a thread
    /* We queue stuff up so we don't block */
    STDMETHODIMP ReceiveCanBlock()
    {
        return S_FALSE;
    }
#endif

    // no more data is coming
    STDMETHODIMP EndOfStream(void);

    // override so we can decommit and commit our own allocator
    HRESULT Active(void);
    HRESULT Inactive(void);

    // Override to handle quality messages
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q)
    {
        UNREFERENCED_PARAMETER(q);
        UNREFERENCED_PARAMETER(pSender);
        return E_NOTIMPL;             // We do NOT handle this
    }

    // flush our queued data
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);

    // NewSegment notifies of the start/stop/rate applying to the data
    // about to be received. Default implementation records data and
    // returns S_OK.  We potentially have to adjust our rate.
    // We may also have to reset our "callback advise"
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    //  Suggest a format
    //  We do this so that in situations where we are already in the graph
    //  the filter graph can determine what types we like so limiting
    //  searches that pull in lots of strange filters
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    REFERENCE_TIME GetFirstBufferStartTime(void);

    // Say when a buffer has been rejected - and hence if we need to
    // restart
    BOOL IsStreamTurnedOff()
    {
        return m_bSampleRejected;
    }

    // Check if the wave device needs restarting
    void CheckPaused();

    // RestartWave
    void RestartWave();

    // called to verify that a rate about to be set is actually valid.
    STDMETHODIMP SetRate(double dRate);

    //  IPinConnection stuff
    //  Do you accept this type chane in your current state?
    STDMETHODIMP DynamicQueryAccept(const AM_MEDIA_TYPE *pmt);

    //  Set event when EndOfStream receive - do NOT pass it on
    //  This condition is cancelled by a flush or Stop
    STDMETHODIMP NotifyEndOfStream(HANDLE hNotifyEvent);

    STDMETHODIMP DynamicDisconnect();

    //  Are you an 'end pin'
    STDMETHODIMP IsEndPin();

    void DestroyPreviousType(void);


    HRESULT RemovePreroll( IMediaSample * pSample ); // decides whether audio is preroll or very late when slaving
    HRESULT TrimBuffer( IMediaSample * pSample,      // trims this audio sample
                        REFERENCE_TIME rtTrimAmount, // amount to trim 
                        REFERENCE_TIME rtCutoff,     // new start time of the remaining data
                        BOOL bTrimFromFront = TRUE );// trim front front of buffer?


    HANDLE m_hEndOfStream;
    AM_MEDIA_TYPE *m_pmtPrevious;
};

//

/* This is the COM object that represents a simple rendering filter. It
   supports IBaseFilter and has a single input stream (pin).

   The wave renderer implements IResourceConsumer which it will pass
   to some of the IResourceManager interface methods.

*/

//
// We remember whether we have no clock set for the filter,
// our clock, or someone else's clock.
//

enum waveClockState {
    WAVE_NOCLOCK = -1,
    WAVE_OURCLOCK,
    WAVE_OTHERCLOCK
};

enum waveDeviceState {
    WD_UNOWNED = 1,
    WD_OPEN,
    WD_PAUSED,
    WD_PENDING,   // waiting for final release of all buffers
    WD_CLOSED,
    WD_RUNNING,
    WD_ERROR_ON_OPEN,
    WD_ERROR_ON_PAUSE,
    WD_ERROR_ON_RESTART,
    WD_ERROR_ON_RESTARTA,
    WD_ERROR_ON_RESTARTB,
    WD_ERROR_ON_RESTARTC,
    WD_ERROR_ON_RESTARTD,
    WD_ERROR_ON_RESTARTE,
    WD_ERROR_ON_RESTARTF
};

// Define the states for our EOS sent flag.  This normally only
// makes sense if m_bHaveEOS == TRUE.
// EOS_NOTSENT - no EOS has been sent
// EOS_PENDING - will be sent when the wave callback completes
// EOS_SENT    - EOS has been sent
// Note that EOS_PENDING and EOS_SENT BOTH evaluate to TRUE (non-zero)

enum eosSentState {
    EOS_NOTSENT = 0,
    EOS_PENDING,
    EOS_SENT
};

enum _AM_AUDREND_SLAVEMODE_FLAGS {

    AM_AUDREND_SLAVEMODE_LIVE_DATA       = 0x00000001, // slave to live samples
    AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS = 0x00000002, // slave to input buffer fullness
    AM_AUDREND_SLAVEMODE_GRAPH_CLOCK     = 0x00000004, // slave to graph clock
    AM_AUDREND_SLAVEMODE_STREAM_CLOCK    = 0x00000008, // slave to stream clock, which is
                                                       // necessarily the graph clock
    AM_AUDREND_SLAVEMODE_TIMESTAMPS      = 0x00000010  // slave to timestamps

};


class CWaveOutFilter
  : public CBaseFilter,
    public CCritSec,
    public IResourceConsumer,
    public ISpecifyPropertyPages,
#ifdef THROTTLE
    public IQualityControl,
#endif
    public IPersistPropertyBag,
    public IAMDirectSound,
    public CPersistStream,
    public IAMResourceControl,
    public IAMAudioRendererStats,
    public IAMAudioDeviceConfig,
    public IAMClockSlave
{

public:
    // Implements the IBaseFilter and IMediaFilter interfaces

    DECLARE_IUNKNOWN
#ifdef DEBUG
    STDMETHODIMP_(ULONG) NonDelegatingRelease()
    {
        return CBaseFilter::NonDelegatingRelease();
    }
    STDMETHODIMP_(ULONG) NonDelegatingAddRef()
    {
        return CBaseFilter::NonDelegatingAddRef();
    }
#endif

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // override GetState so that we can return an intermediate code
    // until we have at least one audio buffer in the queue
    STDMETHODIMP GetState(DWORD dwMSecs,FILTER_STATE *State);

    // --- IResourceConsumer methods ---

    // Overrides for base Filter class methods

    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);

    //
    // you may acquire the resource specified.
    // return values:
    //      S_OK    -- I have successfully acquired it
    //      S_FALSE -- I will acquire it and call NotifyAcquire afterwards
    //      VFW_S_NOT_NEEDED: I no longer need the resource
    //      FAILED(hr)-I tried to acquire it and failed.

    STDMETHODIMP AcquireResource(LONG idResource);

    // Please release the resource.
    // return values:
    //      S_OK    -- I have released it (and want it again when available)
    //      S_FALSE -- I will call NotifyRelease when I have released it
    //      other   something went wrong.
    STDMETHODIMP ReleaseResource(LONG idResource);

    STDMETHODIMP IsConnected(void)
    {
        return m_pInputPin->IsConnected();
    };

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();
    // STDMETHODIMP GetClassID(CLSID *pClsid);

public:

    CWaveOutFilter(
        LPUNKNOWN pUnk,
        HRESULT *phr,
        const AMOVIESETUP_FILTER* pSetupFilter, // contains filter class id
        CSoundDevice *pDevice);

    virtual ~CWaveOutFilter();

    /* Return the pins that we support */

    int GetPinCount() {return 1;};
    CBasePin *GetPin(int n);

    /* Override this to say what interfaces we support and where */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    // override JoinFilterGraph to obtain IResourceManager interface
    STDMETHODIMP JoinFilterGraph(IFilterGraph*, LPCWSTR);

#ifdef THROTTLE
    // Quality management stuff
    STDMETHODIMP SetSink(IQualityControl * piqc )
    {
        CAutoLock Lock(this);
        // This is a weak reference - no AddRef!
        if (piqc==NULL || IsEqualObject(piqc, m_pGraph)) {
            m_piqcSink = piqc;
            return NOERROR;
        } else {
            return E_NOTIMPL;
        }
    }

    // Override to implement a pure virtual
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q)
    {
        UNREFERENCED_PARAMETER(q);
        UNREFERENCED_PARAMETER(pSender);
        return E_NOTIMPL;             // We do NOT handle this
    }
#endif // THROTTLE

    //  Return a pointer to the format
    WAVEFORMATEX *WaveFormat() const
    {
        WAVEFORMATEX *pFormat = (WAVEFORMATEX *)m_pInputPin->m_mt.Format();
        return pFormat;
    };

private:
    // return the format tag of the current wave format block
    DWORD WaveFormatTag() {
        WAVEFORMATEX *pwfx = WaveFormat();

        if (!pwfx) return (0);

        return pwfx->wFormatTag;
    }

    // Pause helper for undo
    HRESULT DoPause();

public:

    // called by CWaveAllocator when it has finished with the device
    void OnReleaseComplete(void);

    // called by CWaveAllocator when it has completed a delayed OnAcquire
    HRESULT CompleteAcquire(HRESULT hr);

    // IPropertypage
    STDMETHODIMP GetPages(CAUUID * pPages);

#ifdef DSR_ENABLED
    // let the Direct Sound renderer share our callback thread
    CCallbackThread  * GetCallbackThreadObject()
    {
        return &m_callback;
    };
#endif // DSR_ENABLED

    // IPersistPropertyBag methods
    STDMETHOD(InitNew)(THIS);
    STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                   BOOL fSaveAllProperties);

    STDMETHODIMP GetClassID(CLSID *pClsid);

    // IAMAudioRendererStats
    STDMETHODIMP GetStatParam( DWORD dwParam, DWORD *pdwParam1, DWORD *pdwParam2 );

    // IAMClockSlave
    STDMETHODIMP SetErrorTolerance( DWORD   dwTolerance );
    STDMETHODIMP GetErrorTolerance( DWORD * pdwTolerace );

    BOOL        m_fUsingWaveHdr;

    // in order to synchronise end-of-stream with the codec,
    // we have a long that counts the number of queued buffers, which we
    // access with InterlockedIncrement.  It is initialised to 0,
    // incremented whenever a buffer is added, and then decremented whenever
    // a buffer is completed. End-of-stream decrements it, so if the decrement
    // decrements it to -1, the wave callback knows it is EOS.  The wave callback
    // will then re-increment it back to 0 so it can detect future end of
    // streams.
    LONG        m_lBuffers;

    // See if there are actually any buffers waiting to be processed
    // by the device
    bool AreThereBuffersOutstanding() {
        return 0 == m_lBuffers + (m_eSentEOS == EOS_PENDING ? 1 : 0) ?
            false : true;
    }

private:

    // The actual rendering device (Direct Sound or Waveout)
    CSoundDevice    *m_pSoundDevice ;       // the sound device.

    LONG        m_lHeaderSize;
    BOOL    m_fDSound;

    IAMAudioDuplexController * m_pAudioDuplexController;

    const AMOVIESETUP_FILTER* m_pSetupFilter;

    // attempt to acquire the wave device. Returns S_FALSE if it is busy.
    HRESULT AcquireWaveDevice(void);

    // open the wave device - assumes we have the resource manager's
    // go-ahead to acquire it.
    HRESULT OpenWaveDevice(void);

    // subroutine to talk to the actual device and open it
    HRESULT DoOpenWaveDevice(void);

    // See if the device will support this rate/format combination
    inline HRESULT CheckRate(double dRate);

#ifdef DYNAMIC_RATE_CHANGE
    // reopen the wave device.  called on a rate change
    HRESULT ReOpenWaveDevice(double dRate);
#endif
    // reopen the wave device.  called on format change
    HRESULT ReOpenWaveDevice(CMediaType* pNewFormat);

    // actually close the wave handle
    HRESULT CloseWaveDevice(void);

    // cache the rate at which the audio device is running. this is
    // set from CARPosPassThru whenever we open the wave device. the
    // input pin has its own m_dRate recording NewSegment()'s
    // call. this is necessary because we don't handle dynamic rate
    // changes in NewSegment
    double m_dRate;

    // End of stream helper
    void SendComplete(BOOL bRunning, BOOL bAbort = FALSE);

    HRESULT ScheduleComplete(BOOL bAbort = FALSE);

    // device control call wrappers, used for EC_ notifications and failure logging
    MMRESULT amsndOutOpen
    (
        LPHWAVEOUT phwo,
        LPWAVEFORMATEX pwfx,
        double dRate,
        DWORD *pnAvgBytesPerSec,
        DWORD_PTR dwCallBack,
        DWORD_PTR dwCallBackInstance,
        DWORD fdwOpen,
        BOOL bNotifyOnFailure = TRUE
    );
    MMRESULT amsndOutClose( BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutGetDevCaps( LPWAVEOUTCAPS pwoc, UINT cbwoc, BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutGetPosition( LPMMTIME pmmt, UINT cbmmt, BOOL bUseAbsolutePos, BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutPause( BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutPrepareHeader( LPWAVEHDR pwh, UINT cbwh, BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutUnprepareHeader( LPWAVEHDR pwh, UINT cbwh, BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutReset( BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutRestart( BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutWrite ( LPWAVEHDR pwh, UINT cbwh, REFERENCE_TIME const *pStart, BOOL bIsDiscontinuity, BOOL bNotifyOnFailure = TRUE );

#ifdef THROTTLE
    // send quality notification to m_piqcSink when we run short of buffers
    // n is the number of buffers left, nMax is the total number we have
    // m_nLastSent is the last notified quality level
    // m_nMaxAudioQueue is the longest we have seen the queue grow to
    HRESULT SendForHelp(int n);
    int m_nLastSent;
    int m_nMaxAudioQueue;
#endif // THROTTLE

    /* The nested classes may access our private state */

    friend class CWaveOutInputPin;
    friend class CWaveOutClock;
    friend class CBasicAudioControl;   // needs the wave device handle
    friend class CWaveAllocator;       // needs the input pin
    friend class CWaveSlave;

    /* Member variables */
    CWaveOutInputPin *m_pInputPin;         /* IPin and IMemInputPin interfaces */

    CWaveOutClock *m_pRefClock;     // our internal ref clock

    // remember whose clock we are using.  This will have one of three
    // values: WAVE_OURCLOCK, WAVE_NOCLOCK, WAVE_OTHERCLOCK
    DWORD       m_fFilterClock;         // applies to m_pClock in the base class

    // Note: if we are working with an external clock then the behaviour
    // of the filter alters.  If an incoming sample would not play in time
    // then it is dropped.   If an incoming sample shows a significant gap
    // between its start and the end of the previous sample written to the
    // device queue then we pause the device for that time period.
    //
    // Note: we could stuff silence into the queue at this point and will
    // probably do so in future IF the silence stuffing can be handled by
    // the audio device itself (by returning S_OK to amaudioOutSilence).

    // !!! this is a broken concept.  DSound allows per-handle volume setting
    // but waveOut usually does not.  If we have per-handle volume control, this is
    // a good idea, because we need to re-set-up the volume every time we re-open the
    // device, but for waveOut or midiOut it's just annoying to the user.
    bool        m_fVolumeSet;           // need to set the volume
    BOOL        m_fHasVolume;           // wave device can set the volume

    DWORD       m_debugflag;

    HWAVEOUT    m_hwo;                  // handle to the wave device
    DWORD       m_lastWaveError;
    waveDeviceState  m_wavestate;
    DWORD_PTR   m_dwAdviseCookie;       // cookie used by advisecallback

    DWORD       m_dwScheduleCookie;     // cookie for clock dispatching

    void        SetWaveDeviceState(waveDeviceState wDS)
    {
        m_wavestate = wDS;
        // when we are finished trying to track down bug 26045 the above
        // line should be bracketed by #ifdef DEBUG/#endif
    };

    // handles IMediaPosition by passing upstream.
    // our override class will ask us to justify any new playback rate
    CARPosPassThru * m_pImplPosition;

    // handle setting/retrieving audio properties
    CBasicAudioControl m_BasicAudioControl;

    // Handle callbacks from the wave device which will occur when the
    // devices completes a wave buffer.  We will RELEASE the buffer which
    // will then be picked up and refilled.
    static void WaveOutCallback(HDRVR hdrvr, UINT uMsg, DWORD_PTR dwUser,
                                        DWORD_PTR dw1, DWORD_PTR dw2);

    // Set up a routine that will handle callbacks from the clock.  It
    // would be good to not use a static routine, but then we get into a
    // mess trying to get the right THIS pointer.  It is simpler to get
    // the pointer passed back into the callback as a parameter.

    static void CALLBACK RestartWave(DWORD_PTR thispointer);

    // on an audio break we need to synchronise start of playing
    HRESULT SetUpRestartWave(LONGLONG rtStart, LONGLONG rtEnd);

    // Actually RestartWave
    void RestartWave();


    // Remember the time when the data in the wave device queue will
    // expire.  This value is reset by NextHdr().
    LONGLONG    m_llLastPos;

    CAMEvent    m_evPauseComplete; // set whenever transition to Pause is complete
    // note: the state of this event is only valid when m_State==State_Paused.
    // When we transition to Pause from Stopped we RESET the event.  The
    // event is SET on EOS or when data is written to the device queue.
    // GetState will be able to return VFW_S_STATE_INTERMEDIATE if we are
    // paused but do not have any data queued.

#ifdef PERF
    int m_idStartRunning;
    int m_idRestartWave;
    int m_idReleaseSample;
#endif

    // if there is an audio device, we register the resource strWaveName
    // and the id returned by the resource manager is stored here. We do
    // not unregister it (only the PnP removal could do that and it doesn't).
    LONG m_idResource;

    // hold a pointer to the filtergraph's resource manager interface,
    // if there is one. This is obtained in the JoinFilterGraph method.
    // Note that we don't hold a refcount on this (JoinFilterGraph(NULL) will
    // be called when we leave the filtergraph).
    IResourceManager* m_pResourceManager;

    // this interface is treated similarly to the IResourceManager, in that
    // we cache it in JoinFilterGraph, but don't hold a ref count on it
    IAMGraphStreams * m_pGraphStreams;

    DWORD       m_debugflag2;

    // TRUE if we have been told by the resource manager that we can have the
    // wave device.  FALSE if we can't have it, or have been told to give it
    // back.  We should only attempt to open the real wave device (and set
    // m_hwo) if this flag is TRUE.  However, this flag may be FALSE even
    // when m_hwo is set.  This condition indicates that we have been asked
    // to release the device, but have not yet completed the request.
    bool m_bHaveWaveDevice;

    // TRUE if we are currently running or paused and not in transition.
    // FALSE if stopped, or stopping. Can't use m_State because the
    // time that we need this (when calling NotifyRelease) is generally
    // during the shutdown process and the state changes too late.
    bool m_bActive;

    // Set TRUE in EndOfStream to say that EOS has been received
    // Set FALSE on filter creation and when moving to STOP, or connection broken
    bool m_bHaveEOS;            // EOS has been delivered

    // Send EOS OK - synced with m_csComplete
    bool m_bSendEOSOK;

    // TRUE if we have already sent EC_COMPLETE this activation (perhaps
    // because we have no device or lost the device). Will be reset on
    // a transition out of Run state.
    // This is a three-state flag as if we have data queued we send EOS
    // when the last buffer completes playing and is returned in the callback.
    // See eosSentState above for description.
    eosSentState m_eSentEOS;            // EOS has been (or is guaranteed to be) sent

#ifdef THROTTLE
    // NULL unless we have had SetSink called.
    // Non-null means send IQualityControl::Notify messages here
    IQualityControl * m_piqcSink;
#endif // THROTTLE


    // this object calls us back at a specified time - used for
    // EndOfStream processing when we don't have a wave device
    // and also for Direct Sound polling
    CCallbackThread m_callback;

    // this is the EOS function that it will callback to
    // the param is the this pointer. It will deliver EOS
    // to the input pin
    static void EOSAdvise(DWORD_PTR dw);

    // queue an EOS for when the end of the current segment should appear
    HRESULT QueueEOS();

    // callback advise token for EOS callback
    DWORD_PTR  m_dwEOSToken;

    // advise set for this stop time
    REFERENCE_TIME m_tEOSStop;

    // cancel the EOS callback if there is one outstanding
    HRESULT CancelEOSCallback();

    // IAMDirectSound stuff
    STDMETHODIMP GetDirectSoundInterface(LPDIRECTSOUND *lplpds);
    STDMETHODIMP GetPrimaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb);
    STDMETHODIMP GetSecondaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb);
    STDMETHODIMP ReleaseDirectSoundInterface(LPDIRECTSOUND lpds);
    STDMETHODIMP ReleasePrimaryBufferInterface(LPDIRECTSOUNDBUFFER lpdsb);
    STDMETHODIMP ReleaseSecondaryBufferInterface(LPDIRECTSOUNDBUFFER lpdsb);
    STDMETHODIMP SetFocusWindow (HWND hwnd, BOOL bMixingOnOrOff) ;
    STDMETHODIMP GetFocusWindow (HWND *phwnd, BOOL *pbMixingOnOrOff) ;

#if 0
    // how many references has an app made to each of the above?
    int m_cDirectSoundRef, m_cPrimaryBufferRef, m_cSecondaryBufferRef;
#endif

    // We need to support IDirectSound3DListener and IDirectSound3DBuffer.
    // They have methods with the same name, so we need to nest and create
    // a separate object to support each one

    class CDS3D : public CUnknown, public IDirectSound3DListener
    {
        CWaveOutFilter * m_pWaveOut;

    public:
        // constructor
        //
        CDS3D (CWaveOutFilter * pWaveOut, HRESULT *phr) :
         CUnknown(NAME("DirectSound3DListener"), pWaveOut->GetOwner(), phr),
         m_pWaveOut(pWaveOut) { };

        DECLARE_IUNKNOWN

        // IDirectSound3DListener stuff
        STDMETHODIMP GetAllParameters(LPDS3DLISTENER);
        STDMETHODIMP GetDistanceFactor(LPD3DVALUE);
        STDMETHODIMP GetDopplerFactor(LPD3DVALUE);
        STDMETHODIMP GetOrientation(LPD3DVECTOR, LPD3DVECTOR);
        STDMETHODIMP GetPosition(LPD3DVECTOR);
        STDMETHODIMP GetRolloffFactor(LPD3DVALUE );
        STDMETHODIMP GetVelocity(LPD3DVECTOR);
        STDMETHODIMP SetAllParameters(LPCDS3DLISTENER, DWORD);
        STDMETHODIMP SetDistanceFactor(D3DVALUE, DWORD);
        STDMETHODIMP SetDopplerFactor(D3DVALUE, DWORD);
        STDMETHODIMP SetOrientation(D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
        STDMETHODIMP SetPosition(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
        STDMETHODIMP SetRolloffFactor(D3DVALUE, DWORD);
        STDMETHODIMP SetVelocity(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
        STDMETHODIMP CommitDeferredSettings();
    };

    class CDS3DB : public CUnknown, public IDirectSound3DBuffer
    {
        CWaveOutFilter * m_pWaveOut;

    public:
        // constructor
        //
        CDS3DB (CWaveOutFilter * pWaveOut, HRESULT *phr) :
         CUnknown(NAME("DirectSound3DBuffer"), pWaveOut->GetOwner(), phr),
         m_pWaveOut(pWaveOut) { };

        DECLARE_IUNKNOWN

        // IDirectSound3DBuffer stuff
        STDMETHODIMP GetAllParameters(LPDS3DBUFFER);
        STDMETHODIMP GetConeAngles(LPDWORD, LPDWORD);
        STDMETHODIMP GetConeOrientation(LPD3DVECTOR);
        STDMETHODIMP GetConeOutsideVolume(LPLONG);
        STDMETHODIMP GetMaxDistance(LPD3DVALUE);
        STDMETHODIMP GetMinDistance(LPD3DVALUE);
        STDMETHODIMP GetMode(LPDWORD);
        STDMETHODIMP GetPosition(LPD3DVECTOR);
        STDMETHODIMP GetVelocity(LPD3DVECTOR);
        STDMETHODIMP SetAllParameters(LPCDS3DBUFFER, DWORD);
        STDMETHODIMP SetConeAngles(DWORD, DWORD, DWORD);
        STDMETHODIMP SetConeOrientation(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
        STDMETHODIMP SetConeOutsideVolume(LONG, DWORD);
        STDMETHODIMP SetMaxDistance(D3DVALUE, DWORD);
        STDMETHODIMP SetMinDistance(D3DVALUE, DWORD);
        STDMETHODIMP SetMode(DWORD, DWORD);
        STDMETHODIMP SetPosition(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
        STDMETHODIMP SetVelocity(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    };

    friend class CDS3D;
    friend class CDS3DB;
    friend class CDSoundDevice;

    CDS3D m_DS3D;
    CDS3DB m_DS3DB;

    // Have they QI'd for the 3D stuff?  Do they want to use it?
    // We have to make special buffers for 3D to work... but those special
    // buffers can only play in MONO!  So we really need to know if the app
    // wants 3D effects or not.  We'll decide that if they QI for it, they
    // will use it
    BOOL m_fWant3D;

    // IAMResourceControl
    STDMETHODIMP Reserve(
        /*[in]*/ DWORD dwFlags,          //  From _AMRESCTL_RESERVEFLAGS enum
        /*[in]*/ PVOID pvReserved        //  Must be NULL
    );
    DWORD m_dwLockCount;

    // IAMAudioDeviceConfig methods
    STDMETHODIMP SetDeviceID(
        IN  REFGUID pDSoundGUID,
        IN  UINT    uiWaveID
        );

    STDMETHODIMP SetDuplexController(
        IN  IAMAudioDuplexController * pAudioDuplexController
        );

    //  Control sending EC_COMPLETE over pause and run
    CCritSec    m_csComplete;

};


inline REFERENCE_TIME CWaveOutInputPin::GetFirstBufferStartTime()
{
    return m_rtActualSegmentStartTime;
}


// const int            HEADER_SIZE = (max(sizeof(WAVEHDR), sizeof(MIDIHDR)));
// !!! the above line should be right, but didn't compile correctly, who knows why.

template<class T> CUnknown* CreateRendererInstance(LPUNKNOWN pUnk, const AMOVIESETUP_FILTER* pamsf, HRESULT *phr)
{
    CSoundDevice *pDev = new T;
    if (pDev == NULL)
    {
        *phr = E_OUTOFMEMORY;
        return NULL;
    }

    CUnknown* pAudioRenderer = new CWaveOutFilter(pUnk, phr, pamsf, pDev);
    if (pAudioRenderer == NULL)
    {
        delete pDev;
        *phr = E_OUTOFMEMORY;
        return NULL;
    }

    return pAudioRenderer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\xmlgraph\xmlgraph.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.


// Simple filter to build graphs from XML descriptions
//


// Tags supported now:
//
// <graph>			General enclosure
//
// <filter>
//	id="name"		(optional) name to use for filter
//	clsid="{...}"		specific filter to insert
//	category="{...}"	category to get a filter from
//
//				one of clsid, category must be specified
//	instance="friendly name"
//				Note: we need a way to specify a non-default
//					member of a particular category
//				Note: filters/categories currently require full
//					CLSIDs, we could use the friendly name
//
// <connect>
//	src="name1"		first filter to connect
//	srcpin="pin_name1"	(optional) pin to connect,
//				otherwise use first avail output pin
//	dest="name2"
//	destpin="pin_name2"
//
// <render>
//	id="name"		filter to render
//	pin1="pin_name"		pin to render
//
// <filesource>
//	id="name"		(optional) name to use for source filter
//	url="url"		Source filename/URL to load
//
// <param>			subtag of <filter>, allows setting properties
//	name="propname"
//	value="propval"		optional, if not supplied then contents of
//				the <param> tag are used as value
//
//				Possibly special case some parameters if
//				IPersistPropertyBag not implemented:
//				src="" could use IFileSourceFilter/IFileSinkFilter,
//				for instance
//
// <subgraph>
//
// <block>
//
// <videocompress>		Use various Dexter filters to compress video
//				appropriately.
//	in=  inpin=		starting filter & pin
//	out=  outpin=		ending filter & pin
//
//	width="x"
//	size="y"
//	codec="fourcc"?		or use CLSID here?
//				!!! current implementation is friendly name from category
//
//	datarate="n"		in bytes/sec, bits/sec, or K/sec?
//				!!! current implementation is k/sec
//	keyframespacing="n"
//	frametime=n"		in frames/sec, milliseconds, ?
//				!!! not implemented
//
// <audiocompress>		just like videocompress
//	in=  inpin=		starting filter & pin
//	out=  outpin=		ending filter & pin
//
// note: videocompress/audiocompress can take the <param> subtag.  Parameters
// are applied to the codec, not the supporting filters (if any).
//
//
// <defproc>			"define" a named processing sequence?
//	proc="rule"		name to be used in <call> tag
//	<filter id="f1"....>
//	<connect....>
//
// <invoke>			"call" a named processing sequence?
//	id="newname"
//	proc="rulename"
//                              Note: when the filters eventually get added,
//                              the name used for them in the graph is
//                              "newname.filtername", that is, it's the name
//                              used when the procedure is called, then a period,
//                              then the name of the filter as used inside the
//                              defproc call.
//
//
// Ideas for more tags:
//
// <filewriter>			Does this add just the file writing filter,
//				or mux + filewriter?
//				ask Danny/Syon why no extension->mux mapping
//
// <tee>			Does this just save knowing the Tee filter's
//				CLSID, or does it actually add something?
//
// <compress>			Since the actual output media type is important
//
//
// <resize>			More shorthand?  Part of <compress>?
//	width="x"
//	height="y"
//
// <seq>			Lets you leave out some <connect> tags, potentially
//
// <apply-effect>		More shorthand, probably not needed
//
// <mediatype>			Possible subtag of <connect> to allow explictly
//				specified media type?
//
//
// <timeline>                   Link to dexter, load using IPersistXML
//
// <clock>                      set clock to given filter.... necessary?
//      src="filter"
//
//
// <connect>
//      allpins="1"             want some way to say "connect all pins on src to the dst"
//                              useful for transcoding, where you're making multiple connections
//                              between a demux and a mux.
//

// Issues:
//
// if there's a <connect> inside a <defproc>, we may not be able to
// establish the connection when the procedure is called, because we may need to
// make the first input pin connection first.
//
// Need to add support for base path
//
// Better error reporting?  Use IXMLError?
//
//
// How can this work with SeanMcD's "graph segments"?  Should a tag map to a
// segment?
//

#include <streams.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "xmlgraph.h"
#include <atlbase.h>
#include <atlconv.h>

#include <msxml.h>

#include "qxmlhelp.h"
#include <qedit.h>
#include <qeditint.h>


//////////////////////////////////////////////////////////////////////////////
LPSTR HandleRelativePath(LPSTR lpRelative, LPSTR lpBase, LPSTR lpWork)
{
    //
    // If the given URL is not relative, get out immediately
    //
    if ((NULL == lpBase) ||
	(NULL != strstr( lpRelative, "\\\\")) ||     //  UNC path
        (NULL != strstr( lpRelative, ":")))       //  anything with a colon
    {
        //ATLTRACE((_T("CNPC::PreProcessURL: '%S' is not a relative URL\n"), *pbstrUrl ));

        return lpRelative;
    }

    int cchBase = 0;

    if (*lpRelative == '\\' || *lpRelative == '/') {
	// semi-relative path, start at drive root.

	LPSTR lpOut = lpWork;
	if (lpBase[0] && lpBase[1] != ':') {
	    // if there's a colon, copy everything up to it.
	    char *pchColon = strchr( lpBase, ':' );
	    if (pchColon) {
		int cch = (int) (pchColon - lpBase) + 1;
		lstrcpynA(lpWork, lpBase, cch + 1);
		lpOut += cch;
		lpBase += cch;
	    }

	    // copy whatever slashes are present
	    while (lpBase[0] == '/') {
		*lpOut++ = *lpBase++;
	    }
	}
	
	if (lpBase[0] == '\\' && lpBase[1] == '\\') {
	    // UNC path, drive root is location of fourth slash
	    // i.e. \\server\share\

	    char *pchSlash = strchr( lpBase, '\\');
	    if (!pchSlash)
		return lpRelative;

	    pchSlash = strchr( lpBase, '\\');

	    if (pchSlash) {
		cchBase = (int) (pchSlash - lpBase) + 1;
	    } else {
		cchBase = lstrlenA(lpBase);
	    }
	
	    lstrcpynA( lpOut, lpBase, cchBase + 1 );
	} else {
	    // non-unc path, root is first slash or backslash.

	    char *pchForward = strchr( lpBase, '/' );
	    char *pchBack = strchr( lpBase, '\\' );

	    if (!pchForward && !pchBack) {
		char *pchColon = strchr( lpBase, ':' );
		if (pchColon) {
		    // path is like c:\something, take the c: part
		    cchBase = (int) (pchColon - lpBase) + 1;
		} else {
		    // assume the whole thing was a server name
		    cchBase = lstrlenA(lpBase);
		}
	    } else if (!pchForward) {
		// take up to, but not including, the slash
		cchBase = (int)(pchBack - lpBase);
	    }
	    else {
		// take up to, but not including, the slash
		pchBack = max(pchForward, pchBack);
		cchBase = (int)(pchBack - lpBase);
	    }
		
	    if (cchBase)
		lstrcpynA( lpOut, lpBase, cchBase + 1 );
	}
    } else {
	//
	// Pull a base URL from our current FileName
	//
	char *pchForward = strrchr( lpBase, '/' );
	char *pchBack = strrchr( lpBase, '\\' );

	if( ( NULL == pchForward ) && ( NULL == pchBack ) )
	{
		//ATLTRACE((_T("CNPC::PreProcessURL: no base URL in '%S'!\n"), m_bstrFileName ));
	}
	else if( NULL == pchForward )
	{
	    cchBase = (int) (pchBack - lpBase) + 1;
	    lstrcpynA( lpWork, lpBase, cchBase + 1 );
	}
	else
	{
	    pchForward = max( pchBack, pchForward );

	    cchBase = (int)(pchForward - lpBase) + 1;
	    lstrcpynA( lpWork, lpBase, cchBase + 1 );
	}
    }

    //
    // If we have no base URL, don't launch this relative URL.  WRONG!  We need to launch
    // this to maintain backwards compatibility with v1 and v2 beta 1.
    //
    if( 0 == cchBase )
    {
	//DbgLog(( LOG_TRACE, 4, "CNPC::PreProcessURL: launching URL '%S' untouched\n", *pbstrUrl ));
	return lpRelative;
    }


    //
    // Concatenate the base URL and relative URL
    //
    lstrcatA( lpWork, lpRelative );

    //
    // Point all separators the same way (first come, first served)
    //
    char *pchForward = strchr( lpWork, '/' );
    char *pchBack = strchr( lpWork, '\\' );

    if( ( NULL != pchForward ) && ( pchForward < pchBack ) )
    {
        for( pchForward = lpWork; *pchForward; pchForward++ )
        {
            if( '\\' == *pchForward )
            {
                *pchForward = '/';
            }
        }
    }
    else if( NULL != pchBack )
    {
        for( pchBack = lpWork; *pchBack; pchBack++ )
        {
            if( '/' == *pchBack )
            {
                *pchBack = '\\';
            }
        }
    }

    return lpWork;
}


//
// CEnumSomePins
//
// wrapper for IEnumPins
// Can enumerate all pins, or just one direction (input or output)
class CEnumSomePins {

public:

    enum DirType {PINDIR_INPUT, PINDIR_OUTPUT, All};

    CEnumSomePins(IBaseFilter *pFilter, DirType Type = All, bool fAllowConnected = false);
    ~CEnumSomePins();

    // the returned interface is addref'd
    IPin * operator() (void);

private:

    PIN_DIRECTION m_EnumDir;
    DirType       m_Type;
    bool	  m_fAllowConnected;

    IEnumPins	 *m_pEnum;
};




// *
// * CEnumSomePins
// *

// Enumerates a filter's pins.

//
// Constructor
//
// Set the type of pins to provide - PINDIR_INPUT, PINDIR_OUTPUT or all
CEnumSomePins::CEnumSomePins(
    IBaseFilter *pFilter,
    DirType Type,
    bool fAllowConnected
)
    : m_Type(Type), m_fAllowConnected(fAllowConnected)
{

    if (m_Type == PINDIR_INPUT) {

        m_EnumDir = ::PINDIR_INPUT;
    }
    else if (m_Type == PINDIR_OUTPUT) {

        m_EnumDir = ::PINDIR_OUTPUT;
    }

    ASSERT(pFilter);

    HRESULT hr = pFilter->EnumPins(&m_pEnum);
    if (FAILED(hr)) {
        // we just fail to return any pins now.
        DbgLog((LOG_ERROR, 0, TEXT("EnumPins constructor failed")));
        ASSERT(m_pEnum == 0);
    }
}


//
// CPinEnum::Destructor
//
CEnumSomePins::~CEnumSomePins(void) {

    if(m_pEnum) {
        m_pEnum->Release();
    }
}


//
// operator()
//
// return the next pin, of the requested type. return NULL if no more pins.
// NB it is addref'd
IPin *CEnumSomePins::operator() (void) {


    if(m_pEnum)
    {
        ULONG	ulActual;
        IPin	*aPin[1];

        for (;;) {

            HRESULT hr = m_pEnum->Next(1, aPin, &ulActual);
            if (SUCCEEDED(hr) && (ulActual == 0) ) {	// no more filters
                return NULL;
            }
            else if (hr == VFW_E_ENUM_OUT_OF_SYNC)
            {
                m_pEnum->Reset();

                continue;
            }
            else if (ulActual==0)
                return NULL;

            else if (FAILED(hr) || (ulActual != 1) ) {	// some unexpected problem occured
                ASSERT(!"Pin enumerator broken - Continuation is possible");
                return NULL;
            }

            // if m_Type == All return the first pin we find
            // otherwise return the first of the correct sense

            PIN_DIRECTION pd;
            if (m_Type != All) {

                hr = aPin[0]->QueryDirection(&pd);

                if (FAILED(hr)) {
                    aPin[0]->Release();
                    ASSERT(!"Query pin broken - continuation is possible");
                    return NULL;
                }
            }

            if (m_Type == All || pd == m_EnumDir) {	// its the direction we want
		if (!m_fAllowConnected) {
		    IPin *ppin = NULL;
		    hr = aPin[0]->ConnectedTo(&ppin);

		    if (SUCCEEDED(hr)) {
			// it's connected, and we don't want a connected one,
			// so release both and try again
			ppin->Release();
			aPin[0]->Release();
			continue;
		    }
		}
                return aPin[0];
            }
	    else {		// it's not the dir we want, so release & try again
                aPin[0]->Release();
            }
        }
    }
    else                        // m_pEnum == 0
    {
        return 0;
    }
}



HRESULT FindThePin(IXMLElement *p, WCHAR *pinTag,
		IBaseFilter *pFilter, IPin **ppPin,
		PIN_DIRECTION pindir, WCHAR *szFilterName)
{
    HRESULT hr = S_OK;

    BSTR bstrPin = NULL;
    if (pinTag) bstrPin = FindAttribute(p, pinTag);

    if (bstrPin) {
	hr = (pFilter)->FindPin(bstrPin, ppPin);

	if (FAILED(hr)) {
#ifdef DEBUG
	    BSTR bstrName;
            hr = p->get_tagName(&bstrName);
            if (SUCCEEDED(hr)) {
                DbgLog((LOG_ERROR, 0,
                        TEXT("%ls couldn't find pin='%ls' on filter '%ls'"),
                        bstrName, bstrPin, szFilterName));
                SysFreeString(bstrName);
            }
#endif
	    hr = VFW_E_INVALID_FILE_FORMAT;
	}
	SysFreeString(bstrPin);	
    } else {
	CEnumSomePins Next(pFilter, (CEnumSomePins::DirType) pindir);

	*ppPin = Next();

	if (!*ppPin) {
#ifdef DEBUG
	    BSTR bstrName;
	    hr = p->get_tagName(&bstrName);
            if (SUCCEEDED(hr)) {
                DbgLog((LOG_ERROR, 0,
                        TEXT("%ls couldn't find an output pin on id='%ls'"),
                        bstrName, szFilterName));
                SysFreeString(bstrName);
            }
#endif
	    hr = VFW_E_INVALID_FILE_FORMAT;
	}
    }

    return hr;
}

class CXMLGraph : public CBaseFilter, public IFileSourceFilter, public IXMLGraphBuilder {
    public:
	CXMLGraph(LPUNKNOWN punk, HRESULT *phr);
	~CXMLGraph();
	
	int GetPinCount() { return 0; }

	CBasePin * GetPin(int n) { return NULL; }

	DECLARE_IUNKNOWN

	// override this to say what interfaces we support where
	STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

	// -- IFileSourceFilter methods ---

	STDMETHODIMP Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE *mt);
	STDMETHODIMP GetCurFile(LPOLESTR * ppszFileName, AM_MEDIA_TYPE *mt);

	// IXMLGraphBuilder methods
	STDMETHODIMP BuildFromXML(IGraphBuilder *pGraph, IXMLElement *pxml);
        STDMETHODIMP SaveToXML(IGraphBuilder *pGraph, BSTR *pbstrxml);
	STDMETHODIMP BuildFromXMLFile(IGraphBuilder *pGraph, WCHAR *wszXMLFile, WCHAR *wszBaseURL);

    private:
	HRESULT BuildFromXMLDocInternal(IXMLDocument *pxml);
	HRESULT BuildFromXMLInternal(IXMLElement *pxml);
	HRESULT BuildFromXMLFileInternal(WCHAR *wszXMLFile);

	HRESULT BuildChildren(IXMLElement *pxml);
	HRESULT ReleaseNameTable();
	HRESULT BuildOneElement(IXMLElement *p);

	HRESULT HandleCompressTag(IXMLElement *p, BOOL fVideo);
	
	HRESULT FindFilterAndPin(IXMLElement *p, WCHAR *filTag, WCHAR *pinTag,
				 IBaseFilter **ppFilter, IPin **ppPin,
				 PIN_DIRECTION pindir);

	HRESULT FindNamedFilterAndPin(IXMLElement *p, WCHAR *wszFilterName, WCHAR *pinTag,
				      IBaseFilter **ppFilter, IPin **ppPin,
				      PIN_DIRECTION pindir);

	HRESULT AddFilter(IBaseFilter *pFilter, WCHAR *wszFilterName);
	
	CGenericList<WCHAR> m_listRuleNames;
	CGenericList<IXMLElement> m_listRuleElements;

	WCHAR *m_pwszBaseURL;

	WCHAR m_wszNamePrefix[256];

	WCHAR *m_pFileName;

	CCritSec m_csLock;

	IGraphBuilder *m_pGB;
};

CXMLGraph::CXMLGraph(LPUNKNOWN punk, HRESULT *phr) :
		       CBaseFilter(NAME("XML Graph Builder"), punk, &m_csLock, CLSID_XMLGraphBuilder),
		       m_listRuleNames(NAME("rule names")),
		       m_listRuleElements(NAME("rule elements")),
		       m_pGB(NULL),
                       m_pFileName(NULL)
{
    m_wszNamePrefix[0] = L'\0';
}

CXMLGraph::~CXMLGraph()
{
    delete[] m_pFileName;
}

STDMETHODIMP
CXMLGraph::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IFileSourceFilter) {
	return GetInterface((IFileSourceFilter*) this, ppv);
    } else if (riid == IID_IXMLGraphBuilder) {
	return GetInterface((IXMLGraphBuilder*) this, ppv);
    } else {
	return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

HRESULT
CXMLGraph::Load(LPCOLESTR lpwszFileName, const AM_MEDIA_TYPE *pmt)
{
    CheckPointer(lpwszFileName, E_POINTER);

    m_pFileName = new WCHAR[lstrlenW(lpwszFileName) + 1];
    if (m_pFileName!=NULL) {
	lstrcpyW(m_pFileName, lpwszFileName);
    } else
	return E_OUTOFMEMORY;

    HRESULT hr = S_OK;

    if (m_pGraph) {
	hr = m_pGraph->QueryInterface(IID_IGraphBuilder, (void **) &m_pGB);
	if (FAILED(hr))
	    return hr;

	hr = BuildFromXMLFileInternal((WCHAR *) lpwszFileName);

	ReleaseNameTable();
    } else {
	// m_fLoadLater = TRUE;
    }

    return hr;
}

// Modelled on IPersistFile::Load
// Caller needs to CoTaskMemFree or equivalent.

STDMETHODIMP
CXMLGraph::GetCurFile(
    LPOLESTR * ppszFileName,
    AM_MEDIA_TYPE *pmt)
{
    return E_NOTIMPL;
}


HRESULT CXMLGraph::AddFilter(IBaseFilter *pFilter, WCHAR *pwszName)
{
    HRESULT hr;

    if (m_wszNamePrefix) {
	WCHAR wszName[256];

	lstrcpyW(wszName, m_wszNamePrefix);
	if (pwszName)
	    lstrcpyW(wszName + lstrlenW(wszName), pwszName);

	return m_pGB->AddFilter(pFilter, wszName);
    } else {
	return m_pGB->AddFilter(pFilter, pwszName);
    }
}

HRESULT CXMLGraph::FindFilterAndPin(IXMLElement *p, WCHAR *filTag, WCHAR *pinTag,
				  IBaseFilter **ppFilter, IPin **ppPin,
				  PIN_DIRECTION pindir)
{
    BSTR bstrFilter = FindAttribute(p, filTag);

    if (!bstrFilter) {
#ifdef DEBUG
	BSTR bstrName;
	p->get_tagName(&bstrName);
	DbgLog((LOG_ERROR, 0, TEXT("%ls needs filter id to be specified"),
		 bstrName));
	SysFreeString(bstrName);
#endif
	return VFW_E_INVALID_FILE_FORMAT;
    }

    HRESULT hr = E_FAIL;

    // if we're in a namespace, first look at things in the local namespace.  Then go
    // global.
    // !!! is one namespace enough, or do we need to search backwards?
    if (m_wszNamePrefix[0]) {
	WCHAR wszCompleteName[1024];

	lstrcpyW(wszCompleteName, m_wszNamePrefix);
	lstrcpyW(wszCompleteName + lstrlenW(wszCompleteName), bstrFilter);

	hr = FindNamedFilterAndPin(p, wszCompleteName, pinTag, ppFilter, ppPin, pindir);
    }

    if (FAILED(hr)) {
	hr = FindNamedFilterAndPin(p, bstrFilter, pinTag, ppFilter, ppPin, pindir);
    }

    SysFreeString(bstrFilter);

    return hr;
}

HRESULT CXMLGraph::FindNamedFilterAndPin(IXMLElement *p, WCHAR *wszFilterName, WCHAR *pinTag,
					 IBaseFilter **ppFilter, IPin **ppPin,
					 PIN_DIRECTION pindir)
{
    HRESULT hr = m_pGB->FindFilterByName(wszFilterName, ppFilter);

    if (FAILED(hr)) {
	// search through graph for a filter starting with the same name....

	IEnumFilters *pFilters;

	if (SUCCEEDED(m_pGB->EnumFilters(&pFilters))) {
	    IBaseFilter *pFilter;
	    ULONG	n;
	    while (pFilters->Next(1, &pFilter, &n) == S_OK) {
		FILTER_INFO	info;

		if (SUCCEEDED(pFilter->QueryFilterInfo(&info))) {
		    QueryFilterInfoReleaseGraph(info);

		    bool bMatch = true;

		    // see if wszFilterName is a prefix of info.achName
		    WCHAR *p1 = wszFilterName;
		    WCHAR *p2 = info.achName;

		    while (*p1) {
			if (*p1++ != *p2++) {
			    bMatch = false;
			    break;
			}
		    }

		    // check for == '.' makes sure that info.achName has to look like name1.name2
		    // if wszFilterName is name1, rather than something like achName = name12
		    if (bMatch && *p2 == L'.') {
			hr = FindThePin(p, pinTag, *ppFilter, ppPin, pindir, wszFilterName);

			if (SUCCEEDED(hr))
			    return hr;

			// else keep going, try another possible filter
		    }
		}

		pFilter->Release();
	    }

	    pFilters->Release();
	}
    }

    if (FAILED(hr)) {
#ifdef DEBUG
	BSTR bstrName;
	p->get_tagName(&bstrName);
	DbgLog((LOG_ERROR, 0, TEXT("%hs couldn't find id='%ls'"),
		  bstrName, wszFilterName));
	SysFreeString(bstrName);
#endif
	return VFW_E_INVALID_FILE_FORMAT;
    }

    hr = FindThePin(p, pinTag, *ppFilter, ppPin, pindir, wszFilterName);

    return hr;
}


HRESULT CXMLGraph::HandleCompressTag(IXMLElement *p, BOOL fVideo)
{
    IBaseFilter *pf1 = NULL, *pf2 = NULL;
    IPin *ppin1 = NULL, *ppin2 = NULL;

    HRESULT hr = FindFilterAndPin(p, L"src", L"srcpin", &pf1, &ppin1, PINDIR_OUTPUT);
    if (SUCCEEDED(hr)) {
	hr = FindFilterAndPin(p, L"dest", L"destpin", &pf2, &ppin2, PINDIR_INPUT);
    }

    IBaseFilter *pfCodec = NULL;

    if (SUCCEEDED(hr)) {
	BSTR bstrCodec = FindAttribute(p, L"codec");
	BSTR bstrID = FindAttribute(p, L"id");

	if (!bstrCodec) {
	    DbgLog((LOG_ERROR, 0, TEXT("VideoCompress with no CODEC tag")));

	    hr = VFW_E_INVALID_FILE_FORMAT;
	} else {
	    hr = GetFilterFromCategory(fVideo ? CLSID_VideoCompressorCategory :
						   CLSID_AudioCompressorCategory,
				       bstrCodec, &pfCodec);

	    if (SUCCEEDED(hr)) {
		hr = AddFilter(pfCodec, bstrID ? bstrID : bstrCodec);

		if (SUCCEEDED(hr))
		    hr = HandleParamTags(p, pfCodec);
	    }

	    SysFreeString(bstrCodec);
	    if (bstrID)
		SysFreeString(bstrID);
	}
    }

    if (SUCCEEDED(hr)) {
        if (fVideo) {
            long lWidth = ReadNumAttribute(p, L"width", -1);
            long lHeight = ReadNumAttribute(p, L"height", -1);
            DWORD dwFlag = RESIZEF_STRETCH; // !!! need RESIZEF_CROP, RESIZEF_PRESERVEASPECTRATIO

            if (lWidth > 0 && lHeight > 0) {
                DbgLog((LOG_TRACE, 1, "attempting to resize video to %dx%d", lWidth, lHeight));
                IResize *pResize;
                HRESULT hr2 = CoCreateInstance(__uuidof(Resize), NULL, CLSCTX_INPROC,
                                               __uuidof(IResize), (void **) &pResize);

                if (SUCCEEDED(hr2)) {
                    hr2 = pResize->put_Size(lWidth, lHeight, dwFlag);
                    ASSERT(SUCCEEDED(hr2)); // !!!

                    IBaseFilter *pfResize;
                    hr2 = pResize->QueryInterface(IID_IBaseFilter, (void **) &pfResize);

                    if (SUCCEEDED(hr2)) {
                        IPin *pResizeInPin = NULL;
                        IPin *pResizeOutPin = NULL;
                        hr2 = FindThePin(p, NULL, pfResize, &pResizeInPin, PINDIR_INPUT, L"resize");
                        if (SUCCEEDED(hr2)) {
                            hr2 = FindThePin(p, NULL, pfResize, &pResizeOutPin, PINDIR_OUTPUT, L"resize");
                            if (SUCCEEDED(hr2)) {

                                m_pGB->AddFilter(pfResize, L"resizer");

                                pfResize->Release();

                                hr2 = m_pGB->Connect(ppin1, pResizeInPin);

                                DbgLog((LOG_TRACE, 1, "connect to resize input returned %x", hr));
                                if (SUCCEEDED(hr2)) {
                                    ppin1->Release();
                                    ppin1 = pResizeOutPin;
                                } else
                                    pResizeOutPin->Release();
                            }
                            pResizeInPin->Release();
                        }
                        pfResize->Release();
                    } else {
                        DbgLog((LOG_ERROR, 0, "couldn't create Resizer filter: %x", hr));
                    }

                    pResize->Release();
                }
            }
        }


	IPin *pCodecInPin = NULL;

	hr = FindThePin(p, L"codecinpin", pfCodec, &pCodecInPin, PINDIR_INPUT, L"codec");

	if (SUCCEEDED(hr)) {
	    hr = m_pGB->Connect(ppin1, pCodecInPin);

	    DbgLog((LOG_TRACE, 1,
		      TEXT("CONNECT (intelligent) '%ls' to '%ls' (codec input) returned %x"),
		      FindAttribute(p, L"src"), FindAttribute(p, L"codec"), hr));

	    pCodecInPin->Release();

	    if (SUCCEEDED(hr)) {
		IPin *pCodecOutPin = NULL;
		hr = FindThePin(p, L"codecoutpin", pfCodec, &pCodecOutPin, PINDIR_OUTPUT, L"codec");

		if (fVideo && SUCCEEDED(hr)) {
		    IAMVideoCompression *pVC;

		    hr = pCodecOutPin->QueryInterface(IID_IAMVideoCompression,
						    (void **) &pVC);

		    if (SUCCEEDED(hr)) {
			BSTR bstrKeyFrameRate = FindAttribute(p, L"keyframerate");

			if (bstrKeyFrameRate) {
			    DWORD dwKeyFrameRate = ParseNum(bstrKeyFrameRate);

			    hr = pVC->put_KeyFrameRate(dwKeyFrameRate);

			    DbgLog((LOG_TRACE, 1, "put_KeyFrameRate(%d) returned %x",
				      dwKeyFrameRate, hr));

			    SysFreeString(bstrKeyFrameRate);
			}

			pVC->Release();
		    }

		    IAMStreamConfig *pSC;

		    hr = pCodecOutPin->QueryInterface(IID_IAMStreamConfig,
						    (void **) &pSC);

		    if (SUCCEEDED(hr)) {
			AM_MEDIA_TYPE *pType = NULL;

			hr = pSC->GetFormat(&pType);

			if (SUCCEEDED(hr)) {
			    BOOL fCallSetFormat = FALSE;

			    BSTR bstrFrameRate = FindAttribute(p, L"framerate");

			    if (bstrFrameRate) {
				DWORD dwFrameRate = ParseNum(bstrFrameRate);

				// !!! need code here to see if the codec can
				// produce this frame rate, if not go back and stick
				// a frame rate converter before the compressor!

				SysFreeString(bstrFrameRate);
			    }

			    BSTR bstrDataRate = FindAttribute(p, L"datarate");

			    if (bstrDataRate) {
				DWORD dwDataRate = ParseNum(bstrDataRate);

				// !!! need code here to see if the codec can
				// produce this frame rate, if not go back and stick
				// a frame rate converter before the compressor!

				VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)
								pType->pbFormat;

				pvi->dwBitRate = dwDataRate * 8192;
				fCallSetFormat = TRUE;

				DbgLog((LOG_TRACE, 1, TEXT("Setting output data rate to %d bps"),
				    pvi->dwBitRate));

				SysFreeString(bstrDataRate);
			    }

			    if (fCallSetFormat) {
				hr = pSC->SetFormat(pType);

				DbgLog((LOG_TRACE, 1, TEXT("Setting modified output format returned %x"),
				    hr));
			    }

			    DeleteMediaType(pType);
			}

		    }

		    // !!! are errors here fatal, or not?
		    hr = S_OK; // !!!
		}

		if (SUCCEEDED(hr)) {
		    hr = m_pGB->Connect(pCodecOutPin, ppin2);

		    DbgLog((LOG_TRACE, 1,
			      TEXT("CONNECT (intelligent) '%ls' (codec output) to '%ls'returned %x"),
			      FindAttribute(p, L"codec"), FindAttribute(p, L"dest"), hr));
		}

		if (pCodecOutPin)
		    pCodecOutPin->Release();
	    }
	}
    }

    if (pfCodec) {
	pfCodec->Release();
    }

    if (pf1)
	pf1->Release();

    if (pf2)
	pf2->Release();

    if (ppin1)
	ppin1->Release();

    if (ppin2)
	ppin2->Release();

    return hr;
}


HRESULT CXMLGraph::BuildOneElement(IXMLElement *p)
{
    HRESULT hr = S_OK;

    BSTR bstrName;
    hr = p->get_tagName(&bstrName);

    if (FAILED(hr))
	return hr;

    // do the appropriate thing based on the current tag
    if (!lstrcmpiW(bstrName, L"filter")) {
	BSTR bstrID = FindAttribute(p, L"id");
	BSTR bstrCLSID = FindAttribute(p, L"clsid");
	BSTR bstrCategory = FindAttribute(p, L"category");
	BSTR bstrInstance = FindAttribute(p, L"instance");

	// !!! add prefix onto ID?
	
	IBaseFilter *pf = NULL;

	if (bstrCLSID) {
	    CLSID clsidFilter;
	    hr = CLSIDFromString(bstrCLSID, &clsidFilter);

	    if (FAILED(hr)) {
		DbgLog((LOG_ERROR, 0, TEXT("FILTER with unparseable CLSID tag '%ls'"),
			 bstrCLSID));

		// !!! could enumerate filters looking for
		// string match

		hr = VFW_E_INVALID_FILE_FORMAT;
	    } else {
		hr = CoCreateInstance(clsidFilter, NULL, CLSCTX_INPROC,
				      IID_IBaseFilter, (void **) &pf);

		if (FAILED(hr)) {
		    DbgLog((LOG_ERROR, 0, TEXT("unable to create FILTER with CLSID tag '%ls'"),
			      bstrCLSID));
		}
	    }
	} else if (bstrCategory || bstrInstance) {
	    CLSID clsidCategory;
	    if (bstrCategory) {
		hr = CLSIDFromString(bstrCategory, &clsidCategory);

		if (FAILED(hr)) {
		    DbgLog((LOG_ERROR, 0, TEXT("FILTER with unparseable CATEGORY tag '%ls'"),
			     bstrCategory));

		    // !!! could enumerate categories looking for
		    // string match

		    hr = VFW_E_INVALID_FILE_FORMAT;
		}
	    } else {
		// plain old filter name....
		clsidCategory = CLSID_LegacyAmFilterCategory;
	    }

	    if (SUCCEEDED(hr)) {
		// do they want a non-default device?

		hr = GetFilterFromCategory(clsidCategory, bstrInstance, &pf);
		if (pf == NULL) {
		    DbgLog((LOG_ERROR, 0, TEXT("Error %x: Cannot create filter of category %ls"), hr, bstrCategory));
		}
	    }
	} else {
	    DbgLog((LOG_ERROR, 0, TEXT("FILTER with no CLSID or Category tag")));

	    // !!! someday, other ways to identify which filter?

	    hr = VFW_E_INVALID_FILE_FORMAT;
	}

	if (SUCCEEDED(hr)) {
	    hr = AddFilter(pf, bstrID);
	    if (FAILED(hr)) {
		DbgLog((LOG_ERROR, 0, TEXT("failed to add new filter to graph???")));
	    }
	}

	if (SUCCEEDED(hr)) {
	    hr = HandleParamTags(p, pf);
	}

	// !!! if we're in a SEQUENCE block, automatically connect this to
	// the previous filter?

	if (pf)
	    pf->Release();

	if (bstrID)
	    SysFreeString(bstrID);
	if (bstrCLSID)
	    SysFreeString(bstrCLSID);
	if (bstrCategory)
	    SysFreeString(bstrCategory);
	if (bstrInstance)
	    SysFreeString(bstrInstance);
    } else if (!lstrcmpiW(bstrName, L"connect")) {
	// <connect src="f1" srcpin="out"  dest="f2"  destpin="in" direct="yes/no">
	// defaults:
	//    if srcpin not specified, find an unconnected output of first filter.
	//    if destpin not specified, find an unconnected input of second filter.
	// !!!!


	// !!! use name prefix?
	
	IBaseFilter *pf1 = NULL, *pf2 = NULL;
	IPin *ppin1 = NULL, *ppin2 = NULL;

	hr = FindFilterAndPin(p, L"src", L"srcpin", &pf1, &ppin1, PINDIR_OUTPUT);
	if (SUCCEEDED(hr))
	    hr = FindFilterAndPin(p, L"dest", L"destpin", &pf2, &ppin2, PINDIR_INPUT);

	if (SUCCEEDED(hr)) {
	    // okay, we finally have everything we need.

	    BOOL fDirect = ReadBoolAttribute(p, L"Direct", FALSE);

	    if (fDirect) {
		hr = m_pGB->ConnectDirect(ppin1, ppin2, NULL);

		DbgLog((LOG_TRACE, 1,
			  TEXT("CONNECT (direct) '%ls' to '%ls' returned %x"),
			  FindAttribute(p, L"src"), FindAttribute(p, L"dest"), hr));
	    }
	    else {
		hr = m_pGB->Connect(ppin1, ppin2);

		DbgLog((LOG_TRACE, 1,
			  TEXT("CONNECT (intelligent) '%ls' to '%ls' returned %x"),
			  FindAttribute(p, L"src"), FindAttribute(p, L"dest"), hr));
	    }
	}

	if (pf1)
	    pf1->Release();

	if (pf2)
	    pf2->Release();

	if (ppin1)
	    ppin1->Release();

	if (ppin2)
	    ppin2->Release();
    } else if (!lstrcmpiW(bstrName, L"render")) {
	// <RENDER id="name" pin="">
	// defaults:
	//    if pin not specified, find an unconnected output
	//	  !!! could default to "last filter touched" or something....
	//    !!! if pin not specified, render all pins?

	IBaseFilter *pf = NULL;
	IPin *ppin = NULL;

	hr = FindFilterAndPin(p, L"id", L"pin", &pf, &ppin, PINDIR_OUTPUT);

	if (SUCCEEDED(hr)) {
	    // okay, we finally have everything we need.

	    hr = m_pGB->Render(ppin);

	    DbgLog((LOG_TRACE, 1,
		      TEXT("RENDER '%ls' returned %x"),
		      FindAttribute(p, L"id"), hr));
	}

	if (pf)
	    pf->Release();

	if (ppin)
	    ppin->Release();
    } else if (!lstrcmpiW(bstrName, L"filesource")) {
	// <filesource id="name" url="url"  ... >
	// allow specified classid?

	BSTR bstrSrc = FindAttribute(p, L"url");

	if (!bstrSrc) {
	    DbgLog((LOG_ERROR, 0, TEXT("FILESOURCE with no SRC tag")));

	    return VFW_E_INVALID_FILE_FORMAT;
	}

	// !!! bstrSrc = HandleRelativePath(bstrSrc, m_BasePath, szWork);

	BSTR bstrID = FindAttribute(p, L"id");

	IBaseFilter *pf = NULL;
	hr = m_pGB->AddSourceFilter(bstrSrc, bstrID, &pf);

	DbgLog((LOG_TRACE, 1, TEXT("AddSourceFilter('%ls') returned %d"),
		  bstrSrc, hr));

	if (bstrSrc)
	    SysFreeString(bstrSrc);
	if (bstrID)
	    SysFreeString(bstrID);
	
	if (pf)
	    pf->Release();
    } else if (!lstrcmpiW(bstrName, L"include")) {
	BSTR bstrSrc = FindAttribute(p, L"src");
        BSTR bstrFragment = FindAttribute(p, L"fragment");
        BSTR bstrSubgraph = FindAttribute(p, L"subgraph");

	if ((!bstrSrc && !bstrFragment) || (bstrSrc && bstrFragment)) {
	    hr = VFW_E_INVALID_FILE_FORMAT;
	} else {
            int iPrefixLen = -1;

            if (bstrSubgraph) {
                iPrefixLen = lstrlenW(m_wszNamePrefix);
		// append ID of this rule to the current name prefix
		lstrcpyW(m_wszNamePrefix + iPrefixLen, bstrName);
		
		m_wszNamePrefix[lstrlenW(m_wszNamePrefix)] = L'.';
            }

            if (bstrSrc) {
                // !!! need to handle relative path here
                // !!! use IXMLDocument2Ex::get_baseURL

                hr = BuildFromXMLFileInternal(bstrSrc);
            } else {
                ASSERT(bstrFragment);

                // first, find this procedure in our list
                POSITION pos1, pos2;
                for (pos1 = m_listRuleNames.GetHeadPosition(),
                             pos2 = m_listRuleElements.GetHeadPosition();
                     pos1;
                     pos1 = m_listRuleNames.Next(pos1),
                             pos2 = m_listRuleElements.Next(pos2))
                {
                    WCHAR *pName = m_listRuleNames.Get(pos1);

                    if (lstrcmpW(pName, bstrFragment) == 0)
                        break;
                }

                if (pos1 == 0) {
                    hr = VFW_E_INVALID_FILE_FORMAT;
                } else {
                    // then, go through it and do what it wants.

                    IXMLElement *pRule = m_listRuleElements.Get(pos2);
                    ASSERT(pRule);

                    // do the actual work
                    hr = BuildChildren(pRule);
                }

            }

            if (iPrefixLen > 0) {
		// restore name prefix
		m_wszNamePrefix[iPrefixLen] = L'\0';
            }
        }
	
	if (bstrSrc)
	    SysFreeString(bstrSrc);
	if (bstrFragment)
	    SysFreeString(bstrFragment);
	if (bstrSubgraph)
	    SysFreeString(bstrSubgraph);
    } else if (!lstrcmpiW(bstrName, L"Subgraph")) {
        // <subgraph name="...">
	BSTR bstrName = FindAttribute(p, L"name");

        if (!bstrName) {
	    hr = VFW_E_INVALID_FILE_FORMAT;
        } else {
            int iPrefixLen = lstrlenW(m_wszNamePrefix);
            // append ID of this rule to the current name prefix
            lstrcpyW(m_wszNamePrefix + iPrefixLen, bstrName);

            m_wszNamePrefix[lstrlenW(m_wszNamePrefix)] = L'.';

            // build sub-elements
            hr = BuildChildren(p);

            m_wszNamePrefix[iPrefixLen] = L'\0';
        }
    } else if (!lstrcmpiW(bstrName, L"Block")) {
        // <block >

        // build sub-elements
        hr = BuildChildren(p);
    } else if (!lstrcmpiW(bstrName, L"VideoCompress")) {
	hr = HandleCompressTag(p, TRUE);
    } else if (!lstrcmpiW(bstrName, L"AudioCompress")) {
	hr = HandleCompressTag(p, FALSE);
    } else if (!lstrcmpiW(bstrName, L"fragment")) {
	// <fragment name="....">

	// !!! if name prefix is non-null then we're in a nested proc, shouldn't be allowed.
	if (m_wszNamePrefix[0]) {
	    hr = VFW_E_INVALID_FILE_FORMAT;
	} else {
	    BSTR bstrName = FindAttribute(p, L"name");
	    if (!bstrName) {
		hr = VFW_E_INVALID_FILE_FORMAT;
	    } else {
		p->AddRef();

		// stick this tag into our list of procedures
		m_listRuleNames.AddTail(bstrName);
		m_listRuleElements.AddTail(p);
	    }
	}
    } else if (!lstrcmpiW(bstrName, L"timeline")) {
        // !!! link to the dexter stuff, create filter
        // now id+groupname needs to map to a filter name.  (unless dexter changes to not need this.)

        // get xml2dex object
        IXml2Dex *pxml2dex = NULL;
        hr = CoCreateInstance(__uuidof(Xml2Dex), NULL, CLSCTX_INPROC_SERVER,
                              __uuidof(IXml2Dex), (void**) &pxml2dex);
        DbgLog((LOG_TRACE, 1, TEXT("Processing <timeline> tag....")));
        DbgLog((LOG_TRACE, 1, TEXT("     CoCreate(Xml2Dex) returned %x"), hr));

        if (SUCCEEDED(hr)) {
            IAMTimeline * pTimeline;
            hr = CoCreateInstance(__uuidof(AMTimeline), NULL, CLSCTX_INPROC_SERVER,
                                  __uuidof(IAMTimeline), (void**) &pTimeline);

            // tell it to load my timeline
            if (SUCCEEDED(hr)) {
                hr = pxml2dex->ReadXML(pTimeline, p);
                DbgLog((LOG_TRACE, 1, TEXT("     ReadXML returned %x"), hr));
            }

            if (SUCCEEDED(hr)) {
                // get render engine, have it build partial graph
                IRenderEngine * pRenderEngine = NULL;

                hr = CoCreateInstance(__uuidof(RenderEngine), NULL, CLSCTX_INPROC_SERVER,
                                      __uuidof(IRenderEngine), (void**) &pRenderEngine );

                if (SUCCEEDED(hr)) {
                    // !!! pRenderEngine->SetDynamicReconnectLevel(CONNECTF_DYNAMIC_NONE);
                    hr = pRenderEngine->SetTimelineObject(pTimeline);
                    ASSERT(SUCCEEDED(hr));
                    hr = pRenderEngine->SetFilterGraph(m_pGB);
                    ASSERT(SUCCEEDED(hr));

                    if (SUCCEEDED(hr)) {
                        hr = pRenderEngine->ConnectFrontEnd();
                        DbgLog((LOG_TRACE, 1, TEXT("     ConnectFrontEnd returned %x"), hr));
                    }

                    pRenderEngine->Release();
                }
            }

            pTimeline->Release();
        }

        pxml2dex->Release();
    } else {
	// !!! ignore unknown tags?

	DbgLog((LOG_ERROR, 1,
		  TEXT("unknown tag '%ls'???"),
		  bstrName));
	
    }


    SysFreeString(bstrName);

    return hr;
}


HRESULT CXMLGraph::ReleaseNameTable()
{
    BSTR p;

    do {
	p = m_listRuleNames.RemoveHead();
	if (p)
	    SysFreeString(p);
    } while (p);

    IXMLElement * pxml;

    do {
	pxml = m_listRuleElements.RemoveHead();
	if (pxml)
	    pxml->Release();
    } while (pxml);

    if (m_pGB) {
	m_pGB->Release();
	m_pGB = NULL;
    }

    return S_OK;
}


STDMETHODIMP CXMLGraph::BuildFromXML(IGraphBuilder *pGraph, IXMLElement *pxml)
{
    m_pGB = pGraph;
    m_pGB->AddRef();

    HRESULT hr = BuildFromXMLInternal(pxml);

    ReleaseNameTable();

    return hr;
}

HRESULT CXMLGraph::BuildFromXMLInternal(IXMLElement *pxml)
{
    HRESULT hr = S_OK;

    BSTR bstrName;
    hr = pxml->get_tagName(&bstrName);

    if (FAILED(hr))
	return hr;

    int i = lstrcmpiW(bstrName, L"graph");
    SysFreeString(bstrName);

    if (i != 0)
	return VFW_E_INVALID_FILE_FORMAT;

    hr = BuildChildren(pxml);
    return hr;
}

HRESULT CXMLGraph::BuildChildren(IXMLElement *pxml)
{
    IXMLElementCollection *pcoll;

    HRESULT hr = pxml->get_children(&pcoll);

    if (hr == S_FALSE)
	return S_OK; // nothing to do, is this an error?

    if (FAILED(hr))
        return hr;

    long lChildren;
    hr = pcoll->get_length(&lChildren);

    VARIANT var;

    var.vt = VT_I4;
    var.lVal = 0;

    for (SUCCEEDED(hr); var.lVal < lChildren; (var.lVal)++) {
	IDispatch *pDisp;
	hr = pcoll->item(var, var, &pDisp);

	if (SUCCEEDED(hr) && pDisp) {
	    IXMLElement *pelem;
	    hr = pDisp->QueryInterface(__uuidof(IXMLElement), (void **) &pelem);

	    if (SUCCEEDED(hr)) {
                long lType;

                pelem->get_type(&lType);

                if (lType == XMLELEMTYPE_ELEMENT) {
                    hr = BuildOneElement(pelem);

                    pelem->Release();
                } else {
                    DbgLog((LOG_TRACE, 1, "XML element of type %d", lType));
                }
	    }
	    pDisp->Release();
	}

	if (FAILED(hr))
	    break;
    }

    pcoll->Release();

    return hr;
}	

HRESULT CXMLGraph::BuildFromXMLDocInternal(IXMLDocument *pxml)
{
    HRESULT hr = S_OK;

    IXMLElement *proot;

    hr = pxml->get_root(&proot);

    if (FAILED(hr))
	return hr;

    hr = BuildFromXMLInternal(proot);

    proot->Release();

    return hr;
}

HRESULT CXMLGraph::BuildFromXMLFile(IGraphBuilder *pGraph, WCHAR *wszXMLFile, WCHAR *wszBaseURL)
{
    m_pGB = pGraph;
    m_pGB->AddRef();

    m_pwszBaseURL = wszBaseURL;

    HRESULT hr = BuildFromXMLFileInternal(wszXMLFile);

    ReleaseNameTable();

    return hr;
}

HRESULT CXMLGraph::BuildFromXMLFileInternal(WCHAR *wszXMLFile)
{
    IXMLDocument *pxml;
    HRESULT hr = CoCreateInstance(__uuidof(XMLDocument), NULL, CLSCTX_INPROC_SERVER,
				  __uuidof(IXMLDocument), (void**)&pxml);

    if (SUCCEEDED(hr)) {
	hr = pxml->put_URL(wszXMLFile);

	// !!! async?

	if (SUCCEEDED(hr)) {
	    hr = BuildFromXMLDocInternal(pxml);
	}

	pxml->Release();
    }

    return hr;
}


//
// CreateInstance
//
// Called by CoCreateInstance to create our filter
CUnknown *CreateXMLGraphInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CXMLGraph(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


/* Implements the CXMLGraphBuilder public member functions */


const int MAX_STRING_LEN=1000;

// WriteString
//
// Helper function to facilitate appending text to a string
//
BOOL WriteString(TCHAR * &ptsz, int &cbAlloc, LPCTSTR lptstr, ...)
{
    TCHAR atchBuffer[MAX_STRING_LEN];

    /* Format the variable length parameter list */

    va_list va;
    va_start(va, lptstr);

    wvsprintf(atchBuffer, lptstr, va);

    DWORD cToWrite=lstrlen(atchBuffer);

    DWORD cCurrent = lstrlen(ptsz);
    if ((int) (cCurrent + cToWrite) >= cbAlloc) {
        TCHAR *ptNew = new TCHAR[cbAlloc * 2];
        if (!ptNew)
            return FALSE;

        lstrcpy(ptNew, ptsz);
        cbAlloc = cbAlloc * 2;
        delete[] ptsz;
        ptsz = ptNew;
    }

    lstrcpy(ptsz + cCurrent, atchBuffer);

    return TRUE;
}

const int MAXFILTERS = 100;
typedef struct { //fit
    int iFilterCount;
    struct {
        DWORD dwUnconnectedInputPins;
        DWORD dwUnconnectedOutputPins;
        FILTER_INFO finfo;
        IBaseFilter * pFilter;
        bool IsSource;
    } Item[MAXFILTERS];
} FILTER_INFO_TABLE;


// GetNextOutFilter
//
// This function does a linear search and returns in iOutFilter the index of
// first filter in the filter information table  which has zero unconnected
// input pins and atleast one output pin  unconnected.
// Returns FALSE when there are none o.w. returns TRUE
//
BOOL GetNextOutFilter(FILTER_INFO_TABLE &fit, int *iOutFilter)
{
    for (int i=0; i < fit.iFilterCount; ++i) {
        if ((fit.Item[i].dwUnconnectedInputPins == 0) &&
                (fit.Item[i].dwUnconnectedOutputPins > 0)) {
            *iOutFilter=i;
            return TRUE;
        }
    }

    // then things with more outputs than inputs
    for (i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].dwUnconnectedOutputPins > fit.Item[i].dwUnconnectedInputPins) {
            *iOutFilter=i;
            return TRUE;
        }
    }

    // if that doesn't work, find one that at least has unconnected output pins....
    for (i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].dwUnconnectedOutputPins > 0) {
            *iOutFilter=i;
            return TRUE;
        }
    }
    return FALSE;
}

// LocateFilterInFIT
//
// Returns the index into the filter information table corresponding to
// the given IBaseFilter
//
int LocateFilterInFIT(FILTER_INFO_TABLE &fit, IBaseFilter *pFilter)
{
    int iFilter=-1;
    for (int i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].pFilter == pFilter)
            iFilter=i;
    }

    return iFilter;
}

// MakeScriptableFilterName
//
// Replace any spaces and minus signs in the filter name with an underscore.
// If it is a source filtername than it actually is a file path (with the
// possibility of some stuff added at the end for uniqueness), we create a good filter
// name for it here.
//
void MakeScriptableFilterName(WCHAR awch[], BOOL bSourceFilter, int& cSources)
{
    if (bSourceFilter) {
        WCHAR awchBuf[MAX_FILTER_NAME];
        BOOL bExtPresentInName=FALSE;
        int iBuf=0;
        for (int i=0; awch[i] != L'\0';++i) {
            if (awch[i]==L'.' && awch[i+1]!=L')') {
                for (int j=1; j <=3; awchBuf[iBuf]=towupper(awch[i+j]),++j,++iBuf);
                awchBuf[iBuf++]=L'_';
                wcscpy(&(awchBuf[iBuf]), L"Source_");
                bExtPresentInName=TRUE;
                break;
            }
        }

        // If we have a filename with no extension than create a suitable name

        if (!bExtPresentInName) {
            wcscpy(awchBuf, L"Source_");
        }

        // make source filter name unique by appending digit always, we don't want to
        // bother to make it unique only if its another instance of the same source
        // filter
        WCHAR awchSrcFilterCnt[10];
        wcscpy(&(awchBuf[wcslen(awchBuf)]),
                _ltow(cSources++, awchSrcFilterCnt, 10));
        wcscpy(awch, awchBuf);
    } else {

        for (int i = 0; i < MAX_FILTER_NAME; i++) {
            if (awch[i] == L'\0')
                break;
            else if ((awch[i] == L' ') || (awch[i] == L'-'))
                awch[i] = L'_';
        }
    }
}

// PopulateFIT
//
// Scans through all the filters in the graph, storing the number of input and out
// put pins for each filter, and identifying the source filters in the filter
// inforamtion table. The object tag statements are also printed here
//
void PopulateFIT(TCHAR * &ptsz, int &cbAlloc, IFilterGraph *pGraph,
        FILTER_INFO_TABLE *pfit, int &cSources)
{
    HRESULT hr;
    IEnumFilters *penmFilters=NULL;
    if (FAILED(hr=pGraph->EnumFilters(&penmFilters))) {
        WriteString(ptsz, cbAlloc, TEXT("'Error[%x]:EnumFilters failed!\r\n"), hr);
    }

    IBaseFilter *pFilter;
    ULONG n;
    while (penmFilters && (penmFilters->Next(1, &pFilter, &n) == S_OK)) {
	pfit->Item[pfit->iFilterCount].pFilter = pFilter;
	
        // Get the input and output pin counts for this filter

        IEnumPins *penmPins=NULL;
        if (FAILED(hr=pFilter->EnumPins(&penmPins))) {
            WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: EnumPins for Filter Failed !\r\n"), hr);
        }

        IPin *ppin = NULL;
        while (penmPins && (penmPins->Next(1, &ppin, &n) == S_OK)) {
            PIN_DIRECTION pPinDir;
            if (SUCCEEDED(hr=ppin->QueryDirection(&pPinDir))) {
                if (pPinDir == PINDIR_INPUT)
                    pfit->Item[pfit->iFilterCount].dwUnconnectedInputPins++;
                else
                    pfit->Item[pfit->iFilterCount].dwUnconnectedOutputPins++;
            } else {
                WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryDirection Failed!\r\n"), hr);
            }

            ppin->Release();
        }

        if (penmPins)
            penmPins->Release();

        // Mark the source filters, remember at this point any filters that have
        // all input pins connected (or don't have any input pins) must be sources

        if (pfit->Item[pfit->iFilterCount].dwUnconnectedInputPins==0)
            pfit->Item[pfit->iFilterCount].IsSource=TRUE;


	if (FAILED(hr=pFilter->QueryFilterInfo(&pfit->Item[pfit->iFilterCount].finfo))) {
	    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryFilterInfo Failed!\r\n"),hr);

	} else {
	    QueryFilterInfoReleaseGraph(pfit->Item[pfit->iFilterCount].finfo);

            MakeScriptableFilterName(pfit->Item[pfit->iFilterCount].finfo.achName,
                    pfit->Item[pfit->iFilterCount].IsSource, cSources);
	}

	pfit->iFilterCount++;
    }

    if (penmFilters)
        penmFilters->Release();
}


void PrintFiltersAsXML(TCHAR * &ptsz, int &cbAlloc, FILTER_INFO_TABLE *pfit)
{
    HRESULT hr;
	
    for (int i = 0; i < pfit->iFilterCount; i++) {
	LPWSTR lpwstrFile = NULL;
    	IBaseFilter *pFilter = pfit->Item[i].pFilter;

	IFileSourceFilter *pFileSourceFilter=NULL;
	if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IFileSourceFilter,
			                    reinterpret_cast<void **>(&pFileSourceFilter)))) {
            hr = pFileSourceFilter->GetCurFile(&lpwstrFile, NULL);
            pFileSourceFilter->Release();
        } else {
	    IFileSinkFilter *pFileSinkFilter=NULL;
	    if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IFileSinkFilter,
						reinterpret_cast<void **>(&pFileSinkFilter)))) {
		hr = pFileSinkFilter->GetCurFile(&lpwstrFile, NULL);
		pFileSinkFilter->Release();
	    }
	}


        IPersistPropertyBag *pPPB = NULL;

        if (SUCCEEDED(hr = pFilter->QueryInterface(IID_IPersistPropertyBag, (void **) &pPPB))) {
            CLSID clsid;
            if (SUCCEEDED(hr=pPPB->GetClassID(&clsid))) {
                WCHAR szGUID[100];
                StringFromGUID2(clsid, szGUID, 100);

                CFakePropertyBag bag;

                hr = pPPB->Save(&bag, FALSE, FALSE); // fClearDirty=FALSE, fSaveAll=FALSE

                if (SUCCEEDED(hr)) {
                    WriteString(ptsz, cbAlloc, TEXT("\t<FILTER ID=\"%ls\" clsid=\"%ls\">\r\n"),
                                pfit->Item[i].finfo.achName, szGUID);
                    POSITION pos1, pos2;
                    for(pos1 = bag.m_listNames.GetHeadPosition(),
                        pos2 = bag.m_listValues.GetHeadPosition();
                        pos1;
                        pos1 = bag.m_listNames.Next(pos1),
                        pos2 = bag.m_listValues.Next(pos2))
                    {
                        WCHAR *pName = bag.m_listNames.Get(pos1);
                        WCHAR *pValue = bag.m_listValues.Get(pos2);

                        WriteString(ptsz, cbAlloc, TEXT("\t\t<PARAM name=\"%ls\" value=\"%ls\"/>\r\n"),
                                    pName, pValue);
                    }

                    WriteString(ptsz, cbAlloc, TEXT("\t</FILTER>\r\n"),
                                pfit->Item[i].finfo.achName, szGUID, lpwstrFile);

                } else {
                    // we'll fall through and IPersistStream in this case!
                    // if it was E_NOTIMPL, it's a hacky filter that just supports IPersistPropertyBag to
                    // load from a category, don't report an error.
                    if (hr != E_NOTIMPL)
                        WriteString(ptsz, cbAlloc, TEXT("<!-- 'Error[%x]: IPersistPropertyBag failed! -->\r\n"), hr);
                }
            }

            pPPB->Release();
        }

        if (FAILED(hr)) {
            IPersistStream *pPS = NULL;
            IPersist *pP = NULL;
            if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IPersistStream, (void**) &pPS))) {
                CLSID clsid;

                if (SUCCEEDED(hr=pPS->GetClassID(&clsid))) {
                    WCHAR szGUID[100];
                    StringFromGUID2(clsid, szGUID, 100);

                    HGLOBAL h = GlobalAlloc(GHND, 0x010000); // !!! 64K, why?
                    IStream *pstr = NULL;
                    hr = CreateStreamOnHGlobal(h, TRUE, &pstr);

                    LARGE_INTEGER li;
                    ULARGE_INTEGER liCurrent, li2;
                    li.QuadPart = liCurrent.QuadPart = 0;
                    if (SUCCEEDED(hr)) {
                        hr = pPS->Save(pstr, FALSE);

                        if (SUCCEEDED(hr)) {
                            pstr->Seek(li, STREAM_SEEK_CUR, &liCurrent); // get length
                            pstr->Seek(li, STREAM_SEEK_SET, &li2); // seek to start
                        }
                    }

                    WriteString(ptsz, cbAlloc, TEXT("\t<FILTER ID=\"%ls\" clsid=\"%ls\">\r\n"),
                                   pfit->Item[i].finfo.achName, szGUID);
                    if (lpwstrFile) {
                        WriteString(ptsz, cbAlloc, TEXT("\t\t<PARAM name=\"src\" value=\"%ls\"/>\r\n"),
                                   lpwstrFile);
                    }

                    if (liCurrent.QuadPart > 0) {
                        // !!! Idea from SyonB: check if data is really just text and
                        // if so don't hex-encode it.  Obviously also needs support on
                        // the other end.

                        WriteString(ptsz, cbAlloc, TEXT("\t\t<PARAM name=\"data\" value=\""),
                                   lpwstrFile);

                        for (ULONGLONG i = 0; i < liCurrent.QuadPart; i++) {
                            BYTE b;
                            DWORD cbRead;
                            pstr->Read(&b, 1, &cbRead);

                            WriteString(ptsz, cbAlloc, TEXT("%02X"), b);
                        }

                        WriteString(ptsz, cbAlloc, TEXT("\"/>\r\n"),
                                   lpwstrFile);
                    }

                    WriteString(ptsz, cbAlloc, TEXT("\t</FILTER>\r\n"),
                                   pfit->Item[i].finfo.achName, szGUID, lpwstrFile);
                } else {
                    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: GetClassID for Filter Failed !\r\n"), hr);
                }

                pPS->Release();
            } else if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IPersist, (void**) &pP))) {
                CLSID clsid;

                if (SUCCEEDED(hr=pP->GetClassID(&clsid))) {
                    WCHAR szGUID[100];
                    StringFromGUID2(clsid, szGUID, 100);
                    WriteString(ptsz, cbAlloc, TEXT("\t<FILTER ID=\"%ls\" clsid=\"%ls\">\r\n"),
                                   pfit->Item[i].finfo.achName, szGUID);
                    if (lpwstrFile) {
                        WriteString(ptsz, cbAlloc, TEXT("\t\t<PARAM name=\"src\" value=\"%ls\"/>\r\n"),
                                   lpwstrFile);
                    }

                    WriteString(ptsz, cbAlloc, TEXT("\t</FILTER>\r\n"),
                                   pfit->Item[i].finfo.achName, szGUID, lpwstrFile);
                }
                pP->Release();
            } else {
                WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: Filter doesn't support IID_IPersist!\r\n"), hr);
            }
        }

	if (lpwstrFile) {
	    CoTaskMemFree(lpwstrFile);
	    lpwstrFile = NULL;
	}
    }
}


HRESULT CXMLGraph::SaveToXML(IGraphBuilder *pGraph, BSTR *pbstrxml)
{
    HRESULT hr;
    ULONG n;
    FILTER_INFO_TABLE fit;
    ZeroMemory(&fit, sizeof(fit));

    int cbAlloc = 1024;
    TCHAR *ptsz = new TCHAR[cbAlloc];
    if (!ptsz)
        return E_OUTOFMEMORY;
    ptsz[0] = TEXT('\0');

    int cSources = 0;

    // write the initial header tags and instantiate the filter graph
    WriteString(ptsz, cbAlloc, TEXT("<GRAPH version=\"1.0\">\r\n"));

    // Fill up the Filter information table and also print the <OBJECT> tag
    // filter instantiations
    PopulateFIT(ptsz, cbAlloc, pGraph, &fit, cSources);

    PrintFiltersAsXML(ptsz, cbAlloc, &fit);

    // Find a filter with zero unconnected input pins and > 0 unconnected output pins
    // Connect the output pins and subtract the connections counts for that filter.
    // Quit when there is no such filter left
    for (int i=0; i< fit.iFilterCount; i++) {
        int iOutFilter=-1; // index into the fit
        if (!GetNextOutFilter(fit, &iOutFilter))
            break;
        ASSERT(iOutFilter !=-1);
        IEnumPins *penmPins=NULL;
        if (FAILED(hr=fit.Item[iOutFilter].pFilter->EnumPins(&penmPins))) {
            WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: EnumPins failed for Filter!\r\n"), hr);
        }
        IPin *ppinOut=NULL;
        while (penmPins && (penmPins->Next(1, &ppinOut, &n)==S_OK)) {
            PIN_DIRECTION pPinDir;
            if (FAILED(hr=ppinOut->QueryDirection(&pPinDir))) {
                WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryDirection Failed!\r\n"), hr);
                ppinOut->Release();
                continue;
            }
            if (pPinDir == PINDIR_OUTPUT) {
                LPWSTR pwstrOutPinID;
                LPWSTR pwstrInPinID;
                IPin *ppinIn=NULL;
                PIN_INFO pinfo;
                FILTER_INFO finfo;
                if (FAILED(hr=ppinOut->QueryId(&pwstrOutPinID))) {
                    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryId Failed! \r\n"), hr);
                    ppinOut->Release();
                    continue;
                }
                if (FAILED(hr= ppinOut->ConnectedTo(&ppinIn))) {

                    // It is ok if a particular pin is not connected since we allow
                    // a pruned graph to be saved
                    if (hr == VFW_E_NOT_CONNECTED) {
                        fit.Item[iOutFilter].dwUnconnectedOutputPins--;
                    } else {
                        WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: ConnectedTo Failed! \r\n"), hr);
                    }
                    ppinOut->Release();
                    continue;
                }
                if (FAILED(hr= ppinIn->QueryId(&pwstrInPinID))) {
                    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryId Failed! \r\n"), hr);
                    ppinOut->Release();
                    ppinIn->Release();
                    continue;
                }
                if (FAILED(hr=ppinIn->QueryPinInfo(&pinfo))) {
                    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryPinInfo Failed! \r\n"), hr);
                    ppinOut->Release();
                    ppinIn->Release();
                    continue;
                }
                ppinIn->Release();
                QueryPinInfoReleaseFilter(pinfo)
                int iToFilter = LocateFilterInFIT(fit, pinfo.pFilter);
                ASSERT(iToFilter < fit.iFilterCount);
                if (FAILED(hr=pinfo.pFilter->QueryFilterInfo(&finfo))) {
                    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryFilterInfo Failed! \r\n"), hr);
                    ppinOut->Release();
                    continue;
                }
                QueryFilterInfoReleaseGraph(finfo)
                MakeScriptableFilterName(finfo.achName, fit.Item[iToFilter].IsSource, cSources);
                WriteString(ptsz, cbAlloc, TEXT("\t<connect direct=\"yes\" ")
						TEXT("src=\"%ls\" srcpin=\"%ls\" ")
						TEXT("dest=\"%ls\" destpin=\"%ls\"/>\r\n"),
			 fit.Item[iOutFilter].finfo.achName,
			 pwstrOutPinID, finfo.achName, pwstrInPinID);

                QzTaskMemFree(pwstrOutPinID);
                QzTaskMemFree(pwstrInPinID);

                // decrement the count for the unconnected pins for these two filters
                fit.Item[iOutFilter].dwUnconnectedOutputPins--;
                fit.Item[iToFilter].dwUnconnectedInputPins--;
            }
            ppinOut->Release();
        }
        if (penmPins)
            penmPins->Release();
    }

    // Release all the filters in the fit
    for (i = 0; i < fit.iFilterCount; i++)
        fit.Item[i].pFilter->Release();

    WriteString(ptsz, cbAlloc, TEXT("</GRAPH>\r\n"));

    USES_CONVERSION;

    *pbstrxml = T2BSTR(ptsz);

    if (!pbstrxml)
        return E_OUTOFMEMORY;

    delete[] ptsz;

    return S_OK;
}



#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"XML Graphbuilder"
    , &CLSID_XMLGraphBuilder
    , CreateXMLGraphInstance
    , NULL
    , NULL }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#include <atlimpl.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdaca.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


////////////////////////////////////////////////////////////////////////////////
//
// BDA Conditional Access class
//
class CBdaConditionalAccess :
    public CUnknown,
    public IBDA_Mpeg2CA
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    CBdaConditionalAccess (
        IUnknown *              pUnkOuter,
        CBdaControlNode *       pControlNode
        );

    ~CBdaConditionalAccess ( );


    STDMETHODIMP
    put_TuneRequest (
        ITuneRequest *      pTuneRequest
        );

    STDMETHODIMP
    put_Locator (
        ILocator *          pLocator
        );

    STDMETHODIMP
    AddComponent (
        IComponent *        pComponent
        );

    STDMETHODIMP
    RemoveComponent (
        IComponent *        pComponent
        );

    STDMETHODIMP
    PutTableSection (
        PBDA_TABLE_SECTION  pTableSection
        );

private:

    IUnknown *                          m_pUnkOuter;
    CBdaControlNode *                   m_pControlNode;
    CCritSec                            m_FilterLock;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdademod.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


////////////////////////////////////////////////////////////////////////////////
//
// BDA Digital Demodulator class
//
class CBdaDigitalDemodulator :
    public CUnknown,
    public IBDA_DigitalDemodulator
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    CBdaDigitalDemodulator (
        IUnknown *              pUnkOuter,
        CBdaControlNode *       pControlNode
        );

    ~CBdaDigitalDemodulator ( );

    //
    //  IBDA_DigitalDemodulator
    //

    STDMETHODIMP
    put_ModulationType (
        ModulationType *    pModulationType
        );

    STDMETHODIMP
    get_ModulationType (
        ModulationType *    pModulationType
        );

    STDMETHODIMP
    put_InnerFECMethod (
        FECMethod * pFECMethod
        );

    STDMETHODIMP
    get_InnerFECMethod (
        FECMethod * pFECMethod
        );

    STDMETHODIMP
    put_InnerFECRate (
        BinaryConvolutionCodeRate * pFECRate
        );

    STDMETHODIMP
    get_InnerFECRate (
        BinaryConvolutionCodeRate * pFECRate
        );

    STDMETHODIMP
    put_OuterFECMethod (
        FECMethod * pFECMethod
        );

    STDMETHODIMP
    get_OuterFECMethod (
        FECMethod * pFECMethod
        );

    STDMETHODIMP
    put_OuterFECRate (
        BinaryConvolutionCodeRate * pFECRate
        );

    STDMETHODIMP
    get_OuterFECRate (
        BinaryConvolutionCodeRate * pFECRate
        );

    STDMETHODIMP
    put_SymbolRate (
        ULONG * pSymbolRate
        );

    STDMETHODIMP
    get_SymbolRate (
        ULONG * pSymbolRate
        );

    STDMETHODIMP
    put_SpectralInversion (
        SpectralInversion * pSpectralInversion
        );

    STDMETHODIMP
    get_SpectralInversion (
        SpectralInversion * pSpectralInversion
        );

    //
    //  Utility Methods
    //

    STDMETHODIMP
    put_KsProperty(
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData
        );

    STDMETHODIMP
    get_KsProperty (
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData,
        ULONG * pulcbBytesReturned
        );

private:

    IUnknown *                          m_pUnkOuter;
    CBdaControlNode *                   m_pControlNode;
    CCritSec                            m_FilterLock;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdademod.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"



///////////////////////////////////////////////////////////////////////////////
CBdaDigitalDemodulator::CBdaDigitalDemodulator (
    IUnknown *              pUnkOuter,
    CBdaControlNode *       pControlNode
    ) :
    CUnknown( NAME( "IBDA_DigitalDemodulator"), pUnkOuter, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;

    ASSERT( pUnkOuter);

    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaDigitalDemodulator: No parent specified.\n")
              );

        return;
    }

    //  Initialize Members
    //
    m_pUnkOuter = pUnkOuter;
    m_pControlNode = pControlNode;
}

///////////////////////////////////////////////////////////////////////////////
CBdaDigitalDemodulator::~CBdaDigitalDemodulator ( )
///////////////////////////////////////////////////////////////////////////////
{
    m_pUnkOuter = NULL;
    m_pControlNode = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_ModulationType (
    ModulationType *    pModulationType
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_MODULATION_TYPE,
                             pModulationType,
                             sizeof( ModulationType)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_ModulationType (
    ModulationType *    pModulationType
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_InnerFECMethod (
    FECMethod * pFECMethod
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_INNER_FEC_TYPE,
                             pFECMethod,
                             sizeof( FECMethod)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_InnerFECMethod (
    FECMethod * pFECMethod
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_InnerFECRate (
    BinaryConvolutionCodeRate * pFECRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_INNER_FEC_RATE,
                             pFECRate,
                             sizeof( BinaryConvolutionCodeRate)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_InnerFECRate (
    BinaryConvolutionCodeRate * pFECRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_OuterFECMethod (
    FECMethod * pFECMethod
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_OUTER_FEC_TYPE,
                             pFECMethod,
                             sizeof( FECMethod)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_OuterFECMethod (
    FECMethod * pFECMethod
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_OuterFECRate (
    BinaryConvolutionCodeRate * pFECRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_OUTER_FEC_RATE,
                             pFECRate,
                             sizeof( BinaryConvolutionCodeRate)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_OuterFECRate (
    BinaryConvolutionCodeRate * pFECRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_SymbolRate (
    ULONG * pSymbolRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_SYMBOL_RATE,
                             pSymbolRate,
                             sizeof( ULONG)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_SymbolRate (
    ULONG * pSymbolRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_SpectralInversion (
    SpectralInversion * pSpectralInversion
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_SPECTRAL_INVERSION,
                             pSpectralInversion,
                             sizeof( SpectralInversion)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_SpectralInversion (
    SpectralInversion * pSpectralInversion
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->put_BdaNodeProperty(
                            __uuidof( IBDA_DigitalDemodulator),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData
                            );

errExit:
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData,
    ULONG * pulcbBytesReturned
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->get_BdaNodeProperty(
                            __uuidof( IBDA_DigitalDemodulator),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData,
                            pulcbBytesReturned
                            );

errExit:
    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdafreq.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


////////////////////////////////////////////////////////////////////////////////
//
// BDA Frequency Filter class
//
class CBdaFrequencyFilter :
    public CUnknown,
    public IBDA_FrequencyFilter
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    CBdaFrequencyFilter (
        IUnknown *              pUnkOuter,
        CBdaControlNode *       pControlNode
        );

    ~CBdaFrequencyFilter ( );

    //
    //  IBDA_FrequencyFilter
    //

    STDMETHODIMP
    put_Autotune (
        ULONG           ulTransponder
        );
    
    STDMETHODIMP
    get_Autotune (
        ULONG *         pulTransponder
        );

    STDMETHODIMP
    put_Frequency (
        ULONG           ulFrequency
        );

    STDMETHODIMP
    get_Frequency (
        ULONG *         pulFrequency
        );

    STDMETHODIMP
    put_Polarity (
        Polarisation    Polarity
        );

    STDMETHODIMP
    get_Polarity (
        Polarisation *  pPolarity
        );

    STDMETHODIMP
    put_Range (
        ULONG           ulRange
        );

    STDMETHODIMP
    get_Range (
        ULONG *         pulRange
        );

    STDMETHODIMP
    put_Bandwidth (
        ULONG           ulBandwidth
        );

    STDMETHODIMP
    get_Bandwidth (
        ULONG *         pulBandwidth
        );

    STDMETHODIMP
    put_FrequencyMultiplier (
        ULONG           ulMultiplier
        );

    STDMETHODIMP
    get_FrequencyMultiplier (
        ULONG *         pulMultiplier
        );

    //
    //  Utility Methods
    //

    STDMETHODIMP
    put_KsProperty(
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData
        );

    STDMETHODIMP
    get_KsProperty (
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData,
        ULONG * pulcbBytesReturned
        );


private:

    IUnknown *                          m_pUnkOuter;
    CBdaControlNode *                   m_pControlNode;
    CCritSec                            m_FilterLock;
};


////////////////////////////////////////////////////////////////////////////////
//
// BDA LNB Info class
//
class CBdaLNBInfo :
    public CUnknown,
    public IBDA_LNBInfo
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    CBdaLNBInfo (
        IUnknown *              pUnkOuter,
        CBdaControlNode *       pControlNode
        );

    ~CBdaLNBInfo ( );

    //
    //  IBDA_LNBInfo
    //

    STDMETHODIMP
    put_LocalOscilatorFrequencyLowBand (
        ULONG       ulLOFLow
        );

    STDMETHODIMP
    get_LocalOscilatorFrequencyLowBand (
        ULONG *     pulLOFLow
        );

    STDMETHODIMP
    put_LocalOscilatorFrequencyHighBand (
        ULONG       ulLOFHigh
        );

    STDMETHODIMP
    get_LocalOscilatorFrequencyHighBand (
        ULONG *     pulLOFHigh
        );

    STDMETHODIMP
    put_HighLowSwitchFrequency (
        ULONG       ulSwitchFrequency
        );

    STDMETHODIMP
    get_HighLowSwitchFrequency (
        ULONG *     pulSwitchFrequency
        );

    //
    //  Utility Methods
    //

    STDMETHODIMP
    put_KsProperty(
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData
        );

    STDMETHODIMP
    get_KsProperty (
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData,
        ULONG * pulcbBytesReturned
        );

private:

    IUnknown *                          m_pUnkOuter;
    CBdaControlNode *                   m_pControlNode;
    CCritSec                            m_FilterLock;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdafreq.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"



///////////////////////////////////////////////////////////////////////////////
CBdaFrequencyFilter::CBdaFrequencyFilter (
    IUnknown *              pUnkOuter,
    CBdaControlNode *       pControlNode
    ) :
    CUnknown( NAME( "IBDA_FrequencyFilter"), pUnkOuter, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;

    ASSERT( pUnkOuter);

    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: No parent specified.\n")
              );

        return;
    }



    //  Initialize Members
    //
    m_pUnkOuter = pUnkOuter;
    m_pControlNode = pControlNode;
}

///////////////////////////////////////////////////////////////////////////////
CBdaFrequencyFilter::~CBdaFrequencyFilter ( )
///////////////////////////////////////////////////////////////////////////////
{
    m_pUnkOuter = NULL;
    m_pControlNode = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_Autotune (
    ULONG       ulTransponder
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_Autotune (
    ULONG *     pulTransponder
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_Frequency (
    ULONG       ulFrequency
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_RF_TUNER_FREQUENCY,
                             &ulFrequency,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put tuner frequency (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_Frequency (
    ULONG *     pulFrequency
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_Polarity (
    Polarisation    Polarity
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_RF_TUNER_POLARITY,
                             &Polarity,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put tuner polarity (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_Polarity (
    Polarisation *  pPolarity
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_Range (
    ULONG       ulRange
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_RF_TUNER_RANGE,
                             &ulRange,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put tuner range / LNB power (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_Range (
    ULONG *     pulRange
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_Bandwidth (
    ULONG       ulBandwidth
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER,
                             &ulBandwidth,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put tuner bandwidth (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_Bandwidth (
    ULONG *         pulBandwidth
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_FrequencyMultiplier (
    ULONG       ulMultiplier
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER,
                             &ulMultiplier,
                             sizeof( LONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put frequency multiplier (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_FrequencyMultiplier (
    ULONG *     pulMultiplier
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->put_BdaNodeProperty(
                            __uuidof( IBDA_FrequencyFilter),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData
                            );

errExit:
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData,
    ULONG * pulcbBytesReturned
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->get_BdaNodeProperty(
                            __uuidof( IBDA_FrequencyFilter),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData,
                            pulcbBytesReturned
                            );

errExit:
    return hrStatus;
}




///////////////////////////////////////////////////////////////////////////////
CBdaLNBInfo::CBdaLNBInfo (
    IUnknown *              pUnkOuter,
    CBdaControlNode *       pControlNode
    ) :
    CUnknown( NAME( "IBDA_LNBInfo"), pUnkOuter, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;

    ASSERT( pUnkOuter);

    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaLNBInfo: No parent specified.\n")
              );

        return;
    }

    //  Initialize Members
    //
    m_pUnkOuter = pUnkOuter;
    m_pControlNode = pControlNode;
}


///////////////////////////////////////////////////////////////////////////////
CBdaLNBInfo::~CBdaLNBInfo ( )
///////////////////////////////////////////////////////////////////////////////
{
    m_pUnkOuter = NULL;
    m_pControlNode = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::put_LocalOscilatorFrequencyLowBand (
        ULONG       ulLOFLow
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_LNB_LOF_LOW_BAND,
                             &ulLOFLow,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put LNB Low Band Local Oscillator Frequency(0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::get_LocalOscilatorFrequencyLowBand (
        ULONG *     pulLOFLow
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::put_LocalOscilatorFrequencyHighBand (
        ULONG       ulLOFHigh
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_LNB_LOF_HIGH_BAND,
                             &ulLOFHigh,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put LNB High Band Local Oscillator Frequency(0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::get_LocalOscilatorFrequencyHighBand (
        ULONG *     pulLOFHigh
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::put_HighLowSwitchFrequency (
        ULONG       ulSwitchFrequency
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_LNB_SWITCH_FREQUENCY,
                             &ulSwitchFrequency,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put LNB High/Low Switch Frequency(0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::get_HighLowSwitchFrequency (
        ULONG *     pulSwitchFrequency
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::put_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->put_BdaNodeProperty(
                            __uuidof( IBDA_LNBInfo),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData
                            );

errExit:
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::get_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData,
    ULONG * pulcbBytesReturned
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->get_BdaNodeProperty(
                            __uuidof( IBDA_LNBInfo),
                            dwPropID,
                            (UCHAR *)pvPropData,
                            ulcbPropData,
                            pulcbBytesReturned
                            );

errExit:
    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdaplgin.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: BdaPlgIn.cpp
//
//  Abstract:
//
//    Implements BDA Device Plugin Component
//
//
////////////////////////////////////////////////////////////////////////////////////////////

#include "pch.h"



////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
typedef enum
{
    KSEVENT_BDA_DEVICE_EVENT,

} KSEVENT_BDA_DEVICE;


////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] =
{
    {   L"IBDA_DeviceControl",
        &IID_IBDA_DeviceControl,
        CBdaDeviceControlInterfaceHandler::CreateInstance,
        NULL,
        NULL
    },
    {   L"IBDA_PinControl",
        &IID_IBDA_PinControl,
        CBdaPinControlInterfaceHandler::CreateInstance,
        NULL,
        NULL
    },
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);


///////////////////////////////////////////////////////////////////////////////
//
// DllRegisterServer
//
// Exported entry points for registration and unregistration
//
STDAPI
DllRegisterServer (
    void
    )
{
    return AMovieDllRegisterServer2( TRUE );

}


///////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer (
    void
    )
///////////////////////////////////////////////////////////////////////////////
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer



///////////////////////////////////////////////////////////////////////////////
HRESULT
FindInterfaceOnGraph (
    IUnknown* pUnkGraph,
    REFIID riid,
    void **ppInterface
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = E_NOINTERFACE;

    CComPtr<IBaseFilter> pFilter;
    CComPtr<IEnumFilters> pEnum;
    ULONG ulFetched = 0;

    if(!ppInterface)
    {
        return E_FAIL;
    }

    *ppInterface= NULL;

    if(!pUnkGraph)
    {
        return E_FAIL;
    }

    CComQIPtr<IFilterGraph, &IID_IFilterGraph> pFilterGraph(pUnkGraph);

    hr = pFilterGraph->EnumFilters(&pEnum);
    if(!pEnum)
    {
        return hr;
    }

    //
    // find the first filter in the graph that supports riid interface
    //
    while(!*ppInterface && pEnum->Next(1, &pFilter, NULL) == S_OK)
    {
        hr = pFilter->QueryInterface(riid, ppInterface);
        pFilter.Release();
    }

    return hr;
}




////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CUnknown*
CALLBACK
CBdaDeviceControlInterfaceHandler::CreateInstance(
    LPUNKNOWN   pUnkOuter,
    HRESULT*    pHrStatus
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    CUnknown *pUnknown;

    pUnknown = new CBdaDeviceControlInterfaceHandler(
                       pUnkOuter,
                       NAME("IBDA_DeviceControl"),
                       pHrStatus
                       );
    if (!pUnknown)
    {
        *pHrStatus = E_OUTOFMEMORY;
    }

    return pUnknown;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CBdaDeviceControlInterfaceHandler::CBdaDeviceControlInterfaceHandler(
    LPUNKNOWN   pUnkOuter,
    TCHAR*      ptchName,
    HRESULT*    phrStatus
    ) :
    CUnknown( ptchName, pUnkOuter, phrStatus)
////////////////////////////////////////////////////////////////////////////////////////////
{
    IKsObject*   pKsObject = NULL;


    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "Bad outer IUnknown.\n")
              );
        *phrStatus = VFW_E_NEED_OWNER;
        goto exit;
    }

    //  Initialize members
    //
    m_ObjectHandle = NULL;
    m_EndEventHandle = NULL;
    m_pBaseFilter = NULL;
    m_pGraph = NULL;
    m_pNetProvider = NULL;


    //  Get the IKsObject interface on KSProxy so that we can communicate
    //  with the driver.
    //
    *phrStatus =  pUnkOuter->QueryInterface(
                          __uuidof(IKsObject),
                          reinterpret_cast<PVOID*>(&pKsObject)
                          );
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "Can't get IKSObject for device.\n")
              );
        goto errExit;
    }

    //  Get the interface to the DShow Filter.
    //
    *phrStatus =  pUnkOuter->QueryInterface(
                         __uuidof( IBaseFilter),
                         reinterpret_cast<PVOID*>(&m_pBaseFilter)
                         );
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "Can't get IBaseFilter for device.\n")
              );
        goto errExit;
    }

    //  Since we are an aggregated to the base filter we must not keep
    //  a reference to the basefilter.
    //
    //$REVIEW - Can we use this Interface or must we always QI and Release
    //
    m_pBaseFilter->Release();

    //  Get the handle of the device.
    //
    m_ObjectHandle = pKsObject->KsGetObjectHandle( );
    if (!m_ObjectHandle)
    {
        *phrStatus = E_UNEXPECTED;
        DbgLog( ( LOG_ERROR,
                  0,
                  "Can't get device handle.\n")
              );
        goto errExit;
    }


exit:
    RELEASE_AND_CLEAR( pKsObject);
    return;

errExit:
    RELEASE_AND_CLEAR( m_pBaseFilter);
    RELEASE_AND_CLEAR( m_pNetProvider);
    RELEASE_AND_CLEAR( m_pGraph);

    //$BUG  Close threads and devices

    goto exit;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CBdaDeviceControlInterfaceHandler::~CBdaDeviceControlInterfaceHandler (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    DbgLog(( LOG_TRACE,
             10,
             "In BdaPlugIn DeviceControl Destructor\n"
           ));


    RELEASE_AND_CLEAR( m_pBaseFilter);
    RELEASE_AND_CLEAR( m_pNetProvider);
    RELEASE_AND_CLEAR( m_pGraph);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    if (riid ==  __uuidof(IBDA_DeviceControl))
    {
        return GetInterface(static_cast<IBDA_DeviceControl*>(this), ppv);
    }
    else if (riid ==  __uuidof(IBDA_Topology))
    {
        return GetInterface(static_cast<IBDA_Topology*>(this), ppv);
    }

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::StartChanges(
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hResult = NOERROR;
    KSMETHOD    ksmStartChanges;
    ULONG       BytesReturned = 0;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> StartChanges.\n"
           ));

    ksmStartChanges.Set = KSMETHODSETID_BdaChangeSync;
    ksmStartChanges.Id = KSMETHOD_BDA_START_CHANGES;
    ksmStartChanges.Flags = KSMETHOD_TYPE_NONE;

    hResult = ::KsSynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_METHOD,
                    (PVOID) &ksmStartChanges,
                    sizeof(KSMETHOD),
                    NULL,
                    NULL,
                    &BytesReturned
                    );

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::CheckChanges(
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hResult = NOERROR;
    KSMETHOD    ksmCheckChanges;
    ULONG       BytesReturned = 0;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> CheckChanges.\n"
           ));

    ksmCheckChanges.Set = KSMETHODSETID_BdaChangeSync;
    ksmCheckChanges.Id = KSMETHOD_BDA_CHECK_CHANGES;
    ksmCheckChanges.Flags = KSMETHOD_TYPE_NONE;

    hResult = ::KsSynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_METHOD,
                    (PVOID) &ksmCheckChanges,
                    sizeof(KSMETHOD),
                    NULL,
                    NULL,
                    &BytesReturned
                    );

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::CommitChanges(
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hResult = NOERROR;
    KSMETHOD    ksmCommitChanges;
    ULONG       BytesReturned = 0;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> CommitChanges.\n"
           ));

    ksmCommitChanges.Set = KSMETHODSETID_BdaChangeSync;
    ksmCommitChanges.Id = KSMETHOD_BDA_COMMIT_CHANGES;
    ksmCommitChanges.Flags = KSMETHOD_TYPE_NONE;

    hResult = ::KsSynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_METHOD,
                    (PVOID) &ksmCommitChanges,
                    sizeof(KSMETHOD),
                    NULL,
                    NULL,
                    &BytesReturned
                    );

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetChangeState(
    ULONG *     pulChangeState
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hResult = NOERROR;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> GetChangeState.\n"
           ));

    *pulChangeState = 0;

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::Set (
     IN  PKSPROPERTY pBdaDeviceControl,
     OUT PVOID  pvBuffer,
     OUT PULONG pulcbSize
     )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG       BytesReturned = 0;
    HRESULT     hr            = NOERROR;

    hr = ::KsSynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                (PVOID) pBdaDeviceControl,
                sizeof(KSPROPERTY),
                pvBuffer,
                *pulcbSize,
                &BytesReturned);

    *pulcbSize = BytesReturned;

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::Get (
     IN  PKSPROPERTY pBdaDeviceControl,
     OUT PVOID  pvBuffer,
     OUT PULONG pulcbSize
     )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG       BytesReturned = 0;
    HRESULT     hr            = NOERROR;

    hr = ::KsSynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                (PVOID) pBdaDeviceControl,
                sizeof(KSPROPERTY),
                pvBuffer,
                *pulcbSize,
                &BytesReturned);

    *pulcbSize = BytesReturned;

    return hr;
}




////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CUnknown*
CALLBACK
CBdaPinControlInterfaceHandler::CreateInstance(
    LPUNKNOWN   pUnkOuter,
    HRESULT*    pHrStatus
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    CUnknown *pUnknown;

    pUnknown = new CBdaPinControlInterfaceHandler(
                       pUnkOuter,
                       NAME("IBDA_PinControl"),
                       pHrStatus
                       );
    if (!pUnknown)
    {
        *pHrStatus = E_OUTOFMEMORY;
    }

    return pUnknown;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CBdaPinControlInterfaceHandler::CBdaPinControlInterfaceHandler(
    LPUNKNOWN   pUnkOuter,
    TCHAR*      ptchName,
    HRESULT*    phrStatus
    ) :
    CUnknown( ptchName, pUnkOuter, phrStatus)
////////////////////////////////////////////////////////////////////////////////////////////
{
    IKsObject*              pKsObject = NULL;
    IPin *                  pPin = NULL;
    IPin *                  pConnectedPin = NULL;
    IBDA_NetworkProvider *  pNetProvider = NULL;
    IFilterGraph *          pGraph = NULL;
    IBaseFilter *           pBaseFilter = NULL;
    IUnknown *              pUnkDevice = NULL;
    PIN_INFO     pinInfoT;
    FILTER_INFO  filterInfoT;


    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Bad outer IUnknown.\n")
              );
        *phrStatus = VFW_E_NEED_OWNER;
        goto errExit;
    }

    //  Initialize members
    //
    m_ObjectHandle = NULL;

    m_pConnectedPin = NULL;

    m_pNetProvider = NULL;
    m_ulRegistrationCtx = 0;

    //  Get the IKsObject interface on KSProxy so that we can communicate
    //  with the driver.
    //
    *phrStatus =  pUnkOuter->QueryInterface(
                          __uuidof(IKsObject),
                          reinterpret_cast<PVOID*>(&pKsObject)
                          );
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get IKSObject for device.\n")
              );
        goto errExit;
    }


    //  Get an IPin interface for this pin
    //
    *phrStatus = pUnkOuter->QueryInterface( __uuidof( IPin), 
                                            (PVOID *) &pPin
                                            );
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get IPin for this pin.\n")
              );
        goto errExit;
    }


    //  First get the IUnknown for the recieving pin's filter.
    //
    *phrStatus = pPin->QueryPinInfo( &pinInfoT);
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get pin info for this pin.\n")
              );
        goto errExit;
    }
    pBaseFilter = pinInfoT.pFilter;
    if (!pBaseFilter)
    {
        *phrStatus = E_NOINTERFACE;
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get IBaseFilter for this filter.\n")
              );
        goto errExit;
    }

    //  Get a pointer the the graph that the filter is in.
    //
    *phrStatus = pBaseFilter->QueryFilterInfo( &filterInfoT);
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get filter info for this filter.\n")
              );
        goto errExit;
    }
    pGraph = filterInfoT.pGraph;
    if (!pGraph)
    {
        *phrStatus = E_NOINTERFACE;
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get graph for this filter.\n")
              );
        goto errExit;
    }

    //  Get a pointer to the network provider for this graph.
    //
    *phrStatus = FindInterfaceOnGraph( pGraph, 
                                       __uuidof( IBDA_NetworkProvider),
                                       (PVOID *) &pNetProvider
                                       );
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get network provider for this graph.\n")
              );
        goto errExit;
    }
    if (!pNetProvider)
    {
        *phrStatus = E_NOINTERFACE;
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get network provider for this graph.\n")
              );
        goto errExit;
    }


    if (pinInfoT.dir == PINDIR_INPUT)
    {
        //  Get the IUnknown for the filter that contains this pin.
        //
        *phrStatus = pBaseFilter->QueryInterface( __uuidof( IUnknown),
                                                  (PVOID *) &pUnkDevice
                                                  );
        if (FAILED(*phrStatus))
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaPinControl: Can't get IUnknown for filter.\n")
                  );
            goto errExit;
        }
        if (!pUnkDevice)
        {
            *phrStatus = E_NOINTERFACE;
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaPinControl: Can't get IUnknown for filter.\n")
                  );
            goto errExit;
        }
    
    
        //  Register this filter with the network provider.
        //
        *phrStatus = pNetProvider->RegisterDeviceFilter( pUnkDevice,
                                                         &m_ulRegistrationCtx
                                                         );
        if (FAILED( *phrStatus))
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaPinControl: Can't register filter with network provider.\n")
                  );
            goto errExit;
        }
    }
    else
    {
        //  Keep track of the connected device so that we can
        //  unregister it on disconnect
        //
        *phrStatus = pPin->ConnectedTo( &pConnectedPin);
        if (FAILED( *phrStatus))
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaPinControl: Can't get connected pin.\n")
                  );
            goto errExit;
        }
    }


    //  Get the handle of the device.
    //
    m_ObjectHandle = pKsObject->KsGetObjectHandle( );
    if (!m_ObjectHandle)
    {
        *phrStatus = E_UNEXPECTED;
        DbgLog( ( LOG_ERROR,
                  0,
                  "Can't get device handle.\n")
              );
        goto errExit;
    }

    m_pNetProvider = pNetProvider;
    pNetProvider = NULL;

    m_pConnectedPin = pConnectedPin;
    pConnectedPin = NULL;


errExit:
    RELEASE_AND_CLEAR( pKsObject);
    RELEASE_AND_CLEAR( pPin);
    RELEASE_AND_CLEAR( pGraph);
    RELEASE_AND_CLEAR( pBaseFilter);
    RELEASE_AND_CLEAR( pUnkDevice);
    RELEASE_AND_CLEAR( pNetProvider);
    RELEASE_AND_CLEAR( pConnectedPin);
    return;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CBdaPinControlInterfaceHandler::~CBdaPinControlInterfaceHandler (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT                 hrStatus = NOERROR;
    IBDA_PinControl *       pPinControl = NULL;

    DbgLog(( LOG_TRACE,
             10,
             "~CBdaPinControlInterfaceHandler: In BdaPlgIn PinControl Destructor\n"
          ));

    if (m_pConnectedPin && m_pNetProvider)
    {

        hrStatus = m_pConnectedPin->QueryInterface( 
                                        __uuidof( IBDA_PinControl),
                                        (PVOID *) &pPinControl
                                        );
        if (!FAILED( hrStatus) && pPinControl)
        {
            ULONG                   ulRegistrationCtx;

             hrStatus = pPinControl->RegistrationContext( 
                                        &ulRegistrationCtx
                                        );
             if (!FAILED( hrStatus))
             {
                 m_pNetProvider->UnRegisterDeviceFilter( 
                                        ulRegistrationCtx
                                        );
             }
        }
        else
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaPinControl: Can't get IBDA_PinControl for connected pin.\n")
                  );
        }
    }

    RELEASE_AND_CLEAR( m_pNetProvider);
    RELEASE_AND_CLEAR( m_pConnectedPin);
    RELEASE_AND_CLEAR( pPinControl);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaPinControlInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    if (riid ==  __uuidof(IBDA_PinControl))
    {
        return GetInterface(static_cast<IBDA_PinControl*>(this), ppv);
    }
#ifdef PROPERTY_PAGES
    else if (riid ==  IID_ISpecifyPropertyPages)
    {
        return GetInterface(static_cast<ISpecifyPropertyPages *>(this), ppv);
    }
#endif // PROPERTY_PAGES

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

#ifdef PROPERTY_PAGES
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaPinControlInterfaceHandler::GetPages (
    CAUUID * pPages
    )
///////////////////////////////////////////////////////////////////////////////
{
    pPages->cElems = 1 ;

    pPages->pElems = (GUID *) CoTaskMemAlloc( pPages->cElems * sizeof( GUID));

    if (pPages->pElems == NULL)
    {
        return E_OUTOFMEMORY;
    }

    (pPages->pElems)[0] = CLSID_BDAFrequecyFilterPropertyPage;

    return NOERROR;
}
#endif // PROPERTY_PAGES

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaPinControlInterfaceHandler::GetPinID (
    ULONG *     pulPinID
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspPinID;
    ULONG           ulcbReturned = 0;

    kspPinID.Set = KSPROPSETID_BdaPinControl;
    kspPinID.Id = KSPROPERTY_BDA_PIN_ID;
    kspPinID.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspPinID,
                     sizeof( KSPROPERTY),
                     (PVOID) pulPinID,
                     sizeof( ULONG),
                     &ulcbReturned
                     );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaPinControlInterfaceHandler::GetPinType (
    ULONG *     pulPinType
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspPinType;
    ULONG           ulcbReturned = 0;

    kspPinType.Set = KSPROPSETID_BdaPinControl;
    kspPinType.Id = KSPROPERTY_BDA_PIN_TYPE;
    kspPinType.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspPinType,
                     sizeof( KSPROPERTY),
                     (PVOID) pulPinType,
                     sizeof( ULONG),
                     &ulcbReturned
                     );

    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdasignl.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


////////////////////////////////////////////////////////////////////////////////
//
// BDA Signal Statistics class
//
class CBdaSignalStatistics :
    public CUnknown,
    public IBDA_SignalStatistics
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    CBdaSignalStatistics (
        IUnknown *              pUnkOuter,
        CBdaControlNode *       pControlNode
        );

    ~CBdaSignalStatistics ( );

    //
    //  IBDA_SignalStatistics
    //
    STDMETHODIMP
    put_SignalStrength (
        LONG        lDbStrength
        );
    
    STDMETHODIMP
    get_SignalStrength (
        LONG *      plDbStrength
        );
    
    STDMETHODIMP
    put_SignalQuality (
        LONG        lPercentQuality
        );
    
    STDMETHODIMP
    get_SignalQuality (
        LONG *      plPercentQuality
        );
    
    STDMETHODIMP
    put_SignalPresent (
        BOOLEAN     fPresent
        );
    
    STDMETHODIMP
    get_SignalPresent (
        BOOLEAN *   pfPresent
        );
    
    STDMETHODIMP
    put_SignalLocked (
        BOOLEAN     fLocked
        );
    
    STDMETHODIMP
    get_SignalLocked (
        BOOLEAN *   pfLocked
        );
    
    STDMETHODIMP
    put_SampleTime (
        LONG        lmsSampleTime
        );
    
    STDMETHODIMP
    get_SampleTime (
        LONG *      plmsSampleTime
        );

    //
    //  Utility Methods
    //

    STDMETHODIMP
    put_KsProperty(
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData
        );

    STDMETHODIMP
    get_KsProperty (
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData,
        ULONG * pulcbBytesReturned
        );

private:

    IUnknown *                          m_pUnkOuter;
    CBdaControlNode *                   m_pControlNode;
    CCritSec                            m_FilterLock;
};


////////////////////////////////////////////////////////////////////////////////
//
// SignalProperties Filter class
//
class CSignalProperties :
    public IBDA_SignalProperties
{

public:

    STDMETHODIMP
    PutNetworkType (
        REFGUID     guidNetworkType
        );

    STDMETHODIMP
    GetNetworkType (
        GUID *      pguidNetworkType
        );

    STDMETHODIMP
    PutSignalSource (
        ULONG       ulSignalSource
        );

    STDMETHODIMP
    GetSignalSource (
        ULONG *     pulSignalSource
        );

    STDMETHODIMP
    PutTuningSpace (
        REFGUID     guidTuningSpace
        );

    STDMETHODIMP
    GetTuningSpace (
        GUID *      pguidTuingSpace
        );

private:

    CCritSec        m_FilterLock;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdaplgin.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: BdaPlgIn.h
//
//  Abstract:
//
//    Internal header
//
//
/////////////////////////////////////////////////////////////////////////////////


class CBdaDeviceControlInterfaceHandler :
    public CUnknown,
    public IBDA_DeviceControl,
    public IBDA_Topology
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
            LPUNKNOWN UnkOuter,
            HRESULT* hr
            );

    STDMETHODIMP StartChanges(
            void
            );

    STDMETHODIMP CheckChanges(
            void
            );

    STDMETHODIMP CommitChanges(
            void
            );

    STDMETHODIMP GetChangeState(
            ULONG *     pState
            );

    STDMETHODIMP
    GetNodeTypes (
        ULONG *     pulcNodeTypes,
        ULONG       ulcMaxElements,
        ULONG       rgulNodeTypes[]
        );

    STDMETHODIMP
    GetNodeDescriptors (
        ULONG *                     pulcElements,
        ULONG                       ulcElementsMax,
        BDANODE_DESCRIPTOR          rgNodeDescriptors[]
        );


    STDMETHODIMP
    GetNodeInterfaces (
        ULONG       ulNodeType,
        ULONG *     pulcInterfaces,
        ULONG       ulcmaxElements,
        GUID        rgguidInterfaces[]
        );

    STDMETHODIMP
    GetPinTypes (
        ULONG *     pulcPinTypes,
        ULONG       ulcMaxElements,
        ULONG       rgulPinTypes[]
        );

    STDMETHODIMP
    GetTemplateConnections (
        ULONG *                     pulcConnections,
        ULONG                       ulcMaxElements,
        BDA_TEMPLATE_CONNECTION     rgConnections[]
        );

    STDMETHODIMP
    CreatePin (
        ULONG       ulPinType,
        ULONG *     pulPinId
        );

    STDMETHODIMP
    DeletePin (
        ULONG       ulPinId
        );

    STDMETHODIMP
    SetMediaType (
        ULONG           ulPinId,
        AM_MEDIA_TYPE * pMediaType
        );

    STDMETHODIMP
    SetMedium (
        ULONG           ulPinId,
        REGPINMEDIUM *  pMedium
        );

    STDMETHODIMP
    CreateTopology (
        ULONG           ulInputPinId,
        ULONG           ulOutputPinId
        );

    STDMETHODIMP
    GetControlNode (
        ULONG           ulInputPinId,
        ULONG           ulOutputPinId,
        ULONG           ulNodeType,
        IUnknown**      ppControlNode
        );

private:

    CBdaDeviceControlInterfaceHandler(
            LPUNKNOWN UnkOuter,
            TCHAR* Name,
            HRESULT* hr
            );

    ~CBdaDeviceControlInterfaceHandler (
            void
            );

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID riid,
            PVOID* ppv
            );

    STDMETHODIMP EnableEvent (
            const GUID *pInterfaceGuid,
            ULONG ulId
            );

    STDMETHODIMP Set (
            IN  PKSPROPERTY  pBdaDeviceControl,
            OUT PVOID  pvBuffer,
            OUT PULONG pulcbSize
            );

    STDMETHODIMP Get (
            IN  PKSPROPERTY pBdaDeviceControl,
            OUT PVOID  pvBuffer,
            OUT PULONG pulcbSize
            );

private:

    HANDLE                  m_ObjectHandle;
    HANDLE                  m_EndEventHandle;
    KSEVENTDATA             m_EventData;
    IFilterGraph*           m_pGraph;
    IBaseFilter*            m_pBaseFilter;
    IBDA_NetworkProvider *  m_pNetProvider;
};


class CBdaPinControlInterfaceHandler :
    public CUnknown,
#ifdef PROPERTY_PAGES
    public ISpecifyPropertyPages,
#endif // PROPERTY_PAGES
    public IBDA_PinControl
{

public:

    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
            LPUNKNOWN UnkOuter,
            HRESULT* hr
            );

    STDMETHODIMP
    RegistrationContext(
        ULONG *     pRegistrationCtx
        )
    {
        if (!pRegistrationCtx)
        {
            return E_POINTER;
        }
        if (!m_ulRegistrationCtx)
        {
            return E_FAIL;
        }

        *pRegistrationCtx = m_ulRegistrationCtx;

        return NOERROR;
    }

    STDMETHODIMP
    GetPinID (
        ULONG *     pulPinID
        );

    STDMETHODIMP
    GetPinType (
        ULONG *     pulPinID
        );

#ifdef PROPERTY_PAGES
    STDMETHODIMP
    GetPages (
        CAUUID * pPages
        ) ;
#endif // PROPERTY_PAGES

private:

    CBdaPinControlInterfaceHandler(
            LPUNKNOWN UnkOuter,
            TCHAR* Name,
            HRESULT* hr
            );

    ~CBdaPinControlInterfaceHandler (
            void
            );

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID riid,
            PVOID* ppv
            );

private:

    HANDLE                  m_ObjectHandle;

    IPin *                  m_pConnectedPin;

    IBDA_NetworkProvider *  m_pNetProvider;
    ULONG                   m_ulRegistrationCtx;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdasignl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"



////////////////////////////////////////////////////////////////////////////////
//
// BDA Signal Properties class
//
////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::PutNetworkType (
    REFGUID     guidNetworkType
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::GetNetworkType (
    GUID *      pguidNetworkType
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::PutSignalSource (
    ULONG       ulSignalSource
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::GetSignalSource (
    ULONG *     pulSignalSource
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::PutTuningSpace (
    REFGUID     guidTuningSpace
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::GetTuningSpace (
    GUID *      pguidTuningSpace
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}



////////////////////////////////////////////////////////////////////////////////
//
// BDA Signal Statistics class
//
////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
CBdaSignalStatistics::CBdaSignalStatistics (
    IUnknown *              pUnkOuter,
    CBdaControlNode *       pControlNode
    ) :
    CUnknown( NAME( "IBDA_SignalStatistics"), pUnkOuter, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;

    ASSERT( pUnkOuter);

    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: No parent specified.\n")
              );

        return;
    }

    //  Initialize Members
    //
    m_pUnkOuter = pUnkOuter;
    m_pControlNode = pControlNode;
}


///////////////////////////////////////////////////////////////////////////////
CBdaSignalStatistics::~CBdaSignalStatistics ( )
///////////////////////////////////////////////////////////////////////////////
{
    m_pUnkOuter = NULL;
    m_pControlNode = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_SignalStrength (
    LONG        lDbStrength
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_SignalStrength (
    LONG *      plDbStrength
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;
    ULONG       ulcbReturned;

    hrStatus = get_KsProperty(
                             KSPROPERTY_BDA_SIGNAL_STRENGTH,
                             plDbStrength,
                             sizeof( LONG),
                             &ulcbReturned
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get signal strength (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_SignalQuality (
    LONG        lPercentQuality
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_SignalQuality (
    LONG *      plPercentQuality
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;
    ULONG       ulcbReturned;

    hrStatus = get_KsProperty(
                             KSPROPERTY_BDA_SIGNAL_QUALITY,
                             plPercentQuality,
                             sizeof( LONG),
                             &ulcbReturned
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get signal quality (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_SignalPresent (
    BOOLEAN     fPresent
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_SignalPresent (
    BOOLEAN *   pfPresent
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;
    ULONG       ulcbReturned;

    hrStatus = get_KsProperty(
                             KSPROPERTY_BDA_SIGNAL_PRESENT,
                             pfPresent,
                             sizeof( BOOLEAN),
                             &ulcbReturned
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get signal present (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_SignalLocked (
    BOOLEAN     fLocked
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_SignalLocked (
    BOOLEAN *   pfLocked
    )
///////////////////////////////////////////////////////////////////////////////
{
    ULONG       ulcbReturned;
    HRESULT     hrStatus = E_NOINTERFACE;

    hrStatus = get_KsProperty(
                             KSPROPERTY_BDA_SIGNAL_LOCKED,
                             pfLocked,
                             sizeof( BOOLEAN),
                             &ulcbReturned
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get signal locked (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_SampleTime (
    LONG        lmsSampleTime
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_SAMPLE_TIME,
                             &lmsSampleTime,
                             sizeof( LONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get signal locked (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_SampleTime (
    LONG *      plmsSampleTime
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;
    ULONG       ulcbReturned;

    hrStatus = get_KsProperty(
                             KSPROPERTY_BDA_SAMPLE_TIME,
                             plmsSampleTime,
                             sizeof( LONG),
                             &ulcbReturned
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get sample time (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->put_BdaNodeProperty(
                            __uuidof( IBDA_SignalStatistics),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData
                            );

errExit:
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData,
    ULONG * pulcbBytesReturned
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->get_BdaNodeProperty(
                            __uuidof( IBDA_SignalStatistics),
                            dwPropID,
                            (UCHAR *)pvPropData,
                            ulcbPropData,
                            pulcbBytesReturned
                            );

errExit:
    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdatopgy.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


////////////////////////////////////////////////////////////////////////////////
//
// BDA Control Node class
//
class CBdaControlNode :
    public CUnknown,
    public IBDA_KSNode
{
    friend class CBdaDeviceControlInterfaceHandler;
    friend class CBdaFrequencyFilter;
    friend class CBdaDigitalDemodulator;

public:

    DECLARE_IUNKNOWN;

    CBdaControlNode (
        CBdaDeviceControlInterfaceHandler * pOwner,
        ULONG                               ulControllingPinID,
        ULONG                               ulNodeType
        );

    ~CBdaControlNode ( );

    STDMETHODIMP
    NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv
        );

    //
    //  IBDA_KSNode
    //

    STDMETHODIMP
    ControllingPin( );

    STDMETHODIMP
    CBdaControlNode::put_BdaNodeProperty(
        REFGUID     refguidPropSet,
        ULONG       ulPropertyId,
        UCHAR*      pbPropertyData, 
        ULONG       ulcbPropertyData
        );

    STDMETHODIMP
    CBdaControlNode::get_BdaNodeProperty(
        REFGUID     refguidPropSet,
        ULONG       ulPropertyId,
        UCHAR*      pbPropertyData, 
        ULONG       ulcbPropertyData, 
        ULONG*      pulcbBytesReturned
        );


private:

    CCritSec                            m_FilterLock;

    IBaseFilter *                       m_pBaseFilter;
#ifdef NEVER
    HANDLE                              m_ObjectHandle;
#endif // NEVER

    ULONG                               m_ulNodeType;
    ULONG                               m_ulControllingPinId;
    IPin *                              m_pControllingPin;
    IKsPropertySet *                    m_pIKsPropertySet;

    CBdaFrequencyFilter *               m_pFrequencyFilter;
    CBdaLNBInfo *                       m_pLNBInfo;
    CBdaDigitalDemodulator *            m_pDigitalDemodulator;
    CBdaConditionalAccess *             m_pConditionalAccess;
    IBDA_SignalStatistics *             m_pSignalStatistics;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled header for BdaPlgIn.ax

--*/

// Windows
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <memory.h>
#include <stdio.h>

// DShow
#include <streams.h>
#include <amstream.h>
#include <dvdmedia.h>

// DDraw
#include <ddraw.h>
#include <ddkernel.h>

// KS
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>

#include <atlbase.h>
#include <strmif.h>

#include <BdaTypes.h>
#include <BdaMedia.h>
#include <BdaIface.h>
#include "BdaRcvr.h"

//  ---------------------------------------------------------------------------
//      MACROS
//  ---------------------------------------------------------------------------

#define RELEASE_AND_CLEAR(punk)         if (punk) { (punk)->Release(); (punk) = NULL; }
#define DELETE_RESET(p)                 if (p) { delete (p); (p) = NULL ; }
#define DELETE_RESET_COM(p)             if (p) { CoTaskMemFree (p); (p) = NULL ; }
#define CLOSE_RESET_HANDLE(h)           if ((h) != NULL) { CloseHandle (h); (h) = NULL ;}
#define CLOSE_RESET_REG_KEY(r)          if ((r) != NULL) { RegCloseKey (r); (r) = NULL ;}
#define GOTO_NE(v,c,l)                  if ((v) != (c)) { ERROR_SPEW(v,!=,c) ; goto l ; }
#define GOTO_EQ(v,c,l)                  if ((v) == (c)) { ERROR_SPEW(v,==,c) ; goto l ; }
#define GOTO_NE_SET(v,c,l,h,r)          if ((v) != (c)) { (h) = (r) ; ERROR_SPEW(v,!=,c) ; goto l ; }
#define GOTO_EQ_SET(v,c,l,h,r)          if ((v) == (c)) { (h) = (r) ; ERROR_SPEW(v,==,c) ; goto l ; }
#define DIV_ROUND_UP_MAYBE(num,den)     ((num) / (den) + ((num) % (den) ? 1 : 0))
#define MIN(a,b)                        ((a) < (b) ? (a) : (b))
#define MAX(a,b)                        ((a) > (b) ? (a) : (b))
#define IN_RANGE(v,min,max)             (((min) <= (v)) && ((v) <= (max)))

#define NE_ERROR_RET(v,c)               ERROR_RET(v,!=,c)
#define EQ_ERROR_RET(v,c)               ERROR_RET(v,==,c)
#define NE_ERROR_RET_VAL(v,c,r)         ERROR_RET_VAL(v,!=,c,r)
#define EQ_ERROR_RET_VAL(v,c,r)         ERROR_RET_VAL(v,==,c,r)
#define NE_ERROR_RET_EX(v,c,m)          ERROR_RET_EX(v,!=,c,m)
#define EQ_ERROR_RET_EX(v,c,m)          ERROR_RET_EX(v,==,c,m)
#define NE_ERROR_RET_VAL_EX(v,c,r,m)    ERROR_RET_VAL_EX(v,!=,c,r,m)
#define EQ_ERROR_RET_VAL_EX(v,c,r,m)    ERROR_RET_VAL_EX(v,==,c,r,m)

//  empty if-clauses should be otpimized out in release builds
#define NE_SPEW(v,c,m)                  if ((v) != (c)) ERROR_SPEW_EX(v,!=,c,m)
#define EQ_SPEW(v,c,m)                  if ((v) == (c)) ERROR_SPEW_EX(v,==,c,m)

////////////////////////////////////////////////////////////////////////////////
//
// Forward declarations
//
class CBdaDeviceControlInterfaceHandler;
class CBdaControlNode;
class CBdaFrequencyFilter;
class CBdaLNBInfo;
class CBdaDigitalDemodulator;
class CBdaConditionalAccess;

#include "BdaTopgy.h"
#include "BdaSignl.h"
#include "BdaFreq.h"
#include "BdaDemod.h"
#include "BdaCA.h"
#include "BdaPlgIn.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\bdatopgy.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetNodeTypes (
    ULONG *     pulcElements,
    ULONG       ulcMaxElements,
    ULONG       rgulNodeTypes[]
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      ksProperty;
    ULONG           ulcbReturned = 0;

    ksProperty.Set = KSPROPSETID_BdaTopology;
    ksProperty.Id = KSPROPERTY_BDA_NODE_TYPES;
    ksProperty.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &ksProperty,
                     sizeof( KSPROPERTY),
                     (PVOID) rgulNodeTypes,
                     ulcMaxElements * sizeof( ULONG),
                     &ulcbReturned
                     );

    *pulcElements = (ulcbReturned + sizeof( ULONG) - 1) / sizeof( ULONG);
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetNodeDescriptors (
    ULONG *                 pulcElements,
    ULONG                   ulcMaxElements,
    BDANODE_DESCRIPTOR      rgulNodeDescriptors[]
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      ksProperty;
    ULONG           ulcbReturned = 0;

    ksProperty.Set = KSPROPSETID_BdaTopology;
    ksProperty.Id = KSPROPERTY_BDA_NODE_DESCRIPTORS;
    ksProperty.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &ksProperty,
                     sizeof( KSPROPERTY),
                     (PVOID) rgulNodeDescriptors,
                     ulcMaxElements * sizeof( BDANODE_DESCRIPTOR),
                     &ulcbReturned
                     );

    *pulcElements = (ulcbReturned + sizeof( BDANODE_DESCRIPTOR) - 1) / sizeof( BDANODE_DESCRIPTOR);
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetNodeInterfaces (
    ULONG       ulNodeType,
    ULONG *     pulcElements,
    ULONG       ulcMaxElements,
    GUID        rgguidInterfaces[]
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSP_NODE        kspNode;
    ULONG           ulcbReturned = 0;

    kspNode.Property.Set = KSPROPSETID_BdaTopology;
    kspNode.Property.Id = KSPROPERTY_BDA_NODE_PROPERTIES;
    kspNode.Property.Flags = KSPROPERTY_TYPE_GET;
    kspNode.NodeId = ulNodeType;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspNode,
                     sizeof( KSP_NODE),
                     (PVOID) rgguidInterfaces,
                     ulcMaxElements * sizeof( GUID),
                     &ulcbReturned
                     );

    *pulcElements = (ulcbReturned + sizeof( GUID) - 1) / sizeof( GUID);
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetPinTypes (
    ULONG *     pulcPinTypes,
    ULONG       ulcMaxElements,
    ULONG       rgulPinTypes[]
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspPinTypes;
    ULONG           ulcbReturned = 0;

    kspPinTypes.Set = KSPROPSETID_BdaTopology;
    kspPinTypes.Id = KSPROPERTY_BDA_PIN_TYPES;
    kspPinTypes.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspPinTypes,
                     sizeof( KSPROPERTY),
                     (PVOID) rgulPinTypes,
                     ulcMaxElements * sizeof( ULONG),
                     &ulcbReturned
                     );

    *pulcPinTypes = (ulcbReturned + sizeof( ULONG) - 1) / sizeof( ULONG);
    return hrStatus;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetTemplateConnections (
    ULONG *                     pulcConnections,
    ULONG                       ulcMaxElements,
    BDA_TEMPLATE_CONNECTION     rgConnections[]
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspConnections;
    ULONG           ulcbReturned = 0;

    kspConnections.Set = KSPROPSETID_BdaTopology;
    kspConnections.Id = KSPROPERTY_BDA_TEMPLATE_CONNECTIONS;
    kspConnections.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspConnections,
                     sizeof( KSPROPERTY),
                     (PVOID) rgConnections,
                     ulcMaxElements * sizeof( BDA_TEMPLATE_CONNECTION),
                     &ulcbReturned
                     );

    *pulcConnections =  (ulcbReturned + sizeof( BDA_TEMPLATE_CONNECTION) - 1)
                      / sizeof( BDA_TEMPLATE_CONNECTION);
    return hrStatus;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::CreatePin (
    ULONG       ulPinType,
    ULONG *     pulPinId
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hResult = NOERROR;
    KSM_BDA_PIN ksmCreatePin;
    ULONG       BytesReturned = 0;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> CreatePin.\n"
           ));

    ksmCreatePin.Method.Set = KSMETHODSETID_BdaDeviceConfiguration;
    ksmCreatePin.Method.Id = KSMETHOD_BDA_CREATE_PIN_FACTORY;
    ksmCreatePin.Method.Flags = KSMETHOD_TYPE_NONE;
    ksmCreatePin.PinType = ulPinType;
    
    hResult = ::KsSynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_METHOD,
                    (PVOID) &ksmCreatePin,
                    sizeof(KSM_BDA_PIN),
                    pulPinId,
                    sizeof( ULONG),
                    &BytesReturned
                    );

    *pulPinId = ksmCreatePin.PinId;

    return hResult;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::DeletePin (
    ULONG       ulPinId
    )
///////////////////////////////////////////////////////////////////////////////
{
    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::SetMediaType (
    ULONG           ulPinId,
    AM_MEDIA_TYPE * pMediaType
    )
///////////////////////////////////////////////////////////////////////////////
{
    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::SetMedium (
    ULONG           ulPinId,
    REGPINMEDIUM *  pMedium
    )
///////////////////////////////////////////////////////////////////////////////
{
    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::CreateTopology (
    ULONG           ulInputPinId,
    ULONG           ulOutputPinId
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hResult = NOERROR;
    KSM_BDA_PIN_PAIR    ksmCreateTopology;
    ULONG               BytesReturned = 0;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> CreateTopology.\n"
           ));

    ksmCreateTopology.Method.Set = KSMETHODSETID_BdaDeviceConfiguration;
    ksmCreateTopology.Method.Id = KSMETHOD_BDA_CREATE_TOPOLOGY;
    ksmCreateTopology.Method.Flags = KSMETHOD_TYPE_NONE;
    ksmCreateTopology.InputPinId = ulInputPinId;
    ksmCreateTopology.OutputPinId = ulOutputPinId;
    
    hResult = ::KsSynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_METHOD,
                    (PVOID) &ksmCreateTopology,
                    sizeof(KSM_BDA_PIN_PAIR),
                    NULL,
                    0,
                    &BytesReturned
                    );

    return hResult;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetControlNode (
    ULONG           ulInputPinId,
    ULONG           ulOutputPinId,
    ULONG           ulNodeType,
    IUnknown**      ppControlNode
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = NOERROR;
    IPin*               pInputPin = NULL;
    IPin*               pOutputPin = NULL;
    KSP_BDA_NODE_PIN    kspControllingPinId;
    ULONG               ulControllingPinId;
    ULONG               ulcbReturned;
    CBdaControlNode *   pControlNode = NULL;

    //  Query the filter to determine on which pin to access the
    //  node type.
    //

    kspControllingPinId.Property.Set = KSPROPSETID_BdaTopology;
    kspControllingPinId.Property.Id = KSPROPERTY_BDA_CONTROLLING_PIN_ID;
    kspControllingPinId.Property.Flags = KSPROPERTY_TYPE_GET;
    kspControllingPinId.ulNodeType = ulNodeType;
    kspControllingPinId.ulInputPinId = ulInputPinId;
    kspControllingPinId.ulOutputPinId = ulOutputPinId;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspControllingPinId,
                     sizeof( KSP_BDA_NODE_PIN),
                     (PVOID) &ulControllingPinId,
                     sizeof( ULONG),
                     &ulcbReturned
                     );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "GetControlNode: No controlling pin found.\n")
              );
        goto errExit;
    }

    pControlNode = new CBdaControlNode( this,
                                        ulControllingPinId,
                                        ulNodeType
                                        );
    if (!pControlNode)
    {
        hrStatus = E_OUTOFMEMORY;
        DbgLog( ( LOG_ERROR,
                  0,
                  "GetControlNode: Can't create control node.\n")
              );
        goto errExit;
    }

    hrStatus = GetInterface( (IUnknown *) pControlNode,
                             (PVOID *) ppControlNode
                             );

errExit:

    return hrStatus;
}



///////////////////////////////////////////////////////////////////////////////
CBdaControlNode::CBdaControlNode (
    CBdaDeviceControlInterfaceHandler * pOwner,
    ULONG                               ulControllingPinId,
    ULONG                               ulNodeType
    ) :
    CUnknown( NAME("IBDA_ControlNode"), NULL, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    WCHAR           pstrPinId[16];

    ASSERT( pOwner);
    ASSERT( pOwner->m_pBaseFilter);

    if (!pOwner || !pOwner->m_pBaseFilter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaControlNode: No parent specified.\n")
              );

        return;
    }

    //  Initialize Members
    //
    m_pBaseFilter = pOwner->m_pBaseFilter;
    m_ulControllingPinId = ulControllingPinId;
    m_ulNodeType = ulNodeType;
    m_pControllingPin = NULL;
    m_pIKsPropertySet = NULL;
    m_pFrequencyFilter = NULL;
    m_pLNBInfo = NULL;
    m_pDigitalDemodulator = NULL;
    m_pConditionalAccess = NULL;
    m_pSignalStatistics = NULL;

    //  Try to open the controlling pin.
    //
    ControllingPin();
}

///////////////////////////////////////////////////////////////////////////////
CBdaControlNode::~CBdaControlNode ( )
///////////////////////////////////////////////////////////////////////////////
{
    RELEASE_AND_CLEAR( m_pControllingPin);
    RELEASE_AND_CLEAR( m_pIKsPropertySet);
    DELETE_RESET( m_pFrequencyFilter);
    DELETE_RESET( m_pLNBInfo);
    DELETE_RESET( m_pDigitalDemodulator);
    DELETE_RESET( m_pConditionalAccess);
    DELETE_RESET( m_pSignalStatistics);
    m_pBaseFilter = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaControlNode::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = NOERROR;

    if (!ppv)
    {
        return E_POINTER;
    }

    if (riid ==  __uuidof(IBDA_FrequencyFilter))
    {
        if (!m_pFrequencyFilter)
        {
            IUnknown *      pUnkMe = NULL;

            hrStatus = GetInterface( (IUnknown *) this, (PVOID *) &pUnkMe);
            if (FAILED(hrStatus))
            {
                return hrStatus;
            }

            m_pFrequencyFilter = new CBdaFrequencyFilter(
                                            pUnkMe,
                                            this
                                            );
            RELEASE_AND_CLEAR( pUnkMe);
        }

        if (m_pFrequencyFilter)
        {
            return GetInterface(static_cast<IBDA_FrequencyFilter*>(m_pFrequencyFilter), ppv);
        }
    }

    else if (riid ==  __uuidof(IBDA_LNBInfo))
    {
        if (!m_pLNBInfo)
        {
            IUnknown *      pUnkMe = NULL;

            hrStatus = GetInterface( (IUnknown *) this, (PVOID *) &pUnkMe);
            if (FAILED(hrStatus))
            {
                return hrStatus;
            }

            m_pLNBInfo = new CBdaLNBInfo(
                                    pUnkMe,
                                    this
                                    );
            RELEASE_AND_CLEAR( pUnkMe);
        }

        if (m_pLNBInfo)
        {
            return GetInterface(static_cast<IBDA_LNBInfo*>(m_pLNBInfo), ppv);
        }
    }

    else if (riid ==  __uuidof(IBDA_DigitalDemodulator))
    {
        if (!m_pDigitalDemodulator)
        {
            IUnknown *      pUnkMe = NULL;

            hrStatus = GetInterface( (IUnknown *) this, (PVOID *) &pUnkMe);
            if (FAILED(hrStatus))
            {
                return hrStatus;
            }

            m_pDigitalDemodulator = new CBdaDigitalDemodulator(
                                            pUnkMe,
                                            this
                                            );
            RELEASE_AND_CLEAR( pUnkMe);
        }

        if (m_pDigitalDemodulator)
        {
            return GetInterface(static_cast<IBDA_DigitalDemodulator*>(m_pDigitalDemodulator), ppv);
        }
    }

    else if (riid ==  __uuidof(IBDA_Mpeg2CA))
    {
        if (!m_pConditionalAccess)
        {
            IUnknown *      pUnkMe = NULL;

            hrStatus = GetInterface( (IUnknown *) this, (PVOID *) &pUnkMe);
            if (FAILED(hrStatus))
            {
                return hrStatus;
            }

            m_pConditionalAccess = new CBdaConditionalAccess(
                                            pUnkMe,
                                            this
                                            );
            RELEASE_AND_CLEAR( pUnkMe);
        }

        if (m_pConditionalAccess)
        {
            return GetInterface(static_cast<IBDA_Mpeg2CA*>(m_pConditionalAccess), ppv);
        }
    }

    else if (riid ==  __uuidof(IBDA_SignalStatistics))
    {
        if (!m_pConditionalAccess)
        {
            IUnknown *      pUnkMe = NULL;

            hrStatus = GetInterface( (IUnknown *) this, (PVOID *) &pUnkMe);
            if (FAILED(hrStatus))
            {
                return hrStatus;
            }

            m_pSignalStatistics = new CBdaSignalStatistics(
                                            pUnkMe,
                                            this
                                            );
            RELEASE_AND_CLEAR( pUnkMe);
        }

        if (m_pSignalStatistics)
        {
            return GetInterface(static_cast<IBDA_SignalStatistics*>(m_pSignalStatistics), ppv);
        }
    }

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaControlNode::ControllingPin(
    void
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = NOERROR;
    WCHAR       pstrPinId[32];

    if (!m_pControllingPin)
    {
        //  Try to open the controlling pin for this node.
        //
        swprintf( pstrPinId, L"%u", m_ulControllingPinId);
        hrStatus = m_pBaseFilter->FindPin( pstrPinId,
                                           &m_pControllingPin
                                           );
        if (FAILED( hrStatus) || !m_pControllingPin)
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaControlNode::ControllingPin: Can't open controlling IPin.\n")
                  );
            m_pControllingPin = NULL;
        }
    }

    //  Open an IKSPropertySet interface on the object if we don't
    //  already have one.
    //
    if (m_pControllingPin && !m_pIKsPropertySet)
    {
        hrStatus = m_pControllingPin->QueryInterface(
                                          __uuidof( IKsPropertySet),
                                          (PVOID *) &m_pIKsPropertySet
                                          );
        if (FAILED(hrStatus) || !m_pIKsPropertySet)
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaControlNode::ControllingPin: Can't get IKsPropertySet.\n")
                  );
            m_pIKsPropertySet = NULL;
        }
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaControlNode::put_BdaNodeProperty(
    REFGUID     refguidPropSet,
    ULONG       ulPropertyId,
    UCHAR*      pbPropertyData, 
    ULONG       ulcbPropertyData
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = NOERROR;
    KSP_NODE    nodeProperty;

    //  Make sure we have a controlling pin object.
    //
    ControllingPin();
    if (!m_pControllingPin || !m_pIKsPropertySet)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    nodeProperty.NodeId = m_ulNodeType;

    ASSERT( m_pIKsPropertySet);

    hrStatus = m_pIKsPropertySet->Set(
                            refguidPropSet,
                            ulPropertyId,
                            &nodeProperty.NodeId,
                            sizeof( KSP_NODE) - sizeof( KSPROPERTY),
                            (PVOID) pbPropertyData,
                            ulcbPropertyData
                            );

errExit:
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaControlNode::get_BdaNodeProperty(
    REFGUID     refguidPropSet,
    ULONG       ulPropertyId,
    UCHAR*      pbPropertyData, 
    ULONG       ulcbPropertyData, 
    ULONG*      pulcbBytesReturned
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = NOERROR;
    KSP_NODE    nodeProperty;

    //  Make sure we have a controlling pin object.
    //
    ControllingPin();
    if (!m_pControllingPin || !m_pIKsPropertySet)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    nodeProperty.NodeId = m_ulNodeType;

    ASSERT( m_pIKsPropertySet);

    hrStatus = m_pIKsPropertySet->Get(
                            refguidPropSet,
                            ulPropertyId,
                            &nodeProperty.NodeId,
                            sizeof( KSP_NODE) - sizeof( KSPROPERTY),
                            (PVOID) pbPropertyData,
                            ulcbPropertyData,
                            pulcbBytesReturned
                            );

errExit:
    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\bdaplugin\resource.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#define IDS_VERSION                     100
#define IDS_TITLE                       101

#ifndef IDC_STATIC
#define IDC_STATIC (-1)
#endif

/////////////////////////////////////////////////////////////////////////////
//
//  BDA Frequency Filter Property Pane
//

#define IDD_BDAFrequencyFilterDialog    102
#define IDS_FrequencyFilterPageName     1050
#define IDC_Frequency                   1057
#define IDC_STATIC_STRENGTH             1059
#define IDC_REFRESH                     1061
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dbgpages\dbgpages.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    dbgpages.h

Abstract:

    Internal debugging property page implementation.

Author(s):

    Bill Messmer

--*/

#include <streams.h>
#include <tchar.h>
#include <stdio.h>

#include <olectl.h>

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>

#include <ksiproxy.h>

#include <initguid.h>
#include "dbgpages.h"

CFactoryTemplate g_Templates[] = {
    { 
        L"Internal Pipes Property Page",
        &CLSID_DebugPipesPropertyPage,
        CKsDebugPipesPropertyPage::CreateInstance,
        NULL,
        NULL
    }
};

int g_cTemplates = sizeof(g_Templates) / sizeof (g_Templates[0]);


HRESULT
RegisterDebugPage (
    const GUID *PageGuid
    )

/*++

Routine Description:

    Register a debug property page with KsProxy.

Arguments:

    The CLSID of the page.  This will be placed in the appropriate location
    in KsProxy's reg space.

Return Value:

    Success / failure of registration.

--*/

{

    OLECHAR PageGuidString[40];
    TCHAR RegistryPath[256];

    //
    // Convert the property page's GUID to a reg string and add it to
    // the proxy's registry location.
    //
    if (SUCCEEDED (
        StringFromGUID2 (*PageGuid, PageGuidString, CHARS_IN_GUID)
        )) {

        wsprintf(
            RegistryPath,
            TEXT("Software\\Microsoft\\KsProxy\\DebugPages\\%ls"),
            PageGuidString
            );

        HKEY ProxyKey;
        DWORD Disposition;

        if ((RegCreateKeyEx (
            HKEY_LOCAL_MACHINE,
            RegistryPath,
            0,
            TEXT(""),
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &ProxyKey,
            &Disposition
            )) != ERROR_SUCCESS) {

            //
            // Couldn't open the key and register the page!?  Return failure.
            //
            return E_FAIL;

        }

        RegCloseKey (ProxyKey);
    }

    return S_OK;
}


HRESULT
UnRegisterDebugPage (
    const GUID *PageGuid
    )

/*++

Routine Description:

    Unregister a debug property page with KsProxy.

Arguments:

    The CLSID of the page.  This will be removed from the appropriate location
    in KsProxy's reg space.

Return Value:

    Success / failure of unregistration.

--*/

{

    OLECHAR PageGuidString[CHARS_IN_GUID];
    TCHAR RegistryPath[256];

    //
    // Convert the property page's GUID to a reg string and remove it from
    // the proxy's registry location.
    //
    if (SUCCEEDED (
        StringFromGUID2 (*PageGuid, PageGuidString, CHARS_IN_GUID)
        )) {

        HKEY ProxyKey;
        DWORD Disposition;

        if ((RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\KsProxy\\DebugPages"),
            0,
            KEY_ALL_ACCESS,
            &ProxyKey
            )) == ERROR_SUCCESS) {

            wsprintf (RegistryPath, TEXT("%ls"), PageGuidString);

            if ((RegDeleteKey (
                ProxyKey,
                RegistryPath
                )) != ERROR_SUCCESS) {

                //
                // Could not delete debug key!?  Return failure.
                //
                return E_FAIL;

            }

            RegCloseKey (ProxyKey);
        }
    }

    return S_OK;
}


STDAPI
DllRegisterServer (
    void
    )

/*++

Routine Description:

    Register ourselves & COM servers.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    HRESULT hr;

    hr = AMovieDllRegisterServer2 (TRUE);

    //
    // Any debug pages that are intended for use by KsProxy must sit in
    // an appropriate location within KsProxy's reg space.
    //
    if (!FAILED (hr)) {
        hr = RegisterDebugPage (&CLSID_DebugPipesPropertyPage);

        //
        // If we couldn't register the debug page, back out the 
        // AMovieDllRegisterServer2 call.
        //
        if (!SUCCEEDED (hr)) {
            HRESULT backoutHr = AMovieDllRegisterServer2 (FALSE);

            ASSERT (SUCCEEDED (backoutHr));
        }
    }

    return hr;

}


STDAPI
DllUnregisterServer (
    void
    )

/*++

Routine Description:

    Unregister ourselves & COM servers.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    HRESULT hr;

    hr = AMovieDllRegisterServer2 (FALSE);

    //
    // If we're unregistering this server, KsProxy must be made aware that
    // this property page no longer exists.  Update the registry. 
    //
    if (!FAILED (hr)) {
        hr = UnRegisterDebugPage (&CLSID_DebugPipesPropertyPage);

        //
        // If we couldn't unregister the debug page, back out the
        // AMovieDllRegisterServer2 call.
        //
        if (!SUCCEEDED (hr)) {
            HRESULT backoutHr = AMovieDllRegisterServer2 (TRUE);

            ASSERT (SUCCEEDED (backoutHr));
        }
       
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dbgpages\prxpipe.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    prxpipe.h

Abstract:

    Copies of routines out of KsProxy to facilitate walking pipes.

--*/

STDMETHODIMP_(BOOL)
WalkPipeAndProcess(
    IN IKsPin* RootKsPin,
    IN ULONG RootPinType,
    IN IKsPin* BreakKsPin,
    IN PWALK_PIPE_CALLBACK CallerCallback,
    IN PVOID* Param1,
    IN PVOID* Param2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dbgpages\prxpipe.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 2000

Module Name:

    prxpipe.cpp

Abstract:

    Copies of routines out of KsProxy to facilitate walking pipes.

--*/

#include <windows.h>
#ifdef WIN9X_KS
#include <comdef.h>
#endif // WIN9X_KS
#include <setupapi.h>
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <limits.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>

#define GLOBAL_KSIPROXY
#include "ksiproxy.h"
#include "kspipes.h"


STDMETHODIMP_(BOOL)
IsKernelPin(
    IN IPin* Pin
    )

{

    IKsPinPipe*  KsPinPipe;
    HRESULT      hr;



    hr = Pin->QueryInterface( __uuidof(IKsPinPipe), reinterpret_cast<PVOID*>(&KsPinPipe) );
    if (! SUCCEEDED( hr )) {
        return FALSE;
    }
    else {
        if (KsPinPipe) {
            KsPinPipe->Release();
        }
        return TRUE;
    }
}


STDMETHODIMP_(BOOL)
FindFirstPinOnPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT IKsPin** FirstKsPin,
    OUT ULONG* FirstPinType
    )
{

    IKsPin*      CurrentKsPin;
    IKsPin*      StoreKsPin;
    ULONG        CurrentPinType;
    ULONG        RetCode;


    CurrentKsPin = KsPin;
    CurrentPinType = PinType;

    do {
        StoreKsPin = CurrentKsPin;

        RetCode = FindNextPinOnPipe(StoreKsPin, CurrentPinType, KS_DIRECTION_UPSTREAM, NULL, FALSE, &CurrentKsPin);

        if (! RetCode) {
            *FirstKsPin = StoreKsPin;
            *FirstPinType = CurrentPinType;
            return (TRUE);
        }

        if (CurrentPinType == Pin_Input) {
            CurrentPinType = Pin_Output;
        }
        else {
            CurrentPinType = Pin_Input;
        }

    } while ( 1 );

}


STDMETHODIMP_(BOOL)
FindNextPinOnPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    IN IKsAllocatorEx* KsAllocator,        // NULL - if same pipe.
    IN BOOL FlagIgnoreKey,
    OUT IKsPin** NextKsPin
)

{
    IPin*             Pin;
    IKsPinPipe*       KsPinPipe;
    IKsAllocatorEx*   NextKsAllocator;
    IKsPinPipe*       NextKsPinPipe;
    HRESULT           hr;
    ULONG             RetCode = FALSE;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! KsAllocator) {
        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    }

    if (KsAllocator) {
        if  ( ((PinType == Pin_Input) && (Direction == KS_DIRECTION_UPSTREAM)) ||
              ((PinType == Pin_Output) && (Direction == KS_DIRECTION_DOWNSTREAM))    )  {

            Pin = KsPinPipe->KsGetConnectedPin();

            if (Pin && IsKernelPin(Pin) ) {

                hr = Pin->QueryInterface( __uuidof(IKsPin), reinterpret_cast<PVOID*>(NextKsPin) );
                if ( SUCCEEDED( hr ) && (*NextKsPin) )  {
                    //
                    // Otherwise: user pin -> end of pipe
                    //
                    (*NextKsPin)->Release();

                    GetInterfacePointerNoLockWithAssert((*NextKsPin), __uuidof(IKsPinPipe), NextKsPinPipe, hr);

                    NextKsAllocator = NextKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                    if (FlagIgnoreKey || (KsAllocator == NextKsAllocator) ) {
                        RetCode = TRUE;
                    }
                }
            }
        }
        else {
            RetCode = FindConnectedPinOnPipe(KsPin, KsAllocator, FlagIgnoreKey, NextKsPin);
        }
    }

    return  RetCode;
}


STDMETHODIMP_(BOOL)
FindConnectedPinOnPipe(
    IN IKsPin* KsPin,
    IN IKsAllocatorEx* KsAllocator,        // NULL - if same pipe.
    IN BOOL FlagIgnoreKey,
    OUT IKsPin** ConnectedKsPin
)

{
    BOOL             RetCode = FALSE;
    IKsAllocatorEx*  ConnectedKsAllocator;
    IPin*            Pin;
    ULONG            PinCount = 0;
    IPin**           PinList;
    ULONG            i;
    HRESULT          hr;
    IKsPinPipe*      KsPinPipe;
    IKsPinPipe*      ConnectedKsPinPipe;



    ASSERT(KsPin);

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! KsAllocator) {
        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    }

    if (KsAllocator) {
        //
        // find connected Pins
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

        hr = Pin->QueryInternalConnections(NULL, &PinCount);
        if ( ! (SUCCEEDED( hr ) )) {
            ASSERT( 0 );
        }
        else if (PinCount) {
            if (NULL == (PinList = new IPin*[ PinCount ])) {
                hr = E_OUTOFMEMORY;
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FindConnectedPinOnPipe E_OUTOFMEMORY on new PinCount=%d"), PinCount ));
            }
            else {
                hr = Pin->QueryInternalConnections(PinList, &PinCount);
                if ( ! (SUCCEEDED( hr ) )) {
                    ASSERT( 0 );
                }
                else {
                    //
                    // Find first ConnectedKsPin in the PinList array that resides on the same KsPin-pipe.
                    //
                    for (i = 0; i < PinCount; i++) {
                        GetInterfacePointerNoLockWithAssert(PinList[ i ], __uuidof(IKsPin), (*ConnectedKsPin), hr);

                        GetInterfacePointerNoLockWithAssert((*ConnectedKsPin), __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

                        ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                        if (FlagIgnoreKey || (ConnectedKsAllocator == KsAllocator) ) {
                            RetCode = TRUE;
                            break;
                        }
                    }
                    for (i=0; i<PinCount; i++) {
                        PinList[i]->Release();
                    }
                }
                delete [] PinList;
            }
        }
    }

    if (! RetCode) {
        (*ConnectedKsPin) = NULL;
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
FindAllConnectedPinsOnPipe(
    IN IKsPin* KsPin,
    IN IKsAllocatorEx* KsAllocator,
    OUT IKsPin** ListConnectedKsPins,
    OUT ULONG* CountConnectedKsPins
)

{
    BOOL             RetCode = FALSE;
    IKsAllocatorEx*  ConnectedKsAllocator;
    IPin*            Pin;
    ULONG            PinCount = 0;
    IPin**           PinList;
    ULONG            i;
    HRESULT          hr;
    IKsPinPipe*      KsPinPipe;
    IKsPin*          ConnectedKsPin;
    IKsPinPipe*      ConnectedKsPinPipe;




    ASSERT(KsPin);

    *CountConnectedKsPins = 0;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! KsAllocator) {
        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    }

    if (KsAllocator) {
        //
        // find connected Pins
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

        hr = Pin->QueryInternalConnections(NULL, &PinCount);
        ASSERT( SUCCEEDED( hr ) );

        if ( SUCCEEDED( hr ) && (PinCount != 0) ) {

            if (NULL == (PinList = new IPin*[ PinCount ])) {
                hr = E_OUTOFMEMORY;
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FindAllConnectedPinsOnPipe E_OUTOFMEMORY on new PinCount=%d"), PinCount ));
            }
            else {
                hr = Pin->QueryInternalConnections(PinList, &PinCount);

                ASSERT( SUCCEEDED( hr ) );

                if ( SUCCEEDED( hr ) ) {
                    //
                    // Find all  ConnectedKsPin-s in the PinList array that resides on the same KsPin-pipe.
                    //
                    for (i = 0; i < PinCount; i++) {

                        GetInterfacePointerNoLockWithAssert(PinList[ i ], __uuidof(IKsPin), ConnectedKsPin, hr);

                        GetInterfacePointerNoLockWithAssert(ConnectedKsPin, __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

                        ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                        if (ConnectedKsAllocator == KsAllocator) {
                            if (ListConnectedKsPins) {
                                ListConnectedKsPins[*CountConnectedKsPins] = ConnectedKsPin;
                            }

                            (*CountConnectedKsPins)++;

                            RetCode = TRUE;
                        }
                    }
                    for (i=0; i<PinCount; i++) {
                        PinList[i]->Release();
                    }
                }
                delete [] PinList;
            }
        }
    }
    return RetCode;

}


STDMETHODIMP_(BOOL)
WalkPipeAndProcess(
    IN IKsPin* RootKsPin,
    IN ULONG RootPinType,
    IN IKsPin* BreakKsPin,
    IN PWALK_PIPE_CALLBACK CallerCallback,
    IN PVOID* Param1,
    IN PVOID* Param2
    )
/*++

Routine Description:

    Walks the pipe defined by its root pin downstream.

    Because of possible multiple read-only downstream connections, the pipe can be
    generally represented as a tree.

    This routine walks the pipe layer by layer downstream starting with RootKsPin.
    For each new pin found, the supplied CallerCallback is called passing thru the
    supplied Param1 and Param2.

    CallerCallback may return IsDone=1, indicating that the walking process should
    immediately stop.

    If CallerCallback never sets IsDone=1, then the tree walking process is continued
    until all the pins on this pipe are processed.

    If BreakKsPin is not NULL, then BreakKsPin and all the downstream pins starting at
    BreakKsPin are not enumerated.
    This is used when we want to split RootKsPin-tree at BreakKsPin point.

    NOTE: It is possible to change the algorithm to use the search handles, and do something
    like FindFirstPin/FindNextPin - but it is more complex and less efficient. On the other hand,
    it is more generic.

Arguments:

    RootKsPin -
        root pin for the pipe.

    RootPinType -
        root pin type.

    BreakKsPin -
        break pin for the pipe.

    CallerCallback -
        defined above.

    Param1 -
        first parameter for CallerCallback

    Param2 -
        last parameter for CallerCallback


Return Value:

    TRUE on success.

--*/
{


#define INCREMENT_PINS  25

    IKsPin**            InputList;
    IKsPin**            OutputList = NULL;
    IKsPin**            TempList;
    IKsPin*             InputKsPin;
    ULONG               CountInputList = 0;
    ULONG               AllocInputList = INCREMENT_PINS;
    ULONG               CountOutputList = 0;
    ULONG               AllocOutputList = INCREMENT_PINS;
    ULONG               CurrentPinType;
    ULONG               i, j, Count;
    BOOL                RetCode = TRUE;
    BOOL                IsDone = FALSE;
    HRESULT             hr;
    IKsAllocatorEx*     KsAllocator;
    IKsPinPipe*         KsPinPipe;
    BOOL                IsBreakKsPinHandled;



    if (BreakKsPin) {
        IsBreakKsPinHandled = 0;
    }
    else {
        IsBreakKsPinHandled = 1;
    }

    //
    // allocate minimum memory for both input and output lists.
    //

    InputList = new IKsPin*[ INCREMENT_PINS ];
    if (! InputList) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new InputList") ));
        RetCode = FALSE;
    }
    else {
        OutputList = new IKsPin*[ INCREMENT_PINS ];
        if (! OutputList) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new OutputList") ));
            RetCode = FALSE;
        }
    }

    if (RetCode) {
        //
        // get the pipe pointer from RootKsPin as a search key for all downstream pins.
        //
        GetInterfacePointerNoLockWithAssert(RootKsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

        //
        // depending on the root pin type, prepare the lists and counts to enter the main tree walking loop.
        //
        if (RootPinType == Pin_Input) {
            InputList[0] = RootKsPin;
            CountInputList = 1;
        }
        else {
            //
            // there could be multiple output pins at the same level with this root pin.
            //
            if (! FindConnectedPinOnPipe(RootKsPin, KsAllocator, TRUE, &InputKsPin) ) {
                OutputList[0] = RootKsPin;
                CountOutputList = 1;
            }
            else {
                //
                // first - get the count of connected output pins.
                //
                if (! (RetCode = FindAllConnectedPinsOnPipe(InputKsPin, KsAllocator, NULL, &Count) ) ) {
                    ASSERT(0);
                }
                else {
                    if (Count > AllocOutputList) {
                        AllocOutputList = ( (Count/INCREMENT_PINS) + 1) * INCREMENT_PINS;
                        delete [] OutputList;

                        OutputList = new IKsPin*[ AllocOutputList ];
                        if (! OutputList) {
                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new OutputList %d"),
                                    AllocOutputList ));

                            RetCode = FALSE;
                        }
                    }

                    if (RetCode) {
                        //
                        // fill the pins.
                        //
                        if (! FindAllConnectedPinsOnPipe(InputKsPin, KsAllocator, &OutputList[0], &Count) ) {
                            ASSERT(0);
                            RetCode = FALSE;
                        }

                        CountOutputList = Count;
                    }
                }
            }
        }

        if (RetCode) {
            CurrentPinType = RootPinType;

            //
            // main tree walking loop.
            //
            do {
                if (CurrentPinType == Pin_Input) {
                    //
                    // remove the BreakKsPin from the InputList if found.
                    //
                    if (! IsBreakKsPinHandled) {
                        for (i=0; i<CountInputList; i++) {
                            if (InputList[i] == BreakKsPin) {
                                for (j=i; j<CountInputList-1; j++) {
                                    InputList[j] = InputList[j+1];
                                }
                                CountInputList--;
                                IsBreakKsPinHandled = 1;
                                break;
                            }
                        }
                    }

                    //
                    // process current layer.
                    //
                    if (CountInputList) {
                        for (i=0; i<CountInputList; i++) {
                            RetCode = CallerCallback( InputList[i], Pin_Input, Param1, Param2, &IsDone);
                            if (IsDone) {
                                break;
                            }
                        }

                        if (IsDone) {
                            break;
                        }

                        //
                        // Build next layer
                        //
                        CountOutputList = 0;

                        for (i=0; i<CountInputList; i++) {

                            if (FindAllConnectedPinsOnPipe(InputList[i], KsAllocator, NULL, &Count) ) {

                                Count += CountOutputList;

                                if (Count > AllocOutputList) {
                                    AllocOutputList = ( (Count/INCREMENT_PINS) + 1) * INCREMENT_PINS;
                                    TempList = OutputList;

                                    OutputList = new IKsPin*[ AllocOutputList ];
                                    if (! OutputList) {
                                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new OutputList %d"),
                                                AllocOutputList ));

                                        RetCode = FALSE;
                                        break;
                                    }

                                    if (TempList) {
                                        if (CountOutputList) {
                                            MoveMemory(OutputList, TempList, CountOutputList * sizeof(OutputList[0]));
                                        }
                                        delete [] TempList;
                                    }
                                }

                                if (! (RetCode = FindAllConnectedPinsOnPipe(InputList[i], KsAllocator, &OutputList[CountOutputList], &Count) ) ) {
                                    ASSERT(0);
                                    break;
                                }

                                CountOutputList += Count;
                            }
                        }

                        CurrentPinType = Pin_Output;
                    }
                    else {
                        break;
                    }

                }
                else { // Output
                    //
                    // remove the BreakKsPin from the OutputList if found.
                    //
                    if (! IsBreakKsPinHandled) {
                        for (i=0; i<CountOutputList; i++) {
                            if (OutputList[i] == BreakKsPin) {
                                for (j=i; j<CountOutputList-1; j++) {
                                    OutputList[j] = OutputList[j+1];
                                }
                                CountOutputList--;
                                IsBreakKsPinHandled = 1;
                                break;
                            }
                        }
                    }

                    if (CountOutputList) {
                        for (i=0; i<CountOutputList; i++) {
                            RetCode = CallerCallback( OutputList[i], Pin_Output, Param1, Param2, &IsDone);
                            if (IsDone) {
                                break;
                            }
                        }

                        if (IsDone) {
                            break;
                        }

                        //
                        // Build next layer
                        //
                        CountInputList = 0;

                        for (i=0; i<CountOutputList; i++) {

                            if (FindNextPinOnPipe(OutputList[i], Pin_Output, KS_DIRECTION_DOWNSTREAM, KsAllocator, FALSE, &InputKsPin) ) {

                                InputList[CountInputList] = InputKsPin;

                                CountInputList++;
                                if (CountInputList >= AllocInputList) {
                                    AllocInputList = ( (CountInputList/INCREMENT_PINS) + 1) * INCREMENT_PINS;
                                    TempList = InputList;

                                    InputList = new IKsPin*[ AllocInputList ];
                                    if (! InputList) {
                                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new InputList %d"),
                                                AllocInputList ));

                                        RetCode = FALSE;
                                        break;
                                    }

                                    if (TempList) {
                                        if (CountInputList) {
                                            MoveMemory(InputList, TempList,  CountInputList * sizeof(InputList[0]));
                                        }
                                        delete [] TempList;
                                    }
                                }
                            }
                        }

                        CurrentPinType = Pin_Input;
                    }
                    else {
                        break;
                    }
                }

            } while (RetCode);
        }
    }


    //
    // Possible to use IsDone in future.
    //

    if (InputList) {
        delete [] InputList;
    }

    if (OutputList) {
        delete [] OutputList;
    }


    return RetCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dbgpages\dbgpipes.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    dbgpipes.cpp

Abstract:

    Internal debugging property page implementation for pipes implementation
    in KsProxy.

Author(s):

    Bill Messmer

--*/

#include <afxres.h>

#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <commctrl.h>
#include <memory.h>
#include <olectl.h>

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "..\ksproxy\ksiproxy.h"

#include "dbgpages.h"
#include "resource.h"

#define ListBox_InsertItem(hwnd, str) \
    SendMessage (hwnd, LB_ADDSTRING, 0, (LPARAM)str)

/**************************************************************************

    PIPES DEBUG PROPERTY PAGE

**************************************************************************/

/**************************************************************************

    INSTANCE CREATION / IPropertyPage IMPLEMENTATION

**************************************************************************/


CUnknown *
CKsDebugPipesPropertyPage::
CreateInstance (
    IN LPUNKNOWN lpunk,
    OUT HRESULT *phr
    )

/*++

Routine Description:

    Create an instance of the property page

Arguments:
    
    lpunk -

    phr -
        Status of instance creation

Return Value:

    An instance of the property page

--*/

{

    CUnknown *PropertyPage = 
        (CUnknown *)new CKsDebugPipesPropertyPage (lpunk, phr);

    if (PropertyPage == NULL)
        *phr = E_OUTOFMEMORY;

    return PropertyPage;

}

CKsDebugPipesPropertyPage::
~CKsDebugPipesPropertyPage (
    )

/*++

Routine Description:

    Destructor for the debug pipes property page.  

--*/

{

    //
    // This should happen via the property page site sending us a
    // SetObjects (0, NULL).  Cleanup just incase.
    //
    if (m_Filter) {
        m_Filter -> Release ();
        m_Filter = NULL;
    }

    if (m_Pin) {
        m_Pin -> Release ();
        m_Pin = NULL;
    }

}


CKsDebugPipesPropertyPage::
CKsDebugPipesPropertyPage (
    IN LPUNKNOWN lpunk,
    OUT HRESULT *phr
    ) :
    CUnknown (NAME("Debug Pipes Property Page"), lpunk, phr),
    m_Filter (NULL),
    m_Pin (NULL),
    m_PageSite (NULL),
    m_Window (NULL)

/*++

Routine Description:

    Construct an instance of the debug pipes property page.

Arguments:

    lpunk -
        

    phr -
        Status of construction

Return Value:

    None

--*/

{

}

STDMETHODIMP
CKsDebugPipesPropertyPage::
NonDelegatingQueryInterface (
    IN REFIID riid,
    OUT void **ppv
    )

/*++

Routine Description:

    Non delegating query interface for the property page COM object.

Arguments:

    riid -
        The interface being queried

    ppv -
        Output where interface pointer is placed

Return Value:

    Success / Failure

--*/

{

    if (riid == IID_IPropertyPage) 
        return GetInterface ((IPropertyPage *)this, ppv);
    else
        return CUnknown::NonDelegatingQueryInterface (riid, ppv);

}


STDMETHODIMP
CKsDebugPipesPropertyPage::
GetPageInfo (
    OUT LPPROPPAGEINFO PageInfo
    )

/*++

Routine Description:

    IPropertyPage::GetPageInfo implementation.  Return information about
    the debug pipes property page.

Arguments:

    PageInfo -
        The page information will be returned here

Return Value:

    Success / Failure

--*/

{

    WCHAR ITitle[] = L"Debug Pipes";
    LPOLESTR Title;

    if (!PageInfo)
        return E_POINTER;

    //
    // Caller has responsibility of freeing this.
    //
    Title = (LPOLESTR)CoTaskMemAlloc (sizeof (ITitle));
    if (!Title)
        return E_OUTOFMEMORY;
    memcpy (Title, ITitle, sizeof (ITitle));

    PageInfo -> cb = sizeof (PROPPAGEINFO);
    PageInfo -> pszTitle = Title;

    PageInfo -> size.cx = 256;
    PageInfo -> size.cy = 128;

    GetDialogSize (
        IDC_CONFIG, 
        CKsDebugPipesPropertyPage::DialogProc,
        0L, 
        &PageInfo -> size
        );

    PageInfo -> pszDocString = NULL;
    PageInfo -> pszHelpFile = NULL;
    PageInfo -> dwHelpContext = 0;

    return S_OK;

}


STDMETHODIMP
CKsDebugPipesPropertyPage::
SetObjects (
    IN ULONG NumObjects,
    IN LPUNKNOWN FAR* Objects
    )

/*++

Routine Description:

    Implement IPropertyPage::SetObjects.  Cache the pointers related to this
    property page.  If NumObjects is zero, release any interface pointers
    we have hold on.

Arguments:

    NumObjects -
        The number of unknowns in the Objects array.

    Objects -
        Unknown pointers to any objects related to this property page

Return Value:

    Success / Failure

--*/

{

    //
    // If the count is zero, we're being asked to release any interface
    // pointers we hold ref on.
    //
    if (NumObjects == 0) {

        if (m_Pin) {
            m_Pin -> Release();
            m_Pin = NULL;
        }

        if (m_Filter) {
            m_Filter -> Release ();
            m_Filter = NULL;
        }

    } else {

        if (!Objects)
            return E_POINTER;

        //
        // Find any related object pointers.  This is being looped to provide
        // for future use of this property page.
        //
        LPUNKNOWN FAR *Object = Objects;
        for (ULONG i = 0; i < NumObjects; i++) {

            IKsPin *Pin;

            if (!*Object) {
                SetObjects (0, NULL);
                return E_POINTER;
            }

            HRESULT hr = (*Object) -> QueryInterface (
                IID_IKsPin, (void **)&Pin
                );

            if (SUCCEEDED (hr)) {
                //
                // Only one pin should be in this list!
                //
                if (m_Pin) {
                    SetObjects (0, NULL);
                    return E_FAIL;
                }
                m_Pin = Pin;

                //
                // Determine the pin type and parent filter.
                //
                HRESULT hr;
                if (!SUCCEEDED (hr = (DeterminePinTypeAndParentFilter ()))) {
                    SetObjects (0, NULL);
                    return hr;
                }

            } else {

                //
                // Warning: unknown object in the list?  Only fail if we didn't
                // get the pin.
                //

            }
        }
    }

    //
    // If we don't have the pin interface, release everything we did get and
    // return such.  
    //
    if (!m_Pin && NumObjects != 0) {
        SetObjects (0, NULL);
        return E_NOINTERFACE;
    }

    return S_OK;
}


STDMETHODIMP
CKsDebugPipesPropertyPage::
IsPageDirty (
    void
    )

/*++

Routine Description:

    Implement the IPropertyPage::IsPageDirty function.  Since we are 
    just displaying static information about the pipes system configuration,
    we always return S_FALSE.

Arguments:

    None

Return Value:

    S_FALSE (we are never dirty)

--*/

{

    //
    // We provide static information about the pipes system.  We cannot 
    // make any changes, ever.  Just return S_FALSE.
    //
    return S_FALSE;

}


STDMETHODIMP
CKsDebugPipesPropertyPage::
Apply (
    void
    )

/*++

Routine Description:

    Implement the IPropertyPage::Apply function.  Since we are just
    displaying static information about the pipes system configuration,
    we always return S_OK.  Never actually attempt to make any changes.

Arguments:

    None

Return Value:

    S_OK (we never really apply changes)

--*/

{

    //
    // We provide static information about the pipes system.  No changes
    // can ever be made.  Just return S_OK.
    //
    return S_OK;

}


STDMETHODIMP
CKsDebugPipesPropertyPage::
SetPageSite (
    IN IPropertyPageSite *PageSite
    )

/*++

Routine Description:

    Set the page site or clean up the page site interface pointers as
    specified by IPropertyPage::SetPageSite.

Arguments:

    PageSite -
        The property page site.

Return Value:

    Success / Failure

--*/

{

    //
    // NULL indicates a cleanup.  Release our ref on the page site.
    //
    if (PageSite == NULL) {

        if (!m_PageSite)
            return E_UNEXPECTED;

        m_PageSite -> Release ();
        m_PageSite = NULL;

    } else {

        if (!PageSite) 
            return E_POINTER;

        m_PageSite = PageSite;
        m_PageSite -> AddRef();

    }

    return S_OK;

}


STDMETHODIMP
CKsDebugPipesPropertyPage::
Activate (
    IN HWND ParentWindow,
    IN LPCRECT Rect,
    IN BOOL Modal
    )

/*++

Routine Description:

    Implement the IPropertyPage::Active function.  Create the dialog window
    and move it to the specified location.

Arguments:

    ParentWindow -
        The parent window for the dialog

    Rect -
        The rect specifying the characteristics of the property page dialog
        we will create.

    Modal -
        Indicates whether the dialog is modal or not.

--*/

{

    if (!ParentWindow || !Rect) 
        return E_POINTER;

    TCHAR* Dialog = MAKEINTRESOURCE (IDD_PIPEDIALOG);

    m_Window = CreateDialogParam (
        g_hInst,
        Dialog,
        ParentWindow,
        CKsDebugPipesPropertyPage::DialogProc,
        (LPARAM)this
        );

    if (!m_Window) {
        return E_FAIL;
    }

    //
    // Set parental control.
    //
    SetWindowLong (m_Window, GWL_USERDATA, (long)this);
    DWORD dwStyle = GetWindowLong (m_Window, GWL_EXSTYLE);
    dwStyle = dwStyle | WS_EX_CONTROLPARENT;
    SetWindowLong (m_Window, GWL_EXSTYLE, dwStyle);

    UpdatePipeSystem ();

    return Move (Rect);

}


STDMETHODIMP
CKsDebugPipesPropertyPage::
Deactivate (
    void
    )

/*++

Routine Description:

    Implement the IPropertyPage::Deactivate function.  Destroy our dialog,
    etc...

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    if (m_Window == NULL)
        return E_UNEXPECTED;

    if (!DestroyWindow (m_Window)) {
        return E_FAIL;
    }

    return S_OK;


}


STDMETHODIMP
CKsDebugPipesPropertyPage::
Move (
    IN LPCRECT Rect
    )

/*++

Description:

    Implement the IPropertyPage::Move function.  Move the dialog as specified
    by Rect.

Arguments:

    Rect -
        Specifies the position to move the dialog to

Return Value:

    Success / Failure

--*/

{

    if (!Rect)
        return E_POINTER;

    if (!MoveWindow (
        m_Window,
        Rect -> left,
        Rect -> top,
        WIDTH (Rect),
        HEIGHT (Rect),
        TRUE
        )) {

        return E_FAIL;
    }

    return S_OK;

}


STDMETHODIMP
CKsDebugPipesPropertyPage::
Show (
    IN UINT nCmdShow
    )

/*++

Description:

    Implement the IPropertyPage::Show function.  Show the dialog as specified
    by nCmdShow.

Arguments:

    nCmdShow -

Return Value:

    Success / Failure

--*/

{
    if (m_Window == NULL)
        return E_UNEXPECTED;

    ShowWindow (m_Window, nCmdShow);
    InvalidateRect (m_Window, NULL, TRUE);

    return S_OK;

}

/**************************************************************************

    MISC STUFF

**************************************************************************/

HRESULT
CKsDebugPipesPropertyPage::
DeterminePinTypeAndParentFilter (
    )

/*++

Routine Description:

    Determine whether m_Pin is input or output.  Set m_PinType accordingly.

--*/

{

    HRESULT hr = S_OK;

    if (!m_Pin)
        return E_UNEXPECTED;

    IPin *DSPin;
    PIN_INFO PinInfo;

    PinInfo.pFilter = NULL;

    if (m_Filter) {
        m_Filter -> Release();
        m_Filter = NULL;
    }

    hr = m_Pin -> QueryInterface (__uuidof (IPin), (void **)&DSPin
        );

    //
    // Get the pin information so that we have a pointer to the IBaseFilter
    // implementation on proxy.
    //
    if (SUCCEEDED (hr)) {

        hr = DSPin -> QueryPinInfo (&PinInfo);
        DSPin -> Release();

    }

    if (SUCCEEDED (hr)) {

        if (PinInfo.dir == PINDIR_OUTPUT)
            m_PinType = Pin_Output;
        else if (PinInfo.dir == PINDIR_INPUT)
            m_PinType = Pin_Input;
        else
            hr = E_FAIL;
    }

    if (PinInfo.pFilter) {
        m_Filter = PinInfo.pFilter;
    }

    return hr;

}

/**************************************************************************

    DIALOG IMPLEMENTATION

**************************************************************************/

BOOL
CKsDebugPipesPropertyPage::
DisplayPipeLayoutCallback (
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )

/*++

Routine Description:

    Callback from WalkPipesAndProcess to display pipe layout.  Note I don't
    understand the parameters fully; I'm just using it out of KsProxy.

--*/

{

    HWND ConfigWindow = *((HWND *)Param1);

    IKsPinPipe *PinPipe;
    HRESULT hr;

    hr = KsPin -> QueryInterface (__uuidof (IKsPinPipe), 
        (void **)&PinPipe
        );

    //
    // It darn well better succeed. 
    //
    if (SUCCEEDED (hr)) {

        TCHAR ItemText [512];

        PWCHAR PinName = PinPipe -> KsGetPinName ();
        wsprintf (ItemText, TEXT("    Pin: %ls [0x%p]"), PinName, KsPin);

        ListBox_InsertItem (ConfigWindow, ItemText);

        PinPipe -> Release ();

    }

    return TRUE;

}

HRESULT
CKsDebugPipesPropertyPage::
DisplayKernelAllocatorProperties (
    IN HWND ConfigWindow
    )

/*++

Routine Description:

    Display the kernel allocator's properties of m_Pin.  This will require
    sending IOCTLs to the kernel driver, but we'll let the proxy do this
    for us via the IKsControl interface.

Arguments:

    ConfigWindow -
        The HWND of the listbox to dump this to.

Return Value:

    Success / Failure

--*/

{

    if (!m_Pin)
        return E_UNEXPECTED;

    HRESULT hr;
    IKsControl *Control = NULL;

    //
    // Get the proxy's control interface for the pin.
    //
    hr = m_Pin -> QueryInterface (__uuidof (IKsControl),
        (void **)&Control
        );

    if (SUCCEEDED (hr)) {

        KSPROPERTY Property;
        ULONG BytesReturned;
        KSALLOCATOR_FRAMING_EX FramingExSt;
        KSALLOCATOR_FRAMING FramingSt;
        PKSALLOCATOR_FRAMING_EX FramingEx = NULL;
        PKSALLOCATOR_FRAMING Framing = NULL;

        Property.Set = KSPROPSETID_Connection;
        Property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX;
        Property.Flags = KSPROPERTY_TYPE_GET;

        hr = Control -> KsProperty (
            &Property,
            sizeof (KSPROPERTY),
            &FramingExSt,
            sizeof (FramingExSt),
            &BytesReturned
            );

        //
        // If we couldn't get extended allocator framing, either we have
        // insufficient buffer space, or it isn't supported.
        //
        if (!SUCCEEDED (hr)) {

            // If there was insufficient buffer space, allocate a big
            // enough buffer and make the property request again.
            //
            if (hr == HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER)) {
                FramingEx = reinterpret_cast <PKSALLOCATOR_FRAMING_EX> 
                    (new BYTE [BytesReturned]);

                if (!FramingEx) {
                    Control -> Release ();
                    return E_OUTOFMEMORY;
                }

                hr = Control -> KsProperty (
                    &Property,
                    sizeof (KSPROPERTY),
                    FramingEx,
                    BytesReturned,
                    &BytesReturned
                    );

            }

            //
            // If we haven't yet succeeded, assume that this filter doesn't
            // support extended framing.  Try the regular allocator framing
            // instead.
            //
            if (!SUCCEEDED (hr)) {

                if (FramingEx) {
                    delete [] FramingEx;
                    FramingEx = NULL;
                }
                
                Property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING;

                hr = Control -> KsProperty (
                    &Property,
                    sizeof (KSPROPERTY),
                    &FramingSt,
                    sizeof (FramingSt),
                    &BytesReturned
                    );

                if (!SUCCEEDED (hr)) {

                    //
                    // If there was insufficient buffer space, allocate
                    // a bug enough buffer and make the property request
                    // again.
                    //
                    if (hr == HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER)) {
                        Framing = reinterpret_cast <PKSALLOCATOR_FRAMING>
                            (new BYTE [BytesReturned]);

                        if (!Framing) {
                            Control -> Release();
                            return E_OUTOFMEMORY;
                        }

                        hr = Control -> KsProperty (
                            &Property,
                            sizeof (KSPROPERTY),
                            Framing,
                            BytesReturned,
                            &BytesReturned
                            );
                    }
                } else {
                    Framing = &FramingSt;
                }

                //
                // If we didn't succeed, free memory.
                //
                if (!SUCCEEDED (hr)) {
                    if (Framing) {
                        delete [] Framing;
                        Framing = NULL;
                    }
                }
                    
            }

        } else {
            FramingEx = &FramingExSt;
        }

        TCHAR ItemText [512];

        //
        // If the extended allocator framing was supported, dump it.
        //
        if (FramingEx) {

            wsprintf (ItemText, TEXT("Kernel Extended Allocator Properties:"));
            ListBox_InsertItem (ConfigWindow, ItemText);

            wsprintf (ItemText, TEXT("    Compression = %lu / %lu (rcm = %lu)"),
                FramingEx -> OutputCompression.RatioNumerator,
                FramingEx -> OutputCompression.RatioDenominator,
                FramingEx -> OutputCompression.RatioConstantMargin
                );
            ListBox_InsertItem (ConfigWindow, ItemText);

            wsprintf (ItemText, TEXT("    Pin Weight = %lu"),
                FramingEx -> PinWeight
                );
            ListBox_InsertItem (ConfigWindow, ItemText);

            //
            // Iterate through all the framing items and dump characteristics.
            //
            for (ULONG i = 0; i < FramingEx -> CountItems; i++) {

                PKS_FRAMING_ITEM FramingItem = &(FramingEx -> FramingItem [i]);

                wsprintf (ItemText, TEXT("    Framing Item #%lu"),
                    i+1
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);

                wsprintf (ItemText, TEXT("        Frames = %lu"),  
                    FramingItem -> Frames
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);

                wsprintf (ItemText, TEXT("        Alignment = %lu"),
                    FramingItem -> FileAlignment
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);

                wsprintf (ItemText, TEXT("        Memory Type Weight = %lu"),
                    FramingItem -> MemoryTypeWeight
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);

                wsprintf (ItemText, 
                    TEXT("        Physical Range = %lu - %lu (step = %lu)"),
                    FramingItem -> PhysicalRange.MinFrameSize,
                    FramingItem -> PhysicalRange.MaxFrameSize,
                    FramingItem -> PhysicalRange.Stepping
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);

                wsprintf (ItemText,
                    TEXT("        Framing Range = %lu - %lu (step = %lu)"),
                    FramingItem -> FramingRange.Range.MinFrameSize,
                    FramingItem -> FramingRange.Range.MaxFrameSize,
                    FramingItem -> FramingRange.Range.Stepping
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);

                wsprintf (ItemText, TEXT("        Framing Range Weights:"));
                ListBox_InsertItem (ConfigWindow, ItemText);

                wsprintf (ItemText, TEXT("            In Place = %lu"),
                    FramingItem -> FramingRange.InPlaceWeight
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);

                wsprintf (ItemText, TEXT("            Not In Place = %lu"),
                    FramingItem -> FramingRange.NotInPlaceWeight
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);
            }
        }

        //
        // Otherwise, if regular allocator framing was supported, dump it.
        //
        else if (Framing) {

            wsprintf (ItemText, TEXT("Kernel Allocator Properties"));
            ListBox_InsertItem (ConfigWindow, ItemText);

            wsprintf (ItemText, TEXT("    Frames = %lu"),
                Framing -> Frames
                );
            ListBox_InsertItem (ConfigWindow, ItemText);

            wsprintf (ItemText, TEXT("    Frame Size = %lu"),
                Framing -> FrameSize
                );
            ListBox_InsertItem (ConfigWindow, ItemText);

            wsprintf (ItemText, TEXT("    Alignment = %lu"),
                Framing -> FileAlignment
                );
            ListBox_InsertItem (ConfigWindow, ItemText);

        }

        //
        // Otherwise, print a message stating that the kernel pin had no
        // framing!
        //
        else {

            wsprintf (ItemText, 
                TEXT("Kernel Pin Has No Allocator Properties!")
                );
            ListBox_InsertItem (ConfigWindow, ItemText);

        }

        //
        // Clean up
        //
        if (FramingEx && FramingEx != &FramingExSt) {
            delete [] FramingEx;
            FramingEx = NULL;
        }
        if (Framing && Framing != &FramingSt) {
            delete [] Framing;
            Framing = NULL;
        }

        Control -> Release ();

    }

    return hr;

}


HRESULT
CKsDebugPipesPropertyPage::
UpdatePipeSystem (
    )

/*++

Routine Description:

    Update the dialog box (m_Window) with the appropriate pipe system
    information.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    HRESULT hr;

    if (!m_Pin)
        return E_UNEXPECTED;

    IKsPinPipe *PinPipe;
    IKsAllocatorEx *PipeObject = NULL;

    //
    // Get the pin pipe interface for the object.  This particular interface
    // contains information about the pin as well as the pipe it belongs to.
    //
    if (!SUCCEEDED ( hr = (
        m_Pin -> QueryInterface (__uuidof (IKsPinPipe), (void **)&PinPipe)))) {

        return hr;

    }

    //
    // Peek the pipe.
    //
    PipeObject = PinPipe -> KsGetPipe (KsPeekOperation_PeekOnly);

    TCHAR ItemText[512];

    //
    // Update the name of the parent filter as KsProxy reports it.
    //
    PWCHAR FilterName = PinPipe -> KsGetFilterName ();
    wsprintf (ItemText, TEXT("%ls [0x%p]"), FilterName, m_Filter);
    SetDlgItemText (m_Window, IDC_FILTER, ItemText);

    //
    // Now, update the name of the pin as KsProxy reports it.
    //
    PWCHAR PinName = PinPipe -> KsGetPinName ();
    wsprintf (ItemText, TEXT("%ls [0x%p]"), PinName, m_Pin);
    SetDlgItemText (m_Window, IDC_PIN, ItemText);

    //
    // Now, update the pipe identifier on the pin as KsProxy reports
    // it.
    //
    if (PipeObject) {
        wsprintf (ItemText, TEXT("object at 0x%p"), PipeObject);
    } else {
        wsprintf (ItemText, TEXT("no pipe assigned yet!"));
    }
    SetDlgItemText (m_Window, IDC_PIPE, ItemText);

    //
    // Now, update the listbox with the configuration of the pipe.  But do
    // so only if a pipe has been assigned.
    //
    if (PipeObject) {

        HWND ConfigWindow = GetDlgItem (m_Window, IDC_CONFIG);

        wsprintf (ItemText, TEXT("Pipe Properties:"));
        ListBox_InsertItem (ConfigWindow, ItemText);

        //
        // Determine the allocator properties.
        //
        PALLOCATOR_PROPERTIES_EX AllocEx =
            PipeObject -> KsGetProperties ();

        if (!AllocEx) {
            wsprintf (ItemText, TEXT("    Cannot get properties!"));
            ListBox_InsertItem (ConfigWindow, ItemText);
        } else {
            wsprintf (ItemText, TEXT("    cBuffers = %lu"),
                AllocEx -> cBuffers
                );
            ListBox_InsertItem (ConfigWindow, ItemText);

            wsprintf (ItemText, TEXT("    cbBuffer = %lu"),
                AllocEx -> cbBuffer
                );
            ListBox_InsertItem (ConfigWindow, ItemText);

            wsprintf (ItemText, TEXT("    cbAlign  = %lu"),
                AllocEx -> cbAlign
                );
            ListBox_InsertItem (ConfigWindow, ItemText);
        }

        //
        // If we show a ring 3 DShow allocator, show the properties of 
        // the ring 3 DShow allocator.
        //
        IMemAllocator *Ring3Allocator =
            m_Pin -> KsPeekAllocator (KsPeekOperation_PeekOnly);

        if (Ring3Allocator) {

            wsprintf (ItemText, 
                TEXT("Ring 3 [DShow] Allocator Properties:"));
            ListBox_InsertItem (ConfigWindow, ItemText);

            ALLOCATOR_PROPERTIES Alloc;
            if (!SUCCEEDED (
                hr = Ring3Allocator -> GetProperties (&Alloc)
                )) {

                wsprintf (ItemText, TEXT("    Can't get properties!"));
                ListBox_InsertItem (ConfigWindow, ItemText);

            } else {
                wsprintf (ItemText, TEXT("    cBuffers = %lu"),
                    Alloc.cBuffers
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);
    
                wsprintf (ItemText, TEXT("    cbBuffer = %lu"),
                    Alloc.cbBuffer
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);
    
                wsprintf (ItemText, TEXT("    cbAlign  = %lu"),
                    Alloc.cbAlign
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);
            }
        }

        DisplayKernelAllocatorProperties (ConfigWindow);

        wsprintf (ItemText, TEXT("Pipe Layout:"));
        ListBox_InsertItem (ConfigWindow, ItemText);

        IKsPin *FirstKsPin;
        ULONG FirstPinType;
        BOOL RetCode = FindFirstPinOnPipe (
            m_Pin,
            m_PinType,
            &FirstKsPin,
            &FirstPinType
            );

        if (RetCode) {
            RetCode = WalkPipeAndProcess (
                FirstKsPin, 
                FirstPinType, 
                NULL,
                CKsDebugPipesPropertyPage::DisplayPipeLayoutCallback, 
                (PVOID*)&ConfigWindow,
                NULL
                );
        } else {
            wsprintf (ItemText, TEXT("    Unable to walk pipe!"));
            ListBox_InsertItem (ConfigWindow, ItemText);
        }

        if (AllocEx) {
            
            //
            // Display any dependent pipe in the previous segment list.
            //
            wsprintf (ItemText, TEXT("Previous Dependent Pipe Segment:"));
            ListBox_InsertItem (ConfigWindow, ItemText);

            if (AllocEx -> PrevSegment) {
                wsprintf (ItemText, TEXT("    Pipe 0x%p"), 
                    AllocEx -> PrevSegment
                    );
                ListBox_InsertItem (ConfigWindow, ItemText);
            } else {
                wsprintf (ItemText, TEXT("    No previous segment"));
                ListBox_InsertItem (ConfigWindow, ItemText);
            }

            //
            // Display any dependent pipes in the next segments list
            //
            wsprintf (ItemText, TEXT("Next Dependent Pipe Segments:"));
            ListBox_InsertItem (ConfigWindow, ItemText);

            if (AllocEx -> CountNextSegments) {
                for (ULONG i = 0; i < AllocEx -> CountNextSegments; i++) {
                    wsprintf (ItemText, TEXT("    Pipe 0x%p"),
                        AllocEx -> NextSegments [i]
                        );
                    ListBox_InsertItem (ConfigWindow, ItemText);
                }
            } else {
                wsprintf (ItemText, TEXT("    No next segments"));
                ListBox_InsertItem (ConfigWindow, ItemText);
            }
        }
    }

    PinPipe -> Release ();
    PinPipe = NULL;

    return S_OK;

}

BOOL
CALLBACK
CKsDebugPipesPropertyPage::
DialogProc (
    IN HWND Window,
    IN UINT Msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This is the dialog procedure for the debug pipes property page.

Arguments:

Return Value:

    Indicates whether we handled the message or not

--*/

{

    switch (Msg) {

        case WM_INITDIALOG:
            return TRUE;
            break;

        case WM_DESTROY:
            return TRUE;
            break;

        default:
            return FALSE;
            break;
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dbgpages\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dbgpages.rc
//
#define IDD_PIPEDIALOG                  101
#define IDC_PIN                         101
#define IDC_PIPE                        102
#define IDC_CONFIG                      103
#define IDC_FILTER                      1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dbgpages\dbgpages.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    dbgpages.h

Abstract:

    Internal debugging property page implementation.

Author(s):

    Bill Messmer

--*/

/**************************************************************************

    GUIDS

**************************************************************************/

#define STATIC_CLSID_DebugPipesPropertyPage = \
    0x8f62e8d3, 0x4f88, 0x4189, 0x88, 0x5e, 0x31, 0x7b, 0xed, 0xfc, 0x9e, 0x0e

DEFINE_GUIDSTRUCT("8F62E8D3-4F88-4189-885E-317BEDFC9E0E", CLSID_DebugPipesPropertyPage);
#define CLSID_DebugPipesPropertyPage DEFINE_GUIDNAMED(CLSID_DebugPipesPropertyPage)

/**************************************************************************

    PROPERTY PAGES

**************************************************************************/

class CKsDebugPipesPropertyPage : 
    public CUnknown,
    public IPropertyPage

{

private:

    IBaseFilter *m_Filter;
    IKsPin *m_Pin;
    IPropertyPageSite *m_PageSite;

    ULONG m_PinType;

    HWND m_Window;

public:

    DECLARE_IUNKNOWN;

    //
    // CreateInstance():
    //
    // Create an instance of the debug pipes property page.
    //
    static 
    CUnknown *
    CreateInstance (
        IN LPUNKNOWN lpunk, 
        IN HRESULT *phr
        );

    //
    // CKsDebugPipesPropertyPage():
    //
    // Constructor for the property page.
    //
    CKsDebugPipesPropertyPage (
        IN LPUNKNOWN lpunk,
        IN HRESULT *phr
        );

    //
    // ~CKsDebugPipesPropertyPage():
    //
    // Destructor for the property page.
    //
    ~CKsDebugPipesPropertyPage (
        );

    //
    // NonDelegatingQueryInterface():
    //
    // Non delegating QI
    //
    STDMETHODIMP 
    NonDelegatingQueryInterface (
        IN REFIID riid, 
        OUT void ** ppv
        );

    //
    // IPropertyPage::GetPageInfo():
    //
    // Implements the GetPageInfo function.  Returns information about
    // the property page.
    //
    STDMETHODIMP 
    GetPageInfo (
        IN LPPROPPAGEINFO PageInfo
        );

    //
    // IPropertyPage::SetObjects():
    //
    // Implements the IPropertyPage::SetObjects function.  Gets an interface to
    // the pin object the property page pertains to.
    //
    STDMETHODIMP 
    SetObjects (
        IN ULONG NumObjects, 
        IN LPUNKNOWN FAR* Objects
        );

    //
    // IPropertyPage::IsPageDirty():
    //
    // Implements the IPropertyPage::IsPageDirty function.  Currently,
    // no page is ever dirty.
    //
    STDMETHODIMP
    IsPageDirty (
        void
        );

    //
    // IPropertyPage::Apply():
    //
    // Implements the IPropertyPage::Apply function.  Currently, no
    // changes can ever be made.
    //
    STDMETHODIMP 
    Apply (
        void
        );

    //
    // IPropertyPage::SetPageSite():
    //
    // Implements the IPropertyPage::SetPageSite function.  Saves or releases
    // interfaces to the page site.
    //
    STDMETHODIMP
    SetPageSite (
        IN IPropertyPageSite *PageSite
        );

    //
    // IPropertyPage::Activate():
    //
    // Implements the IPropertyPage::Activate function.  Creates the dialog
    // and moves it to the specified location.
    //
    STDMETHODIMP 
    Activate (
        IN HWND ParentWindow, 
        IN LPCRECT Rect, 
        IN BOOL Modal
        );


    //
    // IPropertyPage::Deactivate():
    //
    // Implements the IPropertyPage::Deactivate function.  Destroy the
    // dialog, etc...
    //
    STDMETHODIMP 
    Deactivate (
        void
        );

    //
    // IPropertyPage::Move():
    //
    // Implements the IPropertyPage::Move function.  Move the dialog window
    // to the specified location.
    //
    STDMETHODIMP 
    Move (
        IN LPCRECT Rect
        );

    //
    // IPropertyPage::Show():
    //
    // Implements the IPropertyPage::Show function.  Show the dialog window
    // as specified by nCmdShow
    //
    STDMETHODIMP 
    Show (
        UINT nCmdShow
        );

    STDMETHODIMP Help(LPCWSTR)                 { return E_NOTIMPL; }
    STDMETHODIMP TranslateAccelerator(LPMSG)     { return E_NOTIMPL; }

    //
    // DialogProc():
    //
    // The dialog procedure for the debug pipes property page.
    //
    static BOOL CALLBACK
    DialogProc (
        IN HWND Window,
        IN UINT Msg,
        IN WPARAM wParam,
        IN LPARAM lParam
        );

    //
    // UpdatePipeSystem():
    //
    // Update the dialog with information about the current pipe system.
    //
    HRESULT
    UpdatePipeSystem (
        );

    //
    // DeterminePinTypeAndParentFilter():
    //
    // Determine whether m_Pin is an input or output pin.  Set m_PinType
    // accordingly.  Also determine the parent filter and set m_Filter
    // accordingly.
    //
    HRESULT
    DeterminePinTypeAndParentFilter (
        );

    //
    // DisplayPipeLayoutCallback():
    //
    // Callback from the proxy's pipe walker to display pipe layout in
    // the listbox control with HWND *((HWND *)Param1).
    //
    static BOOL
    DisplayPipeLayoutCallback (
        IN IKsPin* KsPin,
        IN ULONG PinType,
        IN OUT PVOID* Param1,
        IN PVOID* Param2,
        OUT BOOL* IsDone
        );

    //
    // DisplayKernelAllocatorProperties():
    //
    // Display kernel mode allocator properties for m_Pin into the list
    // box ConfigWindow.
    //
    HRESULT
    DisplayKernelAllocatorProperties (
        IN HWND ConfigWindow
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\msmid32\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

#define STR_MODULENAME "MSWAV32:"

#define DEBUGLVL_BLAB    3
#define DEBUGLVL_VERBOSE 2
#define DEBUGLVL_TERSE   1
#define DEBUGLVL_ERROR   0

#if ( DBG )

ULONG DbgPrint( PCH pchFormat, ... );

   #if !defined( DEBUG_LEVEL )
   #define DEBUG_LEVEL DEBUGLVL_TERSE
   #endif

   #define _DbgPrintF( lvl, strings ) if (lvl <= DEBUG_LEVEL) {\
      DbgPrint( STR_MODULENAME );\
      DbgPrint##strings;\
      DbgPrint("\n");\
      if (lvl == DEBUGLVL_ERROR) {\
         DebugBreak();\
      }\
   }
#else
   #define _DbgPrintF( lvl, strings )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\mswav32\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

#define STR_MODULENAME "MSWAV32:"

#define DEBUGLVL_BLAB    3
#define DEBUGLVL_VERBOSE 2
#define DEBUGLVL_TERSE   1
#define DEBUGLVL_ERROR   0

#if ( DBG )

ULONG DbgPrint( PCH pchFormat, ... );

   #if !defined( DEBUG_LEVEL )
   #define DEBUG_LEVEL DEBUGLVL_TERSE
   #endif

   #define _DbgPrintF( lvl, strings ) if (lvl <= DEBUG_LEVEL) {\
      DbgPrint( STR_MODULENAME );\
      DbgPrint##strings;\
      DbgPrint("\n");\
      if (lvl == DEBUGLVL_ERROR) {\
         DebugBreak();\
      }\
   }
#else
   #define _DbgPrintF( lvl, strings )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\msmid32\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       debug.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdarg.h>
#include <stdio.h>

#include "debug.h"

#if ( DBG )
ULONG DbgPrint( PCH pchFormat, ... )
{
    int         i;
    char        buf[256];
    va_list     va;

    va_start( va, pchFormat );
    i = vsprintf( buf, pchFormat, va );
    va_end( va );

    OutputDebugString( buf );
    return (ULONG) i;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\mswav32\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       debug.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdarg.h>
#include <stdio.h>

#include "debug.h"

#if ( DBG )
ULONG DbgPrint( PCH pchFormat, ... )
{
    int         i;
    char        buf[256];
    va_list     va;

    va_start( va, pchFormat );
    i = vsprintf( buf, pchFormat, va );
    va_end( va );

    OutputDebugString( buf );
    return (ULONG) i;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\msmid32\drvproc.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

	drvproc.c

Abstract:

	Driver entry point.

--*/

#include <windows.h>
#include <mmsystem.h>

HANDLE ModuleHandle;

LRESULT DriverProc(
    DWORD   DriverId,
    HDRVR   DriverHandle,
    UINT    Message,
    LPARAM  Param1,
    LPARAM  Param2
    )
{
    LRESULT lr;

    switch (Message) 
    {
        case DRV_LOAD:
            ModuleHandle = GetDriverModuleHandle(DriverHandle);
            return (LRESULT)1L;

        case DRV_FREE:
            return (LRESULT)1L;

        case DRV_OPEN:
            return (LRESULT)1L;

        case DRV_CLOSE:
            return (LRESULT)1L;

        case DRV_ENABLE:
            return 1L;

        case DRV_DISABLE:
            return (LRESULT)1L;

        case DRV_QUERYCONFIGURE:
            return 0L;

        case DRV_CONFIGURE:
            return 0L;

        case DRV_INSTALL:
            return 1L;

        case DRV_REMOVE:
            return 1L;

        default:
            return DefDriverProc( DriverId,
                                  DriverHandle,
                                  Message,
                                  Param1,
                                  Param2 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\mswav32\private.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       private.h
//
//--------------------------------------------------------------------------

#ifdef DEBUG
    extern WORD  wDebugLevel;     // debug level
    #define D( x )          { x }
    #define DPF( x, y ) if (x <= wDebugLevel) (OutputDebugStr(STR_PROLOGUE),OutputDebugStr(y),OutputDebugStr(STR_CRLF))
#else
    #define D( x )
    #define DPF( x, y )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\mswav32\drvproc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       drvproc.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <mmsystem.h>

HANDLE ghModule;

LRESULT DriverProc
(
    DWORD   dwDriverID,
    HDRVR   hDriver,
    UINT    uiMessage,
    LPARAM  lParam1,
    LPARAM  lParam2
)
{
    LRESULT lr;

    switch (uiMessage) 
    {
        case DRV_LOAD:
            ghModule = GetDriverModuleHandle(hDriver);
            return (LRESULT)1L;

        case DRV_FREE:
            return (LRESULT)1L;

        case DRV_OPEN:
            return (LRESULT)1L;

        case DRV_CLOSE:
            return (LRESULT)1L;

        case DRV_ENABLE:
            return 1L;

        case DRV_DISABLE:
            return (LRESULT)1L;

        case DRV_QUERYCONFIGURE:
            return 0L;

        case DRV_CONFIGURE:
            return 0L;

        case DRV_INSTALL:
            return 1L;

        case DRV_REMOVE:
            return 1L;

        default:
            return DefDriverProc( dwDriverID, 
                                  hDriver,
                                  uiMessage,
                                  lParam1,
                                  lParam2 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\msmid32\middrv.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    middrv.c

Abstract:

    MIDI input functionality.

--*/

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <objbase.h>
#include <devioctl.h>

#include <ks.h>
#include <ksmedia.h>

#include "debug.h"

#define IS_REALTIME(b)      (((b) & 0xF8) == 0xF8)
#define IS_SYSTEM(b)        (((b) & 0xF0) == 0xF0)
#define IS_CHANNEL(b)       ((b) & 0x80)
#define IS_STATUS(b)        ((b) & 0x80)
#define MSGLENCHANNEL(b)    MsgLenChannel[(UCHAR)((b) >> 4) - (UCHAR)8]
#define MSGLENSYSTEM(b)     MsgLenSystem[(UCHAR)(b - 0xF0)];

#define MIDI_NOTEOFF            ((BYTE)0x80)    //2
#define MIDI_NOTEON             ((BYTE)0x90)    //2
#define MIDI_POLYPRESSURE       ((BYTE)0xA0)    //2
#define MIDI_CONTROLCHANGE      ((BYTE)0xB0)    //2
#define MIDI_PROGRAMCHANGE      ((BYTE)0xC0)    //1
#define MIDI_CHANPRESSURE       ((BYTE)0xD0)    //1
#define MIDI_PITCHBEND          ((BYTE)0xE0)    //2
#define MIDI_SYSEX              ((BYTE)0xF0)    //n
#define MIDI_TIMECODEQUARTER    ((BYTE)0xF1)    //1
#define MIDI_SONGPOSITION       ((BYTE)0xF2)    //2
#define MIDI_SONGSELECT         ((BYTE)0xF3)    //1
#define MIDI_F4                 ((BYTE)0xF4)    //?
#define MIDI_F5                 ((BYTE)0xF5)    //?
#define MIDI_TUNEREQUEST        ((BYTE)0xF6)    //0
#define MIDI_SYSEXEND           ((BYTE)0xF7)    //n

static UCHAR MsgLenChannel[] = {
    3-1,    /* 0x80 note off    */
    3-1,    /* 0x90 note on     */
    3-1,    /* 0xA0 key pressure    */
    3-1,    /* 0xB0 control change  */
    2-1,    /* 0xC0 program change  */
    2-1,    /* 0xD0 channel pressure*/
    3-1     /* 0xE0 pitch bend  */
};

static UCHAR MsgLenSystem[] = {
    0,      /* 0xF0 sysex begin     */
    2-1,    /* 0xF1 midi tcqf       */
    3-1,    /* 0xF2 song position   */
    2-1,    /* 0xF3 song select     */
    1-1,    /* 0xF4 undefined       */
    1-1,    /* 0xF5 undefined       */
    1-1,    /* 0xF6 tune request    */
    0,      /* 0xF7 sysex eox       */
};

#define STREAM_SIZE     256
#define STREAM_BUFFERS  3

typedef struct tagSTREAM_DATA {
    OVERLAPPED              Overlapped;
    ULONG                   BytesProcessed;
    BOOL                    DoneProcessing;
    struct tagSTREAM_DATA*  NextStreamData;
} STREAM_DATA, *PSTREAM_DATA;

typedef struct {
    HANDLE              FilterHandle;
    HANDLE              ConnectionHandle;
    HANDLE              ThreadHandle;
    CRITICAL_SECTION    Critical;
    KSEVENTDATA         EventData;
    HMIDI               MidiDeviceHandle;
    DWORD               CallbackType;
    DWORD               CallbackFlags;
    DWORD               CallbackContext;
    DWORD               ThreadId;
    LONGLONG            PositionBase;
    LONGLONG            TimeBase;
    ULONG               LastTimeOffset;
    LPMIDIHDR           MidiHdr;
    PSTREAM_DATA        StreamData;
    ULONG               EventBytesLeft;
    ULONG               BlockBytesLeft;
    UCHAR               EventList[sizeof(ULONG)];
    BOOL                ClosingDevice;
    BOOL                SysEx;
    HANDLE              ControlEventHandle;
    UCHAR               RunningStatus;
} MIDIINSTANCE, *PMIDIINSTANCE;

MMRESULT
midFunctionalControl(
    PMIDIINSTANCE   MidiInstance,
    ULONG           IoControl,
    PVOID           InBuffer,
    ULONG           InSize,
    PVOID           OutBuffer,
    ULONG           OutSize
    )
{
    BOOLEAN     Result;
    OVERLAPPED  Overlapped;
    ULONG       BytesReturned;

    ZeroMemory(&Overlapped, sizeof(OVERLAPPED));
    Overlapped.hEvent = MidiInstance->ControlEventHandle;
    if (!(Result = DeviceIoControl(MidiInstance->FilterHandle, IoControl, InBuffer, InSize, OutBuffer, OutSize, &BytesReturned, &Overlapped)) && (ERROR_IO_PENDING == GetLastError())) {
        WaitForSingleObject(Overlapped.hEvent, INFINITE);
        Result = TRUE;
    }
    return Result ? MMSYSERR_NOERROR : MMSYSERR_ERROR;
}

MMRESULT
midConnectionControl(
    PMIDIINSTANCE   MidiInstance,
    ULONG           IoControl,
    PVOID           InBuffer,
    ULONG           InSize,
    PVOID           OutBuffer,
    ULONG           OutSize
    )
{
    BOOLEAN     Result;
    OVERLAPPED  Overlapped;
    ULONG       BytesReturned;

    ZeroMemory(&Overlapped, sizeof(OVERLAPPED));
    Overlapped.hEvent = MidiInstance->ControlEventHandle;
    if (!(Result = DeviceIoControl(MidiInstance->ConnectionHandle, IoControl, InBuffer, InSize, OutBuffer, OutSize, &BytesReturned, &Overlapped)) && (ERROR_IO_PENDING == GetLastError())) {
        WaitForSingleObject(Overlapped.hEvent, INFINITE);
        Result = TRUE;
    }
    return Result ? MMSYSERR_NOERROR : MMSYSERR_ERROR;
}

VOID
midCallback(
    PMIDIINSTANCE   MidiInstance,
    DWORD           Message,
    DWORD           Param1,
    DWORD           Param2
    )
{
    DriverCallback(MidiInstance->CallbackType, HIWORD(MidiInstance->CallbackFlags), (HDRVR)MidiInstance->MidiDeviceHandle, Message, MidiInstance->CallbackContext, Param1, Param2);
}

MMRESULT
midSetState(
    PMIDIINSTANCE   MidiInstance,
    KSSTATE         State
    )
{
    KSPROPERTY  Property;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return midConnectionControl(MidiInstance, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &State, sizeof(State));
}

MMRESULT
midGetTimeBase(
    PMIDIINSTANCE   MidiInstance,
    PLONGLONG       TimeBase
    )
{
    KSPROPERTY  Property;

    //!! needs to be fixed to use timebase again
    Property.Set = KSPROPSETID_Linear;
    Property.Id = KSPROPERTY_LINEAR_POSITION;
    Property.Flags = KSPROPERTY_TYPE_GET;
    return midConnectionControl(MidiInstance, IOCTL_KS_PROPERTY, &Property, sizeof(Property), TimeBase, sizeof(*TimeBase));
}

MMRESULT
midGetDevCaps(
    UINT    DeviceId,
    PBYTE   MidiCaps,
    ULONG   MidiCapsSize
    )
{
    MIDIINCAPSW MidiInCaps;

    MidiInCaps.wMid = 1;
    MidiInCaps.wPid = 1;
    MidiInCaps.vDriverVersion = 0x400;
    wcscpy(MidiInCaps.szPname, L"MIDI Input Device");
    MidiInCaps.dwSupport = 0;
    CopyMemory(MidiCaps, &MidiInCaps, min(sizeof(MidiInCaps), MidiCapsSize));
    return MMSYSERR_NOERROR;
}

MMRESULT
midConnect(
    PMIDIINSTANCE   MidiInstance
    )
{
    UCHAR           ConnectBuffer[sizeof(KSPIN_CONNECT)+sizeof(KSDATAFORMAT)];
//  UCHAR           ConnectBuffer[sizeof(KSPIN_CONNECT)+sizeof(KSDATAFORMAT_MUSIC)];
    PKSPIN_CONNECT  Connect;
//  PKSDATAFORMAT_MUSIC Music;
    PKSDATAFORMAT   Music;

    Connect = (PKSPIN_CONNECT)ConnectBuffer;
    Connect->PinId = 2;
    Connect->PinToHandle = NULL;
    Connect->Interface.Set = KSINTERFACESETID_Media;
    Connect->Interface.Id = KSINTERFACE_MEDIA_MUSIC;
    Connect->Medium.Set = KSMEDIUMSETID_Standard;
    Connect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = 0;
//  Music = (PKSDATAFORMAT_MUSIC)(Connect + 1);
    Music = (PKSDATAFORMAT)(Connect + 1);
    Music->MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
    Music->SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
    Music->Specifier = KSDATAFORMAT_FORMAT_NONE;
//  Music->DataFormat.FormatSize = sizeof(KSDATAFORMAT_MUSIC);
    Music->FormatSize = sizeof(KSDATAFORMAT);
//  Music->FormatId = KSDATAFORMAT_MUSIC_MIDI;
    return KsCreatePin(MidiInstance->FilterHandle, Connect, GENERIC_READ, &MidiInstance->ConnectionHandle) ? MMSYSERR_ERROR : MMSYSERR_NOERROR;
}

MMRESULT
midOpen(
    UINT            DeviceId,
    LPVOID*         InstanceContext,
    LPMIDIOPENDESC  MidiOpenDesc,
    ULONG           CallbackFlags
    )
{
    HANDLE          FilterHandle;
    MMRESULT        Result;
    PMIDIINSTANCE   MidiInstance;

    FilterHandle = CreateFile(TEXT("\\\\.\\msmpu401.SB16_Dev0"), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
    if (FilterHandle == (HANDLE)-1)
        return MMSYSERR_BADDEVICEID;
    if (MidiInstance = (PMIDIINSTANCE)LocalAlloc(LPTR, sizeof(MIDIINSTANCE))) {
        if (MidiInstance->ControlEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL)) {
            MidiInstance->FilterHandle = FilterHandle;
            if (!(Result = midConnect(MidiInstance))) {
                KSEVENT Event;

                Event.Set = KSEVENTSETID_Connection;
                Event.Id = KSEVENT_CONNECTION_POSITIONUPDATE;
                Event.Flags = KSEVENT_TYPE_ENABLE;
                MidiInstance->EventData.NotificationType = KSEVENTF_HANDLE;
                MidiInstance->EventData.Reserved = 0;
                MidiInstance->EventData.EventHandle.Event = CreateEvent(NULL, FALSE, FALSE, NULL);
                MidiInstance->EventData.EventHandle.Reserved = 0;
                midConnectionControl(MidiInstance, IOCTL_KS_ENABLE_EVENT, &Event, sizeof(Event), &MidiInstance->EventData, sizeof(MidiInstance->EventData));
                midSetState(MidiInstance, KSSTATE_PAUSE);
                InitializeCriticalSection(&MidiInstance->Critical);
                MidiInstance->MidiDeviceHandle = MidiOpenDesc->hMidi;
                MidiInstance->CallbackType = MidiOpenDesc->dwCallback;
                MidiInstance->CallbackContext = MidiOpenDesc->dwInstance;
                MidiInstance->CallbackFlags = CallbackFlags;
                MidiInstance->PositionBase = 0;
                midGetTimeBase(MidiInstance, &MidiInstance->TimeBase);
                MidiInstance->LastTimeOffset = 0;
                MidiInstance->MidiHdr = NULL;
                MidiInstance->StreamData = NULL;
                MidiInstance->EventBytesLeft = 0;
                MidiInstance->BlockBytesLeft = 0;
                MidiInstance->ClosingDevice = FALSE;
                MidiInstance->SysEx = FALSE;
                MidiInstance->RunningStatus = 0;
                *InstanceContext = MidiInstance;
                midCallback(MidiInstance, MIM_OPEN, 0, 0);
                return MMSYSERR_NOERROR;
            } else
                Result = MMSYSERR_ALLOCATED;
            CloseHandle(MidiInstance->ControlEventHandle);
        } else
            Result = MMSYSERR_NOMEM;
        LocalFree(MidiInstance);
    } else
        Result = MMSYSERR_NOMEM;
    CloseHandle(FilterHandle);
    return Result;
}

MMRESULT
midGetPosition(
    PMIDIINSTANCE   MidiInstance,
    PDWORDLONG      Position
    )
{
    KSPROPERTY  Property;

    Property.Set = KSPROPSETID_Linear;
    Property.Id = KSPROPERTY_LINEAR_POSITION;
    Property.Flags = KSPROPERTY_TYPE_GET;
    return midConnectionControl(MidiInstance, IOCTL_KS_PROPERTY, &Property, sizeof(Property), Position, sizeof(*Position));
}

VOID
midSysExByte(
    PMIDIINSTANCE   MidiInstance,
    UCHAR           DataSize
    )
{
    PMIDIHDR    MidiHdr;

    EnterCriticalSection(&MidiInstance->Critical);
    MidiHdr = MidiInstance->MidiHdr;
    if (MidiHdr) {
        MidiHdr->lpData[MidiInstance->MidiHdr->dwBytesRecorded++] = DataSize;
        if (MidiHdr->dwBytesRecorded >= MidiHdr->dwBufferLength) {
            MidiHdr->dwFlags |= MHDR_DONE;
            MidiInstance->MidiHdr = MidiInstance->MidiHdr->lpNext;
            midCallback(MidiInstance, MIM_LONGDATA, (DWORD)MidiHdr, 0);
        }
    }
    LeaveCriticalSection(&MidiInstance->Critical);
}

VOID
midServiceData(
    PMIDIINSTANCE   MidiInstance
    )
{
    PSTREAM_DATA    StreamData;
    LONGLONG        CurrentPosition;
    LONGLONG        DevicePosition;

    CurrentPosition = MidiInstance->PositionBase;
    for (StreamData = MidiInstance->StreamData;; StreamData = StreamData->NextStreamData)
        if (!StreamData)
            return;
        else if (!StreamData->DoneProcessing)
            break;
        else
            CurrentPosition += StreamData->BytesProcessed;
    midGetPosition(MidiInstance, (PDWORDLONG)&DevicePosition);
    while (DevicePosition > CurrentPosition + StreamData->BytesProcessed)
        if (!MidiInstance->BlockBytesLeft) {
            ULONG   AlignmentSize;

            AlignmentSize = ((StreamData->BytesProcessed + 3) & ~3) - StreamData->BytesProcessed;
            if (StreamData->BytesProcessed + AlignmentSize + sizeof(ULONG) + sizeof(UCHAR) > STREAM_SIZE) {
                StreamData->DoneProcessing = TRUE;
                CurrentPosition += StreamData->BytesProcessed;
                StreamData = StreamData->NextStreamData;
                if (!StreamData)
                    return;
            } else {
                StreamData->BytesProcessed += AlignmentSize;
                MidiInstance->LastTimeOffset = *(PULONG)((PUCHAR)(StreamData + 1) + StreamData->BytesProcessed);
                StreamData->BytesProcessed += sizeof(ULONG);
                MidiInstance->BlockBytesLeft = *((PUCHAR)(StreamData + 1) + StreamData->BytesProcessed++);
            }
        } else {
            UCHAR   DataSize;

            if (StreamData->BytesProcessed == STREAM_SIZE)
                return;
            DataSize = *((PUCHAR)(StreamData + 1) + StreamData->BytesProcessed++);
            MidiInstance->BlockBytesLeft--;
            if (IS_REALTIME(DataSize))
                midCallback(MidiInstance, MIM_DATA, (DWORD)DataSize, MidiInstance->LastTimeOffset);
            else if (IS_STATUS(DataSize)) {
                if (MidiInstance->SysEx) {
                    MidiInstance->SysEx = FALSE;
                    midSysExByte(MidiInstance, MIDI_SYSEXEND);
                    if (DataSize == MIDI_SYSEXEND)
                        continue;
                }
                if (MidiInstance->EventBytesLeft) {
                    MidiInstance->EventList[3] -= (UCHAR)MidiInstance->EventBytesLeft;
                    midCallback(MidiInstance, MIM_ERROR, *(PDWORD)&MidiInstance->EventList, MidiInstance->LastTimeOffset);
                }
                if (IS_SYSTEM(DataSize)) {
                    MidiInstance->RunningStatus = 0;
                    MidiInstance->EventBytesLeft = MSGLENSYSTEM(DataSize);
                    switch (DataSize) {
                    case MIDI_SYSEX:
                        MidiInstance->SysEx = TRUE;
                        midSysExByte(MidiInstance, DataSize);
                        continue;
                    case MIDI_SYSEXEND:
                        MidiInstance->EventList[3] = (UCHAR)1;
                        MidiInstance->EventList[0] = MIDI_SYSEXEND;
                        midCallback(MidiInstance, MIM_ERROR, *(PDWORD)&MidiInstance->EventList, MidiInstance->LastTimeOffset);
                        continue;
                    }
                } else {
                    MidiInstance->RunningStatus = DataSize;
                    MidiInstance->EventBytesLeft = MSGLENCHANNEL(DataSize);
                }
                MidiInstance->EventList[0] = DataSize;
                MidiInstance->EventList[3] = (UCHAR)MidiInstance->EventBytesLeft + 1;
                if (!MidiInstance->EventBytesLeft)
                    midCallback(MidiInstance, MIM_DATA, *(PDWORD)&MidiInstance->EventList, MidiInstance->LastTimeOffset);
            } else if (MidiInstance->SysEx)
                midSysExByte(MidiInstance, DataSize);
            else if (!MidiInstance->RunningStatus) {
                MidiInstance->EventList[3] = (UCHAR)1;
                MidiInstance->EventList[0] = DataSize;
                midCallback(MidiInstance, MIM_ERROR, *(PDWORD)&MidiInstance->EventList, MidiInstance->LastTimeOffset);
            } else {
                if (!MidiInstance->EventBytesLeft) {
                    MidiInstance->EventList[0] = MidiInstance->RunningStatus;
                    MidiInstance->EventBytesLeft = MSGLENCHANNEL(MidiInstance->RunningStatus);
                    MidiInstance->EventList[3] = (UCHAR)MidiInstance->EventBytesLeft + 1;
                }
                MidiInstance->EventList[MidiInstance->EventList[3] - MidiInstance->EventBytesLeft] = DataSize;
                if (!--MidiInstance->EventBytesLeft)
                    midCallback(MidiInstance, MIM_DATA, *(PDWORD)&MidiInstance->EventList, MidiInstance->LastTimeOffset);
            }
        }
}

DWORD
midThread(
    PMIDIINSTANCE  MidiInstance
    )
{
    HANDLE          WaitHandleList[2];
    PSTREAM_DATA    StreamData;
    ULONG           BytesRead;

    WaitHandleList[1] = MidiInstance->EventData.EventHandle.Event;
    for (StreamData = MidiInstance->StreamData; StreamData; StreamData = StreamData->NextStreamData) {
        StreamData->BytesProcessed = 0;
        StreamData->DoneProcessing = FALSE;
        ReadFile(MidiInstance->ConnectionHandle, StreamData + 1, STREAM_SIZE, &BytesRead, &StreamData->Overlapped);
    }
    for (;;) {
        DWORD   WaitReturn;

        WaitHandleList[0] = MidiInstance->StreamData->Overlapped.hEvent;
        WaitReturn = WaitForMultipleObjects(sizeof(WaitHandleList) / sizeof(WaitHandleList[0]), WaitHandleList, FALSE, INFINITE);
        if (MidiInstance->ClosingDevice)
            break;
        if (WaitReturn == WAIT_OBJECT_0) {
            GetOverlappedResult(MidiInstance->ConnectionHandle, &MidiInstance->StreamData->Overlapped, &BytesRead, TRUE);
            _DbgPrintF( DEBUGLVL_VERBOSE, ("midThread BytesRead=%lu", BytesRead));
            if (BytesRead) {
                midServiceData(MidiInstance);
                MidiInstance->PositionBase += BytesRead;
            }
            for (StreamData = MidiInstance->StreamData; StreamData->NextStreamData; StreamData = StreamData->NextStreamData)
                ;
            StreamData->NextStreamData = MidiInstance->StreamData;
            MidiInstance->StreamData = MidiInstance->StreamData->NextStreamData;
            StreamData = StreamData->NextStreamData;
            StreamData->NextStreamData = NULL;
            StreamData->BytesProcessed = 0;
            StreamData->DoneProcessing = FALSE;
            ReadFile(MidiInstance->ConnectionHandle, StreamData + 1, STREAM_SIZE, &BytesRead, &StreamData->Overlapped);
        } else if (WaitReturn == WAIT_OBJECT_0 + 1)
            midServiceData(MidiInstance);
        else
            _DbgPrintF( DEBUGLVL_VERBOSE, ("midThread WaitReturn=%lx", WaitReturn));
    }
    for (; MidiInstance->StreamData;) {
        GetOverlappedResult(MidiInstance->ConnectionHandle, &MidiInstance->StreamData->Overlapped, &BytesRead, TRUE);
        CloseHandle(MidiInstance->StreamData->Overlapped.hEvent);
        StreamData = MidiInstance->StreamData;
        MidiInstance->StreamData = StreamData->NextStreamData;
        LocalFree(StreamData);
    }
    return 0;
}

MMRESULT
midAddBuffer(
    PMIDIINSTANCE   MidiInstance,
    LPMIDIHDR       MidiHdr
    )
{
    if (!(MidiHdr->dwFlags & MHDR_PREPARED))
        return MIDIERR_UNPREPARED;
    if (MidiHdr->dwFlags & MHDR_INQUEUE)
        return MIDIERR_STILLPLAYING;
    if (!MidiHdr->dwBufferLength)
        return MMSYSERR_INVALPARAM;
    MidiHdr->dwFlags &= ~MHDR_DONE;
    MidiHdr->dwBytesRecorded = 0;
    MidiHdr->lpNext = NULL;
    EnterCriticalSection(&MidiInstance->Critical);
    if (MidiInstance->MidiHdr) {
        LPMIDIHDR   MidiHdrCur;

        for (MidiHdrCur = MidiInstance->MidiHdr; MidiHdr->lpNext; MidiHdr = MidiHdr->lpNext)
            ;
        MidiHdr->lpNext = MidiHdr;
    } else
        MidiInstance->MidiHdr = MidiHdr;
    MidiHdr->dwFlags |= MHDR_INQUEUE;
    LeaveCriticalSection(&MidiInstance->Critical);
    return MMSYSERR_NOERROR;
}

MMRESULT
midReset(
    PMIDIINSTANCE  MidiInstance
    )
{
    EnterCriticalSection(&MidiInstance->Critical);
    for (; MidiInstance->MidiHdr; MidiInstance->MidiHdr = MidiInstance->MidiHdr->lpNext) {
        MidiInstance->MidiHdr->dwFlags &= ~MHDR_INQUEUE;
        MidiInstance->MidiHdr->dwFlags |= MHDR_DONE;
        midCallback(MidiInstance, MIM_LONGDATA, (ULONG)MidiInstance->MidiHdr, 0);
    }
    LeaveCriticalSection(&MidiInstance->Critical);
    FlushFileBuffers(MidiInstance->ConnectionHandle);
    return MMSYSERR_NOERROR;
}

MMRESULT
midStart(
    PMIDIINSTANCE  MidiInstance
    )
{
    ULONG   BufferCount;

    if (!MidiInstance->ThreadHandle) {
        for (BufferCount = 0; BufferCount < STREAM_BUFFERS; BufferCount++) {
            PSTREAM_DATA    StreamData;

            StreamData = (PSTREAM_DATA)LocalAlloc(LPTR, sizeof(STREAM_DATA) + STREAM_SIZE);
            StreamData->Overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            StreamData->NextStreamData = MidiInstance->StreamData;
            MidiInstance->StreamData = StreamData;
        }
        MidiInstance->ThreadHandle = CreateThread(NULL, 0, (PTHREAD_START_ROUTINE)midThread, MidiInstance, 0, &MidiInstance->ThreadId);
        SetThreadPriority(MidiInstance->ThreadHandle, THREAD_PRIORITY_TIME_CRITICAL);
    }
    return midSetState(MidiInstance, KSSTATE_RUN);
}

MMRESULT
midStop(
    PMIDIINSTANCE  MidiInstance
    )
{
    return midSetState(MidiInstance, KSSTATE_PAUSE);
}

MMRESULT
midClose(
    PMIDIINSTANCE  MidiInstance
    )
{
    midSetState(MidiInstance, KSSTATE_STOP);
    MidiInstance->ClosingDevice = TRUE;
    midReset(MidiInstance);
    if (MidiInstance->ThreadHandle) {
        SetEvent(MidiInstance->EventData.EventHandle.Event);
        WaitForSingleObject(MidiInstance->ThreadHandle, INFINITE);
    }
    CloseHandle(MidiInstance->ConnectionHandle);
    CloseHandle(MidiInstance->FilterHandle);
    CloseHandle(MidiInstance->ControlEventHandle);
    midCallback(MidiInstance, MIM_CLOSE, 0, 0);
    LocalFree(MidiInstance);
    return MMSYSERR_NOERROR;
}

DWORD
APIENTRY midMessage(
    DWORD   DeviceId,
    DWORD   Message,
    DWORD   InstanceContext,
    DWORD   Param1,
    DWORD   Param2
    )
{
    switch (Message) {
    case DRVM_INIT:
        return MMSYSERR_NOERROR;
    case MIDM_GETNUMDEVS:
        return 1;
    case MIDM_GETDEVCAPS:
        return midGetDevCaps(DeviceId, (LPBYTE)Param1, Param2);
    case MIDM_OPEN:
        return midOpen(DeviceId, (LPVOID *)InstanceContext, (LPMIDIOPENDESC)Param1, Param2);
    case MIDM_CLOSE:
        return midClose((PMIDIINSTANCE)InstanceContext);
    case MIDM_ADDBUFFER:
        return midAddBuffer((PMIDIINSTANCE)InstanceContext, (LPMIDIHDR) Param1);
    case MIDM_START:
        return midStart((PMIDIINSTANCE)InstanceContext);
    case MIDM_STOP:
        return midStop((PMIDIINSTANCE)InstanceContext);
    case MIDM_RESET:
        return midReset((PMIDIINSTANCE)InstanceContext);
    }
    _DbgPrintF( DEBUGLVL_VERBOSE, ("MIDM_??(%lx), device DeviceId==%ld: unsupported", Message, DeviceId));
    return MMSYSERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\mswav32\woddrv.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       woddrv.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <objbase.h>
#include <devioctl.h>

#include <ks.h>
#include <ksmedia.h>

#include "debug.h"

// HACK! HACK! HACK!

HANDLE ghAEC = NULL;

typedef struct tagWODINSTANCE;

typedef struct tagWAVEHDREX
{
   PWAVEHDR               phdr;
   struct tagWODINSTANCE  *pwi;
   OVERLAPPED             Overlapped;
   struct tagWAVEHDREX    *pNext;

} WAVEHDREX, *PWAVEHDREX;

typedef struct tagWODINSTANCE
{
   HANDLE             hDevSink, hThread, hWaveIOSink, hevtQueue;
#if defined( AEC )
   HANDLE             hAECSink;
#endif
   HWAVE              hWave;
   CRITICAL_SECTION   csQueue;
   DWORD              cbSample, dwCallback, dwFlags, dwInstance, dwThreadId;
   volatile BOOL      fExit, fActive, fPaused;
   KSSTATE            ksCurrentState;
   PWAVEHDREX         pQueue;
                     
} WODINSTANCE, *PWODINSTANCE;

BOOL WvWrite
(
    HANDLE      hDevice,
    PWAVEHDREX  phdrex
)
{
   BOOL        fResult;
   ULONG       cbWritten;

   fResult = 
      WriteFile( hDevice, phdrex->phdr, sizeof( WAVEHDR ), &cbWritten, 
                 &phdrex->Overlapped );

   if (!fResult)
      return (ERROR_IO_PENDING == GetLastError());
   else
      return TRUE;
}

BOOL WvControl
(
   HANDLE   hDevice,
   DWORD    dwIoControl,
   PVOID    pvIn,
   ULONG    cbIn,
   PVOID    pvOut,
   ULONG    cbOut,
   PULONG   pcbReturned
)
{
   BOOL        fResult;
   OVERLAPPED  ov;

   RtlZeroMemory( &ov, sizeof( OVERLAPPED ) );
   if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL )))
      return FALSE;

   fResult =
      DeviceIoControl( hDevice,
                       dwIoControl,
                       pvIn,
                       cbIn,
                       pvOut,
                       cbOut,
                       pcbReturned,
                       &ov );


   if (!fResult)
   {
      if (ERROR_IO_PENDING == GetLastError())
      {
         WaitForSingleObject( ov.hEvent, INFINITE );
         fResult = TRUE;
      }
      else
         fResult = FALSE;
   }

   CloseHandle( ov.hEvent );

   return fResult;

}

static VOID WvSetState
(
   PWODINSTANCE   pwi,
   KSSTATE        DeviceState
)
{
    KSPROPERTY   Property;
    ULONG        cbReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;

    if (pwi->ksCurrentState == DeviceState)
        return;

    if ((KSSTATE_STOP == pwi->ksCurrentState) && 
        (KSSTATE_PAUSE == DeviceState))
    {
        // propogate upstream

        WvControl( pwi->hDevSink,
                  IOCTL_KS_PROPERTY,
                  &Property,
                  sizeof( Property ),
                  &DeviceState,
                  sizeof( DeviceState ),
                  &cbReturned );

        WvControl( pwi->hWaveIOSink,
                  (DWORD) IOCTL_KS_PROPERTY,
                  &Property,
                  sizeof( Property ),
                  &DeviceState,
                  sizeof( DeviceState ),
                  &cbReturned );
    }
    else
    {
        // propogate downstream 

        WvControl( pwi->hWaveIOSink,
                  (DWORD) IOCTL_KS_PROPERTY,
                  &Property,
                  sizeof( Property ),
                  &DeviceState,
                  sizeof( DeviceState ),
                  &cbReturned );

        WvControl( pwi->hDevSink,
                  (DWORD) IOCTL_KS_PROPERTY,
                  &Property,
                  sizeof( Property ),
                  &DeviceState,
                  sizeof( DeviceState ),
                  &cbReturned );
    }
    pwi->ksCurrentState = DeviceState;

}

VOID WvGetPosition
(
   HANDLE   hDevice,
   PULONG   pulCurrentDevicePosition
)
{
   KSPROPERTY   Property;
   DWORDLONG    Position;
   ULONG        cbReturned;

   Property.Set = KSPROPSETID_Wave_Queued;
   Property.Id =  KSPROPERTY_WAVE_QUEUED_POSITION;
   Property.Flags = KSPROPERTY_TYPE_GET;

   if (!WvControl( hDevice,
                   IOCTL_KS_PROPERTY,
                   &Property,
                   sizeof( Property ),
                   &Position,
                   sizeof( Position ),
                   &cbReturned ) || !cbReturned)
      *pulCurrentDevicePosition = (ULONG) 0;
   else
      *pulCurrentDevicePosition = (ULONG) Position;
}

VOID wodCallback
(
   PWODINSTANCE   pwi,
   DWORD          dwMsg,
   DWORD          dwParam1
)
{
   if (pwi->dwCallback)
      DriverCallback( pwi->dwCallback,         // user's callback DWORD
                      HIWORD( pwi->dwFlags ),  // callback flags
                      (HDRVR) pwi->hWave,      // handle to the wave device
                      dwMsg,                   // the message
                      pwi->dwInstance,         // user's instance data
                      dwParam1,                // first DWORD
                      0L );                    // second DWORD
}


VOID wodBlockFinished
(
    PWAVEHDREX  phdrex
)
{
   // Invoke the callback function..

   CloseHandle( phdrex->Overlapped.hEvent );
   wodCallback( phdrex->pwi, WOM_DONE, (DWORD) phdrex->phdr );
   HeapFree( GetProcessHeap(), 0, phdrex );
} 


DWORD wodThread
(
   PWODINSTANCE   pwi
)
{
    BOOL          fDone;
    PWAVEHDREX    phdrex;

    // Keep looping until all notifications are posted...

    fDone = FALSE;
    while (!fDone || !pwi->fExit)
    {
        fDone = FALSE;
        EnterCriticalSection( &pwi->csQueue );
        if (pwi->pQueue)
        {
            LeaveCriticalSection( &pwi->csQueue );
            WaitForSingleObject( pwi->pQueue->Overlapped.hEvent, INFINITE );
            EnterCriticalSection( &pwi->csQueue );
            if (phdrex = pwi->pQueue)
            {
                pwi->pQueue = pwi->pQueue->pNext;
                wodBlockFinished( phdrex );
            }
            LeaveCriticalSection( &pwi->csQueue );
        }
        else
        {
            fDone = TRUE;
            if (pwi->fActive)
            {
                WvSetState( pwi, KSSTATE_PAUSE );
                InterlockedExchange( (LPLONG)&pwi->fActive, FALSE );
            }
            LeaveCriticalSection( &pwi->csQueue );
            WaitForSingleObject( pwi->hevtQueue, INFINITE );
        }
    }

    CloseHandle( pwi->hevtQueue );
    pwi->hevtQueue = NULL;

    return 0;
}

MMRESULT wodGetPos
(
   PWODINSTANCE   pwi,
   LPMMTIME       pmmt,
   ULONG          cbSize
)
{
   ULONG ulCurrentPos;
   
   WvGetPosition( pwi->hWaveIOSink, &ulCurrentPos );

   // Write this to the buffer as appropriate.

   if (pmmt-> wType == TIME_BYTES)
      pmmt->u.cb = ulCurrentPos;
   else
   {
      pmmt->wType = TIME_SAMPLES;
      pmmt->u.sample = ulCurrentPos / pwi->cbSample;
   }

   return MMSYSERR_NOERROR;
}

MMRESULT wodGetDevCaps
(
   UINT  uDevId,
   PBYTE pwc,
   ULONG cbSize
)
{
   WAVEOUTCAPSW wc;

   wc.wMid = 1;
   wc.wPid = 1;
   wc.vDriverVersion = 0x400;
   wc.dwFormats = WAVE_FORMAT_1M08 | WAVE_FORMAT_1S08 |
                   WAVE_FORMAT_1M16 | WAVE_FORMAT_1S16 |
                   WAVE_FORMAT_2M08 | WAVE_FORMAT_2S08 |
                   WAVE_FORMAT_2M16 | WAVE_FORMAT_2S16 |
                   WAVE_FORMAT_4M08 | WAVE_FORMAT_4S08 |
                   WAVE_FORMAT_4M16 | WAVE_FORMAT_4S16;
   wc.wChannels = 2;
   wc.dwSupport = WAVECAPS_VOLUME | WAVECAPS_LRVOLUME | 
                  WAVECAPS_SAMPLEACCURATE;
//                  | WAVECAPS_DIRECTSOUND;

   wcscpy( wc.szPname, L"Windows Sound System" );

   CopyMemory( pwc, &wc, min( sizeof( wc ), cbSize ) );

   return MMSYSERR_NOERROR;
}

#define REGSTR_PATH_WDMAUDIO TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\wdm\\audio")
#define REGSTR_PATH_WDMAEC TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\wdm\\aec")

MMRESULT wodOpen
(
   UINT           uDevId,
   LPVOID         *ppvUser,
   LPWAVEOPENDESC pwodesc,
   ULONG          ulFlags
)
{
    PKSPIN_CONNECT              pConnect;
    PKSDATAFORMAT_WAVEFORMATEX  pDataFormat;
    HANDLE                      hDeviceConnect, hDeviceSink, hSink,
#if defined( AEC )
                                hAECConnect,
                                hAECSourceToWaveIOSink,
                                hWaveIOSink,
#endif
                                hWaveIOSourceToDevice,
                                hWaveIOConnect;
    LPWAVEFORMATEX              pwf;
    PWODINSTANCE                pwi;
    ULONG                       cbReturned;
    WCHAR                       aszValue[128];
                           
    pwf = (LPWAVEFORMATEX) pwodesc->lpFormat;

    hDeviceConnect =           INVALID_HANDLE_VALUE ;
    hDeviceSink =              INVALID_HANDLE_VALUE ;
    hSink =                    INVALID_HANDLE_VALUE ;
    hWaveIOSourceToDevice =    INVALID_HANDLE_VALUE ;
    hWaveIOConnect =           INVALID_HANDLE_VALUE ;

#if defined( AEC )
    hAECConnect =              INVALID_HANDLE_VALUE ;
    hAECSourceToWaveIOSink =   INVALID_HANDLE_VALUE ;
    hWaveIOSink =              INVALID_HANDLE_VALUE ;
#endif

   if (NULL == 
         (pConnect = HeapAlloc( GetProcessHeap(), 0, 
                                sizeof( KSPIN_CONNECT ) + 
                                   sizeof( KSDATAFORMAT_WAVEFORMATEX ) )))
      return MMSYSERR_NOMEM;

   hWaveIOConnect = CreateFile( L"\\\\.\\MSWAVEIO\\{9B365890-165F-11D0-A195-0020AFD156E4}",
                                GENERIC_READ,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                NULL );
                                  
   if (hWaveIOConnect == INVALID_HANDLE_VALUE)
      goto Error;

#if defined( AEC )
    if (ghAEC)
    hAECConnect = ghAEC;
    else
   hAECConnect = CreateFile( L"\\\\.\\AEC",
                             GENERIC_READ,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                             NULL );

   if (hAECConnect == INVALID_HANDLE_VALUE)
      goto Error;
#endif

   cbReturned = sizeof(aszValue);
   if (RegQueryValue (HKEY_LOCAL_MACHINE, REGSTR_PATH_WDMAUDIO, aszValue, &cbReturned) != ERROR_SUCCESS)
      goto Error;

   hDeviceConnect = CreateFile( aszValue,
                                GENERIC_READ,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                NULL );

   if (hDeviceConnect == INVALID_HANDLE_VALUE)
      goto Error;

   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_BUFFERED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 2;  // SOUNDPRT DAC SINK
   // no "connect to"
   pConnect->PinToHandle = NULL;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   pDataFormat = (PKSDATAFORMAT_WAVEFORMATEX) (pConnect + 1);

   pDataFormat->DataFormat.FormatSize = sizeof( KSDATAFORMAT_WAVEFORMATEX );
   pDataFormat->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
   INIT_WAVEFORMATEX_GUID( &pDataFormat->DataFormat.SubFormat,
                           pwf->wFormatTag );
   pDataFormat->DataFormat.Specifier = KSDATAFORMAT_FORMAT_WAVEFORMATEX;
   pDataFormat->WaveFormatEx.cbSize = 0;

   try {
       RtlCopyMemory( &pDataFormat->WaveFormatEx, 
                      pwf, 
                      (pwf->wFormatTag == WAVE_FORMAT_PCM) ?
                        sizeof( PCMWAVEFORMAT ) : sizeof( WAVEFORMATEX ) );
   } except( EXCEPTION_EXECUTE_HANDLER ) {
       HeapFree( GetProcessHeap(), 0, pConnect );
       CloseHandle( hWaveIOSourceToDevice );
       CloseHandle( hDeviceConnect );
       return WAVERR_BADFORMAT;
   }

   if (KsCreatePin( hDeviceConnect, pConnect, GENERIC_WRITE, &hDeviceSink ))
      goto Error;


   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_BUFFERED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 0;  // MSWAVEIO SOURCE
   pConnect->PinToHandle = hDeviceSink;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   if (KsCreatePin( hWaveIOConnect, pConnect, GENERIC_READ, &hWaveIOSourceToDevice ))
      goto Error;

   if (ulFlags & WAVE_FORMAT_QUERY)
   {
      HeapFree( GetProcessHeap(), 0, pConnect );
#if defined( AEC )
      if (hAECConnect != ghAEC)
        CloseHandle( hAECConnect );
#endif
      CloseHandle( hWaveIOSourceToDevice );
      CloseHandle( hDeviceSink );
      CloseHandle( hWaveIOConnect );
      CloseHandle( hDeviceConnect );
      return MMSYSERR_NOERROR;
   }

#if defined( AEC )

   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_QUEUED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 1;  // MSWAVEIO DAC SINK
   // no "connect to"
   pConnect->PinToHandle = NULL;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   if (KsCreatePin( hWaveIOConnect, pConnect, GENERIC_WRITE, &hWaveIOSink ))
      goto Error;

   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_QUEUED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 0;  // AEC SOURCE
   pConnect->PinToHandle = hWaveIOSink;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   if (KsCreatePin( hAECConnect, pConnect, GENERIC_READ, &hAECSourceToWaveIOSink ))
      goto Error;
#endif

   pwi = (PWODINSTANCE) LocalAlloc( LPTR, sizeof( WODINSTANCE ) );

   if (NULL == pwi)
        goto Error;

#if defined( AEC )
   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_QUEUED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 1;  // AEC DAC SINK
   // no "connect to"
   pConnect->PinToHandle = NULL;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   if (KsCreatePin( hAECConnect, pConnect, GENERIC_WRITE, &hSink ))
      goto Error;
#else
   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_QUEUED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 1;  // MSWAVEIO DAC SINK
   // no "connect to"
   pConnect->PinToHandle = NULL;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   if (KsCreatePin( hWaveIOConnect, pConnect, GENERIC_WRITE, &hSink ))
      goto Error;
#endif

   pwi->hWaveIOSink = hSink;
   pwi->hDevSink = hDeviceSink;
#if defined( AEC )
   ghAEC = hAECConnect;
#endif
   InitializeCriticalSection( &pwi->csQueue );

#if defined( AEC )
    CloseHandle( hAECSourceToWaveIOSink ) ;
    CloseHandle( hWaveIOSink );
    if (ghAEC != hAECConnect)
        CloseHandle( hAECConnect );
#endif
    CloseHandle( hWaveIOSourceToDevice );
    CloseHandle( hWaveIOConnect );
    CloseHandle( hDeviceConnect );

    HeapFree( GetProcessHeap(), 0, pConnect );

    pwi->hWave = pwodesc->hWave;
    pwi->dwCallback = pwodesc->dwCallback;
    pwi->dwInstance = pwodesc->dwInstance;
    pwi->dwFlags = ulFlags;

    pwi->cbSample = pwf->nChannels;
    pwi->cbSample *= pwf->wBitsPerSample / 8;

    pwi->pQueue = NULL;
    pwi->fActive = FALSE;
    pwi->fPaused = FALSE;
    pwi->fExit = FALSE;

    //
    // Prepare the device...
    //

    WvSetState( pwi, KSSTATE_PAUSE );

    *ppvUser = pwi;

    wodCallback( pwi, WOM_OPEN, 0L);

    return MMSYSERR_NOERROR;


Error:

    if (pConnect)
        HeapFree( GetProcessHeap(), 0, pConnect );

#if defined( AEC )
    if (INVALID_HANDLE_VALUE != hAECSourceToWaveIOSink)
        CloseHandle( hAECSourceToWaveIOSink ) ;
    if (INVALID_HANDLE_VALUE != hWaveIOSink)
        CloseHandle( hWaveIOSink );
    if (INVALID_HANDLE_VALUE != hAECConnect)
    {
        if (ghAEC != hAECConnect)
            CloseHandle( hAECConnect );
    }
#endif

    if (INVALID_HANDLE_VALUE != hWaveIOSourceToDevice)
        CloseHandle( hWaveIOSourceToDevice );
    if (INVALID_HANDLE_VALUE != hDeviceSink)
        CloseHandle( hDeviceSink );
    if (INVALID_HANDLE_VALUE != hWaveIOConnect)
        CloseHandle( hWaveIOConnect );
    if (INVALID_HANDLE_VALUE != hDeviceConnect)
        CloseHandle( hDeviceConnect );

    return MMSYSERR_BADDEVICEID;
}

MMRESULT wodStart
(
   PWODINSTANCE   pwi
)
{
    if (pwi->fActive)
        return MMSYSERR_INVALPARAM;

    if (!pwi->hThread)
    {
        pwi->hevtQueue = 
            CreateEvent( NULL,      // no security
                         FALSE,     // auto reset
                         FALSE,     // initially not signalled
                         NULL );    // unnamed
        pwi->hThread =
            CreateThread( NULL,                            // no security
                        0,                                 // default stack
                        (PTHREAD_START_ROUTINE) wodThread,
                        (PVOID) pwi,                       // parameter
                        0,                                 // default create flags
                        &pwi->dwThreadId );                // container for
                                                            //    thread id
//        SetThreadPriority( pwi->hThread, THREAD_PRIORITY_TIME_CRITICAL );
    }

    if (NULL == pwi->hThread)
    {
        if (pwi->hevtQueue)
        {
            CloseHandle( pwi->hevtQueue );
            pwi->hevtQueue = NULL;
        }
        return MMSYSERR_ERROR;
    }

    WvSetState( pwi, KSSTATE_RUN );
    InterlockedExchange( (LPLONG)&pwi->fActive, TRUE );

    return MMSYSERR_NOERROR;
}

MMRESULT wodWrite
(
   PWODINSTANCE   pwi,
   LPWAVEHDR      phdr
)
{
    PWAVEHDREX  phdrex, pTemp;
    MMRESULT    mmr;
   
    mmr = MMSYSERR_NOERROR;

    // check if it's been prepared

    if (0 == (phdr->dwFlags & WHDR_PREPARED))
            return WAVERR_UNPREPARED;

    if (phdr->dwFlags & WHDR_INQUEUE)
            return WAVERR_STILLPLAYING;

    if (NULL == 
            (phdrex = HeapAlloc( GetProcessHeap(), 0, sizeof( WAVEHDREX ) )))
        return MMSYSERR_NOMEM;

    phdrex->phdr = phdr;
    phdrex->pwi = pwi;
    phdrex->pNext = NULL;
    RtlZeroMemory( &phdrex->Overlapped, sizeof( OVERLAPPED ) );

    if (NULL == (phdrex->Overlapped.hEvent = 
                    CreateEvent( NULL, TRUE, FALSE, NULL )))
    {
       HeapFree( GetProcessHeap(), 0, phdrex );
       return MMSYSERR_NOMEM;
    }

    phdr->lpNext = 0;

    phdr->dwFlags |= WHDR_INQUEUE;
    phdr->dwFlags &= ~WHDR_DONE;

    EnterCriticalSection( &pwi->csQueue );
    if (!pwi->pQueue)
    {
        pwi->pQueue = phdrex;
        pTemp = NULL;
        if (pwi->hevtQueue)
            SetEvent( pwi->hevtQueue );
    }
    else
    {
        for (pTemp = pwi->pQueue;
             pTemp->pNext != NULL;
             pTemp = pTemp->pNext);
                             
        pTemp->pNext = phdrex;
        pTemp->phdr->lpNext = phdrex->phdr;
    }
    LeaveCriticalSection( &pwi->csQueue );

    if (!WvWrite( pwi->hWaveIOSink, phdrex ))
    {
       // Unlink...

       CloseHandle( phdrex->Overlapped.hEvent );
       HeapFree( GetProcessHeap(), 0, phdrex );

       if (pTemp)
       {
           pTemp->pNext = NULL;
           pTemp->phdr->lpNext = NULL;
       }
       else
           pwi->pQueue = NULL;
       phdr->dwFlags &= ~WHDR_INQUEUE;

       return MMSYSERR_INVALPARAM;
    }

    if (!pwi->fActive && !pwi->fPaused)
        return wodStart( pwi );
    else
        return MMSYSERR_NOERROR;
}

MMRESULT wodPause
(
   PWODINSTANCE   pwi
)
{
   if (!pwi->fPaused)
   {
      if (pwi->fActive)
         WvSetState( pwi, KSSTATE_PAUSE );
      pwi->fPaused = TRUE;
   }

   return MMSYSERR_NOERROR;
}

MMRESULT wodReset
(
   PWODINSTANCE   pwi
)
{
    ULONG cbReturned;

    WvSetState( pwi, KSSTATE_PAUSE );
    InterlockedExchange( (LPLONG)&pwi->fActive, FALSE );
    pwi->fPaused = FALSE;
    CancelIo( pwi->hWaveIOSink );
    WvControl( pwi->hWaveIOSink,
               IOCTL_KS_RESET_STATE,
               NULL,
               0,
               NULL,
               0,
               &cbReturned );
    if (pwi->hThread)
    {
        InterlockedExchange( (LPLONG)&pwi->fExit, TRUE );
        SetEvent( pwi->hevtQueue );
        WaitForSingleObject( pwi->hThread, INFINITE );
        CloseHandle( pwi->hThread );
        pwi->hThread = NULL;
    }

    return MMSYSERR_NOERROR;
}

MMRESULT wodResume
(
   PWODINSTANCE   pwi
)
{
   if (pwi->fPaused)
   {
      pwi->fPaused = FALSE;
      if (pwi->fActive)
         WvSetState( pwi, KSSTATE_RUN );
      else
         wodStart( pwi );
   }

   return MMSYSERR_NOERROR;
}

MMRESULT wodClose
(
   PWODINSTANCE   pwi
)
{
    HANDLE      hDevice;

    if (pwi->pQueue)
      return WAVERR_STILLPLAYING;

    WvSetState( pwi, KSSTATE_STOP );
    InterlockedExchange( (LPLONG)&pwi->fActive, FALSE );

    hDevice = pwi->hWaveIOSink;
    pwi->hWaveIOSink = NULL;
    CloseHandle( hDevice );

    hDevice = pwi->hDevSink;
    pwi->hDevSink = NULL;
    CloseHandle( hDevice );

    //
    // synchronize cleanup with worker thread 
    //

    if (pwi->hThread)
    {
      InterlockedExchange( (LPLONG)&pwi->fExit, TRUE );
      SetEvent( pwi->hevtQueue );
      WaitForSingleObject( pwi->hThread, INFINITE );
      CloseHandle( pwi->hThread );
      pwi->hThread = NULL;
    }

    wodCallback( pwi, WOM_CLOSE, 0L );
    LocalFree( pwi );

    return MMSYSERR_NOERROR;
}

DWORD APIENTRY wodMessage
(
   DWORD id,
   DWORD msg,
   DWORD dwUser,
   DWORD dwParam1,
   DWORD dwParam2
)
{
    switch (msg) 
    {
        case DRVM_INIT:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_INIT"));
            return MMSYSERR_NOERROR;

        case WODM_GETNUMDEVS:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_GETNUMDEVS"));
            return 1;

        case WODM_GETDEVCAPS:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_GETDEVCAPS, device id==%d", id));
            return wodGetDevCaps( id, (LPBYTE) dwParam1, dwParam2 );

        case WODM_OPEN:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_OPEN, device id==%d", id));
            return wodOpen( id, (LPVOID *) dwUser,
                            (LPWAVEOPENDESC) dwParam1, dwParam2  );

        case WODM_CLOSE:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_CLOSE, device id==%d", id));
            return wodClose( (PWODINSTANCE) dwUser );

        case WODM_WRITE:
            _DbgPrintF( DEBUGLVL_BLAB,("WODM_WRITE, device id==%d", id));
            return wodWrite( (PWODINSTANCE) dwUser, (LPWAVEHDR) dwParam1 );

        case WODM_PAUSE:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_PAUSE, device id==%d", id));
            return wodPause( (PWODINSTANCE) dwUser );

        case WODM_RESTART:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_RESTART, device id==%d", id));
            return wodResume( (PWODINSTANCE) dwUser );

        case WODM_RESET:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_RESET, device id==%d", id));
            return wodReset( (PWODINSTANCE) dwUser );

        case WODM_BREAKLOOP:
        {
            KSMETHOD     Method;
            PWODINSTANCE pwi = (PWODINSTANCE) dwUser;
            ULONG        cbReturned;

            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_BREAKLOOP, device id==%d", id));

            Method.Set = KSMETHODSETID_Wave_Queued;
            Method.Id = KSMETHOD_WAVE_QUEUED_BREAKLOOP;
            Method.Flags = KSMETHOD_TYPE_NONE;

            WvControl( pwi->hWaveIOSink,
                       IOCTL_KS_METHOD,
                       &Method,
                       sizeof( Method ),
                       NULL,
                       0,
                       &cbReturned );

            return MMSYSERR_NOERROR;
        }

        case WODM_GETPOS:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_GETPOS, device id==%d", id));
            return wodGetPos( (PWODINSTANCE) dwUser,
                            (LPMMTIME) dwParam1, dwParam2 );

        case WODM_SETPITCH:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_SETPITCH, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_SETVOLUME:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_SETVOLUME, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_SETPLAYBACKRATE:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_SETPLAYBACKRATE, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_GETPITCH:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_GETPITCH, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_GETVOLUME:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_GETVOLUME, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_GETPLAYBACKRATE:
            _DbgPrintF( DEBUGLVL_VERBOSE,("WODM_GETPLAYBACKRATE, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        default:
            return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    return MMSYSERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\msmid32\moddrv.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

	moddrv.c

Abstract:

	MIDI output functionality.

--*/

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <objbase.h>
#include <devioctl.h>

#include <ks.h>
#include <ksmedia.h>

#include "debug.h"

#define	IS_STATUS(b)		((b) & 0x80)
#define	MSG_EVENT(b)		((b) & 0xF0)

#define	MIDI_NOTEOFF		((BYTE)0x80)
#define	MIDI_NOTEON			((BYTE)0x90)
#define	MIDI_POLYPRESSURE	((BYTE)0xA0)
#define	MIDI_CONTROLCHANGE	((BYTE)0xB0)
#define	MIDI_PROGRAMCHANGE	((BYTE)0xC0)
#define	MIDI_CHANPRESSURE	((BYTE)0xD0)
#define	MIDI_PITCHBEND		((BYTE)0xE0)

UCHAR EventAllOff[] = { 
	0xb0,0x7b,0x00,
	0xb1,0x7b,0x00,
	0xb2,0x7b,0x00,
	0xb3,0x7b,0x00,
	0xb4,0x7b,0x00,
	0xb5,0x7b,0x00,
	0xb6,0x7b,0x00,
	0xb7,0x7b,0x00,
	0xb8,0x7b,0x00,
	0xb9,0x7b,0x00,
	0xba,0x7b,0x00,
	0xbb,0x7b,0x00,
	0xbc,0x7b,0x00,
	0xbd,0x7b,0x00,
	0xbe,0x7b,0x00,
	0xbf,0x7b,0x00
};

typedef struct {
	HANDLE	FilterHandle;
	HANDLE	ConnectionHandle;
	HMIDI	MidiDeviceHandle;
	DWORD	CallbackType;
	DWORD	CallbackFlags;
	DWORD	CallbackContext;
	HANDLE	ControlEventHandle;
	BYTE	RunningStatus;
} MIDIINSTANCE, *PMIDIINSTANCE;

BOOLEAN
modConnectionWrite(
	PMIDIINSTANCE	MidiInstance,
	PVOID			Buffer,
	ULONG			BufferSize
	)
{
	BOOLEAN		Result;
	OVERLAPPED	Overlapped;
	DWORD		BytesWritten;

	ZeroMemory(&Overlapped, sizeof(OVERLAPPED));
	Overlapped.hEvent = MidiInstance->ControlEventHandle;
	if (!(Result = WriteFile(MidiInstance->ConnectionHandle, Buffer, BufferSize, &BytesWritten, &Overlapped)) && (ERROR_IO_PENDING == GetLastError())) {
		WaitForSingleObject(Overlapped.hEvent, INFINITE);
		Result = TRUE;
	}
	return Result;
}

MMRESULT
modFunctionalControl(
	PMIDIINSTANCE	MidiInstance,
	ULONG			IoControl,
	PVOID			InBuffer,
	ULONG			InSize,
	PVOID			OutBuffer,
	ULONG			OutSize
	)
{
	BOOLEAN		Result;
	OVERLAPPED	Overlapped;
	ULONG		BytesReturned;

	ZeroMemory(&Overlapped, sizeof(OVERLAPPED));
	Overlapped.hEvent = MidiInstance->ControlEventHandle;
	if (!(Result = DeviceIoControl(MidiInstance->FilterHandle, IoControl, InBuffer, InSize, OutBuffer, OutSize, &BytesReturned, &Overlapped)) && (ERROR_IO_PENDING == GetLastError())) {
		WaitForSingleObject(Overlapped.hEvent, INFINITE);
		Result = TRUE;
	}
	return Result ? MMSYSERR_NOERROR : MMSYSERR_ERROR;
}

MMRESULT
modConnectionControl(
	PMIDIINSTANCE	MidiInstance,
	ULONG			IoControl,
	PVOID			InBuffer,
	ULONG			InSize,
	PVOID			OutBuffer,
	ULONG			OutSize
	)
{
	BOOLEAN		Result;
	OVERLAPPED	Overlapped;
	ULONG		BytesReturned;

	ZeroMemory(&Overlapped, sizeof(OVERLAPPED));
	Overlapped.hEvent = MidiInstance->ControlEventHandle;
	if (!(Result = DeviceIoControl(MidiInstance->ConnectionHandle, IoControl, InBuffer, InSize, OutBuffer, OutSize, &BytesReturned, &Overlapped)) && (ERROR_IO_PENDING == GetLastError())) {
		WaitForSingleObject(Overlapped.hEvent, INFINITE);
		Result = TRUE;
	}
	return Result ? MMSYSERR_NOERROR : MMSYSERR_ERROR;
}

VOID
modCallback(
	PMIDIINSTANCE	MidiInstance,
	DWORD			Message,
	DWORD			Param1
	)
{
	DriverCallback(MidiInstance->CallbackType, HIWORD(MidiInstance->CallbackFlags), (HDRVR)MidiInstance->MidiDeviceHandle, Message, MidiInstance->CallbackContext, Param1, 0);
}

MMRESULT
modGetDevCaps(
	UINT	DeviceId,
	PBYTE	MidiCaps,
	ULONG	MidiCapsSize
	)
{
	MIDIOUTCAPSW	MidiOutCaps;

	MidiOutCaps.wMid = 1;
	MidiOutCaps.wPid = 1;
	MidiOutCaps.vDriverVersion = 0x400;
	wcscpy(MidiOutCaps.szPname, L"MIDI Output Device");
	MidiOutCaps.wTechnology = MOD_MIDIPORT;
	MidiOutCaps.wVoices = 0;
	MidiOutCaps.wNotes = 0;
	MidiOutCaps.wChannelMask = 0;
	MidiOutCaps.dwSupport = 0;
	CopyMemory(MidiCaps, &MidiOutCaps, min(sizeof(MidiOutCaps), MidiCapsSize));
	return MMSYSERR_NOERROR;
}

MMRESULT
modSetState(
	PMIDIINSTANCE	MidiInstance,
	KSSTATE			State
	)
{
	KSPROPERTY     Property;

	Property.Set = KSPROPSETID_Connection;
	Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;
	return modConnectionControl(MidiInstance, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &State, sizeof(State));
}

MMRESULT
modConnect(
	PMIDIINSTANCE	MidiInstance
	)
{
	UCHAR			ConnectBuffer[sizeof(KSPIN_CONNECT)+sizeof(KSDATAFORMAT)];
//	UCHAR			ConnectBuffer[sizeof(KSPIN_CONNECT)+sizeof(KSDATAFORMAT_MUSIC)];
	PKSPIN_CONNECT	Connect;
//	PKSDATAFORMAT_MUSIC	Music;
	PKSDATAFORMAT	Music;

	Connect = (PKSPIN_CONNECT)ConnectBuffer;
	Connect->PinId = 0;
	Connect->PinToHandle = NULL;
	Connect->Interface.Set = KSINTERFACESETID_Media;
	Connect->Interface.Id = KSINTERFACE_MEDIA_MUSIC;
	Connect->Medium.Set = KSMEDIUMSETID_Standard;
	Connect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
	Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
	Connect->Priority.PrioritySubClass = 0;
//	Music = (PKSDATAFORMAT_MUSIC)(Connect + 1);
	Music = (PKSDATAFORMAT)(Connect + 1);
	Music->MajorFormat = KSDATAFORMAT_TYPE_MUSIC;
	Music->SubFormat = KSDATAFORMAT_SUBTYPE_MIDI;
	Music->Specifier = KSDATAFORMAT_FORMAT_NONE;
//	Music->DataFormat.FormatSize = sizeof(KSDATAFORMAT_MUSIC);
	Music->FormatSize = sizeof(KSDATAFORMAT);
//	Music->idFormat = KSDATAFORMAT_MUSIC_MIDI;
	return KsCreatePin(MidiInstance->FilterHandle, Connect, GENERIC_WRITE, &MidiInstance->ConnectionHandle) ? MMSYSERR_ERROR : MMSYSERR_NOERROR;
}

MMRESULT
modOpen(
	UINT			DeviceId,
	LPVOID*			InstanceContext,
	LPMIDIOPENDESC	MidiOpenDesc,
	ULONG			CallbackFlags
	)
{
	HANDLE			FilterHandle;
	MMRESULT		Result;
	PMIDIINSTANCE	MidiInstance;

	FilterHandle = CreateFile(TEXT("\\\\.\\msmpu401.SB16_Dev0"), GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
	if (FilterHandle == (HANDLE)-1)
		return MMSYSERR_BADDEVICEID;
	if (MidiInstance = (PMIDIINSTANCE)LocalAlloc(LPTR, sizeof(MIDIINSTANCE))) {
		if (MidiInstance->ControlEventHandle = CreateEvent(NULL, TRUE, FALSE, NULL)) {
			MidiInstance->FilterHandle = FilterHandle;
			if (!(Result = modConnect(MidiInstance))) {
				MidiInstance->MidiDeviceHandle = MidiOpenDesc->hMidi;
				MidiInstance->CallbackType = MidiOpenDesc->dwCallback;
				MidiInstance->CallbackContext = MidiOpenDesc->dwInstance;
				MidiInstance->CallbackFlags = CallbackFlags;
				MidiInstance->RunningStatus = 0;
				modSetState(MidiInstance, KSSTATE_RUN);
				*InstanceContext = MidiInstance;
				modCallback(MidiInstance, MOM_OPEN, 0);
				return MMSYSERR_NOERROR;
			} else
				Result = MMSYSERR_ALLOCATED;
			CloseHandle(MidiInstance->ControlEventHandle);
		} else
			Result = MMSYSERR_NOMEM;
		LocalFree(MidiInstance);
	} else
		Result = MMSYSERR_NOMEM;
	CloseHandle(FilterHandle);
	return Result;
}

MMRESULT
modData(
	PMIDIINSTANCE	MidiInstance,
	LPBYTE			MidiEvent
	)
{
	BYTE	MidiEventStatus;
	ULONG	MidiEventSize;

	MidiEventStatus = *MidiEvent;
	if (!IS_STATUS(MidiEventStatus))
		MidiEventStatus = MidiInstance->RunningStatus;
	switch (MSG_EVENT(MidiEventStatus)) {
	case MIDI_NOTEOFF:
	case MIDI_NOTEON:
	case MIDI_POLYPRESSURE:
	case MIDI_CONTROLCHANGE:
	case MIDI_PITCHBEND:
		MidiEventSize = 3;
		break;
	case MIDI_PROGRAMCHANGE:
	case MIDI_CHANPRESSURE:
		MidiEventSize = 2;
		break;
	default:
		_DbgPrintF( DEBUGLVL_ERROR, ("MODM_DATA, invalid message==%lx", MidiEventStatus));
		return MMSYSERR_ERROR;
	}
	if (!IS_STATUS(*MidiEvent))
		MidiEventSize -= 1;
	modConnectionWrite(MidiInstance, MidiEvent, MidiEventSize);
	return MMSYSERR_NOERROR;
}

MMRESULT
modLongData(
	PMIDIINSTANCE	MidiInstance,
	LPMIDIHDR		MidiHdr
	)
{
	if (!(MidiHdr->dwFlags & MHDR_PREPARED))
		return MIDIERR_UNPREPARED;
	if (MidiHdr->dwFlags & MHDR_INQUEUE)
		return MIDIERR_STILLPLAYING;
	modConnectionWrite(MidiInstance, MidiHdr->lpData, MidiHdr->dwBufferLength);
	MidiHdr->dwFlags |= MHDR_DONE;
	modCallback(MidiInstance, MOM_DONE, (DWORD)MidiHdr);
	return MMSYSERR_NOERROR;
}

MMRESULT
modReset(
	PMIDIINSTANCE	MidiInstance
	)
{
	MidiInstance->RunningStatus = 0;
	modConnectionWrite(MidiInstance, EventAllOff, sizeof(EventAllOff));
	return MMSYSERR_NOERROR;
}

MMRESULT
modClose(
	PMIDIINSTANCE	MidiInstance
	)
{
	modReset(MidiInstance);
	CloseHandle(MidiInstance->ConnectionHandle);
	CloseHandle(MidiInstance->FilterHandle);
	CloseHandle(MidiInstance->ControlEventHandle);
	modCallback(MidiInstance, MOM_CLOSE, 0);
	LocalFree(MidiInstance);
	return MMSYSERR_NOERROR;
}

DWORD
APIENTRY modMessage(
	DWORD	DeviceId,
	DWORD	Message,
	DWORD	InstanceContext,
	DWORD	Param1,
	DWORD	Param2
	)
{
	switch (Message) {
	case DRVM_INIT:
		return MMSYSERR_NOERROR;
	case MODM_GETNUMDEVS:
		return 1;
	case MODM_GETDEVCAPS:
		return modGetDevCaps(DeviceId, (LPBYTE) Param1, Param2);
	case MODM_OPEN:
		return modOpen(DeviceId, (LPVOID *)InstanceContext, (LPMIDIOPENDESC)Param1, Param2);
	case MODM_CLOSE:
		return modClose((PMIDIINSTANCE)InstanceContext);
	case MODM_DATA:
		return modData((PMIDIINSTANCE)InstanceContext, (LPBYTE)&Param1);
	case MODM_LONGDATA:
		return modLongData((PMIDIINSTANCE)InstanceContext, (LPMIDIHDR)Param1);
	case MODM_RESET:
		return modReset((PMIDIINSTANCE)InstanceContext);
	case MODM_SETVOLUME:
		return MMSYSERR_NOTSUPPORTED;
	case MODM_GETVOLUME:
		return MMSYSERR_NOTSUPPORTED;
	case MODM_CACHEPATCHES:
		_DbgPrintF( DEBUGLVL_VERBOSE, ("MODM_CACHEPATCHES, device DeviceId==%d", DeviceId));
		return MMSYSERR_NOERROR;
	case MODM_CACHEDRUMPATCHES:
		_DbgPrintF( DEBUGLVL_VERBOSE, ("MODM_CACHEDRUMPATCHES, device DeviceId==%d", DeviceId));
		return MMSYSERR_NOERROR;
	}
	_DbgPrintF( DEBUGLVL_VERBOSE, ("MODM_??(%lx), device DeviceId==%ld: unsupported", Message, DeviceId));
	return MMSYSERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\drvstubs\mswav32\widdrv.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       widdrv.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <objbase.h>
#include <devioctl.h>

#include <ks.h>
#include <ksmedia.h>

#include "debug.h"

// HACK! HACK! HACK!

extern HANDLE ghAEC;

// woddrv.c

BOOL WvControl
(
   HANDLE   hDevice,
   DWORD    dwIoControl,
   PVOID    pvIn,
   ULONG    cbIn,
   PVOID    pvOut,
   ULONG    cbOut,
   PULONG   pcbReturned
);

VOID WvGetPosition
(
   HANDLE   hDevice,
   PULONG   pulCurrentDevicePosition
);

typedef struct tagWAVEHDREX
{
   PWAVEHDR               phdr;
   struct tagWIDINSTANCE  *pwi;
   OVERLAPPED             Overlapped;
   struct tagWAVEHDREX    *pNext;

} WAVEHDREX, *PWAVEHDREX;

typedef struct tagWIDINSTANCE
{
    HANDLE              hDevSink, hThread, hWaveIOSink, hevtQueue;
#if defined( AEC )
    HANDLE              hAECSink;
#endif
    HWAVE               hWave;
    CRITICAL_SECTION    csQueue;
    DWORD               cbSample, dwCallback, dwFlags, dwInstance, dwThreadId;
    PVOID               pCurrent;
    volatile BOOL       fActive, fDone, fExit;
    KSSTATE             ksCurrentState;
    PWAVEHDREX          pQueue;

} WIDINSTANCE, *PWIDINSTANCE;

//--------------------------------------------------------------------------

//
// HACK! code duplication, need to set up a common header for the device
// instances.
//

static VOID WvSetState
(
   PWIDINSTANCE   pwi,
   KSSTATE        DeviceState
)
{
    KSPROPERTY   Property;
    ULONG        cbReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;

    if (pwi->ksCurrentState == DeviceState)
        return;

    if (KSSTATE_RUN == pwi->ksCurrentState)
    {
        // propogate upstream

        WvControl( pwi->hDevSink,
                  IOCTL_KS_PROPERTY,
                  &Property,
                  sizeof( Property ),
                  &DeviceState,
                  sizeof( DeviceState ),
                  &cbReturned );

        WvControl( pwi->hWaveIOSink,
                  IOCTL_KS_PROPERTY,
                  &Property,
                  sizeof( Property ),
                  &DeviceState,
                  sizeof( DeviceState ),
                  &cbReturned );
    }
    else
    {
        // propogate downstream 

        WvControl( pwi->hWaveIOSink,
                  IOCTL_KS_PROPERTY,
                  &Property,
                  sizeof( Property ),
                  &DeviceState,
                  sizeof( DeviceState ),
                  &cbReturned );

        WvControl( pwi->hDevSink,
                  IOCTL_KS_PROPERTY,
                  &Property,
                  sizeof( Property ),
                  &DeviceState,
                  sizeof( DeviceState ),
                  &cbReturned );
    }
    pwi->ksCurrentState = DeviceState;

}


BOOL WvRead
(
    HANDLE      hDevice,
    PWAVEHDREX  phdrex
)
{
   BOOL        fResult;
   ULONG       cbRead;

   fResult = 
      ReadFile( hDevice, phdrex->phdr, sizeof( WAVEHDR ), &cbRead, 
                &phdrex->Overlapped );

   if (!fResult)
      return (ERROR_IO_PENDING == GetLastError());
   else
      return TRUE;
}

VOID widCallback
(
   PWIDINSTANCE   pwi,
   DWORD          dwMsg,
   DWORD          dwParam1
)
{
   if (pwi->dwCallback)
      DriverCallback( pwi->dwCallback,         // user's callback DWORD
                      HIWORD( pwi->dwFlags ),  // callback flags
                      (HDRVR) pwi->hWave,      // handle to the wave device
                      dwMsg,                     // the message
                      pwi->dwInstance,         // user's instance data
                      dwParam1,                  // first DWORD
                      0L );                     // second DWORD
}

VOID widBlockFinished
(
   PWAVEHDREX phdrex
)
{
   
    CloseHandle( phdrex->Overlapped.hEvent );
    widCallback( phdrex->pwi, WIM_DATA, (DWORD) phdrex->phdr );
    HeapFree( GetProcessHeap(), 0, phdrex );
}

DWORD widThread
(
   PWIDINSTANCE  pwi
)
{
    BOOL          fDone;
    PWAVEHDREX    phdrex;

    fDone = FALSE;
    while (!fDone || !pwi->fExit)
    {
        fDone = FALSE;
        EnterCriticalSection( &pwi->csQueue );
        if (pwi->pQueue)
        {
            LeaveCriticalSection( &pwi->csQueue );
            WaitForSingleObject( pwi->pQueue->Overlapped.hEvent, INFINITE );
            EnterCriticalSection( &pwi->csQueue );
            if (phdrex = pwi->pQueue)
            {
                pwi->pQueue = pwi->pQueue->pNext;
                widBlockFinished( phdrex );
            }
            LeaveCriticalSection( &pwi->csQueue );
        }
        else
        {
            fDone = TRUE;
            LeaveCriticalSection( &pwi->csQueue );
            WaitForSingleObject( pwi->hevtQueue, INFINITE );
        }
    }

    CloseHandle( pwi->hevtQueue );
    pwi->hevtQueue = NULL;

    return 0;
}

MMRESULT widGetPos
(
   PWIDINSTANCE   pwi,
   LPMMTIME       pmmt,
   ULONG          cbSize
)
{
   ULONG ulCurrentPos;
   
   WvGetPosition( pwi->hWaveIOSink, &ulCurrentPos );

   // Write this to the buffer as appropriate.

   if (pmmt-> wType == TIME_BYTES)
      pmmt->u.cb = ulCurrentPos;
   else
   {
      pmmt->wType = TIME_SAMPLES;
      pmmt->u.sample = ulCurrentPos / pwi->cbSample;
   }

   return MMSYSERR_NOERROR;
}

MMRESULT widGetDevCaps
(
   UINT  uDevId,
   PBYTE pwc,
   ULONG cbSize
)
{
   WAVEINCAPSW wc;

   wc.wMid = 1;
   wc.wPid = 1;
   wc.vDriverVersion = 0x400;
   wc.dwFormats = WAVE_FORMAT_1M08 | WAVE_FORMAT_1S08 |
                   WAVE_FORMAT_1M16 | WAVE_FORMAT_1S16 |
                   WAVE_FORMAT_2M08 | WAVE_FORMAT_2S08 |
                   WAVE_FORMAT_2M16 | WAVE_FORMAT_2S16 |
                   WAVE_FORMAT_4M08 | WAVE_FORMAT_4S08 |
                   WAVE_FORMAT_4M16 | WAVE_FORMAT_4S16;
   wc.wChannels = 2;

   wcscpy( wc.szPname, L"Windows Sound System" );

   CopyMemory( pwc, &wc, min( sizeof( wc ), cbSize ) );

   return MMSYSERR_NOERROR;
}

#define REGSTR_PATH_WDMAUDIO TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\wdm\\audio")
#define REGSTR_PATH_WDMAEC TEXT("System\\CurrentControlSet\\Control\\MediaProperties\\wdm\\aec")

MMRESULT widOpen
(
   UINT           uDevId,
   LPVOID         *ppvUser,
   LPWAVEOPENDESC pwodesc,
   ULONG          ulFlags
)
{
    PKSPIN_CONNECT              pConnect;
    PKSDATAFORMAT_WAVEFORMATEX  pDataFormat;
    HANDLE                      hDeviceConnect, hDeviceSink, hSink,
#if defined( AEC )
                                hAECConnect,
                                hAECSourceToWaveIOSink,
                                hWaveIOSink,
#endif
                                hWaveIOSourceToDevice,
                                hWaveIOConnect;
    LPWAVEFORMATEX              pwf;
    PWIDINSTANCE                pwi;
    ULONG                       cbReturned;
    WCHAR                       aszValue[128];
                           
    pwf = (LPWAVEFORMATEX) pwodesc->lpFormat;

    hDeviceConnect =           INVALID_HANDLE_VALUE ;
    hDeviceSink =              INVALID_HANDLE_VALUE ;
    hSink =                    INVALID_HANDLE_VALUE ;
    hWaveIOSourceToDevice =    INVALID_HANDLE_VALUE ;
    hWaveIOConnect =           INVALID_HANDLE_VALUE ;

#if defined( AEC )
    hAECConnect =              INVALID_HANDLE_VALUE ;
    hAECSourceToWaveIOSink =   INVALID_HANDLE_VALUE ;
    hWaveIOSink =              INVALID_HANDLE_VALUE ;
#endif

   if (NULL == 
         (pConnect = HeapAlloc( GetProcessHeap(), 0, 
                                sizeof( KSPIN_CONNECT ) + 
                                   sizeof( KSDATAFORMAT_WAVEFORMATEX ) )))
      return MMSYSERR_NOMEM;

   hWaveIOConnect = CreateFile( L"\\\\.\\MSWAVEIO\\{9B365890-165F-11D0-A195-0020AFD156E4}",
                                  GENERIC_READ,
                                  0,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                  NULL );
                                  
   if (hWaveIOConnect == INVALID_HANDLE_VALUE)
      goto Error;

#if defined( AEC )
    if (ghAEC)
    hAECConnect = ghAEC;
    else
   hAECConnect = CreateFile( L"\\\\.\\AEC",
                              GENERIC_READ,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                              NULL );

   if (hAECConnect == INVALID_HANDLE_VALUE)
      goto Error;
#endif

   cbReturned = sizeof(aszValue);
   if (RegQueryValue (HKEY_LOCAL_MACHINE, REGSTR_PATH_WDMAUDIO, aszValue, &cbReturned) != ERROR_SUCCESS)
      goto Error;

   hDeviceConnect = CreateFile( aszValue,
                                GENERIC_READ,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                NULL );

   if (hDeviceConnect == INVALID_HANDLE_VALUE)
      goto Error;

   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_BUFFERED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 0;  // SOUNDPRT ADC SINK
   // no "connect to"
   pConnect->PinToHandle = NULL;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   pDataFormat = (PKSDATAFORMAT_WAVEFORMATEX) (pConnect + 1);

   pDataFormat->DataFormat.FormatSize = sizeof( KSDATAFORMAT_WAVEFORMATEX );
   pDataFormat->DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
   INIT_WAVEFORMATEX_GUID( &pDataFormat->DataFormat.SubFormat,
                           pwf->wFormatTag );
   pDataFormat->DataFormat.Specifier = KSDATAFORMAT_FORMAT_WAVEFORMATEX;
   pDataFormat->WaveFormatEx = *pwf;

   if (KsCreatePin( hDeviceConnect, pConnect, GENERIC_READ, &hDeviceSink ))
      goto Error;

   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_BUFFERED;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->Interface.Flags = 0;
   pConnect->PinId = 2;  // MSWAVEIO SOURCE
   pConnect->PinToHandle = hDeviceSink;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   if (KsCreatePin( hWaveIOConnect, pConnect, GENERIC_WRITE, &hWaveIOSourceToDevice ))
      goto Error;

   if (ulFlags & WAVE_FORMAT_QUERY)
   {
      HeapFree( GetProcessHeap(), 0, pConnect );
#if defined( AEC )
    if (hAECConnect != ghAEC)
      CloseHandle( hAECConnect );
#endif
      CloseHandle( hWaveIOSourceToDevice );
      CloseHandle( hDeviceSink );
      CloseHandle( hWaveIOConnect );
      CloseHandle( hDeviceConnect );
      return MMSYSERR_NOERROR;
   }

#if defined( AEC )

   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_QUEUED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 3;  // MSWAVEIO ADC SINK
   // no "connect to"
   pConnect->PinToHandle = NULL;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   if (KsCreatePin( hWaveIOConnect, pConnect, GENERIC_READ, &hWaveIOSink ))
      goto Error;

   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_QUEUED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 2;  // AEC SOURCE
   pConnect->PinToHandle = hWaveIOSink;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   if (KsCreatePin( hAECConnect, pConnect, GENERIC_WRITE, &hAECSourceToWaveIOSink ))
      goto Error;
#endif

   pwi = (PWIDINSTANCE) LocalAlloc( LPTR, sizeof( WIDINSTANCE ) );

   if (NULL == pwi)
        goto Error;

#if defined( AEC )
   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_QUEUED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 3;  // AEC ADC SINK
   // no "connect to"
   pConnect->PinToHandle = NULL;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   if (KsCreatePin( hAECConnect, pConnect, GENERIC_READ, &hSink ))
      goto Error;
#else
   pConnect->Interface.Set = KSINTERFACESETID_Media;
   pConnect->Interface.Id = KSINTERFACE_MEDIA_WAVE_QUEUED;
   pConnect->Interface.Flags = 0;
   pConnect->Medium.Set = KSMEDIUMSETID_Standard;
   pConnect->Medium.Id = KSMEDIUM_STANDARD_DEVIO;
   pConnect->Medium.Flags = 0;
   pConnect->PinId = 3;  // MSWAVEIO ADC SINK
   // no "connect to"
   pConnect->PinToHandle = NULL;
   pConnect->Priority.PriorityClass = KSPRIORITY_NORMAL;
   pConnect->Priority.PrioritySubClass = 0;

   if (KsCreatePin( hWaveIOConnect, pConnect, GENERIC_READ, &hSink ))
      goto Error;
#endif

   pwi->hWaveIOSink = hSink;
   pwi->hDevSink = hDeviceSink;
#if defined( AEC )
   ghAEC = hAECConnect;
#endif
   InitializeCriticalSection( &pwi->csQueue );

#if defined( AEC )
    CloseHandle( hAECSourceToWaveIOSink ) ;
    CloseHandle( hWaveIOSink );
    if (hAECConnect != ghAEC)
    CloseHandle( hAECConnect );
#endif
    CloseHandle( hWaveIOSourceToDevice );
    CloseHandle( hWaveIOConnect );
    CloseHandle( hDeviceConnect );

   HeapFree( GetProcessHeap(), 0, pConnect );

   pwi->hWave = pwodesc->hWave;
   pwi->dwCallback = pwodesc->dwCallback;
   pwi->dwInstance = pwodesc->dwInstance;
   pwi->dwFlags = ulFlags;

   pwi->cbSample = pwf->nChannels;
   pwi->cbSample *= pwf->wBitsPerSample / 8;

   pwi->pQueue = NULL;
   pwi->fActive = FALSE;
   pwi->fExit = FALSE;

   //
   // Prepare the device...
   //

   WvSetState( pwi, KSSTATE_PAUSE );

   *ppvUser = pwi;

   widCallback( pwi, WIM_OPEN, 0L);

   return MMSYSERR_NOERROR;


Error:

    if (pConnect)
        HeapFree( GetProcessHeap(), 0, pConnect );

#if defined( AEC )
    if (INVALID_HANDLE_VALUE != hAECSourceToWaveIOSink)
        CloseHandle( hAECSourceToWaveIOSink ) ;
    if (INVALID_HANDLE_VALUE != hWaveIOSink)
        CloseHandle( hWaveIOSink );
    if (INVALID_HANDLE_VALUE != hAECConnect)
    {
        if (hAECConnect != ghAEC)
            CloseHandle( hAECConnect );
    }
#endif

    if (INVALID_HANDLE_VALUE != hWaveIOSourceToDevice)
        CloseHandle( hWaveIOSourceToDevice );
    if (INVALID_HANDLE_VALUE != hDeviceSink)
        CloseHandle( hDeviceSink );
    if (INVALID_HANDLE_VALUE != hWaveIOConnect)
        CloseHandle( hWaveIOConnect );
    if (INVALID_HANDLE_VALUE != hDeviceConnect)
        CloseHandle( hDeviceConnect );

    return MMSYSERR_BADDEVICEID;
}

MMRESULT widStart
(
   PWIDINSTANCE  pwi
)
{
    if (pwi->fActive)
        return MMSYSERR_INVALPARAM;

    if (!pwi->hThread)
    {
        pwi->hevtQueue = 
            CreateEvent( NULL,      // no security
                         FALSE,     // auto reset
                         FALSE,     // initially not signalled
                         NULL );    // unnamed

        pwi->hThread =
            CreateThread( NULL,                            // no security
                        0,                                 // default stack
                        (PTHREAD_START_ROUTINE) widThread,
                        (PVOID) pwi,                       // parameter
                        0,                                 // default create flags
                        &pwi->dwThreadId );                // container for
                                                           //    thread id
//        SetThreadPriority( pwi->hThread, THREAD_PRIORITY_TIME_CRITICAL );
    }

    if (NULL == pwi->hThread)
    {
        if (pwi->hevtQueue)
        {
            CloseHandle( pwi->hevtQueue );
            pwi->hevtQueue = NULL;
        }
        return MMSYSERR_ERROR;
    }

    WvSetState( pwi, KSSTATE_RUN );
    pwi->fActive = TRUE;

    return MMSYSERR_NOERROR;
}

MMRESULT widAddBuffer
(
   PWIDINSTANCE   pwi,
   LPWAVEHDR      phdr
)
{
    PWAVEHDREX  phdrex, pTemp;
    MMRESULT    mmr;
   
    mmr = MMSYSERR_NOERROR;

    // check if it's been prepared

    if (0 == (phdr->dwFlags & WHDR_PREPARED))
        return WAVERR_UNPREPARED;

    if (phdr->dwFlags & WHDR_INQUEUE)
        return WAVERR_STILLPLAYING;

    if (NULL == 
            (phdrex = HeapAlloc( GetProcessHeap(), 0, sizeof( WAVEHDREX ) )))
        return MMSYSERR_NOMEM;

    phdrex->phdr = phdr;
    phdrex->pwi = pwi;
    phdrex->pNext = NULL;
    RtlZeroMemory( &phdrex->Overlapped, sizeof( OVERLAPPED ) );

    if (NULL == (phdrex->Overlapped.hEvent = 
                    CreateEvent( NULL, TRUE, FALSE, NULL )))
    {
       HeapFree( GetProcessHeap(), 0, phdrex );
       return MMSYSERR_NOMEM;
    }

    phdr->lpNext = 0;

    phdr->dwFlags |= WHDR_INQUEUE;
    phdr->dwFlags &= ~WHDR_DONE;

    EnterCriticalSection( &pwi->csQueue );
    if (!pwi->pQueue)
    {
        pwi->pQueue = phdrex;
        pTemp = NULL;
        if (pwi->hevtQueue)
            SetEvent( pwi->hevtQueue );
    }
    else
    {
        for (pTemp = pwi->pQueue;
             pTemp->pNext != NULL;
             pTemp = pTemp->pNext);
                             
        pTemp->pNext = phdrex;
        pTemp->phdr->lpNext = phdrex->phdr;
    }
    LeaveCriticalSection( &pwi->csQueue );

    if (!WvRead( pwi->hWaveIOSink, phdrex ))
    {
       // Unlink...

       CloseHandle( phdrex->Overlapped.hEvent );
       HeapFree( GetProcessHeap(), 0, phdrex );

       if (pTemp)
       {
           pTemp->pNext = NULL;
           pTemp->phdr->lpNext = NULL;
       }
       else
           pwi->pQueue = NULL;
       phdr->dwFlags &= ~WHDR_INQUEUE;

       return MMSYSERR_INVALPARAM;
    }

    return MMSYSERR_NOERROR;
}

MMRESULT widReset
(
   PWIDINSTANCE   pwi
)
{
    ULONG cbReturned;

    WvSetState( pwi, KSSTATE_PAUSE );
    pwi->fActive = FALSE;
    CancelIo( pwi->hWaveIOSink );
    WvControl( pwi->hWaveIOSink,
               IOCTL_KS_RESET_STATE,
               NULL,
               0,
               NULL,
               0,
               &cbReturned );

    if (pwi->hThread)
    {
        InterlockedExchange( (LPLONG)&pwi->fExit, TRUE );
        SetEvent( pwi->hevtQueue );
        WaitForSingleObject( pwi->hThread, INFINITE );
        CloseHandle( pwi->hThread );
        pwi->hThread = NULL;
    }

    return MMSYSERR_NOERROR;
}

MMRESULT widStop
(
   PWIDINSTANCE   pwi
)
{
    if (pwi->fActive)
    {
        pwi->fActive = FALSE;
        WvSetState( pwi, KSSTATE_PAUSE );
    }

   return MMSYSERR_NOERROR;
}

MMRESULT widClose
(
   PWIDINSTANCE   pwi
)
{
    HANDLE      hDevice;

    WvSetState( pwi, KSSTATE_STOP );
    pwi->fActive = FALSE;

    hDevice = pwi->hWaveIOSink;
    pwi->hWaveIOSink = NULL;
    CloseHandle( hDevice );

    hDevice = pwi->hDevSink;
    pwi->hDevSink = NULL;
    CloseHandle( hDevice );

    //
    // synchronize cleanup with worker thread 
    //

    if (pwi->hThread)
    {
        InterlockedExchange( (LPLONG)&pwi->fExit, TRUE );
        SetEvent( pwi->hevtQueue );
        WaitForSingleObject( pwi->hThread, INFINITE );
        CloseHandle( pwi->hThread );
        pwi->hThread = NULL;
    }

    widCallback( pwi, WIM_CLOSE, 0L );
    LocalFree( pwi );

    return MMSYSERR_NOERROR;
}

DWORD APIENTRY widMessage
(
   DWORD id,
   DWORD msg,
   DWORD dwUser,
   DWORD dwParam1,
   DWORD dwParam2
)
{
   switch (msg) {
      case DRVM_INIT:
         _DbgPrintF( DEBUGLVL_VERBOSE, ("WIDM_INIT") );
         return MMSYSERR_NOERROR;

      case WIDM_GETNUMDEVS:
         _DbgPrintF( DEBUGLVL_VERBOSE, ("WIDM_GETNUMDEVS, device id==%d", id) );
         return 1;

      case WIDM_OPEN:
         _DbgPrintF( DEBUGLVL_VERBOSE, ("WIDM_OPEN, device id==%d", id) );
         return widOpen( id, (LPVOID *) dwUser, 
                         (LPWAVEOPENDESC) dwParam1, dwParam2 );

      case WIDM_GETDEVCAPS:
         _DbgPrintF( DEBUGLVL_VERBOSE, ("WIDM_GETDEVCAPS, device id==%d", id) );
         return widGetDevCaps( id, (LPBYTE) dwParam1, dwParam2 );

      case WIDM_CLOSE:
         _DbgPrintF( DEBUGLVL_VERBOSE, ("WIDM_CLOSE, device id==%d", id) );
         return widClose( (PWIDINSTANCE) dwUser );

      case WIDM_ADDBUFFER:
         _DbgPrintF( DEBUGLVL_VERBOSE, ("WIDM_ADDBUFFER, device id==%d", id) );
         return widAddBuffer( (PWIDINSTANCE) dwUser, (LPWAVEHDR) dwParam1 );

      case WIDM_START:
         _DbgPrintF( DEBUGLVL_VERBOSE, ("WIDM_START, device id==%d", id) );
         return widStart( (PWIDINSTANCE) dwUser );

      case WIDM_STOP:
         _DbgPrintF( DEBUGLVL_VERBOSE, ("WIDM_STOP, device id==%d", id) );
         return widStop( (PWIDINSTANCE) dwUser );

      case WIDM_RESET:
         _DbgPrintF( DEBUGLVL_VERBOSE, ("WIDM_RESET, device id==%d", id) );
         return widReset( (PWIDINSTANCE) dwUser );

      case WIDM_GETPOS:
         _DbgPrintF( DEBUGLVL_VERBOSE, ("WIDM_GETPOS, device id==%d", id) );
         return widGetPos( (PWIDINSTANCE) dwUser,
                           (LPMMTIME) dwParam1, dwParam2 );

      default:
         return MMSYSERR_NOTSUPPORTED;
   }

   //
   // Should not get here
   //

   return MMSYSERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\admindlg.cpp ===
// AdminDlg.cpp : implementation file
//

#include "stdafx.h"
#include "dvdplay.h"
#include "AdminDlg.h"
#include "admlogin.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAdminDlg dialog


CAdminDlg::CAdminDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAdminDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAdminDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAdminDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAdminDlg)
	DDX_Control(pDX, IDC_STATIC_RATE_HIGH, m_ctlRateHigh);
	DDX_Control(pDX, IDC_EDIT_ADMIN_PASSWD, m_ctlAdminPasswd);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAdminDlg, CDialog)
	//{{AFX_MSG_MAP(CAdminDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAdminDlg message handlers

BOOL CAdminDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	m_ctlAdminPasswd.LimitText(MAX_PASSWD);	
	CString csRateHigh;
	csRateHigh.LoadString(IDS_RATE_OVER_RIDE);
	m_ctlRateHigh.SetWindowText(csRateHigh);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAdminDlg::OnOK() 
{
	//get the user entered password
	TCHAR szPasswd[MAX_PASSWD], szSavedPasswd[MAX_PASSWD];
	m_ctlAdminPasswd.GetWindowText(szPasswd, MAX_PASSWD);
	CAdminLogin::EncryptPassword(szPasswd);

	//get the admin passwrod in dvdplay.ini
	CString csSectionName, csKeyName;
	csSectionName.LoadString(IDS_INI_ADMINISTRATOR);
	csKeyName.LoadString(IDS_INI_PASSWORD);
	LPTSTR lpProfileName = ((CDvdplayApp*) AfxGetApp())->GetProfileName();

	GetPrivateProfileString(csSectionName, csKeyName, NULL, szSavedPasswd, MAX_PASSWD, lpProfileName);
	//compare entered password with the saved admin password
	if( lstrcmp(szPasswd, szSavedPasswd) != 0 )
	{
        // Just make sire that it's not password mismatch due to Win98 to Win2K upgrade 
        if (! CAdminLogin::Win98vsWin2KPwdMismatch(szPasswd, szSavedPasswd, csSectionName) ) // truely bad password -- error out
        {
		    CString csMsg;
		    csMsg.LoadString(IDS_PASSWORD_INCORRECT);
		    DVDMessageBox(m_hWnd, csMsg);
		    m_ctlAdminPasswd.SetSel(0, -1);
		    m_ctlAdminPasswd.SetFocus();
		    return;
        }
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\admindlg.h ===
#if !defined(AFX_ADMINDLG_H__6B752DC2_A167_11D1_A5E1_00AA0037E04F__INCLUDED_)
#define AFX_ADMINDLG_H__6B752DC2_A167_11D1_A5E1_00AA0037E04F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AdminDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAdminDlg dialog

class CAdminDlg : public CDialog
{
// Construction
public:
	CAdminDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAdminDlg)
	enum { IDD = IDD_DIALOG_ADMIN_PASSWD };
	CStatic	m_ctlRateHigh;
	CEdit	m_ctlAdminPasswd;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAdminDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAdminDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADMINDLG_H__6B752DC2_A167_11D1_A5E1_00AA0037E04F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\admlogin.cpp ===
// AdmLogin.cpp : implementation file
//

#include "stdafx.h"
#include "dvdplay.h"
#include "AdmLogin.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAdminLogin dialog


CAdminLogin::CAdminLogin(CWnd* pParent /*=NULL*/)
	: CDialog(CAdminLogin::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAdminLogin)
	//}}AFX_DATA_INIT
	m_bNewAdmin     = FALSE;
	m_bChangePasswd = FALSE;
	m_szPassword[0] = 0;
	m_szConfirm[0]  = 0;
	m_szConfirmNew[0] = 0;
	m_uiCalledBy = BY_SET_RATING;
}


void CAdminLogin::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAdminLogin)
	DDX_Control(pDX, IDC_EDIT_CONFIRM_NEW, m_ctlConfirmNew);
	DDX_Control(pDX, IDC_EDIT_PASSWORD, m_ctlPassword);
	DDX_Control(pDX, IDC_EDIT_CONFIRM, m_ctlConfirm);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAdminLogin, CDialog)
	//{{AFX_MSG_MAP(CAdminLogin)
	ON_BN_CLICKED(IDC_BUTTON_CHANGE_PASSWORD, OnButtonChangePassword)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAdminLogin message handlers

BOOL CAdminLogin::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	GetWindowRect(&m_rcOriginalRC);

	m_lpProfileName = ((CDvdplayApp*) AfxGetApp())->GetProfileName();
	if( !((CDvdplayApp*) AfxGetApp())->GetProfileStatus())
		m_bNewAdmin = TRUE;	

	BOOL bShow = ((CDvdplayApp*) AfxGetApp())->GetShowLogonBox();
	CButton* pBtn = (CButton*) GetDlgItem(IDC_CHECK_SHOW_LOGON);
	if(pBtn)
	{
		pBtn->SetCheck(bShow);
		if(m_uiCalledBy == BY_SET_RATING)
			pBtn->ShowWindow(SW_HIDE);
		if(m_uiCalledBy == BY_SET_SHOWLOGON)
		{
			pBtn->ShowWindow(SW_SHOW);
			CString csCaption;
			csCaption.LoadString(IDS_ADM_SETLOGONBOX_TITLE);
			SetWindowText(csCaption);						
		}
	}

	if(m_bNewAdmin)  //first time login
	{
		CString csCaption;
		csCaption.LoadString(IDS_ADM_LOGON_BOX_TITLE);
		DVDMessageBox(this->m_hWnd, IDS_ADM_LOGON_MSG, csCaption, 
			          MB_OK | MB_TOPMOST | MB_ICONEXCLAMATION);
		GetDlgItem(IDC_BUTTON_CHANGE_PASSWORD)->EnableWindow(FALSE);
		SetHalfSizeWindow(TRUE);
	}
	else
		SetHalfSizeWindow(FALSE);

	m_ctlPassword.LimitText(MAX_PASSWD);
	m_ctlConfirm.LimitText(MAX_PASSWD);
	m_ctlConfirmNew.LimitText(MAX_PASSWD);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAdminLogin::SetHalfSizeWindow(BOOL bNewAdmin)
{
	CWnd* pWnd;
	if(!bNewAdmin)
		pWnd = GetDlgItem(IDC_STATIC_HEIGHT1);
	else
		pWnd = GetDlgItem(IDC_STATIC_HEIGHT2);
	CRect rc;
	pWnd->GetWindowRect(&rc);
	SetWindowPos(NULL, 0, 0, m_rcOriginalRC.Width(), rc.Height(), SWP_NOMOVE);
}

void CAdminLogin::SetFullSizeWindow()
{
	SetWindowPos(NULL, 0, 0, m_rcOriginalRC.Width(), 
		         m_rcOriginalRC.Height(), SWP_NOMOVE);
}


void CAdminLogin::OnOK() 
{
	m_ctlPassword.GetWindowText(m_szPassword, MAX_PASSWD);
	m_ctlConfirm.GetWindowText(m_szConfirm, MAX_PASSWD);
	m_ctlConfirmNew.GetWindowText(m_szConfirmNew, MAX_PASSWD);	

	if(lstrcmp(m_szPassword, _T("")) == 0)
	{
		DVDMessageBox(this->m_hWnd, IDS_ENTER_PASSWORD);
		m_ctlPassword.SetFocus();
		return;
	}

	CString csStr1, csStr2;
	if(m_bNewAdmin)  //New Admin people
	{
		if(lstrcmp(m_szConfirm,  _T("")) == 0)
		{			
			DVDMessageBox(this->m_hWnd, IDS_CONFIRM_NEW_PASSWORD);
			m_ctlConfirm.SetFocus();
			return;
		}
		if(lstrcmp(m_szPassword, m_szConfirm) != 0)
		{
			DVDMessageBox(this->m_hWnd, IDS_PASSOWRD_CONFIRM_WRONG);
			m_ctlConfirm.SetWindowText(_T(""));
			m_ctlConfirm.SetFocus();
			return;
		}
		EncryptPassword(m_szPassword);
		csStr1.LoadString(IDS_INI_ADMINISTRATOR);
		csStr2.LoadString(IDS_INI_PASSWORD);
		WritePrivateProfileString(csStr1, csStr2, m_szPassword, m_lpProfileName);
		csStr2.LoadString(IDS_INI_NUMBEROFUSER);
		WritePrivateProfileString(csStr1, csStr2, TEXT("1"), m_lpProfileName);

		//Save Guest with default rate=PG
		csStr1.LoadString(IDS_INI_USER);
		csStr1 += "1";
		csStr2.LoadString(IDS_INI_USERNAME);
		CString csGueststr;
		csGueststr.LoadString(IDS_GUEST);
		WritePrivateProfileString(csStr1, csStr2, csGueststr, m_lpProfileName);
		csStr2.LoadString(IDS_INI_RATE);
		csGueststr.LoadString(IDS_INI_RATE_PG);
		WritePrivateProfileString(csStr1, csStr2, csGueststr, m_lpProfileName);
	}
	else   //Old Admin people, check password
	{
		csStr1.LoadString(IDS_INI_ADMINISTRATOR);
		if(!ConfirmPassword(m_lpProfileName, csStr1.GetBuffer(csStr1.GetLength( )), m_szPassword))
		{
			DVDMessageBox(this->m_hWnd, IDS_PASSWORD_INCORRECT);
			m_ctlPassword.SetWindowText(_T(""));
			m_ctlPassword.SetFocus();
			return;
		}
		if(m_bChangePasswd)
		{
			if(lstrcmp(m_szConfirm,  _T("")) == 0)
			{
				DVDMessageBox(this->m_hWnd, IDS_TYPE_A_NEW_PASSWORD);
				m_ctlConfirm.SetFocus();
				return;
			}
			if(lstrcmp(m_szConfirmNew,  _T("")) == 0)
			{
				DVDMessageBox(this->m_hWnd, IDS_CONFIRM_NEW_PASSWORD);
				m_ctlConfirmNew.SetFocus();
				return;
			}
			if(lstrcmp(m_szConfirmNew,  m_szConfirm) != 0)
			{
				DVDMessageBox(this->m_hWnd, IDS_PASSOWRD_CONFIRM_WRONG);
				m_ctlConfirmNew.SetWindowText(_T(""));
				m_ctlConfirmNew.SetFocus();
				return;
			}
			EncryptPassword(m_szConfirm);
			csStr1.LoadString(IDS_INI_ADMINISTRATOR);
			csStr2.LoadString(IDS_INI_PASSWORD);
			WritePrivateProfileString(csStr1, csStr2, m_szConfirm, m_lpProfileName);
		}				
	}
	
	CButton* pChkBtn = (CButton*) GetDlgItem(IDC_CHECK_SHOW_LOGON);
	csStr1.LoadString(IDS_INI_ADMINISTRATOR);
	csStr2.LoadString(IDS_INI_SHOW_LOGONBOX);
	BOOL bShow = 0;
	if(pChkBtn)
		bShow= pChkBtn->GetCheck();
	((CDvdplayApp*) AfxGetApp())->SetShowLogonBox(bShow);
	if(bShow)
		WritePrivateProfileString(csStr1, csStr2, TEXT("1"), m_lpProfileName);
	else
		WritePrivateProfileString(csStr1, csStr2, TEXT("0"), m_lpProfileName);

	((CDvdplayApp*) AfxGetApp())->SetProfileStatus(TRUE);
	
	CDialog::OnOK();
}

void CAdminLogin::OnButtonChangePassword() 
{
	CString csCaption;
	csCaption.LoadString(IDS_OLD_PASSWORD);
	GetDlgItem(IDC_STATIC_PASSWORD)->SetWindowText(csCaption);
	csCaption.LoadString(IDS_NEW_PASSWORD);
	GetDlgItem(IDC_STATIC_CONFIRM)->SetWindowText(csCaption);
	SetFullSizeWindow();
	m_bChangePasswd = TRUE;	
}

void CAdminLogin::EncryptPassword(LPTSTR lpPassword)
{
	BYTE bFirstBit = 0x01;
	int iLength = lstrlen(lpPassword);
	for(int i=0; i<iLength; i++)
	{
		bFirstBit = bFirstBit & lpPassword[i];
		lpPassword[i] = lpPassword[i] >> 1;
		bFirstBit = bFirstBit << 7;
		lpPassword[i] = lpPassword[i] | bFirstBit;
	}
   //
   // Above code can produce characters in the ranges 0..31 and 127..255, which
   // don't always get through our password saving mechanism
   // (WritePrivateProfileString/GetPrivateProfileString).  So we look for bytes
   // in these ranges and change them to something in the range 32..126.  BUGBUG:
   // this introduces collisions (different passwords encrypt to the same thing),
   // but the algorithm above isn't collision free to begin with.
   //
   for (i = 0; i < iLength; i++) {
      if (lpPassword[i] & 0x80) // high order bit set - kill it
         lpPassword[i] &= 0x7F;
      if ((lpPassword[i] & 0xE0) == 0) // if 000X XXXX, i.e., 0..31
         lpPassword[i] += 42; // bump into the 127..255 range, 42 is an arbitrary number between 32 and 95
      if (lpPassword[i] == 127)
         lpPassword[i] = 80; // 80 is an arbitrary number in the range 32.126
   }
}

#if 0 // dead code, not used anywhere and no longer valid since Encrypt was changed.
void CAdminLogin::DecryptPassword(LPTSTR lpPassword)
{
	BYTE bLastBit = 0x80;
	int iLength = lstrlen(lpPassword);
	for(int i=0; i<iLength; i++)
	{
		bLastBit = bLastBit & lpPassword[i];
		lpPassword[i] = lpPassword[i] << 1;
		bLastBit = bLastBit >> 7;
		lpPassword[i] = lpPassword[i] | bLastBit;
	}
}
#endif

int CAdminLogin::GetNumOfUser(LPTSTR lpProfileName)
{	
	TCHAR szNumUser[MAX_NUMUSER];
	CString csStr1, csStr2;
	csStr1.LoadString(IDS_INI_ADMINISTRATOR);
	csStr2.LoadString(IDS_INI_NUMBEROFUSER);
	GetPrivateProfileString(csStr1, csStr2, TEXT(""), szNumUser, 
		                    MAX_NUMUSER, lpProfileName);
	return ( _ttoi(szNumUser) );
}

BOOL CAdminLogin::ConfirmPassword(LPTSTR lpProfileName, LPTSTR szName, LPTSTR szPassword)
{
	TCHAR szSectionName[MAX_SECTION];
	TCHAR szSavedPasswd[MAX_PASSWD];
	CString csStr;

	csStr.LoadString(IDS_INI_ADMINISTRATOR);
	if(lstrcmp(szName, csStr) == 0)
	{
		lstrcpy(szSectionName, csStr);
	}
	else
	{
		if(!SearchProfileByName(lpProfileName, szName, szSectionName))
			return FALSE;
	}
		
	EncryptPassword(szPassword);
	csStr.LoadString(IDS_INI_PASSWORD);
	GetPrivateProfileString(szSectionName, csStr, 
		          TEXT(""), szSavedPasswd, MAX_PASSWD, lpProfileName);
	if(lstrcmp(szPassword, szSavedPasswd) == 0)
		return TRUE;
    else
    {
        // Success/failure based on whether password mismatch is due to Win98 to Win2K upgrade 
        return Win98vsWin2KPwdMismatch(szPassword, szSavedPasswd, szSectionName) ;
    }
}

BOOL CAdminLogin::SearchProfileByName(LPTSTR lpProfileName, LPTSTR szName, LPTSTR szSectionName)
{
	TCHAR szNumOfUser[MAX_NUMUSER];
	TCHAR szSavedName[MAX_NAME];
	TCHAR szNameUpper[MAX_NAME];
	CString csStr1, csStr2;	

	csStr1.LoadString(IDS_INI_USER);
	csStr2.LoadString(IDS_INI_USERNAME);
	lstrcpy(szNameUpper, szName);
	CharUpper(szNameUpper);

	int iNumOfUser = CAdminLogin::GetNumOfUser(lpProfileName);
	for(int i=1; i<iNumOfUser+1; i++)
	{
		lstrcpy(szSectionName, csStr1);
		_itot(i, szNumOfUser, 10);
		lstrcat(szSectionName, szNumOfUser);
		GetPrivateProfileString(szSectionName, csStr2, TEXT(""), 
			                    szSavedName, MAX_NAME, lpProfileName);
		CharUpper(szSavedName);
		if(lstrcmp(szSavedName, szNameUpper) == 0)
			return TRUE;			
	}
	return FALSE;
}

BOOL CAdminLogin::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
        AfxGetApp()->WinHelp( pHelpInfo->dwContextId, HELP_CONTEXTPOPUP);
    return TRUE;
}


//
// There is a chance that the encrypted password saved in Win98 is not matching
// the encrypted one under Win2K, because Win2K does  special treatment of some
// chars for Unicode requirements.
// We try to see if the mismatch was according to the special changes for Win2K.
//
BOOL CAdminLogin::Win98vsWin2KPwdMismatch(LPTSTR szPasswd, LPTSTR szSavedPasswd, LPCTSTR szSecName)
{
    int  i ;
    int  iLength = lstrlen(szPasswd) ;
    for (i = 0; i < iLength; i++) {
        if (szPasswd[i] != szSavedPasswd[i])  // a mismatched char position
        {
            if ((szSavedPasswd[i] & 0x7F) == szPasswd[i]  || // differs in only high order bit
                ((szPasswd[i] & 0xE0) == 0 &&                // if type 000X XXXX, i.e., in 0..31
                 szPasswd[i] + 42 == szSavedPasswd[i])    || // and a diff of 42 (precisely)
                (127 == szPasswd[i] &&                       // password is 127 (exactly)
                 80 == szSavedPasswd[i]))                    // saved char is 80 (exactly)
                continue ;    // ignore the mismatch -- it's due to different encryption algorithm

            // Actually bad password was given
            return FALSE ;
        }
    }

    // Looks like the password mismatched only because of the different alogrithms.
    // We'll update the saved password with the new one so that we don't go through
    // this code later again.
	CString csKeyName;
	csKeyName.LoadString(IDS_INI_PASSWORD);
	LPTSTR lpProfileName = ((CDvdplayApp*) AfxGetApp())->GetProfileName();
	WritePrivateProfileString(szSecName, csKeyName, szPasswd, lpProfileName);

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\admlogin.h ===
#if !defined(AFX_ADMLOGIN_H__88483F44_E16F_11D0_8A6A_00AA00605CD5__INCLUDED_)
#define AFX_ADMLOGIN_H__88483F44_E16F_11D0_8A6A_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AdmLogin.h : header file
//

#define MAX_LINE    200
#define MAX_NAME    100
#define MAX_RATE     50
#define MAX_PASSWD   20
// #define MAX_SECTION  10 
#define MAX_SECTION 20 // 10 is TOO SHORT for "Administrator" and was causing corruption of another variable !!!
#define MAX_NUMUSER   5
#define BY_SET_RATING     1
#define BY_SET_SHOWLOGON  2

/////////////////////////////////////////////////////////////////////////////
// CAdminLogin dialog

class CAdminLogin : public CDialog
{
// Construction
public:
	CAdminLogin(CWnd* pParent = NULL);   // standard constructor
	static void EncryptPassword(LPTSTR lpPassword);
	static void DecryptPassword(LPTSTR lpPassword);
	static int  GetNumOfUser(LPTSTR m_lpProfileName);
	static BOOL ConfirmPassword(LPTSTR m_lpProfileName, LPTSTR szName, LPTSTR szPassword);
	static BOOL SearchProfileByName(LPTSTR m_lpProfileName, LPTSTR szName, LPTSTR szSectionName);
    static BOOL Win98vsWin2KPwdMismatch(LPTSTR szPasswd, LPTSTR szSavedPasswd, LPCTSTR szSecName) ;

	UINT   m_uiCalledBy;
// Dialog Data
	//{{AFX_DATA(CAdminLogin)
	enum { IDD = IDD_DIALOG_ADMIN_LOGIN };
	CEdit	m_ctlConfirmNew;
	CEdit	m_ctlPassword;
	CEdit	m_ctlConfirm;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAdminLogin)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
	TCHAR    m_szPassword[MAX_PASSWD];
	TCHAR    m_szConfirm[MAX_PASSWD];
	TCHAR    m_szConfirmNew[MAX_PASSWD];

protected:
	void SetHalfSizeWindow(BOOL bNewAdmin);
	void SetFullSizeWindow();
	CRect    m_rcOriginalRC;
	LPTSTR   m_lpProfileName;
	BOOL     m_bNewAdmin;
	BOOL     m_bChangePasswd;

	// Generated message map functions
	//{{AFX_MSG(CAdminLogin)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButtonChangePassword();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADMLOGIN_H__88483F44_E16F_11D0_8A6A_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\audiolan.cpp ===
// AudioLan.cpp : implementation file
//

#include "stdafx.h"
#include "dvdplay.h"
#include "AudioLan.h"
#include "navmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAudioLanguage dialog


CAudioLanguage::CAudioLanguage(CWnd* pParent /*=NULL*/)
	: CDialog(CAudioLanguage::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAudioLanguage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAudioLanguage::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAudioLanguage)
	DDX_Control(pDX, IDC_LIST_AUDIO_LANGUAGE, m_ctlListAudioLanguage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAudioLanguage, CDialog)
	//{{AFX_MSG_MAP(CAudioLanguage)
	ON_LBN_SELCHANGE(IDC_LIST_AUDIO_LANGUAGE, OnSelchangeListAudioLanguage)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAudioLanguage message handlers

BOOL CAudioLanguage::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	m_pDVDNavMgr = ((CDvdplayApp*) AfxGetApp())->GetDVDNavigatorMgr();
	if(!m_pDVDNavMgr)
		return FALSE;

	IDvdInfo *pDvdInfo = m_pDVDNavMgr->GetDvdInfo();
	if(pDvdInfo)
	{
	    ULONG  ulStream;
	    LCID   lcid; 
		TCHAR  szLanguage[MAX_PATH], szNum[4];

	    while(m_ctlListAudioLanguage.GetCount())
			m_ctlListAudioLanguage.DeleteString(0);

		ULONG pnStreamAvailable, pnCurrentStream;
		HRESULT hr = pDvdInfo->GetCurrentAudio(&pnStreamAvailable, &pnCurrentStream);

		//Init language list box
		int nListIdx=0;
	    for(ulStream=0; ulStream<pnStreamAvailable; ulStream++) //ulStream<8
	    {
		    if( SUCCEEDED(pDvdInfo->GetAudioLanguage(ulStream, &lcid)) )
			{
				int iRet = GetLocaleInfo(lcid, LOCALE_SENGLANGUAGE, szLanguage, MAX_PATH);
				if(lcid == 0)
				{
					LoadString(((CDvdplayApp*) AfxGetApp())->m_hInstance, IDS_STREAM, szLanguage, MAX_PATH);
					_itot(ulStream+1, szNum, 10);
					lstrcat(szLanguage, szNum);
				}
				
				m_ctlListAudioLanguage.AddString(szLanguage);
				m_iLanguageIdx[nListIdx] = ulStream;
				nListIdx++;
			}
	    }
		
		//Set highlight to the selected language
		for(nListIdx=0; nListIdx<8; nListIdx++)
		{
			if(m_iLanguageIdx[nListIdx] == pnCurrentStream)
			m_ctlListAudioLanguage.SetCurSel(nListIdx);
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAudioLanguage::OnSelchangeListAudioLanguage() 
{
	ULONG iSelected = m_ctlListAudioLanguage.GetCurSel();
	if(iSelected != LB_ERR)
		m_pDVDNavMgr->DVDAudioStreamChange(m_iLanguageIdx[iSelected]);
}

BOOL CAudioLanguage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
        AfxGetApp()->WinHelp( pHelpInfo->dwContextId, HELP_CONTEXTPOPUP);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\audiolan.h ===
#if !defined(AFX_AUDIOLAN_H__D4F80361_DB4E_11D0_9BFC_00AA00605CD5__INCLUDED_)
#define AFX_AUDIOLAN_H__D4F80361_DB4E_11D0_9BFC_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// AudioLan.h : header file
//
class CDVDNavMgr;
/////////////////////////////////////////////////////////////////////////////
// CAudioLanguage dialog

class CAudioLanguage : public CDialog
{
// Construction
public:
	CAudioLanguage(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAudioLanguage)
	enum { IDD = IDD_DIALOG_AUDIO_LANGUAGE };
	CListBox	m_ctlListAudioLanguage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAudioLanguage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDVDNavMgr* m_pDVDNavMgr;
	ULONG       m_iLanguageIdx[8];

	// Generated message map functions
	//{{AFX_MSG(CAudioLanguage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeListAudioLanguage();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUDIOLAN_H__D4F80361_DB4E_11D0_9BFC_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\dvdevcod.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// list of standard DVD-Video event codes and the expected params
// 


#define EC_DVDBASE							0x0100


typedef enum _tagDVD_ERROR {
    DVD_ERROR_Unexpected=1,         // Something unexpected happened, perhaps content
                                    //   is incorrectly authored.  Playback is stopped.
    DVD_ERROR_CopyProtectFail=2,    // Key exchange for DVD copy protection failed. 
                                    //   Playback is stopped.
    DVD_ERROR_InvalidDVD1_0Disc=3,  // DVD-Video disc is incorrectly authored for v1.0 
                                    //   of spec. Playback is stopped.
    DVD_ERROR_InvalidDiscRegion=4,  // The Disc is not approved for playback by decoders
                                    //   from this DVD region.
    DVD_ERROR_LowParentalLevel=5,   // Player parental level is lower than the lowest parental
                                    //   level available in the DVD content. Playback is stopped.
    DVD_ERROR_MacrovisionFail=6     // Macrovision Distribution Failed.
                                    // Playback is stopped.
} DVD_ERROR;

typedef enum _tagDVD_WARNING {
    DVD_WARNING_InvalidDVD1_0Disc=1,// DVD-Video disc is incorrectly authored. Playback
                                    //   can continue, but unexpected behavior may occur.
    DVD_WARNING_FormatNotSupported=2,// A decoder would not support the current format.  Playback
                                    //   of a stream (audio, video of SP) may not function.
    DVD_WARNING_IllegalNavCommand=3 // The internal DVD navigation command processor attempted to 
                                    //   process an illegal command.
} DVD_WARNING;

// DVD-Video event codes
// ======================
//
// All DVD-Video event are always passed on to the application, and are 
// never processed by the filter graph


#define EC_DVD_DOMAIN_CHANGE                    (EC_DVDBASE + 0x01)
// Parameters: ( DWORD, void ) 
// lParam1 is enum DVD_DOMAIN, and indicates the player's new domain
//
// Raised from following domains: all
//
// Signaled when ever the DVD player changes domains.


#define EC_DVD_TITLE_CHANGE                     (EC_DVDBASE + 0x02)
// Parameters: ( DWORD, void ) 
// lParam1 is the new title number.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Indicates when the current title number changes.  Title numbers
// range 1 to 99.  This indicates the TTN, which is the title number
// with respect to the whole disc, not the VTS_TTN which is the title
// number with respect to just a current VTS.


#define EC_DVD_CHAPTER_START                   (EC_DVDBASE + 0x03)
// Parameters: ( DWORD, void ) 
// lParam1 is the new chapter number (which is the program number for 
// One_Sequential_PGC_Titles).
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signales that DVD player started playback of a new program in the Title 
// domain.  This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_AUDIO_STREAM_CHANGE              (EC_DVDBASE + 0x04)
// Parameters: ( DWORD, void ) 
// lParam1 is the new user audio stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user audio stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.
// Audio stream numbers range from 0 to 7.  Stream 0xffffffff
// indicates that no stream is selected.

#define EC_DVD_SUBPICTURE_STREAM_CHANGE         (EC_DVDBASE + 0x05)
// Parameters: ( DWORD, void ) 
// lParam1 is the new user subpicture stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user subpicture stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.  
// Subpicture stream numbers range from 0 to 31.  Stream 0xffffffff
// indicates that no stream is selected.  

#define EC_DVD_ANGLE_CHANGE                     (EC_DVDBASE + 0x06)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available angles.
// lParam2 is the current user angle number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available angles changes, or  
//   b) the current user angle number changes.
// Current angle number can be changed automatically with navigation command 
// on disc as well as through IDVDAnnexJ.
// When the number of available angles is 1, the current video is not multiangle.
// Angle numbers range from 1 to 9.


#define EC_DVD_BUTTON_CHANGE                    (EC_DVDBASE + 0x07)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available buttons.
// lParam2 is the current selected button number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available buttons changes, or  
//   b) the current selected button number changes.
// The current selected button can be changed automatically with navigation 
// commands on disc as well as through IDVDAnnexJ.  
// Button numbers range from 1 to 36.  Selected button number 0 implies that
// no button is selected.  Note that these button numbers enumerate all 
// available button numbers, and do not always correspond to button numbers
// used for IDVDAnnexJ::ButtonSelectAndActivate since only a subset of buttons
// may be activated with ButtonSelectAndActivate.


#define EC_DVD_VALID_UOPS_CHANGE                (EC_DVDBASE + 0x08)
// Parameters: ( DWORD, void ) 
// lParam1 is a VALID_UOP_SOMTHING_OR_OTHER bit-field stuct which indicates
//   which IDVDAnnexJ commands are explicitly disable by the DVD disc.
//
// Raised from following domains: all
//
// Signaled when ever the available set of IDVDAnnexJ methods changes.  This
// only indicates which operations are explicited disabled by the content on 
// the DVD disc, and does not guarentee that it is valid to call methods 
// which are not disabled.  For example, if no buttons are currently present,
// IDVDAnnexJ::ButtonActivate() won't work, even though the buttons are not
// explicitly disabled. 


#define EC_DVD_STILL_ON                         (EC_DVDBASE + 0x09)
// Parameters: ( BOOL, DWORD ) 
// lParam1 == 0  -->  buttons are available, so StillOff won't work
// lParam1 == 1  -->  no buttons available, so StillOff will work
// lParam2 indicates the number of seconds the still will last, with 0xffffffff 
//   indicating an infinite still (wait till button or StillOff selected).
//
// Raised from following domains: all
//
// Signaled at the beginning of any still: PGC still, Cell Still, or VOBU Still.
// Note that all combinations of buttons and still are possible (buttons on with
// still on, buttons on with still off, button off with still on, button off
// with still off).

#define EC_DVD_STILL_OFF                         (EC_DVDBASE + 0x0a)
// Parameters: ( void, void ) 
//
//   Indicating that any still that is currently active
//   has been released.
//
// Raised from following domains: all
//
// Signaled at the end of any still: PGC still, Cell Still, or VOBU Still.
//

#define EC_DVD_CURRENT_TIME                     (EC_DVDBASE + 0x0b)
// Parameters: ( DWORD, BOOL ) 
// lParam1 is a DVD_TIMECODE which indicates the current 
//   playback time code in a BCD HH:MM:SS:FF format.
// lParam2 == 0  -->  time code is 25 frames/sec
// lParam2 == 1  -->  time code is 30 frames/sec (non-drop).
// lParam2 == 2  -->  time code is invalid (current playback time 
//                    cannot be determined for current title)
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.
// This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_ERROR                            (EC_DVDBASE + 0x0c)
// Parameters: ( DWORD, void) 
// lParam1 is an enum DVD_ERROR which notifies the app of some error condition.
//
// Raised from following domains: all
//

#define EC_DVD_WARNING                           (EC_DVDBASE + 0x0d)
// Parameters: ( DWORD, void) 
// lParam1 is an enum DVD_WARNING which notifies the app of some warning condition.
//
// Raised from following domains: all
//

#define EC_DVD_CHAPTER_AUTOSTOP                  (EC_DVDBASE + 0x0e)
// Parameters: (void, void)
// 
//  Indicating that playback is stopped as a result of a call
//  to IDVDControl::ChapterPlayAutoStop()
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_NO_FP_PGC                         (EC_DVDBASE + 0x0f)
//  Parameters : (void, void)
//
//  Raised from the following domains : FP_DOM
//
//  Indicates that the DVD disc does not have a FP_PGC (First Play Program Chain)
//  and the DVD Navigator will not automatically load any PGC and start playback.
//

#define EC_DVD_PLAYBACK_RATE_CHANGE              (EC_DVDBASE + 0x10)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new playback rate.
//  lParam1 < 0 indicates reverse playback mode.
//  lParam1 > 0 indicates forward playback mode
//  Value of lParam1 is the actual playback rate multiplied by 10000.
//  i.e. lParam1 = rate * 10000
//
//  Raised from the following domains : TT_DOM
//
//  Indicates that a rate change in playback has been initiated and the parameter
//  lParam1 indicates the new playback rate that is being used.
//

#define EC_DVD_PARENTAL_LEVEL_CHANGE            (EC_DVDBASE + 0x11)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new parental level.
//
//  Raised from the following domains : VMGM_DOM
//
//  Indicates that an authored Nav command has changed the parental level
//  setting in the player.
//

#define EC_DVD_PLAYBACK_STOPPED                 (EC_DVDBASE + 0x12)
//  Parameters : (void, void)
//
//  Raised from the following domains : All Domains
//
// Indicates that playback has been stopped as the Navigator has completed
// playback of the pgc and did not find any other branching instruction for
// subsequent playback.
//

#define EC_DVD_ANGLES_AVAILABLE                 (EC_DVDBASE + 0x13)
//  Parameters : (BOOL, void)
//  lParam1 == 0 indicates that playback is not in an angle block and angles are
//             not available
//  lParam1 == 1 indicates that an angle block is being played back and angle changes
//             can be performed.
//
//  Indicates whether an angle block is being played and if angle changes can be 
//  performed. However, angle changes are not restricted to angle blocks and the
//  manifestation of the angle change can be seen only in an angle block.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\dvdstub.cpp ===
// dvdstub.cpp : Defines the entry point for the console application.
//

#pragma once
#include <Windows.h>
#include <stdio.h>
#ifndef MAXPATH
#define MAXPATH 1024
#endif

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     PSTR      pCmdLine,
                     int       nCmdShow)
{
	try{
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		
		ZeroMemory( &si, sizeof(si) );
		si.cb = sizeof(si);
		ZeroMemory( &pi, sizeof(pi) );
		TCHAR filePos[MAXPATH];
		ZeroMemory(filePos, sizeof(TCHAR)*MAXPATH);
		TCHAR filePath[MAXPATH];
		ZeroMemory(filePath, sizeof(TCHAR)*MAXPATH);
		DWORD szPath = (sizeof(TCHAR)/sizeof(BYTE))*MAXPATH;
		HKEY wmpKey = 0;
		LONG temp = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,         // handle to open key
			TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wmplayer.exe"), // subkey name
			0,   // reserved
			KEY_READ, // security access mask
			&wmpKey    // handle to open key
			);
		DWORD tempType = 0;
		temp = RegQueryValueEx(
			wmpKey,            // handle to key
			TEXT("Path"),  // value name
			0,   // reserved
			&tempType,       // type buffer
			(BYTE*)filePath,        // data buffer
			&szPath     // size of data buffer
			);
		TCHAR *namePos;
		DWORD retVal =  0;
		retVal = SearchPath(
			(TCHAR *)filePath,      // search path
			TEXT("wmplayer"),  // file name
			TEXT(".exe"), // file extension
			MAXPATH, // size of path buffer
			filePos,     // path buffer
			&namePos   // address of file name in path
			);
		
		BOOL retBool = CreateProcess(
			filePos,
			TEXT(" /device:dvd"),
			NULL,
			NULL,
			FALSE,
			0,
			NULL,
			NULL,
			&si,              // Pointer to STARTUPINFO structure.
			&pi             // Pointer to PROCESS_INFORMATION structure.
			);
	}
	catch(...){}    
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\dvduidlg.cpp ===
// DvdUIDlg.cpp : implementation file
//
#include "dvdevcod.h"
#include "stdafx.h"
#include "dvdplay.h"
#include "DvdUIDlg.h"
#include "navmgr.h"
#include "videowin.h"
#include "voladjst.h"
#include "subtitle.h"
#include "audiolan.h"
#include "setrate.h"
#include "srchTitl.h"
#include "srchchap.h"
#include <mmsystem.h>
#include "admlogin.h"
#include "openfile.h"
#include "htmlhelp.h"
#include "dbt.h"
#include "mediakey.h"

/*
This was necessary for MFC subclassing, which we don't need after all
//
// There is a #define in windowsx.h that defines SubclassWindow to mean something, which
// conflicts with CWnd::SubclassWindow.  There is a clause in afxwin.h that is supposed to
// #undef the SubclassWindow macro, but for some reason that does not seem to be happening.
// So we manually #undef it here...
//
//#undef SubclassWindow
*/

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDvdUIDlg dialog


CDvdUIDlg::CDvdUIDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDvdUIDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDvdUIDlg)
	//}}AFX_DATA_INIT
	m_pVideoWindow = new CVideoWindow;
	szTitleNumber[0] = 0;
	szChapterNumber[0] = 0;
	szTimePrograss[0] = 0;
	m_bEjected = FALSE;
}

BOOL CDvdUIDlg::Create()
{
	return CDialog::Create(CDvdUIDlg::IDD);
}

CDvdUIDlg::~CDvdUIDlg()
{
	if(m_pVideoWindow != NULL)
	{
		delete m_pVideoWindow;
		m_pVideoWindow = NULL;
	}
}

void CDvdUIDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDvdUIDlg)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDvdUIDlg, CDialog)
	//{{AFX_MSG_MAP(CDvdUIDlg)
	ON_BN_CLICKED(IDB_PLAY, OnPlay)
	ON_BN_CLICKED(IDB_STOP, OnStop)
	ON_BN_CLICKED(IDB_PAUSE, OnPause)
	ON_BN_CLICKED(IDB_VERY_FAST_REWIND, OnVeryFastRewind)
	ON_BN_CLICKED(IDB_FAST_REWIND, OnFastRewind)
	ON_BN_CLICKED(IDB_FAST_FORWARD, OnFastForward)
	ON_BN_CLICKED(IDB_VERY_FAST_FORWARD, OnVeryFastForward)
	ON_BN_CLICKED(IDB_STEP, OnStep)
	ON_BN_CLICKED(IDB_FULL_SCREEN, OnFullScreen)
	ON_BN_CLICKED(IDB_AUDIO_VOLUME, OnAudioVolume)
	ON_BN_CLICKED(IDB_MENU, OnMenu)
	ON_BN_CLICKED(IDB_ENTER, OnEnter)
	ON_BN_CLICKED(IDB_UP, OnUp)
	ON_BN_CLICKED(IDB_DOWN, OnDown)
	ON_BN_CLICKED(IDB_LEFT, OnLeft)
	ON_BN_CLICKED(IDB_RIGHT, OnRight)
	ON_BN_CLICKED(IDB_OPTIONS, OnOptions)
	ON_COMMAND(ID_OPERATION_SKIP_NEXTCHAPTER, OnNextChapter)
	ON_COMMAND(ID_OPERATION_SKIP_PREVIOSCHAPTER, OnPreviosChapter)
	ON_COMMAND(ID_OPTIONS_SUBTITLES, OnOptionsSubtitles)
	ON_WM_CLOSE()
#ifdef DISPLAY_OPTIONS
	ON_COMMAND(ID_OPTIONS_DISPLAY_PANSCAN, OnOptionsDisplayPanscan)
	ON_COMMAND(ID_OPTIONS_DISPLAY_LETTERBOX, OnOptionsDisplayLetterbox)
	ON_COMMAND(ID_OPTIONS_DISPLAY_WIDE, OnOptionsDisplayWide)
#endif
	ON_WM_CONTEXTMENU()
	ON_COMMAND(ID_OPTIONS_SETRATINGS, OnOptionsSetratings)
	ON_COMMAND(ID_OPERATION_PLAYSPEED_NORMALSPEED, OnOperationPlayspeedNormalspeed)
	ON_COMMAND(ID_OPERATION_PLAYSPEED_DOUBLESPEED, OnOperationPlayspeedDoublespeed)
	ON_COMMAND(ID_OPERATION_PLAYSPEED_HALFSPEED, OnOperationPlayspeedHalfspeed)
	ON_COMMAND(ID_SEARCH_TITLE, OnSearchTitle)
	ON_COMMAND(ID_SEARCH_CHAPTER, OnSearchChapter)
	ON_WM_DRAWITEM()
	ON_BN_CLICKED(IDB_EJECT_DISC, OnEjectDisc)
	ON_COMMAND(ID_OPTIONS_CLOSEDCAPTION, OnOptionsClosedcaption)
	ON_BN_CLICKED(IDB_HELP, OnHelp)
	ON_COMMAND(ID_OPTIONS_SELECT_DISC, OnOptionsSelectDisc)
	ON_COMMAND(ID_OPTIONS_SHOW_LOGON, OnOptionsShowLogon)
	ON_COMMAND(ID_OPTIONS_LANGUAGE, OnOptionsLanguage)
	ON_WM_HELPINFO()
	ON_BN_CLICKED(IDC_CONTEXT_HELP, OnContextHelp)
	ON_COMMAND(ID_OPERATION_PLAY, OnPlay)
	ON_COMMAND(ID_OPERATION_STOP, OnStop)
	ON_COMMAND(ID_OPERATION_PAUSE, OnPause)
	ON_COMMAND(ID_OPERATION_FULLSCREEN, OnFullScreen)
	ON_COMMAND(ID_OPERATION_FASTFORWARD, OnFastForward)
	ON_COMMAND(ID_OPERATION_FASTREWIND, OnFastRewind)
	ON_COMMAND(ID_OPERATION_VERYFASTFORWARD, OnVeryFastForward)
	ON_COMMAND(ID_OPERATION_VERYFASTREWIND, OnVeryFastRewind)
	ON_COMMAND(ID_OPERATION_MENU, OnMenu)
	ON_COMMAND(ID_OPERATION_SETVOLUME, OnAudioVolume)	
	ON_COMMAND(ID_ARROWS_UP, OnUp)
	ON_COMMAND(ID_ARROWS_DOWN, OnDown)
	ON_COMMAND(ID_ARROWS_LEFT, OnLeft)
	ON_COMMAND(ID_ARROWS_RIGHT, OnRight)
	ON_COMMAND(ID_ARROWS_ENTER, OnEnter)
	ON_COMMAND(ID_OPERATION_EJECTDISK, OnEjectDisc)
	ON_COMMAND(ID_OPTIONS_TITLE_MENU, OnOptionsTitleMenu)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_POWERBROADCAST , OnPowerBroadcast)
	ON_MESSAGE(WM_DEVICECHANGE, OnDeviceChange)
   //ON_MESSAGE(WM_APPCOMMAND, OnAppCommand)
	ON_COMMAND_EX(ID_OPTIONS_CAMERAANGLES_ANGLE1, OnAngleChange)
	ON_COMMAND_EX(ID_OPTIONS_CAMERAANGLES_ANGLE2, OnAngleChange)
	ON_COMMAND_EX(ID_OPTIONS_CAMERAANGLES_ANGLE3, OnAngleChange)
	ON_COMMAND_EX(ID_OPTIONS_CAMERAANGLES_ANGLE4, OnAngleChange)
	ON_COMMAND_EX(ID_OPTIONS_CAMERAANGLES_ANGLE5, OnAngleChange)
	ON_COMMAND_EX(ID_OPTIONS_CAMERAANGLES_ANGLE6, OnAngleChange)
	ON_COMMAND_EX(ID_OPTIONS_CAMERAANGLES_ANGLE7, OnAngleChange)
	ON_COMMAND_EX(ID_OPTIONS_CAMERAANGLES_ANGLE8, OnAngleChange)
	ON_COMMAND_EX(ID_OPTIONS_CAMERAANGLES_ANGLE9, OnAngleChange)
   ON_WM_TIMER()
   //ON_MESSAGE(WM_SYSCOMMAND, OnSysCommand)
END_MESSAGE_MAP()


/* Hook stuff - unnecessary
HHOOK g_hHook;

//
// This is called when one of our windows received a WM_APPCOMMAND and did not process it.
// The advantage of handling WM_APPCOMMAND here is that we get it all in one place regardless
// of which window had focus.
//
LRESULT CALLBACK ShellProc(int nCode, WPARAM wParam, LPARAM lParam) {
   if (nCode < 0)
      return CallNextHookEx(g_hHook, nCode, wParam, lParam);
   else if (IsAppcommandCode(nCode)) {
      CDVDNavMgr* pNav = ((CDvdplayApp*)(AfxGetApp()))->GetDVDNavigatorMgr();
      CDvdUIDlg* pUI = (CDvdUIDlg*) (((CDvdplayApp*)(AfxGetApp()))->GetUIWndPtr());

      switch (MediaKey(lParam)) { // see mediakey.cpp
         case MediaKey_NextTrack:
            pUI->OnNextChapter();
            return TRUE;
         case MediaKey_PrevTrack:
            pUI->OnPreviosChapter();
            return TRUE;
         case MediaKey_Stop:
            pUI->OnStop();
            return TRUE;
         case MediaKey_Play:
            //
            // Spec ambiguity: in the "scanning" state (ff/rw), both play and pause
            // are legal.  Play takes precedence.
            //
            if (pNav->DVDCanPlay())
               pUI->OnPlay();
            else if (pNav->DVDCanPause())
               pUI->OnPause();
            return TRUE;
         default:
            return FALSE;
      }
   }
   else
      return FALSE;
}
End hoook stuff */

/* This is also unnecessary since instead of waiting for WM_APPCOMMAND
   we now process interesting WM_KEYDOWNS directly.
//
// Override WindowProc to fish out and process WM_APPCOMMAND messages.
// Cannot do this via the message map because the WM_APPCOMMAND #define
// is not available in this file (see mediakey.cpp).
//
LRESULT CDvdUIDlg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) {
   if (IsAppcommandMessage(message)) {
      return OnAppCommand(wParam, lParam);
   }
   else
      return CDialog::WindowProc(message, wParam, lParam); // dispatch through message map
}
*/

/* Win32 subclassing stuff - unnecessary, we have CDvdplayApp::PreTranslateMessage()
#define OLDPROCTABLESIZE 50 // we have 26 windows, 50 entries should do for a while
struct {
   HWND hWnd;
   WNDPROC lpfnOldWndProc;
} g_OldProcTable[OLDPROCTABLESIZE];

int g_nOldProcTableElms;

LONG FAR PASCAL SubClassFunc(HWND hWnd,
                             WORD Message,
                             WORD wParam,
                             LONG lParam) {
   if (((Message == WM_KEYUP) || (Message == WM_KEYDOWN)) &&
       IsMediaControlKey(wParam))
      return (((CDvdplayApp*) AfxGetApp())->GetUIWndPtr())->SendMessage(Message, wParam, lParam);
   for (int i = 0; i < OLDPROCTABLESIZE; i++) {
      if (g_OldProcTable[i].hWnd == hWnd) {
         DbgLog((LOG_TRACE,1,"message for hwnd %X goes to 0x%08X", hWnd, g_OldProcTable[i].lpfnOldWndProc));
         return CallWindowProc(g_OldProcTable[i].lpfnOldWndProc,
                               hWnd, Message, wParam, lParam);
      }
   }
   DbgLog((LOG_TRACE,1,"Could not find subclassed window's entry in the OldProc table !"));
   return FALSE;
}
End Win32 subclassing stuff
*/

/////////////////////////////////////////////////////////////////////////////
// CDvdUIDlg message handlers
BOOL CDvdUIDlg::OnInitDialog()
{	
	CDialog::OnInitDialog();

	//Set window title.
	CString csTitle;
	csTitle.LoadString(IDS_MSGBOX_TITLE);
	SetWindowText(csTitle);

	//Save class name, so second instance of player can use it to find first instance.
	TCHAR szClassName[MAX_PATH];
	GetClassName(m_hWnd, szClassName, MAX_PATH);
	CString csSection, csEntry;
	csSection.LoadString(IDS_UI_WINDOW_POS);
	csEntry.LoadString(IDS_UIWND_CLASSNAME);
	((CDvdplayApp*) AfxGetApp())->WriteProfileString(csSection, csEntry, szClassName);
	
	// TODO: Add extra initialization here
	if (m_pVideoWindow->GetSafeHwnd() == 0)
		m_pVideoWindow->Create(this);

	m_pDVDNavMgr = ((CDvdplayApp*) AfxGetApp())->GetDVDNavigatorMgr();
	if(!m_pDVDNavMgr)
		return FALSE;

	CMenu* sysMenu = GetSystemMenu(FALSE);
	if(sysMenu)
	{
		sysMenu->DeleteMenu(2, MF_BYPOSITION);   //don't need "size"
		sysMenu->DeleteMenu(3, MF_BYPOSITION);   //don't need "Maximize"
	}

	m_csBox1Title.LoadString(IDS_BLACKBOX1_TITLE);
	m_csBox2Title.LoadString(IDS_BLACKBOX2_CHAPTER);
	m_csBox3Title.LoadString(IDS_BLACKBOX3_PROGRESS);

	HICON hIcon = ((CDvdplayApp*) AfxGetApp())->LoadIcon( IDR_MAINFRAME );
	SetIcon( hIcon, TRUE );
	InitBitmapButton();	
	createAddToolTips();

	//Set default font for Englisg, the localize people will change
	//FontFace, FontHeight, CharSet for particular language.
	CString csFontHeight, csFontFace, csCharSet;
	int nFontHeight = 15;
	BYTE bCharSet = 1;
	csFontHeight.LoadString(IDS_FONTHEIGHT);
	csFontFace.LoadString(IDS_FONTFACE);
	csCharSet.LoadString(IDS_CHARSET);
	nFontHeight = _ttoi(csFontHeight);
	bCharSet = (BYTE) _ttoi(csCharSet);
	m_font.CreateFont(nFontHeight, 0, 0, 0, FW_DONTCARE, FALSE, FALSE, 0, bCharSet,
		              OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
		              DEFAULT_PITCH | FF_SWISS, csFontFace);

	EnableEnterArrowButtons(FALSE);

   /* Subclassing stuff - unnecessary
   //
   // Subclass the children so that we can get their WM_KEYUP/WM_KEYDOWN
   //

   // Initialize the lookup table used for calling the subclassed windows
   for (int i = 0; i < OLDPROCTABLESIZE; i++)
      g_OldProcTable[i].hWnd = NULL;
   g_nOldProcTableElms = 0;

   // int nTotal = 0, nThis = 0, nOurs = 0, nOrphans = 0, nMFCWeird = 0;
   CWnd *pChild = GetWindow(GW_CHILD);
   while (pChild) {
      // MFC subclassing - causes an assert in CWnd::SubclassWindow()
      // SubclassWindow(pChild->m_hWnd);

      if (g_nOldProcTableElms >= OLDPROCTABLESIZE) {
         DbgLog((LOG_TRACE,1,"OldProcTable is full !"));
         break;
      }

      g_OldProcTable[g_nOldProcTableElms].lpfnOldWndProc
          =
         (WNDPROC) SetWindowLongPtr(pChild->m_hWnd, GWLP_WNDPROC, (LONG_PTR) SubClassFunc);

      if (g_OldProcTable[g_nOldProcTableElms].lpfnOldWndProc) {
         g_OldProcTable[g_nOldProcTableElms].hWnd = pChild->m_hWnd;
         g_nOldProcTableElms++;
      }
      else {
         DbgLog((LOG_TRACE,1,"failed to subclass window %08X (SetWindowLong failed)", pChild->m_hWnd));
      }

   #if 0 // test code to investigate how GetWindow works
      nTotal++;
      DbgLog((LOG_TRACE,1,"child %X", pChild->m_hWnd));
      CWnd *pOwner = pChild->GetWindow(GW_OWNER);
      if (pOwner) {
         if (pOwner == this)
            nThis++;
         else if (pOwner->m_hWnd == m_hWnd)
            nOurs++;
      }
      else {
         if (::GetWindow(pChild->m_hWnd, GW_OWNER))
            nMFCWeird++;
         else
            nOrphans++;
      }
   #endif
      pChild = pChild->GetWindow(GW_HWNDNEXT);
   }
   #if 0 // more test code
   DbgLog((LOG_TRACE,1,"%d children: %d this, %d ours, %d orphans, %d MFCweird",
           nTotal, nThis, nOurs, nOrphans, nMFCWeird));
   #endif
   End subclassing stuff
   */


   //if (AfxGetApp()->m_nThreadID != GetCurrentThreadId())
   //   MessageBox(TEXT("OnInitDialog is run on a different thread than the app's main thread"), TEXT("Threads"));

   /* Hook stuff
   // install the hook that will handle WM_APPCOMMAND messages not handled by our windows
   g_hHook = SetWindowsHookEx(
      WH_SHELL,
      ShellProc,
      AfxGetApp()->m_hInstance,
      AfxGetApp()->m_nThreadID
   );
   if (g_hHook == NULL)
      //MessageBox(TEXT("trouble"), TEXT("SetWindowsHookEx failed !"));
      DbgLog((LOG_TRACE,1,"SetWindowsHookEx failed, media keys won't work"));
   */
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/* Hook stuff
void CDvdUIDlg::OnDestroy() {
   if (g_hHook) {
      if (UnhookWindowsHookEx(g_hHook) == 0)
         //_asm int 3;
         DbgLog((LOG_TRACE,1,"UnhookWindowsHookEx failed"));
      else
         g_hHook = NULL;
   }
}
*/

void CDvdUIDlg::InitBitmapButton()
{
	m_bmpBtnPlay.AutoLoad(IDB_PLAY, this);
	m_bmpBtnPause.AutoLoad(IDB_PAUSE, this);
	m_bmpBtnStop.AutoLoad(IDB_STOP, this);
	m_bmpBtnEj.AutoLoad(IDB_EJECT_DISC, this);
	m_bmpBtnFullScreen.AutoLoad(IDB_FULL_SCREEN, this);
	m_bmpBtnVeryFastRewind.AutoLoad(IDB_VERY_FAST_REWIND, this);
	m_bmpBtnFastRewind.AutoLoad(IDB_FAST_REWIND, this);
	m_bmpBtnFastForward.AutoLoad(IDB_FAST_FORWARD, this);
	m_bmpBtnVeryFastForward.AutoLoad(IDB_VERY_FAST_FORWARD, this);
//	m_bmpBtnStep.AutoLoad(IDB_STEP, this);
	m_bmpBtnAudio.AutoLoad(IDB_AUDIO_VOLUME, this);
	m_bmpBtnUp.AutoLoad(IDB_UP, this);
	m_bmpBtnDown.AutoLoad(IDB_DOWN, this);
	m_bmpBtnLeft.AutoLoad(IDB_LEFT, this);
	m_bmpBtnRught.AutoLoad(IDB_RIGHT, this);
	m_bmpBtnHelp.AutoLoad(IDB_HELP, this);
	m_bmpContextHelp.AutoLoad(IDC_CONTEXT_HELP, this);
}

void CDvdUIDlg::createAddToolTips()
{
	m_ToolTips.Create(this, TTS_ALWAYSTIP);
	
	addTool(IDB_PLAY, IDS_PLAY_TIP);
	addTool(IDB_PAUSE, IDS_PAUSE_TIP);
	addTool(IDB_STOP, IDS_STOP_TIP);
	addTool(IDB_EJECT_DISC, IDS_EJECT_DISC_TIP);
	addTool(IDB_VERY_FAST_REWIND, IDS_VERY_FAST_REWIND_TIP);
	addTool(IDB_FAST_REWIND, IDS_FAST_REWIND_TIP);
	addTool(IDB_FAST_FORWARD, IDS_FAST_FORWARD_TIP);
	addTool(IDB_VERY_FAST_FORWARD, IDS_VERY_FAST_FORWARD_TIP);
	addTool(IDB_STEP, IDS_STEP_TIP);
	addTool(IDB_FULL_SCREEN, IDS_FULL_SCREEN_TIP);
	addTool(IDB_AUDIO_VOLUME, IDS_AUDIO_VOLUME_TIP);
	addTool(IDB_MENU, IDS_MENU_TIP);
	addTool(IDB_ENTER, IDS_ENTER_TIP);
	addTool(IDB_UP, IDS_UP_TIP);
	addTool(IDB_DOWN, IDS_DOWN_TIP);
	addTool(IDB_LEFT, IDS_LEFT_TIP);
	addTool(IDB_RIGHT, IDS_RIGHT_TIP);
	addTool(IDB_HELP, IDS_HELP_TIP);
	addTool(IDB_OPTIONS, IDS_OPTIONS_TIP);

	m_ToolTips.SetDelayTime(500);
	m_ToolTips.Activate(TRUE);
}

void  CDvdUIDlg::addTool(UINT nBtnID, UINT nTipStrID)
{	
	RECT rect;

	CWnd* pCWnd = GetDlgItem(nBtnID);
	pCWnd->GetClientRect(&rect);
	m_ToolTips.AddTool(pCWnd, nTipStrID, &rect, nBtnID);
}

BOOL CDvdUIDlg::PreTranslateMessage(MSG* pMsg)
{
   /* This hwnd munging is unnecessary.  Also, we handle these keys in
      CDvdApp::PreTranslateMessage because there we can catch messages
      sent to the video window.
   //
   // Intercept WM_KEYUP and WM_KEYDOWN messages sent to our children and
   // if they are for a key we are interested in, process them in the
   // context of this window instead.
   //
   if ((pMsg->hwnd != m_hWnd) &&
       ((pMsg->message == WM_KEYUP) || (pMsg->message == WM_KEYDOWN)) &&
       IsMediaControlKey(pMsg->wParam)
      )
   {
         DbgLog((LOG_TRACE,1,"UP/DOWN MEDIA KEY message for another window - intercepting"));
         pMsg->hwnd = m_hWnd; // Steal the message from our children
   }
   */

   //
   // If this window seees the WM_SYSCOMMAND::SC_SCREENSAVE message, it means
   // the screen saver is trying to kick in.  If this happens during playback, we
   // return TRUE here to prevent the message from reaching the screen saver.
   //
   // We do this even if the message is not indended for this window because
   // we ideally would like to prevent the screen saver  from kicking in during
   // playback whenever possible, even if our messages are routed elsewhere.
   //
   if (//(pMsg->hwnd == m_hWnd) &&
       (pMsg->message == WM_SYSCOMMAND) &&
       (pMsg->wParam == SC_SCREENSAVE) &&
       (m_pDVDNavMgr->DVDCanStop())) {
      DbgLog((LOG_TRACE,2,"DVD player control window: intercepting the screen saver"));
      return TRUE;
   }

	if (pMsg->message == WM_MOUSEMOVE)
			m_ToolTips.RelayEvent(pMsg);

	CWnd* pWnd = GetForegroundWindow();
	if(pWnd == this)
	{
		if (pMsg->message == WM_KEYDOWN && m_pDVDNavMgr->IsMenuOn())
		{		
			switch(pMsg->wParam)
			{
				case VK_UP:
					OnUp();
					return TRUE;
				case VK_DOWN:
					OnDown();
					return TRUE;
				case VK_LEFT:
					OnLeft();
					return TRUE;
				case VK_RIGHT:
					OnRight();
					return TRUE;
				case VK_RETURN:
					short sKeyStatus = GetAsyncKeyState(VK_SHIFT);
					//UINT uiFocusStatus = ((CButton*)GetDlgItem(IDB_MENU))->GetState( ) ;
					//if(sKeyStatus & 0x8000  &&  uiFocusStatus & 0x0008)
					if(sKeyStatus & 0x8000)    //Shift key is pressed
						OnMenu();
					else
						OnEnter();
					return TRUE;
			}
		}
	}
	return CDialog::PreTranslateMessage(pMsg);
}

void CDvdUIDlg::OnOK()
{
   //if (AfxGetApp()->m_nThreadID != GetCurrentThreadId())
   //   MessageBox(TEXT("OnOk is run on a different thread than the app's main thread"), TEXT("Threads"));
	CWnd* pWnd = GetFocus();
	if(GetDlgItem(IDB_PLAY) == pWnd)
		OnPlay();
	if(GetDlgItem(IDB_PAUSE) == pWnd)
		OnPause();
	if(GetDlgItem(IDB_STOP) == pWnd)
		OnStop();
	if(GetDlgItem(IDB_EJECT_DISC) == pWnd)
		OnEjectDisc();
	if(GetDlgItem(IDB_VERY_FAST_REWIND) == pWnd)
		OnVeryFastRewind();		
	if(GetDlgItem(IDB_FAST_REWIND) == pWnd)
		OnFastRewind();
	if(GetDlgItem(IDB_FAST_FORWARD) == pWnd)
		OnFastForward();
	if(GetDlgItem(IDB_VERY_FAST_FORWARD) == pWnd)
		OnVeryFastForward();
	if(GetDlgItem(IDB_FULL_SCREEN) == pWnd)
		OnFullScreen();
	if(GetDlgItem(IDB_AUDIO_VOLUME) == pWnd)
		OnAudioVolume();
	if(GetDlgItem(IDB_HELP) == pWnd)
		OnHelp();
}

BOOL CDvdUIDlg::OpenDVDROM()
{
	if(!m_pDVDNavMgr->DVDOpenDVD_ROM())
	{
		return FALSE;
	}
	return TRUE;
}

void CDvdUIDlg::PainBlackBox()
{
	TEXTMETRIC tm;
	RECT rc;
	CWnd* pWnd = GetDlgItem(IDC_STATIC_TITLE);
	pWnd->GetWindowRect(&rc);
	ScreenToClient(&rc);
	int x1 = rc.left;
	int y1 = rc.top;
	
	pWnd = GetDlgItem(IDC_STATIC_PROGRESS);
	pWnd->GetWindowRect(&rc);
	ScreenToClient(&rc);
	int x2 = rc.right;
	int y2 = rc.bottom;
	
	CDC *pDC = GetDC();	
	pDC->SelectStockObject(BLACK_BRUSH);
	pDC->Rectangle(x1, y1, x2, y2);
		
	CFont* OldFont = pDC->SelectObject(&m_font);
	pDC->SetBkColor(RGB(0,0,0));
	pDC->SetTextColor(RGB(0,255,0));
	pDC->GetTextMetrics(&tm);
		
	pWnd = GetDlgItem(IDC_STATIC_TITLE);
	pWnd->GetWindowRect(&rc);
	ScreenToClient(&rc);
	pDC->DrawText(m_csBox1Title, &rc, DT_WORDBREAK);
	pDC->TextOut(rc.left, rc.top+tm.tmHeight+tm.tmExternalLeading, szTitleNumber);

	pWnd = GetDlgItem(IDC_STATIC_CHAPTER);
	pWnd->GetWindowRect(&rc);
	ScreenToClient(&rc);
	pDC->DrawText(m_csBox2Title, &rc, DT_WORDBREAK);
	pDC->TextOut(rc.left, rc.top+tm.tmHeight+tm.tmExternalLeading, szChapterNumber);

	pWnd = GetDlgItem(IDC_STATIC_PROGRESS);
	pWnd->GetWindowRect(&rc);
	ScreenToClient(&rc);
	pDC->DrawText(m_csBox3Title, &rc, DT_WORDBREAK);
	pDC->TextOut(rc.left, rc.top+tm.tmHeight+tm.tmExternalLeading, szTimePrograss);	

	pDC->SelectObject(&OldFont);
	ReleaseDC(pDC);
}

void CDvdUIDlg::OnClose()
{	
	m_pDVDNavMgr->DVDStop();
	((CDvdplayApp*) AfxGetApp())->OnUIClosed();
}

void CDvdUIDlg::OnPlay()
{
	//if player is started without a disc, need to call SetRoot() via
	//OnOptionsSelectDisc(), no matter disc is currently inside or not.
	if( !((CDvdplayApp*) AfxGetApp())->GetPassedSetRoot() )
	{
		OnOptionsSelectDisc();
		return;
	}

	//if DVD drive is ejected, need to do uneject
	if(m_bEjected)
	{
		OnEjectDisc();
		return;
	}	

	//if no disc is found, pop up open file dialog box
	if(!((CDvdplayApp*) AfxGetApp())->GetDiscFound())
	{
		//need to check again. when manually uneject disc. there is ~10 seconds delay.
		if(!IsDiscInDrive())
		{
			OnOptionsSelectDisc();
			return;
		}
	}

	m_pDVDNavMgr->DVDPlay();
}

void CDvdUIDlg::OnStop()
{
	m_pDVDNavMgr->DVDStop();
}

void CDvdUIDlg::OnPause()
{
	m_pDVDNavMgr->DVDPause();
}

void CDvdUIDlg::OnVeryFastRewind()
{
	m_pDVDNavMgr->DVDVeryFastRewind();
}

void CDvdUIDlg::OnFastRewind()
{
	m_pDVDNavMgr->DVDFastRewind();
}

void CDvdUIDlg::OnFastForward()
{
	m_pDVDNavMgr->DVDFastForward();
}

void CDvdUIDlg::OnVeryFastForward()
{
	m_pDVDNavMgr->DVDVeryFastForward();
}

void CDvdUIDlg::OnStep()
{	
	m_pDVDNavMgr->DVDSlowPlayBack();
}

void CDvdUIDlg::OnFullScreen()
{
	m_pDVDNavMgr->DVDOnShowFullScreen();
}

void CDvdUIDlg::OnAudioVolume()
{
	if(m_pDVDNavMgr->GetBasicAudioState())
	{
		CVolumeAdjust dlg(this);
		dlg.DoModal();
	}
	else
		m_pDVDNavMgr->DVDSysVolControl();
}

void CDvdUIDlg::OnMenu()
{
	m_pDVDNavMgr->DVDMenuVtsm(DVD_MENU_Root);
}

void CDvdUIDlg::OnEnter()
{
	m_pDVDNavMgr->DVDCursorSelect();
	SetFocus();
}

void CDvdUIDlg::OnUp()
{
	m_pDVDNavMgr->DVDCursorUp();
	SetFocus();
}

void CDvdUIDlg::OnDown()
{
	m_pDVDNavMgr->DVDCursorDown();
	SetFocus();
}

void CDvdUIDlg::OnLeft()
{
	m_pDVDNavMgr->DVDCursorLeft();
	SetFocus();
}

void CDvdUIDlg::OnRight()
{
	m_pDVDNavMgr->DVDCursorRight();
	SetFocus();
}

void CDvdUIDlg::OnOptions()
{
	CMenu menu, *OptionSubMenu;
	menu.LoadMenu(IDR_MENU_OPTIONS);
	OptionSubMenu = menu.GetSubMenu(0);
	if(NULL == OptionSubMenu)
		return;

	POINT point;
	GetCursorPos(&point);

	ULONG ulAnglesAvailable=0, ulCurrentAngle;
	m_pDVDNavMgr->DVDGetAngleInfo(&ulAnglesAvailable, &ulCurrentAngle);	

	BOOL bAngleDeleted = FALSE;
	//determine if disable angle or not
	if(ulAnglesAvailable <= 1)
	{		
		OptionSubMenu->DeleteMenu(6, MF_BYPOSITION);
		bAngleDeleted = TRUE;
	}
	else if(ulAnglesAvailable > 1)
	{
		CMenu* AngleSubMenu;
		AngleSubMenu = OptionSubMenu->GetSubMenu(6);
		if(AngleSubMenu)
		{
			for(ULONG i=8; i>ulAnglesAvailable-1; i--)
				AngleSubMenu->DeleteMenu(i, MF_BYPOSITION);
		}
		AngleSubMenu->CheckMenuItem(ulCurrentAngle-1, MF_BYPOSITION | MF_CHECKED);
	}

#ifdef DISPLAY_OPTIONS
	UINT nDisplayMenuIdx = 7;
	if(bAngleDeleted)
		nDisplayMenuIdx = 6;
#endif
	
	//Default turn off SubTitle, Language, Display menu, in case app starts with no disc
	OptionSubMenu->EnableMenuItem(ID_OPTIONS_SUBTITLES, MF_GRAYED | MF_BYCOMMAND);
	OptionSubMenu->EnableMenuItem(ID_OPTIONS_LANGUAGE,  MF_GRAYED | MF_BYCOMMAND);
#ifdef DISPLAY_OPTIONS
	OptionSubMenu->EnableMenuItem(nDisplayMenuIdx, MF_GRAYED | MF_BYPOSITION);
#endif	
   IDvdInfo *pDvdInfo = m_pDVDNavMgr->GetDvdInfo();
	if(pDvdInfo)
	{
		//determine if gray out SubPicture menu item or not.
		ULONG pnStreamAvailable, pnCurrentStream;
		BOOL  bIsDisabled=0;
		HRESULT hr = pDvdInfo->GetCurrentSubpicture(&pnStreamAvailable, &pnCurrentStream, &bIsDisabled);
		if( SUCCEEDED(hr) && (pnStreamAvailable > 0) )
			OptionSubMenu->EnableMenuItem(ID_OPTIONS_SUBTITLES, MF_ENABLED | MF_BYCOMMAND);

		//determine if display Audio Language dialog box or not.		
		hr = pDvdInfo->GetCurrentAudio(&pnStreamAvailable, &pnCurrentStream);
		if( SUCCEEDED(hr) && (pnStreamAvailable > 0) )
			OptionSubMenu->EnableMenuItem(ID_OPTIONS_LANGUAGE,  MF_ENABLED | MF_BYCOMMAND);

#ifdef DISPLAY_OPTIONS
		//determine if disable Pan-Scab, LetterBox, Wide or not
		DVD_VideoATR VideoATR;
		if( SUCCEEDED(pDvdInfo->GetCurrentVideoAttributes(&VideoATR)))
		{
			//Info about VideoATR[0]: (see DVD video spec page V14-42)			
			//bit3-4: "Aspect ratio". 00b: 4:3, 11b: 16:9, others: reserved.
			//when Aspect ratio is 00b(4:3),  Display mode can only be 11b
			//when Aspect ratio is 11b(16:9), Display mode can be 00b, 01b or 10b.
			//bit1-2: "Display mode". value meaning:
			//         00b: Pan-Scan & LetterBox, 01b: Only Pan-Scan,
			//         10b: Only LetterBox,       11b: Not specified.
			BYTE bAspectRatio, bDisplayMode, bTemp;
			bTemp = VideoATR[0] << 6;
			bDisplayMode = bTemp >> 6;

			bTemp = VideoATR[0] << 4;
			bAspectRatio = bTemp >> 6;

			//rule: if disc content is 4:3, gray out "Display" menu
			//      if content is 16:9, gray out menu based on above availablility.			
			if(bAspectRatio == 3)      //Aspect ratio is 11b(16:9)
			{
				//Enable Display menu (all sub menu also enabled)
				OptionSubMenu->EnableMenuItem(nDisplayMenuIdx, MF_ENABLED | MF_BYPOSITION);
				
            CMenu* pDisplaySubMenu;
				pDisplaySubMenu = OptionSubMenu->GetSubMenu(nDisplayMenuIdx);

				//Disable Pan-Scan when display mode does not have Pan-Scan vector
				if(pDisplaySubMenu && bDisplayMode != 0 && bDisplayMode != 1)
				OptionSubMenu->EnableMenuItem(ID_OPTIONS_DISPLAY_PANSCAN, MF_GRAYED | MF_BYCOMMAND);

				//Disable LetterBox when display mode does not have LetterBox vector
				if(pDisplaySubMenu && bDisplayMode != 0 && bDisplayMode != 2)
				OptionSubMenu->EnableMenuItem(ID_OPTIONS_DISPLAY_LETTERBOX, MF_GRAYED | MF_BYCOMMAND);
			}
		} // if SUCCEEDED(GetCurrentVideoAttr)
#endif
	} // if pDVDInfo

	//determine if disable CC control or not
	if( !m_pDVDNavMgr->IsCCEnabled() || (m_pDVDNavMgr->GetCCErrorFlag() & NO_CC_IN_ERROR) )
		OptionSubMenu->DeleteMenu(ID_OPTIONS_CLOSEDCAPTION, MF_BYCOMMAND);
	else if(m_pDVDNavMgr->IsCCOn())
			OptionSubMenu->CheckMenuItem(ID_OPTIONS_CLOSEDCAPTION, MF_CHECKED | MF_BYCOMMAND);

	//If menu is on, disable "Title Menu" menu item
	if(m_pDVDNavMgr->IsMenuOn())
		OptionSubMenu->EnableMenuItem(ID_OPTIONS_TITLE_MENU, MF_GRAYED | MF_BYCOMMAND);

	OptionSubMenu->TrackPopupMenu(TPM_LEFTALIGN, point.x, point.y, this);
}

void CDvdUIDlg::OnEjectDisc()
{
	BeginWaitCursor();

/*
	static TCHAR achVolumeName[20];	
	static DWORD dwVolumeSerialNumber;		
*/
  	static TCHAR szDrive[4];
	DWORD  dwHandle;
	UINT   uErrorMode;

	if(m_bEjected == FALSE)   //do eject
	{		
		getCDDriveLetter(szDrive);
		if(szDrive[0] == 0)
		{
			DVDMessageBox(this->m_hWnd, IDS_EJECT_CANNOT_EJECT);
			return;
		}
	
		DWORD dwErr;
		dwHandle = OpenCdRom(szDrive[0], &dwErr);
		if (dwErr != MMSYSERR_NOERROR)
		{
			TRACE(TEXT("Eject: OpenCdRom() failed\n"));
			return;
		}
/*
		uErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);
		lstrcpy(achVolumeName, _T("X"));
		dwVolumeSerialNumber = -1;
		if(!GetVolumeInformation(szDrive, achVolumeName, sizeof(achVolumeName), &dwVolumeSerialNumber, 0, 0 , 0, 0))
		{
			DWORD dwError = GetLastError();
			TRACE(TEXT("Eject: GetVolumeInformation() failed, dwError=%d, szDrive=%s\n"), dwError, szDrive);
		}

		SetErrorMode(uErrorMode);			
*/
  		OnStop();		
		EjectCdRom(dwHandle);
	}
	else  //do uneject
	{
		DWORD dwErr;
		dwHandle = OpenCdRom(szDrive[0], &dwErr);
		if (dwErr != MMSYSERR_NOERROR)
		{
			TRACE(TEXT("Uneject: OpenCdRom() 1 failed\n"));
			return;
		}		
		UnEjectCdRom(dwHandle);

/*
		//Must close drive then open again, otherwise we get "drive not accessible" error on NT.
		CloseCdRom(dwHandle);	

   	//Allow system to send WM_DEVICECHANGE msg
		Sleep(8000);

		//Open dvd drive again. This is the very tricky part. It seems not necessary, but we must add CloseCdRom
		//CloseCdRom after UnEjectCdRom and OpenCdRom here. otherwise, we get "drive not accessible" error on NT.
		dwHandle = OpenCdRom(szDrive[0], &dwErr);
		if (dwErr != MMSYSERR_NOERROR)
		{
			((CDvdplayApp*) AfxGetApp())->SetDiscFound(FALSE);
			SetFocus();
			return;
		}

		DWORD  dwVolSerNum=0;
		TCHAR  achVolName[20]={'\0'};
		int    iCnt = 0;
		uErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);	
		while(!GetVolumeInformation(szDrive, achVolName, sizeof(achVolName),&dwVolSerNum, 0, 0 , 0, 0))			
		{
			Sleep(1000);
			iCnt++;
			if(iCnt == 20)   //to avoid infinit loop
				break;				
		}

		SetErrorMode(uErrorMode);

		//disc not changed
		if(!lstrcmp(achVolName, achVolumeName) && dwVolumeSerialNumber == dwVolSerNum &&
			((CDvdplayApp*) AfxGetApp())->GetPassedSetRoot())			
		{
			OnPlay();			
		}
		else  //disc is changed or GetVolumeInformation() failed
		{				
			wTCHAR_t wc[MAX_PATH];
			TCHAR szDriveFilePath[MAX_PATH];
			lstrcpy(szDriveFilePath, szDrive);
			lstrcat(szDriveFilePath, _T("\\Video_ts\\Video_ts.ifo"));

#ifdef _UNICODE
			lstrcpy(wc, szDriveFilePath);
#else				
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPCTSTR)szDriveFilePath, -1, wc, MAX_PATH);
#endif

			if(m_pDVDNavMgr->DVDOpenFile(wc))
				OnPlay();
		}
*/
	}
	CloseCdRom(dwHandle);	
	EndWaitCursor();
	SetFocus();
}

// Eject Functions
void CDvdUIDlg::getCDDriveLetter(TCHAR* lpDrive)
{
	CHAR szTempA[MAX_PATH];
	TCHAR szTemp[MAX_PATH];
	ULONG ulActualSize;
	TCHAR *ptr;

	lpDrive[0]=lpDrive[3]=0;
	if(m_pDVDNavMgr->DVDGetRoot(szTempA, MAX_PATH, &ulActualSize)) //get player's root dir
	{	
#ifdef UNICODE
        MultiByteToWideChar(CP_ACP, 0, szTempA, 0, szTemp, MAX_PATH);
#else
        lstrcpy(szTemp, szTempA);
#endif
		lstrcpyn(lpDrive, szTemp, 3);
		if(GetDriveType(&lpDrive[0]) == DRIVE_CDROM)  //possibly root=c: or drive in hard disc
			return;
	}

    DWORD totChrs = GetLogicalDriveStrings(MAX_PATH, szTemp); //get all drives
	ptr = szTemp;
	for(DWORD i = 0; i < totChrs; i+=4)      //look at these drives one by one
	{
		if(GetDriveType(ptr) == DRIVE_CDROM) //look only CD-ROM and see if it has a disc
		{
			TCHAR achDVDFilePath1[MAX_PATH], achDVDFilePath2[MAX_PATH];
			lstrcpyn(achDVDFilePath1, ptr, 4);
			lstrcpyn(achDVDFilePath2, ptr, 4);
			lstrcat(achDVDFilePath1, _T("Video_ts\\Video_ts.ifo"));
			lstrcat(achDVDFilePath2, _T("Video_ts\\Vts_01_0.ifo"));

			if( ((CDvdplayApp*) AfxGetApp())->DoesFileExist(achDVDFilePath1) &&
				((CDvdplayApp*) AfxGetApp())->DoesFileExist(achDVDFilePath2) )							
			{
				lstrcpyn(lpDrive, ptr, 3);
				return;   //Return the first found drive which has a valid DVD disc
			}
		}
		ptr += 4;
	}
}

DWORD CDvdUIDlg::OpenCdRom(TCHAR chDrive, LPDWORD lpdwErrCode)
{
	MCI_OPEN_PARMS  mciOpen;
	TCHAR           szElementName[4];
	TCHAR           szAliasName[32];
	DWORD           dwFlags;
	DWORD           dwAliasCount = GetCurrentTime();
	DWORD           dwRet;

    ZeroMemory( &mciOpen, sizeof(mciOpen) );

    mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    wsprintf( szElementName, TEXT("%c:"), chDrive );
    wsprintf( szAliasName, TEXT("SJE%lu:"), dwAliasCount );
    mciOpen.lpstrAlias = szAliasName;

    mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    mciOpen.lpstrElementName = szElementName;
    dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_ALIAS |
	      MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;

	// send mci command
    dwRet = mciSendCommand(0, MCI_OPEN, dwFlags, reinterpret_cast<DWORD_PTR>(&mciOpen));

    if ( dwRet != MMSYSERR_NOERROR )
		mciOpen.wDeviceID = 0;

    if (lpdwErrCode != NULL)
		*lpdwErrCode = dwRet;

    return mciOpen.wDeviceID;
}

void CDvdUIDlg::CloseCdRom(DWORD DevHandle)
{
	MCIERROR theMciErr = mciSendCommand( DevHandle, MCI_CLOSE, 0L, 0L );
}

void CDvdUIDlg::EjectCdRom(DWORD DevHandle)
{
	MCIERROR theMciErr = mciSendCommand( DevHandle, MCI_SET, MCI_SET_DOOR_OPEN, 0L );
}

void CDvdUIDlg::UnEjectCdRom(DWORD DevHandle)
{
	MCIERROR theMciErr = mciSendCommand( DevHandle, MCI_SET, MCI_SET_DOOR_CLOSED, 0L );
}

void CDvdUIDlg::OnHelp()
{
	TCHAR szHelpPath[MAX_PATH];
	GetWindowsDirectory(szHelpPath, MAX_PATH);
	lstrcat(szHelpPath, _T("\\help\\"));
	lstrcat(szHelpPath, ((CDvdplayApp*) AfxGetApp())->m_pszProfileName);
	lstrcat(szHelpPath, _T(".chm"));

	HtmlHelp(m_hWnd, szHelpPath, HH_DISPLAY_TOPIC, 0);
}

void CDvdUIDlg::OnContextMenu(CWnd* pWnd, CPoint point)
{
	RECT rcClient, rcTitle, rcChapter, rcMenu;	
	RECT rcFScreen, rcAudioVol, rcHelp, rcOptions;
	CMenu menu;	
	
	pWnd = GetDlgItem(IDC_STATIC_TITLE);
	pWnd->GetWindowRect(&rcTitle);
	pWnd = GetDlgItem(IDC_STATIC_CHAPTER);
	pWnd->GetWindowRect(&rcChapter);	

	pWnd = GetDlgItem(IDB_FULL_SCREEN);
	pWnd->GetWindowRect(&rcFScreen);
	pWnd = GetDlgItem(IDB_AUDIO_VOLUME);
	pWnd->GetWindowRect(&rcAudioVol);
		
	pWnd = GetDlgItem(IDB_HELP);
	pWnd->GetWindowRect(&rcHelp);
	pWnd = GetDlgItem(IDB_OPTIONS);
	pWnd->GetWindowRect(&rcOptions);

	pWnd = GetDlgItem(IDB_MENU);
	pWnd->GetWindowRect(&rcMenu);

	GetClientRect(&rcClient);	
	ClientToScreen(&rcClient);
	if(isInsidRect(rcClient, point))
	{				
		if(isInsidRect(rcTitle, point) || isInsidRect(rcChapter, point))
		{
			menu.LoadMenu(IDR_MENU_TITLE_CHAPTER);					
			menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
		}				
		else if(isInsideOperationBtns(point))
		{
			menu.LoadMenu(IDR_MENU_OPERATIONS);
			if( m_pDVDNavMgr->IsMenuOn() )
			{
				CString csResume;
				csResume.LoadString(IDS_RESUME);
				menu.GetSubMenu(0)->ModifyMenu(ID_OPERATION_MENU, MF_BYCOMMAND | MF_STRING, ID_OPERATION_MENU, csResume);
			}
			menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
		}
		else if(isInsidRect(rcFScreen, point))
		{
			OnFullScreen();
		}
		else if(isInsidRect(rcAudioVol, point))
		{
			OnAudioVolume();
		}
		else if(isInsideArrowBtns(point))
		{
			menu.LoadMenu(IDR_MENU_ARROWS);					
			menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
		}
		else if(isInsidRect(rcMenu, point) || isInsidRect(rcOptions, point))
		{
			/* do nothing */
		}
		else if(isInsidRect(rcHelp, point))
		{
			/*((CDvdplayApp*) AfxGetApp())->OnAppAbout(); */
		}
		else
		{
			/*
			menu.LoadMenu(IDR_MENU_DOCK);					
			menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
			*/
		}
	}
	else
	{
		/*
		CMenu* menu = GetSystemMenu(FALSE);
		menu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
		DefWindowProc(WM_CONTEXTMENU, 0, 0);
		*/
	}
}

BOOL CDvdUIDlg::isInsideOperationBtns(CPoint point)
{
	RECT rcPrograss, rcPlay, rcPause, rcStop, rcEject,
		 rcVFRew, rcFRew, rcFForward, rcVForward, rcStep;
	CWnd* pWnd;

	pWnd = GetDlgItem(IDC_STATIC_PROGRESS);
	pWnd->GetWindowRect(&rcPrograss);
	pWnd = GetDlgItem(IDB_PLAY);
	pWnd->GetWindowRect(&rcPlay);
	pWnd = GetDlgItem(IDB_PAUSE);
	pWnd->GetWindowRect(&rcPause);
	pWnd = GetDlgItem(IDB_STOP);
	pWnd->GetWindowRect(&rcStop);
	pWnd = GetDlgItem(IDB_EJECT_DISC);
	pWnd->GetWindowRect(&rcEject);
	pWnd = GetDlgItem(IDB_VERY_FAST_REWIND);
	pWnd->GetWindowRect(&rcVFRew);
	pWnd = GetDlgItem(IDB_FAST_REWIND);
	pWnd->GetWindowRect(&rcFRew);
	pWnd = GetDlgItem(IDB_FAST_FORWARD);
	pWnd->GetWindowRect(&rcFForward);
	pWnd = GetDlgItem(IDB_VERY_FAST_FORWARD);
	pWnd->GetWindowRect(&rcVForward);
	pWnd = GetDlgItem(IDB_STEP);
	pWnd->GetWindowRect(&rcStep);

	if( isInsidRect(rcPrograss, point) || isInsidRect(rcPlay, point) ||
		isInsidRect(rcPause, point)    || isInsidRect(rcStop, point) ||
		isInsidRect(rcEject, point)    || isInsidRect(rcVFRew, point) ||
		isInsidRect(rcFRew, point)     || isInsidRect(rcFForward, point) ||
		isInsidRect(rcVForward, point) || isInsidRect(rcStep, point) )
		return TRUE;
	return FALSE;
}

BOOL CDvdUIDlg::isInsideArrowBtns(CPoint point)
{
	RECT rcEnter, rcUp, rcDown, rcLeft, rcRight;
	CWnd* pWnd;
	
	pWnd = GetDlgItem(IDB_ENTER);
	pWnd->GetWindowRect(&rcEnter);
	pWnd = GetDlgItem(IDB_UP);
	pWnd->GetWindowRect(&rcUp);
	pWnd = GetDlgItem(IDB_DOWN);
	pWnd->GetWindowRect(&rcDown);
	pWnd = GetDlgItem(IDB_LEFT);
	pWnd->GetWindowRect(&rcLeft);
	pWnd = GetDlgItem(IDB_RIGHT);
	pWnd->GetWindowRect(&rcRight);

	if( isInsidRect(rcEnter, point) ||
		isInsidRect(rcUp, point)    || isInsidRect(rcDown, point) ||
		isInsidRect(rcLeft, point)  || isInsidRect(rcRight, point) )
		return TRUE;
	return FALSE;
}

BOOL CDvdUIDlg::isInsidRect(RECT rc, CPoint point)
{
	if(point.x >= rc.left && point.x <= rc.right &&
	   point.y >= rc.top  && point.y <= rc.bottom)
	   return TRUE;
	return FALSE;
}

void CDvdUIDlg::OnNextChapter()
{
	m_pDVDNavMgr->DVDNextProgramSearch();
}

void CDvdUIDlg::OnPreviosChapter()
{
	m_pDVDNavMgr->DVDPreviousProgramSearch();
}

void CDvdUIDlg::OnOptionsSubtitles()
{
	CSubTitle dlg(this);
	dlg.DoModal();	
}

void CDvdUIDlg::OnOptionsLanguage()
{
	CAudioLanguage dlg(this);
	dlg.DoModal();
}

#ifdef DISPLAY_OPTIONS
void CDvdUIDlg::OnOptionsDisplayPanscan()
{
	m_pDVDNavMgr->DVDVideoPanscan();	
}

void CDvdUIDlg::OnOptionsDisplayLetterbox()
{
	m_pDVDNavMgr->DVDVideoLetterbox();
}

void CDvdUIDlg::OnOptionsDisplayWide()
{
	m_pDVDNavMgr->DVDVideo169();
}
#endif

void CDvdUIDlg::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	PainBlackBox();
	
	CDialog::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

void CDvdUIDlg::OnOptionsSetratings()
{
	CSetRating dlg(this);
	dlg.DoModal();
}

void CDvdUIDlg::OnCancel()
{
	OnClose();
}

void CDvdUIDlg::OnOperationPlayspeedNormalspeed()
{
	m_pDVDNavMgr->DVDChangePlaySpeed(1.0);
}

void CDvdUIDlg::OnOperationPlayspeedDoublespeed()
{
	m_pDVDNavMgr->DVDChangePlaySpeed(2.0);
}

void CDvdUIDlg::OnOperationPlayspeedHalfspeed()
{
	m_pDVDNavMgr->DVDChangePlaySpeed(0.5);
}

void CDvdUIDlg::OnOptionsSelectDisc()
{
	COpenFile CFileDlg(TRUE,  NULL, NULL,
		      OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, NULL, this);
	TCHAR   szDrive[4];
	CString csTitle;

	getCDDriveLetter(szDrive);

	if(!IsDiscInDrive())
		szDrive[0] = 0;

	CFileDlg.m_ofn.lpstrInitialDir = szDrive;
	csTitle.LoadString(IDS_FILE_OPEN_DLGBOX_TITLE);
	CFileDlg.m_ofn.lpstrTitle = csTitle;

	if(CFileDlg.DoModal() == IDOK)
	{
		BeginWaitCursor();
		wchar_t achwFilePath[MAX_PATH];
		CString csFilePath = CFileDlg.GetPathName();
#ifdef _UNICODE
		lstrcpy(achwFilePath, csFilePath);
#else
		MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
			   (LPCTSTR)csFilePath, -1, achwFilePath, MAX_PATH);
#endif			
		if(m_pDVDNavMgr->DVDOpenFile(achwFilePath))
			OnPlay();
	}
	EndWaitCursor();	
}

void CDvdUIDlg::OnSearchTitle()
{
	CSearchTitle dlg(this);
	dlg.DoModal();
}

void CDvdUIDlg::OnSearchChapter()
{
	CSearchChapter dlg(this);
	dlg.DoModal();
}

void CDvdUIDlg::OnDomainChange(long lEvent)
{
	CString csCaption;
	IDvdInfo* pInfo = m_pDVDNavMgr->GetDvdInfo();
	switch (lEvent)
	{
		case DVD_DOMAIN_FirstPlay:         //lEvent=1
			break;
		case DVD_DOMAIN_VideoManagerMenu:  //lEvent=2			
		case DVD_DOMAIN_VideoTitleSetMenu: //lEvent=3		
			if(!m_pDVDNavMgr->IsVideoWindowMaximized())
				m_pVideoWindow->AlignWindowsFrame();
			break;
		case DVD_DOMAIN_Title:             //lEvent=4
			//original code is moved to Videowin.cpp
			break;
		case DVD_DOMAIN_Stop:              //lEvent=5
			break;
	}
}

BOOL CDvdUIDlg::OnAngleChange(UINT nID)
{
	switch(nID)
	{
		case ID_OPTIONS_CAMERAANGLES_ANGLE1:
			m_pDVDNavMgr->DVDAngleChange(1);
			break;
		case ID_OPTIONS_CAMERAANGLES_ANGLE2:
			m_pDVDNavMgr->DVDAngleChange(2);
			break;
		case ID_OPTIONS_CAMERAANGLES_ANGLE3:
			m_pDVDNavMgr->DVDAngleChange(3);
			break;
		case ID_OPTIONS_CAMERAANGLES_ANGLE4:
			m_pDVDNavMgr->DVDAngleChange(4);
			break;
		case ID_OPTIONS_CAMERAANGLES_ANGLE5:
			m_pDVDNavMgr->DVDAngleChange(5);
			break;
		case ID_OPTIONS_CAMERAANGLES_ANGLE6:
			m_pDVDNavMgr->DVDAngleChange(6);
			break;
		case ID_OPTIONS_CAMERAANGLES_ANGLE7:
			m_pDVDNavMgr->DVDAngleChange(7);
			break;
		case ID_OPTIONS_CAMERAANGLES_ANGLE8:
			m_pDVDNavMgr->DVDAngleChange(8);
			break;
		case ID_OPTIONS_CAMERAANGLES_ANGLE9:
			m_pDVDNavMgr->DVDAngleChange(9);
			break;
	}

	return TRUE;
}

void CDvdUIDlg::OnOptionsClosedcaption()
{	
	if( m_pDVDNavMgr->GetCCErrorFlag() & CC_OUT_ERROR )
	{
		CString csErrMsg, csTmp;
		csErrMsg.LoadString(IDS_CC_OUT_ERROR);
		csTmp.LoadString(IDS_WANT_CONTINUE);
		csErrMsg += csTmp;
		if( IDNO == DVDMessageBox(this->m_hWnd, csErrMsg, 0,
			MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2) )
			return;
	}
	m_pDVDNavMgr->DVDCCControl();
}

void CDvdUIDlg::OnOptionsShowLogon()
{
	CAdminLogin dlg(this);
	dlg.m_uiCalledBy = BY_SET_SHOWLOGON;
	dlg.DoModal();	
}

void  CDvdUIDlg::EnableEnterArrowButtons(BOOL bEnable)
{
	GetDlgItem(IDB_UP)->EnableWindow(bEnable);
	GetDlgItem(IDB_DOWN)->EnableWindow(bEnable);
	GetDlgItem(IDB_LEFT)->EnableWindow(bEnable);
	GetDlgItem(IDB_RIGHT)->EnableWindow(bEnable);
	GetDlgItem(IDB_ENTER)->EnableWindow(bEnable);
}

BOOL CDvdUIDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
        AfxGetApp()->WinHelp( pHelpInfo->dwContextId, HELP_CONTEXTPOPUP);
    return TRUE;	
}

void CDvdUIDlg::OnContextHelp()
{
	SendMessage(WM_SYSCOMMAND, SC_CONTEXTHELP);	
}

//Handle case when user eject disc manually.
BOOL CDvdUIDlg::OnDeviceChange( UINT nEventType, DWORD_PTR dwData )
{
	PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR) dwData;	

	if(nEventType == DBT_DEVICEREMOVECOMPLETE || nEventType == DBT_DEVICEARRIVAL || nEventType == DBT_DEVICEQUERYREMOVE)
	{
		if(lpdb->dbch_devicetype == DBT_DEVTYP_VOLUME)
		{
			PDEV_BROADCAST_VOLUME lpdbv = (PDEV_BROADCAST_VOLUME)lpdb;
			//Handle only CD/DVD drive event, ignore all other devices
         //This flag is never set in the query removal message
			if (lpdbv->dbcv_flags & DBTF_MEDIA || nEventType == DBT_DEVICEQUERYREMOVE)
			{
				TCHAR szDrive1, szDrive2[4];
				szDrive1 = GetFirstDriveFromMask(lpdbv ->dbcv_unitmask);			
				getCDDriveLetter(szDrive2);
				CharUpper(szDrive2);
				//Care only currently playing DVD drive, ignore all other DVD drives.
				if(szDrive1 == szDrive2[0] || szDrive2[0] == 0)
				{
					//A CD-ROM was removed from a drive.
					if(nEventType == DBT_DEVICEREMOVECOMPLETE)
					{
						MessageBeep(0xFFFFFFFF);
						((CDvdplayApp*) AfxGetApp())->SetDiscFound(FALSE);
						TRACE(TEXT("Drive %c: was removed\n"), szDrive1);
                  m_bEjected = TRUE;
					}
					//A CD-ROM was inserted into a drive.
					if(nEventType == DBT_DEVICEARRIVAL)
					{
						MessageBeep(0xFFFFFFFF);
						((CDvdplayApp*) AfxGetApp())->SetDiscFound(TRUE);
						TRACE(TEXT("Drive %c: arrived\n"), szDrive1);
                  m_bEjected = FALSE;
                  m_pDVDNavMgr->DVDPlay();
					}
					if (nEventType == DBT_DEVICEQUERYREMOVE)
					{
						MessageBeep(0xFFFFFFFF);
                  if (m_pDVDNavMgr->DVDCanChangeSpeed()) {
                     m_pDVDNavMgr->DVDStop();
                  }
						TRACE(TEXT("Drive %c: about to be removed\n"), szDrive1);
					}
				}
			}
		}
	}

	return TRUE;
}

/* We don't wait for WM_APPCOMMAND, we handle WM_KEYDOWNs instead
LRESULT CDvdUIDlg::OnAppCommand(WPARAM wParam, LPARAM lParam) { */
BOOL CDvdUIDlg::OnMediaKey(WPARAM wParam, LPARAM lParam) {
   CDVDNavMgr* pNav = ((CDvdplayApp*)(AfxGetApp()))->GetDVDNavigatorMgr();

   switch (MediaKey(wParam)) { // see mediakey.cpp
      case MediaKey_NextTrack:
         OnNextChapter();
         return TRUE;
      case MediaKey_PrevTrack:
         OnPreviosChapter();
         return TRUE;
      case MediaKey_Stop:
         OnStop();
         return TRUE;
      case MediaKey_Play:
         //
         // Spec ambiguity: in the "scanning" state (ff/rw), both play and pause
         // are legal.  Play takes precedence.
         //
         if (pNav->DVDCanPlay())
            OnPlay();
         else if (pNav->DVDCanPause())
            OnPause();
         return TRUE;
      default:
         DbgLog((LOG_TRACE,1,"unknown Media key"));
         return FALSE;
   }
}

//
// I know of three ways to prevent the screen saver from kicking in during playback.
//
// (1) Dsable the screen saver when playback starts and reenable it back when the
//     movie is over/stopped.  Problems: this introduces the danger of leaving the
//     screen saver disabled should the player die while the screen is disabled.
//     Also, there is a possibility of a race condition with another app and/or the
//     screen saver settings dialog while we mess with the settings.
//
// (2) Fail WM_SYSCOMMAND::SC_SCREENSAVE.  Much better than (1), but with its own
//     problems  First, the screen saver generates this message every second after
//     it has decided to kick in, hence CPU wastefulness.  Second, it only works if
//     one of the player's windows has focus => customer is less delighted.
//
// (3) Set up a timer to send us a notification often enough that if we do something
//     to reset the screen saver's timeout timer every time we get the timer event,
//     the screen saver's timer will never reach the set off condition.  One way to
//     reset the screen saver turns out to be to Get and then Set to the same value
//     the screen saver's timeout !  I guess when we do this the screen saver logic
//     figures that the user is messing with the screen saver properties, so it can't
//     hurt to reset the timeout.
//
// We choose 3 as the default method, and if that fails we fall back on #2 (immediately
// following this comment).
//
//
// Implementation issue: somehow the Video Window's messages get routed to the DShow
// IVideoWindow window instead of the app's own CVideoWindow window, so we have to
// intercept this message during PreTranslateMessage at least for the video window.
// For the main (control) app window OnSysCommand works fine, but for the sake of
// uniformity we interpect the message inside PreTranslateMessage for both.
//
#if 0
BOOL CDvdUIDlg::OnSysCommand( UINT nEventType, LPARAM lParam ) {
   if ((nEventType == SC_SCREENSAVE) && (m_pDVDNavMgr->DVDCanStop())) {
      DbgLog((LOG_TRACE,2,"DVD player control window: screen saver is trying to kick in"));
      return FALSE;
   }
   else {
      CDialog::OnSysCommand(nEventType, lParam);
      return TRUE;
   }
}
#endif

//
// Timer proc - used to keep the screen saver distracted.
// The timer is set up and killed in navmgr.cpp.
//
void CDvdUIDlg::OnTimer(UINT_PTR nIDEvent) {
   ASSERT(nIDEvent == TIMER_ID);
   DbgLog((LOG_TRACE,3,"dvdplay UI window: timer event"));
   //
   // Do something to keep the screen saver from coming alive
   //
   //PostMessage(WM_CHAR,0,0); // didn't work
   //
   // Query the screen saver timeout value and set said value
   // to the value we get.  This should have no real effect,
   // so I can't think of any possible side effects even if
   // this crashes half way through, etc.
   //
   unsigned int TimeOut;
   if (SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT, 0, &TimeOut, 0) == 0)
      DbgLog((LOG_ERROR,2,"Cannot get screen saver timeout"));
   else {
      if (SystemParametersInfo(SPI_SETSCREENSAVETIMEOUT, TimeOut, 0, 0) == 0)
         DbgLog((LOG_ERROR,2,"Cannot set screen saver timeout"));
      else
         DbgLog((LOG_TRACE,2,"Successfully reset screen saver timeout"));
   }
}



TCHAR CDvdUIDlg::GetFirstDriveFromMask(ULONG unitmask)
{
	int i;

	for (i = 0; i < 26; ++i)
	{
		if (unitmask & 0x1)
			break;
		unitmask = unitmask >> 1;
	}
	TCHAR C = i + 'A';

	return C;
}

BOOL CDvdUIDlg::IsDiscInDrive()
{
	TCHAR szDrive[4];
	getCDDriveLetter(szDrive);

	if(szDrive[0] == 0)
	{
		((CDvdplayApp*) AfxGetApp())->SetDiscFound(FALSE);
		return FALSE;
	}

	TCHAR achDVDFilePath1[MAX_PATH], achDVDFilePath2[MAX_PATH];
	lstrcpyn(achDVDFilePath1, szDrive, 4);
	lstrcpyn(achDVDFilePath2, szDrive, 4);
	lstrcat(achDVDFilePath1, _T("Video_ts\\Video_ts.ifo"));
	lstrcat(achDVDFilePath2, _T("Video_ts\\Vts_01_0.ifo"));

	if( ((CDvdplayApp*) AfxGetApp())->DoesFileExist(achDVDFilePath1) &&
		((CDvdplayApp*) AfxGetApp())->DoesFileExist(achDVDFilePath2) )
	{
		((CDvdplayApp*) AfxGetApp())->SetDiscFound(TRUE);
		return TRUE;
	}
	else
	{
		((CDvdplayApp*) AfxGetApp())->SetDiscFound(FALSE);
		return FALSE;
	}
}

BOOL CDvdUIDlg::OnPowerBroadcast(DWORD dwPowerEvent, DWORD dwData)
{
	if(dwPowerEvent == PBT_APMQUERYSUSPEND)
		OnStop();	
	return TRUE;
}

void CDvdUIDlg::OnOptionsTitleMenu()
{
	m_pDVDNavMgr->DVDMenuVtsm(DVD_MENU_Title);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\dvdplay.h ===
// dvdplay.h : main header file for the DVDPLAY application
//

#if !defined(AFX_DVDPLAY_H__AF1C3AA7_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_)
#define AFX_DVDPLAY_H__AF1C3AA7_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#if DEBUG
#include "test.h"
#endif

class CDVDNavMgr;
class CDvdUIDlg;

int DVDMessageBox(HWND hWnd, LPCTSTR lpszText, LPCTSTR lpszCaption=NULL, UINT nType=MB_OK | MB_ICONEXCLAMATION);
int DVDMessageBox(HWND hWnd, UINT nID, LPCTSTR lpszCaption=NULL, UINT nType=MB_OK | MB_ICONEXCLAMATION);

#define MAX_VALUE_NAME  128
/////////////////////////////////////////////////////////////////////////////
// CDvdplayApp:
// See dvdplay.cpp for the implementation of this class
//

class CDvdplayApp : public CWinApp
{
public:
	CDvdplayApp();

	BOOL CreateNavigatorMgr();
	void DestroyNavigatorMgr();
	BOOL DoesFileExist(LPTSTR lpFileName);
	void OnUIClosed();
    CDVDNavMgr* GetDVDNavigatorMgr()   { return m_pDVDNavMgr; };
	CWnd* GetUIWndPtr()                { return (CWnd*) m_pUIDlg; };	
	void SetProfileStatus(BOOL bExist) { m_bProfileExist = bExist; };
	BOOL GetProfileStatus()            { return m_bProfileExist; };
	LPTSTR GetProfileName()            { return m_szProfile; };
	void SetShowLogonBox(BOOL bShow)   { m_bShowLogonBox = bShow; };
	BOOL GetShowLogonBox()             { return m_bShowLogonBox; };
	void WriteVideoWndPos();
	BOOL GetVideoWndPos(long *lLeft, long *lTop, long *lWidth, long *lHeight);
	void WriteUIWndPos();
	BOOL GetUIWndPos(long *lShowCmd, long *lLeft, long *lTop);
	void SetParentCtrlLevel(UINT nLevel){ m_nParentctrlLevel = nLevel; };
	UINT GetParentCtrlLevel()          { return m_nParentctrlLevel; };
	BOOL GetMuteState()                { return m_bMuteChecked; };
	void SetMuteState(BOOL bChecked)   { m_bMuteChecked = bChecked; };
	void SetDiscFound(BOOL bFound)     { m_bDiscFound = bFound; };
	BOOL GetDiscFound()                { return m_bDiscFound; };
	void SetPassedSetRoot(BOOL bPassed){ m_bPassedSetRoot = bPassed; };
	BOOL GetPassedSetRoot()            { return m_bPassedSetRoot; };
	LPCTSTR GetCurrentUser()           { return (LPCTSTR) m_csCurrentUser; };
	void SetCurrentUser(LPCTSTR lpUser){ m_csCurrentUser = lpUser; };
	void SetDiscRegionDiff(BOOL bDiff) { m_bDiscRegionDiff = bDiff; };

#if DEBUG
     static BOOL t_Ctrl (CDvdplayApp*);
     TEST_CASE_LIST* t_ReadScriptFile (TEST_CASE_LIST*, LPCTSTR);
     LPTSTR     cFileName;
#endif

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDvdplayApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	COleTemplateServer m_server;
		// Server object for document creation

	//{{AFX_MSG(CDvdplayApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void ShowPersistentUIWnd();
	BOOL QueryRegistryOEMFlag();
   BOOL PreTranslateMessage(MSG*);
	CDVDNavMgr* m_pDVDNavMgr;
	CDvdUIDlg*  m_pUIDlg;
	BOOL        m_bProfileExist;
	TCHAR       m_szProfile[MAX_PATH];
	BOOL        m_bShowLogonBox;
	UINT        m_nParentctrlLevel;
	BOOL        m_bMuteChecked;
	BOOL        m_bDiscFound;
	BOOL        m_bPassedSetRoot;
	CString     m_csCurrentUser;
	BOOL        m_bDiscRegionDiff;
};

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DVDPLAY_H__AF1C3AA7_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\mediakey.h ===
#ifndef __MEDIAKEY_H__
#define __MEDIAKEY_H__

enum MediaKeys {
   MediaKey_NextTrack,
   MediaKey_PrevTrack,
   MediaKey_Stop,
   MediaKey_Play,
   MediaKey_Other
};

BOOL IsAppcommandMessage(UINT message);
BOOL IsAppcommandCode(int nCode);
enum MediaKeys MediaKey(WPARAM wParam);
BOOL IsMediaControlKey (WPARAM wParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\dvdplay.cpp ===
// dvdplay.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "dvdplay.h"
#include "dvduidlg.h"
#include "navmgr.h"
#include "parenctl.h"
#include "videowin.h"
#include "mediakey.h"

#if DEBUG
#include "test.h"
#endif


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDvdplayApp

BEGIN_MESSAGE_MAP(CDvdplayApp, CWinApp)
	//{{AFX_MSG_MAP(CDvdplayApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDvdplayApp construction

BOOL CDvdplayApp::PreTranslateMessage(MSG *pMsg) {
/* MSG::hwnd munging - we don't need this anymore, we process WM_KEYDOWN
   messages directly instead.
   if (((pMsg->message == WM_KEYUP) || (pMsg->message == WM_KEYDOWN)) &&
       IsMediaControlKey(pMsg->wParam)
      )
   {
         //
         // Intercept all WM_KEYUP/WM_KEYDOWN
         // messages corresponding to the media control keys and force them to
         // be routed to the main UI window, so that that window's DefWindowProc
         // can combine the up/down messages into a WM_APPCOMMAND and let the main
         // UI window process the keystrokes.  We do this here to catch ALL such
         // messages sent to the app, even those sent to the video window.  This
         // way we only need to handle the WM_APPCOMMAND message in one window's
         // proc (the UI window's).
         //
         DbgLog((LOG_TRACE,1,"DVD App: intercepting media key"));
         pMsg->hwnd = m_pUIDlg->m_hWnd; // give it to the UI window
   }
*/
   if ((pMsg->message == WM_KEYDOWN) && IsMediaControlKey(pMsg->wParam))
       m_pUIDlg->OnMediaKey(pMsg->wParam, pMsg->lParam);

   return CWinApp::PreTranslateMessage(pMsg); // process in a normal way
}

CDvdplayApp::CDvdplayApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance	
	m_pDVDNavMgr       = NULL;
	m_pUIDlg           = NULL;
	m_bProfileExist    = FALSE;
	m_bShowLogonBox    = FALSE;
	m_nParentctrlLevel = LEVEL_ADULT;
	m_bMuteChecked     = FALSE;
	m_bDiscFound       = TRUE;
	m_bPassedSetRoot   = TRUE;
	m_csCurrentUser    = _T("");
	m_bDiscRegionDiff  = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDvdplayApp object

CDvdplayApp theApp;

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.

// {1952BBCE-D806-11D0-9BFC-00AA00605CD5}
static const CLSID clsid =
{ 0x1952bbce, 0xd806, 0x11d0, { 0x9b, 0xfc, 0x0, 0xaa, 0x0, 0x60, 0x5c, 0xd5 } };

/////////////////////////////////////////////////////////////////////////////
// CDvdplayApp initialization

BOOL CDvdplayApp::InitInstance()
{
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		DVDMessageBox(NULL, IDP_OLE_INIT_FAILED);
		return FALSE;
		m_pszProfileName = NULL;
	}

	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

   DbgInitialise(m_hInstance);

	// Change the registry key under which our settings are stored.
	// You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	if(!QueryRegistryOEMFlag())
	{
		DVDMessageBox(NULL, IDS_NOT_MEET_MS_LOGO);
		return FALSE;
	}

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.
/*
	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CDvdplayDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CDvdplayView));
	AddDocTemplate(pDocTemplate);

	// Connect the COleTemplateServer to the document template.
	//  The COleTemplateServer creates new documents on behalf
	//  of requesting OLE containers by using information
	//  specified in the document template.
	m_server.ConnectTemplate(clsid, pDocTemplate, TRUE);
		// Note: SDI applications register server objects only if /Embedding
		//   or /Automation is present on the command line.
*/
	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Check to see if launched as OLE server
	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
	{
		// Register all OLE server (factories) as running.  This enables the
		//  OLE libraries to create objects from other applications.
		COleTemplateServer::RegisterAll();

		// Application was run with /Embedding or /Automation.  Don't show the
		//  main window in this case.
		return TRUE;
	}

	// When a server application is launched stand-alone, it is a good idea
	//  to update the system registry in case it has been damaged.
//	m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
	COleObjectFactory::UpdateRegistryAll();

	// Dispatch commands specified on the command line
//	if (!ProcessShellCommand(cmdInfo))
//		return FALSE;

	// The one and only window has been initialized, so show and update it.
//	m_pMainWnd->ShowWindow(SW_SHOW);
//	m_pMainWnd->UpdateWindow();
///////////////////////////////////////////////////////////

	//Do not allow second instance of DVD player to run
	CString csSection, csEntry, csClassName, csTitle;
	csSection.LoadString(IDS_UI_WINDOW_POS);
	csEntry.LoadString(IDS_UIWND_CLASSNAME);
	csClassName = GetProfileString((LPCTSTR)csSection, (LPCTSTR)csEntry, NULL);
	csTitle.LoadString(IDS_MSGBOX_TITLE);
	HWND hWnd = ::FindWindow((LPCTSTR)csClassName,  (LPCTSTR) csTitle);
	if(hWnd != NULL)
	{
		SetForegroundWindow(hWnd);
		ShowWindow(hWnd, SW_SHOWNORMAL);
		return FALSE;
	}

	//First free the string allocated by MFC at CWinApp startup.
	//The string is allocated before InitInstance is called.
	free((void*)m_pszHelpFilePath);	
	TCHAR szCSHelpFilePath[MAX_PATH];
	GetWindowsDirectory(szCSHelpFilePath, MAX_PATH);
	CString csHelpFileName;
	csHelpFileName.LoadString(IDS_CONTEXT_HELP_FILENAME);
	lstrcat(szCSHelpFilePath, _T("\\help\\"));
	lstrcat(szCSHelpFilePath, csHelpFileName);
	//Change the path of the .HLP file.
	//The CWinApp destructor will free the memory.
	m_pszHelpFilePath=_tcsdup(szCSHelpFilePath);

	GetWindowsDirectory(m_szProfile, MAX_PATH);
	lstrcat(m_szProfile, _T("\\"));
	lstrcat(m_szProfile, this->m_pszProfileName);
	lstrcat(m_szProfile, _T(".ini"));

	if(DoesFileExist(m_szProfile))
		m_bProfileExist = TRUE;

	if(!CreateNavigatorMgr())
		return FALSE;

	//Default is not to show Logon Box. 
	if(m_bProfileExist)
	{
		CString csStr1, csStr2;
		csStr1.LoadString(IDS_INI_ADMINISTRATOR);
		csStr2.LoadString(IDS_INI_SHOW_LOGONBOX);
		m_bShowLogonBox = GetPrivateProfileInt(csStr1, csStr2, 0, m_szProfile);		
	}
	//Parental control level is determined by indivadual setting.
	if(m_bShowLogonBox) 
	{
		CParentControl dlg;		
		if(dlg.DoModal() == IDCANCEL)
		{
			DestroyNavigatorMgr(); 
			return FALSE;
		}
	}

	m_pUIDlg = new CDvdUIDlg;
	if(!m_pUIDlg)
	{
		DestroyNavigatorMgr(); 
		return FALSE;
	}

	if(!m_pUIDlg->Create())
	{
		OnUIClosed();
		return FALSE;
	}

	m_pMainWnd = (CWnd*) m_pUIDlg->m_pVideoWindow;
	if(!m_pMainWnd)
	{
		OnUIClosed();
		return FALSE;
	}

	if(!m_pUIDlg->OpenDVDROM() && m_bDiscRegionDiff == FALSE)
	{
		OnUIClosed();		
		return FALSE;
	}
	m_bDiscRegionDiff = FALSE;

	m_pUIDlg->m_pVideoWindow->AlignWindowsFrame();

	ShowPersistentUIWnd();		


#if DEBUG

     int iLen = cmdInfo.m_strFileName.GetLength();
     cFileName = (LPTSTR)malloc(iLen+1);
     cmdInfo.m_strPrinterName.MakeLower();
     cmdInfo.m_strDriverName.MakeLower();

     if(iLen != 0 &&
        cmdInfo.m_strPrinterName.GetAt(0) == 'i' &&
        cmdInfo.m_strDriverName.GetAt(0) == 'n' &&
        cmdInfo.m_strPortName.GetAt(0) == '5') {
          for (int i=0;i<iLen;i++)
               cFileName[i] = cmdInfo.m_strFileName.GetAt(i);
          cFileName[i] = '\0';
          DWORD dwTestThreadId;
          HANDLE hTestThreadHandle =
               ::CreateThread (NULL,
                               0,
                               reinterpret_cast<LPTHREAD_START_ROUTINE>(t_Ctrl),
                               reinterpret_cast<LPVOID>(this),
                               0,
                               &dwTestThreadId);
     }
#endif


	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDvdplayApp commands
void CDvdplayApp::ShowPersistentUIWnd()
{
	long lVWLeft=0, lVWTop=0, lVWWidth=0, lVWHeight=0;
	m_pDVDNavMgr->DVDGetVideoWindowSize(&lVWLeft, &lVWTop, &lVWWidth, &lVWHeight);

	RECT rcUI;
	m_pUIDlg->GetWindowRect(&rcUI);
	long UIWidth  = rcUI.right-rcUI.left;
	long UIHeight = rcUI.bottom-rcUI.top;

	int iScreenWidth  = GetSystemMetrics(SM_CXSCREEN);
	int iScreenHeight = GetSystemMetrics(SM_CYSCREEN);

	long lUIShowCmd, lUILeft, lUITop;
	if(GetUIWndPos(&lUIShowCmd, &lUILeft, &lUITop))
	{
		if(lUIShowCmd == SW_SHOWNORMAL)
		{
			if( (m_pDVDNavMgr->GetVWInitState() == FALSE)  &&	//VideoWindwo previous pos/size
				(lUILeft+UIWidth < iScreenWidth) &&                        //inside screen
				(UIWidth    < iScreenWidth && UIHeight < iScreenHeight) )  //smaller than screen
				//display UI with previous position.
				m_pUIDlg->MoveWindow(lUILeft, lUITop, UIWidth, UIHeight);
			else
				goto NEWPOSITION;
		}
		m_pUIDlg->ShowWindow(lUIShowCmd);
		m_pUIDlg->SetFocus();
		return;
	}

NEWPOSITION:
    // Get to here in following cases:
	// 1) GetUIWndPos failed or
	// 2) Video Window uses initial size/position or
	// 3) UI is (totally or partially) outside the screen or
	// 4) UI is wider than screen. This may indicates system error, testing people has seen it.
	// 3) and 4) may happen when change to lower resolution after quit the app.
	if( iScreenHeight - (lVWTop+lVWHeight) < UIHeight )  //no enough space at bottom
	{
		if( lVWTop < UIHeight )                          //no enough space at top for UI wnd
			m_pUIDlg->ShowWindow(SW_SHOWMINIMIZED);      //minimize UI window		
		else
		{
			//display UI at top of VW
			m_pUIDlg->MoveWindow(lVWLeft, lVWTop-UIHeight-2, UIWidth, UIHeight);
			m_pUIDlg->ShowWindow(SW_SHOW);
		}
	}
	else
	{
		//display UI at bottom of VW
		m_pUIDlg->MoveWindow(lVWLeft, lVWTop+lVWHeight+2, UIWidth, UIHeight);
		m_pUIDlg->ShowWindow(SW_SHOW);
	}		

	m_pUIDlg->SetFocus();
}

void CDvdplayApp::WriteVideoWndPos()
{
	long lLeft=0, lTop=0, lWidth=0, lHeight=0;
	m_pDVDNavMgr->DVDGetVideoWindowSize(&lLeft, &lTop, &lWidth, &lHeight);

	if(lLeft==0 && lTop==0 && lWidth==0 && lHeight==0)
		return;

	if(lLeft < 0) lLeft = 0;
	if(lTop < 0)  lTop  = 0;	

	CString csSection, csIntItem;
	csSection.LoadString(IDS_VIDEO_WINDOW_POS);
	csIntItem.LoadString(IDS_WINDOW_LEFT);
	WriteProfileInt( csSection, csIntItem, lLeft );
	csIntItem.LoadString(IDS_WINDOW_TOP);
	WriteProfileInt( csSection, csIntItem, lTop );
	csIntItem.LoadString(IDS_WINDOW_WIDTH);
	WriteProfileInt( csSection, csIntItem, lWidth );
	csIntItem.LoadString(IDS_WINDOW_HEIGHT);
	WriteProfileInt( csSection, csIntItem, lHeight );	
}

BOOL CDvdplayApp::GetVideoWndPos(long *lLeft, long *lTop, long *lWidth, long *lHeight)
{
	CString csSection, csIntItem;
	csSection.LoadString(IDS_VIDEO_WINDOW_POS);

	csIntItem.LoadString(IDS_WINDOW_LEFT);
	*lLeft = GetProfileInt( csSection, csIntItem, -1 );

	csIntItem.LoadString(IDS_WINDOW_TOP);
	*lTop = GetProfileInt( csSection, csIntItem, -1 );

	csIntItem.LoadString(IDS_WINDOW_WIDTH);
	*lWidth = GetProfileInt( csSection, csIntItem, -1 );

	csIntItem.LoadString(IDS_WINDOW_HEIGHT);
	*lHeight = GetProfileInt( csSection, csIntItem, -1 );

	if(*lLeft<0 || *lTop<0 || *lWidth<0 || *lHeight<0)
		return FALSE;
	else
		return TRUE;
}

void CDvdplayApp::WriteUIWndPos()
{
	WINDOWPLACEMENT wndplUIWnd;
	if(m_pUIDlg->GetWindowPlacement(&wndplUIWnd))
	{
		CString csSection, csIntItem;
		csSection.LoadString(IDS_UI_WINDOW_POS);
		csIntItem.LoadString(IDS_UI_SHOWCMD);
		WriteProfileInt(csSection, csIntItem, wndplUIWnd.showCmd);

		long lLeft = wndplUIWnd.rcNormalPosition.left;
		long lTop  = wndplUIWnd.rcNormalPosition.top;
		
		csIntItem.LoadString(IDS_WINDOW_LEFT);
		WriteProfileInt(csSection, csIntItem, lLeft);

		csIntItem.LoadString(IDS_WINDOW_TOP);
		WriteProfileInt(csSection, csIntItem, lTop);
	}
}

BOOL CDvdplayApp::GetUIWndPos(long *lShowCmd, long *lLeft, long *lTop)
{
	CString csSection, csIntItem;
	csSection.LoadString(IDS_UI_WINDOW_POS);

	csIntItem.LoadString(IDS_UI_SHOWCMD);
	*lShowCmd = GetProfileInt(csSection, csIntItem, -1);

	csIntItem.LoadString(IDS_WINDOW_LEFT);
	*lLeft = GetProfileInt(csSection, csIntItem, -1);

	csIntItem.LoadString(IDS_WINDOW_TOP);
	*lTop = GetProfileInt(csSection, csIntItem, -1);

	if(*lShowCmd<0 || *lLeft<0 || *lTop<0)
		return FALSE;
	else
		return TRUE;
}

void CDvdplayApp::OnUIClosed()
{
	WriteVideoWndPos();
	WriteUIWndPos();

	if(m_pUIDlg)
	{
		delete m_pUIDlg;
		m_pUIDlg = NULL;
	}
	DestroyNavigatorMgr();
}


BOOL CDvdplayApp::CreateNavigatorMgr()
{
	m_pDVDNavMgr = new CDVDNavMgr;

    // If by any chance Nav manager component didn't instantiate correctly or
    // more importantly, if somehow DVD graph builder didn't instantiate (because
    // qdvd.dll was not available / did not load).
	if(!m_pDVDNavMgr || m_pDVDNavMgr->IsGBNull())
	{
		DVDMessageBox(NULL, IDS_FAILED_CREATE_INSTANCE);
		DestroyNavigatorMgr();
		return FALSE;
	}
	return TRUE;
}

void CDvdplayApp::DestroyNavigatorMgr()
{
	if(m_pDVDNavMgr)
	{
		delete m_pDVDNavMgr;
		m_pDVDNavMgr = NULL;
	}
}

BOOL CDvdplayApp::DoesFileExist(LPTSTR lpFileName)
{
	HANDLE	hFile = NULL ;
	UINT uErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);		
	hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	SetErrorMode(uErrorMode);
	if(hFile == INVALID_HANDLE_VALUE) 
		return FALSE ;		

	CloseHandle(hFile);
	return TRUE;
}
/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About
CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


// App command to run the dialog
void CDvdplayApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

BOOL CDvdplayApp::QueryRegistryOEMFlag()
{
	BOOL    bDefaultOEMFlag = TRUE;     // Default is: play movie. 

	DWORD   retCode = 0;
	HKEY    hKeyRoot = HKEY_LOCAL_MACHINE;
	HKEY    hKey = 0; 
	CString csRegPath;
	csRegPath.LoadString(IDS_OEM_FLAG_PATH);
	retCode = RegOpenKeyEx (hKeyRoot,    // Key handle at root level.
                            csRegPath,   // Path name of child key.
                            0,           // Reserved.
                            KEY_EXECUTE, // Requesting read access.
                            &hKey);      // Address of key to be returned.
	
	if (retCode != ERROR_SUCCESS)        //no flag entry from OEM or the call just fails
	{
		TRACE(TEXT("RegOpenKeyEx() failed, No DVD key is found, play movie by default.\n"));
		return bDefaultOEMFlag;
	}

	TCHAR  szValueName[MAX_VALUE_NAME];
	DWORD dwType = REG_DWORD;
	LONG  lData ;
	DWORD cbData;
	cbData = sizeof(lData) ;
	LoadString(m_hInstance, IDS_OEM_FLAG_NAME, szValueName, MAX_VALUE_NAME);
	retCode = RegQueryValueEx(hKey, szValueName, NULL, &dwType, (LPBYTE)&lData, &cbData) ;

	if (ERROR_SUCCESS != retCode)        //not found DVD key
	{
		TRACE(TEXT("RegQueryValueEx() failed. No OEM flag is found, play movie by default.\n"));
		return bDefaultOEMFlag;
	}

	if (0 == lData)                      //not meet Windows logo, quit
		return FALSE;
	else                                 //meet Windows logo, play movie
		return TRUE;
}

int DVDMessageBox(HWND hWnd, LPCTSTR lpszText, LPCTSTR lpszCaption, UINT nType)
{
	CString csCaption;	
	if(lpszCaption == NULL)
	{
		csCaption.LoadString(IDS_MSGBOX_TITLE);
		return MessageBox(hWnd, lpszText, csCaption, nType );
	}
	else
		return MessageBox(hWnd, lpszText, lpszCaption, nType );
}

int DVDMessageBox(HWND hWnd, UINT nID, LPCTSTR lpszCaption, UINT nType)
{
	CString csMsgString, csCaption;
	csMsgString.LoadString(nID);
	if(lpszCaption == NULL)
	{
		csCaption.LoadString(IDS_MSGBOX_TITLE);
		return MessageBox(hWnd, csMsgString, csCaption, nType );
	}
	else
		return MessageBox(hWnd, csMsgString, lpszCaption, nType );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\mediakey.cpp ===
//
// mediakey.cpp: various code to handle the new MS Natural keyboard, which
// has media control keys (play/pause, stop, prev. track, next track).
//
// The reason all this has to be in a separate file is that winuser.h
// defines the new key identifier macros only if _WIN32_WINNT >= 0x0500,
// but MFC stuff needs to be compiled in NT4 compatibility mode to prevent
// random memory corruption (per BryanT).
//
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500

#include "windows.h"
#include "mediakey.h"

BOOL IsAppcommandMessage(UINT message) {
   return (message == WM_APPCOMMAND);
}

BOOL IsAppcommandCode(int nCode) {
   return (nCode == HSHELL_APPCOMMAND);
}

/*
enum MediaKeys MediaKeyFromAppCommand(LPARAM lParam) {
   switch (GET_APPCOMMAND_LPARAM(lParam)) {
      case APPCOMMAND_MEDIA_NEXTTRACK:
         return MediaKey_NextTrack;
      case APPCOMMAND_MEDIA_PREVIOUSTRACK:
         return MediaKey_PrevTrack;
      case APPCOMMAND_MEDIA_STOP:
         return MediaKey_Stop;
      case APPCOMMAND_MEDIA_PLAY_PAUSE:
         return MediaKey_Play;
      default:
         return MediaKey_Other;
   }
}
*/

enum MediaKeys MediaKey(WPARAM wParam) {
   switch (wParam) {
      case VK_MEDIA_NEXT_TRACK:
         return MediaKey_NextTrack;
      case VK_MEDIA_PREV_TRACK:
         return MediaKey_PrevTrack;
      case VK_MEDIA_STOP:
         return MediaKey_Stop;
      case VK_MEDIA_PLAY_PAUSE:
         return MediaKey_Play;
      default:
         return MediaKey_Other;
   }
}

BOOL IsMediaControlKey (WPARAM wParam) {
   return ((wParam == VK_MEDIA_NEXT_TRACK) ||
           (wParam == VK_MEDIA_PREV_TRACK) ||
           (wParam == VK_MEDIA_STOP) ||
           (wParam == VK_MEDIA_PLAY_PAUSE)
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\dvduidlg.h ===
#if !defined(AFX_DVDUIDLG_H__AF1C3AD3_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_)
#define AFX_DVDUIDLG_H__AF1C3AD3_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_

#if DEBUG
#include "test.h"
#endif


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DvdUIDlg.h : header file
//
class CDVDNavMgr;
class CVideoWindow;
/////////////////////////////////////////////////////////////////////////////
// CDvdUIDlg dialog

class CDvdUIDlg : public CDialog
{
	friend CVideoWindow;
// Construction
public:
	CDvdUIDlg(CWnd* pParent = NULL);   // standard constructor
	~CDvdUIDlg();
	BOOL Create();
	BOOL OpenDVDROM();
	void OnDomainChange(long lEvent);
	void PainBlackBox();
	void EnableEnterArrowButtons(BOOL);
   BOOL OnMediaKey(WPARAM, LPARAM);

	CVideoWindow* m_pVideoWindow;
	TCHAR szTitleNumber[3];
	TCHAR szChapterNumber[3];
	TCHAR szTimePrograss[9];

#if DEBUG
     BOOL t_Parse (char*, FILE*);
     BOOL t_Wait (int);
     BOOL t_IsCdEjected ();
#endif


// Dialog Data
	//{{AFX_DATA(CDvdUIDlg)
	enum { IDD = IDD_UI_WINDOW };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDvdUIDlg)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void     InitBitmapButton();
	void     createAddToolTips();
	void     addTool(UINT nBtnID, UINT nTipStrID);	
	void     getCDDriveLetter(TCHAR* lpDrive);
	BOOL     isInsideOperationBtns(CPoint point);
	BOOL     isInsideArrowBtns(CPoint point);
	BOOL     isInsidRect(RECT rc, CPoint point);
	DWORD    OpenCdRom(TCHAR chDrive, LPDWORD lpdwErrCode);
	void     CloseCdRom(DWORD DevHandle);
	void     EjectCdRom(DWORD DevHandle);
	void     UnEjectCdRom(DWORD DevHandle);
	TCHAR    GetFirstDriveFromMask(ULONG unitmask);
	BOOL     IsDiscInDrive();

	CDVDNavMgr* m_pDVDNavMgr;
	POINT       m_iCurrentPos;	
	CString     m_csBox1Title;
	CString     m_csBox2Title;
	CString     m_csBox3Title;
	BOOL        m_bEjected;	
	CFont       m_font;
	
	CBitmapButton m_bmpBtnPlay;
	CBitmapButton m_bmpBtnPause;
	CBitmapButton m_bmpBtnStop;
	CBitmapButton m_bmpBtnEj;
	CBitmapButton m_bmpBtnFullScreen;
	CBitmapButton m_bmpBtnVeryFastRewind;
	CBitmapButton m_bmpBtnFastRewind;
	CBitmapButton m_bmpBtnFastForward;
	CBitmapButton m_bmpBtnVeryFastForward;
	CBitmapButton m_bmpBtnStep;
	CBitmapButton m_bmpBtnAudio;
	CBitmapButton m_bmpBtnUp;
	CBitmapButton m_bmpBtnDown;
	CBitmapButton m_bmpBtnLeft;
	CBitmapButton m_bmpBtnRught;	
	CBitmapButton m_bmpBtnHelp;	
	CBitmapButton m_bmpContextHelp;
	CToolTipCtrl  m_ToolTips;

	// Generated message map functions
	//{{AFX_MSG(CDvdUIDlg)
	virtual void OnOK();
	virtual void OnCancel();
   afx_msg void OnPlay();
	afx_msg void OnStop();
   virtual BOOL OnInitDialog();
   //virtual LRESULT WindowProc(UINT message, WPARAM, LPARAM);
	afx_msg void OnPause();
	afx_msg void OnVeryFastRewind();
	afx_msg void OnFastRewind();
	afx_msg void OnFastForward();
	afx_msg void OnVeryFastForward();
	afx_msg void OnStep();
	afx_msg void OnFullScreen();
	afx_msg void OnAudioVolume();
	afx_msg void OnMenu();
	afx_msg void OnEnter();
	afx_msg void OnUp();
	afx_msg void OnDown();
	afx_msg void OnLeft();
	afx_msg void OnRight();
	afx_msg void OnOptions();
	afx_msg void OnNextChapter();
	afx_msg void OnPreviosChapter();
	afx_msg void OnOptionsSubtitles();
	afx_msg void OnClose();
#ifdef DISPLAY_OPTIONS
	afx_msg void OnOptionsDisplayPanscan();
	afx_msg void OnOptionsDisplayLetterbox();
	afx_msg void OnOptionsDisplayWide();
#endif	
   afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnOptionsSetratings();
	afx_msg void OnOperationPlayspeedNormalspeed();
	afx_msg void OnOperationPlayspeedDoublespeed();
	afx_msg void OnOperationPlayspeedHalfspeed();
	afx_msg void OnSearchTitle();
	afx_msg void OnSearchChapter();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnEjectDisc();
	afx_msg void OnOptionsClosedcaption();
	afx_msg void OnHelp();
	afx_msg void OnOptionsSelectDisc();
	afx_msg void OnOptionsShowLogon();
	afx_msg void OnOptionsLanguage();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextHelp();
	afx_msg void OnOptionsTitleMenu();
	//}}AFX_MSG
	afx_msg BOOL OnPowerBroadcast(DWORD dwPowerEvent, DWORD dwData);
	afx_msg BOOL OnDeviceChange(UINT nEventType, DWORD_PTR dwData);
   //LRESULT OnAppCommand(WPARAM, LPARAM);
	afx_msg BOOL OnAngleChange(UINT nID);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
   //afx_msg void OnDestroy();
   //afx_msg BOOL OnSysCommand(UINT nEventType, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DVDUIDLG_H__AF1C3AD3_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\navmgr.cpp ===
//
// Microsoft's DVD Navigator Manager
//
#include "stdafx.h"
#include "dvdplay.h"
#include "navmgr.h"
#include <initguid.h>
#include "videowin.h"
#include <IL21Dec.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDVDNavMgr construction/destruction

CDVDNavMgr::CDVDNavMgr()
{
	m_pDvdGB        = NULL;
	m_pGraph        = NULL;	
	m_pDvdInfo      = NULL;
	m_pDvdControl   = NULL;
	m_pMediaEventEx = NULL;
	m_pL21Dec       = NULL;

	m_State        = UNINITIALIZED;
	m_bShowSP      = FALSE;
	m_bFullScreen  = FALSE;
	m_bMenuOn      = FALSE;
	m_bStillOn     = FALSE;	
	m_bCCOn        = TRUE;	   //To turn it off, must be on first
	m_dwRenderFlag = AM_DVD_HWDEC_PREFER;
	m_hWndMsgDrain = NULL;
	m_bCCErrorFlag = 0;
	m_bInitVWSize  = FALSE;
	m_bNeedInitNav = TRUE;

	CoInitialize(NULL);
	HRESULT hr = CoCreateInstance(CLSID_DvdGraphBuilder,
                                  NULL,		
                                  CLSCTX_INPROC_SERVER,
                                  IID_IDvdGraphBuilder,
                                  (void **) &m_pDvdGB);
	//if(m_pDvdGB == NULL)   bug70259
	//	DVDMessageBox(NULL, IDS_FAILED_CREATE_INSTANCE);  bug70259

	ASSERT(SUCCEEDED(hr) && m_pDvdGB);
   m_TimerId = 0;
}

typedef UINT (CALLBACK* LPFNDLLFUNC1)(UINT);

CDVDNavMgr::~CDVDNavMgr()
{	
	ReleaseAllInterfaces();
	if(m_pDvdGB)
	{
		m_pDvdGB->Release();
		m_pDvdGB = NULL;
	}
	CoUninitialize();

	//Notify power manager that this app no longer needs display.
	// SetThreadExecutionState() is a Win98/NT5.x API. The following
	// code lets it run on Win95 too.
	LPFNDLLFUNC1 pfn ;
	pfn = (LPFNDLLFUNC1) GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), 
		                     "SetThreadExecutionState") ;
	if (pfn)
	    pfn(ES_CONTINUOUS);
}

void CDVDNavMgr::ReleaseAllInterfaces(void)
{
	if(m_pGraph)
	{
		m_pGraph->Release();
		m_pGraph = NULL;
	}
	if(m_pDvdInfo)
	{
		m_pDvdInfo->Release();
		m_pDvdInfo = NULL;
	}
	if(m_pDvdControl)
	{
		m_pDvdControl->Release();
		m_pDvdControl = NULL;
	}
	if(m_pMediaEventEx)
	{
		m_pMediaEventEx->Release();
		m_pMediaEventEx = NULL;
	}
}

// Do all initialization. Then open and play DVD ROM
BOOL CDVDNavMgr::DVDOpenDVD_ROM(LPCWSTR lpszPathName)
{
	ReleaseAllInterfaces();	

	CWnd* pWnd = ((CDvdplayApp*) AfxGetApp())->GetUIWndPtr();
	if(NULL == m_pDvdGB)
	{
		DVDMessageBox(pWnd->m_hWnd, IDS_FAILED_CREATE_INSTANCE);
		return FALSE;
	}		

	AM_DVD_RENDERSTATUS Status;
	HRESULT hr = m_pDvdGB->RenderDvdVideoVolume(NULL, m_dwRenderFlag, &Status);
    if (FAILED(hr))
	{
		DVDMessageBox(pWnd->m_hWnd, IDS_CANT_RENDER_FILE);		
		return FALSE;
	}
	
	m_pDvdGB->GetDvdInterface(IID_IDvdControl, (LPVOID *)&m_pDvdControl) ;
	if(NULL == m_pDvdControl)
	{
		DVDMessageBox(pWnd->m_hWnd, IDS_FAILED_INIT_DSHOW);
		return FALSE;  //App quits, destructor will call ReleaseAllInterfaces()
	}

	BOOL bValidDiscFound = TRUE;
	if (S_FALSE == hr)  // if partial success
	{
		CString csCaption, csMsg, csError, csTmp;
		UINT uiDefaultMsgBtn = MB_DEFBUTTON1;  //MB_DEFBUTTON1=Yes
		BOOL bUnKnownError = TRUE;
		int iNumErrors = 0;

        /*
		if (Status.iNumStreamsFailed > 0)                     //Total num stream failed
		{ 
			if(Status.iNumStreamsFailed == 1)
				csTmp.LoadString(IDS_STREAM_FAILED_ONE);
			else
				csTmp.LoadString(IDS_STREAM_FAILED_MORE);
			csError += csTmp;
			bUnKnownError = FALSE;
		}
        */

		if (Status.dwFailedStreamsFlag & AM_DVD_STREAM_VIDEO) //video stream failed
		{
			csTmp.LoadString(IDS_VIDEO_STREAM);
			csError += csTmp;
			uiDefaultMsgBtn = MB_DEFBUTTON2;  //MB_DEFBUTTON2=NO
			bUnKnownError = FALSE;
			iNumErrors++;
		}
		if (Status.dwFailedStreamsFlag & AM_DVD_STREAM_AUDIO) //audio stream failed
		{
			csTmp.LoadString(IDS_AUDIO_STREAM);
			csError += csTmp;
			bUnKnownError = FALSE;
			iNumErrors++;
		}
		if (Status.dwFailedStreamsFlag & AM_DVD_STREAM_SUBPIC)// SubPicture stream failed
		{
            if (Status.dwFailedStreamsFlag & AM_DVD_STREAM_VIDEO) // video stream also failed
            {
                // ignore this one as it is covered by the video stream failure message
                DbgLog((LOG_TRACE, TEXT("DVD subpicture (as well as video) stream didn't render)"))) ;
            }
            else
            {
			    csTmp.LoadString(IDS_SUBPICTURE_STREAM);
			    csError += csTmp;
			    bUnKnownError = FALSE;
			    iNumErrors++;
            }
		}
		// if (Status.iNumStreamsFailed > 0 && Status.hrVPEStatus == 0)
		// {
		// 	csTmp.LoadString(IDS_DECODER_WRONG);
		// 	csError += csTmp;
		// }

        /*
		if (FAILED(Status.hrVPEStatus))                       //VPE not work
		{
			TCHAR szBuffer[200];
			AMGetErrorText(Status.hrVPEStatus, szBuffer, 200);
			csTmp.LoadString(IDS_VPE_NOT_WORKING);
			csError += csTmp;
			csTmp.LoadString(IDS_ERROR);
			csError += "   ( " + csTmp + ": " +  (CString)szBuffer + ")\n";
			bUnKnownError = FALSE;
			iNumErrors++;
		}
        */
		if (Status.bDvdVolInvalid)                            //Invalid DVD disc
		{
			bValidDiscFound = FALSE;
			bUnKnownError = FALSE;
		}
		else if (Status.bDvdVolUnknown)                       //No DVD dsic
		{
			bValidDiscFound = FALSE;
			bUnKnownError = FALSE;
		}
		if (Status.bNoLine21In)                               //no cc data produced
		{
			m_bCCErrorFlag |= NO_CC_IN_ERROR;
			bUnKnownError = FALSE;
		}
		if (Status.bNoLine21Out)                              //cc data not rendered properly
		{
			m_bCCErrorFlag |= CC_OUT_ERROR;
			bUnKnownError = FALSE;
		}

		if(bUnKnownError == TRUE)                             //can't get exact error text
		{
			csError.LoadString(IDS_UNKNOWN_ERROR);
			uiDefaultMsgBtn = MB_DEFBUTTON2;
			iNumErrors++;
		}
		csCaption.LoadString(IDS_MSGBOX_TITLE);
        // if(iNumErrors < 2)
		// 	csMsg.LoadString(IDS_FOLLOWING_ERROR_HAPPENED);
		// else
		csMsg.LoadString(IDS_FOLLOWING_ERRORS_HAPPENED);
		csMsg += csError;
		csTmp.LoadString(IDS_WANT_CONTINUE);
		csMsg += csTmp;
		if(!csError.IsEmpty())
		{
			if( IDNO == DVDMessageBox(pWnd->m_hWnd, csMsg, csCaption, 
				MB_YESNO | MB_ICONEXCLAMATION | uiDefaultMsgBtn))
				return FALSE;
		}
	}	

	if(FAILED(m_pDvdControl->SetRoot(lpszPathName)))
	{
		bValidDiscFound = FALSE;
		((CDvdplayApp*) AfxGetApp())->SetPassedSetRoot(FALSE);
	}

    // Now get all the interfaces to playback the DVD-Video volume
    hr = m_pDvdGB->GetFiltergraph(&m_pGraph);
	hr = m_pDvdGB->GetDvdInterface(IID_IDvdInfo, (LPVOID *)&m_pDvdInfo);    
	if(!m_pGraph || !m_pDvdInfo)
	{
		DVDMessageBox(pWnd->m_hWnd, IDS_FAILED_INIT_DSHOW);
		return FALSE;  //App quits, destructor will call ReleaseAllInterfaces()
	}

	//Change 1) aspect ratio, 2) suPicture state, 3) parental control level 
	//from Navigator's default to the app's default.
	DVDInitNavgator(); 
	DVDCCControl();    //Turn CC off by default.    
	    
	m_pGraph->QueryInterface(IID_IMediaEventEx, (void **)&m_pMediaEventEx);
	if(m_pMediaEventEx)
	{
		CWnd* pWnd = AfxGetMainWnd(); 
		m_pMediaEventEx->SetNotifyWindow((OAHWND)pWnd->m_hWnd, WM_AMPLAY_EVENT, 
					reinterpret_cast<LONG_PTR>(m_pMediaEventEx));
	}		

	DVDSetPersistentVideoWindow();
	CString cs;
	wchar_t wc[100];
	cs.LoadString(IDS_MSGBOX_TITLE);		
#ifdef _UNICODE
	lstrcpy(wc, cs);
#else
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (LPCTSTR)cs, -1, wc, 100);
#endif
	DVDSetVideoWindowCaption(wc);

	if(bValidDiscFound)
	{		
		m_State = STOPPED;
		if(!DVDPlay())
			return FALSE;
	}	

	//notify power manager that display is in use, don't go to sleep
	// SetThreadExecutionState() is a Win98/NT5.x API. The following
	// code lets it run on Win95 too.
	LPFNDLLFUNC1 pfn ;
	pfn = (LPFNDLLFUNC1) GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), 
		                     "SetThreadExecutionState") ;
	if (pfn)
	    pfn(ES_CONTINUOUS | ES_DISPLAY_REQUIRED);

	return TRUE;
}

BOOL CDVDNavMgr::IsCCEnabled()
{
	HRESULT hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&m_pL21Dec);
	if (SUCCEEDED(hr) && m_pL21Dec)
	{
		m_pL21Dec->Release();
		m_pL21Dec = NULL;
		return TRUE;
	}

	return FALSE;
}

BOOL CDVDNavMgr::DVDCCControl()
{
	HRESULT hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&m_pL21Dec);
	if (SUCCEEDED(hr) && m_pL21Dec)
	{		
		hr = m_pL21Dec->SetServiceState(m_bCCOn ? AM_L21_CCSTATE_Off : AM_L21_CCSTATE_On);
		m_pL21Dec->Release();
		m_pL21Dec = NULL;
		if(SUCCEEDED(hr))
			m_bCCOn = !m_bCCOn;
	}
	
	return (m_bCCOn);
}

// Open a DVD file to play. 
BOOL CDVDNavMgr::DVDOpenFile(LPCWSTR lpszPathName) 
{
	DVDStop();  //must be in DVD_DOMAIN_Stop state to call SetRoot
	if( SUCCEEDED(m_pDvdControl->SetRoot(lpszPathName)) )
		m_State = STOPPED;
	else
	{
		CString csMsg, csTitle, csTmp;
		csTmp.LoadString(IDS_NOT_A_VALID_DVD_FILE);
		csMsg += (CString) lpszPathName + ":  ";
		csMsg += csTmp;
		csTitle.LoadString(IDS_MSGBOX_TITLE);
		CWnd* pWnd = ((CDvdplayApp*) AfxGetApp())->GetUIWndPtr();
		DVDMessageBox(pWnd->m_hWnd, csMsg, csTitle, MB_OK | MB_ICONEXCLAMATION);
		m_State = UNINITIALIZED;
		((CDvdplayApp*) AfxGetApp())->SetDiscFound(FALSE);
		((CDvdplayApp*) AfxGetApp())->SetPassedSetRoot(FALSE);
		return FALSE;
	}

	((CDvdplayApp*) AfxGetApp())->SetDiscFound(TRUE);
	((CDvdplayApp*) AfxGetApp())->SetPassedSetRoot(TRUE);
	return TRUE;
}

void CDVDNavMgr::DVDOnShowFullScreen()
{
	if(!DVDIsInitialized())
		return;

	if(!m_bFullScreen)
		DVDStartFullScreenMode();
	else
		DVDStopFullScreenMode();
}

void CDVDNavMgr::DVDStartFullScreenMode() 
{
	TRACE(TEXT("Enter DVDStartFullScreenMode()\n")) ; 

	if(!DVDIsInitialized())
		return;

	TCHAR  achBuffer[100] ;
	IVideoWindow *pVW ;
	HRESULT       hr ;
	hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (void **)&pVW) ;
	if(SUCCEEDED(hr) && NULL != pVW)
	{
		CWnd* pWnd = AfxGetMainWnd();
		ASSERT(pWnd->m_hWnd) ;
		hr = pVW->get_MessageDrain((OAHWND *) &m_hWndMsgDrain) ;
		ASSERT(SUCCEEDED(hr)) ;
		hr = pVW->put_MessageDrain((OAHWND) pWnd->m_hWnd) ;
		ASSERT(SUCCEEDED(hr)) ;		
		wsprintf(achBuffer, TEXT("DVDStartFullScreenMode: put_MessageDrain() returned 0x%lx\n"), hr) ;
		TRACE(achBuffer) ;
      hr = pVW->put_FullScreenMode(OATRUE) ;
		ASSERT(SUCCEEDED(hr)) ;
		wsprintf(achBuffer, TEXT("DVDStartFullScreenMode: put_FullScreenMode() returned 0x%lx\n"), hr) ;
		TRACE(achBuffer) ;

		// This is to undo any letter-boxing done by the filter-graph-manager, 
		// since the overlay mixer is supposed to take care of that now.
		{
			IBasicVideo *pBV = NULL;
			hr = m_pDvdGB->GetDvdInterface(IID_IBasicVideo, (void **)&pBV) ;
			if( SUCCEEDED(hr) && pBV)
			{
				// make the destination rectangle the whole window 
				hr = pBV->SetDefaultDestinationPosition();
				ASSERT(SUCCEEDED(hr)) ;
				pBV->Release();
			}
		}
		pVW->Release() ;
		m_bFullScreen = TRUE;
	}
	else
		TRACE(TEXT("No VideoWindow -- No Full Screen\n"));
}

void CDVDNavMgr::DVDStopFullScreenMode()
{
	TRACE(TEXT("Inside DVDStopFullScreenMode()\n")) ; 

	if(!DVDIsInitialized())
		return;

	if (NULL == m_pMediaEventEx)
	{
	TRACE(TEXT("Looks like Full Screen mode has already been exited\n")) ;
	return ;
	}
	HRESULT hr ;
	IVideoWindow *pVW ;
	hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (void **)&pVW) ;
	if(SUCCEEDED(hr) && pVW)
	{
		hr = pVW->put_FullScreenMode(OAFALSE) ;
		ASSERT(SUCCEEDED(hr)) ;
		TRACE(TEXT("put_FullScreenMode(OAFALSE) returns ox%x\n"), hr);
		m_bFullScreen = FALSE;
		if(!m_bMenuOn)
			hr = pVW->put_MessageDrain((OAHWND) m_hWndMsgDrain);
		else
			((CVideoWindow*)AfxGetMainWnd())->AlignWindowsFrame();
		ASSERT(SUCCEEDED(hr)) ;
		TRACE(TEXT("put_MessageDrain() returns Ox%lx\n"), hr);

		CWnd* pWnd = ((CDvdplayApp*) AfxGetApp())->GetUIWndPtr();
		pWnd->GetDlgItem(IDB_FULL_SCREEN)->SetFocus();		
		pVW->Release();
	}
	else
		TRACE(TEXT("No VideoWindow -- No Full Screen\n"));
}

// Play
BOOL CDVDNavMgr::DVDPlay()
{
	if( DVDCanPlay() )
	{
		//Need to remove infinite still.
		if(m_bStillOn)
		{
			if(SUCCEEDED(m_pDvdControl->StillOff()))
			{
				m_State=PLAYING;
            //DisableScreenSaver();
            SetupTimer();
				return TRUE;
			}
		}

	HRESULT hr;
	IMediaControl *pMC;

	// Obtain the interface to our filter graph
	hr = m_pGraph->QueryInterface(IID_IMediaControl, (void **) &pMC);

	if( SUCCEEDED(hr) )
	{
		// Ask the filter graph to play and release the interface

		// default behaviour is to carry on from where we stopped last
		// time.
		//
		// if you want it to do this, but rewind at the end then
		// define REWIND.
		// Otherwise you probably want to always start from the
		// beginning -> define FROM_START (in stop)
#undef REWIND
#define FROM_START

#ifdef REWIND
		IMediaPosition * pMP;
		hr = m_pGraph->QueryInterface(IID_IMediaPosition, (void**) &pMP);
		if (SUCCEEDED(hr)) 
		{
		// start from last position, but rewind if near the end
		REFTIME tCurrent, tLength;
		hr = pMP->get_Duration(&tLength);
		if (SUCCEEDED(hr)) {
			hr = pMP->get_CurrentPosition(&tCurrent);
			if (SUCCEEDED(hr)) {
			// within 1sec of end? (or past end?)
			if ((tLength - tCurrent) < 1) {
				pMP->put_CurrentPosition(0);
			}
			}
		}
		pMP->Release();
		}
			else
			{
				pMC->Release();
				return FALSE;
			}
#endif
		if(m_bFullScreen)
			DVDStartFullScreenMode();

		//After stop, Navgator sets all parameter to Navigator's default,
		//App should set them to whatever init values app wants.
		if(m_bNeedInitNav)
			DVDInitNavgator();				

		hr = pMC->Run();
		m_pDvdControl->ForwardScan(1.0);
		pMC->Release();

		if( SUCCEEDED(hr) )
		{			
			m_State=PLAYING;
			m_bNeedInitNav = FALSE;
         //DisableScreenSaver();
         SetupTimer();
			return TRUE;
		}
	}  // end of if (SUCCEEDED(hr))

	// Inform the user that an error occurred
	CWnd* pWnd = ((CDvdplayApp*) AfxGetApp())->GetUIWndPtr();
	DVDMessageBox(pWnd->m_hWnd, IDS_CANT_PLAY);
	}    // end of if (CanPlay())
	return FALSE;
}

void CDVDNavMgr::DVDSetVideoWindowCaption(BSTR lpCaption)
{
	IVideoWindow *piVidWnd = NULL;
	HRESULT hr = m_pDvdGB->GetDvdInterface( IID_IVideoWindow, (void **)&piVidWnd);
	if(SUCCEEDED(hr) && NULL != piVidWnd)
	{
		piVidWnd->put_Caption(lpCaption);
		piVidWnd->Release();
	}
}

void CDVDNavMgr::DVDSetPersistentVideoWindow()
{
	long lLeft, lTop, lWidth, lHeight;
	BOOL bRet;
	bRet = ((CDvdplayApp*) AfxGetApp())->GetVideoWndPos(&lLeft, &lTop, &lWidth, &lHeight);
	if(bRet == TRUE)
	{
		IVideoWindow *pIVW = NULL;
		HRESULT hr;
		hr = m_pDvdGB->GetDvdInterface( IID_IVideoWindow, (void **)&pIVW);
		if(SUCCEEDED(hr) && pIVW)
		{
			int iRight  = lLeft + lWidth;
			int iBottom = lTop  + lHeight;
			int iScreenWidth  = GetSystemMetrics(SM_CXSCREEN);
			int iScreenHeight = GetSystemMetrics(SM_CYSCREEN);
			if( (lLeft  < iScreenWidth && lTop    < iScreenHeight) &&  //not minimized (see below)
				(iRight < iScreenWidth && iBottom < iScreenHeight) &&  //not outside screen
				(lWidth < iScreenWidth && lHeight < iScreenHeight) )   //smaller than screen
			{
				hr = pIVW->SetWindowPosition(lLeft, lTop, lWidth, lHeight);
				pIVW->Release();
				return;
			}
			pIVW->Release();
		}
	}

	//call DVDInitVideoWindowSize() in following cases:
	//1)GetVideoWndPos failed. 2)pIVW == NULL, 
	//3)VW minimized before quit, IVideowindiw sets lLeft=3000, lTop=3000
	//4)VW is bigger than screen. (changed to lower resolution after quit)
	DVDInitVideoWindowSize();
	m_bInitVWSize = TRUE;
}

void CDVDNavMgr::DVDInitVideoWindowSize()
{
    HRESULT hr = NOERROR;
    IBasicVideo *pIBV = NULL;
    IVideoWindow *pIVW = NULL;
    RECT rcWindowRect;
    LONG lNativeWidth = 0, lNativeHeight = 0;
    double dReductionFactor = 2.0/3.0;
    LONG lWindowStyle = 0;
    int iScreenWidth = 0, iScreenHeight = 0;
    BOOL bRetVal = TRUE;

    SetRect(&rcWindowRect, 0, 0, 0, 0);

    //get the IBasicVideo interface
    hr = m_pDvdGB->GetDvdInterface( IID_IBasicVideo, (void **)&pIBV);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 0, "m_pDvdGB->GetDvdInterface(IBasicVideo) failed, hr = 0x%x", hr));
	goto CleanUp;
    }

    //get the IVideoWindow interface
    hr = m_pDvdGB->GetDvdInterface( IID_IVideoWindow, (void **)&pIVW);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 0, "m_pDvdGB->GetDvdInterface(IVideoWindow) failed, hr = 0x%x", hr));
	goto CleanUp;
    }

    // get the native size
    hr = pIBV->GetVideoSize(&lNativeWidth, &lNativeHeight);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 0, "pIBV->GetVideoSize failed, hr = 0x%x", hr));
	goto CleanUp;
    }

    // get the window style
    hr = pIVW->get_WindowStyle(&lWindowStyle);
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 0, "pIVW->get_WindowStyle failed, hr = 0x%x", hr));
	goto CleanUp;
    }

    iScreenWidth = GetSystemMetrics(SM_CXSCREEN);
    iScreenHeight = GetSystemMetrics(SM_CYSCREEN);

    do
    {
	SetRect(&rcWindowRect, 0, 0, lNativeWidth, lNativeHeight);

	// calculate the window rect based on the client rect
	bRetVal = AdjustWindowRect(&rcWindowRect, lWindowStyle, FALSE);
	if (bRetVal == 0)
	{
	    DbgLog((LOG_ERROR, 0, "AdjustWindowRect failed, hr = 0x%x", hr));
	    goto CleanUp;
	}

	// if width or height does not fit on the desktop, reduce both
	if ((WIDTH(&rcWindowRect) > iScreenWidth) || (HEIGHT(&rcWindowRect) > iScreenHeight))
	{
	    lNativeWidth = (LONG)(lNativeWidth*dReductionFactor);
		lNativeHeight = (LONG)(lNativeHeight*dReductionFactor);
	}

    }
    while((WIDTH(&rcWindowRect) > iScreenWidth) || (HEIGHT(&rcWindowRect) > iScreenHeight));

    DbgLog((LOG_TRACE, 0, "NewWidth = %d, NewHeight = %d", WIDTH(&rcWindowRect), HEIGHT(&rcWindowRect)));
	
    // set the window position
    hr = pIVW->SetWindowPosition(0, 0, WIDTH(&rcWindowRect), HEIGHT(&rcWindowRect));
    if (FAILED(hr))
    {
	DbgLog((LOG_ERROR, 0, "pIVW->SetWindowPosition failed, hr = 0x%x", hr));
	goto CleanUp;
    }

CleanUp:
    if (pIBV)
    {
	pIBV->Release();
	pIBV = NULL;
    }

    if (pIVW)
    {
	pIVW->Release();
	pIVW = NULL;
    }
}

// Set Video Window Size
void CDVDNavMgr::DVDSetVideoWindowSize(long iLeft, long iTop, long iWidth, long iHeight)
{
	TRACE(TEXT("navmgr.cpp DVDSetVideoWindowSize()\n"));

	IVideoWindow *piVidWnd = NULL;
	HRESULT hr = m_pDvdGB->GetDvdInterface( IID_IVideoWindow, (void **)&piVidWnd);
	if(SUCCEEDED(hr) && NULL != piVidWnd)
	{
		piVidWnd->SetWindowPosition(iLeft, iTop, iWidth, iHeight);
		piVidWnd->Release();
	}
}

// Get Video Window Size
void CDVDNavMgr::DVDGetVideoWindowSize(long *lLeft, long *lTop, long *lWidth, long *lHeight)
{
	IVideoWindow *piVidWnd = NULL;
	HRESULT hr = m_pDvdGB->GetDvdInterface( IID_IVideoWindow, (void **)&piVidWnd);
	if(SUCCEEDED(hr) && NULL != piVidWnd)
	{
		piVidWnd->GetWindowPosition(lLeft, lTop, lWidth, lHeight);
		piVidWnd->Release();
	}
}

// Pause
void CDVDNavMgr::DVDPause()
{
	if( DVDCanPause() )
	{
		/*
		if(DVDIsInitialized())
		{
		m_pDvdControl->PauseOn();
			m_State = PAUSED;
		}
		*/
		HRESULT hr;
		IMediaControl *pMC;

	   // Obtain the interface to our filter graph
		hr = m_pGraph->QueryInterface(IID_IMediaControl, (void **) &pMC);

		if( SUCCEEDED(hr) )
		{
		// Ask the filter graph to pause and release the interface
			hr = pMC->Pause();
			pMC->Release();

			if( SUCCEEDED(hr) )
			{
				m_State = PAUSED;
				return;
			}
		}

		// Inform the user that an error occurred
		CWnd* pWnd = ((CDvdplayApp*) AfxGetApp())->GetUIWndPtr();
		DVDMessageBox(pWnd->m_hWnd, IDS_CANT_PAUSE);
	}   
}

// There are two different ways to stop a graph. We can stop and then when we
// are later paused or run continue from the same position. Alternatively the
// graph can be set back to the start of the media when it is stopped to have
// a more CDPLAYER style interface. These are both offered here conditionally
// compiled using the FROM_START definition. The main difference is that in
// the latter case we put the current position to zero while we change states

void CDVDNavMgr::DVDStop()
{
	if( DVDCanStop() )
	{
		HRESULT hr;
		IMediaControl *pMC;

		hr = m_pGraph->QueryInterface(IID_IMediaControl, (void **) &pMC);
		if( SUCCEEDED(hr) )
		{
#ifdef FROM_START
			IMediaPosition * pMP;
			OAFilterState state;

			// Ask the filter graph to pause
			hr = pMC->Pause();

			// if we want always to play from the beginning
			// then we should seek back to the start here
			// (on app or user stop request, and also after EC_COMPLETE).
			hr = m_pGraph->QueryInterface(IID_IMediaPosition,(void**) &pMP);
			if (SUCCEEDED(hr)) 
			{
				pMP->put_CurrentPosition(0);
				pMP->Release();
			}

			// wait for pause to complete
			pMC->GetState(5000, &state);// INFINITE
#endif
			// now really do the stop
			pMC->Stop();
			pMC->Release();
			m_State = STOPPED;
			m_bNeedInitNav = TRUE;
         //ReenableScreenSaver();
         StopTimer();
			return;
		}
		// Inform the user that an error occurred
		CWnd* pWnd = ((CDvdplayApp*) AfxGetApp())->GetUIWndPtr();
		DVDMessageBox(pWnd->m_hWnd, IDS_CANT_STOP);
	}
}

void CDVDNavMgr::DVDSlowPlayBack()
{
	if(DVDIsInitialized() && DVDCanChangeSpeed())
	{
		m_pDvdControl->ForwardScan(0.5);
		m_State = SCANNING;
	}
}

// Slow Fast Forward
void CDVDNavMgr::DVDFastForward() 
{
	if(DVDIsInitialized() && DVDCanChangeSpeed())
	{
		m_pDvdControl->ForwardScan(2.0);
		m_State = SCANNING;
	}
}

// Slow Rewind
void CDVDNavMgr::DVDFastRewind() 
{
	if(DVDIsInitialized() && DVDCanChangeSpeed())
	{
		m_pDvdControl->BackwardScan(2.0);
		m_State = SCANNING;
	}
}

// Fast Forward
void CDVDNavMgr::DVDVeryFastForward() 
{
	if(DVDIsInitialized() && DVDCanChangeSpeed())
	{
		m_pDvdControl->ForwardScan(8.0);
		m_State = SCANNING;
	}
}

// Rewind
void CDVDNavMgr::DVDVeryFastRewind() 
{
	if(DVDIsInitialized() && DVDCanChangeSpeed())
	{
		m_pDvdControl->BackwardScan(8.0);
		m_State = SCANNING;
	}
}

// Pressing buttons.
void CDVDNavMgr::DVDPressButton(int iButton) 
{
	if(DVDIsInitialized())
	m_pDvdControl->ButtonSelectAndActivate(iButton);
}

// Sub-Picture ON/OFF
void CDVDNavMgr::DVDSubPictureOn(BOOL bOn) 
{
	TRACE(TEXT("Inside DVDSubPictureOn(), call subPictStreamChange() bOn=%d\n"), bOn);
	m_bShowSP = bOn;
	subPictStreamChange(32,m_bShowSP);      
}

// Select Sub-Picture
void CDVDNavMgr::DVDSubPictureSel(int iSel) 
{
	subPictStreamChange(iSel, m_bShowSP);   
}

// stream starts from 0
void CDVDNavMgr::subPictStreamChange(ULONG bStream, BOOL bShow)
{
	if(!DVDIsInitialized())
		return;

	TRACE(TEXT("Inside subPictStreamChange(), Trying to set SP to %d, bShow=%d\n"),bStream, bShow);
	if( SUCCEEDED( m_pDvdControl->SubpictureStreamChange(bStream,bShow) ) )
	{
		TRACE(TEXT("Successful to set lauguage to %d, bShow=%d\n"), bStream, bShow);
	}
}

// Cursor Down
void CDVDNavMgr::DVDCursorDown() 
{
	if(DVDIsInitialized())
	{
	if( SUCCEEDED( m_pDvdControl->LowerButtonSelect() ) )
		{
		}
	}
}

// Cursor Left
void CDVDNavMgr::DVDCursorLeft() 
{
	if(DVDIsInitialized())
	{
	m_pDvdControl->LeftButtonSelect();
	}
}

// Cursor right
void CDVDNavMgr::DVDCursorRight() 
{
	if(DVDIsInitialized())
	{
	m_pDvdControl->RightButtonSelect();
	}
}

// Cursor select
void CDVDNavMgr::DVDCursorSelect() 
{
	if(DVDIsInitialized())
	{
	m_pDvdControl->ButtonActivate();
	}
}

// Cursor up
void CDVDNavMgr::DVDCursorUp() 
{
	if(DVDIsInitialized())
	{
		m_pDvdControl->UpperButtonSelect();
	}       
}

HRESULT CDVDNavMgr::getSPRM(UINT uiSprm, WORD * pWord)
{
	SPRMARRAY  sprm;
	HRESULT    hRes;
	if(pWord==NULL)
		return E_INVALIDARG;

	if( SUCCEEDED (hRes=m_pDvdInfo->GetAllSPRMs(&sprm)) )
		*pWord = sprm[uiSprm];
	return hRes;
}

// Stream starts from 0
void CDVDNavMgr::DVDAudioStreamChange(ULONG Stream)
{       
	if(!DVDIsInitialized())
		return;

	TRACE(TEXT("Setting Audio Stream %d\n"),Stream);
	if( SUCCEEDED(m_pDvdControl->AudioStreamChange(Stream) ) )
		TRACE(TEXT("Succeeded to change audio stream to %d\n"), Stream);
}

void CDVDNavMgr::DVDMenuResume()
{
	m_pDvdControl->Resume();
	m_bMenuOn = FALSE;
}

// To set Menu on/off
void CDVDNavMgr::DVDMenuVtsm(DVD_MENU_ID MenuID) 
{
	if(!DVDIsInitialized())
		return;

	DVD_DOMAIN Domain;
	if(FAILED(m_pDvdInfo->GetCurrentDomain(&Domain)))
	{
		TRACE(TEXT("m_pDvdInfo->GetCurrentDomain() failed\n"));
		return;
	}
	switch(Domain)
	{
		case DVD_DOMAIN_FirstPlay:         //lEvent=1
			break;
		case DVD_DOMAIN_VideoManagerMenu:  //lEvent=2
			m_bMenuOn = TRUE;
			break;
		case DVD_DOMAIN_VideoTitleSetMenu: //lEvent=3
			m_bMenuOn = TRUE;
			break;
		case DVD_DOMAIN_Title:             //lEvent=4
			m_bMenuOn = FALSE;
			break;
		case DVD_DOMAIN_Stop:              //lEvent=5 
			break;
	}

	if(m_bMenuOn)
	{
		DVDMenuResume();
		return;
	}       

	if( SUCCEEDED( m_pDvdControl->MenuCall(MenuID) ) )
	{
		m_bMenuOn = TRUE;
	}
}

void CDVDNavMgr::MessageDrainOn(BOOL on)
{
	//When FullScreen, message drain is always on, cannot change.
	if(IsFullScreenMode())
		return;

	IVideoWindow *pVW;
	HRESULT       hr;
	hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (void **)&pVW);
	if(SUCCEEDED(hr) && NULL != pVW)
	{
		CWnd* pWnd = AfxGetMainWnd();
		ASSERT(pWnd->m_hWnd) ;
		if(on)
			hr = pVW->put_MessageDrain((OAHWND) pWnd->m_hWnd);
		else
			hr = pVW->put_MessageDrain((OAHWND) NULL);
		ASSERT(SUCCEEDED(hr));
		pVW->Release();
	}
	else
		TRACE(TEXT("No VideoWindow -- No message drain.\n"));
}

// Still ON/OFF
void CDVDNavMgr::DVDStillOff() 
{
	if( SUCCEEDED( m_pDvdControl && m_pDvdControl->StillOff() ) )
	{
	}               
}

void CDVDNavMgr::DVDNextProgramSearch() 
{
	if(DVDIsInitialized())
	m_pDvdControl->NextPGSearch(); 
}

void CDVDNavMgr::DVDPreviousProgramSearch() 
{
	if(DVDIsInitialized())
	m_pDvdControl->PrevPGSearch(); 
}

// Restart
void CDVDNavMgr::DVDTopProgramSearch() 
{
	if(DVDIsInitialized())
	m_pDvdControl->TopPGSearch();  
}

void CDVDNavMgr::DVDPlayPTT(ULONG title, ULONG ptt)
{
	if(DVDIsInitialized())
		m_pDvdControl->ChapterPlay(title, ptt);
}

void CDVDNavMgr::DVDPlayTitle(ULONG title) 
{
	if(DVDIsInitialized())
	m_pDvdControl->TitlePlay(title);
}

void CDVDNavMgr::DVDChapterSearch(ULONG Chapter) 
{
	if(DVDIsInitialized())  
	m_pDvdControl->ChapterSearch(Chapter);
}

void CDVDNavMgr::DVDGoUp() 
{
	if(DVDIsInitialized())
		m_pDvdControl->GoUp();
}

void CDVDNavMgr::DVDGetAngleInfo(ULONG* pnAnglesAvailable, ULONG* pnCurrentAngle)
{
	if(DVDIsInitialized() && m_pDvdInfo)
	m_pDvdInfo->GetCurrentAngle(pnAnglesAvailable, pnCurrentAngle);
}

// To set Angle
void CDVDNavMgr::DVDAngleChange(ULONG angle) 
{
	if(DVDIsInitialized())
	m_pDvdControl->AngleChange(angle);
}

// To set Video to Normal
void CDVDNavMgr::DVDVideoNormal() 
{	
	DVD_PREFERRED_DISPLAY_MODE mode;
	mode = DISPLAY_CONTENT_DEFAULT;
	
	if(DVDIsInitialized())
		m_pDvdControl->VideoModePreferrence((ULONG) mode);
}

// To set Video to Panscan
void CDVDNavMgr::DVDVideoPanscan() 
{
	DVD_PREFERRED_DISPLAY_MODE mode;
	mode = DISPLAY_4x3_PANSCAN_PREFERRED;
	
	if(DVDIsInitialized())
		m_pDvdControl->VideoModePreferrence((ULONG) mode);
}

// To set Video to Letterbox
void CDVDNavMgr::DVDVideoLetterbox() 
{
	DVD_PREFERRED_DISPLAY_MODE mode;
	mode = DISPLAY_4x3_LETTERBOX_PREFERRED;
	
	if(DVDIsInitialized())
		m_pDvdControl->VideoModePreferrence((ULONG) mode);
}

// To set Video to 16:9
void CDVDNavMgr::DVDVideo169() 
{
	DVD_PREFERRED_DISPLAY_MODE mode;
	mode = DISPLAY_16x9;
	
	if(DVDIsInitialized())
		m_pDvdControl->VideoModePreferrence((ULONG) mode);
}

// To Handle LButtuonUp message from VideoWindow
BOOL CDVDNavMgr::DVDMouseClick(CPoint point)
{
	if(m_pDvdControl != NULL && m_pDvdControl->MouseActivate(point) == S_OK)
		return TRUE;
	return FALSE;
}

// To Handle Mouse move message from VideoWindow
BOOL CDVDNavMgr::DVDMouseSelect(CPoint point)
{
	if(m_pDvdControl != NULL && m_pDvdControl->MouseSelect(point) == S_OK)
		return TRUE;
	return FALSE;
}

// Returns number of Titles
ULONG CDVDNavMgr::DVDQueryNumTitles()
{
	ULONG pNumOfVol;
	ULONG pThisVolNum;
	DVD_DISC_SIDE pSide;
	ULONG pNumOfTitles;
	if(m_pDvdInfo)
		m_pDvdInfo->GetCurrentVolumeInfo(&pNumOfVol, 
				&pThisVolNum, &pSide, &pNumOfTitles);

	return pNumOfTitles;
}

void CDVDNavMgr::DVDSetParentControlLevel(ULONG bLevel)
{
	if(m_pDvdControl)
		m_pDvdControl->ParentalLevelSelect(bLevel);
}

void CDVDNavMgr::DVDChangePlaySpeed(double dwSpeed)
{
	if(DVDIsInitialized() && m_pDvdControl)
	{
		if(SUCCEEDED(m_pDvdControl->ForwardScan(dwSpeed)))
		{
			if(dwSpeed == 1.0)
				m_State = PLAYING;
			else
				m_State = SCANNING;
		}
	}
}

void CDVDNavMgr::DVDTimeSearch(ULONG ulTime)
{
	if(DVDIsInitialized() && m_pDvdControl)
		m_pDvdControl->TimeSearch(ulTime);
}

void CDVDNavMgr::DVDTimePlay(ULONG ulTitle, ULONG ulTime)
{
	if(DVDIsInitialized() && m_pDvdControl)
		m_pDvdControl->TimePlay(ulTitle, ulTime);
}

//Use IBasicAudio first, if it is NULL then use system audio control.
//bVol == TRUE, do Volume control, bVol == FALSE, do Balance control
//bSet == TRUE, do Set value, bSet == FALSE, do get volue. 
BOOL CDVDNavMgr::DVDVolumeControl(BOOL bVol, BOOL bSet, long *plValue)
{
	IBasicAudio *pAudio;
	HRESULT hr = m_pDvdGB->GetDvdInterface(IID_IBasicAudio, (LPVOID *)&pAudio);
	if(pAudio)
	{
		hr = -1;
		if(bVol && bSet)
			hr = pAudio->put_Volume(*plValue);
		else if(bVol && !bSet)
			hr = pAudio->get_Volume(plValue);
		else if(!bVol && bSet)
			hr = pAudio->put_Balance(*plValue);
		else if(!bVol && !bSet)
			hr = pAudio->get_Balance(plValue);

		pAudio->Release();
		if(SUCCEEDED(hr))
			return TRUE;
	}

	return FALSE;
}

//use system audio control
BOOL CDVDNavMgr::DVDSysVolControl()
{
	WinExec("sndvol32.exe", SW_SHOW);
	return TRUE;
}

BOOL CDVDNavMgr::GetBasicAudioState()
{
	IBasicAudio *pAudio = NULL;
	HRESULT hr = m_pDvdGB->GetDvdInterface(IID_IBasicAudio, (LPVOID *)&pAudio);
	if( SUCCEEDED(hr) && pAudio)
	{
		pAudio->Release();
		return TRUE;
	}
	return FALSE;
}

BOOL CDVDNavMgr::DVDGetRoot(LPSTR pRoot, ULONG cbBufSize, ULONG *pcbActualSize)
{
	if(m_pDvdControl)
	{
		HRESULT hr = m_pDvdInfo->GetRoot(pRoot, cbBufSize, pcbActualSize);
		if(SUCCEEDED(hr) && *pcbActualSize != 0)
			return TRUE;
	}
	return FALSE;
}

BOOL CDVDNavMgr::IsVideoWindowMaximized()
{
	IVideoWindow *pVW = NULL;
	HRESULT       hr ;
	hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (void **)&pVW) ;
	if(SUCCEEDED(hr) && NULL != pVW)
	{
		long lState=-1;
		hr = pVW->get_WindowState(&lState);
		pVW->Release();
		if( lState == SW_MAXIMIZE         || 
			lState == SW_SHOWMINNOACTIVE  || //IVideoWindow returns this when Miximized
			lState == SW_SHOWMAXIMIZED )
			return TRUE;
	}
	return FALSE;
}

//Change settings from Navigator's default to the App's default
void CDVDNavMgr::DVDInitNavgator()
{
	UINT nLevel = ((CDvdplayApp*) AfxGetApp())->GetParentCtrlLevel();
	DVDSetParentControlLevel(nLevel);	

	// Set default aspect ratio to normal/widescreen
    DVDVideoNormal() ;

	//Set subPicture off by default
	DVDSubPictureOn(FALSE);
}

BOOL CDVDNavMgr::DVDResetGraph()
{
	((CDvdplayApp*) AfxGetApp())->WriteVideoWndPos();
	ReleaseAllInterfaces();
	return DVDOpenDVD_ROM();
}


//
// Set up a timer to do something every now and then to keep the screen saver
// from activating.  This seems to be the most reliable and free of side effects
// method.
//
void CDVDNavMgr::SetupTimer() {
   //
   // When we go to Play from any state other than stopped, the timer
   // may already exist.
   //
   if (m_TimerId) {
      DbgLog((LOG_TRACE,2,"timer already exists"));
      //StopTimer();
      return;
   }

   unsigned int TimeOut;
   BOOL bActive;
   if (SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &bActive, 0) == 0) {
      DbgLog((LOG_ERROR,2,"Cannot get screen saver state, assuming enabled with timeout > 30 seconds"));
      TimeOut = 30;
   }
   else if (!bActive) {
      DbgLog((LOG_TRACE,2,"The screen saver is not active (yet), will set up a 30 second timer in case it becomes active later"));
      TimeOut = 30;
   }
   else if (SystemParametersInfo(SPI_GETSCREENSAVETIMEOUT, 0, &TimeOut, 0) == 0) {
      DbgLog((LOG_ERROR,2,"Cannot get screen saver timeout, defaulting timer interval to 30 seconds"));
      TimeOut = 30;
   }
   else {
      if (TimeOut <= 1) {
         DbgLog((LOG_TRACE,2,"Got the screen saver timeout, but it's a weird value (%d), so let's try setting our timer to 1 second", TimeOut));
         TimeOut = 1;
      }
      else {
         DbgLog((LOG_TRACE,2,"Screen saver timeout claims to be %d, so we'll set ours to %d",TimeOut,TimeOut-1));
         TimeOut--;
      }
   }
   m_TimerId = SetTimer(((CDvdplayApp*)AfxGetApp())->GetUIWndPtr()->m_hWnd,
                        TIMER_ID,
                        TimeOut * 1000,
                        NULL);
}

void CDVDNavMgr::StopTimer() {
   if (m_TimerId)
      KillTimer(((CDvdplayApp*)AfxGetApp())->GetUIWndPtr()->m_hWnd, TIMER_ID);
   m_TimerId = 0;
}

#if 0
//
// There are several ways to keep the screen saver from kicking in while we
// are in the middle of playback, this one works but it is not the best one
// (see the comment in front of CDvdUIDlg::OnSysCommand() to see what the
// other ways is and why they are better).  Still, let's keep the code around
// just in case the other ways don't prove to work so well.
//
//
// Remember current screen saver state and disable it if enabled.
//
// BUGBUG: I don't think it's possible, but shouldn't the screen
// saver state somehow be locked during this function to keep other
// apps that may be doing the same thing from racing with us ?
//
void CDVDNavMgr::DisableScreenSaver() {
   if (SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &m_bNeedToReenableScreenSaver, 0) == 0) {
      DbgLog((LOG_ERROR,2,"Cannot get screen saver state"));
      m_bNeedToReenableScreenSaver = FALSE;
   }
   else {
       if (m_bNeedToReenableScreenSaver) {
          DbgLog((LOG_TRACE,2,"Screen saver enabled, trying to disable"));
          if (SystemParametersInfo( SPI_SETSCREENSAVEACTIVE, FALSE, 0, 0) == 0) {
             DbgLog((LOG_ERROR,2,"Failed to disable the screen saver"));
             m_bNeedToReenableScreenSaver = FALSE;
          }
          else {
             DbgLog((LOG_TRACE,2,"Successfully disabled the screen saver"));
          }
       }
       else {
          DbgLog((LOG_TRACE,2,"Screen saver already disabled"));
       }
   }
}

//
// Reenable the screen saver if it was enabled before playback started
//
void CDVDNavMgr::ReenableScreenSaver() {
   if (m_bNeedToReenableScreenSaver) {
      DbgLog((LOG_TRACE,2,"Flag says reenable the screen saver"));
      if (SystemParametersInfo( SPI_SETSCREENSAVEACTIVE, TRUE, 0, 0) == 0) {
         DbgLog((LOG_ERROR,2,"Failed to reenable the screen saver"));
      }
      else {
         DbgLog((LOG_TRACE,2,"Successfully reenabled the screen saver"));
         m_bNeedToReenableScreenSaver = FALSE; // just in case this is called again
      }
   }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\navmgr.h ===
// Microsoft's Navigator Engine
#ifndef _H_NAVMGR
#define _H_NAVMGR

interface IDvdControl;
interface IDvdInfo;
interface IAMLine21Decoder;

#define NO_CC_IN_ERROR  1
#define CC_OUT_ERROR    2

#if DEBUG
#include "test.h"
#endif

class CDVDNavMgr
{
public:
	CDVDNavMgr();
	virtual ~CDVDNavMgr();	

	BOOL DVDCanPlay() { return m_State==STOPPED || m_State==PAUSED || m_State==SCANNING; };
	BOOL DVDCanStop() { return m_State==PLAYING || m_State==PAUSED || m_State==SCANNING; };
	BOOL DVDCanPause(){ return m_State==PLAYING || m_State==SCANNING; };	
	BOOL DVDIsInitialized()      { return m_State!=UNINITIALIZED; }
	BOOL DVDCanChangeSpeed()     { return (m_State==PLAYING || m_State==SCANNING); }
	BOOL IsPlaying()             { return m_State==PLAYING ; };
	BOOL IsFullScreenMode()      { return m_bFullScreen; };
	void SetStillOn(BOOL On)     { m_bStillOn = On; if(On) m_State=PAUSED; else m_State=SCANNING; };
	BOOL GetStillOn()            { return m_bStillOn; };
	BOOL IsMenuOn()              { return m_bMenuOn; };
	void SetMenuOn(BOOL On)      { m_bMenuOn = On; };	
	IDvdInfo* GetDvdInfo()       { return m_pDvdInfo; };
	BYTE GetCCErrorFlag()        { return m_bCCErrorFlag; };
	BOOL IsCCOn()                { return m_bCCOn; };
	BOOL GetVWInitState()        { return m_bInitVWSize; };
	void SetNeedInitNav(BOOL b)  { m_bNeedInitNav = b;};
	BOOL IsGBNull()              { return m_pDvdGB == NULL; };

	BOOL DVDPlay();
	void DVDPause();
	void DVDStop();
	void DVDSlowPlayBack();
	void DVDFastForward();
	void DVDFastRewind();
	void DVDVeryFastForward();
	void DVDVeryFastRewind();
	void DVDPressButton(int);
	void DVDSubPictureOn(BOOL);
	void DVDSubPictureSel(int iSel);
	void DVDCursorDown();
	void DVDCursorLeft();
	void DVDCursorRight();
	void DVDCursorSelect();
	void DVDCursorUp();
	void DVDAudioStreamChange(ULONG Stream);
	void DVDStillOff();
	void DVDNextProgramSearch();
	void DVDPreviousProgramSearch();
	void DVDTopProgramSearch();
	void DVDPlayPTT(ULONG title, ULONG ptt);
	void DVDPlayTitle(ULONG title);
	void DVDMenuVtsm(DVD_MENU_ID MenuID);
	void DVDMenuResume();
	void DVDChapterSearch(ULONG Chapter);
	void DVDGoUp();
	void DVDAngleChange(ULONG angle);
	void DVDVideoNormal();
	void DVDVideoPanscan();
	void DVDVideoLetterbox();
	void DVDVideo169();
	void DVDOnShowFullScreen();
	void DVDStartFullScreenMode() ;
	void DVDStopFullScreenMode() ;
	void MessageDrainOn(BOOL on);
	void DVDSetPersistentVideoWindow();
	void DVDSetVideoWindowSize(long iLeft, long iTop, long iWidth, long iHeight);	
	void DVDGetVideoWindowSize(long *left, long *top, long *iWidth, long *iHeight);
	BOOL DVDMouseClick(CPoint point);
	BOOL DVDMouseSelect(CPoint point);
	BOOL DVDOpenFile(LPCWSTR);
	BOOL DVDOpenDVD_ROM(LPCWSTR lpszPathName=NULL);
	ULONG DVDQueryNumTitles();
	void DVDSetParentControlLevel(ULONG bLevel);
	void DVDSetVideoWindowCaption(BSTR lpCaption);
	void DVDInitVideoWindowSize();
	void DVDChangePlaySpeed(double dwSpeed);
	void DVDTimeSearch(ULONG ulTime);
	void DVDTimePlay(ULONG ulTitle, ULONG ulTime);
	void DVDGetAngleInfo(ULONG* pnAnglesAvailable, ULONG* pnCurrentAngle);
	BOOL DVDCCControl();
	BOOL IsCCEnabled();
	BOOL DVDVolumeControl(BOOL bVol, BOOL bSet, long *plValue);
	BOOL DVDSysVolControl();
	BOOL GetBasicAudioState();
	BOOL DVDGetRoot(LPSTR pRoot, ULONG cbBufSize, ULONG *pcbActualSize);
	BOOL IsVideoWindowMaximized();
	BOOL DVDResetGraph();

#if DEBUG
     BOOL t_Verify (CURRENT_STATE, ULONG);
#endif     

private:
	enum {UNINITIALIZED, STOPPED, PAUSED, PLAYING, SCANNING } m_State;

	IDvdGraphBuilder *m_pDvdGB;
	IGraphBuilder    *m_pGraph;
	IDvdInfo         *m_pDvdInfo;
	IDvdControl      *m_pDvdControl;
	IMediaEventEx    *m_pMediaEventEx;
	IAMLine21Decoder *m_pL21Dec;

	void    subPictStreamChange(ULONG bStream, BOOL bShow);
	HRESULT getSPRM(UINT uiSprm, WORD * pWord);
	void    ReleaseAllInterfaces(void);
	void    DVDInitNavgator();
   
   //void DisableScreenSaver();
   //void ReenableScreenSaver();
   //BOOL  m_bNeedToReenableScreenSaver;
   void SetupTimer();
   void StopTimer();

   UINT_PTR m_TimerId;

	BOOL  m_bShowSP;
	BOOL  m_bFullScreen;
	BOOL  m_bMenuOn;
	BOOL  m_bStillOn;
	BOOL  m_bCCOn;
	DWORD m_dwRenderFlag ;    // flags to use for building graph
	HWND  m_hWndMsgDrain;
	BYTE  m_bCCErrorFlag;
	BOOL  m_bInitVWSize;
	BOOL  m_bNeedInitNav;
};

/////////////////////////////////////////////////////////////////////////////
#endif	// _H_NAVMGR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\parenctl.h ===
#if !defined(AFX_PARENCTL_H__BF82BEA1_E0BA_11D0_8A6A_00AA00605CD5__INCLUDED_)
#define AFX_PARENCTL_H__BF82BEA1_E0BA_11D0_8A6A_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ParenCtl.h : header file
//

#define LEVEL_G		1
#define LEVEL_PG	3
#define LEVEL_PG13	4
#define LEVEL_R		6
#define LEVEL_NC17	7
#define LEVEL_ADULT	8

class CDVDNavMgr;
/////////////////////////////////////////////////////////////////////////////
// CParentControl dialog

class CParentControl : public CDialog
{
// Construction
public:
	CParentControl(CWnd* pParent = NULL);   // standard constructor	
	static void SetRate(LPCTSTR csRate);

// Dialog Data
	//{{AFX_DATA(CParentControl)
	enum { IDD = IDD_DIALOG_PARENT_CONTROL };
	CButton	m_ctlBtnChangePasswd;
	CStatic	m_ctlStaticPasswd;
	CStatic	m_ctlHeight2;
	CStatic	m_ctlHeight1;
	CEdit	m_ctlConfirm;
	CEdit	m_ctlNewPasswd;
	CEdit	m_ctlPassword;
	CListBox	m_ctlListName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CParentControl)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void InitListBox();
	void ChangeWindowSize(int iSize);
	void Killtimer();	
	void GuestLogon();

	CDVDNavMgr* m_pDVDNavMgr;
	int         m_iFullHeight;
	int         m_iFullWidth;
	LPTSTR      m_lpProfileName;
	int         m_iTimeCount;
	BOOL        m_bChangePasswd;
	BOOL        m_bTimerAlive;

	// Generated message map functions
	//{{AFX_MSG(CParentControl)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeListName();
	virtual void OnOK();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnButtonChangePassword();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	virtual void OnCancel();
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PARENCTL_H__BF82BEA1_E0BA_11D0_8A6A_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\parenctl.cpp ===
// ParenCtl.h.cpp : implementation file
//

#include "stdafx.h"
#include "dvdplay.h"
#include "ParenCtl.h"
#include "navmgr.h"
#include "admlogin.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CParentControl dialog


CParentControl::CParentControl(CWnd* pParent /*=NULL*/)
	: CDialog(CParentControl::IDD, pParent)
{
	//{{AFX_DATA_INIT(CParentControl)
	//}}AFX_DATA_INIT
	m_pDVDNavMgr = NULL;
	m_bChangePasswd = FALSE;
	m_bTimerAlive   = FALSE;
}


void CParentControl::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CParentControl)
	DDX_Control(pDX, IDC_BUTTON_CHANGE_PASSWORD, m_ctlBtnChangePasswd);
	DDX_Control(pDX, IDC_STATIC_PASSWORD, m_ctlStaticPasswd);
	DDX_Control(pDX, IDC_STATIC_HEIGHT2, m_ctlHeight2);
	DDX_Control(pDX, IDC_STATIC_HEIGHT1, m_ctlHeight1);
	DDX_Control(pDX, IDC_EDIT_CONFIRM_NEW, m_ctlConfirm);
	DDX_Control(pDX, IDC_EDIT_NEW_PASSWORD, m_ctlNewPasswd);
	DDX_Control(pDX, IDC_EDIT_PASSWORD, m_ctlPassword);
	DDX_Control(pDX, IDC_LIST_NAME, m_ctlListName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CParentControl, CDialog)
	//{{AFX_MSG_MAP(CParentControl)
	ON_LBN_SELCHANGE(IDC_LIST_NAME, OnSelchangeListName)
	ON_WM_TIMER()
	ON_BN_CLICKED(IDC_BUTTON_CHANGE_PASSWORD, OnButtonChangePassword)
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CParentControl message handlers

BOOL CParentControl::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	CRect rc;
	GetWindowRect(&rc);
	m_iFullHeight = rc.Height();
	m_iFullWidth  = rc.Width();
	m_pDVDNavMgr = ((CDvdplayApp*) AfxGetApp())->GetDVDNavigatorMgr();
	if(!m_pDVDNavMgr)
		return FALSE;

	m_lpProfileName = ((CDvdplayApp*) AfxGetApp())->GetProfileName();

	ChangeWindowSize(1);

	InitListBox();
	m_ctlBtnChangePasswd.EnableWindow(FALSE);
	
	m_iTimeCount = 0;
	SetTimer(1, 1000, NULL);
	m_bTimerAlive = TRUE;

	m_ctlPassword.SetWindowText(_T(""));
	m_ctlNewPasswd.SetWindowText(_T(""));
	m_ctlConfirm.SetWindowText(_T(""));	

	m_ctlPassword.LimitText(MAX_PASSWD);
	m_ctlNewPasswd.LimitText(MAX_PASSWD);
	m_ctlConfirm.LimitText(MAX_PASSWD);	
   SetForegroundWindow();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CParentControl::InitListBox()
{
	CString csStr;

	if(!((CDvdplayApp*) AfxGetApp())->GetProfileStatus())
		return;

	int iNumOfUser = CAdminLogin::GetNumOfUser(m_lpProfileName);
	if(iNumOfUser == 0)
		return;

	TCHAR szCurrentUserNum[MAX_NUMUSER];
	TCHAR szSectionName[MAX_SECTION];
	TCHAR szUserName[MAX_NAME];
	
	for (int i=1; i<iNumOfUser+1; i++)
	{
		lstrcpy(szUserName, _T(""));
		_itot(i, szCurrentUserNum, 10);
		csStr.LoadString(IDS_INI_USER);
		lstrcpy(szSectionName, csStr);
		lstrcat(szSectionName, szCurrentUserNum);

		csStr.LoadString(IDS_INI_USERNAME);
		GetPrivateProfileString(szSectionName, csStr, 
		              NULL, szUserName, MAX_NAME, m_lpProfileName);
		
		if( lstrcmp(szUserName, _T("")) > 0)
			m_ctlListName.AddString(szUserName);
	}
	
	csStr.LoadString(IDS_GUEST);
	int iGuest = m_ctlListName.FindString(-1, csStr);
	if(iGuest == LB_ERR) //Guest not found, no user is highlighted
		m_ctlListName.SetCurSel(-1);
	else                 //Guest found, highlight it
		m_ctlListName.SetCurSel(iGuest);
}

void CParentControl::ChangeWindowSize(int iSize)
{
	CRect rc;	
	if(iSize == 1)
		m_ctlHeight1.GetWindowRect(&rc);
	if(iSize == 2)
		m_ctlHeight2.GetWindowRect(&rc);
	int iHeight = rc.Height();
	if(iSize == 3)
		iHeight = m_iFullHeight;

	SetWindowPos(NULL, 0, 0, m_iFullWidth, iHeight, SWP_NOMOVE);
}

void CParentControl::OnSelchangeListName() 
{	
	Killtimer();
	m_bChangePasswd = FALSE;
	int iSelect = m_ctlListName.GetCurSel();	
	if(iSelect != LB_ERR)
	{
		CString csGuest, csSelectedUser;
		csGuest.LoadString(IDS_GUEST);
		m_ctlListName.GetText(iSelect, csSelectedUser);
		if(csSelectedUser == csGuest) //Guest login
		{
			m_ctlBtnChangePasswd.EnableWindow(FALSE);
			ChangeWindowSize(1);
		}
		else
		{
			m_ctlBtnChangePasswd.EnableWindow(TRUE);
			CString csCaption;
			csCaption.LoadString(IDS_PASSWORD);
			m_ctlStaticPasswd.SetWindowText(csCaption);
			ChangeWindowSize(2);
		}
	}	
}

void CParentControl::OnOK() 
{
	Killtimer();
	TCHAR szPassword[MAX_PASSWD];
	m_ctlPassword.GetWindowText(szPassword, MAX_PASSWD);

	int iSelect = m_ctlListName.GetCurSel();
	if(iSelect == LB_ERR) //no one is selected, login as Guest
	{
		CString csSel;
		csSel.LoadString(IDS_NO_USER_SELECTED_GUEST_LOGON);
		if(DVDMessageBox(m_hWnd, csSel, NULL, MB_YESNO) == IDNO)
		{
			m_ctlListName.SetCurSel(-1);
			return;
		}
		GuestLogon();
	}
	else   //Selected a user
	{
		CString csGuest, csSelectedUser;
		csGuest.LoadString(IDS_GUEST);
		m_ctlListName.GetText(iSelect, csSelectedUser);
		if(csSelectedUser != csGuest)  //Selected a user other than Guest
		{
			if(lstrcmp(szPassword, _T("")) == 0)
			{
				DVDMessageBox(this->m_hWnd, IDS_ENTER_PASSWORD);
				m_ctlPassword.SetFocus();				
				return;
			}

			TCHAR szNewPassword[MAX_PASSWD];
			TCHAR szConfirmPasswd[MAX_PASSWD];
			if(m_bChangePasswd)
			{
				m_ctlNewPasswd.GetWindowText(szNewPassword, MAX_PASSWD);
				if(lstrcmp(szNewPassword, _T("")) == 0)
				{
					DVDMessageBox(this->m_hWnd, IDS_TYPE_A_NEW_PASSWORD);
					m_ctlNewPasswd.SetFocus();
					return;
				}
				m_ctlConfirm.GetWindowText(szConfirmPasswd, MAX_PASSWD);
				if(lstrcmp(szConfirmPasswd, _T("")) == 0)
				{
					DVDMessageBox(this->m_hWnd, IDS_CONFIRM_NEW_PASSWORD);
					m_ctlConfirm.SetFocus();
					return;
				}
				if(lstrcmp(szNewPassword, szConfirmPasswd) != 0)
				{
					DVDMessageBox(this->m_hWnd, IDS_PASSOWRD_CONFIRM_WRONG);
					m_ctlConfirm.SetWindowText(_T(""));
					m_ctlConfirm.SetFocus();
					return;
				}
			}
			
			int   iNumOfUser;
			TCHAR szUserName[MAX_NAME];
			TCHAR szSectionName[MAX_SECTION];
			TCHAR szSavedPasswd[MAX_PASSWD];
			TCHAR szUserRate[MAX_RATE];
			CString csStr;

			m_ctlListName.GetText(iSelect, szUserName);
			iNumOfUser = CAdminLogin::GetNumOfUser(m_lpProfileName);
			if(CAdminLogin::SearchProfileByName(m_lpProfileName, szUserName, szSectionName))
			{
				csStr.LoadString(IDS_INI_PASSWORD);
				GetPrivateProfileString(szSectionName, csStr, NULL, 
										szSavedPasswd, MAX_PASSWD, m_lpProfileName);
				CAdminLogin::EncryptPassword(szPassword);
				if(lstrcmp(szPassword, szSavedPasswd) == 0  ||       // password matched  OR
                   CAdminLogin::Win98vsWin2KPwdMismatch(szPassword, szSavedPasswd, szSectionName)) // mismatch on W98->W2K upgrade
				{
					csStr.LoadString(IDS_INI_RATE);
					GetPrivateProfileString(szSectionName, csStr, NULL,
											szUserRate, MAX_RATE, m_lpProfileName);
					SetRate(szUserRate);
					((CDvdplayApp*) AfxGetApp())->SetCurrentUser(szUserName);
					if(m_bChangePasswd)
					{					
						CAdminLogin::EncryptPassword(szNewPassword);
						csStr.LoadString(IDS_INI_PASSWORD);
						WritePrivateProfileString(szSectionName, csStr, 
												  szNewPassword, m_lpProfileName);				
					}
				}
				else
				{
					DVDMessageBox(this->m_hWnd, IDS_PASSWORD_INCORRECT);
					m_ctlPassword.SetWindowText(_T(""));
					m_ctlPassword.SetFocus();
					return;
				}
			}
			else      //this case may never happen
			{
				DVDMessageBox(this->m_hWnd, IDS_USER_NAME_NOT_FOUND_LOGON_AS_GUEST);
				GuestLogon();
			}
		}
		else     //Default: Guest Logged on
			GuestLogon();
	}

	CDialog::OnOK();
}

void CParentControl::GuestLogon()
{
	HINSTANCE hInstance = ((CDvdplayApp*) AfxGetApp())->m_hInstance;
	TCHAR szSectionName[MAX_SECTION], szUserRate[MAX_RATE] = _T("");
	TCHAR szUser[MAX_NAME], szRate[MAX_RATE];

	LoadString(hInstance, IDS_GUEST,    szUser, MAX_NAME);
	LoadString(hInstance, IDS_INI_RATE, szRate, MAX_RATE);

	((CDvdplayApp*) AfxGetApp())->SetCurrentUser(szUser);

	//see if Guest is in dvdplay.ini
	if(CAdminLogin::SearchProfileByName(m_lpProfileName, szUser, szSectionName))
		GetPrivateProfileString(szSectionName, szRate, NULL, szUserRate, MAX_RATE, m_lpProfileName);

	//If Guest not in dvdplay.ini or error getting the rate, use default Guest rate PG
	if(szUserRate[0] == 0)
		LoadString(hInstance, IDS_INI_RATE_PG, szUserRate, MAX_RATE);

	SetRate(szUserRate);	
}

void CParentControl::SetRate(LPCTSTR lpRate)
{
	CString csStr;
	csStr.LoadString(IDS_INI_RATE_G);
	if(lstrcmp(lpRate, csStr) == 0)
		((CDvdplayApp*) AfxGetApp())->SetParentCtrlLevel(LEVEL_G);
	csStr.LoadString(IDS_INI_RATE_PG);
	if(lstrcmp(lpRate, csStr) == 0)
		((CDvdplayApp*) AfxGetApp())->SetParentCtrlLevel(LEVEL_PG);
	csStr.LoadString(IDS_INI_RATE_PG13);
	if(lstrcmp(lpRate, csStr) == 0)
		((CDvdplayApp*) AfxGetApp())->SetParentCtrlLevel(LEVEL_PG13);
	csStr.LoadString(IDS_INI_RATE_R);
	if(lstrcmp(lpRate, csStr) == 0)
		((CDvdplayApp*) AfxGetApp())->SetParentCtrlLevel(LEVEL_R);
	csStr.LoadString(IDS_INI_RATE_NC17);
	if(lstrcmp(lpRate, csStr) == 0)
		((CDvdplayApp*) AfxGetApp())->SetParentCtrlLevel(LEVEL_NC17);
	csStr.LoadString(IDS_INI_RATE_ADULT);
	if(lstrcmp(lpRate, csStr) == 0)
		((CDvdplayApp*) AfxGetApp())->SetParentCtrlLevel(LEVEL_ADULT);
}

void CParentControl::OnTimer(UINT nIDEvent) 
{
	m_iTimeCount++;
	if(m_iTimeCount == 60)
	{
		Killtimer();
		if(GetSafeHwnd() != 0)
			OnOK();	
	}

	CDialog::OnTimer(nIDEvent);
}

void CParentControl::OnButtonChangePassword() 
{
	Killtimer();
	CString csCaption;
	csCaption.LoadString(IDS_OLD_PASSWORD);
	m_ctlStaticPasswd.SetWindowText(csCaption);
	ChangeWindowSize(3);
	m_ctlNewPasswd.SetWindowText(_T(""));
	m_ctlNewPasswd.SetFocus();
	m_ctlConfirm.SetWindowText(_T(""));
	m_bChangePasswd = TRUE;
}

void CParentControl::OnLButtonDown(UINT nFlags, CPoint point) 
{
	Killtimer();	
	CDialog::OnLButtonDown(nFlags, point);
}

void CParentControl::OnCancel() 
{
	Killtimer();
	CDialog::OnCancel();
}

void CParentControl::OnRButtonDown(UINT nFlags, CPoint point) 
{
	Killtimer();
	CDialog::OnRButtonDown(nFlags, point);
}

void CParentControl::Killtimer()
{
	if(m_bTimerAlive)
	{
		KillTimer(1);
		m_bTimerAlive = FALSE;
	}
}

BOOL CParentControl::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
        AfxGetApp()->WinHelp( pHelpInfo->dwContextId, HELP_CONTEXTPOPUP);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\openfile.cpp ===
// openfile.cpp : implementation file
// This file overwite 2 virtual functions of CFileDialog
// The purpose is to allow user not to click DVD file, just its folder.

#include "stdafx.h"
#include "dvdplay.h"
#include "openfile.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COpenFile dialog


COpenFile::COpenFile(BOOL bOpenFileDialog, LPCTSTR lpszDefExt, LPCTSTR lpszFileName, 
					 DWORD dwFlags, LPCTSTR lpszFilter, CWnd* pParentWnd)
	: CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags, lpszFilter, pParentWnd)
{
	//{{AFX_DATA_INIT(COpenFile)
	//}}AFX_DATA_INIT
}

BEGIN_MESSAGE_MAP(COpenFile, CFileDialog)
	//{{AFX_MSG_MAP(COpenFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COpenFile message handlers
void COpenFile::OnInitDone( )
{
	CString csDir = GetFolderPath();
	CWnd *pCtrl = GetParent()->GetWindow(GW_CHILD);
	// Get ID of edit box in CFileDialog
	do
	{
		TCHAR psz[128];
		GetClassName(pCtrl->m_hWnd, psz, 127);		
		if(!_tcscmp(psz, TEXT("Edit")))
		{
			// m_nIdEditCtrl = pCtrl->GetDlgCtrlID();
			// SetControlText(m_nIdEditCtrl, csDir);
         m_hWndIdEditCtrl = pCtrl->m_hWnd;
         ::SetWindowText(m_hWndIdEditCtrl, csDir);
		}
	}while( (pCtrl = pCtrl->GetWindow(GW_HWNDNEXT)) ) ;		
}

void COpenFile::OnFolderChange( )
{	
	CString csFolderPath = GetFolderPath();
	CString csDrive = csFolderPath.Left(3);

	TCHAR achDVDFilePath1[MAX_PATH], achDVDFilePath2[MAX_PATH];
	// If DVD disc, the DVD file is in the root dir
	if( GetDriveType(csDrive) == DRIVE_CDROM)
	{		
		lstrcpy(achDVDFilePath1, csDrive);
		lstrcpy(achDVDFilePath2, csDrive);
		lstrcat(achDVDFilePath1, _T("Video_ts\\Video_ts.ifo"));
		lstrcat(achDVDFilePath2, _T("Video_ts\\Vts_01_0.ifo"));
	}
	// If not a DVD disc, DVD file could be in anywhere
	else
	{
		lstrcpy(achDVDFilePath1, csFolderPath);
		lstrcpy(achDVDFilePath2, csFolderPath);

		TCHAR slash = '\\';
		if( achDVDFilePath1[lstrlen(achDVDFilePath1)-1] != slash )
			lstrcat(achDVDFilePath1, _T("\\"));
		if( achDVDFilePath2[lstrlen(achDVDFilePath2)-1] != slash )
			lstrcat(achDVDFilePath2, _T("\\"));
		lstrcat(achDVDFilePath1, _T("Video_ts.ifo"));
		lstrcat(achDVDFilePath2, _T("Vts_01_0.ifo"));
	}
	// If DVD file is found, put it in edit box, so click OK will get it
	if( ((CDvdplayApp*) AfxGetApp())->DoesFileExist(achDVDFilePath1) &&
		((CDvdplayApp*) AfxGetApp())->DoesFileExist(achDVDFilePath2) )			
	//	SetControlText(m_nIdEditCtrl, achDVDFilePath1);
      ::SetWindowText(m_hWndIdEditCtrl, achDVDFilePath1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\resource.h ===
#pragma warning (disable : 4005)
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dvdplay.rc
//
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDR_MAINFRAME                   128
#define IDD_VIDEO_WINDOW                130
#define IDD_UI_WINDOW                   131
#define IDD_DIALOG_AUDIO_VOLUME         132
#define IDR_MENU_OPTIONS                133
#define IDR_MENU_OPERATIONS             134
#define IDR_MENU_TITLE                  135
#define IDR_MENU_CHAPTER                136
#define IDD_DIALOG_SUBTITLE             137
#define IDD_DIALOG_AUDIO_LANGUAGE       138
#define IDR_MENU_ARROWS                 139
#define IDR_MENU_DOCK                   140
#define IDD_DIALOG_PARENT_CONTROL       144
#define IDD_DIALOG_ADMIN_LOGIN          145
#define IDD_DIALOG_SET_RATE             146
#define IDR_MENU_TITLE_CHAPTER          149
#define IDD_DIALOG_SEARCH_TITLE         150
#define IDD_DIALOG_SEARCH_CHAPTER       151
#define IDR_MENU_DVDLOGO                152
#define IDR_MENU_VIDEOWIN               206
#define IDD_DIALOG_ADMIN_PASSWD         218
#define IDB_PLAY                        1000
#define IDC_PLAY                        1000
#define IDB_STOP                        1001
#define IDC_STOP                        1001
#define IDB_PAUSE                       1003
#define IDC_PAUSE                       1003
#define IDB_EJECT                       1004
#define IDB_FULL_SCREEN                 1005
#define IDC_FULL_SCREEN                 1005
#define IDB_FAST_FORWARD                1006
#define IDC_FAST_FORWARD                1006
#define IDB_FAST_REWIND                 1007
#define IDC_FAST_REWIND                 1007
#define IDB_VERY_FAST_FORWARD           1008
#define IDC_VERY_FAST_FORWARD           1008
#define IDB_VERY_FAST_REWIND            1009
#define IDC_VERY_FAST_REWIND            1009
#define IDB_UP                          1010
#define IDC_UP                          1010
#define IDB_AUDIO_VOLUME                1011
#define IDC_AUDIO_VOLUME                1011
#define IDB_DOWN                        1012
#define IDC_DOWN                        1012
#define IDB_RIGHT                       1013
#define IDC_RIGHT                       1013
#define IDB_LEFT                        1014
#define IDC_LEFT                        1014
#define IDB_ENTER                       1015
#define IDC_ENTER                       1015
#define IDB_MENU                        1016
#define IDC_MENU                        1016
#define IDB_HELP                        1017
// Get rid of the commonly defined one to avoid warnings.
#undef IDC_HELP
#define IDC_HELP                        1017
#define IDB_STEP                        1018
#define IDB_OPTIONS                     1019
#define IDC_OPTIONS                     1019
#define IDC_STATIC_TITLE                1020
#define IDC_SLIDER_BALANCE              1021
#define IDC_CHECK_SHOW_LOGON            1022
#define IDC_STATIC_CHAPTER              1023
#define IDC_STATIC_PROGRESS             1024
#define IDC_CHECK_MUTE                  1025
#define IDC_CHECK_SUBTITLE              1026
#define IDC_LIST_SUBTITLE               1027
#define IDC_LIST_AUDIO_LANGUAGE         1028
#define IDC_LIST_NAME                   1032
#define IDC_EDIT_PASSWORD               1033
#define IDC_EDIT_CONFIRM                1038
#define IDC_COMBO_RATE                  1043
#define IDC_BUTTON_SAVE                 1044
#define IDC_STATIC_SELECT_NAME          1045
#define IDC_LIST_USER_RATE              1046
#define IDC_EDIT_NAME                   1047
#define IDC_BUTTON_CHANGE_OLD           1048
#define IDC_BUTTON_CHANGE_PASSWORD      1051
#define IDC_EDIT_NEW_PASSWORD           1053
#define IDC_STATIC_NEW_PASSWORD         1054
#define IDC_STATIC_HEIGHT2              1055
#define IDC_STATIC_HEIGHT1              1056
#define IDC_STATIC_PASSWORD             1057
#define IDC_STATIC_CONFIRM              1058
#define IDC_EDIT_CONFIRM_NEW            1061
#define IDC_STATIC_CONFIRM_NEW          1062
#define IDC_EDIT_HOUR                   1079
#define IDC_EDIT_MINUTE                 1080
#define IDC_EDIT_SECOND                 1081
#define IDC_SPIN_HOUR                   1082
#define IDC_SPIN_MINUTE                 1083
#define IDC_SPIN_SECOND                 1084
#define IDC_EDIT_TITLE_NUMBER           1091
#define IDC_SPIN_TITLE_NUMBER           1092
#define IDB_EJECT_DISC                  1094
#define IDC_EJECT_DISC                  1094
#define IDC_BUTTON_CLOSE                1096
#define IDC_SLIDER_VOLUME               1097
#define IDC_STATIC_TIME                 1098
#define IDC_STATIC_TOTAL_TIME           1099
#define IDC_STATIC_SEL_SUBTITLE_LAN     1100
#define IDC_STATIC_SEL_AUDIO_LAN        1101
#define IDC_STATIC_START_PLAY           1102
#define IDC_STATIC_GROUP_CHAPTER        1103
#define IDC_STATIC_HOUR                 1104
#define IDC_STATIC_MINUTE               1105
#define IDC_STATIC_SECOND               1106
#define IDC_STATIC_BALANCE              1107
#define IDC_STATIC_VOLUME               1108
#define IDC_STATIC_SEL_USER_NAME        1109
#define IDC_STATIC_RATING               1111
#define IDC_STATIC_USER                 1112
#define IDC_CONTEXT_HELP                1113
#define IDC_STATIC_TITLE_NUM            1115
#define IDC_BUTTON_DELETE               1120
#define IDC_STATIC_ADMIN_PASSWD         1121
#define IDC_EDIT_ADMIN_PASSWD           1122
#define IDC_STATIC_RATE_HIGH            1123
#define ID_OPTIONS_SEARCHFORTEXT        32772
#define ID_OPTIONS_SETRATINGS           32773
#define ID_OPTIONS_CAPTUREVIDEO_ASWALLPAPER 32775
#define ID_OPTIONS_CAPTUREVIDEO_ASPICTURE 32776
#define ID_OPTIONS_PROGRAMTITLES        32777
#ifdef DISPLAY_OPTIONS
   #define ID_OPTIONS_DISPLAY_PANSCAN      32779
   #define ID_OPTIONS_DISPLAY_LETTERBOX    32780
#endif
#define ID_OPTIONS_AUDIO_STEREO         32794
#define ID_OPTIONS_CAMERAANGLES_ANGLE1  32795
#define ID_OPTIONS_CAMERAANGLES_ANGLE2  32796
#define ID_OPTIONS_CAMERAANGLES_ANGLE3  32797
#ifdef DISPLAY_OPTIONS
   #define ID_OPTIONS_DISPLAY_WIDE         32798
#endif
#define ID_OPERATION_PLAY               32799
#define ID_OPERATION_PAUSE              32800
#define ID_OPERATION_STOP               32801
#define ID_OPERATION_VERYFASTREWIND     32803
#define ID_OPERATION_FASTFORWARD        32804
#define ID_OPERATION_SKIP_PREVIOSCHAPTER 32807
#define ID_OPERATION_SKIP_NEXTCHAPTER   32808
#define ID_OPERATION_SKIP_PREVIOUSFRAME 32809
#define ID_OPERATION_SKIP_NEXTFRAME     32810
#define ID_OPERATION_PLAYSPEED_NORMALSPEED 32811
#define ID_OPERATION_PLAYSPEED_DOUBLESPEED 32812
#define ID_OPERATION_PLAYSPEED_HALFSPEED 32813
#define ID_OPERATION_MENU               32814
#define ID_OPERATION_FULLSCREEN         32815
#define ID_OPERATION_TOOLBAR            32816
#define ID_OPERATION_SETVOLUME          32817
#define ID_OPERATION_CAPTUREVIDEO       32818
#define ID_TITLE_PREVIOUS               32819
#define ID_TITLE_MAINTITLE              32820
#define ID_TITLE_CREDITS                32821
#define ID_TITLE_COOLMOVIEINFO          32822
#define ID_CHAPTER                      32823
#define ID_CHAPTER_GOOSHYKISSING        32824
#define ID_OPERATION_EJECTDISK          32825
#define ID_OPERATION_FASTREWIND         32826
#define ID_OPERATION_VERYFASTFORWARD    32827
#define ID_OPTIONS_SUBTITLES            32828
#define ID_ARROWS_UP                    32829
#define ID_ARROWS_DOWN                  32830
#define ID_ARROWS_LEFT                  32831
#define ID_ARROWS_RIGHT                 32832
#define ID_ARROWS_ENTER                 32833
#define ID_DOCK_DOCKTOTOPOFSCREEN       32834
#define ID_DOCK_SHOWASFLOATINGWINDOW    32835
#define ID_DOCK_HIDE                    32836
#define ID_OPTIONS_SELECTDISK_CURRENTDISK 32837
#define ID_SEARCH_TITLE                 32838
#define ID_SEARCH_CHAPTER               32839
#define ID_DVDLOGO_ABOUT                32842
#define ID_DVDLOGO_HELP                 32843
#define ID_OPTIONS_CAMERAANGLES_ANGLE4  32845
#define ID_OPTIONS_CAMERAANGLES_ANGLE5  32846
#define ID_OPTIONS_CAMERAANGLES_ANGLE6  32847
#define ID_OPTIONS_CAMERAANGLES_ANGLE7  32848
#define ID_OPTIONS_CAMERAANGLES_ANGLE8  32849
#define ID_OPTIONS_CAMERAANGLES_ANGLE9  32850
#define ID_VIDEOWIN_PLAY                32851
#define ID_VIDEOWIN_PAUSE               32852
#define ID_VIDEOWIN_STOP                32853
#define ID_VIDEOWIN_FASTFORWARD         32854
#define ID_VIDEOWIN_FASTREWIND          32855
#define ID_VIDEOWIN_VERYFASTFORWARD     32856
#define ID_VIDEOWIN_VERYFASTREWIND      32857
#define ID_VIDEOWIN_GOTO_PREVIOUSCHAPTER 32860
#define ID_VIDEOWIN_GOTO_NEXTCHAPTER    32861
#define ID_VIDEOWIN_FULLSCREEN          32863
#define ID_OPTIONS_CLOSEDCAPTION        32864
#define ID_OPTIONS_SELECT_DISC          32865
#define ID_OPTIONS_SHOW_LOGON           32866
#define ID_OPTIONS_LANGUAGE             32867
#define ID_VIDEOWIN_MENU                32868
#define ID_OPTIONS_TITLE_MENU           32869
#define ID_VIDEOWIN_EJECTDISK           32871
#define ID_VIDEOWIN_PLAYSPEED_NORMALSPEED 32872
#define ID_VIDEOWIN_PLAYSPEED_DOUBLESPEED 32873
#define ID_VIDEOWIN_PLAYSPEED_HALFSPEED   32874
#define IDS_CANT_PLAY                   61204
#define IDS_CANT_PAUSE                  61205
#define IDS_CANT_STOP                   61206
#define IDS_CANT_INIT_QUARTZ            61207
#define IDS_CANT_RENDER_FILE            61208
#define IDS_CANT_FIND_DVD               61209
#define IDS_VPE_NOT_WORKING             61210
#define IDS_EJECT                       61211
#define IDS_UNEJECT                     61212
#define IDS_ENTER_PASSWORD              61212
#define IDS_CONFIRM_NEW_PASSWORD        61213
#define IDS_PASSOWRD_CONFIRM_WRONG      61214
#define IDS_PASSWORD_INCORRECT          61215
#define IDS_TYPE_A_NEW_PASSWORD         61216
#define IDS_EJECT_CANNOT_FIND_DISC      61217
#define IDS_EJECT_CANNOT_EJECT          61218
#define IDS_USER_NAME_NOT_FOUND_LOGON_AS_GUEST 61219
#define IDS_TYPE_A_USER_NAME            61220
#define IDS_USER_ALREADY_EXISTS         61221
#define IDS_SELECT_A_NAME               61222
#define IDS_MSGBOX_TITLE                61223
#define IDS_NOT_A_VALID_DVD_FILE        61224
#define IDS_OLD_PASSWORD                61225
#define IDS_NEW_PASSWORD                61226
#define IDS_PASSWORD                    61227
#define IDS_RESUME                      61228
#define IDS_MENU                        61229
#define IDS_NOT_MEET_MS_LOGO            61230
#define IDS_OEM_FLAG_PATH               61231
#define IDS_OEM_FLAG_NAME               61232
#define IDS_PLAY_TIP                    61233
#define IDS_PAUSE_TIP                   61234
#define IDS_STOP_TIP                    61235
#define IDS_EJECT_DISC_TIP              61236
#define IDS_VERY_FAST_REWIND_TIP        61237
#define IDS_FAST_REWIND_TIP             61238
#define IDS_FAST_FORWARD_TIP            61239
#define IDS_VERY_FAST_FORWARD_TIP       61240
#define IDS_STEP_TIP                    61241
#define IDS_FULL_SCREEN_TIP             61242
#define IDS_AUDIO_VOLUME_TIP            61243
#define IDS_MENU_TIP                    61244
#define IDS_ENTER_TIP                   61245
#define IDS_UP_TIP                      61246
#define IDS_DOWN_TIP                    61247
#define IDS_LEFT_TIP                    61248
#define IDS_RIGHT_TIP                   61249
#define IDS_ABOUT_TIP                   61250
#define IDS_HELP_TIP                    61250
#define IDS_OPTIONS_TIP                 61251
#define IDS_ADM_LOGON_BOX_TITLE         61252
#define IDS_ADM_LOGON_MSG               61253
#define IDS_GUEST                       61254
#define IDS_INI_USER                    61255
#define IDS_INI_USERNAME                61256
#define IDS_INI_PASSWORD                61257
#define IDS_INI_RATE                    61258
#define IDS_INI_KIDSAFE                 61259
#define IDS_INI_RATE_G                  61259
#define IDS_INI_THEATRICAL              61260
#define IDS_INI_RATE_PG                 61260
#define IDS_INI_ADULT                   61261
#define IDS_INI_RATE_ADULT              61261
#define IDS_INI_ADMINISTRATOR           61262
#define IDS_INI_NUMBEROFUSER            61263
#define IDS_NAME_EXIST_SELECT_FOR_CHANGE 61264
#define IDS_FAILED_CREATE_INSTANCE      61265
#define IDS_FOLLOWING_ERROR_HAPPENED    61266
#define IDS_FAILED_INIT_DSHOW           61267
#define IDS_UNKNOWN_ERROR               61268
#define IDS_WANT_CONTINUE               61269
#define IDS_STREAM_FAILED_ONE           61270
#define IDS_VIDEO_STREAM                61271
#define IDS_AUDIO_STREAM                61272
#define IDS_SUBPICTURE_STREAM           61273
#define IDS_INVALID_DVD_DISC            61274
#define IDS_NOT_FOUND_DVD_DISC          61275
#define IDS_FOLLOWING_ERRORS_HAPPENED   61276
#define IDS_NO_CC_IN_ERROR              61277
#define IDS_CC_OUT_ERROR                61278
#define IDS_FILE_OPEN_DLGBOX_TITLE      61279
#define IDS_BLACKBOX1_TITLE             61280
#define IDS_BLACKBOX2_CHAPTER           61281
#define IDS_BLACKBOX3_PROGRESS          61282
#define IDS_STREAM_FAILED_MORE          61283
#define IDS_INI_SHOW_LOGONBOX           61284
#define IDS_ADM_SETLOGONBOX_TITLE       61285
#define IDS_VIDEO_WINDOW_POS            61286
#define IDS_WINDOW_LEFT                 61287
#define IDS_WINDOW_TOP                  61288
#define IDS_WINDOW_WIDTH                61289
#define IDS_WINDOW_HEIGHT               61290
#define IDS_UI_WINDOW_POS               61291
#define IDS_UI_SHOWCMD                  61292
#define IDS_VIDEO_WND_FULLSCREEN        61293
#define IDS_INI_RATE_PG13               61294
#define IDS_INI_RATE_R                  61295
#define IDS_INI_RATE_NC17               61296
#define IDS_RATED_HIGH                  61297
#define IDS_DECODER_WRONG               61298
#define IDS_FONTHEIGHT                  61299
#define IDS_FONTFACE                    61300
#define IDS_CHARSET                     61301
#define IDS_CONTEXT_HELP_FILENAME       61302
#define IDS_UIWND_CLASSNAME             61303
#define IDS_SELECT_DELETE               61304
#define IDS_CANT_DELETE_GUEST           61305
#define IDS_SURE_TO_DELETE              61306
#define IDS_STREAM                      61307
#define IDS_NO_USER_SELECTED_GUEST_LOGON 61308
#define IDS_REGION_CHANGE_FAIL          61309
#define IDS_RATE_OVER_RIDE              61310
#define IDS_ERROR                       61311
#define IDS_MACROVISION_FAIL            61312
#define IDS_REGION_CHANGE_PROMPT        61313
#define TIMER_ID                        1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        219
#define _APS_NEXT_COMMAND_VALUE         32870
#define _APS_NEXT_CONTROL_VALUE         1124
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\openfile.h ===
#if !defined(AFX_OPENFILE_H__56E80E83_5041_11D1_B7E0_00AA0037E04F__INCLUDED_)
#define AFX_OPENFILE_H__56E80E83_5041_11D1_B7E0_00AA0037E04F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// openfile.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COpenFile dialog

class COpenFile : public CFileDialog
{
// Construction
public:
	//COpenFile(CWnd* pParent = NULL);   // standard constructor
	COpenFile(	BOOL    bOpenFileDialog,
				LPCTSTR lpszDefExt = NULL, 
				LPCTSTR lpszFileName = NULL, 
				DWORD   dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, 
				LPCTSTR lpszFilter = NULL, 
				CWnd*   pParentWnd = NULL  );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COpenFile)
	protected:
	virtual void OnFolderChange( );
	virtual void OnInitDone( );
	//}}AFX_VIRTUAL

// Implementation
protected:
	//int m_nIdEditCtrl;
   HWND m_hWndIdEditCtrl;

	// Generated message map functions
	//{{AFX_MSG(COpenFile)	
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OPENFILE_H__56E80E83_5041_11D1_B7E0_00AA0037E04F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\setrate.cpp ===
// SetRate.cpp : implementation file
//

#include "stdafx.h"
#include "dvdplay.h"
#include "SetRate.h"
#include "admlogin.h"
#include "parenctl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSetRating dialog


CSetRating::CSetRating(CWnd* pParent /*=NULL*/)
	: CDialog(CSetRating::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSetRating)
	//}}AFX_DATA_INIT
	m_bHideConfirm = TRUE;
}


void CSetRating::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSetRating)
	DDX_Control(pDX, IDC_EDIT_CONFIRM_NEW, m_ctlConfirm);
	DDX_Control(pDX, IDC_EDIT_PASSWORD, m_ctlPassword);
	DDX_Control(pDX, IDC_LIST_USER_RATE, m_ctlUserRateList);
	DDX_Control(pDX, IDC_EDIT_NAME, m_ctlName);
	DDX_Control(pDX, IDC_COMBO_RATE, m_ctlRate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSetRating, CDialog)
	//{{AFX_MSG_MAP(CSetRating)
	ON_LBN_SELCHANGE(IDC_LIST_USER_RATE, OnSelchangeListUserRate)
	ON_BN_CLICKED(IDC_BUTTON_SAVE, OnButtonSave)
	ON_BN_CLICKED(IDC_BUTTON_CLOSE, OnButtonClose)
	ON_WM_HELPINFO()
	ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnChangeEditPassword)
	ON_EN_KILLFOCUS(IDC_EDIT_PASSWORD, OnKillfocusEditPassword)
	ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSetRating message handlers
BOOL CSetRating::OnInitDialog() 
{	
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	m_lpProfileName = ((CDvdplayApp*) AfxGetApp())->GetProfileName();

	CAdminLogin dlg(this);
	dlg.m_uiCalledBy = BY_SET_RATING;
	if(dlg.DoModal() == IDCANCEL)
	{
		CDialog::OnCancel();
		return FALSE;
	}

	int tabs[] = {15, 90};
	m_ctlUserRateList.SetTabStops(2, tabs);
	InitNameRateListBox();

	CString csStr;
	csStr.LoadString(IDS_INI_RATE_G);
	m_ctlRate.AddString(csStr);
	csStr.LoadString(IDS_INI_RATE_PG);
	m_ctlRate.AddString(csStr);
	csStr.LoadString(IDS_INI_RATE_PG13);
	m_ctlRate.AddString(csStr);
	csStr.LoadString(IDS_INI_RATE_R);
	m_ctlRate.AddString(csStr);
	csStr.LoadString(IDS_INI_RATE_NC17);	
	m_ctlRate.AddString(csStr);
	csStr.LoadString(IDS_INI_RATE_ADULT);
	m_ctlRate.AddString(csStr);

	m_ctlRate.SetCurSel(0);
	m_ctlPassword.SetWindowText(_T(""));

	m_ctlPassword.LimitText(MAX_PASSWD);
	m_ctlConfirm.LimitText(MAX_PASSWD);
	m_ctlName.LimitText(MAX_NAME);
	HideConfirmPasswd(TRUE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSetRating::InitNameRateListBox()
{	
	int iNumOfUser = CAdminLogin::GetNumOfUser(m_lpProfileName);
	if(iNumOfUser == 0)
		return;	

	TCHAR szCurrentUserNum[MAX_NUMUSER];
	TCHAR szSectionName[MAX_SECTION];
	TCHAR szUserName[MAX_NAME];
	TCHAR szUserRate[MAX_RATE];
	CString csStr;
	
	for (int i=1; i<iNumOfUser+1; i++)
	{
		lstrcpy(szUserName, _T(""));
		_itot(i, szCurrentUserNum, 10);
		csStr.LoadString(IDS_INI_USER);
		lstrcpy(szSectionName, csStr);
		lstrcat(szSectionName, szCurrentUserNum);

		csStr.LoadString(IDS_INI_USERNAME);
		GetPrivateProfileString(szSectionName, csStr, 
		              NULL, szUserName, MAX_NAME, m_lpProfileName);
		csStr.LoadString(IDS_INI_RATE);
		GetPrivateProfileString(szSectionName, csStr, 
		              NULL, szUserRate, MAX_RATE, m_lpProfileName);
		if( lstrcmp(szUserName, _T("")) > 0)
		{
			TCHAR ListStr[MAX_LINE];			
			PackListString(ListStr, szCurrentUserNum, szUserName, szUserRate);
			m_ctlUserRateList.AddString(ListStr);
		}
	}
	m_ctlUserRateList.SetCurSel(-1);
}

void CSetRating::PackListString(LPTSTR lpListStr, LPTSTR lpNum, LPTSTR lpName, LPTSTR lpRate)
{
	lstrcpy(lpListStr, lpNum);
	lstrcat(lpListStr, _T("\t"));
	lstrcat(lpListStr, lpName);
	lstrcat(lpListStr, _T("\t"));
	lstrcat(lpListStr, lpRate);	
}

void CSetRating::UnpackListString(LPTSTR lpListStr, LPTSTR lpNum, LPTSTR lpName, LPTSTR lpRate)
{
	int i, iStart;
	BOOL bSkip1=FALSE, bSkip2=FALSE;

	for(i=0; i<lstrlen(lpListStr); i++)
	{
		if(bSkip1 == FALSE)
		{
			if(lpListStr[i] == '\t')
			{
				lpNum[i] = '\0';
				bSkip1 = TRUE;
				iStart = i+1;
				continue;
			}
			lpNum[i] = lpListStr[i];
			continue;
		}
		if(bSkip2 == FALSE)
		{
			if(lpListStr[i] == '\t')
			{
				lpName[i-iStart] = '\0';
				bSkip2 = TRUE;
				iStart = i+1;
				continue;
			}
			lpName[i-iStart] = lpListStr[i];
			continue;
		}
		lpRate[i-iStart] = lpListStr[i];
	}
	lpRate[i-iStart] = '\0';
}

void CSetRating::OnButtonSave() 
{
	m_bHideConfirm = TRUE;
	int iSelect = m_ctlUserRateList.GetCurSel();
	if(iSelect == LB_ERR)
		SaveNewUser();
	else
		SaveExistingUserChanges(iSelect);
	
	HideConfirmPasswd(m_bHideConfirm);
}

void CSetRating::SaveNewUser()
{
	TCHAR szName[MAX_NAME];
	TCHAR szRate[MAX_RATE];
	TCHAR szPassword[MAX_PASSWD];
	TCHAR szConfirm[MAX_PASSWD];
	m_ctlName.GetWindowText(szName, MAX_NAME);	
	m_ctlRate.GetWindowText(szRate, MAX_RATE);
	m_ctlPassword.GetWindowText(szPassword, MAX_PASSWD);
	m_ctlConfirm.GetWindowText(szConfirm, MAX_PASSWD);

	if(lstrcmp(szName, _T("")) == 0)
	{
		DVDMessageBox(m_hWnd, IDS_TYPE_A_USER_NAME);
		m_ctlName.SetFocus();
		if(lstrcmp(szPassword, _T("")) != 0)
			m_bHideConfirm = FALSE;
		return;
	}
	if(IsDuplicateUser(szName))
	{
		DVDMessageBox(m_hWnd, IDS_NAME_EXIST_SELECT_FOR_CHANGE);
		m_ctlName.SetFocus();
		if(lstrcmp(szPassword, _T("")) != 0)
			m_bHideConfirm = FALSE;
		return;
	}
	if(lstrcmp(szPassword, _T("")) == 0)
	{
		DVDMessageBox(m_hWnd, IDS_ENTER_PASSWORD);
		GetDlgItem(IDC_EDIT_PASSWORD)->SetFocus();
		return;
	}
	if(lstrcmp(szConfirm, _T("")) == 0)
	{
		DVDMessageBox(m_hWnd, IDS_CONFIRM_NEW_PASSWORD);
		m_ctlConfirm.SetFocus();
		m_bHideConfirm = FALSE;
		return;
	}
	if(!ConfirmPassword())
	{
		DVDMessageBox(m_hWnd, IDS_PASSOWRD_CONFIRM_WRONG);
		m_ctlConfirm.SetFocus();
		m_bHideConfirm = FALSE;
		return;
	}

	int   iNumOfUser = CAdminLogin::GetNumOfUser(m_lpProfileName);
	TCHAR szNumOfUser[MAX_NUMUSER];
	TCHAR szSectionName[MAX_SECTION];
	CString csStr, csStr2;
	
	csStr.LoadString(IDS_INI_USER);
	lstrcpy(szSectionName, csStr);
	_itot(iNumOfUser+1, szNumOfUser, 10);
	lstrcat(szSectionName, szNumOfUser);

	csStr.LoadString(IDS_INI_USERNAME);
	WritePrivateProfileString(szSectionName, csStr, szName, m_lpProfileName);
	CAdminLogin::EncryptPassword(szPassword);
	csStr.LoadString(IDS_INI_PASSWORD);
	WritePrivateProfileString(szSectionName, csStr, szPassword, m_lpProfileName);
	csStr.LoadString(IDS_INI_RATE);
	WritePrivateProfileString(szSectionName, csStr, szRate, m_lpProfileName);	
	csStr.LoadString(IDS_INI_ADMINISTRATOR);
	csStr2.LoadString(IDS_INI_NUMBEROFUSER);
	WritePrivateProfileString(csStr, csStr2, szNumOfUser, m_lpProfileName);	

	TCHAR ListStr[MAX_LINE];
	PackListString(ListStr, szNumOfUser, szName, szRate);	
	m_ctlUserRateList.AddString(ListStr);
	m_ctlPassword.SetWindowText(_T(""));

	m_ctlName.SetWindowText(_T(""));
	m_ctlName.SetFocus();
	m_ctlUserRateList.SetCurSel(-1);
	m_ctlPassword.EnableWindow(TRUE);
}

void CSetRating::SaveExistingUserChanges(int iSelect) 
{
	TCHAR ListStr[MAX_LINE];
	m_ctlUserRateList.GetText(iSelect, ListStr);

	TCHAR szCurrentUserNum[MAX_NUMUSER];
	TCHAR szSectionName[MAX_SECTION];
	TCHAR szUserName[MAX_NAME];
	TCHAR szUserRate[MAX_RATE];
	TCHAR szPassword[MAX_PASSWD];
	CString csStr;

	UnpackListString(ListStr, szCurrentUserNum, szUserName, szUserRate);

	TCHAR szNewUser[MAX_NAME];
	TCHAR szNewRate[MAX_RATE];
	m_ctlName.GetWindowText(szNewUser, MAX_NAME);
	m_ctlRate.GetWindowText(szNewRate, MAX_RATE);
	m_ctlPassword.GetWindowText(szPassword, MAX_PASSWD);

	if(lstrcmp(szNewUser, _T("")) == 0)
	{
		DVDMessageBox(m_hWnd, IDS_TYPE_A_USER_NAME);
		GetDlgItem(IDC_EDIT_NAME)->SetFocus();
		m_ctlPassword.SetWindowText(_T(""));
		return;
	}
	
	TCHAR szNumOfUser[MAX_NUMUSER];
	TCHAR szSavedName[MAX_NAME];
	TCHAR szNewUserUpper[MAX_NAME];
	
	int iCurrentUser = _ttoi(szCurrentUserNum);
	int iNumOfUser = CAdminLogin::GetNumOfUser(m_lpProfileName);
	lstrcpy(szNewUserUpper, szNewUser);
	CharUpper(szNewUserUpper);
	for(int i=1; i<iNumOfUser+1; i++)
	{
		if(i == iCurrentUser)
			continue;

		csStr.LoadString(IDS_INI_USER);
		lstrcpy(szSectionName, csStr);
		_itot(i, szNumOfUser, 10);
		lstrcat(szSectionName, szNumOfUser);
		csStr.LoadString(IDS_INI_USERNAME);
		GetPrivateProfileString(szSectionName, csStr, NULL, 
			                    szSavedName, MAX_NAME, m_lpProfileName);
		CharUpper(szSavedName);
		if(lstrcmp(szSavedName, szNewUserUpper) == 0)
		{
			DVDMessageBox(m_hWnd, IDS_USER_ALREADY_EXISTS);
			m_ctlPassword.SetWindowText(_T(""));
			return;
		}
	}

	if(lstrcmp(szPassword, _T("")) != 0 )
	{
		CString csConfirm;
		m_ctlConfirm.GetWindowText(csConfirm);
		if(csConfirm.IsEmpty())
		{
			DVDMessageBox(m_hWnd, IDS_CONFIRM_NEW_PASSWORD);
			m_ctlConfirm.SetFocus();
			m_bHideConfirm = FALSE;
			return;
		}
		if(!ConfirmPassword())
		{
			DVDMessageBox(m_hWnd, IDS_PASSOWRD_CONFIRM_WRONG);
			m_ctlConfirm.SetFocus();
			m_bHideConfirm = FALSE;
			return;
		}
	}

	csStr.LoadString(IDS_INI_USER);
	lstrcpy(szSectionName, csStr);
	lstrcat(szSectionName, szCurrentUserNum);

	CString csGuest;
	csGuest.LoadString(IDS_GUEST);	
	if(lstrcmp(szUserName, (LPCTSTR) csGuest) == 0)
	{
		lstrcpy(szPassword, _T(""));
		//Don't allow to change Guest's name
		if(lstrcmp(szNewUser, szUserName) != 0)
			lstrcpy(szNewUser, szUserName);
	}

	csStr.LoadString(IDS_INI_USERNAME);
	WritePrivateProfileString(szSectionName, csStr, szNewUser, m_lpProfileName);
	csStr.LoadString(IDS_INI_RATE);
	WritePrivateProfileString(szSectionName, csStr, szNewRate, m_lpProfileName);
	if(lstrcmp(szPassword, _T("")) != 0)
	{
		CAdminLogin::EncryptPassword(szPassword);
		csStr.LoadString(IDS_INI_PASSWORD);
		WritePrivateProfileString(szSectionName, csStr, szPassword, m_lpProfileName);
	}
	
	PackListString(ListStr, szCurrentUserNum, szNewUser, szNewRate);
	m_ctlUserRateList.DeleteString(iSelect);
	m_ctlUserRateList.InsertString(iSelect, ListStr);
	m_ctlPassword.SetWindowText(_T(""));

	m_ctlName.SetWindowText(_T(""));
	m_ctlName.SetFocus();
	m_ctlUserRateList.SetCurSel(-1);
	m_ctlPassword.EnableWindow(TRUE);

	CString csLoginedUser = ((CDvdplayApp*) AfxGetApp())->GetCurrentUser();
	if(csLoginedUser == (CString) szUserName)
		CParentControl::SetRate(szNewRate);
}

void CSetRating::OnSelchangeListUserRate() 
{	
	TCHAR ListStr[MAX_LINE];
	int iSelect = m_ctlUserRateList.GetCurSel();
	if(iSelect != LB_ERR)
		m_ctlUserRateList.GetText(iSelect, ListStr);
	
	TCHAR szUserName[MAX_NAME];
	TCHAR szUserRate[MAX_RATE];
	TCHAR szUserNum[MAX_NUMUSER];	
	UnpackListString(ListStr, szUserNum, szUserName, szUserRate);

	//Disable password for Guest
	CString csGuest;
	csGuest.LoadString(IDS_GUEST);
	if(lstrcmp(szUserName, (LPCTSTR) csGuest) == 0)
		m_ctlPassword.EnableWindow(FALSE);		
	else
		m_ctlPassword.EnableWindow(TRUE);
	
	m_ctlName.SetWindowText(szUserName);
	m_ctlRate.SelectString(-1, szUserRate);
	m_ctlPassword.SetWindowText(_T(""));
	HideConfirmPasswd(TRUE);
}

BOOL CSetRating::IsDuplicateUser(LPTSTR lpUserName)
{
	TCHAR szSectionName[MAX_SECTION];
	if(CAdminLogin::SearchProfileByName(m_lpProfileName, 
		                       lpUserName, szSectionName))
		return TRUE;
	else
		return FALSE;
}

void CSetRating::OnOK() 
{
	OnButtonSave();
}

void CSetRating::OnButtonClose() 
{
	if(((CDvdplayApp*) AfxGetApp())->DoesFileExist(m_lpProfileName))
		((CDvdplayApp*) AfxGetApp())->SetProfileStatus(TRUE);
	
	CDialog::OnOK();
}

BOOL CSetRating::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
        AfxGetApp()->WinHelp( pHelpInfo->dwContextId, HELP_CONTEXTPOPUP);
    return TRUE;
}

BOOL CSetRating::ConfirmPassword()
{
	CString	csPasswd, csConfirm;
	m_ctlPassword.GetWindowText(csPasswd);
	m_ctlConfirm.GetWindowText(csConfirm);
	if(csPasswd == csConfirm)
		return TRUE;
	else
		return FALSE;	
}

void CSetRating::HideConfirmPasswd(BOOL bHide)
{
	if(bHide)
	{
		m_ctlConfirm.ShowWindow(SW_HIDE);
		GetDlgItem(IDC_STATIC_CONFIRM_NEW)->ShowWindow(SW_HIDE);
	}
	else
	{
		m_ctlConfirm.ShowWindow(SW_SHOW);
		GetDlgItem(IDC_STATIC_CONFIRM_NEW)->ShowWindow(SW_SHOW);
	}
}

void CSetRating::OnChangeEditPassword() 
{
	HideConfirmPasswd(FALSE);
	m_ctlConfirm.SetWindowText(_T(""));
}

void CSetRating::OnKillfocusEditPassword() 
{
	CString csPasswd;
	m_ctlPassword.GetWindowText(csPasswd);
	if(csPasswd.IsEmpty())
		HideConfirmPasswd(TRUE);
}

void CSetRating::OnButtonDelete() 
{
	int iSelect = m_ctlUserRateList.GetCurSel();
	if(iSelect == LB_ERR)
	{
		DVDMessageBox(m_hWnd, IDS_SELECT_DELETE);
		return;
	}

	TCHAR szListStr[MAX_LINE];
	TCHAR szUserName[MAX_NAME];
	TCHAR szUserRate[MAX_RATE];
	TCHAR szUserNum[MAX_NUMUSER];
	m_ctlUserRateList.GetText(iSelect, szListStr);
	UnpackListString(szListStr, szUserNum, szUserName, szUserRate);

	//Don't allow to delete Guest
	CString csGuest;
	csGuest.LoadString(IDS_GUEST);
	if(lstrcmp(szUserName, (LPCTSTR) csGuest) == 0)
	{
		DVDMessageBox(m_hWnd, IDS_CANT_DELETE_GUEST);
		m_ctlName.SetWindowText(_T(""));
		m_ctlName.SetFocus();
		m_ctlRate.SetCurSel(0);
		m_ctlUserRateList.SetCurSel(-1);
		return;
	}

	//Delete confirmation dailog box
	if( DVDMessageBox(m_hWnd, IDS_SURE_TO_DELETE, NULL, MB_YESNO) == IDNO )
		return;

	//Change the dvdplay.ini file: 
	//1) totlaNumber-1, 2)delete selected user, 3)adjust sequencial number
	CString csSection, csKey;
	TCHAR Num[4];
	//reduce total user number by 1
	csSection.LoadString(IDS_INI_ADMINISTRATOR);
	csKey.LoadString(IDS_INI_NUMBEROFUSER);
	int iToTalUser = GetPrivateProfileInt(csSection, csKey, 0, m_lpProfileName);
	if(iToTalUser == 0)
		iToTalUser = m_ctlUserRateList.GetCount();
	_itot(iToTalUser-1, Num, 10);
	int ret = WritePrivateProfileString(csSection, csKey, Num, m_lpProfileName);	

	//Adjust the user sequencial number
	int iUserNum = _ttoi(szUserNum);
	if(iUserNum < iToTalUser)
	{
		for(int i=iUserNum+1; i<iToTalUser+1; i++)
		{
			CString csSectionR;

			csSection.LoadString(IDS_INI_USER);			
			_itot(i-1, Num, 10);
			csSection += Num;
			
			csSectionR.LoadString(IDS_INI_USER);
			_itot(i, Num, 10);
			csSectionR += Num;

			GetPrivateProfileSection (csSectionR, szListStr, MAX_LINE, m_lpProfileName);
			WritePrivateProfileSection(csSection, szListStr, m_lpProfileName);
		}
	}

	//delete last user from dvdplay.ini
	csSection.LoadString(IDS_INI_USER);
	_itot(iToTalUser, Num, 10);
	csSection += Num;
	ret = WritePrivateProfileString(csSection, NULL, NULL, m_lpProfileName);

	//update the list box
	while (m_ctlUserRateList.DeleteString(0) != LB_ERR) ;
	InitNameRateListBox();
	m_ctlName.SetWindowText(_T(""));
	m_ctlRate.SetCurSel(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\setrate.h ===
#if !defined(AFX_SETRATE_H__88483F45_E16F_11D0_8A6A_00AA00605CD5__INCLUDED_)
#define AFX_SETRATE_H__88483F45_E16F_11D0_8A6A_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SetRate.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSetRating dialog

class CSetRating : public CDialog
{
// Construction
public:
	CSetRating(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSetRating)
	enum { IDD = IDD_DIALOG_SET_RATE };
	CEdit	m_ctlConfirm;
	CEdit	m_ctlPassword;
	CListBox	m_ctlUserRateList;
	CEdit	m_ctlName;
	CComboBox	m_ctlRate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSetRating)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void     InitNameRateListBox();	
	void     PackListString(LPTSTR lpListStr, LPTSTR lpNum, LPTSTR lpName, LPTSTR lpRate);
	void     UnpackListString(LPTSTR lpListStr, LPTSTR lpNum, LPTSTR lpName, LPTSTR lpRate);
	BOOL     IsDuplicateUser(LPTSTR lpUserName);
	void     SaveNewUser();
	void     SaveExistingUserChanges(int iSelect);
	BOOL     ConfirmPassword();
	void     HideConfirmPasswd(BOOL);
	LPTSTR   m_lpProfileName;
	BOOL     m_bHideConfirm;

	// Generated message map functions
	//{{AFX_MSG(CSetRating)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeListUserRate();
	virtual void OnOK();
	afx_msg void OnButtonSave();
	afx_msg void OnButtonClose();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnChangeEditPassword();
	afx_msg void OnKillfocusEditPassword();
	afx_msg void OnButtonDelete();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SETRATE_H__88483F45_E16F_11D0_8A6A_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\srchchap.cpp ===
// SrchChap.cpp : implementation file
//

#include "stdafx.h"
#include "dvdplay.h"
#include "SrchChap.h"
#include "navmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSearchChapter dialog


CSearchChapter::CSearchChapter(CWnd* pParent /*=NULL*/)
	: CDialog(CSearchChapter::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSearchChapter)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CSearchChapter::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchChapter)
	DDX_Control(pDX, IDC_SPIN_SECOND, m_ctlSpinSec);
	DDX_Control(pDX, IDC_SPIN_MINUTE, m_ctlSpinMin);
	DDX_Control(pDX, IDC_SPIN_HOUR, m_ctlSpinHour);
	DDX_Control(pDX, IDC_EDIT_SECOND, m_ctlEditSec);
	DDX_Control(pDX, IDC_EDIT_MINUTE, m_ctlEditMin);
	DDX_Control(pDX, IDC_EDIT_HOUR, m_ctlEditHour);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSearchChapter, CDialog)
	//{{AFX_MSG_MAP(CSearchChapter)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchChapter message handlers

BOOL CSearchChapter::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	m_pDVDNavMgr = ((CDvdplayApp*) AfxGetApp())->GetDVDNavigatorMgr();
	if(!m_pDVDNavMgr)
		return FALSE;

	m_ctlEditHour.SetWindowText(TEXT("0"));
	m_ctlEditMin.SetWindowText(TEXT("0"));
	m_ctlEditSec.SetWindowText(TEXT("0"));

	m_ctlSpinHour.SetBuddy(&m_ctlEditHour);
	m_ctlSpinMin.SetBuddy(&m_ctlEditMin);
	m_ctlSpinSec.SetBuddy(&m_ctlEditSec);

	m_ctlSpinHour.SetRange(0, 99);
	m_ctlSpinMin.SetRange(0, 59);
	m_ctlSpinSec.SetRange(0, 59);

	IDvdInfo *pDvdInfo = m_pDVDNavMgr->GetDvdInfo();
	if(pDvdInfo)
	{
		ULONG pTotalTime;
		TCHAR szTotalTitleTime[9];
		pDvdInfo->GetTotalTitleTime(&pTotalTime);
		DVD_TIMECODE *ptrTimeCode = (DVD_TIMECODE *) &pTotalTime;
		wsprintf(szTotalTitleTime, TEXT("%d%d:%d%d:%d%d"), 
			     ptrTimeCode->Hours10,     ptrTimeCode->Hours1, 
				 ptrTimeCode->Minutes10,   ptrTimeCode->Minutes1,
				 ptrTimeCode->Seconds10,   ptrTimeCode->Seconds1);
		if(_tcscmp(szTotalTitleTime, TEXT("00:00:00")) != 0)
			GetDlgItem(IDC_STATIC_TIME)->SetWindowText(szTotalTitleTime);
		else
			GetDlgItem(IDC_STATIC_TOTAL_TIME)->ShowWindow(FALSE);
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSearchChapter::OnOK() 
{
	ULONG ulChapterHour= m_ctlSpinHour.GetPos();
	ULONG ulChapterMin = m_ctlSpinMin.GetPos();
	ULONG ulChapterSec = m_ctlSpinSec.GetPos();

	ULONG ulTime = 0;
	DVD_TIMECODE *pTime = (DVD_TIMECODE *) &ulTime;
	pTime->Hours10   = ulChapterHour/10;
	pTime->Hours1    = ulChapterHour%10;
	pTime->Minutes10 = ulChapterMin/10;
	pTime->Minutes1  = ulChapterMin%10;
	pTime->Seconds10 = ulChapterSec/10;
	pTime->Seconds1  = ulChapterSec%10;

	m_pDVDNavMgr->DVDTimeSearch(ulTime);
	
	CDialog::OnOK();
}

BOOL CSearchChapter::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
        AfxGetApp()->WinHelp( pHelpInfo->dwContextId, HELP_CONTEXTPOPUP);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	dvdplay.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\srchtitl.cpp ===
// SrchTitl.cpp : implementation file
//

#include "stdafx.h"
#include "dvdplay.h"
#include "SrchTitl.h"
#include "navmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSearchTitle dialog


CSearchTitle::CSearchTitle(CWnd* pParent /*=NULL*/)
	: CDialog(CSearchTitle::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSearchTitle)
	//}}AFX_DATA_INIT
}


void CSearchTitle::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchTitle)
	DDX_Control(pDX, IDC_SPIN_TITLE_NUMBER, m_ctlSpinTitleNum);
	DDX_Control(pDX, IDC_EDIT_TITLE_NUMBER, m_ctlEditTitleNum);
	DDX_Control(pDX, IDC_SPIN_SECOND, m_ctlSpinSec);
	DDX_Control(pDX, IDC_SPIN_MINUTE, m_ctlSpinMin);
	DDX_Control(pDX, IDC_SPIN_HOUR, m_ctlSpinHour);
	DDX_Control(pDX, IDC_EDIT_SECOND, m_ctlEditSec);
	DDX_Control(pDX, IDC_EDIT_MINUTE, m_ctlEditMin);
	DDX_Control(pDX, IDC_EDIT_HOUR, m_ctlEditHour);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSearchTitle, CDialog)
	//{{AFX_MSG_MAP(CSearchTitle)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchTitle message handlers

BOOL CSearchTitle::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	m_pDVDNavMgr = ((CDvdplayApp*) AfxGetApp())->GetDVDNavigatorMgr();
	if(!m_pDVDNavMgr)
		return FALSE;

	UINT uiNumOfTitle = m_pDVDNavMgr->DVDQueryNumTitles();
	m_ctlEditTitleNum.SetWindowText(TEXT("0"));
	m_ctlSpinTitleNum.SetBuddy(&m_ctlEditTitleNum);
	m_ctlSpinTitleNum.SetRange(0, uiNumOfTitle);

	m_ctlEditHour.SetWindowText(TEXT("0"));
	m_ctlSpinHour.SetBuddy(&m_ctlEditHour);
	m_ctlSpinHour.SetRange(0, 99);

	m_ctlEditMin.SetWindowText(TEXT("0"));
	m_ctlSpinMin.SetBuddy(&m_ctlEditMin);
	m_ctlSpinMin.SetRange(0, 60);

	m_ctlEditSec.SetWindowText(TEXT("0"));	
	m_ctlSpinSec.SetBuddy(&m_ctlEditSec);	
	m_ctlSpinSec.SetRange(0, 60);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSearchTitle::OnOK() 
{
	ULONG ulTitleHour= m_ctlSpinHour.GetPos();
	ULONG ulTitleMin = m_ctlSpinMin.GetPos();
	ULONG ulTitleSec = m_ctlSpinSec.GetPos();
	ULONG ulTitleSel = m_ctlSpinTitleNum.GetPos();

	ULONG ulTime = 0;
	DVD_TIMECODE *pTime = (DVD_TIMECODE *) &ulTime;
	pTime->Hours10   = ulTitleHour/10;
	pTime->Hours1    = ulTitleHour%10;
	pTime->Minutes10 = ulTitleMin/10;
	pTime->Minutes1  = ulTitleMin%10;
	pTime->Seconds10 = ulTitleSec/10;
	pTime->Seconds1  = ulTitleSec%10;

	m_pDVDNavMgr->DVDTimePlay(ulTitleSel, ulTime);
	
	CDialog::OnOK();
}

BOOL CSearchTitle::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
        AfxGetApp()->WinHelp( pHelpInfo->dwContextId, HELP_CONTEXTPOPUP);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__AF1C3AAA_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_)
#define AFX_STDAFX_H__AF1C3AAA_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Amovie stuff
#include <strmif.h>
#include <uuids.h>
#include <control.h>
#include <streams.h>
#include <winbase.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AF1C3AAA_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\srchtitl.h ===
#if !defined(AFX_SRCHTITL_H__C0C46604_ECA5_11D0_A78E_00AA00605CD5__INCLUDED_)
#define AFX_SRCHTITL_H__C0C46604_ECA5_11D0_A78E_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SrchTitl.h : header file
//

class CDVDNavMgr;
/////////////////////////////////////////////////////////////////////////////
// CSearchTitle dialog

class CSearchTitle : public CDialog
{
// Construction
public:
	CSearchTitle(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSearchTitle)
	enum { IDD = IDD_DIALOG_SEARCH_TITLE };
	CSpinButtonCtrl	m_ctlSpinTitleNum;
	CEdit	m_ctlEditTitleNum;
	CSpinButtonCtrl	m_ctlSpinSec;
	CSpinButtonCtrl	m_ctlSpinMin;
	CSpinButtonCtrl	m_ctlSpinHour;
	CEdit	m_ctlEditSec;
	CEdit	m_ctlEditMin;
	CEdit	m_ctlEditHour;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSearchTitle)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDVDNavMgr* m_pDVDNavMgr;

	// Generated message map functions
	//{{AFX_MSG(CSearchTitle)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SRCHTITL_H__C0C46604_ECA5_11D0_A78E_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\srchchap.h ===
#if !defined(AFX_SRCHCHAP_H__C0C46605_ECA5_11D0_A78E_00AA00605CD5__INCLUDED_)
#define AFX_SRCHCHAP_H__C0C46605_ECA5_11D0_A78E_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SrchChap.h : header file
//

class CDVDNavMgr;
/////////////////////////////////////////////////////////////////////////////
// CSearchChapter dialog

class CSearchChapter : public CDialog
{
// Construction
public:
	CSearchChapter(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSearchChapter)
	enum { IDD = IDD_DIALOG_SEARCH_CHAPTER };
	CSpinButtonCtrl	m_ctlSpinSec;
	CSpinButtonCtrl	m_ctlSpinMin;
	CSpinButtonCtrl	m_ctlSpinHour;
	CEdit	m_ctlEditSec;
	CEdit	m_ctlEditMin;
	CEdit	m_ctlEditHour;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSearchChapter)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDVDNavMgr* m_pDVDNavMgr;

	// Generated message map functions
	//{{AFX_MSG(CSearchChapter)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SRCHCHAP_H__C0C46605_ECA5_11D0_A78E_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\subtitle.cpp ===
// SubTitle.cpp : implementation file
//

#include "stdafx.h"
#include "dvdplay.h"
#include "SubTitle.h"
#include "navmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSubTitle dialog


CSubTitle::CSubTitle(CWnd* pParent /*=NULL*/)
	: CDialog(CSubTitle::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSubTitle)
	//}}AFX_DATA_INIT
	m_pDVDNavMgr = NULL;
	m_bSubTitleChecked = FALSE;
}


void CSubTitle::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSubTitle)
	DDX_Control(pDX, IDC_LIST_SUBTITLE, m_ctlListSubTitle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSubTitle, CDialog)
	//{{AFX_MSG_MAP(CSubTitle)
	ON_BN_CLICKED(IDC_CHECK_SUBTITLE, OnCheckSubtitle)
	ON_LBN_SELCHANGE(IDC_LIST_SUBTITLE, OnSelchangeListSubtitle)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSubTitle message handlers

BOOL CSubTitle::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	m_pDVDNavMgr = ((CDvdplayApp*) AfxGetApp())->GetDVDNavigatorMgr();
	if(!m_pDVDNavMgr)
		return FALSE;

	//Init SubTitle Language list box
	IDvdInfo *pDvdInfo = m_pDVDNavMgr->GetDvdInfo();
	if(pDvdInfo)
	{
		ULONG  ulStream;
		LCID   lcid;
		TCHAR  szLanguage[MAX_PATH], szNum[4];

		while(m_ctlListSubTitle.GetCount())         
			m_ctlListSubTitle.DeleteString(0);

		//Init "Show SubTitles" check box.
		ULONG pnStreamAvailable, pnCurrentStream;
		BOOL  bIsDisabled=0;
		HRESULT hr = pDvdInfo->GetCurrentSubpicture(&pnStreamAvailable, &pnCurrentStream, &bIsDisabled);
		if(SUCCEEDED(hr))
		{
			((CButton*)GetDlgItem(IDC_CHECK_SUBTITLE))->SetCheck(!bIsDisabled);
			m_bSubTitleChecked = !bIsDisabled;
		}

		//Init language list box
		int nListIdx=0;
		for(ulStream=0; ulStream<= pnStreamAvailable; ulStream++) //ulStream<32
	    {
		    if( SUCCEEDED(pDvdInfo->GetSubpictureLanguage(ulStream, &lcid)) )
			{				
				int iRet = GetLocaleInfo(lcid, LOCALE_SENGLANGUAGE, szLanguage, MAX_PATH);
				if(lcid == 0)
				{
					LoadString(((CDvdplayApp*) AfxGetApp())->m_hInstance, IDS_STREAM, szLanguage, MAX_PATH);
					_itot(ulStream+1, szNum, 10);
					lstrcat(szLanguage, szNum);
				}				

				m_ctlListSubTitle.AddString(szLanguage);
				m_iLanguageIdx[nListIdx] = ulStream;
				nListIdx++;
			}
	    }

		//Set highlight to the selected language
		for(nListIdx=0; nListIdx<32; nListIdx++)
		{
			if(m_iLanguageIdx[nListIdx] == pnCurrentStream)
			m_ctlListSubTitle.SetCurSel(nListIdx);
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSubTitle::OnCheckSubtitle() 
{
	m_bSubTitleChecked = ((CButton*)GetDlgItem(IDC_CHECK_SUBTITLE))->GetCheck();	
	m_pDVDNavMgr->DVDSubPictureOn(m_bSubTitleChecked);
	OnSelchangeListSubtitle();
}

void CSubTitle::OnSelchangeListSubtitle() 
{
	if(m_bSubTitleChecked)
	{
		int iSelected = m_ctlListSubTitle.GetCurSel();
		if(iSelected != LB_ERR)
			m_pDVDNavMgr->DVDSubPictureSel(m_iLanguageIdx[iSelected]);
	}
}

BOOL CSubTitle::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
        AfxGetApp()->WinHelp( pHelpInfo->dwContextId, HELP_CONTEXTPOPUP);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\test.h ===
#ifndef _TEST_H
#define _TEST_H

#define BUFSIZE 2048

typedef enum {
     Unknown = 0, Stopped, Paused, Playing, Scanning, FF, FR, Slow, VFF, VFR,
     Chapter, Time, FullScreen, Title, CC, Menu, Up, Down, Left, Right,
     NormalSpeed, DoubleSpeed, Eject, AudioVolume, Help, Angle
} CURRENT_STATE;

typedef struct test_case_node_struct {
     char *line;
} TEST_CASE_NODE;

typedef struct test_case_list_struct {
     struct test_case_node_struct *T_CASE[1024];
} TEST_CASE_LIST;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\subtitle.h ===
#if !defined(AFX_SUBTITLE_H__317B4461_DAA7_11D0_9BFC_00AA00605CD5__INCLUDED_)
#define AFX_SUBTITLE_H__317B4461_DAA7_11D0_9BFC_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SubTitle.h : header file
//
class CDVDNavMgr;
/////////////////////////////////////////////////////////////////////////////
// CSubTitle dialog

class CSubTitle : public CDialog
{
// Construction
public:
	CSubTitle(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSubTitle)
	enum { IDD = IDD_DIALOG_SUBTITLE };
	CListBox	m_ctlListSubTitle;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSubTitle)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDVDNavMgr* m_pDVDNavMgr;
	BOOL        m_bSubTitleChecked;
	ULONG       m_iLanguageIdx[32];

	// Generated message map functions
	//{{AFX_MSG(CSubTitle)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckSubtitle();
	afx_msg void OnSelchangeListSubtitle();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SUBTITLE_H__317B4461_DAA7_11D0_9BFC_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\test.cpp ===
// dvdplay.cpp : Defines the class behaviors for the application.
//
#include "stdafx.h"
#include "dvdplay.h"
#include "dvduidlg.h"
#include "navmgr.h"
#include "parenctl.h"
#include "videowin.h"
#include "test.h"
#include <strmif.h>
#include <il21dec.h>
#include <streams.h>
#include <dvdevcod.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif


BOOL CDvdUIDlg::t_Wait (int s_time) {
     DWORD dwEndTime = GetTickCount () + (s_time * 1000);
     MSG msg;

     while (1) {
          while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE)) {
               TranslateMessage (&msg);
               DispatchMessage (&msg);
          }
          Sleep (50);
          if (GetTickCount() >= dwEndTime)
               break;
     }
     return TRUE;
}


TEST_CASE_LIST* CDvdplayApp::t_ReadScriptFile (TEST_CASE_LIST *t_list,
                                               LPCTSTR lpFNAME) {
	char buf[1]={NULL}, outbuf[256];
     int index=0, i, CASE_COUNT=0;
	ULONG bytes_read = 1;
     TEST_CASE_LIST test_case_list;
     HANDLE file_handle;


     file_handle = CreateFile (lpFNAME, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
		               FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN, NULL);
     if (file_handle == INVALID_HANDLE_VALUE)
          return NULL;

	// Read in script file
	while (bytes_read != 0) {
		TEST_CASE_NODE *new_node;
		new_node = (TEST_CASE_NODE *)malloc (sizeof(TEST_CASE_NODE));

		// Read in a line and stops after hitting '\n'
          if (!ReadFile (file_handle, &buf, 1, &bytes_read, NULL))
               return NULL;
          if (buf[0] != ';' && buf[0] != '#' && buf[0] != '\n') {// Allows for comments in script file
               outbuf[index] = buf[0];
               index++;
               while (buf[0] != '\n' && bytes_read != 0) {
                    ReadFile (file_handle, &buf, 1, &bytes_read, NULL);
                    outbuf[index] = buf[0];
                    if (++index > 255) {
                         index = 0;
                         break;
                    }
               }
               buf[0] = '\0';

               //**************** End of read line ******************

               // Add '\0' to end of outbuf and Add new_node to list
               new_node->line = (char*)malloc(index+1);
               if (bytes_read != 0)
                    outbuf[index-2] = '\0';
               else
                    outbuf[index-1] = '\0';
               strcpy (new_node->line, outbuf);
               test_case_list.T_CASE[CASE_COUNT] = new_node;
               CASE_COUNT++;
               if (CASE_COUNT > 1023)
                    break;
               outbuf[0]='\0';
               index = 0;
          }
          else
               while (buf[0] != '\n')
                    ReadFile (file_handle, &buf, 1, &bytes_read, NULL);
	}
	//***************** End of reading file ***************

     CloseHandle (file_handle);
     t_list = &test_case_list;
     return (t_list);
}

BOOL CDvdUIDlg::t_Parse (char *cmd, FILE *pLogFile) {
     char *token;
     char *delimiter = "; ,#";
     UINT i=0;
     int iIteration=1, index=0;
     IDvdInfo *pIDvdInfo;
     DVD_PLAYBACK_LOCATION location;
     ULONG ulChaptNum=0, ulButNum=0, ulNumBut=0;
     BOOL blCCState=FALSE, blFullScreen=FALSE;

     token = strtok (cmd, delimiter);
     if (token == NULL)
          return FALSE;

     if (strcmp(token,"Wait")==0 || strcmp(token,"WAIT")==0) {
          token = strtok (NULL,delimiter);
          if (token == NULL)
               return FALSE;
          i = (UINT) atol (token);
          if (i == 0)
               return FALSE;
          if (t_Wait (i))
               fwprintf (pLogFile, L"Waited for %is\t\t\t...PASS\n",i);
          else
               fwprintf (pLogFile, L"Waited for %is\t\t\t...FAIL\n",i);
     }
     else
     if (strcmp(token,"Play")==0 || strcmp(token,"PLAY")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnPlay();
               t_Wait(3);
               if(m_pDVDNavMgr->t_Verify (Playing, 0))
                    fwprintf (pLogFile, L"Playing\t\t\t\t...PASS\n");
                else
                    fwprintf (pLogFile, L"Playing\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"Stop")==0 || strcmp(token,"STOP")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnStop();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (Stopped, 0))
                    fwprintf (pLogFile, L"Stop\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"Stop\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"Pause")==0 || strcmp(token,"PAUSE")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnPause();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (Paused, 0))
                    fwprintf (pLogFile, L"Pause\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"Pause\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"VFR")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnVeryFastRewind();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (VFR, 0))
                    fwprintf (pLogFile, L"VFR\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"VFR\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"FR")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnFastRewind();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (FR, 0))
                    fwprintf (pLogFile, L"FR\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"FR\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"FF")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnFastForward();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (FF, 0))
                   fwprintf (pLogFile, L"FF\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"FF\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"VFF")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnVeryFastForward();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (VFF, 0))
                    fwprintf (pLogFile, L"VFF\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"VFF\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"Slow")==0 || strcmp(token,"SLOW")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnOperationPlayspeedHalfspeed();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (Slow, 0))
                    fwprintf (pLogFile, L"Slow\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"Slow\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"FullScreen")==0 || strcmp(token,"FULLSCREEN")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               blFullScreen = m_pDVDNavMgr->IsFullScreenMode();
               OnFullScreen();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (FullScreen, !blFullScreen)) {
                    if (blFullScreen)
                         fwprintf (pLogFile, L"FullScreen Off\t\t\t...PASS\n");
                    else
                         fwprintf (pLogFile, L"FullScreen On\t\t\t...PASS\n");
               } else {
                    if (blFullScreen)
                         fwprintf (pLogFile, L"FullScreen Off\t\t\t...FAIL\n");
                    else
                         fwprintf (pLogFile, L"FullScreen On\t\t\t...FAIL\n");
               }
          }
     }
     else
     if (strcmp(token,"Menu")==0 || strcmp(token,"MENU")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnMenu();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (Menu, 0))
                    fwprintf (pLogFile, L"Menu\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"Menu\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"Up")==0 || strcmp(token,"UP")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               pIDvdInfo = m_pDVDNavMgr->GetDvdInfo ();
               pIDvdInfo->GetCurrentButton (&ulNumBut, &ulButNum);
               OnUp();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (Up, ulButNum))
                    fwprintf (pLogFile, L"Up\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"Up\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"Down")==0 || strcmp(token,"DOWN")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               pIDvdInfo = m_pDVDNavMgr->GetDvdInfo ();
               pIDvdInfo->GetCurrentButton (&ulNumBut, &ulButNum);
               OnDown();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (Down, ulButNum))
                    fwprintf (pLogFile, L"Down\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"Down\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"Left")==0 || strcmp(token,"LEFT")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               pIDvdInfo = m_pDVDNavMgr->GetDvdInfo ();
               pIDvdInfo->GetCurrentButton (&ulNumBut, &ulButNum);
               OnLeft();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (Left, ulButNum))
                    fwprintf (pLogFile, L"Left\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"Left\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"Right")==0 || strcmp(token,"RIGHT")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               pIDvdInfo = m_pDVDNavMgr->GetDvdInfo ();
               pIDvdInfo->GetCurrentButton (&ulNumBut, &ulButNum);
               OnRight();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (Right, ulButNum))
                    fwprintf (pLogFile, L"Right\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"Right\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"NextChapter")==0 || strcmp(token,"NEXTCHAPTER")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               pIDvdInfo = m_pDVDNavMgr->GetDvdInfo();
               pIDvdInfo->GetCurrentLocation (&location);
               ulChaptNum = location.ChapterNum;
               OnNextChapter();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (Chapter, ulChaptNum+1))
                    fwprintf (pLogFile, L"NextChapter\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"NextChapter\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"PreviousChapter")==0 ||
                                        strcmp(token,"PREVIOUSCHAPTER")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               pIDvdInfo = m_pDVDNavMgr->GetDvdInfo();
               pIDvdInfo->GetCurrentLocation (&location);
               ulChaptNum = location.ChapterNum;
               OnPreviosChapter();
               t_Wait(3);
               if (ulChaptNum != 0)
                    ulChaptNum--;
               if (m_pDVDNavMgr->t_Verify (Chapter, ulChaptNum))
                    fwprintf (pLogFile, L"Previoushapter\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"PreviousChapter\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"NormalSpeed")==0 || strcmp(token,"NORMALSPEED")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnOperationPlayspeedNormalspeed();
               t_Wait (5);
               if (m_pDVDNavMgr->t_Verify (NormalSpeed, 0))
                    fwprintf (pLogFile, L"NormalSpeed\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"NormalSpeed\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"DoubleSpeed")==0 || strcmp(token,"DOUBLESPEED")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnOperationPlayspeedDoublespeed();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (DoubleSpeed, 0))
                    fwprintf (pLogFile, L"DoubleSpeed\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"DoubleSpeed\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"Eject")==0 || strcmp(token,"EJECT")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnEjectDisc();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (Eject, 0))
                    fwprintf (pLogFile, L"Eject\t\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"Eject\t\t\t\t...FAIL\n");
          }
     }
     else
     if (strcmp(token,"CC")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               blCCState = m_pDVDNavMgr->IsCCOn();
               OnOptionsClosedcaption();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (CC, !blCCState)) {
                    if (!blCCState == TRUE)
                         fwprintf (pLogFile, L"ClosedCaption On\t\t...PASS\n");
                    else
                         fwprintf (pLogFile, L"ClosedCaption Off\t\t...PASS\n");
               } else {
                    if (!blCCState == TRUE)
                         fwprintf (pLogFile, L"ClosedCaption On\t\t...FAIL\n");
                    else
                         fwprintf (pLogFile, L"ClosedCaption Off\t\t...FAIL\n");
               }
          }
     }
     else
     if (strcmp(token,"Angle")==0 || strcmp(token,"ANGLE")==0) {
          token = strtok (NULL, delimiter);
          if (token == NULL)
               return FALSE;
          else {
               i = (UINT)atol(token);
               token = strtok (NULL, delimiter);
               if (token != NULL) {
                    iIteration = atol(token);
                    if (iIteration < 1)
                         iIteration = 1;
               }
               for (index=0;index<iIteration;index++) {
                    OnAngleChange((UINT)i);
                    t_Wait(3);
                    if (m_pDVDNavMgr->t_Verify (Angle, (ULONG)i))
                         fwprintf (pLogFile, L"Angle %i\t\t\t\t...PASS\n",i);
                    else
                         fwprintf (pLogFile, L"Angle %i\t\t\t\t...FAIL\n",i);
               }
          }
     }
     else
     if (strcmp(token,"Sound")==0 || strcmp(token,"SOUND")==0) {
          token = strtok (NULL, delimiter);
          if (token != NULL) {
               iIteration = atol(token);
               if (iIteration < 1)
                    iIteration = 1;
          }
          for (index=0;index<iIteration;index++) {
               OnAudioVolume();
               t_Wait(3);
               if (m_pDVDNavMgr->t_Verify (AudioVolume, 0))
                    fwprintf (pLogFile, L"AudioVolume\t\t\t...PASS\n");
               else
                    fwprintf (pLogFile, L"AudioVolume\t\t\t...FAIL\n");
          }
     }

     return TRUE;
}


BOOL CDVDNavMgr::t_Verify (CURRENT_STATE c_state, ULONG ulParam) {
     OAFilterState pF_State;
     DVD_PLAYBACK_LOCATION *pLocation=NULL, *pLocation2=NULL;
     LONG lScreenMode=0;
     int stat=0;
     unsigned int total_time=0;
     ULONG uLong=0, uLong2=0;
     AM_LINE21_CCSTATE ccState;
     IMediaControl *imedia_ctrl;
     IVideoWindow *ivid_wind;
     DVD_DOMAIN domain;

     pLocation = (DVD_PLAYBACK_LOCATION*)malloc(sizeof(DVD_PLAYBACK_LOCATION));

     if (c_state == Paused) {
          m_pGraph->QueryInterface(IID_IMediaControl, (void**)&imedia_ctrl);
          imedia_ctrl->GetState (100, &pF_State);
          if (pF_State != 1)
               stat = FALSE;
          else
               stat = TRUE;
     }
     else
     if (c_state == Stopped) {
          m_pGraph->QueryInterface(IID_IMediaControl, (void**)&imedia_ctrl);
          imedia_ctrl->GetState (100, &pF_State);
          if (pF_State != 0)
               stat = FALSE;
          else
               stat = TRUE;
     }
     else
     if (c_state == FF || c_state == DoubleSpeed) {
          UINT time1=0, time2=0;
          m_pDvdInfo->GetCurrentLocation (pLocation);
          DVD_TIMECODE *pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time1 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          Sleep(2000);
          m_pDvdInfo->GetCurrentLocation (pLocation);
          pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time2 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          float fElapse = (float)(time2 - time1)/4.0;
          if (fElapse >= 1.5 && fElapse <= 2.5)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == VFF) {
          UINT time1=0, time2=0;
          m_pDvdInfo->GetCurrentLocation (pLocation);
          DVD_TIMECODE *pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time1 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          Sleep(2000);
          m_pDvdInfo->GetCurrentLocation (pLocation);
          pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time2 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          float fElapse = (float)(time2 - time1)/8.0;
          if (fElapse >= 6.0 && fElapse <= 10.0)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == Playing || c_state == NormalSpeed) {
          UINT time1=0, time2=0;
          m_pDvdInfo->GetCurrentLocation (pLocation);
          DVD_TIMECODE *pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time1 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          Sleep(2000);
          m_pDvdInfo->GetCurrentLocation (pLocation);
          pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time2 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          float fElapse = (float)(time2 - time1)/2.0;
          if (fElapse >= 0.5 && fElapse <= 1.5)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == FR) {
          UINT time1=0, time2=0;
          m_pDvdInfo->GetCurrentLocation (pLocation);
          DVD_TIMECODE *pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time1 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          Sleep(2000);
          m_pDvdInfo->GetCurrentLocation (pLocation);
          pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time2 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          float fElapse = (float)(time1 - time2)/4.0;
          if (fElapse >= 1.5 && fElapse <= 2.5)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == VFR) {
          UINT time1=0, time2=0;
          m_pDvdInfo->GetCurrentLocation (pLocation);
          DVD_TIMECODE *pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time1 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          Sleep(2000);
          m_pDvdInfo->GetCurrentLocation (pLocation);
          pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time2 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          float fElapse = (float)(time1 - time2)/8.0;
          if (fElapse >= 6.0 && fElapse <= 10.0)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == Slow) {
          UINT time1=0, time2=0;
          m_pDvdInfo->GetCurrentLocation (pLocation);
          DVD_TIMECODE *pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time1 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          Sleep(2000);
          m_pDvdInfo->GetCurrentLocation (pLocation);
          pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          time2 = pTime->Hours10*36000 + pTime->Hours1*3600 +
                  pTime->Minutes10*600 + pTime->Minutes1*60 +
                  pTime->Seconds10*10 + pTime->Seconds1;
          float fElapse = (float)(time2 - time1)/2.0;
          if (fElapse > 0.1 && fElapse < 0.75)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == Chapter) {
          m_pDvdInfo->GetCurrentLocation (pLocation);
          if (pLocation->ChapterNum == ulParam)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == Time) {
          DVD_TIMECODE *pTime = (DVD_TIMECODE*)&pLocation->TimeCode;
          m_pDvdInfo->GetCurrentLocation (pLocation);
          total_time = pTime->Hours10*36000 + pTime->Hours1*3600 +
                       pTime->Minutes10*600 + pTime->Minutes1*60 +
                       pTime->Seconds10*10 + pTime->Seconds1;
          if (total_time >= (ulParam-2) && total_time <= (ulParam+2))
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == FullScreen) {
          m_pGraph->QueryInterface(IID_IVideoWindow, (LPVOID*)&ivid_wind);
          ivid_wind->get_FullScreenMode (&lScreenMode);
          if (lScreenMode == OATRUE) {
               if (ulParam == TRUE)
                    stat = TRUE;
               else
                    stat = FALSE;
          }
          else {
               if (ulParam == TRUE)
                    stat = FALSE;
               else
                    stat = TRUE;
          }
     }
     else
     if (c_state == Title) {
          m_pDvdInfo->GetCurrentLocation (pLocation);
          if (pLocation->TitleNum == ulParam)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == CC) {
          m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder,(LPVOID*)&m_pL21Dec);
          if (m_pL21Dec == NULL)
               return FALSE;
          m_pL21Dec->GetServiceState (&ccState);
          if (ccState == AM_L21_CCSTATE_On) {
               if (ulParam == TRUE)
                    stat = TRUE;
               else
                    stat = FALSE;
          }
          else
          if (ccState == AM_L21_CCSTATE_Off) {
               if (ulParam == FALSE)
                    stat = TRUE;
               else
                    stat = FALSE;
          }
     }
     else
     if (c_state == Menu) {
          m_pDvdInfo->GetCurrentDomain (&domain);
          if (domain == DVD_DOMAIN_VideoManagerMenu ||
              domain == DVD_DOMAIN_VideoTitleSetMenu)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == Down || c_state == Right) {
          m_pDvdInfo->GetCurrentButton (&uLong2, &uLong);
          if (uLong == ulParam+1)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == Up || c_state == Left) {
          m_pDvdInfo->GetCurrentButton (&uLong2, &uLong);
          if (ulParam > 0)
               ulParam--;
          if (uLong == ulParam)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == Angle) {
          m_pDvdInfo->GetCurrentAngle (&uLong2, &uLong);
          if (uLong == ulParam)
               stat = TRUE;
          else
               stat = FALSE;
     }
     else
     if (c_state == AudioVolume) {
          LPCTSTR lpClass = TEXT("Volume Control");
          HWND hWnd = ::FindWindow (lpClass, NULL);
          if (hWnd == NULL)
               stat = FALSE;
          else
               stat = TRUE;
          ::SendMessage (hWnd, WM_CLOSE,0,0);
     }
     else
     if (c_state == Eject) {
          CDvdUIDlg *ui;
          ui = new CDvdUIDlg;
          stat = !ui->t_IsCdEjected();
          delete ui;
     }

     free (pLocation);
     return (stat);
}

BOOL CDvdplayApp::t_Ctrl (CDvdplayApp *pPlayApp) {
     TEST_CASE_LIST *tcase_list;
     int i=0;
     HWND hWnd=NULL;

     // Finds the dvdplay control window
     hWnd = ::FindWindow (_T("#32770"),_T("DVD Player"));

     tcase_list = (TEST_CASE_LIST*)malloc(sizeof(TEST_CASE_LIST));
     tcase_list = pPlayApp->t_ReadScriptFile (tcase_list,(LPCTSTR)pPlayApp->cFileName);
     if (tcase_list == NULL) {
          MessageBox (NULL, _T("Unable to find script file...Aborting!\0"),
                      _T("Dvdplay.exe"), MB_OK);
          free (tcase_list);
          if (hWnd != NULL)
               ::SendMessage(hWnd, WM_CLOSE,0,0);
          return FALSE;
     }

     // Loop to carry out each command
     while ((tcase_list->T_CASE[i] != NULL) && (i<1024)) {
          // Have no choice but to close file each time just in case
          // of a crash, at we'll have some results
          FILE *fp = _wfopen (L"c:\\dvdplay.log",L"a+");
          pPlayApp->m_pUIDlg->t_Parse (tcase_list->T_CASE[i]->line, fp);
          fclose (fp);
          i++;
     }

     free (tcase_list);
     ::SendMessage (hWnd, WM_CLOSE, 0, 0);
     return 0;
}

BOOL CDvdUIDlg::t_IsCdEjected () {
     return (m_bEjected);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\voladjst.cpp ===
// VolAdjst.cpp : implementation file
//

#include "stdafx.h"
#include "dvdplay.h"
#include "VolAdjst.h"
#include "navmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVolumeAdjust dialog


CVolumeAdjust::CVolumeAdjust(CWnd* pParent /*=NULL*/)
	: CDialog(CVolumeAdjust::IDD, pParent)
{
	//{{AFX_DATA_INIT(CVolumeAdjust)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CVolumeAdjust::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVolumeAdjust)
	DDX_Control(pDX, IDC_SLIDER_VOLUME, m_ctlVolume);
	DDX_Control(pDX, IDC_SLIDER_BALANCE, m_ctlBalance);
	DDX_Control(pDX, IDC_CHECK_MUTE, m_ctlMute);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVolumeAdjust, CDialog)
	//{{AFX_MSG_MAP(CVolumeAdjust)
	ON_BN_CLICKED(IDC_CHECK_MUTE, OnCheckMute)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVolumeAdjust message handlers

BOOL CVolumeAdjust::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	m_pDVDNavMgr = ((CDvdplayApp*) AfxGetApp())->GetDVDNavigatorMgr();
	if(!m_pDVDNavMgr)
		return FALSE;

	//IBasicAudio: -10000, right speaker is off; 10000, left is off; 0, both same loud.
	long lVolue=0;
	m_ctlBalance.SetRangeMin(-10000);
	m_ctlBalance.SetRangeMax(10000);
	m_ctlBalance.SetTicFreq(2000);
	m_ctlBalance.SetPageSize(5000);
	m_ctlBalance.SetLineSize(500);
	m_pDVDNavMgr->DVDVolumeControl(FALSE, FALSE, &lVolue); //Get current balance
	m_ctlBalance.SetPos(lVolue);
	m_iBalPosSave = lVolue;

	//IBasicAudio: volume=-10000 is silence, volume=0 is loudest
	//Note: Volume Slider is upside down: top=0, bottom=10000
	m_ctlVolume.SetRangeMin(0);
	m_ctlVolume.SetRangeMax(10000);
	m_ctlVolume.SetTicFreq(1000);
	m_ctlVolume.SetPageSize(2000);
	m_ctlVolume.SetLineSize(500);
	m_pDVDNavMgr->DVDVolumeControl(TRUE, FALSE, &lVolue);  //Get current volume
	m_ctlVolume.SetPos(-lVolue);
	m_iVolPosSave = lVolue;

	BOOL bMuteChecked = ((CDvdplayApp*) AfxGetApp())->GetMuteState();
	m_ctlMute.SetCheck(bMuteChecked);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CVolumeAdjust::OnCheckMute() 
{
    long lVol = -10000;
	UINT uiChecked = m_ctlMute.GetCheck();
	if(uiChecked == 1)        //mute is checked, set volume to silence (-10000)
	{
		m_pDVDNavMgr->DVDVolumeControl(TRUE, TRUE, &lVol);
	}
	else if(uiChecked == 0)   //mute is unchecked, resume volume
	{
		m_pDVDNavMgr->DVDVolumeControl(TRUE, TRUE, &m_iVolPosSave);
	}
	((CDvdplayApp*) AfxGetApp())->SetMuteState(uiChecked);
}

BOOL CVolumeAdjust::PreTranslateMessage(MSG* pMsg) 
{
	CWnd *pWnd = m_ctlVolume.GetFocus();
	if( pWnd == GetDlgItem(IDC_SLIDER_BALANCE)    ||
	    pWnd == GetDlgItem(IDC_SLIDER_VOLUME) )
	{
		long b = m_ctlBalance.GetPos();
		long v = m_ctlVolume.GetPos();
		if(b != m_iBalPosSave)
		{
			if(m_pDVDNavMgr->DVDVolumeControl(FALSE, TRUE, &b)) //set new balance
				m_iBalPosSave = b;			
		}
		if(v != -m_iVolPosSave)
		{
			m_iVolPosSave = -v;        //Note: this slider is upside down
			if(!m_ctlMute.GetCheck())  //set new volume only mute is not checked
				m_pDVDNavMgr->DVDVolumeControl(TRUE, TRUE, &m_iVolPosSave);			
		}
	}

	return CDialog::PreTranslateMessage(pMsg);
}

BOOL CVolumeAdjust::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	if (pHelpInfo->iContextType == HELPINFO_WINDOW)
        AfxGetApp()->WinHelp( pHelpInfo->dwContextId, HELP_CONTEXTPOPUP);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\videowin.h ===
#if !defined(AFX_VIDEOWIN_H__AF1C3AD2_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_)
#define AFX_VIDEOWIN_H__AF1C3AD2_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// VideoWin.h : header file
//
#define WM_AMPLAY_EVENT   WM_USER+200
class CDVDNavMgr;
class CDvdUIDlg;
/////////////////////////////////////////////////////////////////////////////
// CVideoWindow dialog

class CVideoWindow : public CDialog
{
// Construction
public:
	CVideoWindow(CWnd* pParent = NULL);   // standard constructor
	BOOL Create(CDvdUIDlg* pUIDlg = NULL);
	void AlignWindowsFrame();
// Dialog Data
	//{{AFX_DATA(CVideoWindow)
	enum { IDD = IDD_VIDEO_WINDOW };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA
	afx_msg LRESULT OnAMPlayEvent(WPARAM wParam, LPARAM lParam) ;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVideoWindow)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

   virtual BOOL PreTranslateMessage(MSG *pMsg);

// Implementation
protected:
	CDvdUIDlg*  m_pUIDlg;
	CDVDNavMgr* m_pDVDNavMgr;
	void DoRegionChange();

	// Generated message map functions
	//{{AFX_MSG(CVideoWindow)
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMove(int x, int y);
	afx_msg void OnSize(UINT nType, int cx, int cy);
   afx_msg void OnEjectDisc();
   afx_msg void OnVideowinPlayspeedNormalspeed();
   afx_msg void OnVideowinPlayspeedDoublespeed();
   afx_msg void OnVideowinPlayspeedHalfspeed();
   // afx_msg BOOL OnSysCommand(UINT nEventType, LPARAM lParam);
	//}}AFX_MSG
        afx_msg void OnPopUpMenu(UINT nID);
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VIDEOWIN_H__AF1C3AD2_D8FE_11D0_9BFC_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\videowin.cpp ===
// VideoWin.cpp : implementation file
//

#include "stdafx.h"
#include "dvdplay.h"
#include "VideoWin.h"
#include "navmgr.h"
#include "dvduidlg.h"
#include "dvdevcod.h"
#include "admindlg.h"
;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static CHAR THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVideoWindow dialog


CVideoWindow::CVideoWindow(CWnd* pParent /*=NULL*/)
        : CDialog(CVideoWindow::IDD, pParent)
{
        //{{AFX_DATA_INIT(CVideoWindow)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
        m_pUIDlg = NULL;
        m_pDVDNavMgr = NULL;
}

BOOL CVideoWindow::Create(CDvdUIDlg* pUIDlg)
{
        m_pDVDNavMgr = ((CDvdplayApp*) AfxGetApp())->GetDVDNavigatorMgr();
        ASSERT(m_pDVDNavMgr);
        m_pUIDlg = pUIDlg;
        return CDialog::Create(CVideoWindow::IDD);
}

void CVideoWindow::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CVideoWindow)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVideoWindow, CDialog)
        //{{AFX_MSG_MAP(CVideoWindow)
        ON_WM_KEYUP()
        ON_WM_MOUSEMOVE()
        ON_WM_LBUTTONUP()
        ON_WM_RBUTTONUP()
        ON_WM_MOVE()
        ON_WM_SIZE()
        ON_COMMAND(ID_VIDEOWIN_EJECTDISK, OnEjectDisc)
        ON_COMMAND(ID_VIDEOWIN_PLAYSPEED_NORMALSPEED, OnVideowinPlayspeedNormalspeed)
        ON_COMMAND(ID_VIDEOWIN_PLAYSPEED_DOUBLESPEED, OnVideowinPlayspeedDoublespeed)
        ON_COMMAND(ID_VIDEOWIN_PLAYSPEED_HALFSPEED, OnVideowinPlayspeedHalfspeed)
        //}}AFX_MSG_MAP
        ON_MESSAGE(WM_AMPLAY_EVENT, OnAMPlayEvent)
        ON_COMMAND_EX(ID_VIDEOWIN_PLAY,                 OnPopUpMenu)
        ON_COMMAND_EX(ID_VIDEOWIN_PAUSE,                OnPopUpMenu)
        ON_COMMAND_EX(ID_VIDEOWIN_STOP,                 OnPopUpMenu)
        ON_COMMAND_EX(ID_VIDEOWIN_FASTFORWARD,          OnPopUpMenu)
        ON_COMMAND_EX(ID_VIDEOWIN_FASTREWIND,           OnPopUpMenu)
        ON_COMMAND_EX(ID_VIDEOWIN_VERYFASTFORWARD,      OnPopUpMenu)
        ON_COMMAND_EX(ID_VIDEOWIN_VERYFASTREWIND,       OnPopUpMenu)
        ON_COMMAND_EX(ID_VIDEOWIN_GOTO_PREVIOUSCHAPTER, OnPopUpMenu)
        ON_COMMAND_EX(ID_VIDEOWIN_GOTO_NEXTCHAPTER,     OnPopUpMenu)
        ON_COMMAND_EX(ID_VIDEOWIN_FULLSCREEN,           OnPopUpMenu)
        ON_COMMAND_EX(ID_VIDEOWIN_MENU,                 OnPopUpMenu)
        // ON_MESSAGE(WM_SYSCOMMAND, OnSysCommand)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVideoWindow message handlers

void CVideoWindow::OnEjectDisc() {
   m_pUIDlg->OnEjectDisc();
}

void CVideoWindow::OnVideowinPlayspeedNormalspeed() 
{
        m_pDVDNavMgr->DVDChangePlaySpeed(1.0);
}

void CVideoWindow::OnVideowinPlayspeedDoublespeed() 
{
        m_pDVDNavMgr->DVDChangePlaySpeed(2.0);
}

void CVideoWindow::OnVideowinPlayspeedHalfspeed() 
{
        m_pDVDNavMgr->DVDChangePlaySpeed(0.5);
}

void CVideoWindow::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
        TRACE(TEXT("Inside OnKeyUp(), TCHAR=%c\n"), nChar) ;   

    switch(nChar)
        {
                case VK_ESCAPE:
                case VK_TAB:
                        if(m_pDVDNavMgr)
                        m_pDVDNavMgr->DVDStopFullScreenMode() ;
                        break;
                case VK_UP:
                        m_pDVDNavMgr->DVDCursorUp();
                        break;
                case VK_DOWN:
                        m_pDVDNavMgr->DVDCursorDown();
                        break;
                case VK_LEFT:
                        m_pDVDNavMgr->DVDCursorLeft();
                        break;
                case VK_RIGHT:
                        m_pDVDNavMgr->DVDCursorRight();
                        break;
                case VK_RETURN:                 
                        m_pDVDNavMgr->DVDCursorSelect();
                        break;
        }
}

LRESULT CVideoWindow::OnAMPlayEvent(WPARAM wParam, LPARAM lParam)
{
    IMediaEventEx *pME = (IMediaEventEx *) (LPVOID) lParam ;
    ASSERT(pME) ;

    LONG    lEvent ;
    LONG_PTR lParam1, lParam2 ;
    HRESULT hr ;
    IMediaControl *pMC ;

    while(SUCCEEDED(pME->GetEvent(&lEvent, &lParam1, &lParam2, 0)))
    {
                DVD_TIMECODE * ptrTimeCode;
                switch (lEvent)
                {
                        case EC_DVD_PARENTAL_LEVEL_CHANGE:
                                //Cannot run if parental level is too low. 
                                //But if parental level is changed OK and try again, it should run
                                if((UINT)lParam1 > ((CDvdplayApp*) AfxGetApp())->GetParentCtrlLevel())
                                {
                                        m_pDVDNavMgr->DVDStop();
                                        CAdminDlg dlg;
                                        if( dlg.DoModal() == IDOK )
                                        {
                                                //reset settings from Navigator's default to App's 
                                                m_pDVDNavMgr->DVDSetParentControlLevel((ULONG)lParam1);
                                                m_pDVDNavMgr->DVDVideoLetterbox();
                                                m_pDVDNavMgr->DVDSubPictureOn(FALSE);
                                                m_pDVDNavMgr->SetNeedInitNav(FALSE);
                                                m_pDVDNavMgr->DVDPlay();
                                        }

                                }                               
                                break;
                        case EC_DVD_ERROR:
                                if(lParam1 == DVD_ERROR_LowParentalLevel)
                                {
                                        m_pDVDNavMgr->DVDStop();
                                        DVDMessageBox(this->m_hWnd, IDS_RATED_HIGH);
                                }
                                if(lParam1 == DVD_ERROR_InvalidDiscRegion)
                                {
                                        DoRegionChange();
                                        //Informs dvdplay.cpp not to quit, no matter region is changed or not.
                                        ((CDvdplayApp*) AfxGetApp())->SetDiscRegionDiff(TRUE);
                                }
                                if(lParam1 == DVD_ERROR_MacrovisionFail)
                                {
                                        m_pDVDNavMgr->DVDStop();
                                        CString csMsg;
                                        csMsg.LoadString(IDS_MACROVISION_FAIL);
                                        DVDMessageBox(m_hWnd, csMsg);
                                }
                                break;
                        case EC_DVD_STILL_ON:
                                if(lParam1 == 1 && lParam2 == -1)
                                {
                                        if(m_pDVDNavMgr)
                                        m_pDVDNavMgr->SetStillOn(TRUE);
                                }
                                break;
                        case EC_DVD_STILL_OFF:
                                if(m_pDVDNavMgr)
                                        m_pDVDNavMgr->SetStillOn(FALSE);
                                break;
                        case EC_DVD_DOMAIN_CHANGE:
                        // Note: 
                        //1) Navigator sends DVD_DOMAIN_VideoTitleSetMenu msg for both FBI warning and MENU
                        //2) EC_DVD_BUTTON_CHANGE comes later than DVD_DOMAIN_VideoTitleSetMenu and DVD_DOMAIN_Title
                        //3) When real Menu is on, we get DVD_DOMAIN_VideoTitleSetMenu first then EC_DVD_BUTTON_CHANGE
                        //4) event comes with lParam1(available button) > 0. FBI warning doesn't have it.
                                m_pUIDlg->OnDomainChange((LONG)lParam1);
                                break;
                        case EC_DVD_BUTTON_CHANGE:
                        //Enable arrow buttons and set messageDrain on
                                if(lParam1 > 0)
                                {
                                        CString csCaption, tmp;
                                        m_pUIDlg->GetDlgItem(IDB_MENU)->GetWindowText(tmp);
                                        csCaption.LoadString(IDS_RESUME);
                                        if(!tmp.Compare(csCaption))  //if already enabled, return.
                                                break;

                                        m_pUIDlg->GetDlgItem(IDB_MENU)->SetWindowText(csCaption);                                               
                                        m_pUIDlg->EnableEnterArrowButtons(TRUE);                        
                                        m_pDVDNavMgr->MessageDrainOn(TRUE);
                                        m_pDVDNavMgr->SetMenuOn(TRUE);
                                }
                        //Disable arrow buttons and set messageDrain off
                                else if(lParam1 == 0 && lParam2 == 0)
                                {
                                        CString csCaption;
                                        csCaption.LoadString(IDS_MENU);
                                        m_pUIDlg->GetDlgItem(IDB_MENU)->SetWindowText(csCaption);
                                        m_pUIDlg->EnableEnterArrowButtons(FALSE);
                                        m_pDVDNavMgr->MessageDrainOn(FALSE);
                                        m_pDVDNavMgr->SetMenuOn(FALSE);
                                }
                                else
                                        ASSERT(FALSE);
                                break;
                        case EC_DVD_TITLE_CHANGE:               
                                wsprintf(m_pUIDlg->szTitleNumber, TEXT("%2.2d"), lParam1);
                                m_pUIDlg->PainBlackBox();
                                break;
                        case EC_DVD_CHAPTER_START:
                                wsprintf(m_pUIDlg->szChapterNumber, TEXT("%2.2d"), lParam1);
                                m_pUIDlg->PainBlackBox();
                                break;
                        case EC_DVD_CURRENT_TIME:
                                ptrTimeCode = (DVD_TIMECODE *) &lParam1;
                                wsprintf(m_pUIDlg->szTimePrograss, TEXT("%d%d:%d%d:%d%d"), 
                                                 ptrTimeCode->Hours10,     ptrTimeCode->Hours1, 
                                                 ptrTimeCode->Minutes10,   ptrTimeCode->Minutes1,
                                                 ptrTimeCode->Seconds10,   ptrTimeCode->Seconds1);
                                m_pUIDlg->PainBlackBox();
                                break;
                        case EC_DVD_PLAYBACK_STOPPED:
                                //m_pDVDNavMgr->DVDNotifyPlaybackStopped();
                                m_pDVDNavMgr->DVDStop();
                                break;
                        case EC_COMPLETE:
                                // Should we do a Stop() on end of movie?
                                hr = pME->QueryInterface(IID_IMediaControl, (void **)&pMC ) ;
                                ASSERT(SUCCEEDED(hr) && NULL != pMC) ;
                                pMC->Stop() ;
                                pMC->Release() ;
                                break;
                        // fall through now
                        case EC_FULLSCREEN_LOST:
                        case EC_USERABORT:
                        case EC_ERRORABORT:
                                if(m_pDVDNavMgr)
                                        m_pDVDNavMgr->DVDStopFullScreenMode() ;
                                break ;

                        default:
                                TRACE(TEXT("Unknown DVD event. lEvent=0x%lx lParam1=0x%lx lParam2=0x%lx\n"), lEvent, lParam1, lParam2) ;
                                break ;
                }

                pME->FreeEventParams(lEvent, lParam1, lParam2) ;
        }
    return 0 ;
}

void CVideoWindow::OnMouseMove(UINT nFlags, CPoint point) 
{
        if(m_pDVDNavMgr)
            m_pDVDNavMgr->DVDMouseSelect(point);
}

void CVideoWindow::OnLButtonUp(UINT nFlags, CPoint point) 
{
        if(m_pDVDNavMgr)
            m_pDVDNavMgr->DVDMouseClick(point);                                 
}

void CVideoWindow::OnRButtonUp(UINT nFlags, CPoint point) 
{
        if(m_pDVDNavMgr && m_pDVDNavMgr->IsFullScreenMode())
        {
                CMenu menu;
                menu.LoadMenu(IDR_MENU_VIDEOWIN);
                if( m_pDVDNavMgr->IsMenuOn() )
                {
                        CString csResume;
                        csResume.LoadString(IDS_RESUME);
                        menu.GetSubMenu(0)->ModifyMenu(ID_VIDEOWIN_MENU, MF_BYCOMMAND | MF_STRING, ID_VIDEOWIN_MENU, csResume);
                }
                menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
        }
}

void CVideoWindow::OnPopUpMenu(UINT nID)
{
        switch(nID)
        {
                case ID_VIDEOWIN_PLAY:
                        m_pUIDlg->OnPlay();
                        break;
                case ID_VIDEOWIN_PAUSE:
                        m_pUIDlg->OnPause();
                        break;
                case ID_VIDEOWIN_STOP:
                        m_pUIDlg->OnStop();
                        break;
                case ID_VIDEOWIN_FASTFORWARD:
                        m_pUIDlg->OnFastForward();
                        break;
                case ID_VIDEOWIN_FASTREWIND:
                        m_pUIDlg->OnFastRewind();
                        break;
                case ID_VIDEOWIN_VERYFASTFORWARD:
                        m_pUIDlg->OnVeryFastForward();
                        break;
                case ID_VIDEOWIN_VERYFASTREWIND:
                        m_pUIDlg->OnVeryFastRewind();
                        break;
                case ID_VIDEOWIN_GOTO_PREVIOUSCHAPTER:
                        m_pUIDlg->OnPreviosChapter();
                        break;
                case ID_VIDEOWIN_GOTO_NEXTCHAPTER:
                        m_pUIDlg->OnNextChapter();
                        break;
                case ID_VIDEOWIN_FULLSCREEN:
                        m_pUIDlg->OnFullScreen();
                        break;                  
                case ID_VIDEOWIN_MENU:
                        m_pUIDlg->OnMenu();
                        break;
        }
}

void CVideoWindow::OnMove(int x, int y) 
{
        if(m_pDVDNavMgr->IsVideoWindowMaximized())
                return;

        long lLeft, lTop, lWidth, lHeight;
        m_pDVDNavMgr->DVDGetVideoWindowSize(&lLeft, &lTop, &lWidth, &lHeight);
        m_pDVDNavMgr->DVDSetVideoWindowSize(x, y, lWidth, lHeight);
}

void CVideoWindow::OnSize(UINT nType, int cx, int cy) 
{
        long lLeft, lTop, lWidth, lHeight;
        m_pDVDNavMgr->DVDGetVideoWindowSize(&lLeft, &lTop, &lWidth, &lHeight);
        m_pDVDNavMgr->DVDSetVideoWindowSize(lLeft, lTop, cx, cy);
}

void CVideoWindow::AlignWindowsFrame()
{
        long lLeft, lTop, lWidth, lHeight;
        m_pDVDNavMgr->DVDGetVideoWindowSize(&lLeft, &lTop, &lWidth, &lHeight);
        MoveWindow(lLeft, lTop, lWidth, lHeight, 0);
}

void CVideoWindow::DoRegionChange()
{
typedef BOOL (*DVDPPLAUNCHER) (HWND HWnd, CHAR DriveLetter);

        BOOL regionChanged = FALSE;
        OSVERSIONINFO ver;
        ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&ver);

        if (ver.dwPlatformId==VER_PLATFORM_WIN32_NT) {

                HINSTANCE dllInstance;
                DVDPPLAUNCHER dvdPPLauncher;
                BOOL er;
                TCHAR szCmdLine[MAX_PATH], szDriveLetter[4];
                CHAR szDriveLetterA[4];

                //
                // tell the user why we are showing the dvd region property page
                //
                DVDMessageBox(m_hWnd, IDS_REGION_CHANGE_PROMPT);

                m_pUIDlg->getCDDriveLetter(szDriveLetter);
#ifdef UNICODE
                WideCharToMultiByte(
                    0,
                    0,
                    szDriveLetter,
                    -1,
                    szDriveLetterA,
                    sizeof(szDriveLetterA),
                    NULL,
                    NULL );
#else
               strcpy(szDriveLetterA,szDriveLetter);
#endif
                GetSystemDirectory(szCmdLine, MAX_PATH);
                lstrcat(szCmdLine, _T("\\storprop.dll"));
        
                dllInstance = LoadLibrary (szCmdLine);
                if (dllInstance) {

                        dvdPPLauncher = (DVDPPLAUNCHER) GetProcAddress(
                                                            dllInstance,
                                                            "DvdLauncher");
                
                        if (dvdPPLauncher) {

                                regionChanged = dvdPPLauncher(this->m_hWnd,
                                                              szDriveLetterA[0]);
                        }

                        FreeLibrary(dllInstance);
                }

        } else {

                //Get path of \windows\dvdrgn.exe and command line string
                TCHAR szCmdLine[MAX_PATH], szDriveLetter[4];
                CString csModuleName; 
                m_pUIDlg->getCDDriveLetter(szDriveLetter);
                GetWindowsDirectory(szCmdLine, MAX_PATH);
                lstrcat(szCmdLine, _T("\\dvdrgn.exe "));
                csModuleName = (CString) szCmdLine;
                CString csTmp = szDriveLetter[0];
                lstrcat(szCmdLine, csTmp);
        
                //Prepare and execuate dvdrgn.exe
                STARTUPINFO StartupInfo;
                PROCESS_INFORMATION ProcessInfo;
                StartupInfo.cb          = sizeof(StartupInfo);
                StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;
                StartupInfo.wShowWindow = SW_SHOWNORMAL;
                StartupInfo.lpReserved  = NULL;
                StartupInfo.lpDesktop   = NULL;
                StartupInfo.lpTitle     = NULL;
                StartupInfo.cbReserved2 = 0;
                StartupInfo.lpReserved2 = NULL;
                if( CreateProcess(csModuleName, szCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS,
                                                  NULL, NULL, &StartupInfo, &ProcessInfo) )
                {
                        //Wait dvdrgn.exe finishes.
                        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
                        DWORD dwRet = 1;
                        BOOL bRet = GetExitCodeProcess(ProcessInfo.hProcess, &dwRet);
                        if(dwRet == 0) //User changed the region successfully
                        {
                            regionChanged = TRUE;
    
                        } //else(dwRet != 0), region is not changed. do nothing.
                }
        }

        if (regionChanged) {

                //Delete old Graph and create new Graph
                if(!m_pDVDNavMgr->DVDResetGraph())
                        return;
        } else {

                DVDMessageBox(m_hWnd, IDS_REGION_CHANGE_FAIL);

                //Close the "DVD Player cannot play this file" msg box.
                //Note: This msg box is called earlier than this event comes.
                CString csSection, csEntry, csClassName, csTitle;
                csSection.LoadString(IDS_UI_WINDOW_POS);
                csEntry.LoadString(IDS_UIWND_CLASSNAME);
                csClassName = ((CDvdplayApp*) AfxGetApp())->GetProfileString((LPCTSTR)csSection, (LPCTSTR)csEntry, NULL);
                csTitle.LoadString(IDS_MSGBOX_TITLE);
                HWND hWnd = ::FindWindow((LPCTSTR)csClassName,  (LPCTSTR) csTitle);
                if(hWnd != NULL)
                {
                        //Make sure not the UI window. UI has the same Title and Class Name.
                        if(::GetDlgItem(hWnd, IDC_PLAY) == NULL)
                        {
                                //Delete the msg box.
                                ::SendMessage(hWnd, WM_CLOSE, 0, 0);
                                m_pUIDlg->SetForegroundWindow();
                                m_pUIDlg->SetFocus();
                        }               
                }
        }
}

#if 0 // see comment before CDvdUIDlg::OnSysCommand
// block the screen saver while running
BOOL CVideoWindow::OnSysCommand(UINT nEventType, LPARAM lParam) {
   if (nEventType == SC_SCREENSAVE)
      DbgLog((LOG_TRACE,2,"SC_SCREENSAVE"));
   if ((nEventType == SC_SCREENSAVE) && (m_pDVDNavMgr->DVDCanStop())) {
      DbgLog((LOG_TRACE,2,"DVD player movie window: screen saver is trying to kick in"));
      return FALSE;
   }
   else {
      CDialog::OnSysCommand(nEventType, lParam);
      return TRUE;
   }
}
#endif

// Intercept the screen saver - see comment in CDvdUIDlg::PreTranslateMessage
BOOL CVideoWindow::PreTranslateMessage(MSG *pMsg) {
   if (//(pMsg->hwnd == m_hWnd) &&
       (pMsg->message == WM_SYSCOMMAND) &&
       (pMsg->wParam == SC_SCREENSAVE) &&
       (m_pDVDNavMgr->DVDCanStop())) {
      DbgLog((LOG_TRACE,2,"DVD player video window: intercepting the screen saver"));
      return TRUE;
   }
   return CDialog::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dyndrvr\dyndrvr.c ===
//---------------------------------------------------------------------------
//
//  Module:   dyndrvr.c
//
//  Description:
//
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//
//@@END_MSINTERNAL
//---------------------------------------------------------------------------
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996  All Rights Reserved.
//
//---------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

VOID InstallDriver
(
   IN SC_HANDLE   hscManager,
   IN LPCTSTR     szDriverName,
   IN LPCTSTR     szExeName
) ;

VOID StopDriver
(
   IN SC_HANDLE   hscManager,
   IN LPCTSTR     szDriverName
) ;

VOID StartDriver
(
   IN SC_HANDLE   hscManager,
   IN LPCTSTR     szDriverName
) ;

VOID RemoveDriver
(
   IN SC_HANDLE   hscManager,
   IN LPCTSTR     szDriverName
) ;

VOID _cdecl main
(
   IN int   argc,
   IN char  **argv
)
{
   SC_HANDLE hscManager ;

   if (argc != 3)
   {
      char currentDirectory[128];

      printf ("usage: dyndrvr <driver name> {<.sys path> | <remove>}\n");
      exit( 1 ) ;
   }

   hscManager =
      OpenSCManager( NULL,                     // machine (NULL == local)
                     NULL,                     // database (NULL == default)
                     SC_MANAGER_ALL_ACCESS ) ; // access required )

   if (!stricmp( argv[2], "remove" ))
   {
      StopDriver( hscManager, argv[1] ) ;
      RemoveDriver( hscManager, argv[1] ) ;
   }
   else
   {
      InstallDriver( hscManager, argv[1], argv[2] ) ;
      StartDriver( hscManager, argv[1] ) ;
   }

   CloseServiceHandle( hscManager ) ;
}


VOID InstallDriver
(
   IN SC_HANDLE   hscManager,
   IN LPCTSTR     szDriverName,
   IN LPCTSTR     szExeName
)
{
   SC_HANDLE  hscService;
   ULONG      ulError ;

   //
   // NOTE: This creates an entry for a standalone driver. If this
   //       is modified for use with a driver that requires a Tag,
   //       Group, and/or Dependencies, it may be necessary to
   //       query the registry for existing driver information
   //       (in order to determine a unique Tag, etc.).
   //

   hscService = CreateService( hscManager,            // SCManager database
                               szDriverName,          // name of service
                               szDriverName,          // name to display
                               SERVICE_ALL_ACCESS,    // desired access
                               SERVICE_KERNEL_DRIVER, // service type
                               SERVICE_DEMAND_START,  // start type
                               SERVICE_ERROR_NORMAL,  // error control type
                               szExeName,             // service's binary
                               NULL,                  // no load ordering group
                               NULL,                  // no tag identifier
                               NULL,                  // no dependencies
                               NULL,                  // LocalSystem account
                               NULL ) ;               // no password

   if (hscService == NULL)
   {
       ulError = GetLastError() ;

       if (ulError == ERROR_SERVICE_EXISTS)
       {
           //
           // A common cause of failure (easier to read than an error code)
           //

           printf ("failure: CreateService, ERROR_SERVICE_EXISTS\n");
       }
       else
       {
           printf ("failure: CreateService (0x%02x)\n",
                   ulError
                   );
       }
   }
   else
      printf( "CreateService SUCCESS\n" ) ;

   CloseServiceHandle( hscService ) ;
}

VOID StartDriver
(
   IN SC_HANDLE   hscManager,
   IN LPCTSTR     szDriverName
)
{   
    SC_HANDLE  hscService;
    DWORD      ulError;

    hscService = OpenService (hscManager,
                              szDriverName,
                              SERVICE_ALL_ACCESS
                              );

    if (hscService == NULL)
        printf ("failure: OpenService (0x%02x)\n", GetLastError());

    if (StartService( hscService,    // service identifier
                      0,             // number of arguments
                      NULL           // pointer to arguments
                      ))
        printf ("StartService SUCCESS\n");
    else
    {
        ulError = GetLastError();

        if (ulError == ERROR_SERVICE_ALREADY_RUNNING)
        {
            //
            // A common cause of failure (easier to read than an error code)
            //

            printf ("failure: StartService, ERROR_SERVICE_ALREADY_RUNNING\n");
        }
        else
        {
            printf ("failure: StartService (0x%02x)\n",
                    ulError
                    );
        }
    }

    CloseServiceHandle (hscService);
}

VOID StopDriver
(
   IN SC_HANDLE   hscManager,
   IN LPCTSTR     szDriverName
)
{
   SC_HANDLE       hscService;
   SERVICE_STATUS  serviceStatus;

   hscService = OpenService( hscManager,
                             szDriverName,
                             SERVICE_ALL_ACCESS ) ;

   if (hscService == NULL)
      printf( "failure: OpenService (0x%02x)\n", GetLastError() ) ;

   if (ControlService( hscService, SERVICE_CONTROL_STOP,
                       &serviceStatus ))
      printf( "ControlService SUCCESS\n" ) ;

   else
      printf( "failure: ControlService (0x%02x)\n", GetLastError() ) ;

   CloseServiceHandle( hscService ) ;
}

VOID RemoveDriver
(
   IN SC_HANDLE   hscManager,
   IN LPCTSTR     szDriverName
)
{
   SC_HANDLE  hscService;
   BOOL       fRet ;

   hscService = OpenService( hscManager,
                             szDriverName,
                             SERVICE_ALL_ACCESS ) ; 

   if (hscService == NULL)
      printf( "failure: OpenService (0x%02x)\n", GetLastError() ) ;

   if (DeleteService( hscService ))
      printf( "DeleteService SUCCESS\n" ) ;
   else
      printf( "failure: DeleteService (0x%02x)\n", GetLastError() ) ;

   CloseServiceHandle( hscService ) ;
}

//---------------------------------------------------------------------------
//  End of File: dyndrvr.c
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\dvdplay\voladjst.h ===
#if !defined(AFX_VOLADJST_H__8BC01241_D9AB_11D0_9BFC_00AA00605CD5__INCLUDED_)
#define AFX_VOLADJST_H__8BC01241_D9AB_11D0_9BFC_00AA00605CD5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// VolAdjst.h : header file
//

class CDVDNavMgr;
/////////////////////////////////////////////////////////////////////////////
// CVolumeAdjust dialog

class CVolumeAdjust : public CDialog
{
// Construction
public:
	CVolumeAdjust(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CVolumeAdjust)
	enum { IDD = IDD_DIALOG_AUDIO_VOLUME };
	CSliderCtrl	m_ctlVolume;
	CSliderCtrl	m_ctlBalance;
	CButton	m_ctlMute;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVolumeAdjust)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	long       m_iBalPosSave;
	long       m_iVolPosSave;
	CDVDNavMgr *m_pDVDNavMgr;

	// Generated message map functions
	//{{AFX_MSG(CVolumeAdjust)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckMute();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VOLADJST_H__8BC01241_D9AB_11D0_9BFC_00AA00605CD5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\encapi\private.h ===
//**************************************************************************
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
//
// FileName:        private.h
//
//**************************************************************************

//
// Abstract:        Encoder API private header
//

#include <windows.h>
#include <commctrl.h>
#include <memory.h>
#include <stdio.h>

#include <streams.h>
#include <amstream.h>

#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>

#include <strmif.h>

#include "baseapi.h"
#include "videoenc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\encapi\baseapi.cpp ===
//**************************************************************************
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
//
// FileName:        baseapi.cpp
//
//**************************************************************************

//
// Abstract:        Base encoder API layer
//

//
// NOTES:
//
// If ENFORCE_ONLY_ONE_RANGE_AND_DEFAULT is defined, the plug-in will
// enforce that only one range and default value is specified for the underlying
// kernel object (it will E_FAIL the calls to get range or get default value
// if there is more than one).  If this is not defined, the range and default
// value returned is the FIRST one specified by the driver.
//

#include "private.h"

/*************************************************

    Function:

        CBaseEncoderAPI::CBaseEncoderAPI

    Description:

        Base encoder API proxy constructor

    Arguments:

        UnkOuter -
            The outer unknown (object we are aggregating with)

        Name -
            The name to use to pass to CUnknown

        PropertySetGUID -
            The property set GUID to use for all property requests

        hr - 
            The status to pass back from construction

    Return Value:

        None

*************************************************/

CBaseEncoderAPI::
CBaseEncoderAPI (
    IN LPUNKNOWN UnkOuter,
    IN TCHAR *Name,
    IN HRESULT *hr
    ) :
    CUnknown (Name, UnkOuter, hr),
    m_ObjectHandle (INVALID_HANDLE_VALUE)

{

    if (!UnkOuter) {
        *hr = VFW_E_NEED_OWNER;
        return;
    }

    IKsObject *Object = NULL;

    *hr = UnkOuter -> QueryInterface (
        __uuidof (IKsObject),
        reinterpret_cast <PVOID *> (&Object)
        );

    if (SUCCEEDED (*hr)) {
        m_ObjectHandle = Object -> KsGetObjectHandle ();
        if (!m_ObjectHandle || m_ObjectHandle == INVALID_HANDLE_VALUE) {
            *hr = E_UNEXPECTED;
        }
        Object -> Release ();
    }
}

/*************************************************

    Function:

        CBaseEncoderAPI::~CBaseEncoderAPI

    Description:

        Destroy the base encoder API layer

    Arguments:

        None

    Return Value:

        None

*************************************************/

CBaseEncoderAPI::
~CBaseEncoderAPI (
    )

{
    m_ObjectHandle = NULL;
}

/*************************************************

    Function:

        CBaseEncoderAPI::KsSynchronousDeviceControl

    Description:

        KsSynchronousDeviceControl pulled into encapi.dll to remove loader
        dependence on KsProxy.  It's either this or make it delayload and
        deal intelligently with delayload failures.  This is less bloat.

    Arguments:

        Per KsSynchronousDeviceControl

    Return Value:

        Per KsSynchronousDeviceControl

*************************************************/

//
// Pull KsSynchronousDeviceControl into encapi.dll to remove dependence on
// ksproxy.ax.  It's either this, make ksproxy delayload, or split this DLL.
//
#define STATUS_SOME_NOT_MAPPED      0x00000107
#define STATUS_MORE_ENTRIES         0x00000105
#define STATUS_ALERTED              0x00000101

HRESULT
CBaseEncoderAPI::
KsSynchronousDeviceControl(
    HANDLE Handle,
    ULONG IoControl,
    PVOID InBuffer,
    ULONG InLength,
    PVOID OutBuffer,
    ULONG OutLength,
    PULONG BytesReturned
    )

{
    OVERLAPPED  ov;
    HRESULT     hr;
    DWORD       LastError;

    RtlZeroMemory(&ov, sizeof(ov));
    ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if ( !ov.hEvent ) {
        LastError = GetLastError();
        return HRESULT_FROM_WIN32(LastError);
    }
    if (!DeviceIoControl(
        Handle,
        IoControl,
        InBuffer,
        InLength,
        OutBuffer,
        OutLength,
        BytesReturned,
        &ov)) {
        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32(LastError);
        if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
            if (GetOverlappedResult(Handle, &ov, BytesReturned, TRUE)) {
                hr = NOERROR;
            } else {
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            }
        }
    } else {
        //
        // DeviceIoControl returns TRUE on success, even if the success
        // was not STATUS_SUCCESS. It also does not set the last error
        // on any successful return. Therefore any of the successful
        // returns which standard properties can return are not returned.
        //
        switch (ov.Internal) {
        case STATUS_SOME_NOT_MAPPED:
            hr = HRESULT_FROM_WIN32(ERROR_SOME_NOT_MAPPED);
            break;
        case STATUS_MORE_ENTRIES:
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            break;
        case STATUS_ALERTED:
            hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
            break;
        default:
            hr = NOERROR;
            break;
        }
    }
    CloseHandle(ov.hEvent);
    return hr;
}


/*************************************************

    Function:

        CBaseEncoderAPI::KsProperty

    Description:

        Submit a property to the kernel.

    Arguments:

        Per IKsControl::KsProperty

    Return Value:

        Per IKsControl::KsProperty

*************************************************/

HRESULT
CBaseEncoderAPI::
KsProperty (
    IN PKSPROPERTY Property,
    IN ULONG PropertyLength,
    IN OUT LPVOID PropertyData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )

{

    ASSERT (m_ObjectHandle);

    return KsSynchronousDeviceControl (
        m_ObjectHandle,
        IOCTL_KS_PROPERTY,
        Property,
        PropertyLength,
        PropertyData,
        DataLength,
        BytesReturned
        );

}

/*************************************************

    Function:

        CBaseEncoderAPI::IsSupported

    Description:

        Determine whether a given parameter is supported
        by the underlying kernel object.

    Arguments:

        Api -
            The Api (XXX_API) / parameter to determine support
            for

    Return Value:

        S_OK -
            Indicates that support is available

        E_NOTIMPL -
            Indicates that support is not available

        Other error -
            Indicates error processing the request

*************************************************/

HRESULT
CBaseEncoderAPI::
Base_IsSupported (
    IN const GUID *Api
    )

{

    ASSERT (Api);
    if (!Api) {
        return E_POINTER;
    }

    KSPROPERTY Property;
    KSPROPERTY_DESCRIPTION Description;

    Property.Set = *Api;
    Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
    Property.Id = 0;

    ULONG BytesReturned;
    HRESULT hr = KsProperty (
        &Property,
        sizeof (Property),
        &Description,
        sizeof (Description),
        &BytesReturned
        );


    if (SUCCEEDED (hr)) {
        if (BytesReturned >= sizeof (Description)) {
            hr = S_OK;
        } else {
            hr = E_FAIL;
        }
    } else {
        //
        // TODO: Figure out error translation and only return
        // E_NOTIMPL on couldn't find the item.
        //
        hr = E_NOTIMPL;
    }

    return hr;

}

/*************************************************

    Function:

        CBaseEncoderAPI::IsAvailable

    Description:

        Determine whether a given parameter is available
        by the underlying kernel object.  Availability takes
        into account other settings while supported does not.

    Arguments:

        Api -
            The Api (XXX_API) / parameter to determine support
            for

    Return Value:

        S_OK -
            Indicates that support is available

        E_NOTIMPL -
            Indicates that support is not available

        Other error -
            Indicates error processing the request

*************************************************/

HRESULT
CBaseEncoderAPI::
Base_IsAvailable (
    IN const GUID *Api
    )

{

    ASSERT (Api);
    if (!Api) {
        return E_POINTER;
    }

    KSPROPERTY Property;
    KSPROPERTY_DESCRIPTION Description;

    Property.Set = *Api;
    Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
    Property.Id = 0;

    ULONG BytesReturned;
    HRESULT hr = KsProperty (
        &Property,
        sizeof (Property),
        &Description,
        sizeof (Description),
        &BytesReturned
        );


    if (SUCCEEDED (hr)) {
        if (BytesReturned >= sizeof (Description)) {
            if (Description.AccessFlags &
                (KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET)) {

                hr = S_OK;

            } else {
                hr = E_NOTIMPL;
            }
        } else {
            hr = E_FAIL;
        }
    }

    return hr;

}

/*************************************************

    Function:

        CBaseEncoderAPI::ParseMembersList

    Description:

        Parse a members list returned from the kernel for either a range
        specification or a values specification.  Adjust the input parameters
        to reflect the sought list and remaining count of members.  Return
        whether any such list entry was found.

    Arguments:

        MembersList -
            The members list to start parsing at.  This will be adjusted
            to the sought element on return

        RemainingMembersSize -
            The size of remaining members in the list.  This will be adjusted
            to the remaining elements after *MembersList

        FindRange -
            Determines whether to find a (stepped) range (TRUE) or a value
            (FALSE)

    Return Value:

        Whether said entry can be found

*************************************************/

BOOLEAN
CBaseEncoderAPI::
ParseMembersList (
    IN OUT PKSPROPERTY_MEMBERSHEADER *MembersHeader,
    IN OUT PULONG RemainingMembersSize,
    IN BOOLEAN FindRange
    )

{

    // 
    // This is internal only.  Don't bother with E_POINTER.
    //
    ASSERT (MembersHeader && RemainingMembersSize);

    BOOLEAN Found = FALSE;

    //
    // Look through the list for an element which is a range/stepped range or
    // a value as specified by FindRange.
    //
    while (*RemainingMembersSize && !Found) {

        if (*RemainingMembersSize < sizeof (KSPROPERTY_MEMBERSHEADER)) {
            *RemainingMembersSize = 0;
            break;
        }

        if (FindRange) {
            if ((*MembersHeader) -> MembersFlags == KSPROPERTY_MEMBER_RANGES  ||
                (*MembersHeader) -> MembersFlags == 
                    KSPROPERTY_MEMBER_STEPPEDRANGES) {

                Found = TRUE;
            }
        } else {
            if ((*MembersHeader) -> MembersFlags == KSPROPERTY_MEMBER_VALUES) {
                Found = TRUE;
            }
        }

        //
        // Update the remaining size.
        //
        if ((*RemainingMembersSize) < 
            (*MembersHeader) -> MembersSize + 
                sizeof (KSPROPERTY_MEMBERSHEADER)) {

            *RemainingMembersSize = 0;

        } else {

            (*RemainingMembersSize) -= sizeof (KSPROPERTY_MEMBERSHEADER) +
                (*MembersHeader) -> MembersSize;

        }

        if (!Found) {
            *MembersHeader = reinterpret_cast <PKSPROPERTY_MEMBERSHEADER> (
                reinterpret_cast <PBYTE> (*MembersHeader + 1) + 
                (*MembersHeader) -> MembersSize
                );
        }

    }

    return Found;
 
}

/*************************************************

    Function:

        CBaseEncoderAPI::FillValue

    Description:

        Fill a variant type with a value from a values array and advance
        the values array pointer to the next element in the list

    Arguments:

        VarType -
            The variant type of members of Values

        Value -
            The variant value to fill in

        Values -
            The values array

    Return Value:

        Success / Failure

*************************************************/

HRESULT
CBaseEncoderAPI::
FillValue (
    IN VARTYPE VarType,
    OUT VARIANT *Value,
    IN OUT PVOID *Values
    )

{

    HRESULT hr = S_OK;

    InitVariant (Value, VarType);

    switch (VarType) {
        case VT_UI8:
            Value -> ullVal = *(reinterpret_cast <PULONGLONG> (*Values));
            *Values = reinterpret_cast <PVOID> (
                reinterpret_cast <PULONGLONG> (*Values) + 1
                );
            break;
        
        case VT_UI4:
            Value -> ulVal = *(reinterpret_cast <PULONG> (*Values));
            *Values = reinterpret_cast <PVOID> (
                reinterpret_cast <PULONG> (*Values) + 1
                );
            break;

        case VT_UI2:
            Value -> uiVal = *(reinterpret_cast <PUSHORT> (*Values));
            *Values = reinterpret_cast <PVOID> (
                reinterpret_cast <PUSHORT> (*Values) + 1
                );
            break;

        case VT_UI1:
            Value -> bVal = *(reinterpret_cast <PBYTE> (*Values));
            *Values = reinterpret_cast <PVOID> (
                reinterpret_cast <PBYTE> (*Values) + 1
                );
            break;

        case VT_I8:
            Value -> llVal = *(reinterpret_cast <PLONGLONG> (*Values));
            *Values = reinterpret_cast <PVOID> (
                reinterpret_cast <PLONGLONG> (*Values) + 1
                );
            break;

        case VT_I4:
            Value -> lVal = *(reinterpret_cast <PLONG> (*Values));
            *Values = reinterpret_cast <PVOID> (
                reinterpret_cast <PLONG> (*Values) + 1
                );
            break;

        case VT_I2:
            Value -> iVal = *(reinterpret_cast <PSHORT> (*Values));
            *Values = reinterpret_cast <PVOID> (
                reinterpret_cast <PSHORT> (*Values) + 1
                );
            break;

        case VT_R8: 
            Value -> dblVal = *(reinterpret_cast <double *> (*Values));
            *Values = reinterpret_cast <PVOID> (
                reinterpret_cast <double *> (*Values) + 1
                );
            break;

        case VT_R4:
            Value -> fltVal = *(reinterpret_cast <PFLOAT> (*Values));
            *Values = reinterpret_cast <PVOID> (
                reinterpret_cast <PFLOAT> (*Values) + 1
                );
            break;

        default:
            hr = E_NOTIMPL;

    }

    return hr;

}

/*************************************************

    Function:

        CBaseEncoderAPI::FillRange

    Description:

        Fill a variant type range from a members list

    Arguments:

        VarType -
            The variant type of members of RangeList

        RangeHeader -
            The members header corresponding to a stepped range or a range

        MinValue -
            The variant into which will be deposited the lower end of the
            range

        MaxValue -
            The variant into which will be deposited the upper end of the
            range

        SteppingDelta -
            The variant into which will be deposited the stepping delta.  If
            this is a non-stepped range, the variant will be empty.

    Return Value:

        Success / Failure


*************************************************/

HRESULT
CBaseEncoderAPI::
FillRange (
    IN VARTYPE VarType,
    IN PKSPROPERTY_MEMBERSHEADER RangeHeader,
    IN VARIANT *MinValue,
    IN VARIANT *MaxValue,
    IN VARIANT *SteppingDelta
    )

{

    //
    // TODO: No kernel definition exists for ranges which aren't either
    // 32-bit or 64-bit signed or unsigned integers.  Either disallow ranges
    // outside this bounds in the spec or create new structures.
    //

    HRESULT hr = S_OK;

    #ifdef ENFORCE_ONLY_ONE_RANGE_AND_DEFAULT
        ASSERT (RangeHeader -> MembersCount == 1);
    #endif // ENFORCE_ONLY_ONE_RANGE_AND_DEFAULT

    ASSERT (MinValue && MaxValue && SteppingDelta);

    InitVariant (MinValue, VarType);
    InitVariant (MaxValue, VarType);

    if (RangeHeader -> MembersFlags == KSPROPERTY_MEMBER_RANGES) {

        //
        // SteppingDelta will be VT_EMPTY type if there is no specified
        // stepping.
        //
        InitVariant (SteppingDelta, VT_EMPTY);

        switch (VarType) {
            case VT_I8:
            case VT_UI8:
            {
                PKSPROPERTY_BOUNDS_LONGLONG Bounds =
                    reinterpret_cast <PKSPROPERTY_BOUNDS_LONGLONG> (
                        RangeHeader + 1
                        );

                if (VarType == VT_I8) {
                    MinValue -> llVal = Bounds -> SignedMinimum;
                    MaxValue -> llVal = Bounds -> SignedMaximum;
                } else {
                    MinValue -> ullVal = Bounds -> UnsignedMinimum;
                    MaxValue -> ullVal = Bounds -> UnsignedMaximum;
                }

                break;

            }

            case VT_I4:
            case VT_UI4:
            {
                PKSPROPERTY_BOUNDS_LONG Bounds =
                    reinterpret_cast <PKSPROPERTY_BOUNDS_LONG> (
                        RangeHeader + 1
                        );

                if (VarType == VT_I4) {
                    MinValue -> lVal = Bounds -> SignedMinimum;
                    MaxValue -> lVal = Bounds -> SignedMaximum;
                } else {
                    MinValue -> ulVal = Bounds -> UnsignedMinimum;
                    MaxValue -> ulVal = Bounds -> UnsignedMaximum;
                }

                break;
            }

            default:
                hr = E_NOTIMPL;
                break;

        }
    } else {

        InitVariant (SteppingDelta, VarType);

        switch (VarType) {
            case VT_I8:
            case VT_UI8:
            {
                PKSPROPERTY_STEPPING_LONGLONG Stepping =
                    reinterpret_cast <PKSPROPERTY_STEPPING_LONGLONG> (
                        RangeHeader + 1
                        );

                if (VarType == VT_I8) {
                    MinValue -> llVal = Stepping -> Bounds.SignedMinimum;
                    MaxValue -> llVal = Stepping -> Bounds.SignedMaximum;
                    SteppingDelta -> llVal = 
                        (LONGLONG)Stepping -> SteppingDelta;
                } else {
                    MinValue -> ullVal = Stepping -> Bounds.UnsignedMinimum;
                    MaxValue -> ullVal = Stepping -> Bounds.UnsignedMaximum;
                    SteppingDelta -> ullVal = 
                        (ULONGLONG)Stepping -> SteppingDelta;
                }

                break;

            }

            case VT_I4:
            case VT_UI4:
            {
                PKSPROPERTY_STEPPING_LONG Stepping =
                    reinterpret_cast <PKSPROPERTY_STEPPING_LONG> (
                        RangeHeader + 1
                        );

                if (VarType == VT_I4) {
                    MinValue -> lVal = Stepping -> Bounds.SignedMinimum;
                    MaxValue -> lVal = Stepping -> Bounds.SignedMaximum;
                    SteppingDelta -> lVal = (LONG)Stepping -> SteppingDelta;
                } else {
                    MinValue -> ulVal = Stepping -> Bounds.UnsignedMinimum;
                    MaxValue -> ulVal = Stepping -> Bounds.UnsignedMaximum;
                    SteppingDelta -> ulVal = (ULONG)Stepping -> SteppingDelta;
                }

                break;
            }

            default:
                hr = E_NOTIMPL;
                break;

        }

    }

    return hr;

}

/*************************************************

    Function:

        CBaseEncoderAPI::GetFullPropertyDescription

    Description:

        Get the full property description

    Arguments:
        
        Api -
            The Api (XXX_API) / parameter to get the full property
            description of

        ReturnedDescription -
            The ALLOCATED full description will be passed back here

        DefaultValues -
            Indicates whether to retrieve a listing of default values (TRUE)
            or ranges/values (FALSE)

    Return Value:

        Success / Failure

*************************************************/

HRESULT
CBaseEncoderAPI::
GetFullPropertyDescription (
    IN const GUID *Api,
    OUT PKSPROPERTY_DESCRIPTION *ReturnedDescription,
    IN BOOLEAN DefaultValues
    )

{

    ASSERT (ReturnedDescription);

    KSPROPERTY Property;
    KSPROPERTY_DESCRIPTION BasicDescription;
    PKSPROPERTY_DESCRIPTION Description = &BasicDescription;
    CHAR *Buffer = NULL;

    ULONG BytesReturned;

    //
    // Get the basic property description.
    //
    Property.Set = *Api;
    Property.Id = 0;
    if (DefaultValues) {
        Property.Flags = KSPROPERTY_TYPE_DEFAULTVALUES;
    } else {
        Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
    }

    HRESULT hr = KsProperty (
        &Property,
        sizeof (Property),
        Description,
        sizeof (*Description),
        &BytesReturned
        );

    if (SUCCEEDED (hr) && BytesReturned < sizeof (KSPROPERTY_DESCRIPTION)) {
        hr = E_FAIL;
    } 

    if (SUCCEEDED (hr)) {
        //
        // Allocate a chunk to retrieve and parse the property description.
        //
        Buffer = new CHAR [Description -> DescriptionSize];
        if (!Buffer) {
            hr = E_OUTOFMEMORY;
        } else {
            Description = reinterpret_cast <PKSPROPERTY_DESCRIPTION> (
                Buffer
                );

            hr = KsProperty (
                &Property,
                sizeof (Property),
                Description,
                BasicDescription.DescriptionSize,
                &BytesReturned
                );

            if (SUCCEEDED (hr) && 
                BytesReturned < Description -> DescriptionSize) {

                hr = E_FAIL;

            }
        }
    }

    if (SUCCEEDED (hr)) {
        *ReturnedDescription = Description;
    } else {
        if (Buffer) {
            delete [] Buffer;
        }
    }

    return hr;

}

/*************************************************

    Function:

        CBaseEncoderAPI::GetParameterRange

    Description:

        Get the range of parameter values supported by the given parameter
        on the underlying kernel object.

    Arguments:

        Api -
            The Api (XXX_API) / parameter to determine parameter
            ranges for

        ValueMin -
            If successful, the minimum value of the supported range will
            be placed here

        ValueMax -
            If successful, the maximum value of the supported range will
            be placed here

        SteppingDelta -
            If successful, the stepping delta of the supported range will
            be placed here.

    Return Value:

        S_OK -
            Success

        E_NOTIMPL -
            The parameter specified by Api on the underlying kernel object
            does not support a range of values.  It might support a list
            which can be determined from GetParameterValues

        Other error -
            Inability to process the call

*************************************************/

HRESULT
CBaseEncoderAPI::
Base_GetParameterRange (
    IN const GUID *Api,
    OUT VARIANT *ValueMin,
    OUT VARIANT *ValueMax,
    OUT VARIANT *SteppingDelta
    )

{

    ASSERT (Api && ValueMin && ValueMax && SteppingDelta);
    if (!Api || !ValueMin || !ValueMax || !SteppingDelta) {
        return E_POINTER;
    }

    VARTYPE VarType;
    PKSPROPERTY_DESCRIPTION Description = NULL;
    HRESULT hr = GetFullPropertyDescription (Api, &Description, FALSE);

    //
    // Before we bother going any further, check if there are any data members
    // reported.
    //
    if (SUCCEEDED (hr)) {
        if (Description -> MembersListCount == 0) {
            hr = E_NOTIMPL;
        }
    }

    if (SUCCEEDED (hr)) {

        VarType = (VARTYPE)Description -> PropTypeSet.Id;

        //
        // Parse the description looking for a range.  According to the API,
        // only one range may be specified (although a discrete list of values
        // as well as default values may be present also).
        //
        PKSPROPERTY_MEMBERSHEADER MembersHeader =
            reinterpret_cast <PKSPROPERTY_MEMBERSHEADER> (
                Description + 1
                );

        ULONG RemainingMembersSize = Description -> DescriptionSize -
            sizeof (KSPROPERTY_DESCRIPTION);

        if (ParseMembersList (
            &MembersHeader, 
            &RemainingMembersSize, 
            TRUE
            )) {

            //
            // We only support ONE range by API.  If there's more than one
            // specified by the driver, fail.
            //
            PKSPROPERTY_MEMBERSHEADER RangeHeader = MembersHeader;

            MembersHeader =
                reinterpret_cast <PKSPROPERTY_MEMBERSHEADER> (
                    reinterpret_cast <PBYTE> (MembersHeader + 1) +
                    MembersHeader -> MembersSize
                    );

            #ifdef ENFORCE_ONLY_ONE_RANGE_AND_DEFAULT
                if (RangeHeader -> MembersCount > 1 ||
                    ParseMembersList (
                        &MembersHeader,
                        &RemainingMembersSize,
                        TRUE
                        )) {
                    
                    hr = E_FAIL;
                }
            #endif // ENFORCE_ONLY_ONE_RANGE_AND_DEFAULT

            if (SUCCEEDED (hr)) {
                //
                // We either have a stepped range or a range.  Fill in the
                // values
                //
                hr = FillRange (
                    VarType, RangeHeader, ValueMin, ValueMax, SteppingDelta
                    );

            }
        } else {

            //
            // The kernel object had no range information to report.
            //
            hr = E_NOTIMPL;
        }
    }

    if (Description) {
        delete [] (reinterpret_cast <CHAR *> (Description));
    }

    return hr;

}

/*************************************************

    Function:

        CBaseEncoderAPI::GetParameterValues

    Description:

        Get all of the discrete values supported by the given parameter.
        If Values is NULL, *ValuesCount will contain the total number of values
        on return.  Otherwise, the input of *ValuesCount indicates the size
        of the Values array and on output, *ValuesCount indicates the actual
        number of entries placed into that array.

    Arguments:

        Api -
            The Api (XXX_API) / parameter to determine discrete values
            for

        ValuesSize -
            The size of the values array (in terms of the number of variants)

        Values -
            The array into which the values list will be placed

        ValuesCount -
            OUT - the number of entries placed into the array if Values != NULL
                  Otherwise, the total number of entries

*************************************************/

HRESULT
CBaseEncoderAPI::
Base_GetParameterValues (
    IN const GUID *Api,
    OUT VARIANT **Values,
    OUT PULONG ValuesCount
    )

{
    ASSERT (Api && Values && ValuesCount);
    if (!Api || !Values || !ValuesCount) {
        return E_POINTER;
    }

    VARIANT *ValueList = NULL;
    VARTYPE VarType;
    PKSPROPERTY_DESCRIPTION Description = NULL;
    ULONG TotalValuesCount = 0;
    HRESULT hr = GetFullPropertyDescription (Api, &Description, FALSE);

    //
    // Before we bother going any further, check if there are any data members
    // reported.
    //
    if (SUCCEEDED (hr)) {
        if (Description -> MembersListCount == 0) {
            hr = E_NOTIMPL;
        }
    }

    if (SUCCEEDED (hr)) {

        VarType = (VARTYPE)Description -> PropTypeSet.Id;

        //
        // Parse the description looking for values.  Count the total size
        // of values.
        //
        PKSPROPERTY_MEMBERSHEADER MembersHeader =
            reinterpret_cast <PKSPROPERTY_MEMBERSHEADER> (
                Description + 1
                );

        ULONG RemainingMembersSize = Description -> DescriptionSize -
            sizeof (KSPROPERTY_DESCRIPTION);

        while (
            ParseMembersList (
                &MembersHeader, 
                &RemainingMembersSize, 
                FALSE
                )
            ) {

            TotalValuesCount += MembersHeader -> MembersCount;

            MembersHeader = reinterpret_cast <PKSPROPERTY_MEMBERSHEADER> (
                reinterpret_cast <PBYTE> (MembersHeader + 1) +
                MembersHeader -> MembersSize
                );

        }

        if (!TotalValuesCount) {
            hr = E_NOTIMPL;
        }

    }

    //
    // If Values is NULL, this is a size query against the values set.
    //
    if (SUCCEEDED (hr)) {
        ValueList = *Values = reinterpret_cast <VARIANT *> (
            CoTaskMemAlloc (TotalValuesCount * sizeof (VARIANT))
            );
        if (!*Values) {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED (hr)) {
        PKSPROPERTY_MEMBERSHEADER MembersHeader =
            reinterpret_cast <PKSPROPERTY_MEMBERSHEADER> (
                Description + 1
                );

        ULONG RemainingMembersSize = Description -> DescriptionSize -
            sizeof (KSPROPERTY_DESCRIPTION);

        while (SUCCEEDED (hr) && 
               ParseMembersList (
                   &MembersHeader, 
                   &RemainingMembersSize, 
                   FALSE
                   )
               ) {

            PVOID Value = reinterpret_cast <PVOID> (MembersHeader + 1);

            //
            // Copy back a variant for each value.
            //
            for (ULONG i = 0; 
                 SUCCEEDED (hr) && 
                    i < MembersHeader -> MembersCount; 
                 i++
                 ) {

                hr = FillValue (VarType, ValueList, &Value);
                if (SUCCEEDED (hr)) {
                    ValueList++;
                }
            }

            MembersHeader = reinterpret_cast <PKSPROPERTY_MEMBERSHEADER> (
                reinterpret_cast <PBYTE> (MembersHeader + 1) +
                MembersHeader -> MembersSize
                );
        }

    }

    if (SUCCEEDED (hr)) {
        *ValuesCount = TotalValuesCount;
    } else {
        if (ValueList) {
            CoTaskMemFree (ValueList);
        }
    }

    if (Description) {
        delete [] (reinterpret_cast <CHAR *> (Description));
    }

    return hr;
            
}

/*************************************************

    Function:

        CBaseEncoderAPI::GetDefaultValue

    Description:

        Get the default value for a given parameter should one exist.  
        Otherwise, E_NOTIMPL will get returned.

    Arguments:

        Api -
            The Api (XXX_API) / parameter to determine the default 
            value for

        Value -
            The variant structure into which will be deposited the default
            value of the parameter

    Return Value:

        S_OK -
            Default value returned

        E_NOTIMPL -
            No such default value exists

        Other error -
            Inability to process the call

*************************************************/

HRESULT
CBaseEncoderAPI::
Base_GetDefaultValue (
    IN const GUID *Api,
    OUT VARIANT *Value
    )

{
    ASSERT (Api && Value);
    if (!Api || !Value) {
        return E_POINTER;
    }

    VARTYPE VarType;
    PKSPROPERTY_DESCRIPTION Description = NULL;
    ULONG ValuesCount = 0;
    HRESULT hr = GetFullPropertyDescription (Api, &Description, TRUE);

    //
    // Before we bother going any further, check if there are any data members
    // reported.
    //
    if (SUCCEEDED (hr)) {
        if (Description -> MembersListCount == 0) {
            hr = E_NOTIMPL;
        }
    }

    if (SUCCEEDED (hr)) {

        VarType = (VARTYPE)Description -> PropTypeSet.Id;

        //
        // Parse the description looking for values.  Count the total size
        // of values.
        //
        PKSPROPERTY_MEMBERSHEADER MembersHeader =
            reinterpret_cast <PKSPROPERTY_MEMBERSHEADER> (
                Description + 1
                );

        ULONG RemainingMembersSize = Description -> DescriptionSize -
            sizeof (KSPROPERTY_DESCRIPTION);

        BOOLEAN Found = FALSE;

        //
        // Go through to verify that only one default value exists on the
        // object.
        //
        while (SUCCEEDED (hr) && 
               ParseMembersList (
                   &MembersHeader, 
                   &RemainingMembersSize, 
                   FALSE
                   )
               ) {

            if (MembersHeader -> Flags & KSPROPERTY_MEMBER_FLAG_DEFAULT) {

                //
                // We only support one default value.  If there's another,
                // return E_FAIL.
                //
                #ifdef ENFORCE_ONLY_ONE_RANGE_AND_DEFAULT
                    if (Found || MembersHeader -> MembersCount > 1) {
                        hr = E_FAIL;
                    } else {
                #endif // ENFORCE_ONLY_ONE_RANGE_AND_DEFAULT

                        PVOID Values = 
                            reinterpret_cast <PVOID> (MembersHeader + 1);

                        hr = FillValue (VarType, Value, &Values); 
                        Found = TRUE;

                #ifdef ENFORCE_ONLY_ONE_RANGE_AND_DEFAULT
                    }
                #else // !ENFORCE_ONLY_ONE_RANGE_AND_DEFAULT
                        break;
                #endif // ENFORCE_ONLY_ONE_RANGE_AND_DEFAULT
            }

            MembersHeader = reinterpret_cast <PKSPROPERTY_MEMBERSHEADER> (
                reinterpret_cast <PBYTE> (MembersHeader + 1) +
                MembersHeader -> MembersSize
                );

        }

        if (!Found) {
            hr = E_NOTIMPL;
        }

    }

    if (Description) {
        delete [] (reinterpret_cast <CHAR *> (Description));
    }

    return hr;
}

/*************************************************

    Function:

        CBaseEncoderAPI::GetProperty_UI4

    Description:

        Get the current UI4 property.

    Arguments:

        Api -
            The Api (XXX_API) / parameter to get

        Value -
            The variant structure into which the current UI4 value will be
            placed

    Return Value:

        Success / Failure

*************************************************/

HRESULT
CBaseEncoderAPI::
GetProperty_UI4 (
    IN const GUID *Api,
    OUT VARIANT *Value
    )

{

    ASSERT (Api && Value);
    if (!Api || !Value) {
        return E_POINTER;
    }

    KSPROPERTY Property;

    Property.Set = *Api;
    Property.Id = 0;
    Property.Flags = KSPROPERTY_TYPE_GET;

    ULONG ValUI4;
    ULONG BytesReturned;

    HRESULT hr = KsProperty (
        &Property,
        sizeof (Property),
        &ValUI4,
        sizeof (ValUI4),
        &BytesReturned
        );

    if (SUCCEEDED (hr) && BytesReturned < sizeof (ValUI4)) {
        hr = E_FAIL;
    }

    if (SUCCEEDED (hr)) {
        InitVariant (Value, VT_UI4);
        Value -> ulVal = ValUI4;
    }

    return hr;

}

/*************************************************

    Function:

        CBaseEncoderAPI::SetProperty_UI4

    Description:

        Set the current UI4 property.

    Arguments:

        Api -
            The Api (XXX_API) / parameter to set

        Value -
            The variant structure into which the current UI4 value will be
            placed

    Return Value:

        Success / Failure

*************************************************/

HRESULT
CBaseEncoderAPI::
SetProperty_UI4 (
    IN const GUID *Api,
    IN VARIANT *Value
    )

{

    ASSERT (Api && Value);
    if (!Api || !Value) {
        return E_POINTER;
    }

    if (Value -> vt != VT_UI4) {
        return E_INVALIDARG;
    }

    KSPROPERTY Property;

    Property.Set = *Api;
    Property.Id = 0;
    Property.Flags = KSPROPERTY_TYPE_SET;

    ULONG ValUI4 = Value -> ulVal;
    ULONG BytesReturned;

    HRESULT hr = KsProperty (
        &Property,
        sizeof (Property),
        &ValUI4,
        sizeof (ValUI4),
        &BytesReturned
        );

    return hr;

}

/*************************************************

    Function:

        CBaseEncoderAPI::GetProperty_I4

    Description:

        Get the current I4 property.

    Arguments:

        Api -
            The Api (XXX_API) / parameter to get

        Value -
            The variant structure into which the current I4 value will be
            placed

    Return Value:

        Success / Failure

*************************************************/

HRESULT
CBaseEncoderAPI::
GetProperty_I4 (
    IN const GUID *Api,
    OUT VARIANT *Value
    )

{
    ASSERT (Api && Value);
    if (!Api || !Value) {
        return E_POINTER;
    }

    KSPROPERTY Property;

    Property.Set = *Api;
    Property.Id = 0;
    Property.Flags = KSPROPERTY_TYPE_GET;

    LONG ValI4;
    ULONG BytesReturned;

    HRESULT hr = KsProperty (
        &Property,
        sizeof (Property),
        &ValI4,
        sizeof (ValI4),
        &BytesReturned
        );

    if (SUCCEEDED (hr) && BytesReturned < sizeof (ValI4)) {
        hr = E_FAIL;
    }

    if (SUCCEEDED (hr)) {
        InitVariant (Value, VT_I4);
        Value -> lVal = ValI4;
    }

    return hr;

}

/*************************************************

    Function:

        CBaseEncoderAPI::SetProperty_I4

    Description:

        Set the current I4 property.

    Arguments:

        Api -
            The Api (XXX_API) / parameter to set

        Value -
            The variant structure into which the current I4 value will be
            placed

    Return Value:

        Success / Failure

*************************************************/

HRESULT
CBaseEncoderAPI::
SetProperty_I4 (
    IN const GUID *Api,
    IN VARIANT *Value
    )

{
    ASSERT (Api && Value);
    if (!Api || !Value) {
        return E_POINTER;
    }

    if (Value -> vt != VT_I4) {
        return E_INVALIDARG;
    }

    KSPROPERTY Property;

    Property.Set = *Api;
    Property.Id = 0;
    Property.Flags = KSPROPERTY_TYPE_SET;

    LONG ValI4 = Value -> lVal;
    ULONG BytesReturned;

    HRESULT hr = KsProperty (
        &Property,
        sizeof (Property),
        &ValI4,
        sizeof (ValI4),
        &BytesReturned
        );

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\encapi\encmain.cpp ===
//**************************************************************************
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
//
// FileName:        encmain.cpp
//
//**************************************************************************

//
// Abstract:        Encoder API proxy main
//

#include "private.h"

CFactoryTemplate g_Templates[] = {
    {
        L"IVideoEncoder",
        &CLSID_IVideoEncoderProxy,
        CVideoEncoderAPIProxy::CreateInstance,
        NULL,
        NULL
    }
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

STDAPI
DllRegisterServer (
    )

{
    return AMovieDllRegisterServer2 (TRUE);
}

STDAPI
DllUnregisterServer (
    )

{
    return AMovieDllRegisterServer2 (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\encapi\baseapi.h ===
//**************************************************************************
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
//
// FileName:        baseapi.h
//
//**************************************************************************

//
// Abstract:        Base encoder API layer header
//

#define InitVariant(var, vtval) \
    (var)->vt = vtval; \
    (var)->wReserved1 = (var)->wReserved2 = (var)->wReserved3 = 0

//
// CBaseEncoderAPI:
//
// This abstract base class supports all of the basic IEncoderAPI methods for a 
// given set.  The API proxy plug-in components for video, audio, etc... will 
// derive from this and other interfaces such as IVideoEncoder to provide the 
// functionality of the API proxy.
//

class CBaseEncoderAPI :
    public CUnknown

{

private:

    //
    // KsSynchronousDeviceControl():
    //
    // Per KsProxy's KsSynchronousDeviceControl.  Placed here to remove
    // loader dependence on KsProxy.ax.
    //
    HRESULT
    KsSynchronousDeviceControl(
        HANDLE Handle,
        ULONG IoControl,
        PVOID InBuffer,
        ULONG InLength,
        PVOID OutBuffer,
        ULONG OutLength,
        PULONG BytesReturned
        );

protected:

    //
    // Object handle for communication with kernel object.
    //
    HANDLE m_ObjectHandle;

    //
    // The property set GUID which will be used for all property queries.
    //
    GUID m_PropertySetGUID;

    //
    // ParseMembersList():
    //
    // Parse a members list returned from the kernel object for either a
    // range/stepped range or a value.
    //
    BOOLEAN
    ParseMembersList (
        IN OUT PKSPROPERTY_MEMBERSHEADER *MembersList,
        IN OUT PULONG RemainingMembersSize,
        IN BOOLEAN FindRange
        );

    //
    // FillValue():
    //
    // Fill a variant (Value) with the data at *Values (type determined by
    // VarType) and advance *Values forward by the size of the type determined
    // by VarType.
    //
    HRESULT
    FillValue (
        IN VARTYPE VarType,
        OUT VARIANT *Value,
        IN OUT PVOID *Values
        );

    //
    // FillRange():
    //
    // Fill a range (MinValue .. MaxValue by SteppingDelta) and stepping from
    // a KSPROPERTY_MEMBERSHEADER for a range or stepped range.  If the range
    // is not stepped, SteppingDelta will be empty (VT_EMPTY).
    //
    HRESULT
    FillRange (
        IN VARTYPE VarType,
        IN PKSPROPERTY_MEMBERSHEADER RangeList,
        IN VARIANT *MinValue,
        IN VARIANT *MaxValue,
        IN VARIANT *SteppingDelta
        );

    //
    // GetFullPropertyDescription():
    //
    // Get the full property description back from the kernel.  If DefaultValues
    // is TRUE, it will return only default values; otherwise, it will return
    // (stepped) ranges and values, but not defaults.
    //
    HRESULT
    GetFullPropertyDescription (
        IN const GUID *Api,
        OUT PKSPROPERTY_DESCRIPTION *ReturnedDescription,
        IN BOOLEAN DefaultValues
        );

    //
    // GetProperty_UI4():
    //
    // Generic function to handle getting a VT_UI4 property from the 
    // kernel object.
    //
    HRESULT
    GetProperty_UI4 (
        IN const GUID *Api,
        OUT VARIANT *Value
        );

    //
    // SetProperty_UI4():
    //
    // Generic function to handle setting of a VT_UI4 property on the 
    // kernel object.
    //
    HRESULT
    SetProperty_UI4 (
        IN const GUID *Api,
        IN VARIANT *Value
        );

    //
    // GetProperty_I4():
    //
    // Generic function to handle getting a VT_I4 property from the 
    // kernel object.
    //
    HRESULT
    GetProperty_I4 (
        IN const GUID *Api,
        OUT VARIANT *Value
        );

    //
    // SetProperty_I4():
    //
    // Generic function to handle setting of a VT_I4 property on the 
    // kernel object.
    //
    HRESULT
    SetProperty_I4 (
        IN const GUID *Api,
        IN VARIANT *Value
        );

    //
    // Base_IsSupported():
    //
    // Query whether a given parameter is supported.  A successful return value
    // indicates that the parameter is supported by the interface.  E_NOTIMPL
    // indicates it is not.  Any other error indicates inability to process
    // the call.
    //
    HRESULT
    Base_IsSupported (
        IN const GUID *Api
        );

    //
    // Base_IsAvailable():
    //
    // Query whether a given parameter is available.  A successful return value
    // indicates that the parameter is available given other current settings.
    // E_FAIL indicates that it is not.  Any other error indicates inability
    // to process the call.
    //
    HRESULT
    Base_IsAvailable (
        IN const GUID *Api
        );

    //
    // Base_GetParameterRange():
    //
    // Returns the valid range of values that the parameter supports should
    // the parameter support a stepped range as opposed to a list of specific
    // values.  The support is [ValueMin .. ValueMax] by SteppingDelta.
    //
    // Ranged variant types must fall into one of the below types.  Each
    // parameter will, by definition, return a specific type.
    //
    //     Unsigned types : VT_UI8, VT_UI4, VT_UI2, VT_UI1
    //     Signed types   : VT_I8, VT_I4, VT_I2
    //     Float types    : VT_R8, VT_R4
    //
    HRESULT
    Base_GetParameterRange (
        IN const GUID *Api,
        OUT VARIANT *ValueMin,
        OUT VARIANT *ValueMax,
        OUT VARIANT *SteppingDelta
        );

    //
    // Base_GetParameterValues():
    //
    // Get all of the discrete values supported by the given parameter.
    // The list is returned as a callee allocated (CoTaskMemAlloc()) array
    // of VARIANTs which the caller must free (CoTaskMemFree()).  The actual
    // number of elements in the array is returned in ValuesCount.
    //
    HRESULT
    Base_GetParameterValues (
        IN const GUID *Api,
        OUT VARIANT **Values,
        OUT ULONG *ValuesCount
        );

    //
    // GetDefaultValue():
    //
    // Get the default value for a parameter, if one exists.  Otherwise, 
    // an error will be returned.
    //
    HRESULT
    Base_GetDefaultValue (
        IN const GUID *Api,
        OUT VARIANT *Value
        );

    //
    // KsProperty():
    //
    // Since we cannot hold IKsControl on KsProxy because we are a dynamic
    // aggregate (the circular ref would never go away), this is layered on
    // top of the object handle.
    //
    HRESULT
    KsProperty (
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );

public:

    //
    // CBaseEncoderAPI():
    //
    // Constructs the base encoder API layer (including a QI for IKsControl,
    // etc...)
    //
    CBaseEncoderAPI (
        IN LPUNKNOWN UnkOuter,
        IN TCHAR *Name,
        IN HRESULT *hr
        );

    //
    // ~CBaseEncoderAPI():
    //
    // Destroys the base encoder API layer.
    //
    ~CBaseEncoderAPI (
        );


    //
    // Implementation of GetValue() and SetValue() must be done in the derived
    // classes.  We don't know how much buffer to pass or what types will
    // exist.
    //

};

#define DECLARE_IENCODERAPI_BASE \
    STDMETHODIMP \
    IsSupported ( \
        IN const GUID *Api \
        ) \
    { \
        return Base_IsSupported (Api); \
    } \
    STDMETHODIMP \
    IsAvailable ( \
        IN const GUID *Api \
        ) \
    { \
        return Base_IsAvailable (Api); \
    } \
    STDMETHODIMP \
    GetParameterRange ( \
        IN const GUID *Api, \
        OUT VARIANT *ValueMin, \
        OUT VARIANT *ValueMax, \
        OUT VARIANT *SteppingDelta \
        ) \
    { \
        return Base_GetParameterRange (Api, ValueMin, ValueMax, SteppingDelta); \
    } \
    STDMETHODIMP \
    GetParameterValues ( \
        IN const GUID *Api, \
        OUT VARIANT **Values, \
        OUT ULONG *ValuesCount \
        ) \
    { \
        return Base_GetParameterValues (Api, Values, ValuesCount); \
    } \
    STDMETHODIMP \
    GetDefaultValue ( \
        IN const GUID *Api, \
        OUT VARIANT *Value \
        ) \
    { \
        return Base_GetDefaultValue (Api, Value); \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\encapi\videoenc.cpp ===
//**************************************************************************
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
//
// FileName:        videoenc.cpp
//
//**************************************************************************

//
// Abstract:        Kernel video encoder API proxy and property pages
//

#include "private.h"

/**************************************************************************

    API PROXY IMPLEMENTATION (Video Encoder)

**************************************************************************/

/*************************************************

    Function:

        CVideoEncoderAPIProxy::CreateInstance

    Description:

        Create an instance of the video encoder API proxy (KsProxy plug-in)

    Arguments:

        UnkOuter -
            The outer unknown we are aggregating with

        hr -
            The status of creation

    Return Value:

        The constructed proxy plug-in instance

*************************************************/

CUnknown *
CVideoEncoderAPIProxy::
CreateInstance (
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT *hr
    )

{

    CVideoEncoderAPIProxy *ProxyInstance =
        new CVideoEncoderAPIProxy (
            UnkOuter,
            hr
            );

    if (!ProxyInstance) {
        *hr = E_OUTOFMEMORY;
    } else {
        if (!SUCCEEDED (*hr)) {
            delete ProxyInstance;
            ProxyInstance = NULL;
        }
    }

    return static_cast <CUnknown *> (ProxyInstance);

}

/*************************************************

    Function:

        CVideoEncoderAPIProxy::CVideoEncoderAPIProxy

    Description:

        Construct a new video encoder API proxy instance.

    Arguments:

        UnkOuter -
            The outer unknown we are aggregating with

        hr -
            The result of construction

    Return Value:

        None

*************************************************/

CVideoEncoderAPIProxy::
CVideoEncoderAPIProxy (
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT *hr
    ) :
    CBaseEncoderAPI (
        UnkOuter,
        TEXT("Video Encoder API Proxy"),
        hr
        )

{

    //
    // The base class constructor will already have filled out hr.  If it
    // failed, don't bother.
    //
    if (SUCCEEDED (*hr)) {
        //
        // TODO:
        //
    }

}

/*************************************************

    Function:

        CVideoEncoderAPIProxy::NonDelegatingQueryInterface

    Description:

        Non-delegating QI

    Arguments:

        riid -
            The interface identifier for the interface being queried for

        ppv -
            Interface pointer will be placed here

    Return Value:

        Success / Failure

*************************************************/

STDMETHODIMP
CVideoEncoderAPIProxy::
NonDelegatingQueryInterface (
    IN REFIID riid,
    OUT PVOID *ppv
    )

{

    if (riid == __uuidof (IVideoEncoder)) {
        return GetInterface (static_cast <IVideoEncoder *> (this), ppv);
    } else if (riid == __uuidof (IEncoderAPI)) {
        return GetInterface (static_cast <IEncoderAPI *> (this), ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface (riid, ppv);
    }

}

/*************************************************

    Function:
        
        CVideoEncoderAPIProxy::GetValue

    Description:

        Get the current value of a parameter back.

    Arguments:

        Api -
            The Api parameter to determine the current value of

        Value -
            The variant structure into which the current value will be
            deposited.

    Return Value:

        Success / Failure

*************************************************/

STDMETHODIMP
CVideoEncoderAPIProxy::
GetValue (
    IN const GUID *Api,
    OUT VARIANT *Value
    )

{

    ASSERT (Api && Value);
    if (!Api || !Value) {
        return E_POINTER;
    }

    const CBaseEncoderAPI *Base = static_cast <CBaseEncoderAPI *> (this);
    HRESULT hr;

    if (*Api == ENCAPIPARAM_BITRATE) {
        hr = GetProperty_UI4 (Api, Value);
    }
    else if (*Api == ENCAPIPARAM_BITRATE_MODE) {
        hr = GetProperty_I4 (Api, Value);
    }
    else if (*Api == ENCAPIPARAM_PEAK_BITRATE) {
        hr = GetProperty_UI4 (Api, Value);
    }
    else {
        hr = E_NOTIMPL;
    }

    return hr;

}

/*************************************************

    Function:

        CVideoEncoderAPIProxy::SetValue

    Description:

        Set the current value of a parameter.

    Arguments:

        Api -
            The API / parameter to set the current value of

        Value -
            The variant structure containing the value to set.

    Return Value:

        Success / Failure

*************************************************/

STDMETHODIMP
CVideoEncoderAPIProxy::
SetValue (
    IN const GUID *Api,
    IN VARIANT *Value
    )

{

    const CBaseEncoderAPI *Base = static_cast <CBaseEncoderAPI *> (this);
    HRESULT hr;

    if (*Api == ENCAPIPARAM_BITRATE) {
        hr = SetProperty_UI4 (Api, Value);
    } 
    else if (*Api == ENCAPIPARAM_BITRATE_MODE) {
        hr = SetProperty_I4 (Api, Value);
    } 
    else if (*Api == ENCAPIPARAM_PEAK_BITRATE) {
        hr = SetProperty_UI4 (Api, Value);
    } 
    else {
        hr = E_NOTIMPL;
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\debug.h ===
/*++

Copyright (c) 1994-1997  Microsoft Corporation

Module Name: //KERNEL/RAZZLE3/src/sockets/tcpcmd/ipconfig/debug.h


Abstract: Debug defines, macros, prototypes

Author: Richard L Firth (rfirth) 20-May-1994

Revision History:

    20-May-1994 rfirth  -- Created
    30-Apr-97   MohsinA -- Updating for NT50.
                           macros from "../common2/mdebug.h"

--*/

#if !defined(DEBUG)
#if DBG
#define DEBUG
#endif
#endif



#ifdef DBG

extern int   Debugging;
extern char* if_type$(ulong);
extern char* entity$(ulong);

extern  int   trace;

#define DEBUG_PRINT(S) if( Debugging ){ printf S ; }else;
#define TRACE_PRINT(S) if( trace     ){ printf S; }else{}

#else

#define DEBUG_PRINT(S) /* nothing */
#define TRACE_PRINT(S) /* nothing */

#define if_type$(x)    /* nothing */
#define entity$(x)     /* nothing */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\encapi\videoenc.h ===
//**************************************************************************
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
//
// FileName:        videoenc.h
//
//**************************************************************************

//
// Abstract:        Kernel video encoder API proxy and property pages header
//

/*************************************************

    CVideoEncoderAPIProxy:

    This is the interface handler / proxy for the IVideoEncoder interface.

*************************************************/

class CVideoEncoderAPIProxy :
    public CBaseEncoderAPI,
    public IVideoEncoder

{

public:

    DECLARE_IUNKNOWN;
    DECLARE_IENCODERAPI_BASE;

    //
    // CreateInstance():
    //
    // Called back in order to create an instance of the encoder API
    // proxy plug-in.
    //
    static CUnknown * CALLBACK
    CreateInstance (
        IN LPUNKNOWN UnkOuter,
        OUT HRESULT *hr
        );

    //
    // CVideoEncoderAPIProxy():
    //
    // Construct a new video encoder API proxy instance.
    //
    CVideoEncoderAPIProxy (
        IN LPUNKNOWN UnkOuter,
        OUT HRESULT *hr
        );

    //
    // NonDelegatingQueryInterface():
    //
    // Non delegating QI
    //
    STDMETHODIMP
    NonDelegatingQueryInterface (
        IN REFIID riid,
        OUT PVOID *ppv
        );

    //
    // GetValue():
    //
    // Get the current value of a parameter.
    //
    STDMETHODIMP
    GetValue (
        IN const GUID *Api,
        OUT VARIANT *Value
        );

    //
    // SetValue():
    //
    // Set the current value of a parameter.
    //
    STDMETHODIMP
    SetValue (
	IN const GUID *Api,
        OUT VARIANT *Value
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\adaptlst.c ===
/*++

Copyright (c) 1994-1997 Microsoft Corporation

Module Name: //KERNEL/RAZZLE3/src/sockets/tcpcmd/ipconfig/adaptlst.c

Abstract:

    This module contains functions for retrieving adapter information from
    TCP/IP device driver

    Contents:
        GetAdapterList
        AddIpAddress
        AddIpAddressString
        ConvertIpAddressToString
        CopyString

Author:

    Richard L Firth (rfirth) 20-May-1994

Revision History:

    20-May-1994 rfirth  Created
    30-Apr-97   MohsinA Cleaned Up.

--*/

#include "precomp.h"
#pragma   hdrstop

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

//typedef struct _IP_ADAPTER_ORDER_MAP
//{
//    ULONG NumAdapters;
//    ULONG AdapterOrder[1];
//} IP_ADAPTER_ORDER_MAP, *PIP_ADAPTER_ORDER_MAP;


//
// prototypes
//

extern PIP_ADAPTER_ORDER_MAP APIENTRY GetAdapterOrderMap();

//
// functions
//

/*******************************************************************************
 *
 *  GetAdapterList
 *
 *  Returns a linked list of ADAPTER_INFO structures. The adapter info is queried
 *  from the TCP/IP stack. Only those instances corresponding to physical
 *  adapters are returned
 *
 *  This function only fills in the information in the ADAPTER_INFO structure
 *  pertaining to the physical adapter (like MAC address, adapter type, etc.)
 *  and IP address info
 *
 *  ENTRY   nothing
 *
 *  EXIT    nothing
 *
 *  RETURNS Success - pointer to linked list of ADAPTER_INFO structures, 0
 *                    terminated
 *          Failure - NULL
 *
 *  ASSUMES
 *
 ******************************************************************************/

PADAPTER_INFO GetAdapterList()
{

    TCP_REQUEST_QUERY_INFORMATION_EX req;
    TDIObjectID id;
    PADAPTER_INFO list = NULL, prev = NULL;
    PADAPTER_INFO pCurrentAdapter;
    UINT numberOfEntities;
    TDIEntityID* pEntity = NULL;
    TDIEntityID* entityList;
    UINT i;
    UINT j;
    DWORD status;
    DWORD inputLen;
    DWORD outputLen;
    PIP_ADAPTER_ORDER_MAP adapterOrderMap;

    //
    // get the list of entities supported by TCP/IP then make 2 passes on the
    // list. Pass 1 scans for IF_ENTITY's (interface entities perhaps?) which
    // describe adapter instances (physical and virtual). Once we have our list
    // of adapters, on pass 2 we look for CL_NL_ENTITY's (connection-less
    // network layer entities peut-etre?) which will give us the list of IP
    // addresses for the adapters we found in pass 1
    //

    entityList = GetEntityList(&numberOfEntities);
    if (!entityList) {

        DEBUG_PRINT(("GetAdapterList: failed to get entity list\n"));

        return NULL;
    }

    adapterOrderMap = GetAdapterOrderMap();
    if (!adapterOrderMap) {
        DEBUG_PRINT(("GetAdapterList: failed to get adapter order map\n"));
        return NULL;
    }

    // ====================================================================
    // pass 1
    // ====================================================================

    for (i = 0, pEntity = entityList; i < numberOfEntities; ++i, ++pEntity) {

        if (pEntity->tei_entity == IF_ENTITY) {

            //
            // IF_ENTITY: pCurrentAdapter entity/instance describes an adapter
            //

            DWORD isMib;
            BYTE info[sizeof(IFEntry) + MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
            IFEntry* pIfEntry = (IFEntry*)info;
            int len;

            //
            // find out if pCurrentAdapter entity supports MIB requests
            //

            memset(&req, 0, sizeof(req));

            id.toi_entity = *pEntity;
            id.toi_class = INFO_CLASS_GENERIC;
            id.toi_type = INFO_TYPE_PROVIDER;
            id.toi_id = ENTITY_TYPE_ID;

            req.ID = id;

            inputLen = sizeof(req);
            outputLen = sizeof(isMib);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)&isMib,
                               &outputLen
                               );

            //
            // BUGBUG - pCurrentAdapter returns 0 as outputLen
            //

            // if ((status != TDI_SUCCESS) || (outputLen != sizeof(isMib)))
            if (status != TDI_SUCCESS) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(("GetAdapterList: WsControl(ENTITY_TYPE_ID): status = %ld, outputLen = %ld\n",
                            status,
                            outputLen
                            ));

                // goto error_exit;
                continue;
            }
            if (isMib != IF_MIB) {

                //
                // entity doesn't support MIB requests - try another
                //

                DEBUG_PRINT(("GetAdapterList: Entity %lx, Instance %ld doesn't support MIB (%lx)\n",
                            id.toi_entity.tei_entity,
                            id.toi_entity.tei_instance,
                            isMib
                            ));

                continue;
            }

            //
            // MIB requests supported - query the adapter info
            //

            id.toi_class = INFO_CLASS_PROTOCOL;
            id.toi_id = IF_MIB_STATS_ID;

            memset(&req, 0, sizeof(req));
            req.ID = id;

            inputLen = sizeof(req);
            outputLen = sizeof(info);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)&info,
                               &outputLen
                               );
            if (status != TDI_SUCCESS) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(("GetAdapterList: WsControl(IF_MIB_STATS_ID) returns %ld\n",
                            status
                            ));

                // goto error_exit;
                continue;
            }

            //
            // we only want physical adapters
            //
            if (!IS_INTERESTING_ADAPTER(pIfEntry))
            {
                continue;
            }

            //
            // got pCurrentAdapter adapter info ok. Create a new ADAPTER_INFO and fill
            // in what we can
            //
            pCurrentAdapter = NEW(ADAPTER_INFO);

            if (!pCurrentAdapter)
            {
                DEBUG_PRINT(("GetAdapterList: no mem for this ADAPTER_INFO\n"));
                goto error_exit;
            }

            memset( pCurrentAdapter, 0, sizeof( ADAPTER_INFO ) );

            len = min(MAX_ADAPTER_DESCRIPTION_LENGTH, pIfEntry->if_descrlen);

            strncpy(pCurrentAdapter->Description, pIfEntry->if_descr, len);
            pCurrentAdapter->Description[len] = 0;

            len = min(MAX_ADAPTER_ADDRESS_LENGTH, pIfEntry->if_physaddrlen);

            pCurrentAdapter->AddressLength = (BYTE)len;

            memcpy(pCurrentAdapter->Address, pIfEntry->if_physaddr, len);

            pCurrentAdapter->Index = (UINT)pIfEntry->if_index;
            pCurrentAdapter->Type = (UINT)pIfEntry->if_type;

            //
            // add this ADAPTER_INFO to our list
            // We build the list sorted according to the adapter order
            // specified for TCP/IP under its Linkage key.
            // In order to put this new entry in the right place in the list,
            // we determine its position in the adapter-order, store that
            // position in the (unused) 'NodeType' field, and then use that
            // index for comparison on subsequent insertions.
            // If this IP_ADAPTER_INFO doesn't appear in our list at all,
            // we put it at the end of the current list.
            //
            for (j = 0; j < adapterOrderMap->NumAdapters; j++)
            {
                if (adapterOrderMap->AdapterOrder[j] == pCurrentAdapter->Index)
                {
                    break;
                }
            }

            //
            // 'j' now contains the 'order' for the new entry.
            // Put the entry in the right place in the list.
            //
            pCurrentAdapter->NodeType = j;
            for (prev = NULL, pCurrentAdapter->Next = list; pCurrentAdapter->Next; prev = pCurrentAdapter->Next, pCurrentAdapter->Next = pCurrentAdapter->Next->Next)
            {
                if (pCurrentAdapter->NodeType >= pCurrentAdapter->Next->NodeType)
                {
                    continue;
                } else {
                    break;
                }
            }

            if (prev)
            {
                prev->Next = pCurrentAdapter;
            }

            if (list == pCurrentAdapter->Next)
            {
                list = pCurrentAdapter;
            }
        }
    }

    // ====================================================================
    // pass 2
    // ====================================================================

    for (i = 0, pEntity = entityList; i < numberOfEntities; ++i, ++pEntity)
    {
        if (pEntity->tei_entity == CL_NL_ENTITY)
        {

            IPSNMPInfo info;
            DWORD type;

            //
            // first off, see if this network layer entity supports IP
            //

            memset(&req, 0, sizeof(req));

            id.toi_entity = *pEntity;
            id.toi_class = INFO_CLASS_GENERIC;
            id.toi_type = INFO_TYPE_PROVIDER;
            id.toi_id = ENTITY_TYPE_ID;

            req.ID = id;

            inputLen = sizeof(req);
            outputLen = sizeof(type);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)&type,
                               &outputLen
                               );

            //
            // BUGBUG - this returns 0 as outputLen
            //
            if (status != TDI_SUCCESS)
            {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(("GetAdapterList: WsControl(ENTITY_TYPE_ID): status = %ld, outputLen = %ld\n",
                            status,
                            outputLen
                            ));

                // goto error_exit;
                continue;
            }

            if (type != CL_NL_IP) {

                //
                // nope, not IP - try next one
                //

                DEBUG_PRINT(("GetAdapterList: CL_NL_ENTITY #%ld not CL_NL_IP\n",
                            pEntity->tei_instance
                            ));

                continue;
            }

            //
            // okay, this NL provider supports IP. Let's get them addresses:
            // First we find out how many by getting the SNMP stats and looking
            // at the number of addresses supported by this interface
            //

            memset(&req, 0, sizeof(req));

            id.toi_class = INFO_CLASS_PROTOCOL;
            id.toi_id = IP_MIB_STATS_ID;

            req.ID = id;

            inputLen = sizeof(req);
            outputLen = sizeof(info);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)&info,
                               &outputLen
                               );
            if ((status != TDI_SUCCESS) || (outputLen != sizeof(info)))
            {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(("GetAdapterList: WsControl(IP_MIB_STATS_ID): status = %ld, outputLen = %ld\n",
                            status,
                            outputLen
                            ));

                // goto error_exit;
                continue;
            }

            //
            // get the IP addresses & subnet masks
            //

            if (info.ipsi_numaddr) {

                //
                // this interface has some addresses. What are they?
                //

                LPVOID buffer;
                UINT numberOfAddresses;
                IPAddrEntry* pAddr;
                UINT uiAddress;

                outputLen = info.ipsi_numaddr * sizeof(IPAddrEntry);

                DEBUG_PRINT(("info.ipsi_numaddr = %ld, outputlen = %ld\n", info.ipsi_numaddr, outputLen ));

                buffer = (LPVOID)malloc((size_t)outputLen);
                if (!buffer) {
                    DEBUG_PRINT(("GetAdapterList:malloc failed.\n" ));
                    goto error_exit;
                }

                memset(&req, 0, sizeof(req));

                id.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;

                req.ID = id;

                inputLen = sizeof(req);

                status = WsControl(IPPROTO_TCP,
                                   WSCNTL_TCPIP_QUERY_INFO,
                                   (LPVOID)&req,
                                   &inputLen,
                                   (LPVOID)buffer,
                                   &outputLen
                                   );
                if (status != TDI_SUCCESS) {

                    //
                    // unexpected results - bail out
                    //

                    DEBUG_PRINT(("GetAdapterList: WsControl(IP_MIB_ADDRTABLE_ENTRY_ID): status = %ld, outputLen = %ld\n",
                                status,
                                outputLen
                                ));

                    // goto error_exit;
                    continue;
                }

                //
                // now loop through this list of IP addresses, applying them
                // to the correct adapter
                //

                numberOfAddresses = min((UINT)(outputLen / sizeof(IPAddrEntry)),
                                        (UINT)info.ipsi_numaddr
                                        );

                DEBUG_PRINT(("GetAdapterList: %d IP addresses\n", numberOfAddresses));

                pAddr = (IPAddrEntry*)buffer;
                for ( uiAddress = 0
                    ; uiAddress < numberOfAddresses
                    ; ++uiAddress, ++pAddr) {

                    PADAPTER_INFO pAdapterInfo;

                    DEBUG_PRINT(("GetAdapterList: IP address %d.%d.%d.%d, index %ld, context %ld\n",
                                ((LPBYTE)&pAddr->iae_addr)[0] & 0xff,
                                ((LPBYTE)&pAddr->iae_addr)[1] & 0xff,
                                ((LPBYTE)&pAddr->iae_addr)[2] & 0xff,
                                ((LPBYTE)&pAddr->iae_addr)[3] & 0xff,
                                pAddr->iae_index,
                                pAddr->iae_context
                                ));

                    for (pAdapterInfo = list; pAdapterInfo; pAdapterInfo = pAdapterInfo->Next) {
                        if (pAdapterInfo->Index == (UINT)pAddr->iae_index) {

                            DEBUG_PRINT(("GetAdapterList: adding IP address %d.%d.%d.%d, index %d, context %d\n",
                                        ((LPBYTE)&pAddr->iae_addr)[0] & 0xff,
                                        ((LPBYTE)&pAddr->iae_addr)[1] & 0xff,
                                        ((LPBYTE)&pAddr->iae_addr)[2] & 0xff,
                                        ((LPBYTE)&pAddr->iae_addr)[3] & 0xff,
                                        pAddr->iae_index,
                                        pAddr->iae_context
                                        ));

                            if (!AddIpAddress(&pAdapterInfo->IpAddressList,
                                              pAddr->iae_addr,
                                              pAddr->iae_mask,
                                              pAddr->iae_context
                                              )) {
                                goto error_exit;
                            }
                            break;
                        }
                    }
                }
            }
        }
    }

    // ====================================================================

    free((void*)entityList);
    LocalFree(adapterOrderMap);
    return list;

  error_exit:

    DEBUG_PRINT(("GetAdapterList: <= failed\n"));

    if (pEntity) {
        free((void*)pEntity);
    }

    if (adapterOrderMap) {
        LocalFree(adapterOrderMap);
    }

    while (list) {

        PADAPTER_INFO next;
        PIP_ADDR_STRING ipAddr;

        for (ipAddr = list->IpAddressList.Next; ipAddr; ) {

            PIP_ADDR_STRING nextIpAddr;

            nextIpAddr = ipAddr->Next;
            free((void*)ipAddr);
            ipAddr = nextIpAddr;
        }
        next = list->Next;
        free((void*)list);
        list = next;
    }

    return NULL;
}

/*******************************************************************************
 *
 *  AddIpAddress
 *
 *  Adds an IP_ADDR_STRING to a list. If the input IP_ADDR_STRING is empty this
 *  is filled in, else a new IP_ADDR_STRING is allocated and chained to the
 *  input IP_ADDR_STRING
 *
 *  ENTRY   AddressList - pointer to IP_ADDR which may or may not already hold
 *                        an IP address
 *          Address     - IP address to add
 *          Mask        - corresponding IP subnet mask
 *          Context     - address context
 *
 *  EXIT    AddressList - updated with new info
 *
 *  RETURNS Success - 1
 *          Failure - 0
 *
 *  ASSUMES 1. INADDR_ANY (ulong 0) indicates inactive IP address
 *
 ******************************************************************************/

int AddIpAddress(PIP_ADDR_STRING AddressList, DWORD Address, DWORD Mask, DWORD Context)
{

    PIP_ADDR_STRING ipAddr;

    ASSERT( AddressList);
    if (!AddressList)
    {
        return 0;
    }

    if (AddressList->IpAddress.String[0]) {
        for (ipAddr = AddressList; ipAddr->Next; ipAddr = ipAddr->Next) {
            ;
        }
        ipAddr->Next = NEW(IP_ADDR_STRING);
        if (!ipAddr->Next) {

            DEBUG_PRINT(("AddIpAddress: failed to allocate memory for IP_ADDR_STRING\n"));

            return FALSE;
        }
        ipAddr = ipAddr->Next;
    } else {
        ipAddr = AddressList;
    }
    ConvertIpAddressToString(Address, ipAddr->IpAddress.String);
    ConvertIpAddressToString(Mask, ipAddr->IpMask.String);
    ipAddr->Context = Context;
    return TRUE;
}

/*******************************************************************************
 *
 *  AddIpAddressString
 *
 *  Same as AddIpAddress, except the arguments are already converted to strings
 *
 *  ENTRY   AddressList - pointer to IP_ADDR which may or may not already hold
 *                        an IP address
 *          Address     - IP address to add, as a string
 *          Mask        - corresponding IP subnet mask, as a string
 *
 *  EXIT    AddressList - updated with new info
 *
 *  RETURNS Success - 1
 *          Failure - 0
 *
 *  ASSUMES nothing
 *
 ******************************************************************************/

int AddIpAddressString(PIP_ADDR_STRING AddressList, LPSTR Address, LPSTR Mask)
{

    PIP_ADDR_STRING ipAddr;

    ASSERT( AddressList);
    ASSERT( Address);
    ASSERT( Mask);
    if (!AddressList || !Address || !Mask)
    {
        return 0;
    }

    if (AddressList->IpAddress.String[0])
    {
        for (ipAddr = AddressList; ipAddr->Next; ipAddr = ipAddr->Next)
        {
            ;
        }

        ipAddr->Next = NEW(IP_ADDR_STRING);
        if (!ipAddr->Next)
        {

            DEBUG_PRINT(("AddIpAddressString: failed to allocate memory for IP_ADDR_STRING\n"));

            return FALSE;
        }
        ipAddr = ipAddr->Next;
    }
    else
    {
        ipAddr = AddressList;
    }

    CopyString(ipAddr->IpAddress.String, sizeof(ipAddr->IpAddress.String), Address);
    CopyString(ipAddr->IpMask.String, sizeof(ipAddr->IpMask.String), Mask);

    return TRUE;
}

/*******************************************************************************
 *
 *  ConvertIpAddressToString
 *
 *  Converts a DWORD IP address or subnet mask to dotted decimal string
 *
 *  ENTRY   IpAddress   - IP Address to convert
 *          String      - pointer to place to store dotted decimal string
 *
 *  EXIT    String contains ASCII representation of IpAddress
 *
 *  RETURNS nothing
 *
 *  ASSUMES 1. IP address fits in a DWORD
 *
 ******************************************************************************/

VOID ConvertIpAddressToString(DWORD IpAddress, LPSTR String)
{

    IP_ADDR ipAddr;

    ipAddr.d = IpAddress;
    sprintf(String,
            "%d.%d.%d.%d",
            ipAddr.b[0],
            ipAddr.b[1],
            ipAddr.b[2],
            ipAddr.b[3]
            );
}

/*******************************************************************************
 *
 *  CopyString
 *
 *  Copies a string to a buffer. If the buffer would overflow, the string is
 *  truncated
 *
 *  ENTRY   Destination         - destination buffer to copy to
 *          DestinationLength   - size of Destination
 *          Source              - source string to copy
 *
 *  EXIT    Destination updated
 *
 *  RETURNS nothing
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID CopyString(LPSTR Destination, DWORD DestinationLength, LPSTR Source)
{

    DWORD maximumCharacters = min(DestinationLength - 1, STRLEN(Source));

    strncpy(Destination, Source, maximumCharacters);
    Destination[maximumCharacters] = '\0';
}

DWORD
FillInterfaceNames(
    IN OUT  PADAPTER_INFO   pAdapterList
    )
{
    DWORD           dwResult, i, dwCount;
    PADAPTER_INFO   pAdapter;

    PIP_INTERFACE_NAME_INFO pTable;


    dwResult = NhpAllocateAndGetInterfaceInfoFromStack(&pTable,
                                                       &dwCount,
                                                       TRUE,
                                                       GetProcessHeap(),
                                                       HEAP_NO_SERIALIZE);

    if(dwResult != NO_ERROR)
    {
        return dwResult;
    }

    for(i = 0; i < dwCount; i++)
    {
        if(!IsEqualGUID(&(pTable[i].InterfaceGuid),
                       &(GUID_NULL)))
        {
            for(pAdapter = pAdapterList;
                pAdapter;
                pAdapter = pAdapter->Next)
            {
                if(pAdapter->Index == pTable[i].Index)
                {
                    //
                    // structure copy
                    //

                    pAdapter->InterfaceGuid = pTable[i].InterfaceGuid;
                }
            }
        }
    }

    HeapFree(GetProcessHeap(),
             0,
             pTable);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\ipsink.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: ipsink.h
//
//  Abstract:
//
//    Internal header
//
//
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//

typedef enum
{
    EVENT_IPSINK_MULTICASTLIST,
    EVENT_IPSINK_ADAPTER_DESCRIPTION,
    EVENT_IPSINK_THREAD_SHUTDOWN,
    EVENT_IPSINK_THREAD_SYNC,
    EVENT_COUNT

} KSEVENT_IPSINK;


class CIPSinkControlInterfaceHandler :
    public CUnknown,
    public IBDA_IPSinkControl,
    public IBDA_IPSinkInfo
    {

public:

    DECLARE_IUNKNOWN;
    
    
// IBDA_IPSinkInfo  (in f:\nt\multimedia\Published\DXMDev\dshowdev\idl\bdaiface.idl )
    STDMETHODIMP get_MulticastList (
        unsigned long *pulcbSize,           // 6*N 6-byte 802.3 addresses
        BYTE          **pbBuffer            // allocated with CoTaskMemAlloc, must CoTaskMemFree in the callee
        );

    STDMETHODIMP get_AdapterDescription (
        BSTR    *pbstrBuffer
        );

    STDMETHODIMP get_AdapterIPAddress (
        BSTR     *pbstrBuffer
        );

// IBDA_IPSinkControl  (in f:\nt\multimedia\Published\DXMDev\dshowdev\idl\bdaiface.idl )
            // being depreciate - do not use in Ring3 code
    STDMETHODIMP GetMulticastList (
        unsigned long *pulcbSize,
        BYTE          **pbBuffer
        );

    STDMETHODIMP GetAdapterIPAddress (
        unsigned long *pulcbSize,
        PBYTE         *pbBuffer
        );

// local methods
    HRESULT GetAdapterDescription (
        unsigned long *pulcbSize,
        PBYTE         *pbBuffer
        );

    STDMETHODIMP SetAdapterIPAddress (
        unsigned long pulcbSize,
        PBYTE         pbBuffer
        );

    static CUnknown* CALLBACK CreateInstance(
            LPUNKNOWN UnkOuter,
            HRESULT* hr
            );

private:

    static DWORD WINAPI ThreadFunctionWrapper (LPVOID pvParam);

    CIPSinkControlInterfaceHandler(
            LPUNKNOWN UnkOuter,
            TCHAR* Name,
            HRESULT* hr
            );

    ~CIPSinkControlInterfaceHandler (
            void
            );

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID riid,
            PVOID* ppv
            );

    STDMETHODIMP EnableEvent (
            const GUID *pInterfaceGuid,
            ULONG ulId
            );

    STDMETHODIMP ThreadFunction (
            void
            );

    STDMETHODIMP Set (
            IN  PKSPROPERTY  pIPSinkControl,
            IN  PVOID pvBuffer,
            IN  ULONG ulcbSize
            );

    STDMETHODIMP Get (
            IN  PKSPROPERTY pIPSinkControl,
            OUT PVOID  pvBuffer,
            OUT PULONG pulcbSize
            );

    HRESULT
    CreateThread (
            void
            );

    void ExitThread (
            void
            );

private:

    HANDLE                m_ObjectHandle;
    HANDLE                m_EndEventHandle;
    KSEVENTDATA           m_EventData;
    HANDLE                m_EventHandle [EVENT_COUNT];
    HANDLE                m_ThreadHandle;
    PBYTE                 m_pMulticastList;
    ULONG                 m_ulcbMulticastList;
    ULONG                 m_ulcbAllocated;
    PBYTE                 m_pAdapterDescription;
    ULONG                 m_ulcbAdapterDescription;
    ULONG                 m_ulcbAllocatedForDescription;
    PBYTE                 m_pIPAddress;
    ULONG                 m_ulcbIPAddress;
    ULONG                 m_ulcbAllocatedForAddress;
    LPUNKNOWN             m_UnkOuter;

    const GUID*           m_pPropSetID;
    const GUID*           m_pEventSetID;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\ipsink.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: ipsink.cpp
//
//  Abstract:
//
//    Implements IPSink Plugin Component
//
//
////////////////////////////////////////////////////////////////////////////////////////////

#include "pch.h"
//#include "ipidl.h"
#include "ipuids.h"
#include "ipsink.h"
#include <iptypes.h>


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct _ADAPTER_INFO
{
    struct _ADAPTER_INFO* Next;
    char AdapterName[MAX_ADAPTER_NAME_LENGTH + 1];
    char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
    UINT AddressLength;
    BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
    UINT Index;
    GUID InterfaceGuid;
    UINT Type;
    UINT DhcpEnabled;
    UINT AutoconfigEnabled;     // is autoconfiguration possible?
    UINT AutoconfigActive;      // is the adapter currently autoconfigured?
    UINT NodeType;
    UINT NetbiosEnabled;
    IP_ADDR_STRING IpAddressList;
    IP_ADDR_STRING GatewayList;
    IP_ADDR_STRING DhcpServer;
    BOOL HaveWins;
    IP_ADDR_STRING PrimaryWinsServer;
    IP_ADDR_STRING SecondaryWinsServer;
    time_t LeaseObtained;
    time_t LeaseExpires;
    char DomainName[MAX_DOMAIN_NAME_LEN + 1];
    IP_ADDR_STRING DnsServerList;
} ADAPTER_INFO, *PADAPTER_INFO;

extern "C" PADAPTER_INFO MyGetAdapterInfo(void);

////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] =
{
    {L"IBDA_IPSinkControl", &IID_IBDA_IPSinkControl, CIPSinkControlInterfaceHandler::CreateInstance, NULL, NULL}
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);


///////////////////////////////////////////////////////////////////////////////
//
// DllRegisterServer
//
// Exported entry points for registration and unregistration
//
STDAPI
DllRegisterServer (
    void
    )
{
    return AMovieDllRegisterServer2( TRUE );

}


///////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer (
    void
    )
///////////////////////////////////////////////////////////////////////////////
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer


///////////////////////////////////////////////////////////////////////////////
HRESULT
FindInterfaceOnGraph (
    IUnknown* pUnkGraph,
    REFIID riid,
    void **ppInterface
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = E_NOINTERFACE;

    CComPtr<IBaseFilter> pFilter;
    CComPtr<IEnumFilters> pEnum;
    ULONG ulFetched = 0;

    if(!ppInterface)
    {
        return E_FAIL;
    }

    *ppInterface= NULL;

    if(!pUnkGraph)
    {
        return E_FAIL;
    }

    CComQIPtr<IFilterGraph, &IID_IFilterGraph> pFilterGraph(pUnkGraph);

    hr = pFilterGraph->EnumFilters(&pEnum);
    if(!pEnum)
    {
        return hr;
    }

    //
    // find the first filter in the graph that supports riid interface
    //
    while(!*ppInterface && pEnum->Next(1, &pFilter, NULL) == S_OK)
    {
        hr = pFilter->QueryInterface(riid, ppInterface);
        pFilter.Release();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CUnknown*
CALLBACK
CIPSinkControlInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    CUnknown *Unknown;

    Unknown = new CIPSinkControlInterfaceHandler(UnkOuter, NAME("IBDA_IPSinkControl"), hr);
    if (!Unknown)
    {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CIPSinkControlInterfaceHandler::CIPSinkControlInterfaceHandler(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) :
    CUnknown(Name, UnkOuter, hr)
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG ul = 0;

    if (SUCCEEDED(*hr))
    {
        if (UnkOuter)
        {
            IKsObject*   Object = NULL;


            m_UnkOuter = UnkOuter;

            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
            if (FAILED (*hr))
            {
                return;
            }

            if (SUCCEEDED(*hr))
            {
                m_ObjectHandle = Object->KsGetObjectHandle ();
                if (!m_ObjectHandle)
                {
                    *hr = E_UNEXPECTED;
                }

                Object->Release();


                //
                // Test code to setup a thread and event
                //
                m_pEventSetID         = &IID_IBDA_IPSinkEvent;
                m_ThreadHandle        = NULL;

                m_pMulticastList      = NULL;
                m_pIPAddress          = NULL;
                m_pAdapterDescription = NULL;

                m_ulcbMulticastList   = 0;
                m_ulcbAdapterDescription = 0;
                m_ulcbIPAddress       = 0;

                m_ulcbAllocated       = 0;
                m_ulcbAllocatedForDescription = 0;
                m_ulcbAllocatedForAddress     = 0;


                for (ul = 0; ul < EVENT_COUNT; ul++)
                {
                    m_EventHandle [ul]       = NULL;
                }

                *hr = CreateThread ();
            }
        }
        else
        {
            *hr = VFW_E_NEED_OWNER;
        }
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CIPSinkControlInterfaceHandler::~CIPSinkControlInterfaceHandler (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG ul = 0;

    //
    // Make sure we kill any threads we have running and
    // close the thread handle
    //
    ExitThread();


    //
    // Close the event handles
    //
    for (ul = 0; ul < EVENT_COUNT; ul++)
    {
        if (m_EventHandle [ul])
        {
            CloseHandle(m_EventHandle [ul]);
            m_EventHandle [ul] = NULL;
        }
    }

    m_ulcbMulticastList = 0;
    m_ulcbAllocated = 0;
    delete m_pMulticastList;
    m_pMulticastList = NULL;

    m_ulcbAdapterDescription = 0;
    m_ulcbAllocatedForDescription = 0;
    delete m_pAdapterDescription;
    m_pAdapterDescription = NULL;

    m_ulcbIPAddress = 0;
    m_ulcbAllocatedForAddress = 0;
    delete [] m_pIPAddress;
    m_pIPAddress = NULL;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    if (riid ==  __uuidof(IBDA_IPSinkControl))
    {
        return GetInterface(static_cast<IBDA_IPSinkControl*>(this), ppv);
    }
    if (riid ==  __uuidof(IBDA_IPSinkInfo))
    {
        return GetInterface(static_cast<IBDA_IPSinkInfo*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
HRESULT
CIPSinkControlInterfaceHandler::CreateThread (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = NOERROR;

    ASSERT( !m_EventHandle[EVENT_IPSINK_THREAD_SYNC]);
    if (!m_EventHandle[EVENT_IPSINK_THREAD_SYNC])
    {
        m_EventHandle[EVENT_IPSINK_THREAD_SYNC] 
            = CreateEvent ( NULL,           // no security attributes
                            TRUE,           // manual reset
                            FALSE,          // initial state not signaled
                            NULL            // no object name
                            );
    }

    ASSERT( !m_EventHandle[EVENT_IPSINK_THREAD_SHUTDOWN]);
    if (!m_EventHandle[EVENT_IPSINK_THREAD_SHUTDOWN])
    {
        m_EventHandle[EVENT_IPSINK_THREAD_SHUTDOWN] 
            = CreateEvent ( NULL,           // no security attributes
                            TRUE,           // manual reset
                            FALSE,          // initial state not signaled
                            NULL            // no object name
                            );
    }

    if (   !m_EventHandle[EVENT_IPSINK_THREAD_SYNC]
        || !m_EventHandle[EVENT_IPSINK_THREAD_SHUTDOWN]
       )
    {
        ULONG   uliHandle;

        hr = HRESULT_FROM_WIN32( GetLastError ());
        
        goto errExit;
    }

    {
        ULONG ulcbSize            = 0;
        BYTE *pbMulticastList     = NULL;
        BYTE *pbAdapterDescription = NULL;

        //
        // Get the multicast list initially on startup
        //
        this->GetMulticastList (&ulcbSize, &pbMulticastList);
    
        this->GetAdapterDescription (&ulcbSize, &pbAdapterDescription);
    }

    ASSERT( !m_ThreadHandle);
    if (!m_ThreadHandle)
    {
        DWORD  ThreadId;

        m_ThreadHandle = ::CreateThread (
                               NULL,
                               0,
                               ThreadFunctionWrapper,
                               (LPVOID) this,
                               0,
                               (LPDWORD) &ThreadId
                               );
        if (m_ThreadHandle == NULL)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            goto errExit;
        }
    }

ret:
    return hr;

errExit:

    //
    // Close the event handles
    //
    ULONG   uliEvent;
    for (uliEvent = 0; uliEvent < EVENT_COUNT; uliEvent++)
    {
        if (m_EventHandle [uliEvent])
        {
            CloseHandle(m_EventHandle [uliEvent]);
            m_EventHandle [uliEvent] = NULL;
        }
    }

    goto ret;
}

////////////////////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP
CIPSinkControlInterfaceHandler::GetMulticastList (
    unsigned long *pulcbSize,
    PBYTE         *pbBuffer
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  IPSinkControl = {0};
    HRESULT hr                = NOERROR;
    FILTER_INFO fi            = {0};

    //
    // Initialize KSPROPERTY structure
    //
    IPSinkControl.Set   = IID_IBDA_IPSinkControl;
    IPSinkControl.Id    = KSPROPERTY_IPSINK_MULTICASTLIST;
    IPSinkControl.Flags = KSPROPERTY_TYPE_GET;

    m_ulcbMulticastList = 0;

    do

    {
        hr = this->Get (&IPSinkControl, m_pMulticastList, &m_ulcbMulticastList);

        if (HRESULT_CODE (hr) == ERROR_MORE_DATA)
        {
            if (m_ulcbMulticastList > m_ulcbAllocated)
            {
                if (m_pMulticastList)
                {
                    delete (m_pMulticastList);
                }

                m_ulcbAllocated  = m_ulcbMulticastList;
                m_pMulticastList = new BYTE [m_ulcbAllocated];

                if (m_pMulticastList == NULL)
                {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    goto ret;
                }
            }
        }
        else if (HRESULT_CODE (hr) != NOERROR)
        {
            goto ret;
        }
        else
        {

            HRESULT               hResult         = NOERROR;
            IBaseFilter*          pBaseFilter     = NULL;
            IFilterGraph*         pGraph          = NULL;
            IBDA_EthernetFilter*  pEthernetFilter = NULL;
            IBDA_NetworkProvider* pNetProvider    = NULL;


            *pulcbSize = m_ulcbMulticastList;
            *pbBuffer   = (PBYTE) m_pMulticastList;


            //
            // Get an interface pointer to the current graph
            //
            hResult =  m_UnkOuter->QueryInterface(IID_IBaseFilter, reinterpret_cast<PVOID*>(&pBaseFilter));
            pBaseFilter->QueryFilterInfo (&fi);
            pGraph = fi.pGraph;
            pBaseFilter->Release ();


            if (pGraph != NULL)
            {
                hResult = FindInterfaceOnGraph (pGraph, IID_IBDA_NetworkProvider, (PVOID *) &pNetProvider);
                if ( SUCCEEDED (hResult))
                {
                    if (pNetProvider)
                    {
                        //
                        // Get a pointer to the ethernet interface of the network provider
                        //
                        hResult = pNetProvider->QueryInterface (IID_IBDA_EthernetFilter, (PVOID*) &pEthernetFilter );
                        if (pEthernetFilter)
                        {
                            hResult = pEthernetFilter->PutMulticastList (m_ulcbMulticastList, m_pMulticastList);

                            //
                            // Release our reference to the net providers ethernet filter interface
                            //
                            pEthernetFilter->Release ();

                        }

                        pNetProvider->Release ();
                    }
                }

                pGraph->Release ();
            }
        }

    } while (HRESULT_CODE (hr) == ERROR_MORE_DATA);


ret:

    return hr;
}

STDMETHODIMP
CIPSinkControlInterfaceHandler::get_MulticastList (
    unsigned long *pulcbSize,                           
    BYTE         **ppbBufferOut
    )
{
    unsigned long ulcbSize;
    PBYTE         pbBuffer;
    HRESULT hr = GetMulticastList(&ulcbSize, &pbBuffer);
    if(FAILED(hr))
        return hr;
    
    BYTE *pbBufferOut = (BYTE *) CoTaskMemAlloc(ulcbSize);
    if(NULL == pbBufferOut)
    {
        *pulcbSize = 0;
        return E_OUTOFMEMORY;
    }
    memcpy(pbBufferOut, pbBuffer, ulcbSize);                // copy into our newly allocated memory...

    *pulcbSize = ulcbSize;
    *ppbBufferOut = pbBufferOut;
    return S_OK;    
}
////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::GetAdapterIPAddress (
    unsigned long *pulcbSize,
    PBYTE         *pbBuffer
    )
///////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  IPSinkControl = {0};
    HRESULT hr                = NOERROR;
    FILTER_INFO fi            = {0};

    //
    // Initialize KSPROPERTY structure
    //
    IPSinkControl.Set   = IID_IBDA_IPSinkControl;
    IPSinkControl.Id    = KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION;
    IPSinkControl.Flags = KSPROPERTY_TYPE_GET;

    m_ulcbAdapterDescription = 0;

                        // get the adapter description.  If allocated buffer isn't big enough, try it again
    do
    {
        hr = this->Get (&IPSinkControl, m_pAdapterDescription, &m_ulcbAdapterDescription);

        if (HRESULT_CODE (hr) == ERROR_MORE_DATA)
        {
            if (m_ulcbAdapterDescription > m_ulcbAllocatedForDescription)
            {
                if (m_pAdapterDescription)
                {
                    delete (m_pAdapterDescription);
                }

                m_ulcbAllocatedForDescription  = m_ulcbAdapterDescription;
                m_pAdapterDescription = new BYTE [m_ulcbAllocatedForDescription];

                if (m_pAdapterDescription == NULL)
                {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    goto ret;
                }
            }
        }

    } while (HRESULT_CODE (hr) == ERROR_MORE_DATA);


    //
    // Get a list of adapters from TCP/IP and use the description
    // to find the target adapter
    //
    hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND);
    {
        PADAPTER_INFO   adapterList;
        PADAPTER_INFO   adapter;
        PIP_ADDR_STRING address;

        adapterList = MyGetAdapterInfo();

        for (adapter = adapterList; adapter ; adapter = adapter->Next)
        {
            if (memcmp (adapter->Description, m_pAdapterDescription, m_ulcbAdapterDescription) == 0)
            {
                if (m_pIPAddress == NULL)
                {
                    m_ulcbAllocatedForAddress  = sizeof (IP_ADDRESS_STRING);
                    m_pIPAddress = new BYTE [m_ulcbAllocatedForAddress];

                    if (m_pIPAddress == NULL)
                    {
                        hr = ERROR_NOT_ENOUGH_MEMORY;
                        goto ret;
                    }
                    m_ulcbIPAddress = m_ulcbAllocatedForAddress;
                }

                address = &adapter->IpAddressList;

                memcpy (m_pIPAddress, address->IpAddress.String, m_ulcbIPAddress);

                *pulcbSize = m_ulcbIPAddress;
                *pbBuffer  = m_pIPAddress;
                hr = NOERROR;
                break;
            }
        }
    }
ret:

    return hr;
}

STDMETHODIMP
CIPSinkControlInterfaceHandler::get_AdapterIPAddress (
    BSTR         *pbstrBuffer
    )
{
    unsigned long ulcbSize;
    PBYTE         pbBuffer;
    HRESULT hr = GetAdapterIPAddress(&ulcbSize, &pbBuffer);
    if(FAILED(hr))
        return hr;

    CComBSTR bstrTmp(ulcbSize, (char *) pbBuffer);              // copy into bstrTmp, it has a nice CopyTo method that alloc's correct way
    if(!bstrTmp)
        return ERROR_NOT_ENOUGH_MEMORY;
    return bstrTmp.CopyTo(pbstrBuffer);         
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::SetAdapterIPAddress (
    unsigned long ulcbSize,
    PBYTE         pbBuffer
    )
///////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  IPSinkControl = {0};
    HRESULT hr                = NOERROR;
    FILTER_INFO fi            = {0};

    //
    // Initialize KSPROPERTY structure
    //
    IPSinkControl.Set   = IID_IBDA_IPSinkControl;
    IPSinkControl.Id    = KSPROPERTY_IPSINK_ADAPTER_ADDRESS;
    IPSinkControl.Flags = KSPROPERTY_TYPE_SET;

    hr = this->Set (&IPSinkControl, pbBuffer, ulcbSize);

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
HRESULT
CIPSinkControlInterfaceHandler::GetAdapterDescription (
    unsigned long *pulcbSize,
    PBYTE         *pbBuffer
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  IPSinkControl = {0};
    HRESULT hr                = NOERROR;
    FILTER_INFO fi            = {0};

    //
    // Initialize KSPROPERTY structure
    //
    IPSinkControl.Set   = IID_IBDA_IPSinkControl;
    IPSinkControl.Id    = KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION;
    IPSinkControl.Flags = KSPROPERTY_TYPE_GET;

    m_ulcbAdapterDescription = 0;

    do

    {
        hr = this->Get (&IPSinkControl, m_pAdapterDescription, &m_ulcbAdapterDescription);

        if (HRESULT_CODE (hr) == ERROR_MORE_DATA)
        {
            if (m_ulcbAdapterDescription > m_ulcbAllocatedForDescription)
            {
                if (m_pAdapterDescription)
                {
                    delete (m_pAdapterDescription);
                }

                m_ulcbAllocatedForDescription  = m_ulcbAdapterDescription;
                m_pAdapterDescription = new BYTE [m_ulcbAllocatedForDescription];

                if (m_pAdapterDescription == NULL)
                {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    goto ret;
                }
            }
        }
        else
        {
            *pbBuffer = m_pAdapterDescription;
            *pulcbSize = m_ulcbAllocatedForDescription;
            goto ret;
        }

    } while (HRESULT_CODE (hr) == ERROR_MORE_DATA);


ret:

    return hr;
}

STDMETHODIMP
CIPSinkControlInterfaceHandler::get_AdapterDescription (
    BSTR         *pbstrBuffer
    )
{
    unsigned long ulcbSize = 0;
    PBYTE         pbBuffer = NULL;

    HRESULT hr = GetAdapterDescription(&ulcbSize, &pbBuffer);
    if(FAILED(hr))
        return hr;

    if (!pbBuffer || !ulcbSize)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    CComBSTR bstrTmp(ulcbSize, (char *) pbBuffer);              // copy into bstrTmp, it has a nice CopyTo method that alloc's correct way
    if(!bstrTmp)
        return ERROR_NOT_ENOUGH_MEMORY;
    return bstrTmp.CopyTo(pbstrBuffer);         
}
////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::ThreadFunction (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    DWORD  dwWaitResult       = WAIT_OBJECT_0;
    HRESULT hr                = NOERROR;
    KSPROPERTY  IPSinkControl = {0};
    ULONG ulcbSize            = 0;
    BYTE *pbMulticastList     = NULL;
    BYTE *pbAdapterDescription = NULL;
    BYTE *pbNIC                = NULL;
    HANDLE hEvent              = NULL;


    //
    // Enable an event which will get signaled by the IPSink minidriver when there
    // is a change to the multicast list
    //
    if ((hr = EnableEvent (&IID_IBDA_IPSinkEvent, EVENT_IPSINK_MULTICASTLIST)) != NOERROR)
    {
        goto ret;
    }

    //
    // Enable an event which will get signaled by the IPSink minidriver when there
    // is a change in the adapter description
    //
    if ((hr = EnableEvent (&IID_IBDA_IPSinkEvent, EVENT_IPSINK_ADAPTER_DESCRIPTION)) != NOERROR)
    {
        if (m_EventHandle [EVENT_IPSINK_MULTICASTLIST])
        {
            // Close this event since we got an error.
            //
            CloseHandle (m_EventHandle [EVENT_IPSINK_MULTICASTLIST]);
        }
        m_EventHandle [EVENT_IPSINK_MULTICASTLIST] = NULL;

        goto ret;
    }

    do
    {



        dwWaitResult = WaitForMultipleObjects (
                            EVENT_COUNT,                  // number of handles in the handle array
                            this->m_EventHandle,          // pointer to the object-handle array
                            FALSE,                        // wait flag
                            INFINITE
                            );

        if (dwWaitResult == WAIT_FAILED)
        {
            dwWaitResult = GetLastError ();
            hr = E_FAIL;
            goto ret;
        }

        hEvent = this->m_EventHandle [dwWaitResult - WAIT_OBJECT_0];

        switch (dwWaitResult - WAIT_OBJECT_0)
        {
            case EVENT_IPSINK_MULTICASTLIST:

                hr = this->GetMulticastList (&ulcbSize, &pbMulticastList);

                break;

            case EVENT_IPSINK_ADAPTER_DESCRIPTION:

                hr = this->GetAdapterDescription (&ulcbSize, &pbAdapterDescription);
                hr = this->GetAdapterIPAddress (&ulcbSize, &pbNIC);
                hr = this->SetAdapterIPAddress (ulcbSize, pbNIC);

                break;

            case EVENT_IPSINK_THREAD_SHUTDOWN:    
            default:
                goto ret;
                break;
        }


        //
        // Reset and get ready for the next event
        //

        if (ResetEvent (hEvent) == FALSE)
        {
            //
            // ERROR detected resetting event
            //
            hr = GetLastError ();
            goto ret;
        }

    } while (TRUE);


ret:

    //  Let the parent thread know that we're done.
    //
    if (m_EventHandle [EVENT_IPSINK_THREAD_SYNC])
    {
        SetEvent( m_EventHandle [EVENT_IPSINK_THREAD_SYNC]);
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DWORD
WINAPI
CIPSinkControlInterfaceHandler::ThreadFunctionWrapper (
    LPVOID pvParam
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    CIPSinkControlInterfaceHandler *pThread;

    pThread = (CIPSinkControlInterfaceHandler *) pvParam;

    return pThread->ThreadFunction ();
}



////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::EnableEvent (
    const GUID *pInterfaceGuid,
    ULONG ulId
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = NOERROR;
    KSEVENT Event;
    DWORD BytesReturned;

    if (m_ObjectHandle && m_EventHandle [ulId] == NULL)
    {
        this->m_EventHandle [ulId] = CreateEvent (
                                NULL,           // no security attributes
                                TRUE,           // manual reset
                                FALSE,          // initial state not signaled
                                NULL            // no object name
                                );

        if (this->m_EventHandle [ulId])
        {
            //
            // Set the event information into some KS structures which will
            // get passed to KS and Streaming class
            //
            m_EventData.NotificationType        = KSEVENTF_EVENT_HANDLE;
            m_EventData.EventHandle.Event       = this->m_EventHandle [ulId];
            m_EventData.EventHandle.Reserved[0] = 0;
            m_EventData.EventHandle.Reserved[1] = 0;

            Event.Set   = *pInterfaceGuid; //IID_IBDA_IPSinkEvent;
            Event.Id    = ulId;
            Event.Flags = KSEVENT_TYPE_ENABLE;

            hr = ::KsSynchronousDeviceControl (
                m_ObjectHandle,
                IOCTL_KS_ENABLE_EVENT,
                &Event,
                sizeof(Event),
                &m_EventData,
                sizeof(m_EventData),
                &BytesReturned
                );

        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError ());
        }
    }

    return hr;
}



////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
void
CIPSinkControlInterfaceHandler::ExitThread(
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG ul = 0;

    if (m_ThreadHandle && m_EventHandle [EVENT_IPSINK_THREAD_SHUTDOWN])
    {
        //
        // Tell the thread to exit
        //
        m_ThreadHandle = NULL;
        if (SetEvent(m_EventHandle [EVENT_IPSINK_THREAD_SHUTDOWN]))
        {
            //
            // Synchronize with thread termination.
            //
            if (m_EventHandle [EVENT_IPSINK_THREAD_SYNC])
            {
                WaitForSingleObjectEx( 
                    m_EventHandle [EVENT_IPSINK_THREAD_SYNC],
                    INFINITE, 
                    FALSE
                    );
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::Set (
     IN  PKSPROPERTY pIPSinkControl,
     IN  PVOID  pvBuffer,
     IN  ULONG  ulcbSize
     )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG       BytesReturned = 0;
    HRESULT     hr            = NOERROR;

    hr = ::KsSynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                (PVOID) pIPSinkControl,
                sizeof(KSPROPERTY),
                pvBuffer,
                ulcbSize,
                &BytesReturned);

    ulcbSize = BytesReturned;

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::Get (
     IN  PKSPROPERTY pIPSinkControl,
     OUT PVOID  pvBuffer,
     OUT PULONG pulcbSize
     )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG       BytesReturned = 0;
    HRESULT     hr            = NOERROR;

    hr = ::KsSynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                (PVOID) pIPSinkControl,
                sizeof(KSPROPERTY),
                pvBuffer,
                *pulcbSize,
                &BytesReturned);

    *pulcbSize = BytesReturned;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\ipuids.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: ipsink.h
//
//  Abstract:
//
//    Internal header
//
//
/////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
// 
#define STATIC_IID_IBDA_IPSinkControl\
    0x3F4DC8E2L, 0x4050, 0x11D3, 0x8F, 0x4B, 0x00, 0xC0, 0x4F, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("3F4DC8E2-4050-11d3-8F4B-00C04F7971E2", IID_IBDA_IPSinkControl);
#define IID_IBDA_IPSinkControl DEFINE_GUIDNAMED(IID_IBDA_IPSinkControl)

// {A750108F-492E-4d51-95F7-649B23FF7AD7}
#define STATIC_IID_IBDA_IPSinkInfo\
    0xa750108f, 0x492e, 0x4d51, 0x95, 0xf7, 0x64, 0x9b, 0x23, 0xff, 0x7a, 0xd7
DEFINE_GUIDSTRUCT("A750108F-492E-4d51-95F7-649B23FF7AD7", IID_IBDA_IPSinkInfo);
#define IID_IBDA_IPSinkInfo DEFINE_GUIDNAMED(IID_IBDA_IPSinkInfo)


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define STATIC_IID_IBDA_IPSinkEvent\
    0x3F4DC8E3L, 0x4050, 0x11D3, 0x8F, 0x4B, 0x00, 0xC0, 0x4F, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("3F4DC8E3-4050-11d3-8F4B-00C04F7971E2", IID_IBDA_IPSinkEvent);
#define IID_IBDA_IPSinkEvent DEFINE_GUIDNAMED(IID_IBDA_IPSinkEvent)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\entity.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    entity.c

Abstract:

    This module contains functions to get the entity list from the TCP/IP
    device driver

    Contents:
        GetEntityList

Author:

    Richard L Firth (rfirth) 20-May-1994

Revision History:

    20-May-1994 rfirth
        Created

--*/

#include "precomp.h"
#pragma hdrstop

/*******************************************************************************
 *
 *  GetEntityList
 *
 *  Allocates a buffer for, and retrieves, the list of entities supported by the
 *  TCP/IP device driver
 *
 *  ENTRY   nothing
 *
 *  EXIT    EntityCount - number of entities in the buffer
 *
 *  RETURNS Success - pointer to allocated buffer containing list of entities
 *          Failure - NULL
 *
 *  ASSUMES
 *
 ******************************************************************************/

TDIEntityID* GetEntityList(UINT* EntityCount) {

    TCP_REQUEST_QUERY_INFORMATION_EX req;
    DWORD status;
    DWORD inputLen;
    DWORD outputLen;
    LPVOID buffer = NULL;
    TDIEntityID* pEntity = NULL;
    int moreEntities = TRUE;

    memset(&req, 0, sizeof(req));

    req.ID.toi_entity.tei_entity = GENERIC_ENTITY;
    req.ID.toi_entity.tei_instance = 0;
    req.ID.toi_class = INFO_CLASS_GENERIC;
    req.ID.toi_type = INFO_TYPE_PROVIDER;
    req.ID.toi_id = ENTITY_LIST_ID;

    inputLen = sizeof(req);
    outputLen = sizeof(TDIEntityID) * DEFAULT_MINIMUM_ENTITIES;

    //
    // this is over-engineered - its very unlikely that we'll ever get >32
    // entities returned, never mind >64K's worth
    //

    do {

        DWORD previousOutputLen;

        previousOutputLen = outputLen;
        if (pEntity) {
            free((void*)pEntity);
        }
        pEntity = (TDIEntityID*)malloc((size_t)outputLen);
        if (!pEntity) {

            DEBUG_PRINT(("GetEntityList: failed to allocate entity buffer (%ld bytes)\n",
                        outputLen
                        ));

            return NULL;
        }
        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)pEntity,
                           &outputLen
                           );
        if (status != TDI_SUCCESS) {

            DEBUG_PRINT(("GetEntityList: WsControl(GENERIC_ENTITY) returns %ld, outputLen = %ld\n",
                        status,
                        outputLen
                        ));

            free((void*)pEntity);
            return NULL;
        }

        DEBUG_PRINT(("WsControl(GENERIC_ENTITY) required length = %ld\n", outputLen));

        if (outputLen <= previousOutputLen) {
            moreEntities = FALSE;
        }
    } while ( moreEntities );

    DEBUG_PRINT(("%d entities returned\n", (outputLen / sizeof(TDIEntityID))));

    *EntityCount = (UINT)(outputLen / sizeof(TDIEntityID));
    return pEntity;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\myconfig.c ===
#include "precomp.h"

#define DEVICE_PREFIX       "\\Device\\"
#define DEVICE_PREFIX_W     L"\\Device\\"
#define TCPIP_DEVICE_PREFIX "\\Device\\Tcpip_"
#define KEY_TCP             1
#define KEY_NBT             2
#define TCPIP_PARAMS_INTER_KEY "Tcpip\\Parameters\\Interfaces\\"
#define NETBT_ADAPTER_KEY      "NetBT\\Adapters\\"
#define STRING_ARRAY_DELIMITERS " \t,;"

#ifdef DBG
#define SET_DHCP_MODE 1
#define SET_AUTO_MODE 2
#endif


#define ReleaseMemory(p)    LocalFree((HLOCAL)(p))

#ifdef DBG
UINT uChangeMode = 0;
#endif

BOOL          ReadRegistryDword(HKEY, LPSTR, LPDWORD);

#ifdef DBG
BOOL WriteRegistryDword(HKEY hKey, LPSTR szParameter, DWORD *pdwValue );
#endif

BOOL   ReadRegistryString(HKEY, LPSTR, LPSTR, LPDWORD);
BOOL   ReadRegistryOemString(HKEY, LPWSTR, LPSTR, LPDWORD);
BOOL   ReadRegistryIpAddrString(HKEY, LPSTR, PIP_ADDR_STRING);
LPVOID GrabMemory(DWORD);
void   print_IFEntry( char* message, struct IFEntry * s );

#if defined(DEBUG)

BOOL Debugging = FALSE;
int  trace     = 0;

#endif

/*******************************************************************************
 *
 *  ReadRegistryDword
 *
 *  Reads a registry value that is stored as a DWORD
 *
 *  ENTRY   Key             - open registry key where value resides
 *          ParameterName   - name of value to read from registry
 *          Value           - pointer to returned value
 *
 *  EXIT    *Value = value read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ReadRegistryDword(HKEY Key, LPSTR ParameterName, LPDWORD Value)
{

    LONG err;
    DWORD valueLength;
    DWORD valueType;

    valueLength = sizeof(*Value);
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)Value,
                          &valueLength
                          );
    if ((err == ERROR_SUCCESS) && (valueType == REG_DWORD) && (valueLength == sizeof(DWORD))) {

        DEBUG_PRINT(("ReadRegistryDword(%s): val = %d, type = %d, len = %d\n",
                    ParameterName,
                    *Value,
                    valueType,
                    valueLength
                    ));

    } else {

        DEBUG_PRINT(("ReadRegistryDword(%p,%s): err = %d\n",
                     Key, ParameterName, err));

        err = !ERROR_SUCCESS;
    }

    return (err == ERROR_SUCCESS);
}

/*******************************************************************************
 *
 *  OpenAdapterKey
 *
 *  Opens one of the 2 per-adapter registry keys:
 *     Tcpip\\Parameters"\<adapter>
 *  or NetBT\Adapters\<Adapter>
 *
 *  ENTRY   KeyType - KEY_TCP or KEY_NBT
 *          Name    - pointer to adapter name to use
 *          Key     - pointer to returned key
 *
 *  EXIT    Key updated
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *  HISTORY:     MohsinA, 16-May-97. Fixing for PNP.
 *
 ******************************************************************************/

BOOL OpenAdapterKey(DWORD KeyType, const LPSTR Name, PHKEY Key)
{

    HKEY ServicesKey        = INVALID_HANDLE_VALUE;

    LONG err;
    CHAR keyName[MAX_ADAPTER_NAME_LENGTH + sizeof(TCPIP_PARAMS_INTER_KEY)];

    if (!Name)
    {
        return FALSE;
    }

    if (strlen( Name) >= MAX_ADAPTER_NAME_LENGTH)
    {
        return FALSE;
    }

    if (KeyType == KEY_TCP) {

        //
        // open the handle to this adapter's TCPIP parameter key
        //

        strcpy(keyName, TCPIP_PARAMS_INTER_KEY );
        strcat(keyName, Name);

    } else if (KeyType == KEY_NBT) {

        //
        // open the handle to the NetBT\Adapters\<Adapter> handle
        //

        strcpy(keyName, NETBT_ADAPTER_KEY );
        strcat(keyName, Name);
    }

    TRACE_PRINT(("OpenAdapterKey: %s\n", keyName ));

    err = RegOpenKey(ServicesKey, keyName, Key );

    if( err != ERROR_SUCCESS ){
        DEBUG_PRINT(("OpenAdapterKey: RegOpenKey ServicesKey %s, err=%d\n",
                     keyName, GetLastError() ));
    }else{
        TRACE_PRINT(("Exit OpenAdapterKey: %s ok\n", keyName ));
    }

    return (err == ERROR_SUCCESS);
}


/*******************************************************************************
 *
 *  GetAdapterNameToIndexInfo
 *
 *  Gets the mapping between IP if_index and AdapterName.
 *
 *  RETURNS  pointer to a PIP_INTERFACE_INFO structure that has been allocated.
 *
 ******************************************************************************/

PIP_INTERFACE_INFO GetAdapterNameToIndexInfo( VOID )
{
    PIP_INTERFACE_INFO pInfo;
    ULONG              dwSize, dwError;

    dwSize = 0; pInfo = NULL;

    while( 1 ) {

        dwError = GetInterfaceInfo( pInfo, &dwSize );
        if( ERROR_INSUFFICIENT_BUFFER != dwError ) break;

        if( NULL != pInfo ) ReleaseMemory(pInfo);
        if( 0 == dwSize ) return NULL;

        pInfo = GrabMemory(dwSize);
        if( NULL == pInfo ) return NULL;

    }

    if(   ERROR_SUCCESS != dwError
       || NULL == pInfo
       || 0 == pInfo->NumAdapters ) {
        if( NULL != pInfo ) ReleaseMemory(pInfo);
        return NULL;
    }

    return pInfo;
}


/*******************************************************************************
 *
 *  GetAdapterInfo
 *
 *  Gets a list of all adapters to which TCP/IP is bound and reads the per-
 *  adapter information that we want to display. Most of the information now
 *  comes from the TCP/IP stack itself. In order to keep the 'short' names that
 *  exist in the registry to refer to the individual adapters, we read the names
 *  from the registry then match them to the adapters returned by TCP/IP by
 *  matching the IPInterfaceContext value with the adapter which owns the IP
 *  address with that context value
 *
 *  ENTRY   FixedInfo   - pointer to FIXED_INFO structure or NULL
 *
 *  EXIT    nothing
 *
 *  RETURNS pointer to linked list of ADAPTER_INFO structures
 *
 *  ASSUMES
 *
 ******************************************************************************/

PADAPTER_INFO
MyGetAdapterInfo (
    void
    )
{

    PADAPTER_INFO adapterList = NULL;
    PADAPTER_INFO adapter     = NULL;
    PIP_INTERFACE_INFO currentAdapterNames = NULL;
    LPSTR name = NULL;
    int i = 0;

    HKEY key;

    if (currentAdapterNames = GetAdapterNameToIndexInfo())
    {
        if (adapterList = GetAdapterList())
        {

            //
            // apply the short name to the right adapter info by comparing
            // the IPInterfaceContext value in the adapter\Parameters\Tcpip
            // section with the context values read from the stack for the
            // IP addresses
            //

            for (i = 0; i < currentAdapterNames->NumAdapters ; ++i)
            {
                ULONG  dwLength;
                DWORD  dwIfIndex = currentAdapterNames->Adapter[i].Index;

                TRACE_PRINT(("currentAdapterNames[%d]=%ws (if_index 0x%lx)\n",
                             i, currentAdapterNames->Adapter[i].Name, dwIfIndex ));

                //
                // now search through the list of adapters, looking for the one
                // that has the IP address with the same index value as that
                // just read. When found, apply the short name to that adapter
                //
                for (adapter = adapterList; adapter ; adapter = adapter->Next)
                {

                    if( adapter->Index == dwIfIndex )
                    {

                        dwLength = wcslen(currentAdapterNames->Adapter[i].Name) + 1 - strlen(TCPIP_DEVICE_PREFIX);
                        dwLength = wcstombs(adapter->AdapterName,
                            currentAdapterNames->Adapter[i].Name + strlen(TCPIP_DEVICE_PREFIX),
                            dwLength);
                        if( -1 == dwLength )
                        {
                            adapter->AdapterName[0] = '\0';
                        }

                        break;
                    }
                }
            }
        }
        else
        {
            DEBUG_PRINT(("GetAdapterInfo: GetAdapterInfo gave NULL\n"));

        }
        ReleaseMemory(currentAdapterNames);

        //
        // now get the other pieces of info from the registry for each adapter
        //

        FillInterfaceNames(adapterList);

        for (adapter = adapterList; adapter; adapter = adapter->Next) {

            TRACE_PRINT(("GetAdapterInfo: '%s'\n", adapter->AdapterName ));

            if (adapter->AdapterName[0] &&
                OpenAdapterKey(KEY_TCP, adapter->AdapterName, &key))
            {

                char dhcpServerAddress[4 * 4];
                DWORD addressLength;
                ULONG length;
                BOOL  ok;

                ReadRegistryDword(key,
                                  "EnableDHCP",
                                  &adapter->DhcpEnabled
                                  );

                TRACE_PRINT(("..'EnableDHCP' %d\n", adapter->DhcpEnabled ));

#ifdef DBG
                if ( uChangeMode )
                {
                    DWORD dwAutoconfigEnabled =
                        ( uChangeMode == SET_AUTO_MODE );

                    WriteRegistryDword(
                        key,
                        "IPAutoconfigurationEnabled",
                        &dwAutoconfigEnabled
                        );
                }
#endif

                if( ! ReadRegistryDword(key,
                                   "IPAutoconfigurationEnabled",
                                   &adapter->AutoconfigEnabled
                                   ) ) {

                    // AUTOCONFIG enabled if no regval exists for this...
                    adapter->AutoconfigEnabled = TRUE;

                    TRACE_PRINT(("..'IPAutoconfigurationEnabled'.. couldnt be read\n"));
                }

                TRACE_PRINT(("..'IPAutoconfigurationEnabled' %d\n",
                             adapter->AutoconfigEnabled ));


                if( adapter->AutoconfigEnabled ) {
                    ReadRegistryDword(key,
                                      "AddressType",
                                      &adapter->AutoconfigActive
                    );

                    TRACE_PRINT(("..'AddressType' ! %s\n",
                                 adapter->AutoconfigActive ));
                }

                if ( adapter->DhcpEnabled && !adapter->AutoconfigActive ) {
                    DWORD Temp;
                    ReadRegistryDword(key,
                                      "LeaseObtainedTime",
                                      &Temp
                                      );

                    adapter->LeaseObtained = Temp;
                    ReadRegistryDword(key,
                                      "LeaseTerminatesTime",
                                      &Temp
                                      );
                    adapter->LeaseExpires = Temp;
                }

                addressLength = sizeof( dhcpServerAddress );
                if (ReadRegistryString(key,
                                       "DhcpServer",
                                       dhcpServerAddress,
                                       &addressLength))
                {
                    AddIpAddressString(&adapter->DhcpServer,
                                       dhcpServerAddress,
                                       ""
                                       );
                }

                //
                // domain: first try Domain then DhcpDomain
                //

                length = sizeof(adapter->DomainName);
                ok = ReadRegistryOemString(key,
                                           L"Domain",
                                           adapter->DomainName,
                                           &length
                );
                if (!ok) {
                    length = sizeof(adapter->DomainName);
                    ok = ReadRegistryOemString(key,
                                               L"DhcpDomain",
                                               adapter->DomainName,
                                               &length
                    );
                }

                // DNS Server list.. first try NameServer and then try
                // DhcpNameServer..

                ok = ReadRegistryIpAddrString(key,
                                              "NameServer",
                                              &adapter->DnsServerList
                );
                if( ok ){
                    TRACE_PRINT(("GetFixedInfo: DhcpNameServer %s\n",
                                     adapter->DnsServerList ));
                }

                if (!ok) {
                    ok = ReadRegistryIpAddrString(key,
                                                  "DhcpNameServer",
                                                  &adapter->DnsServerList
                    );
                    if( ok ){
                        TRACE_PRINT(("GetFixedInfo: DhcpNameServer %s\n",
                                     adapter->DnsServerList ));
                    }
                }

                RegCloseKey(key);
            }else{
                DEBUG_PRINT(("Cannot OpenAdapterKey KEY_TCP '%s', gle=%d\n",
                             adapter->AdapterName, GetLastError() ));
            }

#if 0
            //
            // before getting the WINS info we must set the NodeType
            //

            if (FixedInfo) {
                adapter->NodeType = FixedInfo->NodeType;
            }
#endif

            //
            // get the info from the NetBT key - the WINS addresses
            //

            GetWinsServers(adapter);


        }
    } else {
        DEBUG_PRINT(("GetAdapterInfo: GetBoundAdapterList gave NULL\n"));
        adapterList = NULL;
    }

    TRACE_PRINT(("Exit GetAdapterInfo %p\n", adapterList ));

    return adapterList;
}

#ifdef DBG

BOOL WriteRegistryDword(HKEY hKey, LPSTR szParameter, DWORD *pdwValue )
{
    DWORD dwResult;

    TRACE_PRINT(("WriteRegistryDword: %s %d\n", szParameter, *pdwValue ));

    dwResult = RegSetValueEx(
                    hKey,
                    szParameter,
                    0,
                    REG_DWORD,
                    (CONST BYTE *) pdwValue,
                    sizeof( *pdwValue )
                    );

    return ( ERROR_SUCCESS == dwResult );
}

#endif

/*******************************************************************************
 *
 *  ReadRegistryString
 *
 *  Reads a registry value that is stored as a string
 *
 *  ENTRY   Key             - open registry key
 *          ParameterName   - name of value to read from registry
 *          String          - pointer to returned string
 *          Length          - IN: length of String buffer. OUT: length of returned string
 *
 *  EXIT    String contains string read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ReadRegistryString(HKEY Key, LPSTR ParameterName, LPSTR String, LPDWORD Length)
{

    LONG err;
    DWORD valueType;

    *String = '\0';
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)String,
                          Length
                          );

    if (err == ERROR_SUCCESS) {

        ASSERT(valueType == REG_SZ || valueType == REG_MULTI_SZ);

        DEBUG_PRINT(("ReadRegistryString(%s): val = \"%s\", type = %d, len = %d\n",
                    ParameterName,
                    String,
                    valueType,
                    *Length
                    ));

    } else {

        DEBUG_PRINT(("ReadRegistryString(%s): err = %d\n", ParameterName, err));

    }

    return ((err == ERROR_SUCCESS) && (*Length > sizeof(CHAR)));
}

/*******************************************************************************
 *
 *  ReadRegistryOemString
 *
 *  Reads a registry value as a wide character string
 *
 *  ENTRY   Key             - open registry key
 *          ParameterName   - name of value to read from registry
 *          String          - pointer to returned string
 *          Length          - IN: length of String buffer. OUT: length of returned string
 *
 *  EXIT    String contains string read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ReadRegistryOemString(HKEY Key, LPWSTR ParameterName, LPSTR String, LPDWORD Length)
{
    LONG err;
    LPBYTE Buffer;
    DWORD valueType = REG_SZ;
    DWORD valueLength = 0;

    //
    // first, get the length of the string
    //

    *String = '\0';
    err = RegQueryValueExW(Key,
                           ParameterName,
                           NULL, // reserved
                           &valueType,
                           NULL,
                           &valueLength
                           );
    if ((err == ERROR_SUCCESS) && (valueType == REG_SZ)) {
        if (valueLength > sizeof(L'\0')) {

            UNICODE_STRING unicodeString;
            OEM_STRING oemString;
            LPWSTR str = (LPWSTR)GrabMemory(valueLength);

            //
            // read the UNICODE string into allocated memory
            //

            err = RegQueryValueExW(Key,
                                   ParameterName,
                                   NULL,
                                   &valueType,
                                   (LPBYTE)str,
                                   &valueLength
                                   );
            if (err == ERROR_SUCCESS) {

                //
                // convert the UNICODE string to OEM character set
                //

                RtlInitUnicodeString(&unicodeString, str);
                RtlUnicodeStringToOemString(&oemString, &unicodeString, TRUE);
                if (!oemString.Buffer) {
                    err = !ERROR_SUCCESS;
                }
                else if( strlen(String)+1 <= *Length ) {
                    strcpy(String, oemString.Buffer);
                    err = ERROR_SUCCESS;

                    DEBUG_PRINT(("ReadRegistryOemString(%ws): val = \"%s\", len = %d\n",
                                 ParameterName,
                                 String,
                                 valueLength
                        ));

                } else {
                    err = !ERROR_SUCCESS;

                    DEBUG_PRINT(("ReadRegistryOemString(%ws): len = %d, buffer-len = %ld\n",
                                 ParameterName,
                                 valueLength,
                                 *Length
                        ));
                }

                RtlFreeOemString(&oemString);
            } else {

                DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                            ParameterName,
                            err,
                            valueType,
                            valueLength
                            ));

            }
            ReleaseMemory(str);
        } else {

            DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                        ParameterName,
                        err,
                        valueType,
                        valueLength
                        ));

            err = !ERROR_SUCCESS;
        }
    } else {

        DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                    ParameterName,
                    err,
                    valueType,
                    valueLength
                    ));

        err = !ERROR_SUCCESS;
    }
    return (err == ERROR_SUCCESS);
}

/*******************************************************************************
 *
 *  ReadRegistryIpAddrString
 *
 *  Reads zero or more IP addresses from a space-delimited string in a registry
 *  parameter and converts them to a list of IP_ADDR_STRINGs
 *
 *  ENTRY   Key             - registry key
 *          ParameterName   - name of value entry under Key to read from
 *          IpAddr          - pointer to IP_ADDR_STRING to update
 *
 *  EXIT    IpAddr updated if success
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ReadRegistryIpAddrString(HKEY Key, LPSTR ParameterName, PIP_ADDR_STRING IpAddr)
{

    LONG err;
    DWORD valueLength;
    DWORD valueType;
    LPBYTE valueBuffer;

    ASSERT( ParameterName);
    ASSERT( IpAddr);
    if (!ParameterName || !IpAddr)
    {
        return ERROR_INVALID_PARAMETER;
    }

    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          NULL,
                          &valueLength
                          );
    if ((err == ERROR_SUCCESS)) {
        if((valueLength > 1) && (valueType == REG_SZ)
           || (valueLength > 2) && (valueType == REG_MULTI_SZ) ) {
            valueBuffer = GrabMemory(valueLength);
            if (valueBuffer) {
                err = RegQueryValueEx(Key,
                                      ParameterName,
                                      NULL, // reserved
                                      &valueType,
                                      valueBuffer,
                                      &valueLength
                                     );
            }
            else {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }

            if ((err == ERROR_SUCCESS) && (valueLength > 1)) {

                LPSTR stringPointer = valueBuffer;
                LPSTR lastString;
                UINT i, stringCount;

                DEBUG_PRINT(("ReadRegistryIpAddrString(%s): \"%s\", len = %d\n",
                             ParameterName,
                             valueBuffer,
                             valueLength
                ));

                if( REG_SZ == valueType ) {
                    stringCount = 0;
                    lastString = stringPointer;
                    stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
                    while (stringPointer = strpbrk(stringPointer, STRING_ARRAY_DELIMITERS)) {
                        *stringPointer++ = '\0';
                        if(*lastString)
                        {
                            stringCount ++;
                            AddIpAddressString(IpAddr, lastString, "");
                        }
                        lastString = stringPointer;
                        stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
                    }
                    if(*lastString) {
                        stringCount ++;
                        AddIpAddressString(IpAddr, lastString, "");
                    }

                    if( 0 == stringCount ) err = ERROR_PATH_NOT_FOUND;
                } else if( REG_MULTI_SZ == valueType ) {
                    stringCount = 0;
                    while(strlen(stringPointer)) {
                        AddIpAddressString(IpAddr, stringPointer, "");
                        stringPointer += 1+strlen(stringPointer);
                        stringCount ++;
                    }
                    if( 0 == stringCount ) err = ERROR_PATH_NOT_FOUND;
                } else {
                    err = ERROR_PATH_NOT_FOUND;
                }
            } else {

                DEBUG_PRINT(("ReadRegistryIpAddrString(%s): err = %d, len = %d\n",
                             ParameterName,
                             err,
                             valueLength
                ));

                err = ERROR_PATH_NOT_FOUND;
            }
            ReleaseMemory(valueBuffer);
        } else {

            DEBUG_PRINT(("ReadRegistryIpAddrString(%s): err = %d, type = %d, len = %d\n",
                         ParameterName,
                         err,
                         valueType,
                         valueLength
            ));

            err = ERROR_PATH_NOT_FOUND;
        }
    }
    return (err == ERROR_SUCCESS);
}


/*******************************************************************************
 *
 *  GrabMemory
 *
 *  Allocates memory. Exits with a fatal error if LocalAlloc fails, since on NT
 *  I don't expect this ever to occur
 *
 *  ENTRY   size
 *              Number of bytes to allocate
 *
 *  EXIT
 *
 *  RETURNS pointer to allocated memory
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPVOID GrabMemory(DWORD size)
{

    LPVOID p;

    p = (LPVOID)LocalAlloc(LMEM_FIXED, size);
    return p;
}


void
print_IFEntry( char* message, struct IFEntry * s )
{
    int i;

    if(  message   ){
       DEBUG_PRINT(( "%s\n", message ));
    }
    if(  s == NULL ){
       DEBUG_PRINT(( "struct IFEntry is NULL.\n"));
       return;
    }
    DEBUG_PRINT(("struct IFEntry = {\n" ));
    DEBUG_PRINT(("  if_index        =   %d  \n", s->if_index ));
    DEBUG_PRINT(("  if_type         =   %d    ", s->if_type ));

#if 0
    switch( s->if_type ){
        case IF_TYPE_OTHER              : DEBUG_PRINT(("IF_TYPE_OTHER               ")); break;
        case IF_TYPE_ETHERNET_CSMACD    : DEBUG_PRINT(("IF_TYPE_ETHERNET_CSMACD     ")); break;
        case IF_TYPE_ISO88025_TOKENRING : DEBUG_PRINT(("IF_TYPE_ISO88025_TOKENRING  ")); break;
        case IF_TYPE_FDDI               : DEBUG_PRINT(("IF_TYPE_FDDI                ")); break;
        case IF_TYPE_PPP                : DEBUG_PRINT(("IF_TYPE_PPP                 ")); break;
        case IF_TYPE_SOFTWARE_LOOPBACK  : DEBUG_PRINT(("IF_TYPE_SOFTWARE_LOOPBACK   ")); break;
        case IF_TYPE_SLIP               : DEBUG_PRINT(("IF_TYPE_SLIP                ")); break;
    }
#endif
    DEBUG_PRINT(("\n"));

    DEBUG_PRINT(("  if_mtu             =   %d  \n", s->if_mtu ));
    DEBUG_PRINT(("  if_speed           =   %d  \n", s->if_speed ));
    DEBUG_PRINT(("  if_physaddrlen     =   %d  \n", s->if_physaddrlen ));
    DEBUG_PRINT(("  if_physaddr        =   " ));

    for( i = 0; i< MAX_PHYSADDR_SIZE; i++ ){
         DEBUG_PRINT(("%02x.", s->if_physaddr[i] ));
    }
    DEBUG_PRINT(("\n"));

    DEBUG_PRINT(("  if_adminstatus     = %d  \n", s->if_adminstatus ));
    DEBUG_PRINT(("  if_operstatus      = %d  \n", s->if_operstatus ));
    DEBUG_PRINT(("  if_lastchange      = %d  \n", s->if_lastchange ));
    DEBUG_PRINT(("  if_inoctets        = %d  \n", s->if_inoctets ));
    DEBUG_PRINT(("  if_inucastpkts     = %d  \n", s->if_inucastpkts ));
    DEBUG_PRINT(("  if_innucastpkts    = %d  \n", s->if_innucastpkts ));
    DEBUG_PRINT(("  if_indiscards      = %d  \n", s->if_indiscards ));
    DEBUG_PRINT(("  if_inerrors        = %d  \n", s->if_inerrors ));
    DEBUG_PRINT(("  if_inunknownprotos = %d \n", s->if_inunknownprotos ));
    DEBUG_PRINT(("  if_outoctets       = %d \n", s->if_outoctets ));
    DEBUG_PRINT(("  if_outucastpkts    = %d \n", s->if_outucastpkts ));
    DEBUG_PRINT(("  if_outnucastpkts   = %d \n", s->if_outnucastpkts ));
    DEBUG_PRINT(("  if_outdiscards     = %d \n", s->if_outdiscards ));
    DEBUG_PRINT(("  if_outerrors       = %d \n", s->if_outerrors ));
    DEBUG_PRINT(("  if_outqlen         = %d \n", s->if_outqlen ));
    DEBUG_PRINT(("  if_descrlen        = %d \n", s->if_descrlen ));
    DEBUG_PRINT(("  if_descr           = %s \n", s->if_descr ));
    DEBUG_PRINT(("}; // struct IFEntry.\n"));
    return;
} /* print_IFEntry */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled header for ipsink.ax

--*/

// Windows
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <memory.h>
#include <stdio.h>

// DShow
#include <streams.h>
#include <amstream.h>
#include <dvdmedia.h>

// DDraw
#include <ddraw.h>
#include <ddkernel.h>

// KS
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>

#include <atlbase.h>
#include <strmif.h>
#include <BdaIface.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\myconfig.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ipconfig.h

Abstract:

    Contains all includes, definitions, types, prototypes for ipconfig

Author:

    Richard L Firth (rfirth) 20-May-1994

Revision History:

    20-May-1994 rfirth        Created
    20-May-97   MohsinA       NT50 PNP.
    31-Jul-97   MohsinA       Patterns.

--*/

#ifndef _IPCONGIG_H_
#define _IPCONGIG_H_ 1

typedef unsigned int UINT, *PUINT;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>
#include <malloc.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddtcp.h>
#include <ntddip.h>
#include <winerror.h>
#include <winsock.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <llinfo.h>
#include <ipinfo.h>
#include <ipexport.h>
#include <wscntl.h>
#include <assert.h>
#include <objbase.h>
#include <initguid.h>
#include <dnsapi.h>
#include <nhapi.h>
#include <iprtrmib.h>
#include <iptypes.h>

#include "debug.h"

#undef tolower

//
// manifests
//

//#define MAX_ADAPTER_DESCRIPTION_LENGTH  255   // arb.
//#define MAX_ADAPTER_NAME_LENGTH         2000  // arb.
//#define MAX_ALLOWED_ADAPTER_NAME_LENGTH (MAX_ADAPTER_NAME_LENGTH + 256)
//#define MAX_ADAPTER_ADDRESS_LENGTH      256  // arb.
//#define DEFAULT_MINIMUM_ENTITIES        MAX_TDI_ENTITIES // arb.
//#define MAX_HOSTNAME_LEN                256 // arb.
//#define MAX_DOMAIN_NAME_LEN             256 // arb.
//#define MAX_SCOPE_ID_LEN                64  // arb.

#define STRLEN      strlen
#define STRICMP     _stricmp
#define STRNICMP    _strnicmp

#define NODE_TYPE_BROADCAST             1
#define NODE_TYPE_PEER_PEER             2
#define NODE_TYPE_MIXED                 4
#define NODE_TYPE_HYBRID                8

//
// macros
//

#define NEW(thing)  (thing *)calloc(1, sizeof(thing))

//
// IS_INTERESTING_ADAPTER - TRUE if the type of this adapter (IFEntry) is NOT
// loopback. Loopback (corresponding to local host) is the only one we filter
// out right now
//

#define IS_INTERESTING_ADAPTER(p)   (!((p)->if_type == IF_TYPE_SOFTWARE_LOOPBACK))

//
// types
//

#ifndef _AVOID_IP_ADDRESS
//
// IP_ADDR - access an IP address as a single DWORD or 4 BYTEs
//

typedef union {
    DWORD  d;
    BYTE   b[4];
} IP_ADDR, *PIP_ADDR, IP_MASK, *PIP_MASK;
#endif // _AVOID_IP_ADDRESS

//
// IP_ADDRESS_STRING - store an IP address as a dotted decimal string
//

//typedef struct {
//    char String[4 * 4];
//} IP_ADDRESS_STRING, *PIP_ADDRESS_STRING, IP_MASK_STRING, *PIP_MASK_STRING;

//
// IP_ADDR_STRING - store an IP address with its corresponding subnet mask,
// both as dotted decimal strings
//

//typedef struct _IP_ADDR_STRING {
//    struct _IP_ADDR_STRING* Next;
//    IP_ADDRESS_STRING       IpAddress;
//    IP_MASK_STRING          IpMask;
//    DWORD                   Context;
//} IP_ADDR_STRING, *PIP_ADDR_STRING;

//
// ADAPTER_INFO - per-adapter information. All IP addresses are stored as
// strings
//

typedef struct _ADAPTER_INFO {
    struct _ADAPTER_INFO* Next;
    char AdapterName[MAX_ADAPTER_NAME_LENGTH + 1];
    char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
    UINT AddressLength;
    BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
    UINT Index;
    GUID InterfaceGuid;
    UINT Type;
    UINT DhcpEnabled;
    UINT AutoconfigEnabled;     // is autoconfiguration possible?
    UINT AutoconfigActive;      // is the adapter currently autoconfigured?
    UINT NodeType;
    UINT NetbiosEnabled;
    IP_ADDR_STRING IpAddressList;
    IP_ADDR_STRING GatewayList;
    IP_ADDR_STRING DhcpServer;
    BOOL HaveWins;
    IP_ADDR_STRING PrimaryWinsServer;
    IP_ADDR_STRING SecondaryWinsServer;
    time_t LeaseObtained;
    time_t LeaseExpires;
    char DomainName[MAX_DOMAIN_NAME_LEN + 1];
    IP_ADDR_STRING DnsServerList;
} ADAPTER_INFO, *PADAPTER_INFO;

//
// FIXED_INFO - the set of IP-related information which does not depend on DHCP
//

//typedef struct {
//    char HostName[MAX_HOSTNAME_LEN + 1];
//    UINT NodeType;
//    char ScopeId[MAX_SCOPE_ID_LEN + 1];
//    UINT EnableRouting;
//    UINT EnableProxy;
//    UINT EnableDns;
//} FIXED_INFO, *PFIXED_INFO;

//
// DHCP_ADAPTER_INFO - the information returned from DHCP VxD per adapter
//

typedef struct {
    DWORD LeaseObtained;
    DWORD LeaseExpires;
    DWORD DhcpServerIpAddress;
    UINT  NumberOfDnsServers;
    DWORD DnsServerIpAddressList[];
#if 0
    // Dont know why these two are not here... but i'm not messing around.. -RameshV
    char DomainName[MAX_DOMAIN_NAME_LEN + 1];
    IP_ADDR_STRING DnsServerList;
#endif
} DHCP_ADAPTER_INFO, *PDHCP_ADAPTER_INFO;

//
// PHYSICAL_ADAPTER_ADDRESS - structure describing physical adapter
//

typedef struct {
    UINT    AddressLength;
    BYTE    Address[MAX_ADAPTER_ADDRESS_LENGTH];
} PHYSICAL_ADAPTER_ADDRESS, *PPHYSICAL_ADAPTER_ADDRESS;

//
// DHCP_ADAPTER_LIST - list of physical adapters known to DHCP, and therefore
// DHCP-enabled
//

typedef struct {
    UINT                     NumberOfAdapters;
    PHYSICAL_ADAPTER_ADDRESS AdapterList[];
} DHCP_ADAPTER_LIST, *PDHCP_ADAPTER_LIST;

//
// prototypes
//

//
// From ipconfig.c
//

int match( const char * p, const char * s );
LPSTR GetStdErrorString(DWORD status);
LPSTR MapAdapterNameToGuid(LPSTR AdapterName);
LPSTR MapAdapterGuidToName(LPSTR AdapterGuid);



//
// From entity.c
//

TDIEntityID* GetEntityList(UINT*);

//
// From adaptlst.c
//

PADAPTER_INFO GetAdapterList(          void                                );
int           AddIpAddress(            PIP_ADDR_STRING, DWORD, DWORD, DWORD);
int           AddIpAddressString(      PIP_ADDR_STRING, LPSTR, LPSTR       );
VOID          ConvertIpAddressToString(DWORD, LPSTR                        );
VOID          CopyString(              LPSTR, DWORD, LPSTR                 );

DWORD
FillInterfaceNames(
    IN OUT  PADAPTER_INFO   pAdapterList
    );

//
// From wins.c
//

BOOL GetWinsServers(PADAPTER_INFO);


//
// In debug.c
//

#ifdef DBG

void print_IP_ADDRESS_STRING( char* message, IP_ADDRESS_STRING * s );
void print__IP_ADDR_STRING( char* message, PIP_ADDR_STRING s );
void print__ADAPTER_INFO( char* message,  ADAPTER_INFO * s );
void print_FIXED_INFO( char* message, FIXED_INFO * s );
void print_DHCP_ADAPTER_INFO( char* message, DHCP_ADAPTER_INFO * s );
void print_PHYSICAL_ADAPTER_ADDRESS( char* message, PHYSICAL_ADAPTER_ADDRESS * s );
void print_DHCP_ADAPTER_LIST( char* message, DHCP_ADAPTER_LIST * s );
void print_IFEntry( char* message, struct IFEntry * s );

#endif

//
// defined in IPHLPAPI.H -- but can't include that because of clash of
// definitions
// of IP_ADDR_STRING etc (in iptypes.h which is included by iphlpapi.h ).
//
DWORD
WINAPI
GetInterfaceInfo(
    IN PIP_INTERFACE_INFO pIfTable,
    OUT PULONG            dwOutBufLen
    );


//
// Have to do this thing of defining these functions here instead of
// including iphlpapi.h, because someone messed up and named two different
// CONFLICTING structures IP_ADDR_STRING. Whats wrong with people?
//

DWORD
NhpAllocateAndGetInterfaceInfoFromStack(
    OUT IP_INTERFACE_NAME_INFO  **ppTable,
    OUT PDWORD                  pdwCount,
    IN  BOOL                    bOrder,
    IN  HANDLE                  hHeap,
    IN  DWORD                   dwFlags
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\precomp.h ===
#include "myconfig.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
FAR PASCAL
WsControl(
	DWORD	Protocol,
	DWORD	Action,
	LPVOID	InputBuffer,
	LPDWORD	InputBufferLength,
	LPVOID	OutputBuffer,
	LPDWORD	OutputBufferLength
	);

typedef DWORD (FAR PASCAL * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  TCP/IP action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001
#define WSCNTL_TCPIP_ICMP_ECHO				0x00000002


#endif	// _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\wins.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wins.c

Abstract:

    Functions to retrieve info from NetBT device driver

    Contents:
        GetWinsServers

Author:

    Richard L Firth (rfirth) 6-Aug-1994

Revision History:

    rfirth 6-Aug-1994
        Created

--*/

#include "precomp.h"
#include <nbtioctl.h>

//
// seems that if WINS addresses not specified, NetBT reports 127.0.0.0 so if
// this value is returned, we won't display them
//

#define LOCAL_WINS_ADDRESS  0x0000007f  // 127.0.0.0

#define BYTE_SWAP(w)    (HIBYTE(w) | (LOBYTE(w) << 8))
#define WORD_SWAP(d)    (BYTE_SWAP(HIWORD(d)) | (BYTE_SWAP(LOWORD(d)) << 16))

/*******************************************************************************
 *
 *  GetWinsServers
 *
 *  Gets the primary and secondary WINS addresses for a particular adapter from
 *  NetBT
 *
 *  ENTRY   AdapterInfo - pointer to ADAPTER_INFO
 *
 *  EXIT    AdapterInfo.PrimaryWinsServer and AdapterInfo.SecondaryWinsServer
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES 1.
 *          2. We have already got the Node Type for this adapter
 *
 ******************************************************************************/

BOOL GetWinsServers(PADAPTER_INFO AdapterInfo)
{

    HANDLE h;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK iosb;
    STRING name;
    UNICODE_STRING uname;
    NTSTATUS status;
    DWORD winsAddresses[2];
    tWINS_NODE_INFO NodeInfo;    
    char path[MAX_PATH];

    //
    // default the 'have WINS' status of this adapter
    //

    AdapterInfo->HaveWins = FALSE;

    //
    // BUGBUG - should this string be in the registry?
    //

    strcpy(path, "\\Device\\NetBT_Tcpip_");
    strcat(path, AdapterInfo->AdapterName);

    RtlInitString(&name, path);
    RtlAnsiStringToUnicodeString(&uname, &name, TRUE);

    InitializeObjectAttributes(
        &objAttr,
        &uname,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        (PSECURITY_DESCRIPTOR)NULL
        );

    status = NtCreateFile(&h,
                          SYNCHRONIZE | GENERIC_EXECUTE,
                          &objAttr,
                          &iosb,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0
                          );

    RtlFreeUnicodeString(&uname);

    if (!NT_SUCCESS(status)) {
        DEBUG_PRINT(("GetWinsServers: NtCreateFile(path=%s) failed, err=%d\n",
                     path, GetLastError() ));
        return FALSE;
    }

#if 0
    status = NtDeviceIoControlFile(h,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &iosb,
                                   IOCTL_NETBT_GET_WINS_ADDR,
                                   NULL,
                                   0,
                                   (PVOID)winsAddresses,
                                   sizeof(winsAddresses)
                                   );
#else
    status = NtDeviceIoControlFile(h,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &iosb,
                                   IOCTL_NETBT_GET_WINS_ADDR,
                                   NULL,
                                   0,
                                   (PVOID)&NodeInfo,
                                   sizeof(NodeInfo)
                                   );
#endif
    
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(h, TRUE, NULL);
        if (NT_SUCCESS(status)) {
            status = iosb.Status;
        }
    }

    NtClose(h);

    if (!NT_SUCCESS(status)) {
        DEBUG_PRINT(("GetWinsServers: NtDeviceIoControlFile failed, err=%d\n",
                     GetLastError() ));

        return FALSE;
    }

    //
    // for some reason, NetBT returns the addresses in low-byte order. We have
    // to swap them
    //

#if 0
    winsAddresses[0] = WORD_SWAP(winsAddresses[0]);
    winsAddresses[1] = WORD_SWAP(winsAddresses[1]);
#else
    winsAddresses[0] = WORD_SWAP(NodeInfo.NameServerAddress);
    winsAddresses[1] = WORD_SWAP(NodeInfo.BackupServer);
#endif
    
    DEBUG_PRINT(("GetWinsServers: Primary Address = %d.%d.%d.%d\n",
                ((LPBYTE)&winsAddresses[0])[0],
                ((LPBYTE)&winsAddresses[0])[1],
                ((LPBYTE)&winsAddresses[0])[2],
                ((LPBYTE)&winsAddresses[0])[3]
                ));

    DEBUG_PRINT(("GetWinsServers: Secondary Address = %d.%d.%d.%d\n",
                ((LPBYTE)&winsAddresses[1])[0],
                ((LPBYTE)&winsAddresses[1])[1],
                ((LPBYTE)&winsAddresses[1])[2],
                ((LPBYTE)&winsAddresses[1])[3]
                ));

    //
    // if we get 127.0.0.0 back then convert it to the NULL address. See
    // ASSUMES in function header
    //

    if (winsAddresses[0] == LOCAL_WINS_ADDRESS) {
        winsAddresses[0] = 0;
    } else {
        AdapterInfo->HaveWins = TRUE;
    }
    AddIpAddress(&AdapterInfo->PrimaryWinsServer,
                 winsAddresses[0],
                 0,
                 0
                 );

    //
    // same with secondary
    //

    if (winsAddresses[1] == LOCAL_WINS_ADDRESS) {
        winsAddresses[1] = 0;
    } else {
        AdapterInfo->HaveWins = TRUE;
    }
    AddIpAddress(&AdapterInfo->SecondaryWinsServer,
                 winsAddresses[1],
                 0,
                 0
                 );

#if 0
#else
/*
    {
        int i;

        for( i = 0; i < NodeInfo.NumOtherServers ; i ++ ) {
            NodeInfo.Others[i] = WORD_SWAP(NodeInfo.Others[i]);
            if( NodeInfo.Others[i] != LOCAL_WINS_ADDRESS
                && NodeInfo.Others[i] != 0 ) {
                AdapterInfo->HaveWins = TRUE;
                AddIpAddress(
                    &AdapterInfo->SecondaryWinsServer,
                    NodeInfo.Others[i],
                    0, 0
                    );
            }
        }
    }
    */
    AdapterInfo->NodeType = NodeInfo.NodeType;
    
#endif
    AdapterInfo->NetbiosEnabled = NodeInfo.NetbiosEnabled;
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ipsink\wsctrl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wsctrl.c

Abstract:

    Functions to talk to TCP/IP device driver

    Contents:
        WsControl

Author:

    Richard L Firth (rfirth) 6-Aug-1994

Revision History:

    rfirth 6-Aug-1994
        Created

--*/

#include "precomp.h"
#pragma hdrstop

HANDLE TcpipDriverHandle = INVALID_HANDLE_VALUE;

/*******************************************************************************
 *
 *  WsControl
 *
 *  ENTRY   Protocol            - ignored
 *          Request             - ignored
 *          InputBuffer         - pointer to request buffer
 *          InputBufferLength   - pointer to DWORD: IN = request buffer length
 *          OutputBuffer        - pointer to output buffer
 *          OutputBufferLength  - pointer to DWORD: IN = length of output buffer;
 *                                OUT = length of returned data
 *
 *  EXIT    OutputBuffer - contains queried info if successful
 *          OutputBufferLength - contains number of bytes in OutputBuffer if
 *          successful
 *
 *  RETURNS Success = STATUS_SUCCESS/NO_ERROR
 *          Failure = Win32 error code
 *
 *  ASSUMES
 *
 ******************************************************************************/

DWORD
WINAPI
WsControl(
    DWORD   Protocol,
    DWORD   Request,
    LPVOID  InputBuffer,
    LPDWORD InputBufferLength,
    LPVOID  OutputBuffer,
    LPDWORD OutputBufferLength
)
{

    BOOL ok;
    DWORD bytesReturned;

    UNREFERENCED_PARAMETER(Protocol);
    UNREFERENCED_PARAMETER(Request);

    if (TcpipDriverHandle == INVALID_HANDLE_VALUE) {

        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK iosb;
        UNICODE_STRING string;
        NTSTATUS status;

        RtlInitUnicodeString(&string, DD_TCP_DEVICE_NAME);

        InitializeObjectAttributes(&objectAttributes,
                                   &string,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                   );
        status = NtCreateFile(&TcpipDriverHandle,
                              SYNCHRONIZE | GENERIC_EXECUTE,
                              &objectAttributes,
                              &iosb,
                              NULL,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN_IF,
                              FILE_SYNCHRONOUS_IO_NONALERT,
                              NULL,
                              0
                              );
        if (!NT_SUCCESS(status)) {
            return RtlNtStatusToDosError(status);
        }
    }

    ok = DeviceIoControl(TcpipDriverHandle,
                         IOCTL_TCP_QUERY_INFORMATION_EX,
                         InputBuffer,
                         *InputBufferLength,
                         OutputBuffer,
                         *OutputBufferLength,
                         &bytesReturned,
                         NULL
                         );
    if (!ok) {
        *OutputBufferLength = bytesReturned;
        return GetLastError();
    }

    *OutputBufferLength = bytesReturned;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksbasaud\ksbasaud.h ===
//--------------------------------------------------------------------------;
//
//  File: ksbasaud.h
//
//  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//      Header for KsProxy audio interface handler for hardware decoders
//      
//  History:
//      11/08/99    glenne     created
//
//--------------------------------------------------------------------------;

//
// Interface Handler class for filter
//
class CKsIBasicAudioInterfaceHandler :
    public CBasicAudio,
    public IDistributorNotify
{

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CKsIBasicAudioInterfaceHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    ~CKsIBasicAudioInterfaceHandler();

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);
    
protected:

    // IDistributorNotify
    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tBase);
    STDMETHODIMP NotifyGraphChange();

    // Implement IBasicAudio
    STDMETHODIMP put_Volume (IN  long   lVolume);
    STDMETHODIMP get_Volume (OUT long *plVolume);
    STDMETHODIMP put_Balance(IN  long   lVolume);
    STDMETHODIMP get_Balance(OUT long *plVolume);


private:
    bool IsVolumeControlSupported();
    bool KsControl(
        DWORD dwIoControl,
        PVOID pvIn,    ULONG cbIn,
        PVOID pvOut,   ULONG cbOut );
    template <class T, class S>
        bool KsControl( DWORD dwIoControl, T* pIn, S* pOut )
            { return KsControl( dwIoControl, pIn, sizeof(*pIn), pOut, sizeof(*pOut) ); }

private:
    bool    m_fIsVolumeSupported;
    IBaseFilter*    m_pFilter;
    HANDLE  m_hKsObject;
    LONG    m_lBalance;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksbasaud\ksbasaud.cpp ===
//--------------------------------------------------------------------------;
//
//  File: ksbasaud.cpp
//
//  Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//      Implements a DirectShow audio interface wrapper for KsProxy audio filters.
//      This file contains the startup code for the class plus the non interface-specific
//      code needed to implement the wrapper. This handler object code 
//      is instantiated via ksproxy's handler mechanism for ks filters and pins 
//      that support the static aggregates tagged in the g_Templates structure.
//      
//  History:
//      11/09/99    glenne     created
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "ksbasaud.h"
#include <initguid.h>
#include <math.h>

// struct DECLSPEC_UUID("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d") CLSID_KsIBasicAudioInterfaceHandler;

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//

#ifdef FILTER_DLL

static CFactoryTemplate g_Templates[] = 
{
    {L"KsIBasicAudioInterfaceHandler",  &CLSID_KsIBasicAudioInterfaceHandler, CKsIBasicAudioInterfaceHandler::CreateInstance, NULL, NULL}
};

static int g_cTemplates = SIZEOF_ARRAY(g_Templates);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


#define DBG_LEVEL_TRACE_DETAILS 2
#define DBG_LEVEL_TRACE_FAILURES 1

// General purpose functions to convert from decibels to 
// amplitude and vice versa as well as symbolic consts

#define MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL 0xFFFFUL

// This function is passed a value that is in decibels
//  Maps -10000 to 0 decibels to 0x0000 to 0xffff linear
// 
static ULONG DBToAmplitude( LONG lDB )
{
    double dAF;

    if (0 <= lDB)
        return MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL;

    // input lDB is 100ths of decibels

    dAF = pow(10.0, (0.5+((double)lDB))/2000.0);

    // This gives me a number in the range 0-1
    // normalise to 0-MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL

    return (DWORD)(dAF*MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL);
}

static long AmplitudeToDB( long dwFactor )
{
    if (1>=dwFactor) {
	    return -10000;
    } else if (MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL <= dwFactor) {
	    return 0;	// This puts an upper bound - no amplification
    } else {
	    return (LONG)(2000.0 * log10((-0.5+(double)dwFactor)/double(MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL)));
    }
}


// Bounds a value between 2 others ...
static void bound(
    LONG *plValToBound, 
    const LONG dwLowerBound, 
    const LONG dwUpperBound
    )
{
    if (*plValToBound < dwLowerBound) {
        *plValToBound = dwLowerBound;
    } else if (*plValToBound > dwUpperBound) {
        *plValToBound = dwUpperBound;
    }
}


//
// GUID for this KsBasicAudioIntfHandler object
// {B9F8AC3E-0F71-11d2-B72C-00C04FB6BD3D}
// DEFINE_GUID(CLSID_KsIBasicAudioInterfaceHandler, 
// 0xb9f8ac3e, 0xf71, 0x11d2, 0xb7, 0x2c, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d);

#if 0
// #ifdef FILTER_DLL
//--------------------------------------------------------------------------;
//
// templates for classes supported by this DLL
//
//--------------------------------------------------------------------------;
CFactoryTemplate g_Templates[] = 
{
    // Load for filters that support it
    {L"KsIBasicAudioInterfaceHandler",                   &CLSID_KsIBasicAudioInterfaceHandler, 
        CKsIBasicAudioInterfaceHandler::CreateInstance, NULL, NULL},

};

static int g_cTemplates = SIZEOF_ARRAY(g_Templates);

#endif  // #if 0

//--------------------------------------------------------------------------;
//
// CDvdKsInftHandler::CreateInstance
//
// Create an instance of this audio interface handler for KsProxy.
//
// Returns a pointer to the non-delegating CUnknown portion of the object.
//
//--------------------------------------------------------------------------;
CUnknown* CALLBACK CKsIBasicAudioInterfaceHandler::CreateInstance ( LPUNKNOWN UnkOuter, HRESULT* phr )
{
    CUnknown *Unknown = NULL;

    if( !UnkOuter )
        return NULL;
        
    if( SUCCEEDED( *phr ) ) 
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT( "CKsIBasicAudioInterfaceHandler::CreateInstance called on object 0x%08lx" )
                , UnkOuter ) );
        //
        // first determine if we're being called for a filter or pin object
        //
        IBaseFilter * pFilter;
        *phr = UnkOuter->QueryInterface(
                                IID_IBaseFilter, 
                                reinterpret_cast<PVOID*>(&pFilter));
        if (SUCCEEDED( *phr ) ) {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "CKsIBasicAudioInterfaceHandler: load called on filter object" ) ) );
            //
            // if we're being called on a filter object, always create a new handler
            //
            Unknown = new CKsIBasicAudioInterfaceHandler( UnkOuter
                                            , NAME("DvdKs intf handler")
                                            , phr);
            if (!Unknown) {
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_FAILURES
                        , TEXT( "CKsIBasicAudioInterfaceHandler: ERROR - Load failed on filter object" ) ) );
                *phr = E_OUTOFMEMORY;
            }
            pFilter->Release();
        }
    } else {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "CKsIBasicAudioInterfaceHandler::CreateInstance called on NULL object" ) ) );
        *phr = E_FAIL;
    }
    return Unknown;
} 

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// Filter Handler methods
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CDvdKsInftHandler::CKsIBasicAudioInterfaceHandler
//
// The constructor for the DShow/KsProxy audio interface object. Save off 
// the IKsControl & IKsPropertySet ptrs for this object.
//
//--------------------------------------------------------------------------;
CKsIBasicAudioInterfaceHandler::CKsIBasicAudioInterfaceHandler( LPUNKNOWN UnkOuter, TCHAR* Name, HRESULT* phr )
: CBasicAudio(Name, UnkOuter)
, m_lBalance( 0 )
, m_hKsObject( 0 )
, m_fIsVolumeSupported( false ) // updated on first graph change
{
    if (UnkOuter) {
        IKsObject *pKsObject;
        //
        // The parent must support the IKsObject interface in order to obtain
        // the handle to communicate to
        //
        *phr = UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&pKsObject));
        if (SUCCEEDED(*phr)) {
            m_hKsObject = pKsObject->KsGetObjectHandle();
            ASSERT(m_hKsObject != NULL);

            *phr = UnkOuter->QueryInterface(IID_IBaseFilter, reinterpret_cast<PVOID*>(&m_pFilter));
            if (SUCCEEDED(*phr) ) {
                DbgLog((LOG_TRACE, 0, TEXT("IPin interface of pOuter is 0x%lx"), m_pFilter));
                //
                // Holding this ref count will prevent the proxy ever being destroyed
                //
                //  We're part of the parent, so the count is ok
                //
                m_pFilter->Release();
            }
            pKsObject->Release();
        }
    } else {
        *phr = VFW_E_NEED_OWNER;
    }
}

//--------------------------------------------------------------------------;
//
// CDvdKsInftHandler::~CKsIBasicAudioInterfaceHandler
//
//--------------------------------------------------------------------------;
CKsIBasicAudioInterfaceHandler::~CKsIBasicAudioInterfaceHandler()
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "CKsIBasicAudioInterfaceHandler destructor called" ) ) ); // save off constructor UnkOuter for logging?
}

//--------------------------------------------------------------------------;
//
// CDvdKsInftHandler::NonDelegationQueryInterface
//
// We support:
// 
// IBasicAudio         - basic output audio level and pan control, supported on filter and midi/wav audio input pins
// IDistributorNotify  - this is how ksproxy notifies of changes like pin creation, disconnects...
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::NonDelegatingQueryInterface
(
    REFIID  riid,
    PVOID*  ppv
)
{
    if (riid ==  IID_IBasicAudio) {
        return GetInterface(static_cast<IBasicAudio*>(this), ppv);
    }
    else if (riid == IID_IDistributorNotify) {
        return GetInterface(static_cast<IDistributorNotify*>(this), ppv);
    }
    
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


//--------------------------------------------------------------------------;
//
// IDistributorNotify methods (filter)
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CKsIBasicAudioInterfaceHandler::SetSyncSouce
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::SetSyncSource(IReferenceClock *pClock) 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CKsIBasicAudioInterfaceHandler::Stop
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::Stop() 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CKsIBasicAudioInterfaceHandler::Pause
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::Pause() 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CKsIBasicAudioInterfaceHandler::Run
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::Run(REFERENCE_TIME tBase) 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CKsIBasicAudioInterfaceHandler::NotifyGraphChange 
//
// This method will be called:
//
//  a) On the initial load of a ksproxy audio filter just after the filter pins have been
//     created. This will allow us to load a pin interface handler for any control input
//     pins that the filter supports, the cd audio, mic, and line input lines for example.
//     Pins of this type must support the IAMAudioInputMixer interface to allow DShow capture
//     apps to control the input mix level.
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::NotifyGraphChange() 
{
    HRESULT hr;
    IKsObject *pKsObject;

    ASSERT(m_pFilter != NULL);

    hr = m_pFilter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&pKsObject));
    if (SUCCEEDED(hr)) {
        m_hKsObject = pKsObject->KsGetObjectHandle();

        pKsObject->Release();
        //
        // Re-enable the event on a reconnect, else ignore on a disconnect.
        //
        if (m_hKsObject) {
            m_fIsVolumeSupported = IsVolumeControlSupported();
            if( m_fIsVolumeSupported ) {
                put_Balance( m_lBalance );
            } else {
#ifdef _DEBUG
                MessageBox(NULL, TEXT("Volume control enabled on non-supported device"), TEXT("Failed"), MB_OK);
#endif
            }
        }
    }
    return hr;
}


bool CKsIBasicAudioInterfaceHandler::KsControl(
    DWORD dwIoControl,
    PVOID pvIn,  ULONG cbIn,
    PVOID pvOut, ULONG cbOut )
{
    if(!m_hKsObject){
        return false;
    }

   OVERLAPPED ov;

   RtlZeroMemory( &ov, sizeof(OVERLAPPED));
   if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ))){
      return false ;
   }

   DWORD cbReturned;
   bool fResult = (0 != DeviceIoControl( m_hKsObject,
                       dwIoControl,
                       pvIn, cbIn,
                       pvOut, cbOut,
                       &cbReturned,
                       &ov )) ;


   if (!fResult){
      if (ERROR_IO_PENDING == GetLastError()){
         WaitForSingleObject(ov.hEvent, INFINITE) ;
         fResult = true ;
      } else {
         fResult = false ;
      }
   }

   CloseHandle(ov.hEvent) ;
   return fResult;
}

bool CKsIBasicAudioInterfaceHandler::IsVolumeControlSupported()
// Returns true if the handle to the pin supports volume changes
// and false if not
{             
    KSPROPERTY KsProperty;
    KSWAVE_VOLUME Volume;

    KsProperty.Set = KSPROPSETID_Wave;
    KsProperty.Id = KSPROPERTY_WAVE_VOLUME;
    KsProperty.Flags = KSPROPERTY_TYPE_GET;

    // Just try to get the volume and see if it succeeds.
    return KsControl( IOCTL_KS_PROPERTY, &KsProperty, &Volume );
}

static void Debug_NoImplMessage()
{
#ifdef DEBUG
     MessageBox(NULL, TEXT("KsIBasicAudio Enumalator working, but device doesn't support it"), TEXT("Failed"), MB_OK);
#endif
}

STDMETHODIMP 
CKsIBasicAudioInterfaceHandler::get_Volume( long *plVolume )
{
    if( !m_fIsVolumeSupported ) {
        Debug_NoImplMessage();
        return E_NOTIMPL;
    }
    KSPROPERTY KsProperty;
    KSWAVE_VOLUME KsWaveVolume;
    int nRes;
    
    KsProperty.Set = KSPROPSETID_Wave;
    KsProperty.Id = KSPROPERTY_WAVE_VOLUME;
    KsProperty.Flags = KSPROPERTY_TYPE_GET;

    bool fIOCallResult = KsControl( IOCTL_KS_PROPERTY, &KsProperty, &KsWaveVolume );

    if (fIOCallResult == false ){
        return E_FAIL; // unspecified failure -- for now
    }

    // this is the volume we return -- the larger of the 2 speaker values. 
    LONG lLeftDB = AmplitudeToDB(KsWaveVolume.LeftAttenuation);
    LONG lRightDB = AmplitudeToDB(KsWaveVolume.RightAttenuation);

    *plVolume = max( lLeftDB, lRightDB );

    m_lBalance = lRightDB - lLeftDB;
    return NOERROR;
}

STDMETHODIMP 
CKsIBasicAudioInterfaceHandler::put_Volume( long lVolume )
{
    if( !m_fIsVolumeSupported ) {
        Debug_NoImplMessage();
        return E_NOTIMPL;
    }
    // This will be a DeviceIoControl put property call.
    KSPROPERTY KsProperty;
    KSWAVE_VOLUME KsWaveVolume;
    int nRes;
    BOOL bIOCallResult;

    LONG lLeftDB, lRightDB;
    if (m_lBalance >= 0) {
        // left is attenuated
        lLeftDB    = lVolume - m_lBalance ;
        lRightDB   = lVolume;
    } else {
        // right is attenuated
        lLeftDB    = lVolume;
        lRightDB   = lVolume - (-m_lBalance);
    }


    // These values should be attenuation values wrt reference volume and balance
    // We should remember to bound them ...
    KsWaveVolume.LeftAttenuation  = DBToAmplitude( lLeftDB );
    KsWaveVolume.RightAttenuation = DBToAmplitude( lRightDB );

    KsProperty.Set = KSPROPSETID_Wave;
    KsProperty.Id = KSPROPERTY_WAVE_VOLUME;
    KsProperty.Flags = KSPROPERTY_TYPE_SET;

    bIOCallResult = KsControl( IOCTL_KS_PROPERTY, &KsProperty, &KsWaveVolume );

    if (bIOCallResult == FALSE){
        return E_FAIL;   // unspecified failure -- for now
    }
    //  ODS("CKSProxy::put_Volume %ld %ld", lVolume, 0);
    return NOERROR;
}

STDMETHODIMP 
CKsIBasicAudioInterfaceHandler::get_Balance( long *plBalance ) 
{ 
    if( !m_fIsVolumeSupported ) {
        Debug_NoImplMessage();
        return E_NOTIMPL;
    }
    long lVol;
    HRESULT hr = get_Volume(&lVol);
    if (SUCCEEDED(hr)){
        *plBalance = m_lBalance; // that's really it.
    }
    return hr; 
}

STDMETHODIMP 
CKsIBasicAudioInterfaceHandler::put_Balance( long lBalance )   
{ 
    if( !m_fIsVolumeSupported ) {
        Debug_NoImplMessage();
        return E_NOTIMPL;
    }
    LONG lVol;
    get_Volume(&lVol);              // get the present volume 

    m_lBalance = lBalance; // set the desired balance 
    // set the volume, so that 
    //      a. The present volume doesn't change.
    //      b. We get a new balance as required.
    return put_Volume(lVol);                
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksclockf\ksclockf.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksclockf.cpp

Abstract:

    Provides an object interface to query, and a method to forward AM clocks.

--*/

#include <windows.h>
#include <streams.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include "ksclockf.h"

struct DECLSPEC_UUID("877e4352-6fea-11d0-b863-00aa00a216a1") IKsClock;

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
struct DECLSPEC_UUID("877e4351-6fea-11d0-b863-00aa00a216a1") CLSID_KsClockF;

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] =
{
    {L"KS Clock Forwarder", &__uuidof(CLSID_KsClockF), CKsClockF::CreateInstance, NULL, NULL},
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


CUnknown*
CALLBACK
CKsClockF::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a Clock
    Forwarder. It is referred to in the g_Tamplates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CKsClockF(UnkOuter, NAME("KsClockF Class"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
}


CKsClockF::CKsClockF(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) :
    CUnknown(Name, UnkOuter),
    m_RefClock(NULL),
    m_Thread(NULL),
    m_ThreadEvent(NULL),
    m_ClockHandle(NULL),
    m_State(State_Stopped),
    m_StartTime(0),
    m_PendingRun(FALSE)
/*++

Routine Description:

    The constructor for the clock forwarder object. Just initializes
    everything to NULL and opens the kernel mode clock proxy.

Arguments:

    UnkOuter -
        Specifies the outer unknown, which must be set.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    //
    // Must have a parent, as this is always an aggregated object.
    //
    if (UnkOuter) {
        //
        // Try to open the default clock device.
        //
        *hr = KsOpenDefaultDevice(
            KSCATEGORY_CLOCK,
            GENERIC_READ | GENERIC_WRITE,
            &m_ClockHandle);
    } else {
        *hr = VFW_E_NEED_OWNER;
    }
}


CKsClockF::~CKsClockF(
    )
/*++

Routine Description:

    The destructor for the clock forwarder instance.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    //
    // The kernel mode clock proxy may have failed to open.
    //
    if (m_ClockHandle) {
        //
        // If there is a clock handle, the clock may have been started. If there
        // was not a handle, then it could not have been started. This will close
        // down everything, and wait for the thread to terminate.
        //
        Stop();
        CloseHandle(m_ClockHandle);
    }
    //
    // No reference clock may have been yet associated, or it may have been changed.
    //
    if (m_RefClock) {
        m_RefClock->Release();
    }
}


STDMETHODIMP
CKsClockF::NonDelegatingQueryInterface(
    REFIID iid,
    void ** ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interfaces explicitly supported
    are IDistributorNotify and IKsObject.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (iid == __uuidof(IKsClock)) {
        return GetInterface(static_cast<IKsObject*>(this), ppv);
    } else if (iid == __uuidof(IDistributorNotify)) {
        return GetInterface(static_cast<IDistributorNotify*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(iid, ppv);
}


STDMETHODIMP
CKsClockF::Stop(
    )
/*++

Routine Description:

    Implements the IDistributorNotify::Stop method. This sets the state of
    the underlying kernel mode proxy to a Stop state. If a forwarding
    thread had been created, it is terminated.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    //
    // Abort the startup sequence if necessary.
    //
    m_PendingRun = FALSE;
    m_State = State_Stopped;
    //
    // This is created first on a Pause.
    //
    if (m_ThreadEvent) {
        //
        // Check in case a Pause or Run failed because the thread could not be
        // created.
        //
        if (m_Thread) {
            //
            // Signal the thread of a change, and wait for the thread to terminate.
            // Waiting ensures that only a single outstanding thread is attached to
            // this clock forwarder instance.
            //
            SetEvent(m_ThreadEvent);
            WaitForSingleObjectEx(m_Thread, INFINITE, FALSE);
            CloseHandle(m_Thread);
            m_Thread = NULL;
        }
        CloseHandle(m_ThreadEvent);
        m_ThreadEvent = NULL;
    }
    //
    // Set the state on the clock proxy afterwards so that the thread does not
    // make it jump ahead after being stopped.
    //
    SetState(KSSTATE_STOP);
    return S_OK;
}


STDMETHODIMP
CKsClockF::Pause(
     )
/*++

Routine Description:

    Implements the IDistributorNotify::Pause method. This sets the state of
    the underlying kernel mode proxy to a Pause state. If this is a transition
    from Stop --> Pause, a forwarder thread is created if such a thread has
    not already been created. If this is a transition from Run --> Pause, the
    state is changed and the thread is notified.

Arguments:

    None.

Return Value:

    Returns S_OK if the state change could occur, else a thread creation error.

--*/
{
    //
    // Abort the startup sequence if necessary. If the clock is still waiting on
    // a sequence to occur, then this just ensures that the clock will not try
    // to calculate a new start time, and startup the clock. Note that the kernel
    // mode proxy state is changed after signalling the forwarder thread so that
    // the state is kept in sync when possible.
    //
    m_PendingRun = FALSE;
    //
    // If the graph is currently stopped, then the forwarding thread must be
    // created.
    //
    if (m_State == State_Stopped) {
        //
        // The reference clock may have been set back to NULL, so don't
        // bother creating the thread in this case.
        //
        if (m_RefClock) {
            DWORD       ThreadId;

            //
            // This is the event used by the thread to wait between probing the
            // ActiveMovie clock. It is also used to force the clock to check
            // the current state when going to a Stopped or Run state. The event
            // handle should have been closed on a Stop state change, but in
            // case that never happened, just check for a handle first.
            //
            if (!m_ThreadEvent) {
                m_ThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                if (!m_ThreadEvent) {
                    DWORD   LastError;

                    LastError = GetLastError();
                    return HRESULT_FROM_WIN32(LastError);
                }
            }
            //
            // The event handle should have been closed on a Stop state change,
            // but in case that never happened, just check for a handle first.
            //
            if (!m_Thread) {
                //
                // Create this in a suspended state so that the priority and
                // state can be set up first.
                //
                m_Thread = CreateThread(
                    NULL,
                    0,
                    reinterpret_cast<PTHREAD_START_ROUTINE>(CKsClockF::ClockThread),
                    reinterpret_cast<PVOID>(this),
                    CREATE_SUSPENDED,
                    &ThreadId);
                if (!m_Thread) {
                    DWORD   LastError;

                    //
                    // The event handle can be cleaned up later.
                    //
                    LastError = GetLastError();
                    return HRESULT_FROM_WIN32(LastError);
                }
                //
                // The thread only works in short spurts, and when it does, it
                // must be very timely. Of course this is limited by the priority
                // of the calling process class.
                //
                SetThreadPriority(m_Thread, THREAD_PRIORITY_HIGHEST);
            }
            //
            // Only resume the thread after the state has been changed so that
            // the thread does not immediately exit.
            //
            m_State = State_Paused;
            ResumeThread(m_Thread);
        }
    } else if (m_State == State_Running) {
        //
        // Else just change the internal state so that the forwarding thread
        // knows to wait INFINITE rather than continue to update the kernel
        // mode proxy.
        //
        m_State = State_Paused;
        //
        // Signal the thread so that it has a chance of keeping up with state
        // changes. This does not attempt to synchronize the transition with
        // the thread, as the thread itself takes care of this problem.
        // The thread may not exist since the clock may have been set back to
        // NULL, though this module will stay loaded until the graph is destroyed.
        //
        if (m_ThreadEvent) {
            SetEvent(m_ThreadEvent);
        }
    }
    //
    // Update the state of the kernel mode proxy.
    //
    SetState(KSSTATE_PAUSE);
    return S_OK;
}


STDMETHODIMP
CKsClockF::Run(
    REFERENCE_TIME  Start
    )
/*++

Routine Description:

    Implements the IDistributorNotify::Run method. Signals the forwarder
    thread to change the state of the underlying kernel mode proxy to a
    Run state. The thread waits to actually forward the change until the
    Start time has been met.

Arguments:

    Start -
        The reference time at which the state change should occur. This
        may be in the future compared to the current time presented by
        the master clock.

Return Value:

    Returns S_OK.

--*/
{
    //
    // Since the clock forwarder is chained off DShow as a distributor
    // notification, we will not get insertion of a pause state between stop 
    // and run if the graph transitions directly from stop to run.  Thus, if we
    // were in a stop state, we must insert our own pause transition to 
    // compensate for this.  (NTBUG: 371949)
    //
    if (m_State == State_Stopped)
        Pause();

    m_StartTime = Start;
    //
    // Indicate that a new start time has been specified. This makes the
    // forwarder thread check the new time in case it must pause before
    // starting the kernel mode clock.
    //
    m_PendingRun = TRUE;
    m_State = State_Running;
    //
    // The thread will have been waiting INFINITE with the kernel mode
    // clock in Pause for this change to occur. The thread may not exist
    // since the clock may have been set back to NULL, though this
    // module will stay loaded until the graph is destroyed.
    //
    if (m_ThreadEvent) {
        SetEvent(m_ThreadEvent);
    }
    return S_OK;
}


STDMETHODIMP
CKsClockF::SetSyncSource(
    IReferenceClock*    RefClock
    )
/*++

Routine Description:

    Implements the IDistributorNotify::SetSyncSource method. Assigns the
    current master clock for the graph. This is assumed to occur before the
    graph actually is started, since the forwarder thread relies on a clock
    being present.

Arguments:

    RefClock -
        The interface pointer on the new clock source, else NULL if any current
        clock source is being abandoned.

Return Value:

    Returns S_OK.

--*/
{
    //
    // Release any current handle first.
    //
    if (m_RefClock) {
        m_RefClock->Release();
    }
    //
    // Reference the new handle being passed, if any. This may be NULL if a
    // different clock is being selected, and this distributor has not been
    // unloaded yet.
    //
    m_RefClock = RefClock;
    if (m_RefClock) {
        m_RefClock->AddRef();
    }
    return S_OK;
}


STDMETHODIMP
CKsClockF::NotifyGraphChange(
    )
/*++

Routine Description:

    Implements the IDistributorNotify::NotifyGraphChange method. The forwarder
    does not need to do anything on graph changes.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP_(HANDLE)
CKsClockF::KsGetObjectHandle(
    )
/*++

Routine Description:

    Implements the IKsObject::KsGetObjectHandle method. This is actually accessed
    through the IKsClock Guid, which just provides a unique Guid to use when
    trying to load the module through the distributor on the ActiveMovie graph.

Arguments:

    None.

Return Value:

    Returns the handle to the underlying kernel mode proxy clock. This is used
    by the ActiveMovie filter proxy to hand to kernel mode filters.

--*/
{
    return m_ClockHandle;
}


STDMETHODIMP
CKsClockF::SetState(
    KSSTATE DeviceState
    )
/*++

Routine Description:

    Set the state of the underlying kernel mode proxy. Normally a master clock
    cannot be directly set, as it just reflects some stream time or physical
    clock, but in this case it is just acting as a proxy for an Active Movie
    clock, so it does provide such a mechanism.

Arguments:

    DeviceState -
        The state to set the device to.

Return Value:

    Returns any device call error.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Clock;
    Property.Id = KSPROPERTY_CLOCK_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_ClockHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &DeviceState,
        sizeof(DeviceState),
        &BytesReturned);
}


HRESULT
CKsClockF::ClockThread(
    CKsClockF*  KsClockF
    )
/*++

Routine Description:

    The forwarder thread routine.

Arguments:

    KsClockF -
        The instance.

Return Value:

    Returns NOERROR.

--*/
{
    KSPROPERTY      Property;

    //
    // Initialize the property structures once.
    //
    Property.Set = KSPROPSETID_Clock;
    Property.Id = KSPROPERTY_CLOCK_TIME;
    Property.Flags = KSPROPERTY_TYPE_SET;
    //
    // The thread exits when the state goes back to Stopped. This means that on
    // startup, the thread is put into a suspended state until m_State has been
    // set to Paused.
    //
    while (KsClockF->m_State != State_Stopped) {
        REFERENCE_TIME  RefTime;
        DWORD           ThreadWaitTime;

        //
        // When moving to a Run state, a new m_StartTime will be presented to
        // the clock forwarder. This is used to delay the actual starting of
        // the kernel mode proxy. The rest of the kernel mode filters may have
        // been started, but the clock won't be until the correct time on the
        // ActiveMovie clock is reached.
        //
        if (KsClockF->m_PendingRun) {
            //
            // Check the difference between the new m_StartTime and the
            // current time on the ActiveMovie clock. Wait for the specified
            // amount of time, if there is a negative value, else make the
            // wait timeout immediately. After the wait is up, the kernel
            // mode proxy is started.
            //
            KsClockF->m_RefClock->GetTime(&RefTime);
            if (RefTime > KsClockF->m_StartTime) {
                ThreadWaitTime = static_cast<ULONG>((RefTime - KsClockF->m_StartTime) / 10000);
            } else {
                ThreadWaitTime = 0;
            }
        } else if (KsClockF->m_State != State_Running) {
            //
            // Else the clock is likely in a Paused state, which means that
            // the thread should wait until a state change, at which time
            // the event will be signalled. The state could also have been
            // just changed to Stopped, but in that case the event will also
            // have been signalled, and the thread will exit.
            //
            ThreadWaitTime = INFINITE;
        } else {
            //
            // Else just wait the default amount of time.
            //
            ThreadWaitTime = 1000;
        }
        WaitForSingleObjectEx(KsClockF->m_ThreadEvent, ThreadWaitTime, FALSE);
        //
        // The state may have changed during the wait.
        //
        if (KsClockF->m_State == State_Running) {
            ULONG   BytesReturned;

            //
            // Determine if this is the first time through the loop after a
            // state change to Run. If so, the kernel mode proxy state must
            // now be started. The compare is interlocked so that multiple
            // state changes do not allow this assignment to wipe out the
            // current value of m_PendingRun.
            //
            // If a Run/Pause/Run sequence occurs quickly, there is a chance
            // that the kernel mode clock will be left running, even though
            // the m_StartTime has been changed to indicate that filters
            // should not be running yet. The kernel mode proxy time will
            // continuously be adjusted back until the ActiveMovie start time
            // catches up.
            //
            if (InterlockedCompareExchange(reinterpret_cast<PLONG>(&KsClockF->m_PendingRun), FALSE, TRUE)) {
                KsClockF->SetState(KSSTATE_RUN);
                //
                // If a Run/Pause sequence occurs quickly, there is a chance
                // that the kernel mode proxy will be set to the wrong state.
                // Therefore check afterwards, and set the proxy to a Pause
                // state if the graph state was changed after the compare,
                // but before setting the proxy state.
                //
                // Since when a transition to a Stopped state occurs, the
                // thread is terminated, then the kernel mode proxy state
                // is changed to a Stop state, this will not harm anything.
                // Otherwise the clock would correctly be placed back into
                // a Pause state. This saves attempting to synchronize with
                // the Run --> Pause transition.
                //
                if (KsClockF->m_State != State_Running) {
                    KsClockF->SetState(KSSTATE_PAUSE);
                }
            }
            //
            // Synchronize the kernel mode proxy with the current time,
            // offset by the m_StartTime, which gives actual stream time.
            // The kernel clock time progression stops when set to a stop
            // state, which is the difference between it and an Active
            // Movie clock.
            //
            KsClockF->m_RefClock->GetTime(&RefTime);
            RefTime -= KsClockF->m_StartTime;
            ::KsSynchronousDeviceControl(
                KsClockF->m_ClockHandle,
                IOCTL_KS_PROPERTY,
                &Property,
                sizeof(Property),
                &RefTime,
                sizeof(RefTime),
                &BytesReturned);
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksdata\ksdata.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksdata.cpp

Abstract:

    This module implements the IKsDataTypeHandler interface for various
    CMediaType major types.

Author:

    Bryan A. Woodruff (bryanw) 28-Mar-1997

--*/

#include <windows.h>
#include <streams.h>
#include "devioctl.h"
#include "ks.h"
#include "ksmedia.h"
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include "ksdata.h"

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = 
{
    {
        L"KsDataTypeHandler", 
        &KSDATAFORMAT_TYPE_AUDIO,
        CStandardDataTypeHandler::CreateInstance,
        NULL,
        NULL
    }
};
int g_cTemplates = SIZEOF_ARRAY( g_Templates );

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


CUnknown*
CALLBACK
CStandardDataTypeHandler::CreateInstance(
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT* hr
    )
/*++

Routine Description:

    This is called by KS proxy code to create an instance of a
    data type handler. It is referred to in the g_Templates structure.

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;
    
    DbgLog(( LOG_TRACE, 0, TEXT("CStandardDataTypeHandler::CreateInstance()")));

    Unknown = 
        new CStandardDataTypeHandler( 
                UnkOuter, 
                NAME("Audio Data Type Handler"), 
                KSDATAFORMAT_TYPE_AUDIO,
                hr);
                
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CStandardDataTypeHandler::CStandardDataTypeHandler(
    IN LPUNKNOWN   UnkOuter,
    IN TCHAR*      Name,
    IN REFCLSID    ClsID,
    OUT HRESULT*   hr
    ) :
    CUnknown(Name, UnkOuter),
    m_ClsID(ClsID),
    m_MediaType(NULL)
/*++

Routine Description:

    The constructor for the data handler object. 

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    IN TCHAR *Name -
        The name of the object, used for debugging.
        
    IN REFCLSID ClsID -
        The CLSID of the object.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    *hr = NOERROR;
} 


CStandardDataTypeHandler::~CStandardDataTypeHandler()
{
    if (m_MediaType) {
        delete m_MediaType;
    }
}


STDMETHODIMP
CStandardDataTypeHandler::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsDataTypeHandler.

Arguments:

    IN REFIID riid -
        The identifier of the interface to return.

    OUT PVOID *ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IKsDataTypeHandler)) {
        return GetInterface(static_cast<IKsDataTypeHandler*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 

STDMETHODIMP 
CStandardDataTypeHandler::KsCompleteIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation, 
    IN BOOL Cancelled
    )

/*++

Routine Description:
    Clean up the extended header and complete I/O operation.
    
    In the default case for major type == KSDATAFORMAT_TYPE_AUDIO, there
    is no work to do, just return S_OK.

Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation
    
    IN BOOL Cancelled
        Set if the I/O operation was cancelled.

Return:
    S_OK

--*/

{
    return S_OK;
}

STDMETHODIMP 
CStandardDataTypeHandler::KsPrepareIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation
    )

/*++

Routine Description:
    Intialize the extended header and prepare sample for I/O operation.
    
    In the default case for major type == KSDATAFORMAT_TYPE_AUDIO, there
    is no work to do, just return S_OK.

Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation

Return:
    S_OK

--*/

{
    return S_OK;
}

STDMETHODIMP 
CStandardDataTypeHandler::KsIsMediaTypeInRanges(
    IN PVOID DataRanges
)

/*++

Routine Description:
    Validates that the given media type is within the provided data ranges.

Arguments:
    IN PVOID DataRanges -
        pointer to data ranges which is a KSMULTIPLE_ITEM structure followed
        by ((PKSMULTIPLEITEM) DataRanges)->Count data range structures.

Return:

--*/

{
    ULONG               u;
    PKSDATARANGE_AUDIO  AudioRange;
    PKSMULTIPLE_ITEM    MultipleItem;
    
    DbgLog((LOG_TRACE, 0, TEXT("CStandardDataTypeHandler::KsIsMediaTypeInRanges")));
    
    ASSERT( *m_MediaType->Type() == KSDATAFORMAT_TYPE_AUDIO );
    
    MultipleItem = reinterpret_cast<PKSMULTIPLE_ITEM>(DataRanges);
    
    for (u = 0, 
            AudioRange = reinterpret_cast<PKSDATARANGE_AUDIO>(MultipleItem + 1);
         u < MultipleItem->Count; 
         u++, 
            AudioRange = 
                reinterpret_cast<PKSDATARANGE_AUDIO>(reinterpret_cast<PBYTE>(AudioRange) + 
                    ((AudioRange->DataRange.FormatSize + 7) & ~7))) {
    
        //
        // Only validate those in the range that match the format specifier.
        //
        
        if (((AudioRange->DataRange.FormatSize < sizeof( KSDATARANGE )) ||
            (AudioRange->DataRange.MajorFormat != KSDATAFORMAT_TYPE_WILDCARD)) &&
            ((AudioRange->DataRange.FormatSize < sizeof( KSDATARANGE_AUDIO )) ||
            (AudioRange->DataRange.MajorFormat != KSDATAFORMAT_TYPE_AUDIO))) {
            continue;
        }

        //
        // Verify that the correct subformat and specifier are (or wildcards)
        // in the intersection.
        //
        
        if (((AudioRange->DataRange.SubFormat != 
                *m_MediaType->Subtype()) &&
             (AudioRange->DataRange.SubFormat != 
                KSDATAFORMAT_SUBTYPE_WILDCARD)) || 
            ((AudioRange->DataRange.Specifier != 
                *m_MediaType->FormatType()) &&
             (AudioRange->DataRange.Specifier !=
                KSDATAFORMAT_SPECIFIER_WILDCARD))) {
            continue;
        }

        //
        // Verify that we have an intersection with the specified format and 
        // our audio format dictated by our specific requirements.
        //
        
        if (*m_MediaType->FormatType() == 
                KSDATAFORMAT_SPECIFIER_WAVEFORMATEX &&
            AudioRange->DataRange.Specifier == 
                KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) {
                
            PWAVEFORMATEX  WaveFormatEx;
            
            //
            // Verify that the data range size is correct
            //   
            
            //
            // 86040: Since were going to use the Format as WAVEFORMATEX, change the sizeof()
            // comparison to use WAVEFORMATEX instead of just WAVEFORMAT
            //
            
            if ((AudioRange->DataRange.FormatSize != sizeof( KSDATARANGE_AUDIO )) || m_MediaType->FormatLength() < sizeof( WAVEFORMATEX )) {
                continue;
            }
            
            WaveFormatEx = reinterpret_cast<PWAVEFORMATEX>(m_MediaType->Format());
            
            if ((WaveFormatEx->nSamplesPerSec < AudioRange->MinimumSampleFrequency) ||
                (WaveFormatEx->nSamplesPerSec > AudioRange->MaximumSampleFrequency) ||
                (WaveFormatEx->wBitsPerSample < AudioRange->MinimumBitsPerSample) ||
                (WaveFormatEx->wBitsPerSample > AudioRange->MaximumBitsPerSample) ||
                (WaveFormatEx->nChannels      > AudioRange->MaximumChannels)) {
                continue;
            }
            
            //
            // We have found a match.
            //
            
            return S_OK;
            
        } else {
        
            //
            // We match on the wildcard.
            //
            
            return S_OK;
        }
    }
    
    return S_FALSE;
}

STDMETHODIMP 
CStandardDataTypeHandler::KsQueryExtendedSize( 
    OUT ULONG* ExtendedSize
)

/*++

Routine Description:
    Returns the extended size for each stream header. 
    
    In the default case for major type == KSDATAFORMAT_TYPE_AUDIO, 
    the extended size is zero.

Arguments:
    OUT ULONG* ExtendedSize -
        pointer to receive the extended size.

Return:
    S_OK

--*/

{
    *ExtendedSize = 0;
    return S_OK;
}
    

STDMETHODIMP 
CStandardDataTypeHandler::KsSetMediaType(
    const AM_MEDIA_TYPE *AmMediaType
    )

/*++

Routine Description:
    Sets the media type for this instance of the data handler.

Arguments:
    const CMediaType *MediaType -
        pointer to the media type

Return:
    S_OK

--*/

{
    if (m_MediaType) {
        return E_FAIL;
    }
    if (m_MediaType = new CMediaType( *AmMediaType )) {
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksfnspec\ksfnspec.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksfnspec.cpp

Abstract:

    Provides a FileName Specifier property sheet for a Bridge Pin Factory.

--*/

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <streams.h>
#include "devioctl.h"
#include "ks.h"
#include "ksmedia.h"
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include "resource.h"
#include "ksfnspec.h"

//
// Create the two guids which are used as the ClsId's of these two
// specifiers.
//
struct DECLSPEC_UUID("26A40C7E-D20D-11D0-ABEC-00A0C9223196") CLSID_FileNameSpecifier;
struct DECLSPEC_UUID("26A40C7F-D20D-11D0-ABEC-00A0C9223196") CLSID_VcIdSpecifier;

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] = 
{
    {
        L"KsFileNameSpecifier",
        &__uuidof(CLSID_FileNameSpecifier),
        CKsSpecifier::CreateFileNameInstance,
        NULL,
        NULL
    },
    {
        L"KsVCNameSpecifier",
        &__uuidof(CLSID_VcIdSpecifier),
        CKsSpecifier::CreateVCInstance,
        NULL,
        NULL
    }
};
int g_cTemplates = SIZEOF_ARRAY(g_Templates);
const WCHAR KernelPrefix[] = L"\\??\\";


CUnknown*
CALLBACK
CKsSpecifier::CreateFileNameInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a Specifier
    property page. It is referred to in the g_Tamplates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CKsSpecifier(UnkOuter, NAME("Pin Property Page"), KSDATAFORMAT_SPECIFIER_FILENAME, IDS_FILENAME_TITLE, hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CUnknown*
CALLBACK
CKsSpecifier::CreateVCInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a Specifier
    property page. It is referred to in the g_Tamplates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CKsSpecifier(UnkOuter, NAME("Pin Property Page"), KSDATAFORMAT_SPECIFIER_VC_ID, IDS_VC_TITLE, hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CKsSpecifier::CKsSpecifier(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    REFCLSID    ClassId,
    ULONG       TitleStringId,
    HRESULT*    hr
    ) :
    CUnknown(Name, UnkOuter),
    m_Dirty(FALSE),
    m_PropertyPageSite(NULL),
    m_PropertyWindow(NULL),
    m_Pin(NULL),
    m_FileName(NULL),
    m_ClassId(ClassId),
    m_TitleStringId(TitleStringId)
/*++

Routine Description:

    The constructor for the Specifier property page object. Just initializes
    everything to NULL.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    InitCommonControls();
    *hr = NOERROR;
} 


STDMETHODIMP
CKsSpecifier::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IPropertyPage.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IPropertyPage)) {
        return GetInterface(static_cast<IPropertyPage*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CKsSpecifier::SetPageSite(
    LPPROPERTYPAGESITE  PropertyPageSite
    )
/*++

Routine Description:

    Used by the owner of the property page site to set the site interface
    which this property page is to use. Reference the new property site,
    releasing any old property site which had been assigned.

Arguments:

    PropertyPageSite -
        Contains the property page site to use.

Return Value:

    Returns NOERROR.

--*/
{
    if (PropertyPageSite) {
        m_PropertyPageSite = PropertyPageSite;
        m_PropertyPageSite->AddRef();
    } else {
        if (m_PropertyPageSite) {
            m_PropertyPageSite->Release();
            m_PropertyPageSite = NULL;
        }
    }
    return NOERROR;
}


STDMETHODIMP
CKsSpecifier::Activate(
    HWND    ParentWindow,
    LPCRECT Rect,
    BOOL    Modal
    )
/*++

Routine Description:

    Used by the owner of the property page site to activate this property
    page. This involves creating the property page window, and restoring
    any previous state. This will be called each time the tab for this
    property page is selected.

Arguments:

    ParentWindow -
        Contains the parent window handle of the property page being
        activated.

    Rect -
        Contains the size and relative position at which the property
        page window is to be placed.

    Modal -
        Indicates whether or not the property page window created is to
        be modal.

Return Value:

    Returns the success or failure of creating the property page window
    and moving it to the specified location.

--*/
{                                
    HWND            ControlWindow;

    m_PropertyWindow = ::CreateDialogParam(
        g_hInst,
        MAKEINTRESOURCE(IDD_SPECDIALOG),
        ParentWindow,
        DialogProc,
        reinterpret_cast<LPARAM>(this));
    if (!m_PropertyWindow) {
        return E_FAIL;
    }
    //
    // Allow tabbing out of this window to the Property Page Site.
    //
    ::SetWindowLong(
        m_PropertyWindow,
        GWL_EXSTYLE,
        ::GetWindowLong(m_PropertyWindow, GWL_EXSTYLE) | WS_EX_CONTROLPARENT);
    //
    // Re-instantiate any text which has already been typed in. This will only
    // happen if the another page had been selected after typing in some of
    // the filename.
    //
    ControlWindow = ::GetDlgItem(m_PropertyWindow, IDC_FILENAME);
    if (m_FileName) {
        ::SetWindowTextW(ControlWindow, m_FileName);
    }
    //
    // The connection may already have been made, so don't allow it to be
    // made again if there is already a pin handle. This is obviously somewhat
    // limiting, in that a connection can only be made once.
    //
    if (m_Pin->KsGetObjectHandle()) {
        ::EnableWindow(ControlWindow, FALSE);
    }
    //
    // Place the property page where it is supposed to go on the property
    // page site.
    //
    return Move(Rect);
}


STDMETHODIMP
CKsSpecifier::Deactivate(
    )
/*++

Routine Description:

    Used by the owner of the property page site to deactivate this property
    page. This involves saving the current file name text, and destroying
    the property page window. This will be called each time the tab for this
    property page is unselected. This is only called following a successful
    Activate request.

Arguments:

    None.

Return Value:

    Returns NOERROR if the window was destroyed, else E_FAIL.

--*/
{
    //
    // The propety page is only Dirty if some new file name text has been
    // typed, and that text is non-zero in length.
    //
    if (m_Dirty) {
        HWND            ControlWindow;
        int             TextLength;

        ControlWindow = ::GetDlgItem(m_PropertyWindow, IDC_FILENAME);
        //
        // Remove any currently save file name text so that it can be
        // replaced with any new text. The page will only be Dirty if
        // the new text length was non-zero. If the text length became
        // zero, the previous file name save would have already been
        // deleted.
        //
        if (m_FileName) {
            delete [] m_FileName;
        }
        TextLength = ::GetWindowTextLengthW(ControlWindow) + 1;
        m_FileName = new WCHAR [TextLength];
        if (m_FileName) {
            ::GetWindowTextW(ControlWindow, m_FileName, TextLength);
        }
    }
    //
    // Destroy the current property page window.
    //
    return ::DestroyWindow(m_PropertyWindow) ? NOERROR : E_FAIL;
} 


STDMETHODIMP
CKsSpecifier::GetPageInfo(
    LPPROPPAGEINFO  PageInfo
    )
/*++

Routine Description:

    Used by the owner of the property page site to query for the property page
    information. This returns the title, size, and help information.

Arguments:

    PageInfo -
        The place in which to put the property page information.

Return Value:

    Returns NOERROR.

--*/
{
    WCHAR   PageTitle[256];

    PageInfo->cb = sizeof(PROPPAGEINFO);
    LoadStringW(g_hInst, m_TitleStringId, PageTitle, sizeof(PageTitle) / sizeof(WCHAR));
    PageInfo->pszTitle = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(PageTitle) + 1) * sizeof(PageTitle[0])));
    if (PageInfo->pszTitle) {
        ::wcscpy(PageInfo->pszTitle, PageTitle);
    }
    PageInfo->size.cx = 253;
    PageInfo->size.cy = 132;
    PageInfo->pszDocString = NULL;
    PageInfo->pszHelpFile  = NULL;
    PageInfo->dwHelpContext= 0;
    return NOERROR;
}


STDMETHODIMP
CKsSpecifier::SetObjects(
    ULONG       Objects,
    LPUNKNOWN*  Interface
    )
/*++

Routine Description:

    Used by the owner of the property page site to initialize and uninitialize
    the Specifier object.

Arguments:

    Objects -
        Specifies the action to perform. This is normally 0 to uninitialize, and
        1 to initialize.

    Interface -
        Points to a pointer to an interface which is used on initialization.
        This was passed by the owner of the property page site to set up property
        pages within the site, and on initialization contains the IUnknown
        interface on the subject Pin.

Return Value:

    Returns NOERROR if the operation succeeded, or was an unknown operation, else
    E_NOINTERFACE if the IPin interface could not be acquired on the Pin.

--*/
{
    HRESULT hr;

    switch (Objects) {
    case 0:
        //
        // Just release any resources which were acquired during initialization
        // or access to the property page. In case the object is re-used, zero
        // out any elements freed.
        //
        if (m_Pin) {
            //
            // The reference count was not originally retained, since this
            // is guaranteed to be removed before the pin.
            //
            m_Pin = NULL;
        }
        if (m_FileName) {
            delete [] m_FileName;
            m_FileName = NULL;
        }
        break;
    case 1:
        hr = (*Interface)->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&m_Pin));
        if (SUCCEEDED(hr)) {
            //
            // Don't hang onto this interface, since it is a reference to the
            // filter, and will not allow the filter to be deleted.
            //
            m_Pin->Release();
        }
        return hr;
    }
    return NOERROR;
} 


STDMETHODIMP
CKsSpecifier::Show(
    UINT CmdShow
    )
/*++

Routine Description:

    Used by the owner of the property page site to set the show state of the
    property page window.

Arguments:

    CmdShow -
        Contains the ShowWindow command to perform.

Return Value:

    Returns NOERROR.

--*/
{
    ::ShowWindow(m_PropertyWindow, CmdShow);
    ::InvalidateRect(m_PropertyWindow, NULL, TRUE);
    return NOERROR;
} 


STDMETHODIMP
CKsSpecifier::Move(
    LPCRECT Rect
    )
/*++

Routine Description:

    Used by the owner of the property page site to move the window relative to
    the property page site window.

Arguments:

    Rect -
        Contains the rectangle for the new window position.

Return Value:

    Returns NOERROR if the MoveWindow succeeded, else E_FAIL.

--*/
{
    if (::MoveWindow(
        m_PropertyWindow,
        Rect->left,
        Rect->top,
        Rect->right - Rect->left,
        Rect->bottom - Rect->top,
        TRUE)) {
        return NOERROR;
    }
    return E_FAIL;
} 


STDMETHODIMP
CKsSpecifier::IsPageDirty(
    )
/*++

Routine Description:

    Used by the owner of the property page site to determine if the property
    page is currently Dirty and in need of an Apply.

Arguments:

    None.

Return Value:

    Returns S_OK if the property page is Dirty, else S_FALSE.

--*/
{
    return m_Dirty ? S_OK : S_FALSE;
}                          


STDMETHODIMP
CKsSpecifier::Apply(
    )
/*++

Routine Description:

    Used by the owner of the property page site to apply changes to a Dirty
    property page. This has the effect of creating the pin instance handle
    if there has been a file name typed. If the handle is created, the
    property page becomes Clean, and the file name window is disabled. I.e.,
    Only one handle can be created.

Arguments:

    None.

Return Value:

    Returns S_OK if the apply succeeded, else an error.

--*/
{
    HRESULT     hr;

    //
    // This may be called even if the property page is not Dirty.
    //
    if (m_Dirty) {
        HWND        ControlWindow;
        int         TextLength;
        IPin*       Pin;

        //
        // Do the same work as when deactivating the property page.
        //
        ControlWindow = ::GetDlgItem(m_PropertyWindow, IDC_FILENAME);
        //
        // Remove any currently save file name text so that it can be
        // replaced with any new text. The page will only be Dirty if
        // the new text length was non-zero. If the text length became
        // zero, the previous file name save would have already been
        // deleted.
        //
        if (m_FileName) {
            delete [] m_FileName;
        }
        TextLength = ::GetWindowTextLengthW(ControlWindow) + 1;
        m_FileName = new WCHAR [TextLength];
        if (m_FileName) {
            ::GetWindowTextW(ControlWindow, m_FileName, TextLength);
            //
            // Acquire the IPin interface so that the first media
            // type can be enumerated. This is used to attach the
            // file name to.
            //
            hr = m_Pin->QueryInterface(__uuidof(IPin), reinterpret_cast<PVOID*>(&Pin));
        } else {
            hr = E_OUTOFMEMORY;
        }
        if (SUCCEEDED(hr)) {
            IEnumMediaTypes*    Enum;

            hr = Pin->EnumMediaTypes(&Enum);
            if (SUCCEEDED(hr)) {
                AM_MEDIA_TYPE*  AmMediaType;
                ULONG           Fetched;

                //
                // Look for the first media type which can be used
                // with a FileName specifier. This allows a Bridge to
                // support multiple specifiers, though still limits
                // interface/mediums.
                //
                while (SUCCEEDED(hr = Enum->Next(1, &AmMediaType, &Fetched))) {
                    if (!Fetched) {
                        hr = E_FAIL;
                        break;
                    }
                    if (*static_cast<CMediaType*>(AmMediaType)->FormatType() == m_ClassId) {
                        break;
                    }
                    DeleteMediaType(static_cast<CMediaType*>(AmMediaType));
                }
                Enum->Release();
                if (SUCCEEDED(hr)) {
                    //
                    // Translate the file name if necessary such that it
                    // has the correct prefix. This is only needed if the
                    // specifier type is KSDATAFORMAT_SPECIFIER_FILENAME,
                    // and not for KSDATAFORMAT_SPECIFIER_VD_ID.
                    //
                    if (m_ClassId == KSDATAFORMAT_SPECIFIER_FILENAME) {
                        //
                        // Look for the prefix. If not present, insert it.
                        //
                        if (wcsncmp(KernelPrefix, m_FileName, SIZEOF_ARRAY(KernelPrefix) - 1)) {
                            PWCHAR  FileName;

                            FileName = new WCHAR[TextLength + SIZEOF_ARRAY(KernelPrefix) - 1];
                            if (FileName) {
                                wcscpy(FileName, KernelPrefix);
                                wcscpy(FileName + SIZEOF_ARRAY(KernelPrefix) - 1, m_FileName);
                                delete [] m_FileName;
                                m_FileName = FileName;
                                TextLength += SIZEOF_ARRAY(KernelPrefix) - 1;
                            } else {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                    }
                    if (SUCCEEDED(hr)) {
                        //
                        // Apply the file name and attempt a connection.
                        //
                        static_cast<CMediaType*>(AmMediaType)->SetFormat(
                            reinterpret_cast<BYTE*>(m_FileName),
                            TextLength * sizeof(*m_FileName));
                        hr = Pin->Connect(NULL, AmMediaType);
                    }
                    if (SUCCEEDED(hr)) {
                        //
                        // Disallow any further file name changes, since the
                        // connection has already been made.
                        //
                        ::EnableWindow(ControlWindow, FALSE);
                        m_Dirty = FALSE;
                    } else {
                        TCHAR   TitleString[64];
                        TCHAR   TextString[64];

                        //
                        // Report the error encountered attempting a
                        // connection with this specifier data.
                        //
                        LoadString(g_hInst, IDS_CONNECT_TEXT, TitleString, sizeof(TitleString));
                        _stprintf(TextString, TitleString, hr);
                        LoadString(g_hInst, IDS_CONNECT_TITLE, TitleString, sizeof(TitleString));
                        MessageBox(
                            NULL,
                            TextString,
                            TitleString,
                            MB_ICONEXCLAMATION | MB_OK);
                    }
                    DeleteMediaType(static_cast<CMediaType*>(AmMediaType));
                }
            }
            Pin->Release();
        }
    } else {
        hr = S_OK;
    }
    return hr;
}


BOOL
CKsSpecifier::spec_OnCommand(
    HWND            Window,
    int             Id,
    HWND            ControlWindow,
    UINT            Notify
    )
/*++

Routine Description:

    Handles WM_COMMAND messages to the property page window. Specifically is
    used to handle file name text changes in the IDC_FILENAME control. This
    keeps track of whether or not the page is Dirty.

Arguments:

    Window -
        Property page window handle.

    Id -
        Identifier of the control to which the WM_COMMAND applies.

    ControlWindow -
        Handle of the control window.

    Notify -
        Specific notification code. Only EN_CHANGE notifications are useful.

Return Value:

    Returns FALSE always.

--*/
{
    //
    // Just pay attention to text changes to the file name. EN_CHANGE is
    // occurs after the text has actually be changed.
    //
    if ((Id == IDC_FILENAME) && (Notify == EN_CHANGE)) {
        CKsSpecifier*   This;

        This = reinterpret_cast<CKsSpecifier*>(::GetWindowLongPtr(Window, GWLP_USERDATA));
        //
        // If the property page is already Dirty, ensure that there is
        // still text present in the file name.
        //
        if (This->m_Dirty) {
            if (!::GetWindowTextLengthW(ControlWindow)) {
                //
                // No more text. Remove any saved file name, since this
                // is not cleaned up otherwise, since the window will
                // now be made Clean. Then tell the Property page site
                // to query about whether or not the site is Dirty.
                //
                if (This->m_FileName) {
                    delete [] This->m_FileName;
                    This->m_FileName = NULL;
                }
                This->m_Dirty = FALSE;
                This->m_PropertyPageSite->OnStatusChange(PROPPAGESTATUS_VALIDATE);
            }
        } else if (!This->m_Pin->KsGetObjectHandle() && ::GetWindowTextLengthW(ControlWindow)) {
            //
            // Else the property page is not currently Dirty. See if there
            // is no pin instance handle, and that there is an actual file
            // name.
            //
            This->m_Dirty = TRUE;
            This->m_PropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    }
    return FALSE;
}


INT_PTR
CALLBACK
CKsSpecifier::DialogProc(
    HWND        Window,
    UINT        Message,
    WPARAM      wParam,
    LPARAM      lParam
    )
/*++

Routine Description:

    Main window procedure for the property page. Handles window creation,
    destruction, and control commands.

Arguments:

    Window -
        Property page window handle.

    Message -
        Identifier of the window message.

    wParam -
        wParam depends on the message.

    lParam -
        lParam depends on the message.

Return Value:

    Return specific to the message.

--*/
{
    switch (Message) {
    case WM_INITDIALOG:
        //
        // Save the lParam, which contains the IKsPin interface pointer.
        //
        ::SetWindowLongPtr(Window, GWLP_USERDATA, lParam);
        /* no break */
    case WM_DESTROY:
        return TRUE;
    case WM_COMMAND:
        return HANDLE_WM_COMMAND(Window, wParam, lParam, spec_OnCommand);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksdata\ksdata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ksdata.h
//
//--------------------------------------------------------------------------

#ifndef __KSDATA__
#define __KSDATA__

class CStandardDataTypeHandler :
    public CUnknown,
    public IKsDataTypeHandler {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK
    CreateInstance( 
        LPUNKNOWN UnkOuter, 
        HRESULT* hr 
        );

    STDMETHODIMP 
    NonDelegatingQueryInterface( 
        REFIID riid, 
        PVOID* ppv 
        );
    
    // Implement IKsDataTypeHandler
    
    STDMETHODIMP 
    KsCompleteIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation, 
        IN BOOL Cancelled
        );
        
    STDMETHODIMP 
    KsIsMediaTypeInRanges(
        IN PVOID DataRanges
        );
        
    STDMETHODIMP 
    KsPrepareIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation
        );
    
    STDMETHODIMP 
    KsQueryExtendedSize( 
        IN ULONG* ExtendedSize
        );
        
    STDMETHODIMP 
    KsSetMediaType(
        const AM_MEDIA_TYPE *AmMediaType
        );
        
private:
    CLSID       m_ClsID;
    CMediaType  *m_MediaType;

    CStandardDataTypeHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        REFCLSID ClsID,
        HRESULT* hr
        );
        
    ~CStandardDataTypeHandler();
        
};

#endif // __KSDATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksfnspec\ksfnspec.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksfnspec.h

Abstract:

    Internal header.

--*/

class CKsSpecifier :
    public CUnknown,
    public IPropertyPage {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateFileNameInstance(LPUNKNOWN UnkOuter, HRESULT* hr);
    static CUnknown* CALLBACK CreateVCInstance(LPUNKNOWN UnkOuter, HRESULT* hr);

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, PVOID* ppv);

    // Implement IPropertyPage
    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE PropertyPageSite);
    STDMETHODIMP Activate(HWND ParentWindow, LPCRECT Rect, BOOL Modal);
    STDMETHODIMP Deactivate(void);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO PageInfo);
    STDMETHODIMP SetObjects(ULONG Objects, LPUNKNOWN* Interface);
    STDMETHODIMP Show(UINT CmdShow);
    STDMETHODIMP Move(LPCRECT Rect);
    STDMETHODIMP IsPageDirty();
    STDMETHODIMP Apply();
    STDMETHODIMP Help(LPCWSTR)                   { return E_NOTIMPL; }
    STDMETHODIMP TranslateAccelerator(LPMSG)     { return E_NOTIMPL; }

private:
    BOOL m_Dirty;
    IPropertyPageSite* m_PropertyPageSite;
    HWND m_PropertyWindow;
    IKsObject* m_Pin;
    WCHAR* m_FileName;
    CLSID m_ClassId;
    ULONG m_TitleStringId;

    CKsSpecifier(LPUNKNOWN UnkOuter, TCHAR* Name, REFCLSID ClassId, ULONG TitleStringId, HRESULT* hr);
    static BOOL spec_OnCommand(HWND Window, int Id, HWND WindowCtl, UINT Notify);
    static INT_PTR CALLBACK DialogProc(HWND Window, UINT Message, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksclockf\ksclockf.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksclockf.h

Abstract:

    Internal header.

--*/

class CKsClockF :
    public CUnknown,
    public IDistributorNotify,
    public IKsObject {

public:
    DECLARE_IUNKNOWN

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CKsClockF(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);
    ~CKsClockF();

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);

    // Implement IDistributorNotify
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME Start);
    STDMETHODIMP SetSyncSource(IReferenceClock* RefClock);
    STDMETHODIMP NotifyGraphChange();

    // Implement IKsObject
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();

private:
    STDMETHODIMP SetState(
        KSSTATE DeviceState);
    static HRESULT ClockThread(
        CKsClockF* KsClockF);

    IReferenceClock* m_RefClock;
    HANDLE m_Thread;
    HANDLE m_ThreadEvent;
    HANDLE m_ClockHandle;
    FILTER_STATE m_State;
    REFERENCE_TIME m_StartTime;
    BOOL m_PendingRun;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksfnspec\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDD_SPECDIALOG      100
#define IDC_FILENAME        101
#define IDS_FILENAME_TITLE  100
#define IDS_VC_TITLE        101
#define IDS_CONNECT_TEXT    102
#define IDS_CONNECT_TITLE   103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksinterf\ksinterf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ksinterf.h
//
//--------------------------------------------------------------------------

#ifndef __KSINTERF__
#define __KSINTERF__

#define MAXIMUM_SAMPLES_PER_SEGMENT 64

// below renamed to prevent collision with struct with same name in ksiproxy.h
typedef struct _KSSTREAM_SEGMENT_EX2 {
    KSSTREAM_SEGMENT        Common;
    IMediaSample            *Samples[ MAXIMUM_SAMPLES_PER_SEGMENT ];
    int                     SampleCount;
    ULONG                   ExtendedHeaderSize;
    PKSSTREAM_HEADER        StreamHeaders;
    OVERLAPPED              Overlapped;

} KSSTREAM_SEGMENT_EX2, *PKSSTREAM_SEGMENT_EX2;

class CStandardInterfaceHandler :
    public CUnknown,
    public IKsInterfaceHandler {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK
    CreateInstance( 
        LPUNKNOWN UnkOuter, 
        HRESULT* hr 
        );

    STDMETHODIMP 
    NonDelegatingQueryInterface( 
        REFIID riid, 
        PVOID* ppv 
        );
    
    // Implement IKsInterfaceHandler
    
    STDMETHODIMP
    KsSetPin( 
        IN IKsPin *KsPin 
        );
    
    STDMETHODIMP 
    KsProcessMediaSamples( 
        IN IKsDataTypeHandler *KsDataTypeHandler,
        IN IMediaSample** SampleList, 
        IN OUT PLONG SampleCount, 
        IN KSIOOPERATION IoOperation,
        OUT PKSSTREAM_SEGMENT *StreamSegment
        );
        
    STDMETHODIMP
    KsCompleteIo(
        IN PKSSTREAM_SEGMENT StreamSegment
        );
        
private:
    CLSID     m_ClsID;
    IKsPinEx  *m_KsPinEx;
    HANDLE    m_PinHandle;

    CStandardInterfaceHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        REFCLSID ClsID,
        HRESULT* hr
        );
};

#endif // __KSINTERF__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksinterf\ksinterf.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksinterf.cpp

Abstract:

    This module implements the IKsInterfaceHandler interface for 
    the standard interfaces.

Author:

    Bryan A. Woodruff (bryanw) 1-Apr-1997

--*/

#include <windows.h>
#include <streams.h>
#include "devioctl.h"
#include "ks.h"
#include "ksmedia.h"
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include "ksinterf.h"

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = 
{
    {
        L"StandardInterfaceHandler", 
        &KSINTERFACESETID_Standard,
        CStandardInterfaceHandler::CreateInstance,
        NULL,
        NULL
    }
};
int g_cTemplates = SIZEOF_ARRAY( g_Templates );

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


CUnknown*
CALLBACK
CStandardInterfaceHandler::CreateInstance(
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT* hr
    )
/*++

Routine Description:

    This is called by KS proxy code to create an instance of an
    interface handler. It is referred to in the g_Templates structure.

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;
    
    DbgLog(( 
        LOG_TRACE, 
        0, 
        TEXT("CStandardInterfaceHandler::CreateInstance()")));

    Unknown = 
        new CStandardInterfaceHandler( 
                UnkOuter, 
                NAME("Standard Data Type Handler"), 
                KSINTERFACESETID_Standard,
                hr);
                
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CStandardInterfaceHandler::CStandardInterfaceHandler(
    IN LPUNKNOWN   UnkOuter,
    IN TCHAR*      Name,
    IN REFCLSID    ClsID,
    OUT HRESULT*   hr
    ) :
    CUnknown( Name, UnkOuter ),
    m_ClsID( ClsID )
/*++

Routine Description:

    The constructor for the interface handler object. 

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    IN TCHAR *Name -
        The name of the object, used for debugging.
        
    IN REFCLSID ClsID -
        The CLSID of the object.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    *hr = NOERROR;
} 


STDMETHODIMP
CStandardInterfaceHandler::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsInterfaceHandler.

Arguments:

    IN REFIID riid -
        The identifier of the interface to return.

    OUT PVOID *ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IKsInterfaceHandler)) {
        return GetInterface(static_cast<IKsInterfaceHandler*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CStandardInterfaceHandler::KsSetPin(
    IN IKsPin *KsPin
    )
/*++

Routine Description:

    Implements the IKsInterfaceHandler::KsSetPin method. This is used to
    inform the streaming interface handler which pin it should be
    communicating with when passing data. This is set after the instance
    is created, but before any streaming is required of the instance.

    The function obtains the handle to the kernel mode pin.

Arguments:

    KsPin -
        Contains the interface to the pin to which this streaming interface
        handler is to be attached. It is assumed that this pin supports the
        IKsObject interface from which the underlying kernel handle can be
        obtained.

Return Value:

    Returns NOERROR if the pin passed was valid, else E_UNEXPECTED, or some
    QueryInterface error.

--*/
{
    IKsObject*  Object;
    HRESULT     hr;

    hr = KsPin->QueryInterface(__uuidof(IKsPinEx), reinterpret_cast<PVOID*>(&m_KsPinEx));
    if (SUCCEEDED( hr )) {
        //
        // Do not hold a cyclic reference to the pin.
        //
        m_KsPinEx->Release();
    } else {
        return hr;
    }
    
    hr = KsPin->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
    //
    // The object must support the IKsObject interface in order to obtain
    // the handle to the kernel mode pin.
    //
    if (SUCCEEDED(hr)) {
        m_PinHandle = Object->KsGetObjectHandle();
        Object->Release();
        if (!m_PinHandle) {
            hr = E_UNEXPECTED;
            m_KsPinEx = NULL;
        }
    }
    return hr;
} 


STDMETHODIMP
GetSampleProperties(
    IN IMediaSample *Sample,
    OUT AM_SAMPLE2_PROPERTIES *SampleProperties
    )
/*++

Routine Description:

    Retrieves the properties of the given sample object. This is function
    obtains the sample properties even if the IMediaSample2 interface is
    not supported by the sample object. Note that the end time of a sample
    is corrected to not contain the incorrect value returned by the base
    classes.

Arguments:

    Sample -
        Contains the sample object whose properties are to be obtained. This
        object may or may not support IMediaSample2.

    SampleProperties -
        The place in which to put the sample properties retrieved.

Return Value:

    Returns NOERROR if the properties were retrieved, else any GetProperties
    error.

--*/
{
    HRESULT hr;

    //
    // This code was borrowed from the base class.
    //
    
    IMediaSample2 *Sample2;
    
    if (SUCCEEDED( Sample->QueryInterface(
                        __uuidof(IMediaSample2),
                        reinterpret_cast<PVOID*>(&Sample2) ) )) {
        //
        // If IMediaSample2 is supported, retrieving the properties
        // is easy.
                               
        hr = 
            Sample2->GetProperties(
                sizeof( *SampleProperties ), 
                reinterpret_cast<PBYTE>(SampleProperties) );
        Sample2->Release();
        SampleProperties->dwSampleFlags &= ~AM_SAMPLE_TYPECHANGED;
        if (!(SampleProperties->dwSampleFlags & AM_SAMPLE_TIMEVALID)) {
            SampleProperties->tStart = 0;
        }
        if (!(SampleProperties->dwSampleFlags & AM_SAMPLE_STOPVALID)) {
            //
            // Ignore the incorrect end time returned from any
            // IMediaSample implementation.
            //
            SampleProperties->tStop = SampleProperties->tStart;
        }
        
        if (FAILED( hr )) {
            return hr;
        }
    } else {
        //
        // Otherwise build the properties using the old interface.
        //
        
        SampleProperties->cbData = sizeof( *SampleProperties );
        SampleProperties->dwTypeSpecificFlags = 0;
        SampleProperties->dwStreamId = AM_STREAM_MEDIA;
        SampleProperties->dwSampleFlags = 0;
        if (S_OK == Sample->IsDiscontinuity()) {
            SampleProperties->dwSampleFlags |= AM_SAMPLE_DATADISCONTINUITY;
        }
        if (S_OK == Sample->IsPreroll()) {
            SampleProperties->dwSampleFlags |= AM_SAMPLE_PREROLL;
        }
        if (S_OK == Sample->IsSyncPoint()) {
            SampleProperties->dwSampleFlags |= AM_SAMPLE_SPLICEPOINT;
        }
        //
        // This call can return an informational status if the end time
        // is not set. This will never happen because the only way an
        // end time will not be valid while the start time is, is if the
        // IMediaSample2 interface is supported, which in this case it
        // is not. However, a client may be trying to do this, thus the
        // check below.
        //
        hr = Sample->GetTime(
            &SampleProperties->tStart,
            &SampleProperties->tStop);
        if (SUCCEEDED(hr)) {
            SampleProperties->dwSampleFlags |= AM_SAMPLE_TIMEVALID;
            if (SampleProperties->tStop != SampleProperties->tStart) {
                //
                // The only way to specify no valid stop time with the
                // SetTime interface is to make tStop == tStart. This means
                // that a zero duration frame, which has a valid stop time
                // cannot be created.
                //
                SampleProperties->dwSampleFlags |= AM_SAMPLE_STOPVALID;
            }
        } else {
            SampleProperties->tStart = 0;
            SampleProperties->tStop = 0;
        }
        Sample->GetPointer(&SampleProperties->pbBuffer);
        SampleProperties->lActual = Sample->GetActualDataLength();
        SampleProperties->cbBuffer = Sample->GetSize();
    }
    return S_OK;
}
   

STDMETHODIMP 
CStandardInterfaceHandler::KsProcessMediaSamples( 
    IN IKsDataTypeHandler *KsDataTypeHandler,
    IN IMediaSample** SampleList, 
    IN OUT PLONG SampleCount, 
    IN KSIOOPERATION IoOperation,
    OUT PKSSTREAM_SEGMENT *StreamSegment
    )
/*++

Routine Description:

    Implements the IKsInterfaceHandler::KsProcessMediaSamples method. This
    function moves samples from or to the previously assigned filter pin.
    A stream header is initialized to represent each media sample in the
    stream segment. The I/O is then performed, the count of wait items is
    incremented, and the proxy I/O thread waits for completion.

Arguments:

    KsDataTypeHandler -
        Contains the interface to the data type handler for these media
        samples. This is the handler which knows the specifics about the
        particular media type being streamed.

    SampleList -
        Contains the list of samples to process.

    SampleCount -
        Contains the count of samples in SampleList. Is updated with the
        actual number of samples processed.

    IoOperation -
        Indicates the type of I/O operation to perform on the samples.
        This is KsIoOperation_Write or KsIoOperation_Read.

    StreamSegment -
        The place in which to put the pointer to the stream segment
        representing the headers sent to the kernel mode pin.

Return Value:

    Returns NOERROR if the samples were processed, else some memory allocation
    or an error from querying IMediaSample.

--*/
{
    int                     i;
    AM_SAMPLE2_PROPERTIES   SampleProperties;
    HRESULT                 hr;
    PKSSTREAM_HEADER        CurrentHeader;
    PKSSTREAM_SEGMENT_EX2   StreamSegmentEx;
    ULONG                   SizeOfStreamHeaders, Written;
    
    //
    // Allocate an extended stream segment
    //
        
    *StreamSegment = NULL;
    StreamSegmentEx = new KSSTREAM_SEGMENT_EX2;
    if (NULL == StreamSegmentEx) {
        *SampleCount = 0;
        return E_OUTOFMEMORY;
    }
    
    //
    // Create the event to be signalled on I/O completion
    //
    StreamSegmentEx->Common.CompletionEvent = 
        CreateEvent( 
            NULL,       // LPSECURITY_ATTRIBUTES lpEventAttributes
            TRUE,       // BOOL bManualReset
            FALSE,      // BOOL bInitialState
            NULL );     // LPCTSTR lpName
            
    if (!StreamSegmentEx->Common.CompletionEvent) {
        DWORD   LastError;

        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32( LastError );
        DbgLog((
            LOG_TRACE,
            0,
            TEXT("CStandardInterfaceHandler::KsProcessMediaSamples, failed to allocate event: %08x"),
            hr));
        *SampleCount = 0;
        delete StreamSegmentEx;
        return hr;        
    }
    
    //
    // The interface handler needs to stay present until this
    // stream segment has been completed. KsCompleteIo will then
    // release the object.
    //
    AddRef();
    StreamSegmentEx->Common.KsInterfaceHandler = this;
    
    //
    // The KsDataTypeHandler may be NULL.
    //
    StreamSegmentEx->Common.KsDataTypeHandler = KsDataTypeHandler;
    StreamSegmentEx->Common.IoOperation = IoOperation;
    
    //
    // If a data handler is specified, query for the extended
    // header size.
    //
    
    if (StreamSegmentEx->Common.KsDataTypeHandler) {
        
        StreamSegmentEx->Common.KsDataTypeHandler->KsQueryExtendedSize( 
            &StreamSegmentEx->ExtendedHeaderSize );
            
        //
        // If an extended header size is specified, then AddRef() the
        // data handler interface, otherwise we don't need to keep
        // the pointer around.
        //
        if (StreamSegmentEx->ExtendedHeaderSize) {
            StreamSegmentEx->Common.KsDataTypeHandler->AddRef();
        } else {
            StreamSegmentEx->Common.KsDataTypeHandler = NULL;
        }
    } else {
        StreamSegmentEx->ExtendedHeaderSize = 0;
    }
    
    StreamSegmentEx->SampleCount = *SampleCount;
    
    //
    // Allocate the stream headers with the appropriate header sizes
    //
    
    SizeOfStreamHeaders =
        (sizeof( KSSTREAM_HEADER ) +         
            StreamSegmentEx->ExtendedHeaderSize) * *SampleCount;
     
    StreamSegmentEx->StreamHeaders = 
        (PKSSTREAM_HEADER)
            new BYTE[ SizeOfStreamHeaders ];
    if (NULL == StreamSegmentEx->StreamHeaders) {
        if (StreamSegmentEx->Common.KsDataTypeHandler) {
            StreamSegmentEx->Common.KsDataTypeHandler->Release();
        }
        Release();
        delete StreamSegmentEx;
        *SampleCount = 0;
        return E_OUTOFMEMORY;
    }
    
    RtlZeroMemory( 
        StreamSegmentEx->StreamHeaders, 
        SizeOfStreamHeaders );
    
    //
    // For each sample, initialize the header.
    //
    
    CurrentHeader = StreamSegmentEx->StreamHeaders;
    for (i = 0; i < *SampleCount; i++) {
        if (StreamSegmentEx->ExtendedHeaderSize) {
            StreamSegmentEx->Common.KsDataTypeHandler->KsPrepareIoOperation( 
                SampleList[ i ],
                (PVOID)CurrentHeader,
                StreamSegmentEx->Common.IoOperation );
        }
        
        //
        // Copy data pointers, set time stamps, etc.
        //
        
        if (SUCCEEDED(hr = ::GetSampleProperties( 
                            SampleList[ i ],
                            &SampleProperties ) )) {
                            
            CurrentHeader->OptionsFlags =
                SampleProperties.dwSampleFlags;
            CurrentHeader->Size = sizeof( KSSTREAM_HEADER ) +
                StreamSegmentEx->ExtendedHeaderSize;
            CurrentHeader->TypeSpecificFlags = 
                SampleProperties.dwTypeSpecificFlags;    
            CurrentHeader->PresentationTime.Time = SampleProperties.tStart;
            CurrentHeader->PresentationTime.Numerator = 1;
            CurrentHeader->PresentationTime.Denominator = 1;
            CurrentHeader->Duration = 
                SampleProperties.tStop - SampleProperties.tStart;
            CurrentHeader->Data = SampleProperties.pbBuffer;
            CurrentHeader->FrameExtent = SampleProperties.cbBuffer;
            
            if (IoOperation == KsIoOperation_Write) {
                CurrentHeader->DataUsed = SampleProperties.lActual;
            }
            
            //
            // Add the sample to the sample list.
            //
            
            StreamSegmentEx->Samples[ i ] = SampleList[ i ];
            
            //
            // If this is a write operation, hold the sample by 
            // incrementing the reference count. This is released
            // on completion of the write.
            //
            if (StreamSegmentEx->Common.IoOperation == KsIoOperation_Write) {
                StreamSegmentEx->Samples[ i ]->AddRef();
            }
            
        } else {
            //
            // This is considered a fatal error.
            //
            
            DbgLog(( 
                LOG_TRACE, 
                0, 
                TEXT("::GetSampleProperties failed")));
        
            
            if (i) {
                //
                // Undo any of the work performed above.
                //

                CurrentHeader = 
                    reinterpret_cast<PKSSTREAM_HEADER>
                        (reinterpret_cast<PBYTE>(CurrentHeader) - 
                            (sizeof( KSSTREAM_HEADER ) +
                                StreamSegmentEx->ExtendedHeaderSize));
                
                for (--i; i >= 0; i--) {
                    StreamSegmentEx->Common.KsDataTypeHandler->KsCompleteIoOperation( 
                        StreamSegmentEx->Samples[ i ],
                        reinterpret_cast<PVOID>(CurrentHeader),
                        StreamSegmentEx->Common.IoOperation,
                        TRUE ); // BOOL Cancelled
                        
                    //
                    // Didn't get a chance to AddRef() the sample, do
                    // not release it.
                    //                        
                     
                    CurrentHeader = 
                        reinterpret_cast<PKSSTREAM_HEADER>
                            (reinterpret_cast<PBYTE>(CurrentHeader) - 
                                (sizeof( KSSTREAM_HEADER ) +
                                    StreamSegmentEx->ExtendedHeaderSize));
                }
            }
            
            delete StreamSegmentEx->StreamHeaders;
            if (StreamSegmentEx->Common.KsDataTypeHandler) {
                StreamSegmentEx->Common.KsDataTypeHandler->Release();
            }
            Release();
            delete StreamSegmentEx;
            *SampleCount = 0;
            return hr;
        }
        CurrentHeader = 
            reinterpret_cast<PKSSTREAM_HEADER>
                (reinterpret_cast<PBYTE>(CurrentHeader) + 
                    sizeof( KSSTREAM_HEADER ) +
                        StreamSegmentEx->ExtendedHeaderSize);
    }
    
    //
    // Write the stream header to the device and return.
    //
    
    StreamSegmentEx->Overlapped.hEvent = 
        StreamSegmentEx->Common.CompletionEvent;
    m_KsPinEx->KsIncrementPendingIoCount();
    
    if (!DeviceIoControl( 
            m_PinHandle,
            (IoOperation == KsIoOperation_Write) ? 
                IOCTL_KS_WRITE_STREAM : IOCTL_KS_READ_STREAM,
            NULL,
            0,
            StreamSegmentEx->StreamHeaders,
            SizeOfStreamHeaders,
            &Written,
            &StreamSegmentEx->Overlapped )) {
        DWORD   LastError;

        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32(LastError);
        //
        // On a failure case signal the event, but do not decrement the
        // pending I/O count, since this is done in the completion
        // routine already.
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
            hr = S_OK;
        } else {
            SetEvent( StreamSegmentEx->Overlapped.hEvent );
        }
    } else {
        //
        // Completed synchronously -- signal the event so that I/O processing 
        // will continue.  Note that the event is not signalled via 
        // DeviceIoControl() in this case.
        //
        
        SetEvent( StreamSegmentEx->Overlapped.hEvent );
        hr = S_OK;
    }
    
    *StreamSegment = reinterpret_cast<PKSSTREAM_SEGMENT>(StreamSegmentEx);
    
    return hr;
}    


STDMETHODIMP
CStandardInterfaceHandler::KsCompleteIo(
    IN PKSSTREAM_SEGMENT StreamSegment
    )
/*++

Routine Description:

    Implements the IKsInterfaceHandler::KsCompleteIo method. This function
    cleans up after I/O initiated by KsProcessMediaSamples. It discards
    allocated memory, updates the media samples and delivers them on a Read
    operation, and decrements the count of wait items for the proxy.

Arguments:

    StreamSegment -
        Contains the previously allocated stream segment which is being
        completed. This is called because the event was signalled for this
        stream segment, indicating that the kernel mode pin completed the
        I/O.

Return Value:

    Returns NOERROR.

--*/
{
    int                     i;
    BOOL                    Succeeded;
    PKSSTREAM_HEADER        CurrentHeader;
    PKSSTREAM_SEGMENT_EX2   StreamSegmentEx;
    ULONG                   Error, Returned;
    
    //
    // Clean up extended headers and release media samples.
    //
    
    StreamSegmentEx = (PKSSTREAM_SEGMENT_EX2) StreamSegment;
    CurrentHeader = StreamSegmentEx->StreamHeaders;
    
    Succeeded = 
        GetOverlappedResult( 
            m_PinHandle,
            &StreamSegmentEx->Overlapped,
            &Returned,
            FALSE );
    Error = (Succeeded ? NOERROR : GetLastError());
    
    for (i = 0; i < StreamSegmentEx->SampleCount; i++) {
        if (!Succeeded) {
            DbgLog(( 
                LOG_TRACE, 
                0, 
                TEXT("StreamSegment %08x failed"), StreamSegmentEx ));
                
            m_KsPinEx->KsNotifyError(
                StreamSegmentEx->Samples[ i ],
                HRESULT_FROM_WIN32( Error ) );
        }                
        
        // Millennium and beyond, copy the TypeSpecificFlags if non-zero
        if (StreamSegmentEx->StreamHeaders[i].TypeSpecificFlags) {
            IMediaSample2 * MediaSample2;
            HRESULT hr;

            hr = StreamSegmentEx->Samples[i]->QueryInterface(__uuidof(IMediaSample2), 
                                                             reinterpret_cast<PVOID*>(&MediaSample2));
            if (SUCCEEDED( hr )) {
                AM_SAMPLE2_PROPERTIES Sample2Properties;

                MediaSample2->GetProperties(FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, lActual), 
                                            (PBYTE)&Sample2Properties);
                Sample2Properties.cbData = FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, lActual);
                // Copy the type specific flags
                Sample2Properties.dwTypeSpecificFlags = StreamSegmentEx->StreamHeaders[i].TypeSpecificFlags;
                // There's no way to set TimeDiscontinuity from IMediaSample, so we must
                // copy this single bit here
                Sample2Properties.dwSampleFlags |= (StreamSegmentEx->StreamHeaders[i].OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY);
                MediaSample2->SetProperties(FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, lActual), 
                                            (PBYTE)&Sample2Properties);
                MediaSample2->Release();
            }
        }
        // end Millennium and beyond, copy the TypeSpecificFlags if non-zero


        if (StreamSegmentEx->ExtendedHeaderSize) {
            StreamSegmentEx->Common.KsDataTypeHandler->KsCompleteIoOperation( 
                StreamSegmentEx->Samples[ i ],
                reinterpret_cast<PVOID>(CurrentHeader),
                StreamSegmentEx->Common.IoOperation,
                !Succeeded );
        }        
        
        if (StreamSegmentEx->Common.IoOperation != KsIoOperation_Read) {
            //
            // We're going nowhere else with this sample, OK to release.
            //
            StreamSegmentEx->Samples[ i ]->Release();
        
        } else {
        
            //
            // If this is a read operation, deliver the sample to the input
            // pin.  IKsPin->KsDeliver() simply calls the base class to
            // deliver the sample to the connected input pin.
            //
        
            REFERENCE_TIME  tStart, *ptStart, tStop, *ptStop;
        
            //
            // Reflect stream header information in IMediaSample
            //
            
            //
            // (gubgub) Need to reflect media type change here!
            // There is no exisitng driver that will automously change
            // media type midstream. Nor can I see any in near future. 
            // To be complete, still, the type change shall be reflected. 
            // A separate is to be created to track this.
            // 
            
            ptStart = ptStop = NULL;
            
            if (Succeeded) {
                
                StreamSegmentEx->Samples[ i ]->SetDiscontinuity(
                    CurrentHeader->OptionsFlags & 
                        KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY );
                StreamSegmentEx->Samples[ i ]->SetPreroll(
                    CurrentHeader->OptionsFlags &
                        KSSTREAM_HEADER_OPTIONSF_PREROLL
                    );
                StreamSegmentEx->Samples[ i ]->SetSyncPoint(
                    CurrentHeader->OptionsFlags &
                        KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT
                    );
                    
                if (CurrentHeader->OptionsFlags & 
                        KSSTREAM_HEADER_OPTIONSF_TIMEVALID) {
                    tStart = CurrentHeader->PresentationTime.Time;
                    ptStart = &tStart;
                    if (CurrentHeader->OptionsFlags &
                            KSSTREAM_HEADER_OPTIONSF_DURATIONVALID) {
                        tStop = 
                            tStart + CurrentHeader->Duration;
                        ptStop = &tStop;
                    } 
                }
            }
                  
            if (FAILED(StreamSegmentEx->Samples[ i ]->SetTime( ptStart, ptStop )) && !ptStop) {
                //
                // There is no way to specify that the duration is
                // not valid through old SetTime. This means that a
                // zero duration sample with a valid duration cannot
                // be passed. GetSampleProperties makes the assumption
                // that if tStart == tStop on old GetTime, then the
                // duration is not valid.
                //
                StreamSegmentEx->Samples[ i ]->SetTime( ptStart, ptStart );
            }
                
            ASSERT( CurrentHeader->FrameExtent == 
                    static_cast<ULONG>(StreamSegmentEx->Samples[ i ]->GetSize()) );
            StreamSegmentEx->Samples[ i ]->SetActualDataLength( 
                (Succeeded) ? CurrentHeader->DataUsed : 0 );
            
            //
            // To avoid a chicken-vs-egg situation, the KsDeliver method
            // releases the sample so that when queuing buffers to the
            // device, we can retreive this sample if it is the last
            // sample.
            //
            
            if (Succeeded) {
                m_KsPinEx->KsDeliver( 
                    StreamSegmentEx->Samples[ i ], 
                    CurrentHeader->OptionsFlags );
            }                    
            else {
                //
                // Don't deliver cancelled packets or errors.
                //
                StreamSegmentEx->Samples[ i ]->Release();
            } 
        }
        
        CurrentHeader = 
            reinterpret_cast<PKSSTREAM_HEADER>
                (reinterpret_cast<PBYTE>(CurrentHeader) + 
                    sizeof( KSSTREAM_HEADER ) +
                        StreamSegmentEx->ExtendedHeaderSize);
    }   
    
    delete [] StreamSegmentEx->StreamHeaders;
    if (StreamSegmentEx->ExtendedHeaderSize) {
        StreamSegmentEx->Common.KsDataTypeHandler->Release();
    }
    
    m_KsPinEx->KsDecrementPendingIoCount();
    m_KsPinEx->KsMediaSamplesCompleted( StreamSegment );
    
    delete StreamSegmentEx;
    
    //
    // This was previously AddRef'd in KsProcessMediaSamples to keep this
    // instance present.
    //
    Release();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksolay\ksolay.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksolay.h

Abstract:

    Internal header.

--*/

class COverlay :
    public CUnknown,
#ifdef __IOverlayNotify2_FWD_DEFINED__
    public IOverlayNotify2,
#else // !__IOverlayNotify2_FWD_DEFINED__
    public IOverlayNotify,
#endif // !__IOverlayNotify2_FWD_DEFINED__
    public IDistributorNotify {

public:
    DECLARE_IUNKNOWN

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

#ifdef __IOverlayNotify2_FWD_DEFINED__
    static LRESULT CALLBACK PaintWindowCallback(
        HWND Window,
        UINT Message,
        WPARAM wParam,
        LPARAM lParam
        );
#endif // __IOverlayNotify2_FWD_DEFINED__

    COverlay(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);
    ~COverlay();

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);

#ifdef __IOverlayNotify2_FWD_DEFINED__
    STDMETHODIMP_(HWND)
    CreateFullScreenWindow( 
        PRECT MonitorRect
        );
#endif // __IOverlayNotify2_FWD_DEFINED__

    // Implement IOverlayNotify2
    STDMETHODIMP OnPaletteChange( 
        DWORD Colors,
        const PALETTEENTRY* Palette);
    STDMETHODIMP OnClipChange( 
        const RECT* Source,
        const RECT* Destination,
        const RGNDATA* Region);
    STDMETHODIMP OnColorKeyChange( 
        const COLORKEY* ColorKey);
    STDMETHODIMP OnPositionChange( 
        const RECT* Source,
        const RECT* Destination);
#ifdef __IOverlayNotify2_FWD_DEFINED__
    STDMETHODIMP OnDisplayChange( 
        HMONITOR Monitor
        );
#endif // __IOverlayNotify2_FWD_DEFINED__

    // Implement IDistributorNotify
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME Start);
    STDMETHODIMP SetSyncSource(IReferenceClock* RefClock);
    STDMETHODIMP NotifyGraphChange();

private:
    HANDLE m_Object;
    IOverlay* m_Overlay;
    IUnknown* m_UnkOwner;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksproxy\fmtchng.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    fmtchng.cpp

Abstract:

    This module implements the CFormatChangeHandler class which provides
    a private interface handler for in-stream format changes.

Author(s):

    Bryan A. Woodruff (bryanw) 12-May-1997

--*/

#include <windows.h>
#include <streams.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <tchar.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>
#include "ksiproxy.h"


CFormatChangeHandler::CFormatChangeHandler(
    IN LPUNKNOWN   UnkOuter,
    IN TCHAR*      Name,
    OUT HRESULT*   hr
    ) :
    CUnknown( Name, UnkOuter, hr )
/*++

Routine Description:

    The constructor for the data handler object. 

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    IN TCHAR *Name -
        The name of the object, used for debugging.
        
    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
} 


STDMETHODIMP
CFormatChangeHandler::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsInterfaceHandler.

Arguments:

    IN REFIID riid -
        The identifier of the interface to return.

    OUT PVOID *ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IKsInterfaceHandler)) {
        return GetInterface(static_cast<IKsInterfaceHandler*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CFormatChangeHandler::KsSetPin( 
    IN IKsPin *KsPin 
    )
{
    IKsObject*  Object;
    HRESULT     hr;

    hr = KsPin->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
    if (SUCCEEDED(hr)) {
        m_PinHandle = Object->KsGetObjectHandle();
        Object->Release();
        if (m_PinHandle) {
            m_KsPin = KsPin;
        } else {
            hr = E_UNEXPECTED;
        }
    }
    return hr;
} 


STDMETHODIMP 
CFormatChangeHandler::KsProcessMediaSamples( 
    IN IKsDataTypeHandler *KsDataTypeHandler,
    IN IMediaSample** SampleList, 
    IN OUT PLONG SampleCount, 
    IN KSIOOPERATION IoOperation,
    OUT PKSSTREAM_SEGMENT *StreamSegment
    )
{
    AM_MEDIA_TYPE           *MediaType;
    HRESULT                 hr;
    REFERENCE_TIME          tStart, tStop;
    PKSDATAFORMAT           DataFormat;
    PKSSTREAM_SEGMENT_EX    StreamSegmentEx;
    ULONG                   DataFormatSize, Written;
    DECLARE_KSDEBUG_NAME(EventName);

    //
    // This special interface handler allows no data types and only
    // one data format to be specified in the sample array.
    //

    ASSERT( KsDataTypeHandler == NULL );
    ASSERT( *SampleCount == 1 );
    
    hr = 
        SampleList[ 0 ]->GetMediaType( &MediaType );
       
    if (FAILED( hr )) {
        return hr;
    }
    
    hr = ::InitializeDataFormat(
        static_cast<CMediaType*>(MediaType),
        0,
        reinterpret_cast<void**>(&DataFormat),
        &DataFormatSize);
    DeleteMediaType( MediaType );

    if (FAILED(hr)) {
        return hr;
    }
    
    //
    // Allocate an extended stream segment
    //
        
    *StreamSegment = NULL;
    StreamSegmentEx = new KSSTREAM_SEGMENT_EX;
    if (NULL == StreamSegmentEx) {
        *SampleCount = 0;
        return E_OUTOFMEMORY;
    }
    
    RtlZeroMemory( 
        StreamSegmentEx,
        sizeof( *StreamSegmentEx ) );
    
    //
    // Create the event to be signalled on I/O completion
    //
    BUILD_KSDEBUG_NAME(EventName, _T("EvStreamSegmentEx#%p"), StreamSegmentEx);
    StreamSegmentEx->Common.CompletionEvent = 
        CreateEvent( 
            NULL,       // LPSECURITY_ATTRIBUTES lpEventAttributes
            TRUE,       // BOOL bManualReset
            FALSE,      // BOOL bInitialState
            KSDEBUG_NAME(EventName) );     // LPCTSTR lpName
    ASSERT(KSDEBUG_UNIQUE_NAME());
            
    if (!StreamSegmentEx->Common.CompletionEvent) {
        DWORD   LastError;

        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32( LastError );
        DbgLog((
            LOG_TRACE,
            0,
            TEXT("CFormatChangeHandler::KsProcessMediaSamples, failed to allocate event: %08x"),
            hr));
        *SampleCount = 0;
        delete StreamSegmentEx;
        return hr;        
    }
    
    AddRef();
    StreamSegmentEx->Common.KsInterfaceHandler = static_cast<IKsInterfaceHandler*>(this);
    StreamSegmentEx->Common.IoOperation = IoOperation;
    
    //
    // Initialize the stream header.
    //
    
    StreamSegmentEx->StreamHeader.OptionsFlags =
        KSSTREAM_HEADER_OPTIONSF_TYPECHANGED;
        
    StreamSegmentEx->StreamHeader.Size = sizeof(KSSTREAM_HEADER);
    StreamSegmentEx->StreamHeader.TypeSpecificFlags = 0;
    if (S_OK == SampleList[ 0 ]->GetTime( &tStart, &tStop )) {
        StreamSegmentEx->StreamHeader.OptionsFlags |=
            KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
            KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;

        StreamSegmentEx->StreamHeader.PresentationTime.Time = tStart;
        StreamSegmentEx->StreamHeader.PresentationTime.Numerator = 1;
        StreamSegmentEx->StreamHeader.PresentationTime.Denominator = 1;
        StreamSegmentEx->StreamHeader.Duration = tStop - tStart;
    }
        
    StreamSegmentEx->StreamHeader.Data = DataFormat;
    StreamSegmentEx->StreamHeader.FrameExtent = DataFormatSize;
    StreamSegmentEx->StreamHeader.DataUsed = DataFormatSize;
    StreamSegmentEx->Sample = SampleList[ 0 ];
    StreamSegmentEx->Sample->AddRef();
    
    //
    // Write the stream header to the device and return.
    //
    
    StreamSegmentEx->Overlapped.hEvent = 
        StreamSegmentEx->Common.CompletionEvent;
    m_KsPin->KsIncrementPendingIoCount();
    
    
    if (!DeviceIoControl( 
            m_PinHandle,
            IOCTL_KS_WRITE_STREAM,
            NULL,
            0,
            &StreamSegmentEx->StreamHeader,
            sizeof( KSSTREAM_HEADER ),
            &Written,
            &StreamSegmentEx->Overlapped )) {
        DWORD   LastError;

        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32(LastError);
        //
        // On a failure case signal the event, but do not decrement the
        // pending I/O count, since this is done in the completion
        // routine already.
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
            hr = S_OK;
        } else {
            SetEvent( StreamSegmentEx->Overlapped.hEvent );
        }
    } else {
        //
        // Completed synchronously -- signal the event so that I/O processing 
        // will continue.  Note that the event is not signalled via 
        // DeviceIoControl() in this case.
        //
        
        SetEvent( StreamSegmentEx->Overlapped.hEvent );
        hr = S_OK;
    }
    
    *StreamSegment = reinterpret_cast<PKSSTREAM_SEGMENT>(StreamSegmentEx);
    
    return hr;
}


STDMETHODIMP
CFormatChangeHandler::KsCompleteIo(
    IN PKSSTREAM_SEGMENT StreamSegment
    )
{
    PKSSTREAM_SEGMENT_EX    StreamSegmentEx;
    
    //
    // Clean up extended headers and release media samples.
    //
    
    StreamSegmentEx = reinterpret_cast<PKSSTREAM_SEGMENT_EX>(StreamSegment);
    
    //
    // According to the base class documentation, the receiving pin
    // will AddRef() the sample if it keeps it so it is safe to release
    // the sample for read or write operations.
    // 
    
    StreamSegmentEx->Sample->Release();
    CoTaskMemFree(StreamSegmentEx->StreamHeader.Data);
    delete StreamSegmentEx;
    
    //
    // No need to call KsMediaSamplesCompleted() here.
    //
    m_KsPin->KsDecrementPendingIoCount();
    Release();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksproxy\ksalloc.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksalloc.cpp

Abstract:

    Memory allocator proxy

Author:

    Bryan A. Woodruff (bryanw) 14-Apr-1997

--*/

            
#include <windows.h>
#ifdef WIN9X_KS
#include <comdef.h>
#endif // WIN9X_KS
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <memory.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>
#include "ksiproxy.h"

            
CKsAllocator::CKsAllocator(
    TCHAR* ObjectName,
    IUnknown *UnknownOuter,
    IPin *Pin,
    HANDLE FilterHandle,
    HRESULT *hr) :
        CMemAllocator( 
            ObjectName,
            UnknownOuter,
            hr 
            ),
        m_AllocatorHandle( NULL ),
        m_AllocatorMode( KsAllocatorMode_Kernel ),
        m_FilterHandle( NULL ),
        m_OwnerPin( NULL )

{
    
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("CKsAllocator::CKsAllocator()")));
}    
    
CKsAllocator::~CKsAllocator()
{
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("CKsAllocator::~CKsAllocator()")));

    if (m_AllocatorHandle) {
        CloseHandle( m_AllocatorHandle );
    }
}

STDMETHODIMP 
CKsAllocator::QueryInterface(
    REFIID riid, 
    PVOID* ppv)
/*++

Routine Description:

    Implement the IUnknown::QueryInterface method. This just passes the query
    to the owner IUnknown object, which may pass it to the nondelegating
    method implemented on this object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE.

--*/
{
    return GetOwner()->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) 
CKsAllocator::AddRef(
    )
/*++

Routine Description:

    Implement the IUnknown::AddRef method. This just passes the AddRef
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    return GetOwner()->AddRef();
}


STDMETHODIMP_(ULONG) 
CKsAllocator::Release(
    )
/*++

Routine Description:

    Implement the IUnknown::Release method. This just passes the Release
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    return GetOwner()->Release();
}



STDMETHODIMP 
CKsAllocator::NonDelegatingQueryInterface(
    REFIID riid, 
    void **ppv
    )
/*++

Routine Description:

    Implement the CUnknown::NonDelegatingQueryInterface method. This
    returns interfaces supported by this object or supported by the
    base object.

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE, or possibly some memory error.

--*/
{
    if (riid == __uuidof(IKsAllocator) || riid == __uuidof(IKsAllocatorEx)) {
        return GetInterface( static_cast<IKsAllocatorEx*>(this), ppv );
    }
    return CMemAllocator::NonDelegatingQueryInterface( riid, ppv );
}



STDMETHODIMP_( VOID )
CKsAllocator::KsSetAllocatorHandle(
    HANDLE AllocatorHandle 
    )
{
    m_AllocatorHandle = AllocatorHandle;
}



STDMETHODIMP_(HANDLE)
CKsAllocator::KsCreateAllocatorAndGetHandle(
    IKsPin*   KsPin
)

{
    HANDLE               PinHandle;
    KSALLOCATOR_FRAMING  Framing;
    HRESULT              hr;
    IKsPinPipe*          KsPinPipe = NULL;
   
   
    if (m_AllocatorHandle) {
        CloseHandle( m_AllocatorHandle );
        m_AllocatorHandle = NULL;
    }
   
    PinHandle = ::GetObjectHandle( KsPin );
    if (! PinHandle) {
        return ((HANDLE) NULL);
    }
   
    hr = KsPin->QueryInterface( __uuidof(IKsPinPipe), reinterpret_cast<PVOID*>(&KsPinPipe) );
    if (! SUCCEEDED( hr )) {
        ASSERT(0);
        return ((HANDLE) NULL);
    }
   
    Framing.OptionsFlags = KSALLOCATOR_OPTIONF_SYSTEM_MEMORY;
    Framing.Frames = m_AllocatorPropertiesEx.cBuffers;
    Framing.FrameSize = m_AllocatorPropertiesEx.cbBuffer;
    Framing.FileAlignment = (ULONG) (m_AllocatorPropertiesEx.cbAlign - 1);
   
    if (m_AllocatorPropertiesEx.LogicalMemoryType == KS_MemoryTypeKernelPaged) {
        Framing.PoolType = PagedPool;
    }
    else {
        Framing.PoolType = NonPagedPool;
    }
   
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("PIPES ATTN CKsAllocator::KsGetAllocatorAndGetHandle, creating allocator %s(%s) %x %d %d %d %x"),
        KsPinPipe->KsGetFilterName(),
        KsPinPipe->KsGetPinName(),
        KsPin,
        Framing.Frames, Framing.FrameSize, Framing.FileAlignment, Framing.OptionsFlags));
    
    
    //
    // Returns an error code if unsuccessful.
    //    
        
    if (ERROR_SUCCESS !=
        KsCreateAllocator( 
            PinHandle, 
            &Framing,
            &m_AllocatorHandle )) {
   
        DWORD   LastError;
   
        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32( LastError );
        m_AllocatorHandle = NULL;
        
        DbgLog((
            LOG_MEMORY, 
            2, 
            TEXT("PIPES ATTN CKsAllocator, KsCreateAllocator() failed: %08x"), hr));
    }
    
    if (KsPinPipe) {
       KsPinPipe->Release();
    }
   
    return m_AllocatorHandle;

}






STDMETHODIMP_(HANDLE)
CKsAllocator::KsGetAllocatorHandle()
{
    return m_AllocatorHandle;
}

STDMETHODIMP_( KSALLOCATORMODE )
CKsAllocator::KsGetAllocatorMode(
    VOID
    )
{
    return m_AllocatorMode;
}

STDMETHODIMP 
CKsAllocator::KsGetAllocatorStatus(
    PKSSTREAMALLOCATOR_STATUS AllocatorStatus 
    )
{
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("CKsAllocator::KsGetAllocatorStatus")));
    return S_OK;
}    

STDMETHODIMP_( VOID )
CKsAllocator::KsSetAllocatorMode(
    KSALLOCATORMODE Mode
    )
{
    m_AllocatorMode = Mode;

    DbgLog((
        LOG_MEMORY,
        2,
        TEXT("CKsAllocator::KsSetAllocatorMode = %s"),
        (m_AllocatorMode == KsAllocatorMode_Kernel) ? TEXT("Kernel") : TEXT("User") ));
}    

STDMETHODIMP
CKsAllocator::Commit()
    
/*++

Routine Description:


Arguments:
    None.

Return:

--*/

{
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("CKsAllocator::Commit")));

    if (m_AllocatorMode == KsAllocatorMode_Kernel) {
        DbgLog((
            LOG_MEMORY, 
            2, 
            TEXT("CKsAllocator::Commit, kernel-mode allocator")));
        return S_OK;
    } else {
        return CMemAllocator::Commit();
    }
}

STDMETHODIMP 
CKsAllocator::Decommit(
    void
    )

/*++

Routine Description:


Arguments:
    None.

Return:

--*/

{
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("CKsAllocator::Decommit")));
        
    if (m_AllocatorMode == KsAllocatorMode_Kernel) {
        DbgLog((
            LOG_MEMORY, 
            2, 
            TEXT("CKsAllocator::Decommit, kernel-mode allocator")));
        return S_OK;
    } else {
        return CMemAllocator::Decommit();
    }
}

#if DBG || defined(DEBUG)
STDMETHODIMP 
CKsAllocator::GetBuffer(
    IMediaSample **Sample,
    REFERENCE_TIME * StartTime,
    REFERENCE_TIME * EndTime,
    DWORD Flags)

/*++

Routine Description:


Arguments:
    IMediaSample **Sample -

    REFERENCE_TIME * StartTime -

    REFERENCE_TIME * EndTime -

    DWORD Flags -

Return:

--*/

{
    if (m_AllocatorMode == KsAllocatorMode_Kernel) {
        DbgLog((
            LOG_MEMORY, 
            2, 
            TEXT("CKsAllocator::GetBuffer, kernel-mode allocator -- failing")));
        return E_FAIL;
    } else {
        return CMemAllocator::GetBuffer( Sample, StartTime, EndTime, Flags );
    }
}
    
STDMETHODIMP 
CKsAllocator::ReleaseBuffer(
    IMediaSample *Sample
    )

/*++

Routine Description:


Arguments:
    IMediaSample *Sample -

Return:

--*/

{
    if (m_AllocatorMode == KsAllocatorMode_Kernel) {
        DbgLog((
            LOG_MEMORY, 
            2, 
            TEXT("CKsAllocator::ReleaseBuffer, kernel-mode allocator -- failing")));
        return E_FAIL;
    } else {
        return CMemAllocator::ReleaseBuffer( Sample );
    }
}
#endif // DBG || defined(DEBUG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksproxy\ksiproxy.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksiproxy.h

Abstract:

    Internal header.
    
Author(s):

    Thomas O'Rourke (tomor) 2-Feb-1996
    George Shaw (gshaw)
    Bryan A. Woodruff (bryanw) 

--*/

#if !defined(_KSIPROXY_)
#define _KSIPROXY_

//
// This is used for adding unique names to event and semaphores 
// in checked builds.
//
#ifdef DEBUG
    #define KSDEBUG_NAME_LENGTH      64
    #define DECLARE_KSDEBUG_NAME(x)  TCHAR x[KSDEBUG_NAME_LENGTH]
    #define BUILD_KSDEBUG_NAME(buff, fmt, id) \
                _sntprintf(buff, KSDEBUG_NAME_LENGTH, (fmt _T("p%08lx")), (id), (ULONG)GetCurrentProcessId()); \
                buff[KSDEBUG_NAME_LENGTH - 1] = 0
    #define BUILD_KSDEBUG_NAME2(buff, fmt, id1, id2) \
                _sntprintf(buff, KSDEBUG_NAME_LENGTH, (fmt _T("p%08lx")), (id1), (id2), (ULONG)GetCurrentProcessId()); \
                buff[KSDEBUG_NAME_LENGTH - 1] = 0
    #define KSDEBUG_NAME(str)        (str)
    #define KSDEBUG_UNIQUE_NAME()    (GetLastError() != ERROR_ALREADY_EXISTS)
#else
    #define DECLARE_KSDEBUG_NAME(x)
    #define BUILD_KSDEBUG_NAME(buff, fmt, id)
    #define BUILD_KSDEBUG_NAME2(buff, fmt, id1, id2)
    #define KSDEBUG_NAME(str)        NULL
    #define KSDEBUG_UNIQUE_NAME()    TRUE
#endif

//
// This is used for formatting strings which contain guids returned
// from OLE functions, which are always Unicode. If the module is
// not being compiled for Unicode, then the format string must
// indicate the guid is Unicode.
//
#ifdef _UNICODE
#define GUID_FORMAT L"%s"
#else
#define GUID_FORMAT "%S"
#endif

#define SAFERELEASE( pInterface )   { if (NULL != (pInterface)) { IUnknown *pTemp = (pInterface); (pInterface) = NULL; pTemp->Release(); } }

//
// Taken from wdm.h POOL_TYPE.
// Won't compile with entire wdm.h included.
//
typedef enum _KSPOOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType
} KSPOOL_TYPE;


#define DEFAULT_STEPPING         1
#define ALLOC_DEFAULT_PREFIX     0
#define KS_PINWEIGHT_DEFAULT     0
#define KS_MEMORYWEIGHT_DEFAULT  0

//
// GLOBAL 
//
#ifndef GLOBAL_KSIPROXY
extern
#endif
struct {
    ULONG    CodePath;
    long     DefaultNumberBuffers;
    long     DefaultBufferSize;
    long     DefaultBufferAlignment;
} Global;

//
// Internal structures for pipes.
//
typedef enum {
    Pin_First, 
    Pin_Last, 
    Pin_Terminal, 
    Pin_All,   
    Pin_Input,   
    Pin_Output,
    Pin_MultipleOutput,
    Pin_SingleOutput,
    Pin_User,
    Pin_Inside_Pipe,
    Pin_Outside_Pipe,
    Pin_None
} PIN_TYPES_INTERNAL;


#define Pin_Test     0x00000000
#define Pin_Add      0x00000001
#define Pin_Remove   0x00000002
#define Pin_Move     0x00000004


typedef enum {
    NONE_OBJECT_DIFFERENT,
    OUT_OBJECT_DIFFERENT,
    IN_OBJECT_DIFFERENT,
    BOTH_OBJECT_DIFFERENT,
    NO_INTERSECTION
} KS_OBJECTS_INTERSECTION;

typedef KS_OBJECTS_INTERSECTION  *PKS_OBJECTS_INTERSECTION;


//
// framing change flags
//
#define  KS_FramingChangeMemoryType      0x00000001
#define  KS_FramingChangeAllocator       0x00000002
#define  KS_FramingChangeCompression     0x00000004
#define  KS_FramingChangePhysicalRange   0x00000008
#define  KS_FramingChangeOptimalRange    0x00000010
#define  KS_FramingChangePrty            0x00000020


//
// search flags in pin framing
//
#define  KS_SearchByLogicalMemoryType    0x00000001
#define  KS_SearchByMemoryType           0x00000002


//
// framing with fixed memory, bus and range.
//
typedef struct {
    GUID                        MemoryType;
    GUID                        BusType;
    ULONG                       PinFlags;
    ULONG                       PinWeight;          // this pin framing's weight graph-wide
    ULONG                       CountItems;
    ULONG                       MemoryFlags;
    KS_LogicalMemoryType        LogicalMemoryType;
    ULONG                       BusFlags;   
    ULONG                       Flags;
    ULONG                       Frames;             // total number of allowable outstanding frames
    ULONG                       FileAlignment;
    KS_FRAMING_RANGE            PhysicalRange;
    KS_COMPRESSION              OutputCompression;
    KS_FRAMING_RANGE_WEIGHTED   OptimalRange; 
    ULONG                       MemoryTypeWeight;   // this memory type weight pin-wide
} KS_FRAMING_FIXED, *PKS_FRAMING_FIXED;


//
// Connection table for pipes, based on logical memory types.
//
typedef struct {
    ULONG    NumPipes;
    ULONG    Code;
} CONNECTION_TABLE_ENTRY;


#define ConnectionTableDimension   7    // Needs to match the number of values enumerated in KS_LogicalMemoryType
#define ConnectionTableMaxEntries  6

typedef enum {
    KS_DIRECTION_UPSTREAM,
    KS_DIRECTION_DOWNSTREAM,
    KS_DIRECTION_ALL,
    KS_DIRECTION_DEFAULT
} KS_DIRECTION;


//
// Macros for QueryInterface 
//
#define GetInterfacePointerNoLockWithAssert(KnownPointer, InterfaceGuid, ReturnPointer, ReturnHResult)\
{\
    ReturnHResult = KnownPointer->QueryInterface(InterfaceGuid, reinterpret_cast<PVOID*>(&ReturnPointer));\
    if ( ! SUCCEEDED( ReturnHResult ) ) {\
        ASSERT(0);\
        ReturnPointer = NULL;\
    }\
    else {\
        ReturnPointer->Release();\
    }\
}


typedef BOOL
(STDMETHODCALLTYPE *PWALK_PIPE_CALLBACK)(
    IKsPin*     KsPin,
    ULONG       PinType,
    PVOID*      Param1,
    PVOID*      Param2,
    BOOL       *IsDone
    );

typedef struct {
    GUID        MemoryType;
    IKsPin*     KsPin;
    ULONG       PinType;
    ULONG       IsMustAllocator;
    ULONG       NumberMustAllocators;
    BOOL        FlagAssign;
} ALLOCATOR_SEARCH;

typedef struct {
    GUID                        MemoryType;
    PIPE_DIMENSIONS             Dimensions;
    KS_FRAMING_RANGE            PhysicalRange;
    KS_FRAMING_RANGE_WEIGHTED   OptimalRange;
    ULONG                       Frames;
    ULONG                       Flags;
    long                        cbAlign;
} DIMENSIONS_DATA;

//
// Attributes interface attached to Media Types
//
interface __declspec(uuid("D559999A-A4C3-11D2-876A-00A0C9223196")) IMediaTypeAttributes;
interface IMediaTypeAttributes : public IUnknown {
    virtual STDMETHODIMP GetMediaAttributes(
        OUT PKSMULTIPLE_ITEM* Attributes
        ) = 0;
    virtual STDMETHODIMP SetMediaAttributes(
        IN PKSMULTIPLE_ITEM Attributes OPTIONAL
        ) = 0;
};

typedef struct _ITEM_LIST_ITEM {
    struct _ITEM_LIST_ITEM *fLink;
    struct _ITEM_LIST_ITEM *bLink;
} ITEM_LIST_ITEM, *PITEM_LIST_ITEM;

typedef struct _ITEM_LIST_HEAD {
    ITEM_LIST_ITEM  head;
    ITEM_LIST_ITEM  tail;
    DWORD           count;
    HANDLE          mutex;
} ITEM_LIST_HEAD, *PITEM_LIST_HEAD;

DWORD   ItemListInitialize( PITEM_LIST_HEAD pHead );
VOID    ItemListCleanup( PITEM_LIST_HEAD pHead );
VOID    ItemListAppendItem( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pNewItem );
DWORD   ItemListGetCount( PITEM_LIST_HEAD pHead );
VOID    ItemListInsertItemAfter( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pOldItem, PITEM_LIST_ITEM pNewItem );
VOID    ItemListInsertItemBefore( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pOldItem, PITEM_LIST_ITEM pNewItem );
PITEM_LIST_ITEM ItemListRemoveItem( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pItem );
PITEM_LIST_ITEM ItemListGetFirstItem( PITEM_LIST_HEAD pHead );
PITEM_LIST_ITEM ItemListGetLastItem( PITEM_LIST_HEAD pHead );

typedef enum {
    EVENT_SIGNALLED = 0,
    EVENT_CANCELLED
} ASYNC_ITEM_STATUS;

typedef VOID (*PASYNC_ITEM_ROUTINE)( ASYNC_ITEM_STATUS status, struct _ASYNC_ITEM *pItem );

typedef struct _ASYNC_ITEM {
    ITEM_LIST_ITEM      link;
    BOOLEAN             remove;
    HANDLE              event;
    PASYNC_ITEM_ROUTINE itemRoutine;
    PVOID               context;
} ASYNC_ITEM, *PASYNC_ITEM;

#define InitializeAsyncItem( pItm, autoRemove, evnt, routine, ctxt ) \
    (pItm)->link.fLink  = (pItm)->link.bLink = NULL;     \
    (pItm)->remove      = (autoRemove);                  \
    (pItm)->event       = (evnt);                        \
    (pItm)->itemRoutine = (routine);                     \
    (pItm)->context     = (ctxt);

class CAsyncItemHandler
{
public:
    CAsyncItemHandler( DWORD *pResult );
    ~CAsyncItemHandler( void );

    STDMETHODIMP_(DWORD) QueueAsyncItem( PASYNC_ITEM pItem );
    STDMETHODIMP_(VOID) RemoveAsyncItem( HANDLE itemHandle );

protected:
    typedef enum {
        WAKEUP_EXIT = 0,
        WAKEUP_NEWEVENT,
        WAKEUP_REMOVEEVENT
    } WAKEUP;

    static DWORD WINAPI AsyncItemProc( CAsyncItemHandler *pThis );
    HANDLE      m_hEvents[ MAXIMUM_WAIT_OBJECTS ];
    PASYNC_ITEM m_pItems[ MAXIMUM_WAIT_OBJECTS ];
    DWORD       m_arrayCount;
    WAKEUP      m_wakeupReason;
    HANDLE      m_hRemove;
    HANDLE      m_AsyncEvent;

    ITEM_LIST_HEAD  m_eventList;

    HANDLE  m_hWakeupEvent;
    HANDLE  m_hSlotSemaphore;
    HANDLE  m_hItemMutex;
    HANDLE  m_hThread;
    DWORD   m_threadId;
}; // CAsyncItemHandler

class CMediaTypeAttributes : public IMediaTypeAttributes {
private:
    PKSMULTIPLE_ITEM m_Attributes;

public:
    LONG m_cRef;

    CMediaTypeAttributes(
        );

    // IUnknown
    STDMETHODIMP QueryInterface(
        REFIID riid,
        void** ppv
        );
    STDMETHODIMP_(ULONG) AddRef(
        );
    STDMETHODIMP_(ULONG) Release(
        );

    // IMediaTypeAttributes
    STDMETHODIMP GetMediaAttributes(
        OUT PKSMULTIPLE_ITEM* Attributes
        );
    STDMETHODIMP SetMediaAttributes(
        IN PKSMULTIPLE_ITEM Attributes OPTIONAL
        );
};

//
// Aggregator class
//
class CAggregateMarshaler {
public:
    IID m_iid;
    CLSID m_ClassId;
    IUnknown* m_Unknown;
    IDistributorNotify* m_DistributorNotify;
    BOOL m_Volatile;
    BOOL m_Reconnected;
};

typedef CGenericList<CAggregateMarshaler> CMarshalerList;

//
// Allocator class
//

class CKsAllocator :
    public CMemAllocator,
    public IKsAllocatorEx {
    
public:
    CKsAllocator(
        TCHAR* ObjectName,
        IUnknown* UnknownOuter,
        IPin* Pin,
        HANDLE FilterHandle,
        HRESULT* hr);
    ~CKsAllocator();
    
    // Implement CUnknown
    STDMETHODIMP QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Override CMemAllocator
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void** ppv);
    
    // Override CMemAllocator
    STDMETHODIMP Commit();
    STDMETHODIMP Decommit();
#if DBG || defined(DEBUG)
    STDMETHODIMP GetBuffer(
        IMediaSample** Sample,
        REFERENCE_TIME* StartTime,
        REFERENCE_TIME* EndTime,
        DWORD Flags);
    STDMETHODIMP ReleaseBuffer(IMediaSample* Sample);
#endif    
    
    // Implement IKsAllocator and IKsAllocatorEx
    STDMETHODIMP_(HANDLE) KsGetAllocatorHandle();
    STDMETHODIMP_(KSALLOCATORMODE) KsGetAllocatorMode();
    STDMETHODIMP KsGetAllocatorStatus(PKSSTREAMALLOCATOR_STATUS AllocatorStatus);
    STDMETHODIMP_(VOID) KsSetAllocatorMode(KSALLOCATORMODE Mode);
    // IKsAllocatorEx
    STDMETHODIMP_(PALLOCATOR_PROPERTIES_EX) KsGetProperties() {return &m_AllocatorPropertiesEx; }
    STDMETHODIMP_(VOID) KsSetProperties(PALLOCATOR_PROPERTIES_EX PropEx) {m_AllocatorPropertiesEx = *PropEx; }
    STDMETHODIMP_(VOID) KsSetAllocatorHandle(HANDLE AllocatorHandle);
    STDMETHODIMP_(HANDLE) KsCreateAllocatorAndGetHandle(IKsPin*   KsPin);

    
private:
    IPin* m_OwnerPin;
    HANDLE m_FilterHandle;
    HANDLE m_AllocatorHandle;
    KSALLOCATORMODE m_AllocatorMode;
// new
    ALLOCATOR_PROPERTIES_EX m_AllocatorPropertiesEx;
};

//
// This is only used internally as a substitute for IKsObject
//
struct DECLSPEC_UUID("877e4352-6fea-11d0-b863-00aa00a216a1") IKsClock;
DECLARE_INTERFACE_(IKsClock, IUnknown)
{
    STDMETHOD_(HANDLE, KsGetClockHandle)() PURE;
};

//
// Media Sample class
//

class CMicroMediaSample : public IMediaSample2 {
private:
    DWORD   m_Flags;
public:
    LONG    m_cRef;

    CMicroMediaSample(DWORD Flags);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IMediaSample
    STDMETHODIMP GetPointer(BYTE** Buffer);
    STDMETHODIMP_(LONG) GetSize();
    STDMETHODIMP GetTime(REFERENCE_TIME* TimeStart, REFERENCE_TIME* TimeEnd);
    STDMETHODIMP SetTime(REFERENCE_TIME* TimeStart, REFERENCE_TIME* TimeEnd);
    STDMETHODIMP IsSyncPoint();
    STDMETHODIMP SetSyncPoint(BOOL IsSyncPoint);
    STDMETHODIMP IsPreroll();
    STDMETHODIMP SetPreroll(BOOL IsPreroll);
    STDMETHODIMP_(LONG) GetActualDataLength();
    STDMETHODIMP SetActualDataLength(LONG Actual);
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE** MediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE* MediaType);
    STDMETHODIMP IsDiscontinuity();
    STDMETHODIMP SetDiscontinuity(BOOL Discontinuity);
    STDMETHODIMP GetMediaTime(LONGLONG* TimeStart, LONGLONG* TimeEnd);
    STDMETHODIMP SetMediaTime(LONGLONG* TimeStart, LONGLONG* TimeEnd);

    // IMediaSample2
    STDMETHODIMP GetProperties(DWORD PropertiesSize, BYTE* Properties);
    STDMETHODIMP SetProperties(DWORD PropertiesSize, const BYTE* Properties);
};

//
// Proxy class
//

#define STOP_EOS        0
#define ENABLE_EOS      1
#define DISABLE_EOS     2

class CKsProxy :
    public CCritSec,
    public CBaseFilter,
    public CPersistStream,
    public ISpecifyPropertyPages,
    public IPersistPropertyBag,
    public IReferenceClock,
    public IMediaSeeking,
    public IKsObject,
    public IKsClock,
    public IKsPropertySet,
    public IKsClockPropertySet,
    public IAMFilterMiscFlags,
    public IKsControl,
    public IKsTopology,
    public IKsAggregateControl
#ifdef DEVICE_REMOVAL
   ,public IAMDeviceRemoval
#endif // DEVICE_REMOVAL
    {

public:
    static CUnknown* CALLBACK CreateInstance(LPUNKNOWN UnkOuter, HRESULT* hr);

    CKsProxy(LPUNKNOWN UnkOuter, HRESULT* hr);
    ~CKsProxy();

    // Implement CBaseFilter
    CBasePin* GetPin(int n);
    int GetPinCount();

    // Implement IKsObject
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();
    
    // Implement IKsClock
    STDMETHODIMP_(HANDLE) KsGetClockHandle();

    // Override CBaseFilter
    STDMETHODIMP SetSyncSource(IReferenceClock* RefClock);
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME Start);
    STDMETHODIMP GetState(DWORD MSecs, FILTER_STATE* State);
    STDMETHODIMP JoinFilterGraph(IFilterGraph* Graph, LPCWSTR Name);
    STDMETHODIMP FindPin(LPCWSTR Id, IPin** Pin);

    // Implement ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID* Pages);

    // Implement IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Override CBaseFilter
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, PVOID* ppv);

    STDMETHODIMP CreateClockHandle();
    STDMETHODIMP DetermineClockSource();
    STDMETHODIMP GetPinFactoryCount(PULONG PinFactoryCount);
    STDMETHODIMP GetPinFactoryDataFlow(ULONG PinFactoryId, PKSPIN_DATAFLOW DataFlow);
    STDMETHODIMP GetPinFactoryInstances(ULONG PinFactoryId, PKSPIN_CINSTANCES Instances);
    STDMETHODIMP GetPinFactoryCommunication(ULONG PinFactoryId, PKSPIN_COMMUNICATION Communication);
    STDMETHODIMP GeneratePinInstances();
    STDMETHODIMP ConstructPinName(ULONG PinFactoryId, KSPIN_DATAFLOW DataFlow, WCHAR** PinName);
    STDMETHODIMP PropagateAcquire(IKsPin* KsPin, ULONG FlagStarted);
    STDMETHODIMP_(HANDLE) GetPinHandle(CBasePin* Pin);
    STDMETHODIMP_(ULONG) GetPinFactoryId(CBasePin* Pin);
    STDMETHODIMP GetPinFactoryDataRanges(ULONG PinFactoryId, PVOID* DataRanges);
    STDMETHODIMP CheckMediaType(IUnknown* UnkOuter, ULONG PinFactoryId, const CMediaType* MediaType);
    STDMETHODIMP SetPinSyncSource(HANDLE PinHandle);
    STDMETHODIMP QueryTopologyItems(ULONG PropertyId, PKSMULTIPLE_ITEM* MultipleItem);
    STDMETHODIMP QueryInternalConnections(ULONG PinFactoryId, PIN_DIRECTION PinDirection, IPin** PinList, ULONG* PinCount);
    STDMETHODIMP_(VOID) DeliverBeginFlush(ULONG PinFactoryId);
    STDMETHODIMP_(VOID) DeliverEndFlush(ULONG PinFactoryId);
    STDMETHODIMP_(VOID) PositionEOS();
    STDMETHODIMP_(IKsQualityForwarder*) QueryQualityForwarder() { return m_QualityForwarder; }
    STDMETHODIMP_(HKEY) QueryDeviceRegKey() { return m_DeviceRegKey; }

    // Implement IReferenceClock
    STDMETHODIMP GetTime(REFERENCE_TIME* Time);
    STDMETHODIMP AdviseTime(REFERENCE_TIME BaseTime, REFERENCE_TIME StreamTime, HEVENT EventHandle, DWORD_PTR* AdviseCookie);
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME StartTime, REFERENCE_TIME PeriodTime, HSEMAPHORE SemaphoreHandle, DWORD_PTR* AdviseCookie);
    STDMETHODIMP Unadvise(DWORD_PTR AdviseCookie);
    
    // Implement IMediaSeeking
    STDMETHODIMP GetCapabilities(DWORD* Capabilities);
    STDMETHODIMP CheckCapabilities(DWORD* Capabilities);
    STDMETHODIMP IsFormatSupported(const GUID* Format);
    STDMETHODIMP QueryPreferredFormat(GUID* Format);
    STDMETHODIMP GetTimeFormat(GUID* Format);
    STDMETHODIMP IsUsingTimeFormat(const GUID* Format);
    STDMETHODIMP SetTimeFormat(const GUID* Format);
    STDMETHODIMP GetDuration(LONGLONG* Duration);
    STDMETHODIMP GetStopPosition(LONGLONG* Stop);
    STDMETHODIMP GetCurrentPosition(LONGLONG* Current);
    STDMETHODIMP ConvertTimeFormat(LONGLONG* Target, const GUID* TargetFormat, LONGLONG Source, const GUID* SourceFormat);
    STDMETHODIMP SetPositions(LONGLONG* Current, DWORD CurrentFlags, LONGLONG* Stop, DWORD StopFlags);
    STDMETHODIMP GetPositions(LONGLONG* Current, LONGLONG* Stop);
    STDMETHODIMP GetAvailable(LONGLONG* Earliest, LONGLONG* Latest);
    STDMETHODIMP SetRate(double Rate);
    STDMETHODIMP GetRate(double* Rate);
    STDMETHODIMP GetPreroll(LONGLONG* Preroll);

    // Implement IPersistPropertyBag
    STDMETHODIMP Load(LPPROPERTYBAG PropBag, LPERRORLOG ErrorLog);
    STDMETHODIMP Save(LPPROPERTYBAG PropBag, BOOL ClearDirty, BOOL SaveAllProperties);
    STDMETHODIMP InitNew();

    // Implement IPersist
    STDMETHODIMP GetClassID(CLSID* ClassId);
    
    // Implement CPersistStream
    DWORD GetSoftwareVersion();
    HRESULT WriteToStream(IStream* Stream);
    HRESULT ReadFromStream(IStream* Stream);
    int SizeMax();
    
    // Thread for I/O
    static DWORD IoThread(CKsProxy* KsProxy);
    static DWORD WaitThread(CKsProxy* KsProxy);
        
    // I/O interface
    STDMETHODIMP StartIoThread();
    STDMETHODIMP_(VOID) EnterIoCriticalSection();
    STDMETHODIMP_(ULONG) GetFreeIoSlotCount();
    STDMETHODIMP InsertIoSlot(PKSSTREAM_SEGMENT StreamSegment);
    STDMETHODIMP_(VOID) LeaveIoCriticalSection();
    STDMETHODIMP_(VOID) WaitForIoSlot();
    
    // Other helper functions
    STDMETHODIMP_(PWCHAR) GetFilterName() { return m_pName; }
    STDMETHODIMP QueryMediaSeekingFormats(PKSMULTIPLE_ITEM* MultipleItem);
    STDMETHODIMP_(REFERENCE_TIME) GetStartTime() { return m_tStart; }
    STDMETHODIMP_(VOID) TerminateEndOfStreamNotification(HANDLE PinHandle);
    STDMETHODIMP InitiateEndOfStreamNotification(HANDLE PinHandle);
    STDMETHODIMP_(ULONG) DetermineNecessaryInstances(ULONG PinFactoryId);

    // Implement IKsPropertySet
    STDMETHODIMP Set(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength);
    STDMETHODIMP Get(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength, ULONG* BytesReturned);
    STDMETHODIMP QuerySupported(REFGUID PropSet, ULONG Property, ULONG* TypeSupport);
    
    // Helper function
    STDMETHODIMP ClockPropertyIo(ULONG PropertyId, ULONG Flags, ULONG BufferSize, PVOID Buffer);

    // Implement IKsClockPropertySet
    STDMETHODIMP KsGetTime(LONGLONG* Time);
    STDMETHODIMP KsSetTime(LONGLONG Time);
    STDMETHODIMP KsGetPhysicalTime(LONGLONG* Time);
    STDMETHODIMP KsSetPhysicalTime(LONGLONG Time);
    STDMETHODIMP KsGetCorrelatedTime(KSCORRELATED_TIME* CorrelatedTime);
    STDMETHODIMP KsSetCorrelatedTime(KSCORRELATED_TIME* CorrelatedTime);
    STDMETHODIMP KsGetCorrelatedPhysicalTime(KSCORRELATED_TIME* CorrelatedTime);
    STDMETHODIMP KsSetCorrelatedPhysicalTime(KSCORRELATED_TIME* CorrelatedTime);
    STDMETHODIMP KsGetResolution(KSRESOLUTION* Resolution);
    STDMETHODIMP KsGetState(KSSTATE* State);

    // Implement IAMFilterMiscFlags
    STDMETHODIMP_(ULONG)GetMiscFlags();

    // Implement IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsEvent(
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );

    // Implement IKsTopology
    STDMETHODIMP CreateNodeInstance(
        IN ULONG NodeId,
        IN ULONG Flags,
        IN ACCESS_MASK DesiredAccess,
        IN IUnknown* UnkOuter OPTIONAL,
        IN REFGUID InterfaceId,
        OUT LPVOID* Interface
        );

    // Implement IKsAggregateControl
    STDMETHODIMP KsAddAggregate(
        IN REFGUID Aggregate
        );
    STDMETHODIMP KsRemoveAggregate(
        IN REFGUID Aggregate
        );

#ifdef DEVICE_REMOVAL
    // Implement IAMDeviceRemoval
    STDMETHODIMP DeviceInfo( 
        CLSID* InterfaceClass,
        WCHAR** SymbolicLink
        );
    STDMETHODIMP Reassociate(
        );
    STDMETHODIMP Disassociate(
        );
#endif // DEVICE_REMOVAL

private:
    typedef CGenericList<CBasePin> CBasePinList;

    typedef struct {
        ULONG   Message;
        PVOID   Param;
    } WAITMESSAGE, *PWAITMESSAGE;

    CBasePinList m_PinList;
    CMarshalerList m_MarshalerList;
    HANDLE m_FilterHandle;
    HANDLE m_ExternalClockHandle;
    HANDLE m_PinClockHandle;
    HANDLE m_IoThreadHandle;
    ULONG m_IoThreadId;
    BOOL m_IoThreadShutdown;
    CRITICAL_SECTION m_IoThreadCriticalSection;
    HANDLE m_IoFreeSlotSemaphore;
    PHANDLE m_IoEvents;
    PKSSTREAM_SEGMENT* m_IoSegments;
    LONG m_ActiveIoEventCount;
    CBasePin* m_PinClockSource;
    IKsQualityForwarder* m_QualityForwarder;
    BOOL m_MediaSeekingRecursion;
    HKEY m_DeviceRegKey;
    IPersistStream* m_PersistStreamDevice;
    HANDLE m_WaitThreadHandle;
    HANDLE* m_WaitEvents;
    HANDLE* m_WaitPins;
    ULONG m_ActiveWaitEventCount;
    HANDLE m_WaitReplyHandle;
    WAITMESSAGE m_WaitMessage;
    ULONG m_EndOfStreamCount;
    BOOL m_PropagatingAcquire;
    WCHAR* m_SymbolicLink;
    GUID m_InterfaceClassGuid;
    LONG m_EventNameIndex;
};

//
// Input pin class
//

class CKsInputPin :
    public CBaseInputPin,
    public IKsObject,
    public IKsPinEx,
    public IKsPinPipe,
    public ISpecifyPropertyPages,
    public IStreamBuilder,
    public IKsPropertySet,
    public IKsPinFactory,
    public IKsControl,
    public IKsAggregateControl {

private:
    HANDLE m_PinHandle;
    IKsDataTypeHandler* m_DataTypeHandler;
    IUnknown* m_UnkInner;
    IKsInterfaceHandler* m_InterfaceHandler;
    ULONG m_PinFactoryId;
    KSPIN_COMMUNICATION m_OriginalCommunication;
    KSPIN_COMMUNICATION m_CurrentCommunication;
    KSPIN_INTERFACE m_CurrentInterface;
    KSPIN_MEDIUM m_CurrentMedium;
    BOOL m_PropagatingAcquire;
    BOOL m_MarshalData;
    LONG m_PendingIoCount;
    HANDLE m_PendingIoCompletedEvent;
    CCritSec m_IoCriticalSection;
    CMarshalerList m_MarshalerList;
    BOOL m_QualitySupport;
    BOOL m_DeliveryError;
// new
    BOOL m_IsUpstreamPinUserMode;
    IKsAllocatorEx* m_pKsAllocator;
    PKSALLOCATOR_FRAMING_EX m_AllocatorFramingEx[Framing_Cache_Write];
    FRAMING_PROP m_FramingProp[Framing_Cache_Write];
    ULONG m_fPipeAllocator;       
    GUID m_BusOrig;
    BOOL m_PinBusCacheInit;

public:
    ULONG m_RelativeRefCount;
    CKsInputPin(
        TCHAR* ObjectName,
        int PinFactoryId,
        CLSID ClassId,
        CKsProxy* KsProxy,
        HRESULT* hr,
        WCHAR* PinName);
    ~CKsInputPin();

    // Implement IKsObject
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();

    // Implement IKsPinEx
    STDMETHODIMP KsQueryMediums(PKSMULTIPLE_ITEM* MediumList);
    STDMETHODIMP KsQueryInterfaces(PKSMULTIPLE_ITEM* InterfaceList);
    STDMETHODIMP KsCreateSinkPinHandle(KSPIN_INTERFACE& Interface, KSPIN_MEDIUM& Medium);
    STDMETHODIMP KsGetCurrentCommunication(KSPIN_COMMUNICATION* Communication, KSPIN_INTERFACE* Interface, KSPIN_MEDIUM* Medium);
    STDMETHODIMP KsPropagateAcquire();
    STDMETHODIMP KsDeliver(IMediaSample* Sample, ULONG Flags);
    STDMETHODIMP KsMediaSamplesCompleted( PKSSTREAM_SEGMENT StreamSegment );
    STDMETHODIMP_(IMemAllocator*) KsPeekAllocator(KSPEEKOPERATION Operation);
    STDMETHODIMP KsReceiveAllocator(IMemAllocator* MemAllocator);
    STDMETHODIMP KsRenegotiateAllocator();
    STDMETHODIMP_(LONG) KsIncrementPendingIoCount();
    STDMETHODIMP_(LONG) KsDecrementPendingIoCount();
    STDMETHODIMP KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta);
    STDMETHODIMP_(VOID) KsNotifyError(IMediaSample* Sample, HRESULT hr);

    STDMETHODIMP ProcessCompleteConnect(IPin* ReceivePin);
    STDMETHODIMP_(CMarshalerList*) MarshalerList() { return &m_MarshalerList; }
    STDMETHODIMP_(ULONG)PinFactoryId() { return m_PinFactoryId; }


    // Implement IKsPinPipe
    STDMETHODIMP KsGetPinFramingCache (PKSALLOCATOR_FRAMING_EX *FramingEx, PFRAMING_PROP FramingProp, FRAMING_CACHE_OPS Option);
    STDMETHODIMP KsSetPinFramingCache (PKSALLOCATOR_FRAMING_EX FramingEx, PFRAMING_PROP FramingProp, FRAMING_CACHE_OPS Option);
    STDMETHODIMP_(IPin*)KsGetConnectedPin() { return m_Connected; }
    STDMETHODIMP_(IKsAllocatorEx*)KsGetPipe(KSPEEKOPERATION Operation);
    STDMETHODIMP KsSetPipe(IKsAllocatorEx*   KsAllocator);
    STDMETHODIMP_(ULONG)KsGetPipeAllocatorFlag();
    STDMETHODIMP KsSetPipeAllocatorFlag(ULONG Flag);
    STDMETHODIMP_(GUID)KsGetPinBusCache();
    STDMETHODIMP KsSetPinBusCache(GUID Bus);
//  dbg
    STDMETHODIMP_(PWCHAR)KsGetPinName();
    STDMETHODIMP_(PWCHAR)KsGetFilterName();



    // Implement IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, PVOID* ppv);

    // Override CBaseInputPin
    STDMETHODIMP Disconnect();
    STDMETHODIMP GetAllocator(IMemAllocator** MemAllocator);
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES* Requirements);
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();

    // Override CBasePin
    BOOL IsConnected() { return (m_PinHandle != NULL); };//Note that this is not virtual
    STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP Connect(IPin* ReceivePin, const AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP QueryInternalConnections(IPin** PinList, ULONG* PinCount);
    HRESULT Active();
    HRESULT Run(REFERENCE_TIME tStart);
    HRESULT Inactive();
    STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP NewSegment(REFERENCE_TIME Start, REFERENCE_TIME Stop, double Rate);
    STDMETHODIMP QueryId(LPWSTR* Id);
    
    // Implement CBasePin
    HRESULT CheckMediaType(const CMediaType* MediaType);

    // Override CBasePin
    STDMETHODIMP EndOfStream();
    HRESULT SetMediaType(const CMediaType* MediaType);
    HRESULT CheckConnect(IPin* Pin);
    HRESULT CompleteConnect(IPin* ReceivePin);
    HRESULT BreakConnect();
    HRESULT GetMediaType(int Position, CMediaType* MediaType);
    
    // Implement IMemInputPin
    STDMETHODIMP Receive(IMediaSample* MediaSample);
    STDMETHODIMP ReceiveMultiple(IMediaSample** MediaSamples, LONG Samples, LONG* SamplesProcessed);
    STDMETHODIMP ReceiveCanBlock();
    STDMETHODIMP NotifyAllocator(IMemAllocator* Allocator, BOOL ReadOnly);
    
    // Implement ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID* Pages);

    // Implement IStreamBuilder
    STDMETHODIMP Render(IPin* PinOut, IGraphBuilder* Graph);
    STDMETHODIMP Backout(IPin* PinOut, IGraphBuilder* Graph);

    // Implement IKsPropertySet
    STDMETHODIMP Set(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength);
    STDMETHODIMP Get(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength, ULONG* BytesReturned);
    STDMETHODIMP QuerySupported(REFGUID PropSet, ULONG Property, ULONG* TypeSupport);
    
    // Implement IKsPinFactory
    STDMETHODIMP KsPinFactory(ULONG* PinFactory);


    // Implement IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsEvent(
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    //
    // supporting routines (class specific)
    //
    STDMETHODIMP SetStreamMediaType(const CMediaType* MediaType);

    // Implement IKsAggregateControl
    STDMETHODIMP KsAddAggregate(
        IN REFGUID Aggregate
        );
    STDMETHODIMP KsRemoveAggregate(
        IN REFGUID Aggregate
        );
};

//
// Output pin class
//

#define UM_IOTHREAD_STOP    (WM_USER + 0x100)
#define UM_IOTHREAD_DELIVER (WM_USER + 0x101)

typedef CGenericList<ASYNC_ITEM> CIoQueue;
typedef CGenericList<IMediaSample> CIoThreadQueue;

typedef enum {

    FLUSH_NONE = 0,
    FLUSH_SYNCHRONIZE,
    FLUSH_SIGNAL

} FLUSH_MODE, *PFLUSH_MODE;

class CKsOutputPin :
    public CBaseOutputPin,
    public CBaseStreamControl,
    public IMediaSeeking,
    public IKsObject,
    public IKsPinEx,
    public IKsPinPipe,
    public ISpecifyPropertyPages,
    public IStreamBuilder,
    public IKsPropertySet,
    public IKsPinFactory,
    public IAMBufferNegotiation,
    public IAMStreamConfig,
    public IKsControl,
    public IKsAggregateControl,
    public IMemAllocatorNotifyCallbackTemp 
{

private:
    ALLOCATOR_PROPERTIES m_AllocatorProperties;
    ALLOCATOR_PROPERTIES m_SuggestedProperties;
    HANDLE m_PinHandle;
    HANDLE m_IoThreadExitEvent;
    HANDLE m_IoThreadHandle;
    HANDLE m_IoThreadSemaphore;
    ULONG m_IoThreadId;
    IKsDataTypeHandler* m_DataTypeHandler;
    IUnknown* m_UnkInner;
    IKsInterfaceHandler* m_InterfaceHandler;
    ULONG m_PinFactoryId;
    KSPIN_COMMUNICATION m_OriginalCommunication;
    KSPIN_COMMUNICATION m_CurrentCommunication;
    KSPIN_INTERFACE m_CurrentInterface;
    KSPIN_MEDIUM m_CurrentMedium;
    BOOL m_MarshalData; 
    BOOL m_PropagatingAcquire;
    BOOL m_UsingThisAllocator;
    HANDLE m_PendingIoCompletedEvent;
    LONG m_PendingIoCount;
    CMarshalerList m_MarshalerList;
    CIoQueue m_IoQueue;
    CCritSec m_IoCriticalSection;
    CIoThreadQueue m_IoThreadQueue;
    BOOL m_QualitySupport;
    BOOL m_LastSampleDiscarded;
    AM_MEDIA_TYPE* m_ConfigAmMediaType;
    BOOL m_DeliveryError;
    BOOL m_EndOfStream;
// new
    BOOL m_IsDownstreamPinUserMode;
    IKsAllocatorEx* m_pKsAllocator;
    PKSALLOCATOR_FRAMING_EX m_AllocatorFramingEx[Framing_Cache_Write];
    FRAMING_PROP m_FramingProp[Framing_Cache_Write];
    ULONG m_fPipeAllocator;       
    GUID m_BusOrig;
    BOOL m_PinBusCacheInit;
    BOOL m_bFlushing;

    HANDLE m_hMarshalEvent;
    HANDLE m_hFlushEvent;
    HANDLE m_hFlushCompleteEvent;
    HANDLE  m_hEOSevent;
    FLUSH_MODE m_FlushMode;

    CAsyncItemHandler *m_pAsyncItemHandler;

public:
    ULONG m_RelativeRefCount;
    CKsOutputPin(
        TCHAR* ObjectName,
        int PinFactoryId,
        CLSID ClassId,
        CKsProxy* KsProxy,
        HRESULT* hr,
        WCHAR* PinName);
    ~CKsOutputPin();

    // Implement IMediaSeeking
    STDMETHODIMP GetCapabilities(DWORD* Capabilities);
    STDMETHODIMP CheckCapabilities(DWORD* Capabilities);
    STDMETHODIMP IsFormatSupported(const GUID* Format);
    STDMETHODIMP QueryPreferredFormat(GUID* Format);
    STDMETHODIMP GetTimeFormat(GUID* Format);
    STDMETHODIMP IsUsingTimeFormat(const GUID* Format);
    STDMETHODIMP SetTimeFormat(const GUID* Format);
    STDMETHODIMP GetDuration(LONGLONG* Duration);
    STDMETHODIMP GetStopPosition(LONGLONG* Stop);
    STDMETHODIMP GetCurrentPosition(LONGLONG* Current);
    STDMETHODIMP ConvertTimeFormat(LONGLONG* Target, const GUID* TargetFormat, LONGLONG Source, const GUID* SourceFormat);
    STDMETHODIMP SetPositions(LONGLONG* Current, DWORD CurrentFlags, LONGLONG* Stop, DWORD StopFlags);
    STDMETHODIMP GetPositions(LONGLONG* Current, LONGLONG* Stop);
    STDMETHODIMP GetAvailable(LONGLONG* Earliest, LONGLONG* Latest);
    STDMETHODIMP SetRate(double Rate);
    STDMETHODIMP GetRate(double* Rate);
    STDMETHODIMP GetPreroll(LONGLONG* Preroll);

    // Implement IKsObject
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();

    // Implement IKsPinEx
    STDMETHODIMP KsQueryMediums(PKSMULTIPLE_ITEM* MediumList);
    STDMETHODIMP KsQueryInterfaces(PKSMULTIPLE_ITEM* InterfaceList);
    STDMETHODIMP KsCreateSinkPinHandle(KSPIN_INTERFACE& Interface, KSPIN_MEDIUM& Medium);
    STDMETHODIMP KsGetCurrentCommunication(KSPIN_COMMUNICATION* Communication, KSPIN_INTERFACE* Interface, KSPIN_MEDIUM* Medium);
    STDMETHODIMP KsPropagateAcquire();
    STDMETHODIMP KsDeliver(IMediaSample* Sample, ULONG Flags);
    STDMETHODIMP KsMediaSamplesCompleted( PKSSTREAM_SEGMENT StreamSegment );
    STDMETHODIMP_(IMemAllocator*) KsPeekAllocator(KSPEEKOPERATION Operation);
    STDMETHODIMP KsReceiveAllocator(IMemAllocator* MemAllocator);
    STDMETHODIMP KsRenegotiateAllocator();
    STDMETHODIMP_(LONG) KsIncrementPendingIoCount();
    STDMETHODIMP_(LONG) KsDecrementPendingIoCount();
    STDMETHODIMP KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta);
    STDMETHODIMP_(VOID) KsNotifyError(IMediaSample* Sample, HRESULT hr);

    STDMETHODIMP ProcessCompleteConnect(IPin* ReceivePin);
    STDMETHODIMP_(CMarshalerList*) MarshalerList() { return &m_MarshalerList; }
    STDMETHODIMP_(ULONG)PinFactoryId() { return m_PinFactoryId; }

    // Implement IKsPinPipe
    STDMETHODIMP KsGetPinFramingCache (PKSALLOCATOR_FRAMING_EX *FramingEx, PFRAMING_PROP FramingProp, FRAMING_CACHE_OPS Option);
    STDMETHODIMP KsSetPinFramingCache (PKSALLOCATOR_FRAMING_EX FramingEx, PFRAMING_PROP FramingProp, FRAMING_CACHE_OPS Option);
    STDMETHODIMP KsSetUserModeAllocator(IMemAllocator*     MemAllocator);
    STDMETHODIMP_(IPin*)KsGetConnectedPin() { return m_Connected; }
    STDMETHODIMP_(IKsAllocatorEx*)KsGetPipe(KSPEEKOPERATION Operation);
    STDMETHODIMP KsSetPipe(IKsAllocatorEx*   KsAllocator);
    STDMETHODIMP_(ULONG)KsGetPipeAllocatorFlag();
    STDMETHODIMP KsSetPipeAllocatorFlag(ULONG Flag);
    STDMETHODIMP_(GUID)KsGetPinBusCache();
    STDMETHODIMP KsSetPinBusCache(GUID Bus);
// dbg
    STDMETHODIMP_(PWCHAR)KsGetPinName();
    STDMETHODIMP_(PWCHAR)KsGetFilterName();


    // Implement IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, PVOID* ppv);

    // Override CBasePin
    BOOL IsConnected() { return (m_PinHandle != NULL); };
    STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP Connect(IPin* ReceivePin, const AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP Disconnect();
    STDMETHODIMP QueryInternalConnections(IPin** PinList, ULONG* PinCount);
    HRESULT DeliverBeginFlush();
    HRESULT DeliverEndFlush();
    HRESULT DeliverEndOfStream();
    HRESULT Active();
    HRESULT Run(REFERENCE_TIME tStart);
    HRESULT Inactive();
    STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP QueryId(LPWSTR* Id);
    
    // Implement CBasePin
    HRESULT CheckMediaType(const CMediaType* pmt);

    // Override CBasePin
    HRESULT SetMediaType(const CMediaType* MediaType);
    HRESULT CheckConnect(IPin* Pin);
    HRESULT CompleteConnect(IPin* ReceivePin);
    HRESULT BreakConnect();
    HRESULT GetMediaType(int Position, CMediaType* MediaType);
    STDMETHODIMP Notify(IBaseFilter* Sender, Quality q);

    // Implement CBaseOutputPin
    HRESULT Deliver(IMediaSample* Sample);
    HRESULT DecideAllocator(IMemInputPin* Pin, IMemAllocator** MemAllocator);
    HRESULT DecideBufferSize(IMemAllocator* MemAllocator, ALLOCATOR_PROPERTIES* propInputRequest);
    HRESULT InitAllocator(IMemAllocator** MemAllocator, KSALLOCATORMODE AllocatorMode);

    // Implement ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID* Pages);

    // Implement IStreamBuilder
    STDMETHODIMP Render(IPin* PinOut, IGraphBuilder* Graph);
    STDMETHODIMP Backout(IPin* PinOut, IGraphBuilder* Graph);

    // Implement IKsPropertySet
    STDMETHODIMP Set(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength);
    STDMETHODIMP Get(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength, ULONG* BytesReturned);
    STDMETHODIMP QuerySupported(REFGUID PropSet, ULONG Property, ULONG* TypeSupport);
    
    // Implement IKsPinFactory
    STDMETHODIMP KsPinFactory(ULONG* PinFactory);

    // Implement IAMBufferNegotiation
    STDMETHODIMP SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES* AllocatorProperties);
    STDMETHODIMP GetAllocatorProperties(ALLOCATOR_PROPERTIES* AllocatorProperties);
    
    // Implement IAMStreamConfig
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE** AmMediaType);
    STDMETHODIMP GetNumberOfCapabilities(int* Count, int* Size);
    STDMETHODIMP GetStreamCaps(int Index, AM_MEDIA_TYPE** AmMediaType, BYTE* MediaRange);

    // Implement IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsEvent(
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );

    //
    // supporting routines (class specific)
    //
    
    static DWORD IoThread(CKsOutputPin* KsOutputPin);
    
    STDMETHODIMP 
    QueueBuffersToDevice(
        void
        );
        
    STDMETHODIMP
    KsPropagateAllocatorRenegotiation(
        VOID
        );

    STDMETHODIMP CompletePartialMediaType(
        IN CMediaType* MediaType,
        OUT AM_MEDIA_TYPE** CompleteAmMediaType);

    // Implement IKsAggregateControl
    STDMETHODIMP KsAddAggregate(
        IN REFGUID Aggregate
        );
    STDMETHODIMP KsRemoveAggregate(
        IN REFGUID Aggregate
        );

    // Implement IKsProxyMediaNotify/IMemAllocatorNotify
    STDMETHODIMP NotifyRelease(
        );

    typedef struct _BUFFER_CONTEXT {
        CKsOutputPin *      pThis;
        PKSSTREAM_SEGMENT   streamSegment;
    } BUFFER_CONTEXT, *PBUFFER_CONTEXT;

    static VOID OutputPinBufferHandler( ASYNC_ITEM_STATUS status, PASYNC_ITEM pItem ); 
    static VOID EOSEventHandler( ASYNC_ITEM_STATUS status, PASYNC_ITEM pItem );

    static VOID MarshalRoutine( IN ASYNC_ITEM_STATUS status, IN PASYNC_ITEM pItem );

    static VOID SynchronizeFlushRoutine( IN ASYNC_ITEM_STATUS status, IN PASYNC_ITEM pItem );

    HRESULT
    InitializeAsyncThread (
        );

};

typedef struct _KSSTREAM_SEGMENT_EX {
    KSSTREAM_SEGMENT    Common;
    IMediaSample*       Sample;
    KSSTREAM_HEADER     StreamHeader;
    OVERLAPPED          Overlapped;

} KSSTREAM_SEGMENT_EX, *PKSSTREAM_SEGMENT_EX;

class CFormatChangeHandler :
    public CUnknown,
    public IKsInterfaceHandler {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK
    CreateInstance(
        LPUNKNOWN UnkOuter, 
        HRESULT* hr 
        );

    STDMETHODIMP 
    NonDelegatingQueryInterface(
        REFIID riid, 
        PVOID* ppv 
        );
    
    // Implement IKsInterfaceHandler
    
    STDMETHODIMP
    KsSetPin(
        IN IKsPin* KsPin 
        );
    
    STDMETHODIMP 
    KsProcessMediaSamples(
        IN IKsDataTypeHandler* KsDataTypeHandler,
        IN IMediaSample** SampleList, 
        IN OUT PLONG SampleCount, 
        IN KSIOOPERATION IoOperation,
        OUT PKSSTREAM_SEGMENT* StreamSegment
        );
        
    STDMETHODIMP
    KsCompleteIo(
        IN PKSSTREAM_SEGMENT StreamSegment
        );
        
    CFormatChangeHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr
        );
        
private:
    IKsPin* m_KsPin;
    HANDLE m_PinHandle;
};


typedef struct {
    IKsPin*               KsPin;
    ULONG                 PinType;
    IKsAllocatorEx*       KsAllocator;
} KEY_PIPE_DATA;

//
// Topology node class
//

class CKsNode :
   public CUnknown,
   public IKsControl {

public:
    DECLARE_IUNKNOWN

    static CUnknown* CALLBACK CreateInstance(
        IN PKSNODE_CREATE NodeCreate,
        IN ACCESS_MASK DesiredAccess,
        IN HANDLE ParentHandle,
        IN LPUNKNOWN UnkOuter,
        OUT HRESULT* hr);

    CKsNode(
        IN PKSNODE_CREATE NodeCreate,
        IN ACCESS_MASK DesiredAccess,
        IN HANDLE ParentHandle,
        IN LPUNKNOWN UnkOuter,
        OUT HRESULT* hr);
    ~CKsNode();

    STDMETHODIMP NonDelegatingQueryInterface(
        IN REFIID riid,
        OUT PVOID* ppv);

    // Implement IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsEvent(
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );

private:
    HANDLE m_NodeHandle;
};

//
// helper function prototypes
//

STDMETHODIMP
SynchronousDeviceControl(
    HANDLE Handle,
    DWORD IoControl,
    PVOID InBuffer,
    ULONG InLength,
    PVOID OutBuffer,
    ULONG OutLength,
    PULONG BytesReturned
    );
STDMETHODIMP
GetState(
    HANDLE Handle,
    PKSSTATE State
    );
STDMETHODIMP
SetState(
    HANDLE Handle,
    KSSTATE State
    );
STDMETHODIMP
InitializeDataFormat(
    IN const CMediaType* MediaType,
    IN ULONG InitialOffset,
    OUT PVOID* Format,
    OUT ULONG* FormatLength
    );
STDMETHODIMP
SetMediaType(
    HANDLE Handle,
    const CMediaType* MediaType
    );
STDMETHODIMP
Active(
    IKsPin* KsPin,
    ULONG PinType,
    HANDLE PinHandle,
    KSPIN_COMMUNICATION Communication,
    IPin* ConnectedPin,
    CMarshalerList* MarshalerList,
    CKsProxy* KsProxy
    );
STDMETHODIMP
Run(
    HANDLE PinHandle,
    REFERENCE_TIME tStart,
    CMarshalerList* MarshalerList
    );
STDMETHODIMP
Inactive(
    HANDLE PinHandle,
    CMarshalerList* MarshalerList
    );
STDMETHODIMP
CheckConnect(
    IPin* Pin,
    KSPIN_COMMUNICATION CurrentCommunication
    );
STDMETHODIMP
GetMultiplePinFactoryItems(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    ULONG PropertyId,
    PVOID* Items
    );
STDMETHODIMP
FindCompatibleInterface(
    IKsPin* SourcePin,
    IKsPin* DestPin,
    PKSPIN_INTERFACE Interface
    );
STDMETHODIMP
FindCompatibleMedium(
    IKsPin* SourcePin,
    IKsPin* DestPin,
    PKSPIN_MEDIUM Medium
    );
STDMETHODIMP
SetDevIoMedium(
    IKsPin* Pin,
    PKSPIN_MEDIUM Medium
    );
STDMETHODIMP
GetMediaTypeCount(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    ULONG* MediaTypeCount
    );
STDMETHODIMP
GetMediaType(
    int Position,
    CMediaType* MediaType,
    HANDLE FilterHandle,
    ULONG PinFactoryId
    );
STDMETHODIMP_(KSPIN_COMMUNICATION)
ChooseCommunicationMethod(
    CBasePin* SourcePin,
    IKsPin* DestPin
    );
STDMETHODIMP
CreatePinHandle(
    KSPIN_INTERFACE& Interface,
    KSPIN_MEDIUM& Medium,
    HANDLE PeerPinHandle,
    CMediaType* MediaType,
    CKsProxy* KsProxy,
    ULONG PinFactoryId,
    ACCESS_MASK DesiredAccess,
    HANDLE* PinHandle
    );
STDMETHODIMP_(VOID) 
AppendSpecificPropertyPages(
    CAUUID* Pages,
    ULONG Guids,
    GUID* GuidList,
    TCHAR* GuidRoot,
    HKEY DeviceRegKey
    );
STDMETHODIMP 
GetPages(
    IKsObject* Pin,
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    KSPIN_COMMUNICATION Communication,
    HKEY DeviceRegKey,
    CAUUID* Pages
    );
STDMETHODIMP
GetPinFactoryInstances(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    PKSPIN_CINSTANCES Instances
    );
STDMETHODIMP
SetSyncSource(
    HANDLE PinHandle,
    HANDLE ClockHandle
    );
STDMETHODIMP
AggregateMarshalers(
    HKEY RootKey,
    TCHAR* SubKey,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    );
STDMETHODIMP
AggregateTopology(
    HKEY RootKey,
    PKSMULTIPLE_ITEM MultipleItem,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    );
STDMETHODIMP
CollectAllSets(
    HANDLE ObjectHandle,
    GUID** GuidList,
    ULONG* SetDataSize
    );
STDMETHODIMP_(VOID)
ResetInterfaces(
    CMarshalerList* MarshalerList
    );
STDMETHODIMP
AggregateSets(
    HANDLE ObjectHandle,
    HKEY DeviceRegKey,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    );
STDMETHODIMP_(VOID)
FreeMarshalers(
    CMarshalerList* MarshalerList
    );
STDMETHODIMP_(VOID)
UnloadVolatileInterfaces(
    CMarshalerList* MarshalerList,
    BOOL ForceUnload
    );
STDMETHODIMP_(VOID)
FollowFromTopology(
    PKSTOPOLOGY_CONNECTION Connection,
    ULONG Count,
    ULONG PinFactoryId,
    PKSTOPOLOGY_CONNECTION ConnectionBranch,
    PULONG PinFactoryIdList
    );
STDMETHODIMP_(VOID)
FollowToTopology(
    PKSTOPOLOGY_CONNECTION Connection,
    ULONG Count,
    ULONG PinFactoryId,
    PKSTOPOLOGY_CONNECTION ConnectionBranch,
    PULONG PinFactoryIdList
    );
STDMETHODIMP_(BOOL)
IsAcquireOrderingSignificant(
    HANDLE PinHandle
    );
STDMETHODIMP
QueryAccept(
    HANDLE PinHandle,
    const AM_MEDIA_TYPE* ConfigAmMediaType,
    const AM_MEDIA_TYPE* AmMediaType
    );
STDMETHODIMP_(VOID)
DistributeSetSyncSource(
    CMarshalerList* MarshalerList,
    IReferenceClock* RefClock
    );
STDMETHODIMP_(VOID)
DistributeStop(
    CMarshalerList* MarshalerList
    );
STDMETHODIMP_(VOID)
DistributePause(
    CMarshalerList* MarshalerList
    );
STDMETHODIMP_(VOID)
DistributeRun(
    CMarshalerList* MarshalerList,
    REFERENCE_TIME Start
    );
STDMETHODIMP_(VOID)
DistributeNotifyGraphChange(
    CMarshalerList* MarshalerList
    );
STDMETHODIMP
AddAggregate(
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter,
    IN REFGUID Aggregate
    );
STDMETHODIMP
RemoveAggregate(
    CMarshalerList* MarshalerList,
    IN REFGUID Aggregate
    );
STDMETHODIMP
GetDegradationStrategies(
    HANDLE PinHandle,
    PVOID* Items
    );
STDMETHODIMP_(BOOL)
VerifyQualitySupport(
    HANDLE PinHandle
    );
STDMETHODIMP_(BOOL)
EstablishQualitySupport(
    IKsPin* Pin,
    HANDLE PinHandle,
    CKsProxy* Filter
    );
STDMETHODIMP_(PKSDEGRADE)
FindDegradeItem(
    PKSMULTIPLE_ITEM MultipleItem,
    ULONG DegradeItem
    );
STDMETHODIMP
GetAllocatorFraming(
    IN HANDLE PinHandle,
    OUT PKSALLOCATOR_FRAMING Framing
    );
STDMETHODIMP_(HANDLE)
GetObjectHandle(
    IUnknown* Object
    );
STDMETHODIMP
IsAllocatorCompatible(
    HANDLE PinHandle,
    HANDLE InputPinHandle,
    IMemAllocator* MemAllocator
    );
STDMETHODIMP_(VOID)
OpenDataHandler(
    IN const CMediaType* MediaType,
    IN IUnknown* UnkOuter OPTIONAL,
    OUT IKsDataTypeHandler** DataTypeHandler,
    OUT IUnknown** UnkInner
    );
STDMETHODIMP
GetAllocatorFramingEx(
    IN HANDLE PinHandle,
    OUT PKSALLOCATOR_FRAMING_EX* FramingEx
    );
STDMETHODIMP_(VOID)
GetFramingFromFramingEx(
    IN KSALLOCATOR_FRAMING_EX* FramingEx,
    OUT KSALLOCATOR_FRAMING* Framing
    );
STDMETHODIMP_(VOID)
ValidateFramingRange(
    IN OUT PKS_FRAMING_RANGE    Range
    );
STDMETHODIMP_(VOID)
ValidateFramingEx(
    IN OUT PKSALLOCATOR_FRAMING_EX  FramingEx
    );
STDMETHODIMP_(BOOL)
GetPinFramingFromCache(
    IN IKsPin* KsPin,
    OUT PKSALLOCATOR_FRAMING_EX* FramingEx, 
    OUT PFRAMING_PROP FramingProp,
    IN FRAMING_CACHE_OPS Option
    );
STDMETHODIMP
CreatePipe(
    IN IKsPin* KsPin,
    OUT IKsAllocatorEx** KsAllocator
    );
STDMETHODIMP
ReleasePipe(
    IN IKsAllocatorEx* KsAllocator,
    IN IKsPin* KsPin
    );
STDMETHODIMP
DeletePipe(
    IN IKsAllocatorEx* KsAllocator
    );
STDMETHODIMP
DeleteUserModePipe(
    IN IKsAllocatorEx* KsAllocator,
    IN IKsPin* KsPin
    );
STDMETHODIMP
MakePipesBasedOnFilter(
    IN IKsPin* KsPin,
    IN ULONG PinType
    );
STDMETHODIMP
MakePipeBasedOnOnePin(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN IKsPin* OppositeKsPin
    );
STDMETHODIMP
MakePipeBasedOnFixedFraming(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP
MakePipeBasedOnTwoPins(
    IN IKsPin* InPin,
    IN IKsPin* OutPin,
    IN ULONG PinType,
    IN ULONG ConnectPinType
    );
STDMETHODIMP
MakePipeBasedOnSplitter(
    IN IKsPin* InPin,
    IN IPin** OutPinList,
    IN ULONG OutPinCount,
    IN ULONG ConnectPinType
    );
STDMETHODIMP
ConnectPipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin
    );
STDMETHODIMP
ConnectPipeToUserModePin(
    IN IKsPin* OutKsPin,
    IN IMemInputPin* InMemPin
    );
STDMETHODIMP
DisconnectPins(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT BOOL* FlagBypassBaseAllocators
    );
STDMETHODIMP
InitializePipeTermination(
    IN PIPE_TERMINATION* Termin,
    IN BOOL Reset
    );
STDMETHODIMP
InitializePipe(
    IN IKsAllocatorEx* KsAllocator,
    IN BOOL Reset
    );
STDMETHODIMP_(BOOL)
CreatePipeForTwoPins(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID ConnectBus,
    IN GUID MemoryType
    );
STDMETHODIMP
MakeTwoPipesDependent(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin
    );
STDMETHODIMP_(BOOL)
IsFramingRangeDontCare(
    IN KS_FRAMING_RANGE Range
    );
STDMETHODIMP_(BOOL)
IsFramingRangeEqual(
    IN KS_FRAMING_RANGE* Range1,
    IN KS_FRAMING_RANGE* Range2
    );
STDMETHODIMP_(BOOL)
IsCompressionDontCare(
    IN KS_COMPRESSION Compression
    );
STDMETHODIMP
ResolvePipeOnConnection(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG FlagDisconnect,
    OUT ULONG* FlagChange
    );
STDMETHODIMP
ResolveNewPipeOnDisconnect(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KS_LogicalMemoryType OldLogicalMemoryType,
    IN GUID OldMemoryType,
    IN ULONG AllocatorHandlerLocation
    );
STDMETHODIMP_(BOOL)
GetFramingExFromFraming(
    OUT KSALLOCATOR_FRAMING_EX* FramingEx,
    IN KSALLOCATOR_FRAMING* Framing
    );
STDMETHODIMP_(BOOL)  
GetFramingFixedFromFramingEx(
    IN PKSALLOCATOR_FRAMING_EX FramingEx, 
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
ComputeChangeInFraming(
    IN IKsPin* KsPin, 
    IN ULONG PinType,
    IN GUID MemoryType,
    OUT ULONG* FramingDelta
    );
STDMETHODIMP_(BOOL)
SetDefaultDimensions(
    OUT PPIPE_DIMENSIONS Dimensions
    );
STDMETHODIMP_(BOOL)
ComputeNumPinsInPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT ULONG* NumPins
    );
STDMETHODIMP_(BOOL)
CanPipeUseMemoryType(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID MemoryType,
    IN KS_LogicalMemoryType LogicalMemoryType,
    IN ULONG FlagModify,
    IN ULONG QuickTest
    );
STDMETHODIMP_(BOOL)
GetBusForKsPin(
    IN IKsPin* KsPin,
    OUT GUID* Bus
    );
STDMETHODIMP_(BOOL)
IsHostSystemBus(
    IN GUID Bus
    );
STDMETHODIMP_(BOOL)
AreBusesCompatible(
    IN GUID Bus1,
    IN GUID Bus2
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByMemoryType(
    IN IKsPin* KsPin,
    IN GUID MemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByMemoryType(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID MemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByLogicalMemoryType(
    IN IKsPin* KsPin,
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByLogicalMemoryType(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByIndex(
    IN IKsPin* KsPin,
    IN ULONG FramingIndex,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByIndex(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN ULONG FramingIndex,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByBus(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID Bus,
    IN BOOL FlagMustReturnFraming,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetLogicalMemoryTypeFromMemoryType(
    IN GUID MemoryType,
    IN ULONG Flag,
    OUT KS_LogicalMemoryType* LogicalMemoryType
    );
STDMETHODIMP_(BOOL)
GetMemoryTypeFromLogicalMemoryType(
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT GUID* MemoryType
    );
STDMETHODIMP_(BOOL)
DoesPipePreferMemoryType(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID ToMemoryType,
    IN GUID FromMemoryType,
    IN ULONG Flag
    );
STDMETHODIMP
SetUserModePipe(
    IN IKsPin* KsPin,
    IN ULONG KernelPinType,
    IN OUT ALLOCATOR_PROPERTIES* Properties,
    IN ULONG PropertyPinType,
    IN ULONG BufferLimit
    );
STDMETHODIMP_(BOOL)
GetAllocatorHandlerLocationCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
GetAllocatorHandlerLocation(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorHandlerPin,
    OUT ULONG* AllocatorPinType,
    OUT ULONG* AllocatorHandlerLocation
    );
STDMETHODIMP_(BOOL)
SplitPipes(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin
    );
STDMETHODIMP_(BOOL)
FindConnectedPinOnPipe(
    IN IKsPin* KsPin,
    IN IKsAllocatorEx* KsAllocator,        
    IN BOOL FlagIgnoreKey,
    OUT IKsPin** ConnectedKsPin
    );
STDMETHODIMP_(BOOL)
FindAllConnectedPinsOnPipe(
    IN IKsPin* KsPin,
    IN IKsAllocatorEx* KsAllocator,
    OUT IKsPin** ListConnectedKsPins,
    OUT ULONG* CountConnectedKsPins
    );
STDMETHODIMP_(BOOL)
FindNextPinOnPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    IN IKsAllocatorEx* KsAllocator,     
    IN BOOL FlagIgnoreKey,
    OUT IKsPin** NextKsPin
    );
STDMETHODIMP_(BOOL)
FindFirstPinOnPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT IKsPin** FirstKsPin,
    OUT ULONG* FirstPinType
    );
STDMETHODIMP_(BOOL)
ComputeRangeBasedOnCompression(
    IN KS_FRAMING_RANGE From,
    IN KS_COMPRESSION Compression,
    OUT KS_FRAMING_RANGE* To
    );
STDMETHODIMP_(BOOL)
ComputeUlongBasedOnCompression(
    IN ULONG From,
    IN KS_COMPRESSION Compression,
    OUT ULONG* To
    );
STDMETHODIMP_(BOOL)
ReverseCompression(
    IN KS_COMPRESSION* From,
    OUT KS_COMPRESSION* To
    );
STDMETHODIMP_(BOOL)
MultiplyKsCompression(
    IN KS_COMPRESSION C1,
    IN KS_COMPRESSION C2,
    OUT KS_COMPRESSION* Res
    );
STDMETHODIMP_(BOOL)
DivideKsCompression(
    IN KS_COMPRESSION C1,
    IN KS_COMPRESSION C2,
    OUT KS_COMPRESSION* Res
    );
STDMETHODIMP_(BOOL)
IsGreaterKsExpansion(
    IN KS_COMPRESSION C1,
    IN KS_COMPRESSION C2
    );
STDMETHODIMP_(BOOL)
IsKsExpansion(
    IN KS_COMPRESSION C
    );
STDMETHODIMP_(BOOL)
FrameRangeIntersection(
    IN KS_FRAMING_RANGE In,
    IN KS_FRAMING_RANGE Out,
    OUT PKS_FRAMING_RANGE Result,
    OUT PKS_OBJECTS_INTERSECTION Intersect
    );
STDMETHODIMP_(BOOL)
IntersectFrameAlignment(
    IN ULONG In,
    IN ULONG Out,
    OUT LONG* Result
    );
STDMETHODIMP_(BOOL)
ResolvePhysicalRangesBasedOnDimensions(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx
    );
STDMETHODIMP_(BOOL)
ResolveOptimalRangesBasedOnDimensions(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx,
    IN KS_FRAMING_RANGE Range,
    IN ULONG PinType
    );
STDMETHODIMP_(BOOL)
MovePinsToNewPipe(
    IN IKsPin* KsPin,           
    IN ULONG PinType,
    IN ULONG Direction,
    IN IKsAllocatorEx* NewKsAllocator,  
    IN BOOL MoveAllPins
    );
STDMETHODIMP
ResolvePipeDimensions(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction
    );
STDMETHODIMP
CreateSeparatePipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    );
STDMETHODIMP_(BOOL)
CanMergePipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID MemoryType,
    IN ULONG FlagMerge
    );
STDMETHODIMP_(BOOL)
CanAddPinToPipeOnAnotherFilter(
    IN IKsPin* KsPinPipe,
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Flag
    );
STDMETHODIMP_(BOOL)
RemovePinFromPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    );
STDMETHODIMP_(BOOL)
CanConnectPins(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin,
    IN ULONG Flag
    );
STDMETHODIMP_(BOOL)
OptimizePipesSystem(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin
    );
STDMETHODIMP_(BOOL)
AssignPipeAllocatorHandler(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID MemoryType,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorHandlerPin,
    OUT ULONG* AllocatorPinType,
    IN BOOL FlagAssign
    );
STDMETHODIMP_(BOOL)
AssignPipeAllocatorHandlerCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
AssignAllocatorsAndPipeIdForPipePins(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN HANDLE AllocatorHandle,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorPin,
    OUT ULONG* AllocatorPinType
    );
STDMETHODIMP_(BOOL)
AssignAllocatorsAndPipeIdForPipePinsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP
FixupPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    );
STDMETHODIMP
UnfixupPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    );
STDMETHODIMP_(BOOL)
SetDefaultRange(
    OUT PKS_FRAMING_RANGE Range
    );
STDMETHODIMP_(BOOL)
SetDefaultRangeWeighted(
    OUT PKS_FRAMING_RANGE_WEIGHTED  RangeWeighted
    );
STDMETHODIMP_(BOOL)
SetDefaultCompression(
    OUT PKS_COMPRESSION Compression
    );
STDMETHODIMP_(BOOL)
IsKernelPin(
    IN IPin* Pin
    );          
STDMETHODIMP_(BOOL)
HadKernelPinBeenConnectedToUserPin(
    IN IKsPin* OutKsPin,
    IN IKsAllocatorEx* KsAllocator
    );
STDMETHODIMP_(BOOL)
CreateAllocatorCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
ReassignPipeCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
MemoryTypeCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
DimensionsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT PVOID* Param1,
    OUT PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
NumPinsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
DoesPinPreferMemoryTypeCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
WalkPipeAndProcess(
    IN IKsPin* RootKsPin,
    IN ULONG RootPinType,
    IN IKsPin* BreakKsPin,
    IN PWALK_PIPE_CALLBACK CallerCallback,
    IN PVOID* Param1,
    IN PVOID* Param2
    );
STDMETHODIMP_(BOOL)
CanPinUseMemoryType(
    IN IKsPin* KsPin,
    IN GUID MemoryType,
    IN KS_LogicalMemoryType LogicalMemoryType
    );
STDMETHODIMP_(BOOL)
IsPipeSupportPartialFrame(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT HANDLE* FirstPinHandle
    );
STDMETHODIMP_(BOOL)
ResultSinglePipe(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID ConnectBus,
    IN GUID MemoryType,
    IN IKsPinPipe* InKsPinPipe,
    IN IKsPinPipe* OutKsPinPipe,
    IN IMemAllocator* MemAllocator,
    IN IKsAllocatorEx* KsAllocator,
    IN ULONG ExistingPipePinType
    );
STDMETHODIMP_(BOOL)
ResultSeparatePipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN ULONG OutPinType,
    IN ULONG ExistingPipePinType,
    IN IKsAllocatorEx* KsAllocator
    );
STDMETHODIMP_(BOOL)
FindCommonMemoryTypeBasedOnPipeAndPin(
    IN IKsPin* PipeKsPin,
    IN ULONG PipePinType,
    IN IKsPin* ConnectKsPin,
    IN ULONG ConnectPinType,
    IN BOOL FlagMerge,
    OUT GUID* MemoryType
    );
STDMETHODIMP_(BOOL)
SplitterCanAddPinToPipes(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KEY_PIPE_DATA* KeyPipeData,
    IN ULONG KeyPipeDataCount
    );
STDMETHODIMP_(BOOL)
FindCommonMemoryTypesBasedOnBuses(
    IN PKSALLOCATOR_FRAMING_EX FramingEx1,
    IN PKSALLOCATOR_FRAMING_EX FramingEx2,
    IN GUID Bus1,
    IN GUID Bus2,
    IN OUT ULONG* CommonMemoryTypesCount,
    OUT GUID* CommonMemoryTypesList
    );
STDMETHODIMP_(BOOL)
FindAllPinMemoryTypesBasedOnBus(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID Bus,
    IN OUT ULONG* MemoryTypesCount,
    OUT GUID* MemoryTypesList
    );
STDMETHODIMP_(BOOL)
AddPinToPipeUnconditional(
    IN IKsPin* PipeKsPin,
    IN ULONG PipePinType,
    IN IKsPin* ConnectKsPin,
    IN ULONG ConnectPinType
    );
STDMETHODIMP_(BOOL)
GetFriendlyBusNameFromBusId(
    IN GUID BusId,
    OUT PTCHAR BusName
    );
STDMETHODIMP_(BOOL)
GetFriendlyLogicalMemoryTypeNameFromId(
    IN ULONG LogicalMemoryType,
    OUT PTCHAR LogicalMemoryName
    );
STDMETHODIMP_(BOOL)
DerefPipeFromPin(
    IN IPin* Pin
    );
STDMETHODIMP_(BOOL)
IsSpecialOutputReqs(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT IKsPin** OppositeKsPin,
    OUT ULONG* KsPinBufferSize,
    OUT ULONG* OppositeKsPinBufferSize
    );
STDMETHODIMP_(BOOL)
CanResizePipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG RequestedSize
    );
STDMETHODIMP_(BOOL)
AdjustBufferSizeWithStepping(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx
    );
STDMETHODIMP_(VOID)
SetDefaultFramingExItems(
    IN OUT PKSALLOCATOR_FRAMING_EX FramingEx
    );
STDMETHODIMP_(BOOL)
CanAllocateMemoryType(
    IN GUID MemoryType
    );
STDMETHODIMP_(BOOL)
IsKernelModeConnection(
    IN IKsPin* KsPin
    );

#endif // _KSIPROXY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksolay\ksolay.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksolay.cpp

Abstract:

    Provides a Property set interface handler for IOverlay and IOverlayNotify2.

--*/

#include <windows.h>
#include <tchar.h>
#include <streams.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "ksolay.h"

#define WM_NEWCOLORREF (WM_USER)

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = 
{
    {L"OverlayPropSet", &KSPROPSETID_OverlayUpdate, COverlay::CreateInstance}
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


#ifdef __IOverlayNotify2_FWD_DEFINED__
//
// Defined by the standard DLL loading code in the base classes.
//
extern HINSTANCE g_hInst;

static const TCHAR PaintWindowClass[] = TEXT("KSOverlayPaintWindowClass");
#endif


CUnknown*
CALLBACK
COverlay::CreateInstance(
    LPUNKNOWN UnkOuter,
    HRESULT* hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of an IOverlay
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new COverlay(UnkOuter, NAME("OverlayPropSet"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


COverlay::COverlay(
    LPUNKNOWN UnkOuter,
    TCHAR* Name,
    HRESULT* hr
    ) :
    CUnknown(Name, NULL),
    m_Object(NULL),
    m_Overlay(NULL),
    m_UnkOwner(UnkOuter)
/*++

Routine Description:

    The constructor for the Overlay Property Set objects. Does base class
    initialization for the Overlay interface objects.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    //
    // This object does not use the UnkOuter because it exposes no interfaces
    // which would ever be obtained by a client (IDistributorNotify is only
    // queried by the proxy, and used internally). Also, since Advise references
    // the given object, circular referencing would occur. So this separate
    // object allows the referencing/dereferencing to occur without having to
    // do increment/decrements on the refcount when using Advise/Unadvise.
    //
    // The parent must support the IKsObject interface in order to obtain
    // the handle to communicate to.
    //
    ASSERT(UnkOuter);
    //
    // This just does the normal initialization as if the pin were being
    // reconnected.
    //
    *hr = NotifyGraphChange();
}


COverlay::~COverlay(
    )
/*++

Routine Description:

    The desstructor for the Overlay Property Set object. Ensures that all
    the advise requests have been terminated.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    if (m_Overlay) {
        m_Overlay->Unadvise();
    }
}


STDMETHODIMP
COverlay::NonDelegatingQueryInterface(
    REFIID riid,
    PVOID* ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The module does not actually
    support any interfaces from the point of view of the filter user, only
    from the point of view of the overlay notification source.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IDistributorNotify)) {
        //
        // The IDistributorNotify interface will be queried by the proxy
        // in order to send graph change notifications. It will not hold
        // onto a reference count for the interface.
        //
        return GetInterface(static_cast<IDistributorNotify*>(this), ppv);
#ifdef __IOverlayNotify2_FWD_DEFINED__
    } else if (riid == __uuidof(IOverlayNotify2)) {
        //
        // The IOverlayNotify2 interface will be queried by the overlay
        // notification source if the driver sets the ADVISE_DISPLAY_CHANGE
        // notification bit.
        //
        return GetInterface(static_cast<IOverlayNotify2*>(this), ppv);
#endif // __IOverlayNotify2_FWD_DEFINED__
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
COverlay::Stop(
    )
/*++

Routine Description:

    Implements the IDistributorNotify::Stop method. The forwarder
    does not need to do anything on this notification.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP
COverlay::Pause(
     )
/*++

Routine Description:

    Implements the IDistributorNotify::Pause method. The forwarder
    does not need to do anything on this notification.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP
COverlay::Run(
    REFERENCE_TIME  Start
    )
/*++

Routine Description:

    Implements the IDistributorNotify::Run method. The forwarder
    does not need to do anything on this notification.

Arguments:

    Start -
        The reference time at which the state change should occur.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP
COverlay::SetSyncSource(
    IReferenceClock*    RefClock
    )
/*++

Routine Description:

    Implements the IDistributorNotify::SetSyncSource method. The forwarder
    does not need to do anything on this notification.

Arguments:

    RefClock -
        The interface pointer on the new clock source, else NULL if any current
        clock source is being abandoned.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP
COverlay::NotifyGraphChange(
    )
/*++

Routine Description:

    Implements the IDistributorNotify::NotifyGraphChange method. This
    is called when the pin is being connected or disconnected subsequent
    to the initial loading of this instance.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    IKsObject*  PinObject;
    HRESULT     hr;

    //
    // Since this pin has been disconnected, any Advise which has been
    // set up must be removed. There may not be an Advise, because this
    // might have been called from the constructor, or initial setup
    // may have failed.
    //
    if (m_Overlay) {
        m_Overlay->Unadvise();
        //
        // Ensure that on subsequent failure an Unadvise will not be
        // performed on this object during the destructor.
        //
        m_Overlay = NULL;
    }
    hr = m_UnkOwner->QueryInterface(__uuidof(PinObject), reinterpret_cast<PVOID*>(&PinObject));
    if (SUCCEEDED(hr)) {
        //
        // If this is a new connection of the pin, then there will be an object
        // handle, else this will return NULL.
        //
        m_Object = PinObject->KsGetObjectHandle();
        //
        // Do not leave reference counts so that the filter can be destroyed.
        //
        PinObject->Release();
        //
        // If this is a connection, then set up Advise.
        //
        if (m_Object) {
            KSPROPERTY  Property;
            ULONG       BytesReturned;
            ULONG       Interests;

            //
            // Retrieve the interests for this device. These will determine
            // which notification occur. These flags map directly to the
            // DirectShow Overlay Interests flags.
            //
            Property.Set = KSPROPSETID_OverlayUpdate;
            Property.Id = KSPROPERTY_OVERLAYUPDATE_INTERESTS;
            Property.Flags = KSPROPERTY_TYPE_GET;
            hr = ::KsSynchronousDeviceControl(
                m_Object,
                IOCTL_KS_PROPERTY,
                &Property,
                sizeof(Property),
                &Interests,
                sizeof(Interests),
                &BytesReturned);
            if (SUCCEEDED(hr)) {
                IPin*   Pin;

                hr = m_UnkOwner->QueryInterface(
                    __uuidof(Pin),
                    reinterpret_cast<PVOID*>(&Pin));
                if (SUCCEEDED(hr)) {
                    IPin*   ConnectedPin;

                    //
                    // The connected pin is the one which will support the
                    // IOverlay interface on which the Advise should be
                    // started.
                    //
                    hr = Pin->ConnectedTo(&ConnectedPin);
                    if (SUCCEEDED(hr)) {
                        hr = ConnectedPin->QueryInterface(
                            __uuidof(m_Overlay),
                            reinterpret_cast<PVOID*>(&m_Overlay));
                        if (SUCCEEDED(hr)) {
#ifndef __IOverlayNotify2_FWD_DEFINED__
                            Interests &= ADVISE_ALL;
#endif // !__IOverlayNotify2_FWD_DEFINED__
                            //
                            // The interests returned by the driver are just
                            // the properties which will be later accessed,
                            // and map directly to Advise constants.
                            //
                            hr = m_Overlay->Advise(
#ifdef __IOverlayNotify2_FWD_DEFINED__
                                static_cast<IOverlayNotify*>(static_cast<IOverlayNotify2*>(this)),
#else // !__IOverlayNotify2_FWD_DEFINED__
                                this,
#endif //!__IOverlayNotify2_FWD_DEFINED__
                                Interests);

                            //
                            // This can be released because this current object
                            // is deleted when the pin is being deleted.
                            // So the interface is actually always valid as long
                            // as this object is around. This avoids circular
                            // referencing, while still allowing Unadvise to occur.
                            //
                            m_Overlay->Release();
                            //
                            // Ensure that an Unadvise is not performed in the
                            // destructor, since this Advise failed.
                            //
                            if (FAILED(hr)) {
                                m_Overlay = NULL;
                            }
                        }
                        ConnectedPin->Release();
                    }
                    Pin->Release();
                }
            }
        } else {
            hr = VFW_E_NOT_CONNECTED;
        }
    }
    return hr;
}


STDMETHODIMP
COverlay::OnPaletteChange( 
    DWORD Colors,
    const PALETTEENTRY* Palette
    )
/*++

Routine Description:

    Implement the IOverlayNotify2::OnPaletteChange method.

Arguments:

    Colors -
        The number of colors in the Palette parameter.

    Palette -
        The new palette entries

Return Value:

    Returns NOERROR if the new palette was applied.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    if (!m_Object) {
        return VFW_E_NOT_CONNECTED;
    }
    Property.Set = KSPROPSETID_OverlayUpdate;
    Property.Id = KSPROPERTY_OVERLAYUPDATE_PALETTE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_Object,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        const_cast<PALETTEENTRY*>(Palette),
        Colors * sizeof(*Palette),
        &BytesReturned);
}


STDMETHODIMP
COverlay::OnClipChange( 
    const RECT* Source,
    const RECT* Destination,
    const RGNDATA* Region
    )
/*++

Routine Description:

    Implement the IOverlayNotify2::OnClipChange method.

Arguments:

    Source -
        The new source rectangle.

    Destination -
        The new destination rectangle.

    Region -
        The new clipping region.

Return Value:

    Returns NOERROR if the new clipping was applied.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    HRESULT     hr;
    PBYTE       Data;

    if (!m_Object) {
        return VFW_E_NOT_CONNECTED;
    }
    Property.Set = KSPROPSETID_OverlayUpdate;
    Property.Id = KSPROPERTY_OVERLAYUPDATE_CLIPLIST;
    Property.Flags = KSPROPERTY_TYPE_SET;
    //
    // The serialized format contains:
    //     Source
    //     Destination
    //     Region
    //
    Data = new BYTE[sizeof(*Source) + sizeof(*Destination) + Region->rdh.dwSize];
    if (!Data) {
        return E_OUTOFMEMORY;
    }
    //
    // This needs to be copied to a temporary buffer first,
    // because the source and destination rectangles must
    // be serialized.
    //
    *reinterpret_cast<RECT*>(Data) = *Source;
    *(reinterpret_cast<RECT*>(Data) + 1) = *Destination;
    memcpy(Data + sizeof(*Source) + sizeof(*Destination), Region, Region->rdh.dwSize);
    hr = ::KsSynchronousDeviceControl(
        m_Object,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Data,
        sizeof(*Source) + sizeof(*Destination) + Region->rdh.dwSize,
        &BytesReturned);
    delete [] Data;
    return hr;
}


STDMETHODIMP
COverlay::OnColorKeyChange( 
    const COLORKEY* ColorKey
    )
/*++

Routine Description:

    Implement the IOverlayNotify2::OnColorKeyChange method.

Arguments:

    ColorKey -
        The new color key.

Return Value:

    Returns NOERROR if the new color key was applied.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    if (!m_Object) {
        return VFW_E_NOT_CONNECTED;
    }
    Property.Set = KSPROPSETID_OverlayUpdate;
    Property.Id = KSPROPERTY_OVERLAYUPDATE_COLORKEY;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_Object,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        const_cast<COLORKEY*>(ColorKey),
        sizeof(*ColorKey),
        &BytesReturned);
}


STDMETHODIMP
COverlay::OnPositionChange( 
    const RECT* Source,
    const RECT* Destination
    )
/*++

Routine Description:

    Implement the IOverlayNotify2::OnPositionChange method.

Arguments:

    Source -
        The new source rectangle.

    Destination -
        The new destination rectangle.

Return Value:

    Returns NOERROR if the new position was applied.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    RECT        Rects[2];

    if (!m_Object) {
        return VFW_E_NOT_CONNECTED;
    }
    Property.Set = KSPROPSETID_OverlayUpdate;
    Property.Id = KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION;
    Property.Flags = KSPROPERTY_TYPE_SET;
    //
    // These rectangles must be serialized as follows:
    //
    Rects[0] = *Source;
    Rects[1] = *Destination;
    return ::KsSynchronousDeviceControl(
        m_Object,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Rects,
        sizeof(Rects),
        &BytesReturned);
}

#ifdef __IOverlayNotify2_FWD_DEFINED__

STDMETHODIMP
COverlay::OnDisplayChange( 
    HMONITOR Monitor
    )
/*++

Routine Description:

    Implement the IOverlayNotify2::OnDisplayChange method. This is called
    on a WM_DISPLAYCHANGE notification.

Arguments:

    Monitor -
        Contains the handle of the monitor on which overlay is occuring.

Return Value:

    Returns NOERROR.

--*/
{
    KSPROPERTY          Property;
    ULONG               BytesReturned;
    HRESULT             hr;
    MONITORINFOEX       MonitorInfo;
    DEVMODE             DevMode;
    DISPLAY_DEVICE      DisplayDevice;
    PKSDISPLAYCHANGE    DisplayChange;
    BYTE                DisplayBuffer[sizeof(*DisplayChange)+sizeof(DisplayDevice.DeviceID)/sizeof(TCHAR)*sizeof(WCHAR)];

    if (!m_Object) {
        return VFW_E_NOT_CONNECTED;
    }
    Property.Set = KSPROPSETID_OverlayUpdate;
    Property.Id = KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    //
    // Determine name of the monitor so that the display settings
    // and device information can be retrieved.
    //
    MonitorInfo.cbSize = sizeof(MonitorInfo);
    if (!GetMonitorInfo(Monitor, &MonitorInfo)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    //
    // Retrieve the x, y, and bit depth of this display.
    //
    DevMode.dmSize = sizeof(DevMode);
    DevMode.dmDriverExtra = 0;
    if (!EnumDisplaySettings(MonitorInfo.szDevice, ENUM_CURRENT_SETTINGS, &DevMode)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    //
    // Look for the display given the original name. The structure
    // will have the unique device identifier in it which can then
    // be used by the driver.
    //
    for (ULONG Device = 0;; Device++) {
        DisplayDevice.cb = sizeof(DisplayDevice);
        //
        // If the display device could not be found, or an error occurs,
        // just exit with the error.
        //
        if (!EnumDisplayDevices(NULL, Device, &DisplayDevice, 0)) {
            return HRESULT_FROM_WIN32(GetLastError());
        }
        //
        // Determine if this is the same device which was retrieved
        // from the monitor information.
        //
        if (!_tcscmp(DisplayDevice.DeviceName, MonitorInfo.szDevice)) {
            break;
        }
    }
    //
    // Initialize the display change structure to be passed in the
    // notification.
    //
    DisplayChange = reinterpret_cast<PKSDISPLAYCHANGE>(DisplayBuffer);
    DisplayChange->PelsWidth = DevMode.dmPelsWidth;
    DisplayChange->PelsHeight = DevMode.dmPelsHeight;
    DisplayChange->BitsPerPel = DevMode.dmBitsPerPel;
    //
    // Retrieve the number of characters in the string, including
    // the terminating NULL, in order to pass on the notification
    // property correctly.
    //
#ifdef _UNICODE
    Device = _tcslen(DisplayDevice.DeviceID);
    _tcscpy(DisplayChange->DeviceID, DisplayDevice.DeviceID);
#else //! _UNICODE
    //
    // Remove the size of the NULL terminator, which is already
    // included in the size of the DisplayChange structure.
    //
    Device = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        DisplayDevice.DeviceID,
        -1,
        DisplayChange->DeviceID,
        sizeof(DisplayDevice.DeviceID) * sizeof(WCHAR)) - 1;
#endif //! _UNICODE
    hr = ::KsSynchronousDeviceControl(
        m_Object,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        DisplayChange,
        sizeof(*DisplayChange) + Device * sizeof(WCHAR),
        &BytesReturned);
    //
    // If the driver has not dealt with this resolution before,
    // then it will complain, stating that it has more data to
    // present to the client. The list of colors which it wants
    // to paint will then be queried.
    //
    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        HWND    PaintWindow;

        //
        // Create a full screen window to paint on so that hardware
        // can calibrate.
        //
        PaintWindow = CreateFullScreenWindow(&MonitorInfo.rcMonitor);
        if (PaintWindow) {
            Property.Id = KSPROPERTY_OVERLAYUPDATE_COLORREF;
            Property.Flags = KSPROPERTY_TYPE_GET;
            for (;;) {
                COLORREF    ColorRef;

                //
                // Request a color to paint with. If this is not
                // the initial request, then the driver can probe
                // its hardware based on the previous color retrieved.
                //
                hr = ::KsSynchronousDeviceControl(
                    m_Object,
                    IOCTL_KS_PROPERTY,
                    &Property,
                    sizeof(Property),
                    &ColorRef,
                    sizeof(ColorRef),
                    &BytesReturned);
                //
                // If another color was retrieved, paint with it.
                //
                if (SUCCEEDED(hr)) {
                    SendMessage(PaintWindow, WM_NEWCOLORREF, 0, ColorRef);
                } else {
                    //
                    // If the end of the list of colors was reached,
                    // just return success.
                    //
                    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
                        hr = NOERROR;
                    }
                    break;
                }
            }
            DestroyWindow(PaintWindow);
            UnregisterClass(PaintWindowClass, g_hInst);
        } else {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return hr;
}


STDMETHODIMP_(HWND)
COverlay::CreateFullScreenWindow( 
    PRECT MonitorRect
    )
/*++

Routine Description:

    Implement the COverlay::CreateFullScreenWindow method. This is called
    to create a full screen window in order to allow painting with various
    colors to probe hardware.

Arguments:

    MonitorRect -
        The absolute location of monitor.

Return Value:

    Returns the handle of the window created, else NULL.

--*/
{
    WNDCLASSEX  WindowClass;
    HWND        PaintWindow;

    WindowClass.cbSize = sizeof(WindowClass);
    WindowClass.style = CS_HREDRAW | CS_VREDRAW;
    WindowClass.lpfnWndProc = PaintWindowCallback;
    WindowClass.cbClsExtra = 0;
    WindowClass.cbWndExtra = 0;
    WindowClass.hInstance = g_hInst;
    WindowClass.hIcon = NULL;
    WindowClass.hCursor = NULL;
    WindowClass.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_APPWORKSPACE + 1);
    WindowClass.lpszMenuName = NULL;
    WindowClass.lpszClassName = PaintWindowClass;
    WindowClass.hIconSm = NULL;
    if (!RegisterClassEx(&WindowClass)) {
        return NULL;
    }
    //
    // Create a window which covers the entire monitor on which
    // overlay is occuring.
    //
    PaintWindow = CreateWindowEx(
        WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
        PaintWindowClass,
        NULL,
        WS_POPUP | WS_VISIBLE,
        MonitorRect->left,
        MonitorRect->top,
        MonitorRect->right - MonitorRect->left,
        MonitorRect->bottom - MonitorRect->top,
        NULL,
        NULL,
        g_hInst,
        NULL);
    if (!PaintWindow) {
        UnregisterClass(PaintWindowClass, g_hInst);
    }
    return PaintWindow;
}


LRESULT
CALLBACK
COverlay::PaintWindowCallback(
    HWND Window,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    Implement the COverlay::PaintWindowCallback method. This is called
    in response to a message being sent to the window. This implements
    the full screen paint window, which is used to paint specified colors
    to a window for hardware probing.

Arguments:

    Window -
        The handle of the window.

    Message -
        The window message to process.

    wParam -
        Depends on the message.

    lParam -
        Depends on the message.

Return Value:

    Depends on the message.

--*/
{
    switch (Message) {
    case WM_CREATE:
        //
        // The cursor must be hidden so that it does no interfere with the
        // analog signal and provides a pure signal of the color the window
        // is supposed to represent.
        //
        ShowCursor(FALSE);
        break;
    case WM_DESTROY:
        ShowCursor(TRUE);
        break;
    case WM_PAINT:
        PAINTSTRUCT ps;

        BeginPaint(Window, &ps);
        EndPaint(Window, &ps);
        return (LRESULT)1;
    case WM_NEWCOLORREF:
        RECT        ClientRect;
        HDC         hdc;

        //
        // A new background color is specified in the lParam. This
        // should be used in painting the entire window.
        //
        GetClientRect(Window, &ClientRect);
        hdc = GetDC(Window);
        SetBkColor(hdc, *reinterpret_cast<COLORREF*>(&lParam));
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &ClientRect, NULL, 0, NULL);
        ReleaseDC(Window, hdc);
        return 0;
    }
    return DefWindowProc(Window, Message, wParam, lParam);
}
#endif //__IOverlayNotify2_FWD_DEFINED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksproxy\ksoutpin.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksoutpin.cpp

Abstract:

    Provides a generic Active Movie wrapper for a kernel mode filter (WDM-CSA).

Author(s):

    Thomas O'Rourke (tomor) 2-Feb-1996
    George Shaw (gshaw)
    Bryan A. Woodruff (bryanw) 
    
--*/

#include <windows.h>
#ifdef WIN9X_KS
#include <comdef.h>
#endif // WIN9X_KS
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <limits.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>
#include "ksiproxy.h"

#if DBG || defined(DEBUG)
extern ULONG DataFlowVersion;
#endif


CKsOutputPin::CKsOutputPin(
    TCHAR* ObjectName,
    int PinFactoryId,
    CLSID ClassId,
    CKsProxy* KsProxy,
    HRESULT* hr,
    WCHAR* PinName
    ) :
    CBaseOutputPin(
        ObjectName,
        KsProxy,
        KsProxy,
        hr,
        PinName),
        CBaseStreamControl(),
        m_IoQueue(
            NAME("I/O queue")),
        m_PinHandle(NULL),
        m_IoThreadHandle(NULL),
        m_IoThreadQueue(
            NAME("I/O thread queue")),
        m_IoThreadSemaphore(NULL),
        m_IoThreadId(0),
        m_DataTypeHandler(NULL),
        m_UnkInner(NULL),
        m_InterfaceHandler(NULL),
        m_MarshalData(TRUE),
        m_PinFactoryId(PinFactoryId),
        m_PropagatingAcquire(FALSE),
        m_PendingIoCompletedEvent(NULL),
        m_PendingIoCount(0),
        m_MarshalerList(
            NAME("Marshaler list")),
        m_UsingThisAllocator(FALSE),
        m_QualitySupport(FALSE),
        m_LastSampleDiscarded(TRUE),
        m_ConfigAmMediaType(NULL),
        m_DeliveryError(FALSE),
        m_EndOfStream(FALSE),
        m_RelativeRefCount(1),
        m_pKsAllocator( NULL ),
        m_PinBusCacheInit(FALSE),
        m_fPipeAllocator(0),
        m_hEOSevent( NULL ),
        m_hMarshalEvent( NULL ),
        m_hFlushEvent( NULL ),
        m_hFlushCompleteEvent( NULL ),
        m_FlushMode( FLUSH_NONE ),
        m_pAsyncItemHandler( NULL ),
        m_bFlushing( FALSE )
/*++

Routine Description:

    The constructor for a pin. This function is passed an error return
    parameter so that initialization errors can be passed back. It calls the
    base class implementation constructor to initialize it's data memebers.

Arguments:

    ObjectName -
        This identifies the object for debugging purposes.

    PinFactoryId -
        Contains the pin factory identifier on the kernel filter that this
        pin instance represents.

    KsProxy -
        Contains the proxy on which this pin exists.

    hr -
        The place in which to put any error return.

    PinName -
        Contains the name of the pin to present to any query.

Return Value:

    Nothing.

--*/
{
    RtlZeroMemory(m_FramingProp, sizeof(m_FramingProp));
    RtlZeroMemory(m_AllocatorFramingEx, sizeof(m_AllocatorFramingEx));

    if (SUCCEEDED( *hr )) {
        TCHAR       RegistryPath[64];
        
        DECLARE_KSDEBUG_NAME(EventName);

        BUILD_KSDEBUG_NAME(EventName, _T("EvOutPendingIo#%p"), this);
        m_PendingIoCompletedEvent =
            CreateEvent( 
                NULL,       // LPSECURITY_ATTRIBUTES lpEventAttributes
                FALSE,      // BOOL bManualReset
                FALSE,      // BOOL bInitialState
                KSDEBUG_NAME(EventName) );     // LPCTSTR lpName
        ASSERT(KSDEBUG_UNIQUE_NAME());

        if (m_PendingIoCompletedEvent) {
            *hr = KsProxy->GetPinFactoryCommunication(m_PinFactoryId, &m_OriginalCommunication);
        
            //
            // This is always initialized so that it can be queried, and changes
            // on actual device handle creation.
            //
            m_CurrentCommunication = m_OriginalCommunication;
            //
            // This type of pin will never actually be connected to, but should
            // have a media type selected.
            //
            if (m_CurrentCommunication == KSPIN_COMMUNICATION_NONE) {
                CMediaType      MediaType;

                *hr = GetMediaType(0, &MediaType);
                if (SUCCEEDED(*hr)) {
                    SetMediaType(&MediaType);
                }
            }
            //
            // Load any extra interfaces on the proxy that have been specified in
            // this pin factory id entry.
            //
            _stprintf(RegistryPath, TEXT("PinFactory\\%u\\Interfaces"), PinFactoryId);
            ::AggregateMarshalers(
                KsProxy->QueryDeviceRegKey(),
                RegistryPath,
                &m_MarshalerList,
                static_cast<IKsPin*>(this));

            //
            // Clear the initial suggested properties.
            //        

            m_SuggestedProperties.cBuffers = -1;
            m_SuggestedProperties.cbBuffer = -1;
            m_SuggestedProperties.cbPrefix = -1;
            m_SuggestedProperties.cbAlign = -1;
        } else {
            DWORD LastError = GetLastError();
            *hr = HRESULT_FROM_WIN32( LastError );
        }
    }
}


CKsOutputPin::~CKsOutputPin(
    )
/*++

Routine Description:

    The destructor for the pin instance. Cleans up any outstanding resources.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    //
    // Protect against a spurious delete because of aggregation. No need to
    // use an interlocking increment, as the object is being destroyed.
    //
    if (m_PinHandle) {
        //
        // Unload any extra interfaces based on the Property/Method/Event sets
        // supported by this object.
        //
        ::UnloadVolatileInterfaces(&m_MarshalerList, TRUE);
        //
        // Terminate any previous EOS notification that may have been started.
        //
        if (NULL != m_hEOSevent) {
            ULONG bytesReturned;
            KsEvent( NULL, 0, NULL, 0, &bytesReturned );
            m_pAsyncItemHandler->RemoveAsyncItem( m_hEOSevent );
            m_hEOSevent = NULL;
        }

        ::SetSyncSource( m_PinHandle, NULL );
        CloseHandle(m_PinHandle);
    }   
    if (m_PendingIoCompletedEvent) {
        CloseHandle(m_PendingIoCompletedEvent);
    }
    if (m_hFlushCompleteEvent) {
        CloseHandle(m_hFlushCompleteEvent);
    }
    if (m_DataTypeHandler) {
        m_DataTypeHandler = NULL;
        SAFERELEASE( m_UnkInner );
    }
    if (m_InterfaceHandler) {
        m_InterfaceHandler->Release();
    }
    //
    // May have been set with IAMStreamConfig::SetFormat
    //
    if (m_ConfigAmMediaType) {
        DeleteMediaType(m_ConfigAmMediaType);
    }
    ::FreeMarshalers(&m_MarshalerList);

    SAFERELEASE( m_pKsAllocator );
    SAFERELEASE( m_pAllocator );

    for (ULONG Count = 0; Count < SIZEOF_ARRAY(m_AllocatorFramingEx); Count++) {
        if (m_AllocatorFramingEx[Count]) {
            for (ULONG Remainder = Count + 1; Remainder < SIZEOF_ARRAY(m_AllocatorFramingEx); Remainder++) {
                if (m_AllocatorFramingEx[Count] == m_AllocatorFramingEx[Remainder]) {
                    m_AllocatorFramingEx[Remainder] = NULL;
                }
            }
            delete m_AllocatorFramingEx[Count];
            m_AllocatorFramingEx[Count] = NULL;
        }
    }

    if (m_pAsyncItemHandler) {
        delete m_pAsyncItemHandler;
        m_pAsyncItemHandler = NULL;
    }
}


STDMETHODIMP
CKsOutputPin::GetCapabilities(
    DWORD* Capabilities
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetCapabilities method.

Arguments:

    Capabilities -
        The place in which to return the capabilities of the underlying
        filter, limited by the upstream connections.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->GetCapabilities(Capabilities);
}


STDMETHODIMP
CKsOutputPin::CheckCapabilities(
    DWORD* Capabilities
    )
/*++

Routine Description:

    Implement the IMediaSeeking::CheckCapabilities method.

Arguments:

    Capabilities -
        The place containing the original set of capabilities being
        queried, and in which to return the subset of capabilities
        actually supported.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->CheckCapabilities(Capabilities);
}


STDMETHODIMP
CKsOutputPin::IsFormatSupported(
    const GUID* Format
    )
/*++

Routine Description:

    Implement the IMediaSeeking::IsFormatSupported method.

Arguments:

    Format -
        Contains the time format to to compare against.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->IsFormatSupported(Format);
}


STDMETHODIMP
CKsOutputPin::QueryPreferredFormat(
    GUID* Format
    )
/*++

Routine Description:

    Implement the IMediaSeeking::QueryPreferredFormat method.

Arguments:

    Format -
        The place in which to put the preferred format.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->QueryPreferredFormat(Format);
}


STDMETHODIMP
CKsOutputPin::GetTimeFormat(
    GUID* Format
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetTimeFormat method.

Arguments:

    Format -
        The place in which to put the current format.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->GetTimeFormat(Format);
}


STDMETHODIMP
CKsOutputPin::IsUsingTimeFormat(
    const GUID* Format
    )
/*++

Routine Description:

    Implement the IMediaSeeking::IsUsingTimeFormat method.

Arguments:

    Format -
        Contains the time format to compare against the current time
        format.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->IsUsingTimeFormat(Format);
}


STDMETHODIMP
CKsOutputPin::SetTimeFormat(
    const GUID* Format
    )
/*++

Routine Description:

    Implement the IMediaSeeking::SetTimeFormat method.

Arguments:

    Format -
        Contains the new time format to use.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->SetTimeFormat(Format);
}


STDMETHODIMP
CKsOutputPin::GetDuration(
    LONGLONG* Duration
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetDuration method.

Arguments:

    Duration -
        The place in which to put the total duration of the longest
        stream.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->GetDuration(Duration);
}


STDMETHODIMP
CKsOutputPin::GetStopPosition(
    LONGLONG* Stop
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetStopPosition method.

Arguments:

    Stop -
        The place in which to put the current stop position.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->GetStopPosition(Stop);
}


STDMETHODIMP
CKsOutputPin::GetCurrentPosition(
    LONGLONG* Current
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetCurrentPosition method.

Arguments:

    Current -
        The place in which to put the current position.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->GetCurrentPosition(Current);
}


STDMETHODIMP
CKsOutputPin::ConvertTimeFormat(
    LONGLONG* Target,
    const GUID* TargetFormat,
    LONGLONG Source,
    const GUID* SourceFormat
    )
/*++

Routine Description:

    Implement the IMediaSeeking::ConvertTimeFormat method.

Arguments:

    Target -
        The place in which to put the converted time.

    TargetFormat -
        Contains the target time format.

    Source -
        Contains the source time to convert.

    SourceFormat -
        Contains the source time format.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->ConvertTimeFormat(Target, TargetFormat, Source, SourceFormat);
}


STDMETHODIMP
CKsOutputPin::SetPositions(
    LONGLONG* Current,
    DWORD CurrentFlags,
    LONGLONG* Stop,
    DWORD StopFlags
    )
/*++

Routine Description:

    Implement the IMediaSeeking::SetPositions method.

Arguments:

    Current -
        Optionally contains the current position to set.

    CurrentFlags -
        Contains flags pertaining to the Current parameter.

    Stop -
        Optionally contains the stop position to set.

    StopFlags -
        Contains flags pertaining to the Stop parameter.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->SetPositions(Current, CurrentFlags, Stop, StopFlags);
}


STDMETHODIMP
CKsOutputPin::GetPositions(
    LONGLONG* Current,
    LONGLONG* Stop
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetPositions method.

Arguments:

    Current -
        The place in which to put the current position.

    Stop -
        The place in which to put the current stop position.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->GetPositions(Current, Stop);
}


STDMETHODIMP
CKsOutputPin::GetAvailable(
    LONGLONG* Earliest,
    LONGLONG* Latest
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetAvailable method.

Arguments:

    Earliest -
        The place in which to put the earliest position available.

    Latest -
        The place in which to put the latest position available.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->GetAvailable(Earliest, Latest);
}


STDMETHODIMP
CKsOutputPin::SetRate(
    double Rate
    )
/*++

Routine Description:

    Implement the IMediaSeeking::SetRate method.

Arguments:

    Rate -
        Not used.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->SetRate(Rate);
}


STDMETHODIMP
CKsOutputPin::GetRate(
    double* Rate
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetRate method.

Arguments:

    Rate -
        Not used.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->GetRate(Rate);
}


STDMETHODIMP
CKsOutputPin::GetPreroll(
    LONGLONG* Preroll
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetPreroll method.

Arguments:

    Preroll -
        The place in which to put the preroll time.

Return Value:

    Returns the response from the filter object.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->GetPreroll(Preroll);
}


DWORD 
CKsOutputPin::IoThread(
    CKsOutputPin* KsOutputPin
    ) 

/*++

Routine Description:
    This is the I/O thread created for output pins on filters with more than
    one pin when the connected input pin can block.

Arguments:
    KsOuputPin - 
        context pointer which is a pointer to the instance of this pin.
        
Return Value:
    return value is always 0

--*/

{
    ULONG   WaitResult;
    
    HANDLE  WaitObjects[ 2 ] = 
    { 
        KsOutputPin->m_IoThreadExitEvent, 
        KsOutputPin->m_IoThreadSemaphore 
    };
    
    DbgLog((
        LOG_TRACE,
        2,
        TEXT("%s(%s)::IoThread() startup."),
        static_cast<CKsProxy*>(KsOutputPin->m_pFilter)->GetFilterName(),
        KsOutputPin->m_pName ));

    ASSERT( KsOutputPin->m_IoThreadExitEvent );
    ASSERT( KsOutputPin->m_IoThreadSemaphore );

    for (;;) {
        WaitResult = 
            WaitForMultipleObjectsEx( 
                SIZEOF_ARRAY( WaitObjects ),
                WaitObjects,
                FALSE,      // BOOL bWaitAll
                INFINITE,   // DWORD dwMilliseconds
                FALSE );

        switch (WaitResult) {

        case WAIT_OBJECT_0:
            //
            // The thread is signalled to exit. All I/O should have been
            // completed by this point by the Inactive method waiting on
            // the completion event.
            //
            ASSERT(!KsOutputPin->m_PendingIoCount);
            return 0;
            
        default:
        {
            HRESULT         hr;
            IMediaSample    *Sample;
            CKsProxy        *KsProxy;
            BOOL            EOSFlag;
            
            //
            // The I/O semaphore was signalled, grab a frame from the
            // queue and deliver it.
            //
            
            KsOutputPin->m_IoCriticalSection.Lock();
            Sample = KsOutputPin->m_IoThreadQueue.RemoveHead();
            //
            // If this is a NULL sample, it means that the next sample is
            // supposed to be an EOS. Set the EOS flag here, and acquire
            // the next sample in the list, which is guaranteed to exist.
            //
            if (!Sample) {
                EOSFlag = TRUE;
                Sample = KsOutputPin->m_IoThreadQueue.RemoveHead();
            } else {
                EOSFlag = FALSE;
            }
            KsOutputPin->m_IoCriticalSection.Unlock();
            
            ASSERT( Sample );
    
            KsProxy = static_cast<CKsProxy*>(KsOutputPin->m_pFilter);
            
            hr = KsOutputPin->Deliver( Sample );
            
            if (FAILED( hr )) {
                DbgLog((
                    LOG_TRACE,
                    0,
                    TEXT("%s(%s)::delivery failed in IoThread(), hr = %08x."),
                    static_cast<CKsProxy*>(KsOutputPin->m_pFilter)->GetFilterName(),
                    KsOutputPin->m_pName,
                    hr ));
            } else {
                if (EOSFlag) {
                    KsOutputPin->m_EndOfStream = TRUE;
                    //
                    // Call the base class to do the default operation, which is to
                    // forward to the End-Of-Stream to any connected pin.
                    //
                    KsOutputPin->CBaseOutputPin::DeliverEndOfStream();
                }
            }
            break;
        }
        
        }
    }
}


STDMETHODIMP_(HANDLE)
CKsOutputPin::KsGetObjectHandle(
    )
/*++

Routine Description:

    Implements the IKsObject::KsGetObjectHandle method. Returns the current device
    handle to the actual kernel pin this instance represents, if any such handle
    is open.

Arguments:

    None.

Return Value:

    Returns a handle, or NULL if no device handle has been opened, meaning this
    is an unconnected pin.

--*/
{
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    return m_PinHandle;
}


STDMETHODIMP
CKsOutputPin::KsQueryMediums(
    PKSMULTIPLE_ITEM* MediumList
    )
/*++

Routine Description:

    Implements the IKsPin::KsQueryMediums method. Returns a list of Mediums
    which must be freed with CoTaskMemFree.

Arguments:

    MediumList -
        Points to the place in which to put the pointer to the list of
        Mediums. This must be freed with CoTaskMemFree if the function
        succeeds.

Return Value:

    Returns NOERROR if the list was retrieved, else an error.

--*/
{
    return ::KsGetMultiplePinFactoryItems(
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        KSPROPERTY_PIN_MEDIUMS,
        reinterpret_cast<PVOID*>(MediumList));
}


STDMETHODIMP
CKsOutputPin::KsQueryInterfaces(
    PKSMULTIPLE_ITEM* InterfaceList
    )
/*++

Routine Description:

    Implements the IKsPin::KsQueryInterfaces method. Returns a list of
    Interfaces which must be freed with CoTaskMemFree.

Arguments:

    InterfaceList -
        Points to the place in which to put the pointer to the list of
        Interfaces. This must be freed with CoTaskMemFree if the function
        succeeds.

Return Value:

    Returns NOERROR if the list was retrieved, else an error.

--*/
{
    return ::KsGetMultiplePinFactoryItems(
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        KSPROPERTY_PIN_INTERFACES,
        reinterpret_cast<PVOID*>(InterfaceList));
}


STDMETHODIMP
CKsOutputPin::KsCreateSinkPinHandle(
    KSPIN_INTERFACE& Interface,
    KSPIN_MEDIUM& Medium
    )
/*++

Routine Description:

    Implements the IKsPin::KsCreateSinkPinHandle method. This may be called from
    another pin in ProcessCompleteConnect, which is called from CompleteConnect.
    This allows a handle for a communications sink to always be created before a
    handle for a communications source, no matter which direction the data flow
    is going.

Arguments:

    Interface -
        Specifies the interface which has been negotiated.

    Medium -
        Specifies the medium which has been negotiated.

Return Value:

    Returns NOERROR if the handle was created, else some error.

--*/
{
    HRESULT     hr;

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // This may have already been created if this end of the connection was
    // completed first because of data flow direction. This is not an error.
    //
    
    //
    // This connection uses a kernel mode data transfer, by definition.
    //
    m_MarshalData = FALSE;
    
    if (m_PinHandle) {
        return NOERROR;
    }

    hr = ::CreatePinHandle(
        Interface,
        Medium,
        NULL,
        &m_mt,
        static_cast<CKsProxy*>(m_pFilter),
        m_PinFactoryId,
        GENERIC_READ,
        &m_PinHandle);

    if (SUCCEEDED(hr)) {
        //
        // Assumes the caller knows what they are doing, and assigns
        // the communications type to this pin.
        //
        m_CurrentCommunication = KSPIN_COMMUNICATION_SINK;
        //
        // Save the current interface/medium
        // 
        m_CurrentInterface = Interface;
        m_CurrentMedium = Medium;
        //
        // Load any extra interfaces based on the Property/Method/Event sets
        // supported by this object.
        //
        ::AggregateSets(
            m_PinHandle,
            static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
            &m_MarshalerList,
            static_cast<IKsPin*>(this));
        //
        // Determine if this pin supports any standard message complaints.
        //
        m_QualitySupport = ::VerifyQualitySupport(m_PinHandle);
    }
    return hr;
}


STDMETHODIMP
CKsOutputPin::KsGetCurrentCommunication(
    KSPIN_COMMUNICATION *Communication,
    KSPIN_INTERFACE *Interface,
    KSPIN_MEDIUM *Medium
    )
/*++

Routine Description:

    Implements the IKsPin::KsGetCurrentCommunication method. Returns the
    currently selected communications method, Interface, and Medium for this
    pin. These are a subset of the possible methods available to this pin,
    and is selected when the pin handle is being created.

Arguments:

    Communication -
        Optionally points to the place in which to put the current communications.

    Interface -
        Optionally points to the place in which to put the current Interface.

    Medium -
        Optionally points to the place in which to put the current Medium.

Return Value:

    Returns NOERROR if the pin handle has been created, else VFW_E_NOT_CONNECTED.
    Always returns current communication.

--*/
{
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    if (Communication) {
        *Communication = m_CurrentCommunication;
    }
    if (Interface) {
        if (!m_PinHandle) {
            return VFW_E_NOT_CONNECTED;
        }
        *Interface = m_CurrentInterface;
    }
    if (Medium) {
        if (!m_PinHandle) {
            return VFW_E_NOT_CONNECTED;
        }
        *Medium = m_CurrentMedium;
    }
    return NOERROR;
}


STDMETHODIMP
CKsOutputPin::KsPropagateAcquire(
    )
/*++

Routine Description:

    Implements the IKsPin::KsPropagateAcquire method. Directs all the pins on
    the filter to attain the Acquire state, not just this pin. This is provided
    so that a Communication Source pin can direct the sink it is connected to to
    change state before the Source does. This forces the entire filter to which
    the sink belongs to change state so that any Acquire can be further
    propagated along if needed.

Arguments:

    None.

Return Value:

    Returns NOERROR if all pins could attain the Acquire state, else
    an error.

--*/
{
    HRESULT hr;
    //
    // Access is serialized within this call.
    //
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE CKsOutputPin::KsPropagateAcquire entry KsPin=%x"), static_cast<IKsPin*>(this) ));

    ::FixupPipe(static_cast<IKsPin*>(this), Pin_Output);

    hr = static_cast<CKsProxy*>(m_pFilter)->PropagateAcquire(static_cast<IKsPin*>(this), FALSE);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE CKsOutputPin::KsPropagateAcquire exit KsPin=%x hr=%x"), 
            static_cast<IKsPin*>(this), hr ));

    return hr;
}


STDMETHODIMP
CKsOutputPin::ProcessCompleteConnect(
    IPin* ReceivePin
    )
/*++

Routine Description:

    Completes the processing necessary to create a device handle on the
    underlying pin factory. This is called from CompleteConnect in order
    to negotiate a compatible Communication, Interface, and Medium, then
    create the device handle. The handle may have already been created if
    this was a Communication Sink.

    This can also be called from the NonDelegatingQueryInteface method in
    order to ensure that a partially complete connection has a device
    handle before returning an interface which has been aggregated.

Arguments:

    ReceivePin -
        The pin which is to receive the other end of this connection.

Return Value:

    Returns NOERROR if the pin could complete the connection request, else
    an error.

--*/
{
    HRESULT hr;
    
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // The pin handle may have been created if this is a Communication Sink.
    // This is not an error.
    //
    
    if (!m_PinHandle) {
        IKsPin*         KsPin;
        KSPIN_INTERFACE Interface;
        KSPIN_MEDIUM    Medium;
        HANDLE          PeerPinHandle;

        //
        // Determine if the other end of the connection is also a proxy. If so,
        // then a compatible Communication, Interface, and Medium must be
        // determined, plus the other pin handle needs to be created first if
        // this side will be a Communication Source.
        //
        if (SUCCEEDED(ReceivePin->QueryInterface(__uuidof(IKsPin), reinterpret_cast<PVOID*>(&KsPin)))) {
            //
            // The only confusion is when this end can be both a Source and a
            // Sink. Note that this does not handle the case wherein a pin can
            // also be a Bridge at the same time. That is probably an invalid
            // and confusing possibility. It is also mostly the same as a Sink.
            //
            if (m_OriginalCommunication == KSPIN_COMMUNICATION_BOTH) {
                m_CurrentCommunication = ::ChooseCommunicationMethod(static_cast<CBasePin*>(this), KsPin);
            }
            //
            // Run through the list of Interfaces and Mediums each pin supports,
            // choosing the first one that is found compatible. This in no way
            // attempts to preserve the use of Interfaces and Mediums, and
            // relies on kernel filters to present them in best order first.
            //
            if (SUCCEEDED(hr = ::FindCompatibleInterface(static_cast<IKsPin*>(this), KsPin, &Interface))) {
                hr = ::FindCompatibleMedium(static_cast<IKsPin*>(this), KsPin, &Medium);
            }
            if (SUCCEEDED(hr)) {
                if (hr == S_FALSE) {
                    //
                    // This is a usermode filter, but needs to support mediums
                    // because it wants to connect with a non-ActiveMovie
                    // medium. This should really be a kernelmode filter.
                    //
                    PeerPinHandle = NULL;
                    m_MarshalData = TRUE;
                } else {
                    //
                    // If this is a Communication Source, the Sink pin handle must
                    // be created first. Else the Sink handle is NULL (meaning that
                    // this is the Sink pin).
                    //
                    if (m_CurrentCommunication == KSPIN_COMMUNICATION_SOURCE) {
                        IKsObject*      KsObject;

                        hr = KsPin->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&KsObject));
                        if (SUCCEEDED(hr)) {
                            hr = KsPin->KsCreateSinkPinHandle(Interface, Medium);
                            PeerPinHandle = KsObject->KsGetObjectHandle();
                            KsObject->Release();
                        }
                    } else {
                        PeerPinHandle = NULL;
                    }
                    m_MarshalData = FALSE;
                }
            }
            KsPin->Release();
            if (FAILED(hr)) {
                return hr;
            }
        } else {
            //
            // If the other end of the connection is not a proxy, then this pin
            // must be a Communication Sink. It must also use the default
            // Interface and Dev I/O Medium.
            //
            m_CurrentCommunication = KSPIN_COMMUNICATION_SINK;
            if (FAILED(hr = FindCompatibleInterface(static_cast<IKsPin*>(this), NULL, &Interface))) {
                return hr;
            }
            SetDevIoMedium(static_cast<IKsPin*>(this), &Medium);
            PeerPinHandle = NULL;
        }
        hr = ::CreatePinHandle(
            Interface,
            Medium,
            PeerPinHandle,
            &m_mt,
            static_cast<CKsProxy*>(m_pFilter),
            m_PinFactoryId,
            GENERIC_READ,
            &m_PinHandle);

        if (SUCCEEDED( hr )) {
            //
            // Save the current interface/medium
            // 
            m_CurrentInterface = Interface;
            m_CurrentMedium = Medium;
            //
            // Load any extra interfaces based on the Property/Method/Event sets
            // supported by this object.
            //
            ::AggregateSets(
                m_PinHandle,
                static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
                &m_MarshalerList,
                static_cast<IKsPin*>(this));
            //
            // Determine if this pin supports any standard message complaints.
            //
            m_QualitySupport = ::VerifyQualitySupport(m_PinHandle);
        }
    } else {
        hr = NOERROR;
    }
    
    //
    // Create an instance of the interface handler, if specified.
    //        

    if (SUCCEEDED( hr ) && 
        (NULL == m_InterfaceHandler) &&
        (m_CurrentCommunication != KSPIN_COMMUNICATION_BRIDGE)) {
        
        //
        // We must create an interface handler, if not, then
        // return the error.
        //
        
        hr =
            CoCreateInstance(
                m_CurrentInterface.Set,
                NULL,
#ifdef WIN9X_KS
                CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
                __uuidof(IKsInterfaceHandler),
                reinterpret_cast<PVOID*>(&m_InterfaceHandler));
    
        if (m_InterfaceHandler) {
            m_InterfaceHandler->KsSetPin( static_cast<IKsPin*>(this) );
        } else {
            DbgLog((
                LOG_TRACE, 
                0, 
                TEXT("%s(%s)::ProcessCompleteConnect failed to create interface handler"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName ));
        }
    }        
    
    //
    // If we're marshalling data and if everything has succeeded
    // up to this point, then create the filter's I/O thread if 
    // necessary.
    //
    
    if (SUCCEEDED(hr)) {
        //
        // This pin may generate EOS notifications, which must be
        // monitored so that they can be collected and used to
        // generate an EC_COMPLETE graph notification.
        //
        
        if (NULL == m_hEOSevent) { // begin EOS notification
            KSEVENT     event;
            KSEVENTDATA eventData;
            ULONG       bytesReturned;

            //
            // Only if the EOS event is supported should notification be set up.
            //
            event.Set   = KSEVENTSETID_Connection;
            event.Id    = KSEVENT_CONNECTION_ENDOFSTREAM;
            event.Flags = KSEVENT_TYPE_BASICSUPPORT;
            if (SUCCEEDED(KsEvent( 
                &event, sizeof(event), NULL, 0, &bytesReturned))) {

                PASYNC_ITEM pItem = new ASYNC_ITEM;
                if (NULL == pItem) {
                    hr = E_OUTOFMEMORY;
                }

                if (SUCCEEDED(hr)) {
                    //
                    // Enable an event for this pin. Just use the local
                    // stack for the data, since it won't be referenced
                    // again in disable. Status is returned through the
                    // Param of the message.
                    //
                    // Event.Set = KSEVENTSETID_Connection;
                    // Event.Id = KSEVENT_CONNECTION_ENDOFSTREAM;
                    event.Flags = KSEVENT_TYPE_ENABLE;
                    eventData.NotificationType = KSEVENTF_EVENT_HANDLE;
                    m_hEOSevent = CreateEvent( 
                        NULL,
                        FALSE,
                        FALSE,
                        NULL );
    
                    if (m_hEOSevent) {
                        InitializeAsyncItem( pItem, TRUE, m_hEOSevent, (PASYNC_ITEM_ROUTINE) EOSEventHandler, (PVOID) this );
                        
                        eventData.EventHandle.Event = m_hEOSevent;
                        eventData.EventHandle.Reserved[0] = 0;
                        eventData.EventHandle.Reserved[1] = 0;
                        hr = KsEvent( &event, sizeof(event), &eventData, sizeof(eventData), &bytesReturned );
                        
                        if (SUCCEEDED(hr)) {
                            if (NULL == m_pAsyncItemHandler) {
                                hr = InitializeAsyncThread ();
                            }
                            if (SUCCEEDED(hr)) { // Can only be fail if no async item handler is available.
                                m_pAsyncItemHandler->QueueAsyncItem( pItem );
                            } else {
                                // No async item handler was available.
                                // Disable the event
                                KsEvent( NULL, 0, &eventData, sizeof(eventData), &bytesReturned );
                                // Close the event handle
                                CloseHandle( m_hEOSevent );
                                m_hEOSevent = NULL;
                                // Delete the ASYNC_ITEM
                                delete pItem;
                                DbgLog(( LOG_TRACE, 0, TEXT("ProcessCompleteConnect(), couldn't create new AsyncItemHandler.") ));
                            }
                        } else {
                            //
                            // Enable failed, so delete the event created above,
                            // since no disable will happen to delete it.
                            //
                            DbgLog(( LOG_TRACE, 0, TEXT("ProcessCompleteConnect(), couldn't enable EOS event (0x%08X)."), GetLastError() ));
                            CloseHandle(m_hEOSevent);
                            m_hEOSevent = NULL;
                            delete pItem;
                        } // KsEvent was enabled
                    }
                    else {
                        DbgLog(( LOG_TRACE, 0, TEXT("ProcessCompleteConnect(), couldn't create EOS event (0x%08X)."), GetLastError() ));
                        hr = HRESULT_FROM_WIN32 (GetLastError ());
                    } // if (m_hEOSevent), i.e. EOS event handle was created
                } // if (SUCCEEDED(hr)), i.e. ASYNC_ITEM was allocated
            } // if (SUCCEEDED(hr)), i.e. EOS event IS supported
        } // if (NULL == m_hEOSevent)
        // end EOS notification
    } // if (SUCCEEDED(hr)), everything has succeeded so far
    
    //
    // Perform failure clean up
    // 
        
    if (FAILED( hr )) {
    
        //
        // Assume that the thread did not get created (it is the last 
        // operation in ProcessCompleteConnect).
        //
        
        DbgLog((
            LOG_TRACE, 
            0, 
            TEXT("%s(%s)::ProcessCompleteConnect failed, hr = %08x"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName,
            hr ));
    
        ASSERT( m_IoThreadHandle == NULL );
    
        if (m_PinHandle) {
            // Don't need to ::SetSyncSource( m_PinHandle, NULL ) because we could only
            // have a kernel clock if we've gone into pause/run and we can't have done
            // that because we're failing the connect.
            CloseHandle(m_PinHandle);
            m_PinHandle = NULL;
            //
            // If this was set, then unset it.
            //
            m_QualitySupport = FALSE;
        }
        SAFERELEASE( m_InterfaceHandler );
        //
        // If an data handler was instantiated, release it.
        //
        if (NULL != m_DataTypeHandler) {
            m_DataTypeHandler = NULL;
            SAFERELEASE( m_UnkInner );
        }
            
        //
        // Reset the marshal data flag.
        //
        m_MarshalData = TRUE;
        
        //
        // Reset the current Communication for the case of a Both.
        //
        m_CurrentCommunication = m_OriginalCommunication;
    }
    
    
    return hr;
}


STDMETHODIMP
CKsOutputPin::QueryInterface(
    REFIID riid,
    PVOID* ppv
    )
/*++

Routine Description:

    Implement the IUnknown::QueryInterface method. This just passes the query
    to the owner IUnknown object, which may pass it to the nondelegating
    method implemented on this object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE.

--*/
{
    HRESULT hr;

    hr = GetOwner()->QueryInterface(riid, ppv);
    return hr;
}


STDMETHODIMP_(ULONG)
CKsOutputPin::AddRef(
    )
/*++

Routine Description:

    Implement the IUnknown::AddRef method. This just passes the AddRef
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    InterlockedIncrement((PLONG)&m_RelativeRefCount);
    return GetOwner()->AddRef();
}


STDMETHODIMP_(ULONG)
CKsOutputPin::Release(
    )
/*++

Routine Description:

    Implement the IUnknown::Release method. This just passes the Release
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    ULONG   RefCount;

    RefCount = GetOwner()->Release();
    //
    // Ensure that the proxy was not just deleted before trying to
    // delete this pin.
    //
    if (RefCount && !InterlockedDecrement((PLONG)&m_RelativeRefCount)) {
        //
        // This was a connection release from a pin already destined
        // for destruction. The filter had decremented the relative
        // refcount in order to delete it, and found that there was
        // still an outstanding interface being used. So this delayed
        // deletion occurs.
        //
        delete this;
    }
    return RefCount;
}


STDMETHODIMP 
CKsOutputPin::NonDelegatingQueryInterface(
    REFIID riid,
    PVOID* ppv
    )
/*++

Routine Description:

    Implement the CUnknown::NonDelegatingQueryInterface method. This
    returns interfaces supported by this object, or by the underlying
    pin class object. This includes any interface aggregated by the
    pin.

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE, or possibly some memory error.

--*/
{
    if (riid == __uuidof(ISpecifyPropertyPages)) {
        return GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv);
    } else if (riid == __uuidof(IMediaSeeking)) {
        return GetInterface(static_cast<IMediaSeeking*>(this), ppv);
    } else if (riid == __uuidof(IKsObject)) {
        return GetInterface(static_cast<IKsObject*>(this), ppv);
    } else if (riid == __uuidof(IKsPin) || riid == __uuidof(IKsPinEx)) {
        return GetInterface(static_cast<IKsPinEx*>(this), ppv);
    } else if (riid == __uuidof(IKsPinPipe)) {
        return GetInterface(static_cast<IKsPinPipe*>(this), ppv);
    } else if (riid == __uuidof(IKsAggregateControl)) {
        return GetInterface(static_cast<IKsAggregateControl*>(this), ppv);
    } else if (riid == __uuidof(IKsPropertySet)) {
        //
        // In order to allow another filter to access information on the
        // underlying device handle during its CompleteConnect processing,
        // force the connection to be completed now if possible.
        //
        if (m_Connected && !m_PinHandle) {
            ProcessCompleteConnect(m_Connected);
        }
        return GetInterface(static_cast<IKsPropertySet*>(this), ppv);
    } else if (riid == __uuidof(IKsControl)) {
        if (m_Connected && !m_PinHandle) {
            ProcessCompleteConnect(m_Connected);
        }
        return GetInterface(static_cast<IKsControl*>(this), ppv);
    } else if (riid == __uuidof(IKsPinFactory)) {
        return GetInterface(static_cast<IKsPinFactory*>(this), ppv);
    } else if (riid == __uuidof(IStreamBuilder)) {
        //
        // Sink & Source pins are normally forced to be rendered, unless
        // there are already enough instances.
        //
        if ((m_CurrentCommunication & KSPIN_COMMUNICATION_BOTH) &&
            static_cast<CKsProxy*>(m_pFilter)->DetermineNecessaryInstances(m_PinFactoryId)) {
            return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
        }
        //
        // Returning this interface allows a Bridge and None pin to be
        // left alone by the graph builder.
        //
        return GetInterface(static_cast<IStreamBuilder*>(this), ppv);
    } else if (riid == __uuidof(IAMBufferNegotiation)) {
        return GetInterface(static_cast<IAMBufferNegotiation*>(this), ppv);
    } else if (riid == __uuidof(IAMStreamConfig)) {
        return GetInterface(static_cast<IAMStreamConfig*>(this), ppv);
    } else if (riid == __uuidof(IAMStreamControl)) {
        return GetInterface(static_cast<IAMStreamControl*>(this), ppv);
    } else {
        HRESULT hr;
        
        hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
        if (SUCCEEDED(hr)) {
            return hr;
        }
    }
    //
    // In order to allow another filter to access information on the
    // underlying device handle during its CompleteConnect processing,
    // force the connection to be completed now if possible. The
    // assumption is that if there is a Connected pin, but no device
    // handle yet, then this pin is part way through the connection
    // process, and should force completion in case the aggregated
    // interface wants to interact with the device. This must be done
    // before searching the list, since a volatile interface is only
    // added to the list when the the connection is completed.
    //
    if (m_Connected && !m_PinHandle) {
        ProcessCompleteConnect(m_Connected);
    }
    for (POSITION Position = m_MarshalerList.GetHeadPosition(); Position;) {
        CAggregateMarshaler*    Aggregate;

        Aggregate = m_MarshalerList.GetNext(Position);
        if ((Aggregate->m_iid == riid) || (Aggregate->m_iid == GUID_NULL)) {
            HRESULT hr;

            hr = Aggregate->m_Unknown->QueryInterface(riid, ppv);
            if (SUCCEEDED(hr)) {
                return hr;
            }
        }
    }
    return E_NOINTERFACE;
}


STDMETHODIMP
CKsOutputPin::Disconnect(
    )
/*++

Routine Description:

    Override the CBaseInput::Disconnect method. This does not call the base
    class implementation. It disconnects both Source and Sink pins, in
    addition to Bridge pins, which only have handles, and not connected pin
    interfaces, which traditionally is how connection is indicated. It
    specifically does not release the connected pin, since a Bridge may not
    have a connected pin. This is always done in BreakConnect.

Arguments:

    None.

Return Value:

    Returns S_OK, or S_FALSE if the pin was not connected or VFW_E_NOT_STOPPED
    if the filter is not in a Stop state.

--*/
{
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsOutputPin(%s)::Disconnect"), m_pName ));
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // A disconnection can only occur if the filter is in a Stop state.
    //
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }       
    //
    // A Bridge pin can be connected if it just has a device handle. It can't
    // actually report to ActiveMovie this connection, but it can still be
    // connected (with a NULL ReceivePin) and disconnected.
    //
    if (m_Connected || m_PinHandle) {
        //
        // Note that this does not release the connected pin, as that is done
        // in BreakConnect. This is because there may not be a pin in the case
        // of a Bridge.
        //
        BreakConnect();
        return S_OK;
    }
    return S_FALSE;
}


STDMETHODIMP
CKsOutputPin::ConnectionMediaType(
    AM_MEDIA_TYPE* AmMediaType
    )
/*++

Routine Description:

    Override the CBasePin::ConnectionMediaType method. Returns the
    current media type, if connected. The reason for overriding this
    is because IsConnected() is not a virtual function, and is used
    in the base classes to determine if a media type should be returned.

Arguments:

    AmMediaType -
        The place in which to return the media type.

Return Value:

    Returns NOERROR if the type was returned, else a memory or connection
    error.

--*/
{
    CAutoLock AutoLock(m_pLock);

    if (IsConnected()) {
        CopyMediaType(AmMediaType, &m_mt);
        return S_OK;
    }
    static_cast<CMediaType*>(AmMediaType)->InitMediaType();
    return VFW_E_NOT_CONNECTED;
}


STDMETHODIMP
CKsOutputPin::Connect(
    IPin* ReceivePin,
    const AM_MEDIA_TYPE* AmMediaType
    )
/*++

Routine Description:

    Override the CBaseInput::Connect method. Intercepts a connection
    request in order to perform special processing for a Bridge pin. A
    Bridge has no ReceivePin, and uses the first available Interface
    and a Dev I/O Medium. A normal connection request is just passed
    through to the base class.

Arguments:

    ReceivePin -
        Contains the pin on the other end of the proposed connection.
        This is NULL for a Bridge pin.

    AmMediaType -
        Contains the media type for the connection, else NULL if the
        media type is to be negotiated.

Return Value:

    Returns NOERROR if the connection was made, else some error.

--*/
{
#ifdef DEBUG
    PIN_INFO    pinInfo;
    ReceivePin->QueryPinInfo( &pinInfo );
    FILTER_INFO filterInfo;
    filterInfo.achName[0] = 0;
    if (pinInfo.pFilter) {
        pinInfo.pFilter->QueryFilterInfo( &filterInfo );
        if (filterInfo.pGraph) {
            filterInfo.pGraph->Release();
        }
        pinInfo.pFilter->Release();
    }
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsOutputPin(%s)::Connect( %s(%s) )"), m_pName, filterInfo.achName, pinInfo.achName ));
#endif // DEBUG

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // The only reason to intercept the base class implementation is to
    // deal with a Bridge pin.
    //
    if (m_CurrentCommunication == KSPIN_COMMUNICATION_BRIDGE) {
        KSPIN_INTERFACE Interface;
        KSPIN_MEDIUM    Medium;
        CMediaType      MediaType;
        HRESULT         hr;

        //
        // A Bridge pin does not have any other end to the connection.
        //
        if (ReceivePin) {
            E_FAIL;
        }
        //
        // Normally this would check m_Connected, but since there is no
        // connection pin, it must check for a device handle.
        //
        if (m_PinHandle) {
            return VFW_E_ALREADY_CONNECTED;
        }
        if (!IsStopped()) {
            return VFW_E_NOT_STOPPED;
        }
        //
        // Find the first Interface and Medium.
        //
        if (SUCCEEDED(hr = ::FindCompatibleInterface(static_cast<IKsPin*>(this), NULL, &Interface))) {
            hr = ::FindCompatibleMedium(static_cast<IKsPin*>(this), NULL, &Medium);
        }
        if (FAILED(hr)) {
            return hr;
        }
        //
        // If there is no media type, just acquire the first one.
        //
        if (!AmMediaType) {
            CMediaType      MediaType;

            if (SUCCEEDED(hr = GetMediaType(0, &MediaType))) {
                hr = SetMediaType(&MediaType);
            }
        } else {
            hr = SetMediaType(static_cast<const CMediaType*>(AmMediaType));
        }
        if (SUCCEEDED(hr)) {
            hr = ::CreatePinHandle(
                Interface,
                Medium,
                NULL,
                &m_mt,
                static_cast<CKsProxy*>(m_pFilter),
                m_PinFactoryId,
                GENERIC_READ,
                &m_PinHandle);

            if (SUCCEEDED(hr)) {
                //
                // Load any extra interfaces based on the Property/Method/Event sets
                // supported by this object.
                //
                ::AggregateSets(
                    m_PinHandle,
                    static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
                    &m_MarshalerList,
                    static_cast<IKsPin*>(this));
                //
                // Determine if this pin supports any standard message complaints.
                //
                m_QualitySupport = ::VerifyQualitySupport(m_PinHandle);
                //
                // Create a new instance of this pin if necessary.
                //
                static_cast<CKsProxy*>(m_pFilter)->GeneratePinInstances();
            }
        }
        return hr;
    }
    HRESULT hr = CBasePin::Connect(ReceivePin, AmMediaType);
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsOutputPin(%s)::Connect() returns 0x%p"), m_pName, hr ));
    return hr;
}


STDMETHODIMP
CKsOutputPin::QueryInternalConnections(
    IPin** PinList,
    ULONG* PinCount
    )
/*++

Routine Description:

    Override the CBasePin::QueryInternalConnections method. Returns a list of
    pins which are related to this pin through topology.

Arguments:

    PinList -
        Contains a list of slots in which to place all pins related to this
        pin through topology. Each pin returned must be reference counted. This
        may be NULL if PinCount is zero.

    PinCount -
        Contains the number of slots available in PinList, and should be set to
        the number of slots filled or neccessary.

Return Value:

    Returns E_NOTIMPL to specify that all inputs go to all outputs and vice versa,
    S_FALSE if there is not enough slots in PinList, or NOERROR if the mapping was
    placed into PinList and PinCount adjusted.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->QueryInternalConnections(m_PinFactoryId, m_dir, PinList, PinCount);
}


HRESULT
CKsOutputPin::Active(
    )
/*++

Routine Description:

    Override the CBaseOutputPin::Active method. Propagate activation to 
    Communication Sinks before applying it to this pin. Also guard against 
    re-entrancy caused by a cycle in a graph.

Arguments:

    None.

Return Value:

    Returns NOERROR if the transition was made, else some error.

--*/
{
    HRESULT hr;

    {
        //
        // Do not acquire lock while delivering I/O.
        //
        CAutoLock           AutoLock(m_pLock);
#ifdef DEBUG
        if (m_PinHandle) {
            KSPROPERTY  Property;
            ULONG       BasicSupport;
            ULONG       BytesReturned;

            //
            // Ensure that if a pin supports a clock, that it also supports State
            // changes. This appears to currently be a common broken item.
            //
            Property.Set = KSPROPSETID_Stream;
            Property.Id = KSPROPERTY_STREAM_MASTERCLOCK;
            Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
            hr = ::KsSynchronousDeviceControl(
                m_PinHandle,
                IOCTL_KS_PROPERTY,
                &Property,
                sizeof(Property),
                &BasicSupport,
                sizeof(BasicSupport),
                &BytesReturned);
            if (SUCCEEDED(hr) && (BasicSupport & KSPROPERTY_TYPE_GET)) {
                Property.Set = KSPROPSETID_Connection;
                Property.Id = KSPROPERTY_CONNECTION_STATE;
                hr = ::KsSynchronousDeviceControl(
                    m_PinHandle,
                    IOCTL_KS_PROPERTY,
                    &Property,
                    sizeof(Property),
                    &BasicSupport,
                    sizeof(BasicSupport),
                    &BytesReturned);
                if (FAILED(hr) || !(BasicSupport & KSPROPERTY_TYPE_SET)) {
                    DbgLog((
                        LOG_ERROR, 
                        0, 
                        TEXT("%s(%s)::Active - Pin supports a clock but not State"),
                        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                        m_pName ));
                }
            }
        }
#endif // DEBUG

        //
        // If this is re-entered while it is propagating the state change, then
        // it implies a cycle in the graph, and therefore is complete. This is
        // translated as either a transition from Stop through Acquire to Pause
        // (where the filter pins may already be in an Acquire state), or Run to
        // Pause.
        //
        if (m_PropagatingAcquire) {
            return NOERROR;
        }
        m_PropagatingAcquire = TRUE;
        m_LastSampleDiscarded = TRUE;
        //
        // This event is used when inactivating the pin, and may be needed to
        // wait for outstanding I/O to be completed. It must be reset, because
        // a previous transition may not have waited on it, and it will always
        // be set when the state is Stop, and the last I/O has been completed.
        //
        // Note that the filter state has been set to Pause before the Active
        // method is called, so I/O which is started and completes will not
        // accidentally set the event again.
        //
        ResetEvent(m_PendingIoCompletedEvent);
        //
        // Change any Sink first, then pass the state change to the device handle.
        //
        if (SUCCEEDED(hr = ::Active(static_cast<IKsPin*>(this), Pin_Output, m_PinHandle, m_CurrentCommunication, 
                                    m_Connected, &m_MarshalerList,  static_cast<CKsProxy*>(m_pFilter) ))) {
        
            //
            // The base class validates that an allocator is specified and commits
            // the allocator memory.
            //
#if DBG || defined(DEBUG)
            if (! m_pAllocator) {
                DbgLog(( 
                    LOG_MEMORY, 
                    2, 
                    TEXT("PIPES ERROR %s(%s)::Active OutKsPin=%x, BaseAlloc=%x, Pipe=%x"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName,
                    static_cast<IKsPin*>(this),
                    m_pAllocator,
                    m_pKsAllocator ));
                ASSERT(m_pAllocator);
            }
#endif
            
            hr = CBaseOutputPin::Active();
            NotifyFilterState(State_Paused);
        }
    
        DbgLog((
            LOG_TRACE, 
            2, 
            TEXT("%s(%s)::Active returning %08x"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName,
            hr ));
    
        m_PropagatingAcquire = FALSE;
    }
    
    if (!SUCCEEDED( hr )) {
        return hr;
    }
    
    //
    // If this connection is not to a kernel-mode peer, then there is
    // work to do.
    //

    if (m_PinHandle && m_MarshalData) {
        
        //
        // Preroll data to the device
        //
        
        m_pAllocator->GetProperties( &m_AllocatorProperties );

        //
        // Set up the buffer notification callback. This allocator
        // must support the callback. If the downstream proposed
        // allocator did not, then this filter's allocator is used.
        //
        IMemAllocatorCallbackTemp* AllocatorNotify;

        hr = m_pAllocator->QueryInterface(__uuidof(IMemAllocatorCallbackTemp), reinterpret_cast<PVOID*>(&AllocatorNotify));
        ASSERT(SUCCEEDED(hr));
        AllocatorNotify->SetNotify(this);
        AllocatorNotify->Release();

/* BUGBUG: Should use this code to check for IMemAllocator2 when it is implemented in the DirectShow base clases.

        //
        // QueryInterface for IMemAllocator2 so we know that NonBlockingGetBuffer() or GetFreeBufferCount()
        // is supported.
        //
        IMemAllocator2  *pAllocator2;
        
        hr = m_pAllocator->QueryInterface( __uuidof(IMemAllocator2), reinterpret_cast<PVOID *>(&pAllocator2) );
        ASSERT(SUCCEEDED(hr));
        // hmm, we'll need this later... pAllocator2->Release();

*/
        if (NULL == m_pAsyncItemHandler) {
            hr = InitializeAsyncThread ();
        }	

        if (SUCCEEDED (hr)) {
            SetEvent (m_hMarshalEvent);
        }

    } else {
        DbgLog((
            LOG_TRACE, 
            2, 
            TEXT("%s(%s)::Active(), m_MarshalData == FALSE"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName ));
    }
    
    return hr;
}


HRESULT
CKsOutputPin::Run(
    REFERENCE_TIME tStart
    )
/*++

Routine Description:

    Override the CBasePin::Run method. This is translated as a transition
    from Pause to Run. The base classes already ensure that an Active is sent
    before a Run.

Arguments:

    None.

Return Value:

    Returns NOERROR if the transition was made, else some error.

--*/
{
    HRESULT hr;

    //
    // Pass the state change to the device handle.
    //
    if (SUCCEEDED(hr = ::Run(m_PinHandle, tStart, &m_MarshalerList))) {
        NotifyFilterState(State_Running, tStart);
        hr = CBasePin::Run(tStart);
    }
    return hr;
}


HRESULT
CKsOutputPin::Inactive(
    )
/*++

Routine Description:

    Override the CBasePin::Inactive method. This is translated as a transition
    from Run to Stop or Pause to Stop. There does not appear to be a method of
    directly setting the state from Run to Pause though.

Arguments:

    None.

Return Value:

    Returns NOERROR if the transition was made, else some error.

--*/
{
    HRESULT hr;

    //
    // Pass the state change to the device handle.
    //
    hr = ::Inactive(m_PinHandle, &m_MarshalerList);
    {
        NotifyFilterState(State_Stopped);
        //
        // If there is pending I/O, then the state transition must wait
        // for it to complete. The event is signalled when m_PendingIoCount
        // transitions to zero, and when IsStopped() is TRUE.
        //
        // Note that the filter state has been set to Stopped before the
        // Inactive method is called.
        //
        // This critical section will force synchronization with any
        // outstanding QueueBuffersToDevice call, such that it will have
        // looked at the filter state and exited.
        //
        static_cast<CKsProxy*>(m_pFilter)->EnterIoCriticalSection();
        static_cast<CKsProxy*>(m_pFilter)->LeaveIoCriticalSection();
        if (m_PendingIoCount) {
            WaitForSingleObjectEx(m_PendingIoCompletedEvent, INFINITE, FALSE);
        }
        ::UnfixupPipe(static_cast<IKsPin*>(this), Pin_Output);
        //
        // This decommits the allocator, so buffer flushing should occur
        // first.
        //
        hr = CBaseOutputPin::Inactive();
        if (m_pAllocator) {
            //
            // Remove the buffer notification callback. This allocator
            // must support the callback. If the downstream proposed
            // allocator did not, then this filter's allocators is used.
            //
            IMemAllocatorCallbackTemp* AllocatorNotify;

            hr = m_pAllocator->QueryInterface(__uuidof(IMemAllocatorCallbackTemp), reinterpret_cast<PVOID*>(&AllocatorNotify));
            ASSERT(SUCCEEDED(hr));
            AllocatorNotify->SetNotify(NULL);
            AllocatorNotify->Release();
        }
    }
    //
    // Reset the state of any previous delivery error.
    //
    m_DeliveryError = FALSE;
    m_EndOfStream = FALSE;
    return hr;
}


STDMETHODIMP
CKsOutputPin::QueryAccept(
    const AM_MEDIA_TYPE* AmMediaType
    )
/*++

Routine Description:

    Implement the CBasePin::QueryAccept method. Determines if the proposed
    media type is currently acceptable to the pin. If currently streaming,
    this implies that a change of media types will occur in the stream.
    Note that this function does not lock the object, as it is expected
    to be called asynchronously by a knowledgeable client at a point in
    which the connection will not be broken. If IAMStreamConfig::SetFormat
    has been used to set a specific media type, then QueryAccept will only
    accept the type set.

Arguments:

    AmMediatype -
        The media type to check.

Return Value:

    Returns S_OK if the media type can currently be accepted, else S_FALSE.

--*/
{
    //
    // If this is called before connecting pins, or the pin is stopped,
    // then just check the media type. The function definition does not
    // contain any guidance as to what to do if the pin is not connected.
    //
    if (!m_PinHandle || IsStopped()) {
        return CheckMediaType(static_cast<const CMediaType*>(AmMediaType));
    }
    return ::QueryAccept(m_PinHandle, m_ConfigAmMediaType, AmMediaType);
}


STDMETHODIMP
CKsOutputPin::QueryId(
    LPWSTR* Id
    )
/*++

Routine Description:

    Override the CBasePin::QueryAccept method. This returns a unique identifier
    for a particular pin. This identifier is equivalent to the pin name in the
    base class implementation, but does not work if the kernel filter does not
    explicitly name pins, since multiple pins will have duplicate names, and
    graph save/load will not be able to rebuild a graph. The IBaseFilter::FindPin
    method is also implemented by the proxy to return the proper pin based on
    the same method here. This is based on the factory identifier. If multiple
    instances of a pin exist, then there will be duplicates. But new pins are
    inserted at the front of the pin list, so they will be found first, and
    graph building will still work.

Arguments:

    Id -
        The place in which to return a pointer to an allocated string containing
        the unique pin identifier.

Return Value:

    Returns NOERROR if the string was returned, else an allocation error.

--*/
{
    *Id = reinterpret_cast<WCHAR*>(CoTaskMemAlloc(8*sizeof(**Id)));
    if (*Id) {
        swprintf(*Id, L"%u", m_PinFactoryId);
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}


STDMETHODIMP
CKsOutputPin::Notify(
    IBaseFilter* Sender,
    Quality q
    )
/*++

Routine Description:

    Receives quality management complaints from the connected pin. Attempts
    to adjust quality on the pin, and also forwards the complaint to the
    quality sink, if any.

Arguments:

    Sender -
        The filter from which the report originated.

    q -
        The quality complaint.

Return Value:

    Returns the result of forwarding the quality management report, else E_FAIL
    if there is no sink, and no quality adjustment could be made on the pin.

--*/
{
    BOOL    MadeDegradationAdjustment;
    HRESULT hr;

    //
    // If no adjustment is made, and no sink is found, then the function
    // will return failure.
    //
    MadeDegradationAdjustment = FALSE;
    //
    // At connection time it was determined if this pin supported relevant
    // quality adjustments.
    //
    if (m_QualitySupport) {
        PKSMULTIPLE_ITEM    MultipleItem = NULL;

        //
        // Retrieve the list of degradation strategies.
        //
        hr = ::GetDegradationStrategies(m_PinHandle, reinterpret_cast<PVOID*>(&MultipleItem));
        if (SUCCEEDED(hr)) {

            // MultipleItem could be NULL only in the pathological case where
            // the underlying driver returned a success code to KsSynchronousDeviceControl()
            // (called by GetDegradationStrategies()) when passed a size 0 buffer.
            ASSERT( NULL != MultipleItem );
        
            PKSDEGRADE      DegradeItem;

            //
            // Locate a relevant strategy.
            //
            DegradeItem = ::FindDegradeItem(MultipleItem, KSDEGRADE_STANDARD_COMPUTATION);
            if (DegradeItem) {
                ULONG   Degradation;

                if (q.Proportion <= 1000) {
                    //
                    // There is not enough time to process frames. Turn down
                    // computation.
                    //
                    Degradation = 1000 - q.Proportion;
                } else {
                    //
                    // There are just too many frames. This should not happen
                    // because of allocator flow control. First turn up computation.
                    // If it is all the way up, then turn up sample and quality.
                    //
                    Degradation = DegradeItem->Flags * 1000 / q.Proportion;
                }
                //
                // Only if an actual adjustment will be made is are the
                // strategies written. The whole list is just written back
                // in this case.
                //
                if (Degradation != DegradeItem->Flags) {
                    KSPROPERTY  Property;
                    ULONG       BytesReturned;

                    Property.Set = KSPROPSETID_Stream;
                    Property.Id = KSPROPERTY_STREAM_DEGRADATION;
                    Property.Flags = KSPROPERTY_TYPE_SET;
                    DegradeItem->Flags = Degradation;
                    hr = ::KsSynchronousDeviceControl(
                        m_PinHandle,
                        IOCTL_KS_PROPERTY,
                        &Property,
                        sizeof(Property),
                        MultipleItem,
                        MultipleItem->Size,
                        &BytesReturned);
                    //
                    // If an adjustment was made, then it is OK to
                    // return success.
                    //
                    if (SUCCEEDED(hr)) {
                        MadeDegradationAdjustment = TRUE;
                    }
                }
            }
            delete [] reinterpret_cast<BYTE*>(MultipleItem);
        }
    }        
    //
    // If no adjustment could be made, then attempt to forward to the sink.
    //
    if (!MadeDegradationAdjustment) {
        if (m_pQSink) {
            hr = m_pQSink->Notify(m_pFilter, q);
        } else {
            hr = E_FAIL;
        }
    }
    return hr;
}


HRESULT
CKsOutputPin::CheckMediaType(
    const CMediaType* MediaType
    )
/*++

Routine Description:

    Implement the CBasePin::CheckMediaType method. Just uses the common method
    on the filter with the Pin Factory Identifier.

Arguments:

    Mediatype -
        The media type to check.

Return Value:

    Returns NOERROR if the media type was valid, else some error.

--*/
{
    return ((CKsProxy*)m_pFilter)->CheckMediaType(static_cast<IPin*>(this), m_PinFactoryId, MediaType);
}


HRESULT
CKsOutputPin::SetMediaType(
    const CMediaType* MediaType
    )
/*++

Routine Description:

    Override the CBasePin::SetMediaType method. This may be set either before
    a connection is established, to indicate the media type to use in the
    connection, or after the connection has been established in order to change
    the current media type (which is done after a QueryAccept of the media type).

    If the connection has already been made, then the call is directed at the
    device handle in an attempt to change the current media type. Else so such
    call is made, and the function merely attempts to load a media type handler
    corresponding to the subtype or type of media. It then calls the base class
    to actually modify the media type, which does not actually fail, unless there
    is no memory.

Arguments:

    Mediatype -
        The media type to use on the pin.

Return Value:

    Returns NOERROR if the media type was validly set, else some error. If
    there is no pin handle yet, the function will likely succeed.

--*/
{
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // Only pass this request to the device if there is actually a connection
    // currently.
    //
    if (m_PinHandle) {
        HRESULT hr;

        if (FAILED(hr = ::SetMediaType(m_PinHandle, MediaType))) {
            return hr;
        }
    }
    //
    // Discard any previous data type handler.
    //
    if (m_DataTypeHandler) {
        m_DataTypeHandler = NULL;
        SAFERELEASE( m_UnkInner );
    }
    
    ::OpenDataHandler(MediaType, static_cast<IPin*>(this), &m_DataTypeHandler, &m_UnkInner);

    return CBasePin::SetMediaType(MediaType);
}


HRESULT
CKsOutputPin::CheckConnect(
    IPin* Pin
    )
/*++

Routine Description:

    Override the CBasePin::CheckConnect method. First check data flow with
    the base class, then check compatible Communication types.

Arguments:

    Pin -
        The pin which is being checked for compatibility to connect to this
        pin.

Return Value:

    Returns NOERROR if the pin in compatible, else some error.

--*/
{
    HRESULT hr;

    //
    // Get the input pin interface.
    //
    if (SUCCEEDED(hr = CBaseOutputPin::CheckConnect(Pin))) {
        hr = ::CheckConnect(Pin, m_CurrentCommunication);
    }
    return hr;
}


HRESULT
CKsOutputPin::CompleteConnect(
    IPin* ReceivePin
    )
/*++

Routine Description:

    Override the CBasePin::Complete method. First try to create the device
    handle, which possibly tries to create a Sink handle on the receiving
    pin, then call the base class. If this all succeeds, generate a new
    unconnected pin instance if necessary.

Arguments:

    ReceivePin -
        The pin to complete connection on.

Return Value:

    Returns NOERROR if the connection was completed, else some error.

--*/
{
    HRESULT hr;
    
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // Create devices handles first, then allow the base class to complete
    // the operation.
    //
    
    if (SUCCEEDED(hr = ProcessCompleteConnect(ReceivePin))) {
        hr = CBaseOutputPin::CompleteConnect(ReceivePin);
        if (SUCCEEDED(hr)) {
            //
            // Generate a new unconnected instance of this pin if there
            // are more possible instances available.
            //
            static_cast<CKsProxy*>(m_pFilter)->GeneratePinInstances();
        }
    }

    if (FAILED( hr )) {
        return hr;
    }
    return hr;
//    return KsPropagateAllocatorRenegotiation();
}


HRESULT
CKsOutputPin::BreakConnect(
    )
/*++

Routine Description:

    Override the CBasePin::BreakConnect method. Releases any device handle.
    Note that the connected pin is released here. This means that Disconnect
    must also be overridden in order to not release a connected pin.

Arguments:

    None.

Return Value:

    Returns NOERROR.

--*/
{
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsOutputPin(%s)::BreakConnect"), m_pName ));
    IMemAllocator* SaveBaseAllocator;

    //
    // Update pipes.
    //
    BOOL FlagBypassBaseAllocators = FALSE;
    //
    // Update the system of pipes - reflect disconnect.
    //
    if (KsGetPipe(KsPeekOperation_PeekOnly) ) {
        ::DisconnectPins( static_cast<IKsPin*>(this), Pin_Output, &FlagBypassBaseAllocators);
    }
    
    //
    // Close the device handle if it happened to be open. This is called at
    // various times, and may not have actually opened a handle yet.
    //
    if (m_PinHandle) {
        //
        // Terminate any previous EOS notification that may have been started.
        //
        if (NULL != m_hEOSevent) {
            // First tell the pin we're not going to use this event...
            ULONG bytesReturned;
            KsEvent( NULL, 0, NULL, 0, &bytesReturned );
            // Clear the event from the asynchronous event handler
            m_pAsyncItemHandler->RemoveAsyncItem( m_hEOSevent );
            m_hEOSevent = NULL;
        }

        ::SetSyncSource( m_PinHandle, NULL );
        CloseHandle(m_PinHandle);
        m_PinHandle = NULL;
        //
        // If this was set, then unset it.
        //
        m_QualitySupport = FALSE;
        //
        // Mark all volatile interfaces as reset. Only Static interfaces,
        // and those Volatile interfaces found again will be set. Also
        // notify all interfaces of graph change.
        //
        ResetInterfaces(&m_MarshalerList);
    }
    
    //
    // Reset the marshal data flag.
    //
    m_MarshalData = TRUE;

    //
    // Reset the current Communication for the case of a Both.
    //
    m_CurrentCommunication = m_OriginalCommunication;

    //
    // For output, release the allocator and input pin interface, taking into account
    // the system of data pipes.
    //
    SaveBaseAllocator = KsPeekAllocator( KsPeekOperation_AddRef );

    CBaseOutputPin::BreakConnect();

    if (FlagBypassBaseAllocators && SaveBaseAllocator) {
        KsReceiveAllocator(SaveBaseAllocator);
    }
    
    SAFERELEASE( SaveBaseAllocator );

    //
    // There may not actually be a connection pin, such as when a connection
    // was not completed, or when this is a Bridge.
    //
    SAFERELEASE( m_Connected );

    // Time to shut down our asynchronous event handler
    delete m_pAsyncItemHandler;
    m_pAsyncItemHandler = NULL;

    //
    // If an interface handler was instantiated, release it.
    //
    SAFERELEASE( m_InterfaceHandler );
    //
    // If an data handler was instantiated, release it.
    //
    if (NULL != m_DataTypeHandler) {
        m_DataTypeHandler = NULL;
        SAFERELEASE( m_UnkInner );
    }
    //
    // Remove this pin instance if there is already an unconnected pin of
    // this type.
    //
    static_cast<CKsProxy*>(m_pFilter)->GeneratePinInstances();
    return NOERROR;
}


HRESULT
CKsOutputPin::GetMediaType(
    int Position,
    CMediaType* MediaType
    )
/*++

Routine Description:

    Override the CBasePin::GetMediaType method. Returns the specified media
    type on the Pin Factory Id.

Arguments:

    Position -
        The zero-based position to return. This corresponds to the data range
        item.

    MediaType -
        The media type to initialize.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    if (m_ConfigAmMediaType) {
        //
        // If set, this is supposed to be the only media type offered.
        //
        if (!Position) {
            //
            // The copy does not return an out of memory error.
            //
            CopyMediaType(static_cast<AM_MEDIA_TYPE*>(MediaType), m_ConfigAmMediaType);
            if (m_ConfigAmMediaType->cbFormat && !MediaType->FormatLength()) {
                return E_OUTOFMEMORY;
            }
            return NOERROR;
        }
        return VFW_S_NO_MORE_ITEMS;
    }
    return ::KsGetMediaType(
        Position,
        static_cast<AM_MEDIA_TYPE*>(MediaType),
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId);
}


HRESULT 
CKsOutputPin::InitAllocator(
    IMemAllocator** MemAllocator,
    KSALLOCATORMODE AllocatorMode
)

/*++

Routine Description:
    Initializes an allocator object (CKsAllocator) and returns
    the IMemAllocator interface

Arguments:
    IMemAllocator **MemAllocator -
        pointer to receive the interface pointer
        
    KSALLOCATORMODE AllocatorMode -
        allocator mode, user or kernel

Return Value:
    S_OK or appropriate error code

--*/

{
    CKsAllocator* KsAllocator;
    HRESULT hr = S_OK;
    
    *MemAllocator = NULL;
    //
    // Create the allocator proxy
    //
    KsAllocator = new CKsAllocator( 
        NAME("CKsAllocator"), 
        NULL, 
        static_cast<IPin*>(this),
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        &hr);
    if (KsAllocator) {
        if (SUCCEEDED( hr )) {
            //
            // Setting the allocator mode determines what type of response
            // there is to the standard IMemAllocator interface.
            //
            KsAllocator->KsSetAllocatorMode( AllocatorMode );
            //
            // Get a referenced IMemAllocator.
            //
            hr = KsAllocator->QueryInterface( 
                __uuidof(IMemAllocator),
                reinterpret_cast<PVOID*>(MemAllocator) );
        } else {
            delete KsAllocator;
        }
    } else {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


HRESULT 
CKsOutputPin::DecideAllocator(
    IMemInputPin* Pin, 
    IMemAllocator **MemAllocator
    )

/*++

Routine Description:
    This routine is called by the base class (CBaseOutputPin::CompleteConnect)
    to decide the allocator for this pin.  The negotiation of the allocator 
    is started by this process but also continues through the input pin as 
    we attempt to obtain a compatible allocator from either the upstream input 
    pin or the downstream input pin.

Arguments:
    Pin -
        pointer to the connecting input pin

    MemAllocator -
        pointer to contain the resultant allocator

Return Value:
    S_OK or an appropriate error code.

--*/

{
    HRESULT           hr;
    IPin*             InPin;
    IKsPin*           InKsPin;
    IKsPinPipe*       InKsPinPipe;

    
    DbgLog(( 
        LOG_MEMORY, 
        2, 
        TEXT("PIPES ATTN %s(%s)::DecideAllocator v.%03d, *MemAllocator == %08x, OutKsPin=%x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        DataFlowVersion,
        *MemAllocator,
        static_cast<IKsPin*>(this) ));

    //
    // New pipes-based logic.
    // Get the pointers to necessary interfaces
    //
    GetInterfacePointerNoLockWithAssert(Pin, __uuidof(IPin), InPin, hr);

    if (::IsKernelPin(InPin) ) {
        GetInterfacePointerNoLockWithAssert(Pin, __uuidof(IKsPin), InKsPin, hr);
    }
    else {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN %s(%s)::DecideAllocator UserMode input pin"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName ));
        
        InKsPin = NULL;
    }

    // 
    // Detect and handle one of the possible following connections:
    // 1. pipe to pipe,
    // 2. pipe to user-mode pin.
    // If there is no pipe on kernel-mode pins yet, we will create the pipe[-s] and then handle cases 1 or 2 above.
    //

    if ( SUCCEEDED( hr ) && (! KsGetPipe(KsPeekOperation_PeekOnly) ) )  {
        //
        // pipe was not created on this output pin yet.
        //
        hr = ::MakePipesBasedOnFilter( static_cast<IKsPin*>(this), Pin_Output);
    }

    if ( SUCCEEDED( hr )) {
        if ( ! InKsPin) { 
            hr = ::ConnectPipeToUserModePin( static_cast<IKsPin*>(this), Pin);
        }
        else {
            //
            //  This is KM to KM connection.
            //  Query Input pin for a pipe
            //
            GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);
        
            DbgLog(( 
                LOG_MEMORY, 
                2, 
                TEXT("PIPES %s(%s)::DecideAllocator, Input pin=%x"),
                InKsPinPipe->KsGetFilterName(),
                InKsPinPipe->KsGetPinName(),
                InKsPin));
        
        
            if (! InKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly ) ) {
                //
                // pipe was not created on this input pin yet.
                //
                hr = ::MakePipesBasedOnFilter(InKsPin, Pin_Input);
            }
        
            if ( SUCCEEDED( hr )) {
                hr = ::ConnectPipes(InKsPin, static_cast<IKsPin*>(this) );
            }
        }
    }

    //
    // we need to return IMemAllocator
    //
    *MemAllocator = KsPeekAllocator (KsPeekOperation_PeekOnly);
    
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES %s(%s):: DecideAllocator rets=%x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        hr ));


    return hr;
}


STDMETHODIMP
CKsOutputPin::CompletePartialMediaType(
    IN CMediaType* MediaType,
    OUT AM_MEDIA_TYPE** CompleteAmMediaType
    )
/*++

Routine Description:

    Implements the CKsOutputPin::CompletePartialMediaType method. Queries the
    data format handle to complete the media type passed. If the interface
    is not supported, the function succeeds anyway. This is used by
    SetFormat on the MediaType it receives before applying that MediaType
    to the filter.

Arguments:

    MediaType -
        Contains the media type to complete.

    CompleteAmMediaType -
        The place in which to put the completed media type. This contains
        NULL if the function fails.

Return Value:

    S_OK or a validation error.

--*/
{
    IKsDataTypeHandler*     DataTypeHandler;
    IUnknown*               UnkInner;
    IKsDataTypeCompletion*  DataTypeCompletion;
    HRESULT                 hr;

    //
    // Load the data handler for this media type.
    //
    ::OpenDataHandler(MediaType, static_cast<IPin*>(this), &DataTypeHandler, &UnkInner);
    //
    // If there is a data type handler, then attempt to acquire the
    // optional Completion interface.
    //
    if (UnkInner) {
        if (SUCCEEDED(UnkInner->QueryInterface(__uuidof(IKsDataTypeCompletion), reinterpret_cast<PVOID*>(&DataTypeCompletion)))) {
            //
            // This interface produced a refcount on the out IUnknown,
            // which is the filter. No need to keep the count on it.
            // The inner unknown still has a refcount on it.
            //
            DataTypeCompletion->Release();
        }
    } else {
        DataTypeCompletion = NULL;
    }
    //
    // If there is a completion interface on the data type handler,
    // then use it to complete this media type. Make a copy of it
    // first, since it may be modified.
    //
    *CompleteAmMediaType = CreateMediaType(MediaType);
    if (*CompleteAmMediaType) {
        //
        // Complete the media type by calling the data handler.
        //
        if (DataTypeCompletion) {
            hr = DataTypeCompletion->KsCompleteMediaType(
                static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
                m_PinFactoryId,
                *CompleteAmMediaType);
            if (!SUCCEEDED(hr)) {
                DeleteMediaType(*CompleteAmMediaType);
                *CompleteAmMediaType = NULL;
            }
        } else {
            hr = NOERROR;
        }
    } else {
        hr = E_OUTOFMEMORY;
    }
    //
    // Release the data handler if it was loaded. This releases the count
    // on the handler itself.
    //
    SAFERELEASE( UnkInner );
    
    return hr;
}


STDMETHODIMP
CKsOutputPin::KsPropagateAllocatorRenegotiation(
    )
/*++

Routine Description:
    Propagates the allocator renegotation back up stream.  If 
    a non-proxy pin is hit, the renegotation is completed with reconnect.

Arguments:
    None.

Return Value:
    S_OK or an appropriate error

--*/
{
    IPin    **PinList;
    HRESULT hr;
    ULONG   i, PinCount;
    
    PinCount = 0;
    
    //
    // The Transform-In-Place filter issues a reconnection if the output
    // pin is connected and if the MediaType is not the same for both the
    // input and output pins of the filter. If a reconnect is not required 
    // the Transform-In-Place filter calls CBaseInputPin::CompleteConnect() 
    // which calls CBasePin::CompleteConnect(), which does nothing.
    //
    
    hr = 
        QueryInternalConnections(
            NULL,           // IPin** PinList
            &PinCount );
            
    //
    // If any input pins have been connected, reconnect 'em.
    //
    
    if (SUCCEEDED( hr ) && PinCount) {
        if (NULL == (PinList = new IPin*[ PinCount ])) {
            hr = E_OUTOFMEMORY;
        } else {
            hr = 
                QueryInternalConnections(
                    PinList,        // IPin** PinList
                    &PinCount );
        }      
    } else {
        PinList = NULL;
    }
    
    if (SUCCEEDED( hr )) {
        DbgLog(( 
            LOG_MEMORY, 
            2, 
            TEXT("%s(%s)::KsPropagateAllocatorRenegotiation found %d input pins"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName,
            PinCount));
    
        for (i = 0; i < PinCount; i++) {
            if (static_cast<CBasePin*>(PinList[ i ])->IsConnected()) {
            
                IKsPin *KsPin;
                IPin   *UpstreamOutputPin;

                UpstreamOutputPin =
                    static_cast<CBasePin*>(PinList[ i ])->GetConnected();
                
                UpstreamOutputPin->QueryInterface( 
                    __uuidof(IKsPin),
                    reinterpret_cast<PVOID*>(&KsPin) );
                
                if (KsPin) {
                    DbgLog(( 
                        LOG_MEMORY, 
                        2, 
                        TEXT("%s(%s): renegotiating allocators via IKsPin"),
                        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                        m_pName ));
                    KsPin->KsRenegotiateAllocator();
                    KsPin->Release();        
                } else {
                    DbgLog(( 
                        LOG_MEMORY, 
                        2, 
                        TEXT("%s(%s): issuing reconnect"),
                        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                        m_pName ));
                    
                    m_pFilter->GetFilterGraph()->Reconnect( PinList[ i ] );
                }
            }
            PinList[ i ]->Release();
        }
    }
    
    if (PinList) {
        delete [] PinList;
    }
    
    return hr;
}


STDMETHODIMP
CKsOutputPin::KsRenegotiateAllocator(
    )
/*++

Routine Description:
    Renegotiates the allocator for the input pin and then propogates
    renegotation upstream.

Arguments:
    None.

Return Value:
    S_OK or appropriate error

--*/
{
    return S_OK;
}   


STDMETHODIMP
CKsOutputPin::KsReceiveAllocator(
    IMemAllocator* MemAllocator
    )

/*++

Routine Description:
    Receives notifications from input pins specifying which allocator
    was negotiated.  This routine propagates the allocator to any 
    connected downstream input pins.
    
    Borrowed from CTransInPlaceOutputPin.

Arguments:
    MemAllocator -
        Selected memory allocator interface.

Return Value:
    S_OK or an appropriate failure code.

--*/

{
    if (MemAllocator) {
        MemAllocator->AddRef();
    }
    // Do this after the AddRef() above in case MemAllocator == m_pAllocator
    SAFERELEASE( m_pAllocator );
    m_pAllocator = MemAllocator;
    
    return (S_OK);
}    


HRESULT
CKsOutputPin::DecideBufferSize(
    IMemAllocator* MemAllocator,
    ALLOCATOR_PROPERTIES* RequestedRequirements
    )
/*++

Routine Description:
    This routine is called by DecideAllocator() to determine the buffer
    size for the selected allocator.  This method sets up the buffer
    size based on this pin's requirements adjusted for the upstream
    allocator's requirements (if any).  
    
    NOTE: If the associated kernel-mode pin does not report any requirements,
    the buffer size is adjusted to be at least the size of one sample based
    on m_mt.lSampleSize.

Arguments:
    MemAllocator -
        Pointer to the allocator.

    RequestedRequirements -
        Requested requirements for this allocator.  On return, this contains
        the adjusted properties for our our requirements and the upstream
        allocator.

Return Value:
    NOERROR if successful, otherwise an appropriate error code.

--*/

{

    IPin                    **PinList;
    ALLOCATOR_PROPERTIES    CompatibleRequirements, Actual;
    HRESULT                 hr;
    KSALLOCATOR_FRAMING     Framing;
    ULONG                   i, PinCount;
    
    //
    // Check for an upstream input pin's allocator requirements and
    // adjust the given requirements for compatibility.
    //
    
    CompatibleRequirements.cBuffers = 
        max( RequestedRequirements->cBuffers, m_SuggestedProperties.cBuffers );
    CompatibleRequirements.cbBuffer = 
        max( RequestedRequirements->cbBuffer, m_SuggestedProperties.cbBuffer );
    CompatibleRequirements.cbAlign = 
        max( RequestedRequirements->cbAlign, m_SuggestedProperties.cbAlign );
    CompatibleRequirements.cbPrefix = 
        max( RequestedRequirements->cbPrefix, m_SuggestedProperties.cbPrefix );
        
        
    
    CompatibleRequirements.cBuffers = 
        max( 1, CompatibleRequirements.cBuffers );
    CompatibleRequirements.cbBuffer = 
        max( 1, CompatibleRequirements.cbBuffer );

    if (m_PinHandle) {        
        //
        // Query the pin for any output framing requirements
        //
        
        hr = ::GetAllocatorFraming(m_PinHandle, &Framing);
    
        DbgLog(( 
            LOG_MEMORY, 
            2, 
            TEXT("%s(%s)::DecideBufferSize ALLOCATORFRAMING returned %x"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName,
            hr ));
            
    } else {
        hr = E_FAIL;
    }        

    if (SUCCEEDED(hr)) {
        //
        // The kernel-mode pin has framing requirements, adjust the
        // compatible requirements to meet those needs.
        //
        CompatibleRequirements.cBuffers = 
            max( 
                (LONG) Framing.Frames, 
                CompatibleRequirements.cBuffers );
        CompatibleRequirements.cbBuffer = 
            max( 
                (LONG) Framing.FrameSize, 
                CompatibleRequirements.cbBuffer );
        CompatibleRequirements.cbAlign =
            max( 
                (LONG) Framing.FileAlignment + 1, 
                CompatibleRequirements.cbAlign );
    } else if (IsConnected()) {
        //
        // No allocator framing requirements were specified by the
        // kernel-mode pin. If this pin is connected, then adjust 
        // the compatible requirements for the current media type.
        //
        
        CompatibleRequirements.cbBuffer =
            max( static_cast<LONG>(m_mt.lSampleSize), CompatibleRequirements.cbBuffer );
    }
        
    PinCount = 0;
    
    //
    // Query the connected pins, note that PIN_DIRECTION specifies the
    // direction of this pin, not the pin that we are looking for.
    //
    
    hr = 
        QueryInternalConnections(
            NULL,           // IPin** PinList
            &PinCount );
            
    //
    // If there are internal connections (e.g. Topology) then retrieve
    // the connected pins.
    //
            
    if (SUCCEEDED( hr ) && PinCount) {
        if (NULL == (PinList = new IPin*[ PinCount ])) {
            hr = E_OUTOFMEMORY;
        } else {
            hr = 
                QueryInternalConnections(
                    PinList,        // IPin** PinList
                    &PinCount );
        }      
    } else {
        PinList = NULL;
    }
    
    if (SUCCEEDED( hr ) && PinCount) {
        DbgLog(( 
            LOG_MEMORY, 
            2, 
            TEXT("%s(%s)::DecideBufferSize found %d input pins"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName,
            PinCount));
    
        for (i = 0; i < PinCount; i++) {
        
            ALLOCATOR_PROPERTIES    UpstreamRequirements;
            IMemAllocator           *UpstreamAllocator;
        
            //
            // Loop through connected input pins and determine the
            // compatible framing requirements.
            //
            
            if (((CBasePin *)PinList[ i ])->IsConnected()) {
                hr = 
                    static_cast<CBaseInputPin*>(PinList[ i ])->GetAllocator( 
                        &UpstreamAllocator );
            
                //
                // Get the allocator properties and adjust the compatible
                // properties to meet these needs.
                //
                    
                if (SUCCEEDED( hr ) && UpstreamAllocator) {
                
                    if (SUCCEEDED( UpstreamAllocator->GetProperties( 
                                        &UpstreamRequirements ) )) {
                                        
                        DbgLog(( 
                            LOG_MEMORY, 
                            2, 
                            TEXT("upstream requirements: cBuffers = %x, cbBuffer = %x"),
                            UpstreamRequirements.cBuffers,
                            UpstreamRequirements.cbBuffer));
                        DbgLog(( 
                            LOG_MEMORY, 
                            2, 
                            TEXT("upstream requirements: cbAlign = %x, cbPrefix = %x"),
                            UpstreamRequirements.cbAlign,
                            UpstreamRequirements.cbPrefix));
                                        
                        CompatibleRequirements.cBuffers =
                            max( 
                                CompatibleRequirements.cBuffers,
                                UpstreamRequirements.cBuffers );
                        CompatibleRequirements.cbBuffer =
                            max( 
                                CompatibleRequirements.cbBuffer,
                                UpstreamRequirements.cbBuffer );
                        CompatibleRequirements.cbAlign =
                            max( 
                                CompatibleRequirements.cbAlign,
                                UpstreamRequirements.cbAlign );
                        
                        //
                        // 86054: Since the only change here is to make cbPrefix larger,
                        // we should be safe with this check.
                        //
                        CompatibleRequirements.cbPrefix =
                            max( CompatibleRequirements.cbPrefix,
                                 UpstreamRequirements.cbPrefix );

                    }
                    UpstreamAllocator->Release();
                }
            }
            
            PinList[ i ]->Release();
        }
        
        //
        // Clean up the pin list.
        // 
        
        if (PinList) {
            delete [] PinList;
        }
    } 
    
    DbgLog(( 
        LOG_MEMORY, 
        2, 
        TEXT("%s(%s):compatible requirements: cBuffers = %x, cbBuffer = %x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        CompatibleRequirements.cBuffers,
        CompatibleRequirements.cbBuffer));
    DbgLog(( 
        LOG_MEMORY, 
        2, 
        TEXT("%s(%s):compatible requirements: cbAlign = %x, cbPrefix = %x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        CompatibleRequirements.cbAlign,
        CompatibleRequirements.cbPrefix));

    if (FAILED( hr = MemAllocator->SetProperties( 
                        &CompatibleRequirements, 
                        &Actual ) )) {
        return hr;
    }

    DbgLog(( 
        LOG_MEMORY, 
        2, 
        TEXT("%s(%s):actual requirements: cBuffers = %x, cbBuffer = %x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        Actual.cBuffers,
        Actual.cbBuffer));

    // Make sure we got the right alignment and at least the minimum required

    if ((CompatibleRequirements.cBuffers > Actual.cBuffers) ||
        (CompatibleRequirements.cbBuffer > Actual.cbBuffer) ||
        (CompatibleRequirements.cbAlign > Actual.cbAlign)) {
        return E_FAIL;
    }
    
    return NOERROR;

} // DecideBufferSize


STDMETHODIMP_(IMemAllocator*)
CKsOutputPin::KsPeekAllocator(
    KSPEEKOPERATION Operation
    )
/*++

Routine Description:
    Returns the assigned allocator for this pin and optionally
    AddRef()'s the interface.

Arguments:
    Operation -
        If KsPeekOperation_AddRef is specified, the m_pAllocator is
        AddRef()'d (if not NULL) before returning.

Return Value:
    The value of m_pAllocator.

--*/
{
    if ( (Operation == KsPeekOperation_AddRef) && m_pAllocator ) {
        m_pAllocator->AddRef();
    }
    return m_pAllocator;
}


STDMETHODIMP_(LONG) 
CKsOutputPin::KsIncrementPendingIoCount(
    )
/*++

Routine Description:

    Implement the IKsPin::KsIncrementPendingIoCount method. Increments the
    count of outstanding pending I/O on the pin, and is called from an
    Interface handler.

Arguments:

    None.

Return Value:

    Returns the current outstanding count.

--*/
{
    return InterlockedIncrement(&m_PendingIoCount);
}    


STDMETHODIMP_(LONG) 
CKsOutputPin::KsDecrementPendingIoCount(
    )
/*++

Routine Description:

    Implement the IKsPin::KsDecrementPendingIoCount method. Decrements the
    count of outstanding pending I/O on the pin, and is called from an
    Interface handler.

Arguments:

    None.

Return Value:

    Returns the current outstanding count.

--*/
{
    LONG PendingIoCount;
    
    if (0 == (PendingIoCount = InterlockedDecrement( &m_PendingIoCount ))) {
        //
        // The filter is in a stopped state, and this is the last I/O to
        // complete. At this point the Inactive method may be waiting on
        // all the I/O to be completed, so it needs to be signalled.
        //
        if (IsStopped()) {
            SetEvent( m_PendingIoCompletedEvent );
        }            
    }
    return PendingIoCount;
}    


STDMETHODIMP_( VOID )
CKsOutputPin::KsNotifyError(
    IMediaSample* Sample, 
    HRESULT hr
    )
/*++

Routine Description:
    Raises an error in the graph, if this has not already occurred.

Arguments:
    IMediaSample* Sample -
    
    HRESULT hr -

Return Value:
    None

--*/
{
    //
    // Don't raise an error if the I/O was cancelled.
    //
    if (hr == HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED)) {
        return;
    }       
    //
    // Notify the filter graph that we have an error. Ensure this
    // happens only once during a run, and that nothing further
    // is queued up.
    //
    m_DeliveryError = TRUE;
    m_pFilter->NotifyEvent( EC_ERRORABORT, hr, 0 );
}    


STDMETHODIMP 
CKsOutputPin::QueueBuffersToDevice(
    )
/*++

Routine Description:
    Queues buffers to the associated device. The m_pLock for the pin cannot
    be taken when this is called because it takes the I/O critical section.

Arguments:
    None.

Return Value:
    S_OK or an appropriate error code.

--*/
{
    HRESULT             hr = S_OK;
    int                 i;
    IMediaSample  *     MediaSample;
    AM_MEDIA_TYPE *     MediaType;
    LONG                SampleCount;
    PKSSTREAM_SEGMENT   StreamSegment;
    PASYNC_ITEM         pAsyncItem;
    CKsProxy *          KsProxy = static_cast<CKsProxy *> (m_pFilter);

    KsProxy->EnterIoCriticalSection ();

    //
    // Marshal buffers into the kernel while we're not in a stop state and
    // the allocator isn't exhausted.
    //
    while (!IsStopped() &&
           !m_DeliveryError &&
           !m_EndOfStream &&
           !m_bFlushing &&
           m_pAllocator ) {

        //
        // give all buffers out
        //
        
        hr = m_pAllocator->GetBuffer( &MediaSample, NULL, NULL, AM_GBF_NOWAIT );
        if (!SUCCEEDED(hr)) {
        	break;
        }

        hr = MediaSample->GetMediaType( &MediaType );

        if (SUCCEEDED(hr) && (S_FALSE != hr)) {
            ::SetMediaType( m_PinHandle, static_cast<CMediaType *>(MediaType) );
            DeleteMediaType( MediaType );
        }

		PBUFFER_CONTEXT pContext;
		
		if (SUCCEEDED (hr) ) {
	        SampleCount = 1;
    	    pAsyncItem = new ASYNC_ITEM;
        	pContext = new BUFFER_CONTEXT;

	        if (pAsyncItem == NULL || pContext == NULL) {
    	        hr = E_OUTOFMEMORY;
        	    MediaSample->Release();
            	if (pAsyncItem) delete pAsyncItem;
	            if (pContext) delete pContext;
    	    }
    	}

        if (SUCCEEDED (hr)) {

            StreamSegment = NULL;
            hr = m_InterfaceHandler->KsProcessMediaSamples (
                m_DataTypeHandler, 
                &MediaSample, 
                &SampleCount, 
                KsIoOperation_Read, 
                &StreamSegment 
                );

            //
            // Check to make sure that the stream segment was created and
            // that the sample count exists.  Otherwise, this is an indication
            // that the interface handler has run out of memory or run into
            // some such problem that prevented it from marshaling.
            //
            ASSERT ((StreamSegment && SampleCount != 0) || 
                    (StreamSegment == NULL && SampleCount == 0));

            if (StreamSegment && SampleCount) {
                //
                // Even if the KsProcessMediaSamples call fails, we must still
                // add the event to the event list.  It gets signalled by the
                // interface handler.  This is true, unless of course, 
                // the check above fails.
                //
                pContext->pThis = this;
                pContext->streamSegment = StreamSegment;
                InitializeAsyncItem (
                    pAsyncItem, 
                    TRUE, 
                    StreamSegment->CompletionEvent, 
                    (PASYNC_ITEM_ROUTINE) OutputPinBufferHandler, 
                    pContext
                    );

                //
                // To retain the delivery order of the packets as they 
                // complete, each sample is added to m_IoQueue and only
                // the head of the list is placed on the I/O thread's queue.
                // When the interface handler calls back via the 
                // MediaSamplesCompleted() method, the next sample on the 
                // queue is added to the I/O thread's list.
                //
                m_IoQueue.AddTail (pAsyncItem);
                if (m_IoQueue.GetHead () == pAsyncItem) {
                    KsProxy->LeaveIoCriticalSection();
                    m_pAsyncItemHandler->QueueAsyncItem (pAsyncItem);
                    KsProxy->EnterIoCriticalSection();
                }
            } else {
            	if (pAsyncItem) delete pAsyncItem;
            	if (pContext) delete pContext;
			}            
        }

        //
        // Check to see whether we need to notify the graph of an error.
        // If so, stop marshaling.
        //
        if (!SUCCEEDED (hr)) {
            KsNotifyError (MediaSample, hr);
            break;
        }
    } // while (!IsStopped() && !m_DeliveryError && !m_EndOfStream && SUCCEEDED(hr = m_pAllocator->GetBuffer( ... )))

    KsProxy->LeaveIoCriticalSection();

    return (VFW_E_TIMEOUT == hr) ? S_OK : hr; // GetBuffer could have returned VFW_E_TIMEOUT
}


STDMETHODIMP
CKsOutputPin::KsDeliver(
    IMediaSample* Sample,
    ULONG Flags
    )
/*++

Routine Description:

    Implements the IKsPin::KsDeliver method which reflects this call to
    the CKsOutputPin::Deliver method or if a helper thread has been
    created, it posts a message to the thread to complete the delivery.
    
    This method on IKsPin provides the interface method for 
    IKsInterfaceHandler to deliver samples to the connected pin and continues 
    the I/O operation by retrieving the next buffer from allocator and 
    submitting the buffer to the device.

Arguments:

    Sample -
        Pointer to a media sample.

    Flags -
        Sample flags. This is used to check for EOS.

Return Value:

    Return from Deliver() method or S_OK.

--*/
{
    //
    // The stream may be temporarily stopped.
    //
    if (STREAM_FLOWING == CheckStreamState( Sample )) {
    
        if (m_LastSampleDiscarded) {
            Sample->SetDiscontinuity(TRUE);
            m_LastSampleDiscarded = FALSE;
        }
        
        HRESULT hr;

        hr = Deliver( Sample );
            
        if (SUCCEEDED(hr) && (Flags & AM_SAMPLE_ENDOFSTREAM)) {
            //
            // An interface handler must pass this flag if it
            // is set so that the EOS can be passed on.
            //
#if 0
            //
            // The reported length may have been an approximation, or Quality
            // Management may have dropped frames. So set the start/end times.
            //
            static_cast<CKsProxy*>(m_pFilter)->PositionEOS();
#endif
            //
            // Call the base class to do the default operation, which is to
            // forward to the End-Of-Stream to any connected pin.
            //
            m_EndOfStream = TRUE;
            CBaseOutputPin::DeliverEndOfStream();
        }

        return hr;
        
    } // if (STREAM_FLOWING == CheckStreamState( Sample ))
    else {
        //
        // This value is set before releasing the sample, in case of recursion.
        //
        m_LastSampleDiscarded = TRUE;
        Sample->Release();
        
        return S_OK;
    }
}


STDMETHODIMP 
CKsOutputPin::KsMediaSamplesCompleted(
    PKSSTREAM_SEGMENT StreamSegment
    )
/*++

Routine Description:
    Notification handler for stream segment completed.  Remove the head
    of the I/O queue and add the next in the list to the I/O slots.

Arguments:
    StreamSegment -
        Segment completed.

Return:
    Nothing.

--*/
{
    //
    // If we're flushing buffers out to synchronize end flush with the kernel
    // filter, ignore ordering.  The synchronization routine will keep
    // the queue managed.
    //
    if (m_FlushMode == FLUSH_NONE) {
    
        PASYNC_ITEM Node = m_IoQueue.RemoveHead ();
        PBUFFER_CONTEXT BufferContext = reinterpret_cast<PBUFFER_CONTEXT> 
            (Node->context);
    
        ASSERT (BufferContext->streamSegment == StreamSegment);
    
        if (Node = m_IoQueue.GetHead ()) {
            m_pAsyncItemHandler -> QueueAsyncItem (Node);
        }
    }

    return S_OK;
}


STDMETHODIMP
CKsOutputPin::KsQualityNotify(
    ULONG Proportion,
    REFERENCE_TIME TimeDelta
    )
/*++

Routine Description:

    This should not be called on an output pin, as quality managment reports
    are not received.

Arguments:

    Proportion -
        The proportion of data rendered.

    TimeDelta -
        The delta from nominal time at which the data is being received.

Return Value:

    Returns E_FAIL.

--*/
{
    //
    // Output pins should not be generating such notifications.
    //
    return E_FAIL;
}


HRESULT
CKsOutputPin::Deliver(
    IMediaSample* Sample
    )
/*++

Routine Description:
    Overrides the Deliver method to account for sample reference counting
    and outstanding allocated frame counts.  Reflects the Deliver to 
    the CBaseOutputPin base class.

Arguments:
    Sample -
        Pointer to the sample to be delivered.

Return Value:
    S_OK or appropriate error code

--*/
{
    HRESULT hr;
    
    //
    // A previous delivery failure will cause any subsequent deliveries not
    // to occur, although success will be returned.
    //
    if (!m_DeliveryError && !m_EndOfStream) {
        if (m_pInputPin == NULL) {
            hr = VFW_E_NOT_CONNECTED;
        } else {
            hr = m_pInputPin->Receive( Sample );
        }
        //
        // On a delivery failure, all subsequent delivery is stopped until the
        // filter transitions through Stop, or is flushed.
        //
        if (FAILED(hr)) {
            m_DeliveryError = TRUE;
        }
    } else {
        hr = S_OK;
    }
    
    Sample->Release();
    
    return hr;
}
    

HRESULT
CKsOutputPin::DeliverBeginFlush(
    )
/*++

Routine Description:

    Override the CBaseOutputPin::DeliverBeginFlush method. Forwards Begin-
    Stream notification to the connected input pin. Also notifies the
    CBaseStreamControl object of the flush state.

Arguments:

    None.

Return Value:

    Returns NOERROR, else VFW_E_NOT_CONNECTED if the pin is not connected.

--*/
{
    Flushing( m_bFlushing = TRUE );
    //
    // Reset the state of any previous delivery error.
    //
    m_DeliveryError = FALSE;
    m_EndOfStream = FALSE;

    return CBaseOutputPin::DeliverBeginFlush();
}


HRESULT
CKsOutputPin::DeliverEndFlush(
    )
/*++

Routine Description:

    Override the CBaseOutputPin::DeliverEndFlush method. Forwards Begin-
    Stream notification to the connected input pin. Also notifies the
    CBaseStreamControl object of the flush state.

Arguments:

    None.

Return Value:

    Returns NOERROR, else VFW_E_NOT_CONNECTED if the pin is not connected.

--*/
{
    HRESULT hr = S_OK;

    //
    // Synchronize with the async handler.  Make sure that no buffers signaled
    // before the flush get delivered downstream.  The async thread itself
    // will deal with this.
    //
    if (m_PinHandle && m_MarshalData) {
        SetEvent(m_hFlushEvent);
        WaitForSingleObjectEx (m_hFlushCompleteEvent, INFINITE, FALSE);
    }

    Flushing( m_bFlushing = FALSE );
    hr = CBaseOutputPin::DeliverEndFlush();
    if (m_Connected && m_MarshalData) {
        SetEvent (m_hMarshalEvent);
    }
    return hr;
}


HRESULT
CKsOutputPin::DeliverEndOfStream(
    )
/*++

Routine Description:

    Override the CBaseOutputPin::DeliverEndOfStream method. Forwards End-Of-
    Stream notification to either the graph, or the connected pin, if any.

Arguments:

    None.

Return Value:

    Returns NOERROR.

--*/
{
    //
    // Notification from any upstream filter is ignored, since the EOS
    // flag will be looked at by the marshaling code and sent when the
    // last I/O has completed. When marshaling does not occur a downstream
    // instance of the proxy will have registered with EOS notification.
    //
    return NOERROR;
}


STDMETHODIMP 
CKsOutputPin::GetPages(
    CAUUID* Pages
    )
/*++

Routine Description:

    Implement the ISpecifyPropertyPages::GetPages method. This adds any
    Specifier handlers to the property pages if the pin instances is still
    unconnected and it is a Bridge pin. Else it adds none.

Arguments:

    Pages -
        The structure to fill in with the page list.

Return Value:

    Returns NOERROR, else a memory allocation error. Fills in the list of pages
    and page count.

--*/
{
    return ::GetPages(
        static_cast<IKsObject*>(this),
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        m_CurrentCommunication,
        static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
        Pages);
} 


STDMETHODIMP
CKsOutputPin::Render(
    IPin* PinOut,
    IGraphBuilder* Graph
    )
/*++

Routine Description:

    Implement the IStreamBuilder::Render method. This is only exposed on Bridge
    and None pins in order to make the graph builder ignore these pins.

Arguments:

    PinOut -
        The pin which this pin should attempt to render to.

    Graph -
        The graph builder making the call.

Return Value:

    Returns S_OK so that the graph builder will ignore this pin.

--*/
{
    return S_OK;
}


STDMETHODIMP
CKsOutputPin::Backout(
    IPin* PinOut,
    IGraphBuilder* Graph
    )
/*++

Routine Description:

    Implement the IStreamBuilder::Backout method. This is only exposed on Bridge
    and None pins in order to make the graph builder ignore these pins.

Arguments:

    PinOut -
        The pin which this pin should back out from.

    Graph -
        The graph builder making the call.

Return Value:

    Returns S_OK so that the graph builder will ignore this pin.

--*/
{
    return S_OK;
}


STDMETHODIMP
CKsOutputPin::Set(
    REFGUID PropSet,
    ULONG Id,
    LPVOID InstanceData,
    ULONG InstanceLength,
    LPVOID PropertyData,
    ULONG DataLength
    )
/*++

Routine Description:

    Implement the IKsPropertySet::Set method. This sets a property on the
    underlying kernel pin.

Arguments:

    PropSet -
        The GUID of the set to use.

    Id -
        The property identifier within the set.

    InstanceData -
        Points to the instance data passed to the property.

    InstanceLength -
        Contains the length of the instance data passed.

    PropertyData -
        Points to the data to pass to the property.

    DataLength -
        Contains the length of the data passed.

Return Value:

    Returns NOERROR if the property was set.

--*/
{
    ULONG   BytesReturned;

    if (InstanceLength) {
        PKSPROPERTY Property;
        HRESULT     hr;

        Property = reinterpret_cast<PKSPROPERTY>(new BYTE[sizeof(*Property) + InstanceLength]);
        if (!Property) {
            return E_OUTOFMEMORY;
        }
        Property->Set = PropSet;
        Property->Id = Id;
        Property->Flags = KSPROPERTY_TYPE_SET;
        memcpy(Property + 1, InstanceData, InstanceLength);
        hr = KsProperty(
            Property,
            sizeof(*Property) + InstanceLength,
            PropertyData,
            DataLength,
            &BytesReturned);
        delete [] reinterpret_cast<BYTE*>(Property);
        return hr;
    } else {
        KSPROPERTY  Property;

        Property.Set = PropSet;
        Property.Id = Id;
        Property.Flags = KSPROPERTY_TYPE_SET;
        return KsProperty(
            &Property,
            sizeof(Property),
            PropertyData,
            DataLength,
            &BytesReturned);
    }
}


STDMETHODIMP
CKsOutputPin::Get(
    REFGUID PropSet,
    ULONG Id,
    LPVOID InstanceData,
    ULONG InstanceLength,
    LPVOID PropertyData,
    ULONG DataLength,
    ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsPropertySet::Get method. This gets a property on the
    underlying kernel pin.

Arguments:

    PropSet -
        The GUID of the set to use.

    Id -
        The property identifier within the set.

    InstanceData -
        Points to the instance data passed to the property.

    InstanceLength -
        Contains the length of the instance data passed.

    PropertyData -
        Points to the place in which to return the data for the property.

    DataLength -
        Contains the length of the data buffer passed.

    BytesReturned -
        The place in which to put the number of bytes actually returned.

Return Value:

    Returns NOERROR if the property was retrieved.

--*/
{
    if (InstanceLength) {
        PKSPROPERTY Property;
        HRESULT     hr;

        Property = reinterpret_cast<PKSPROPERTY>(new BYTE[sizeof(*Property) + InstanceLength]);
        if (!Property) {
            return E_OUTOFMEMORY;
        }
        Property->Set = PropSet;
        Property->Id = Id;
        Property->Flags = KSPROPERTY_TYPE_GET;
        memcpy(Property + 1, InstanceData, InstanceLength);
        hr = KsProperty(
            Property,
            sizeof(*Property) + InstanceLength,
            PropertyData,
            DataLength,
            BytesReturned);
        delete [] reinterpret_cast<BYTE*>(Property);
        return hr;
    } else if (PropSet == AMPROPSETID_Pin) {
        KSP_PIN Pin;

        switch (Id) {
        case AMPROPERTY_PIN_CATEGORY:
            Pin.Property.Set = KSPROPSETID_Pin;
            Pin.Property.Id = KSPROPERTY_PIN_CATEGORY;
            Pin.Property.Flags = KSPROPERTY_TYPE_GET;
            Pin.PinId = m_PinFactoryId;
            Pin.Reserved = 0;
            return static_cast<CKsProxy*>(m_pFilter)->KsProperty(
                reinterpret_cast<PKSPROPERTY>(&Pin),
                sizeof(Pin),
                PropertyData,
                DataLength,
                BytesReturned);
        default:
            return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }
    } else {
        KSPROPERTY  Property;

        Property.Set = PropSet;
        Property.Id = Id;
        Property.Flags = KSPROPERTY_TYPE_GET;
        return KsProperty(
            &Property,
            sizeof(Property),
            PropertyData,
            DataLength,
            BytesReturned);
    }
}


STDMETHODIMP
CKsOutputPin::QuerySupported(
    REFGUID PropSet,
    ULONG Id,
    ULONG* TypeSupport
    )
/*++

Routine Description:

    Implement the IKsPropertySet::QuerySupported method. Return the type of
    support is provided for this property.

Arguments:

    PropSet -
        The GUID of the set to query.

    Id -
        The property identifier within the set.

    TypeSupport
        Optionally the place in which to put the type of support. If NULL, the
        query returns whether or not the property set as a whole is supported.
        In this case the Id parameter is not used and must be zero.

Return Value:

    Returns NOERROR if the property support was retrieved.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = PropSet;
    Property.Id = Id;
    Property.Flags = TypeSupport ? KSPROPERTY_TYPE_BASICSUPPORT : KSPROPERTY_TYPE_SETSUPPORT;
    return KsProperty(
        &Property,
        sizeof(Property),
        TypeSupport,
        TypeSupport ? sizeof(*TypeSupport) : 0,
        &BytesReturned);
}


STDMETHODIMP
CKsOutputPin::KsPinFactory(
    ULONG* PinFactory
    )
/*++

Routine Description:

    Implement the IKsPinFactory::KsPinFactory method. Return the pin factory
    identifier.

Arguments:

    PinFactory -
        The place in which to put the pin factory identifier.

Return Value:

    Returns NOERROR.

--*/
{
    *PinFactory = m_PinFactoryId;
    return NOERROR;
}


STDMETHODIMP
CKsOutputPin::SuggestAllocatorProperties(
    const ALLOCATOR_PROPERTIES *AllocatorProperties
    )
/*++

Routine Description:

    Implement the IAMBufferNegotiation::SuggestAllocatorProperties method.
    Sets the suggested allocator properties. These properties are
    suggested by an application but are adjusted for driver requirements.

Arguments:

    AllocatorProperties -
        Pointer to suggested allocator properties.

Return Value:

    Return E_UNEXPECTED if connected or S_OK.

--*/
{
    CAutoLock   AutoLock(m_pLock);
    
    DbgLog((
        LOG_TRACE,
        2,
        TEXT("%s(%s)::SuggestAllocatorProperties"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName ));

    //
    // SuggestAllocatorProperties must be called prior to 
    // connecting the pins.
    //
    
    if (IsConnected()) {
        return E_UNEXPECTED;
    }

    m_SuggestedProperties = *AllocatorProperties;

    DbgLog((
        LOG_TRACE,
        2,
        TEXT("cBuffers: %d  cbBuffer: %d  cbAlign: %d  cbPrefix: %d"),
        AllocatorProperties->cBuffers, 
        AllocatorProperties->cbBuffer, 
        AllocatorProperties->cbAlign, 
        AllocatorProperties->cbPrefix ));

    return S_OK;
}


STDMETHODIMP
CKsOutputPin::GetAllocatorProperties(
    ALLOCATOR_PROPERTIES *AllocatorProperties
    )
/*++

Routine Description:
    Implement the IAMBufferNegotiation::GetAllocatorProperties method.
    Returns the properties for this allocator if this pin's allocator
    is being used.

Arguments:
    AllocatorProperties -
        Pointer to retrieve the properties.

Return Value:

    Return E_UNEXPECTED if not connected, E_FAIL if not using our
    alloctor or S_OK.

--*/
{
    CAutoLock   AutoLock(m_pLock);
    
    DbgLog((
        LOG_TRACE,
        2,
        TEXT("%s(%s)::GetAllocatorProperties"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName ));

    //
    // This call is only valid after the pin is connected and only 
    // if this pin provides the allocator.
    //         

    if (!IsConnected()) {
        return E_UNEXPECTED;
    }

    if (m_UsingThisAllocator) {
        *AllocatorProperties = m_AllocatorProperties;
    } else {
        return E_FAIL;
    }

    return S_OK;
}


STDMETHODIMP
CKsOutputPin::SetFormat(
    AM_MEDIA_TYPE* AmMediaType
    )
/*++

Routine Description:

    Implements the IAMStreamConfig::SetFormat method. Sets the format to return
    first in format enumeration, and to use in any current connection.

Arguments:

    AmMediaType -
        The new media type to return first in enumerations, and to switch to in
        any current connection. If this is NULL any current setting is removed.
        Otherwise it is not a complete media type, and may have unspecified
        elements within it that the filter must fill in.

Return Value:

    Returns NOERROR if the setting was accepted, else a memory or reconnection
    error. If the pin is not in a Stop state, return VFW_E_WRONG_STATE.

--*/
{
    AM_MEDIA_TYPE* CompleteAmMediaType;

    //
    // The pin must be stopped, since this may involve reconnection.
    //
    if (!IsStopped()) {
        return VFW_E_WRONG_STATE;
    }
    //
    // Determine if this media type is at all acceptable to the filter before
    // trying to change formats.
    //
    if (AmMediaType) {
        HRESULT     hr;

        //
        // This may be a partial media type, so try to have the filter
        // complete it. This will create a new private media type to
        // use, which must be deleted if SetFormat fails before assigning
        // it to m_ConfigAmMediaType.
        //
        hr = CompletePartialMediaType(
            static_cast<CMediaType*>(AmMediaType),
            &CompleteAmMediaType);
        if (FAILED(hr)) {
            return hr;
        }
        hr = CheckMediaType(static_cast<CMediaType*>(CompleteAmMediaType));
        if (FAILED(hr)) {
            DeleteMediaType(CompleteAmMediaType);
            return hr;
        }
        if (IsConnected()) {
            //
            // This guarantees nothing, but makes it more likely
            // that a reconnection will succeed.
            //
            if (GetConnected()->QueryAccept(CompleteAmMediaType) != S_OK) {
                DeleteMediaType(CompleteAmMediaType);
                return VFW_E_INVALIDMEDIATYPE;
            }
        }
    } else {
        CompleteAmMediaType = NULL;
    }
    //
    // Delete any previous setting. This does not affect the current connection.
    //
    if (m_ConfigAmMediaType) {
        DeleteMediaType(m_ConfigAmMediaType);
        m_ConfigAmMediaType = NULL;
    }
    //
    // This call may be just removing any current setting, rather than actually
    // applying a new setting.
    //
    if (CompleteAmMediaType) {
        m_ConfigAmMediaType = CompleteAmMediaType;
        //
        // A connected pin must reconnect with this new media type. Since
        // this media type is now the only one returned from GetMediaType,
        // it will be used in a reconnection.
        //
        if (IsConnected()) {
            return m_pFilter->GetFilterGraph()->Reconnect(static_cast<IPin*>(this));
        }
    }
    return NOERROR;
}


STDMETHODIMP
CKsOutputPin::GetFormat(
    AM_MEDIA_TYPE** AmMediaType
    )
/*++

Routine Description:

    Implements the IAMStreamConfig::GetFormat method. Returns any current
    format setting previously applied with IAMStreamConfig::SetFormat. If
    no format has been applied, the current format is returned if the pin
    is connected, else the first format in the list is returned.

Arguments:

    AmMediaType -
        The place in which to put any current format setting. This must be
        deleted with DeleteMediaType.

Return Value:

    Returns NOERROR if a format could be returned, else a memory error, or
    device error.

--*/
{
    HRESULT hr;

    *AmMediaType = reinterpret_cast<AM_MEDIA_TYPE*>(CoTaskMemAlloc(sizeof(**AmMediaType)));
    if (!*AmMediaType) {
        return E_OUTOFMEMORY;
    }
    ZeroMemory(reinterpret_cast<PVOID>(*AmMediaType), sizeof(**AmMediaType));
    //
    // If the pin is connected, then return the current format. Presumably
    // if SetFormat had previously been used, this should match that format.
    //
    if (IsConnected()) {
        //
        // The copy does not return an out of memory error.
        //
        CopyMediaType(*AmMediaType, &m_mt);
        if (m_mt.cbFormat && !(*AmMediaType)->cbFormat) {
            hr = E_OUTOFMEMORY;
        } else {
            hr = NOERROR;
        }
    } else {
        //
        // Else get the first format enumerated. If SetFormat has been
        // called, this will return that format, else the first one
        // provided by the driver will be returned.
        //
        hr = GetMediaType(0, static_cast<CMediaType*>(*AmMediaType));
    }
    if (FAILED(hr)) {
        DeleteMediaType(*AmMediaType);
    }
    return hr;
}


STDMETHODIMP
CKsOutputPin::GetNumberOfCapabilities(
    int* Count,
    int* Size
    )
/*++

Routine Description:

    Implements the IAMStreamConfig::GetNumberOfCapabilities method. Returns
    the number of range structures which may be queried from GetStreamCaps.
    Also returns what is supposed to be the size of each range structure,
    except that since each one may be different, returns instead a large
    number.

Arguments:

    Count -
        The place in which to put the number of data ranges available.

    Size -
        The place in which to put a large number.

Return Value:

    Returns NOERROR if the count of ranges was returned.

--*/
{
    //
    // Too much work to figure out a maximum size, then convert
    // to AM range structures, so just return a large number.
    // This interface can only handle two specific media types
    // with very specific specifiers, so return the largest possible
    // range structure amongst the two.
    //
    *Size = max(sizeof(VIDEO_STREAM_CONFIG_CAPS), sizeof(AUDIO_STREAM_CONFIG_CAPS));
    return ::KsGetMediaTypeCount(
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        (ULONG*)Count);
}


STDMETHODIMP
CKsOutputPin::GetStreamCaps(
    int Index,
    AM_MEDIA_TYPE** AmMediaType,
    BYTE* MediaRange
    )
/*++

Routine Description:

    Implements the IAMStreamConfig::GetStreamCaps method. Returns a default
    media type and data range. The possible ranges can be queried from
    GetNumberOfCapabilities.

Arguments:

    Index -
        The zero-based index of the media range to return.

    AmMediaType -
        The place in which to put a default media type. This must be deleted
        with DeleteMediaType.

    MediaRange -
        The place in which to copy the media range. This must be large
        enough to hold one of the two data types supported.

Return Value:

    Returns NOERROR if the range was returned, else S_FALSE if the index
    was out of range, or some allocation error.

--*/
{
    HRESULT         hr;
    ULONG           MediaCount;

    //
    // Verify that the index is in range.
    //
    hr = ::KsGetMediaTypeCount(
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        &MediaCount);
    if (FAILED(hr)) {
        return hr;
    }
    if ((ULONG)Index >= MediaCount) {
        return S_FALSE;
    }
    //
    // Allocate the media type and initialize it so that it can safely
    // be handed to the CMediaType methods.
    //
    *AmMediaType = reinterpret_cast<AM_MEDIA_TYPE*>(CoTaskMemAlloc(sizeof(**AmMediaType)));
    if (!*AmMediaType) {
        return E_OUTOFMEMORY;
    }
    ZeroMemory(*AmMediaType, sizeof(**AmMediaType));
    //
    // Retrieve the specified media type directly, rather than through
    // the GetMediaType method, since that method would return the configured
    // media type for index zero.
    //
    hr = ::KsGetMediaType(
        Index,
        *AmMediaType,
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId);
    if (SUCCEEDED(hr)) {
        PKSMULTIPLE_ITEM    MultipleItem;

        //
        // Retrieve all the media ranges again so that the range data for
        // the particular index can be returned.
        //
        if (FAILED(KsGetMultiplePinFactoryItems(
            static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
            m_PinFactoryId,
            KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
            reinterpret_cast<PVOID*>(&MultipleItem)))) {
            hr = KsGetMultiplePinFactoryItems(
                static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
                m_PinFactoryId,
                KSPROPERTY_PIN_DATARANGES,
                reinterpret_cast<PVOID*>(&MultipleItem));
        }
        if (SUCCEEDED(hr)) {
            PKSDATARANGE        DataRange;

            DataRange = reinterpret_cast<PKSDATARANGE>(MultipleItem + 1);
            //
            // Increment to the correct data range element.
            //
            for (; Index--; ) {
                //
                // If a data range has attributes, advance twice, reducing the
                // current count.
                //
                if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
                    Index--;
                    DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
                }
                DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            }
            //
            // Begin EVIL EVIL EVIL EVIL EVIL EVIL EVIL EVIL EVIL EVIL EVIL EVIL!!!!
            //
            // For some reason people can't figure out how to develop a single
            // product as if they actually worked at the same company. So AM
            // has a set of data range formats for Video and Audio, which of
            // course differ from the kernel structures.
            //
            if (((*AmMediaType)->majortype == MEDIATYPE_Video) &&
                (((*AmMediaType)->formattype == KSDATAFORMAT_SPECIFIER_VIDEOINFO) ||
                ((*AmMediaType)->formattype == KSDATAFORMAT_SPECIFIER_VIDEOINFO2) ||
                ((*AmMediaType)->formattype == KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO) ||
                ((*AmMediaType)->formattype == KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO))) {
                PKS_DATARANGE_VIDEO         VideoRange;
                VIDEO_STREAM_CONFIG_CAPS*   VideoConfig;

                //
                // Only the video config structure information is returned.
                // The assumption below is that a KS_DATARANGE_VIDEO2 is
                // almost the same as a KS_DATARANGE_VIDEO.
                //
                ASSERT(FIELD_OFFSET(KS_DATARANGE_VIDEO, ConfigCaps) == FIELD_OFFSET(KS_DATARANGE_VIDEO2, ConfigCaps));
                ASSERT(FIELD_OFFSET(KS_DATARANGE_VIDEO, ConfigCaps) == FIELD_OFFSET(KS_DATARANGE_MPEG2_VIDEO, ConfigCaps));
                VideoRange = reinterpret_cast<PKS_DATARANGE_VIDEO>(DataRange);
                VideoConfig = reinterpret_cast<VIDEO_STREAM_CONFIG_CAPS*>(MediaRange);
                *VideoConfig = *reinterpret_cast<VIDEO_STREAM_CONFIG_CAPS*>(&VideoRange->ConfigCaps);
            } else if (((*AmMediaType)->majortype == MEDIATYPE_Audio) &&
                ((*AmMediaType)->formattype == KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)) {
                PKSDATARANGE_AUDIO          AudioRange;
                AUDIO_STREAM_CONFIG_CAPS*   AudioConfig;

                //
                // Some of the numbers need to be made up.
                //
                AudioRange = reinterpret_cast<PKSDATARANGE_AUDIO>(DataRange);
                AudioConfig = reinterpret_cast<AUDIO_STREAM_CONFIG_CAPS*>(MediaRange);
                AudioConfig->guid = MEDIATYPE_Audio;
                AudioConfig->MinimumChannels = 1;
                AudioConfig->MaximumChannels = AudioRange->MaximumChannels;
                AudioConfig->ChannelsGranularity = 1;
                AudioConfig->MinimumBitsPerSample = AudioRange->MinimumBitsPerSample;
                AudioConfig->MaximumBitsPerSample = AudioRange->MaximumBitsPerSample;
                AudioConfig->BitsPerSampleGranularity = 1;
                AudioConfig->MinimumSampleFrequency = AudioRange->MinimumSampleFrequency;
                AudioConfig->MaximumSampleFrequency = AudioRange->MaximumSampleFrequency;
                AudioConfig->SampleFrequencyGranularity = 1;
            } else {
                //
                // The interface can't really support data ranges anyway,
                // so just return the media type and a range prefixed with a
                // GUID_NULL. A GUID_NULL means that there is no following
                // range information, just the initial data format.
                //
                *reinterpret_cast<GUID *>(MediaRange) = GUID_NULL;
            }
            //
            // End EVIL EVIL EVIL EVIL EVIL EVIL EVIL EVIL EVIL EVIL EVIL EVIL!!!!
            //
            CoTaskMemFree(MultipleItem);
        }
    }
    if (FAILED(hr)) {
        DeleteMediaType(*AmMediaType);
    }
    return hr;
}


STDMETHODIMP
CKsOutputPin::KsProperty(
    IN PKSPROPERTY Property,
    IN ULONG PropertyLength,
    IN OUT LPVOID PropertyData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsProperty method. This is used to query and
    manipulate property sets on an object. It can perform a Get, Set, and
    various Support queries.

Arguments:

    Property -
        Contains the property set identification for the query.

    PropertyLength -
        Contains the length of the Property parameter. Normally this is
        the size of the KSPROPERTY structure.

    PropertyData -
        Contains either the data to apply to a property on a Set, the
        place in which to return the current property data on a Get, or the
        place in which to return property set information on a Support
        query.

    DataLength -
        Contains the size of the PropertyData buffer.

    BytesReturned -
        On a Get or Support query, returns the number of bytes actually
        used in the PropertyData buffer. This is not used on a Set, and
        is returned as zero.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    return ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_PROPERTY,
        Property,
        PropertyLength,
        PropertyData,
        DataLength,
        BytesReturned);
}


STDMETHODIMP
CKsOutputPin::KsMethod(
    IN PKSMETHOD Method,
    IN ULONG MethodLength,
    IN OUT LPVOID MethodData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsMethod method. This is used to query and
    manipulate method sets on an object. It can perform an Execute and
    various Support queries.

Arguments:

    Method -
        Contains the method set identification for the query.

    MethodLength -
        Contains the length of the Method parameter. Normally this is
        the size of the KSMETHOD structure.

    MethodData -
        Contains either the IN and OUT parameters to the method, or the
        place in which to return method set information on a Support
        query.

    DataLength -
        Contains the size of the MethodData buffer.

    BytesReturned -
        Returns the number of bytes actually used in the MethodData buffer.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    return ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_METHOD,
        Method,
        MethodLength,
        MethodData,
        DataLength,
        BytesReturned);
}


STDMETHODIMP
CKsOutputPin::KsEvent(
    IN PKSEVENT Event OPTIONAL,
    IN ULONG EventLength,
    IN OUT LPVOID EventData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsEvent method. This is used to set and
    query events sets on an object. It can perform an Enable, Disable and
    various Support queries.

Arguments:

    Event -
        Contains the event set identification for the enable, disable, or
        query. To disable an event, this parameter must be set to NULL, and
        EventLength set to zero. The EventData must be passed the original
        KSEVENTDATA pointer.

    EventLength -
        Contains the length of the Event parameter. Normally this is
        the size of the KSEVENT structure for an Enable. This would be set
        to zero for a Disable.

    EventData -
        Contains either the KSEVENTDATA to apply to a event on an Enable,
        or the place in which to return event set information on a Support
        query.

    DataLength -
        Contains the size of the EventData buffer. For an Enable or Disable
        this would normally be the size of a KSEVENTDATA, structure plus
        event specific data.

    BytesReturned -
        On a Support query, returns the number of bytes actually used in
        the EventData buffer. This is not used on an Enable or Disable, and
        is returned as zero.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    //
    // If an event structure is present, this must either be an Enable or
    // or a Support query.
    //
    if (EventLength) {
        return ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_ENABLE_EVENT,
            Event,
            EventLength,
            EventData,
            DataLength,
            BytesReturned);
    }
    //
    // Otherwise this must be a Disable.
    //
    return ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_DISABLE_EVENT,
        EventData,
        DataLength,
        NULL,
        0,
        BytesReturned);
}


STDMETHODIMP
CKsOutputPin::KsGetPinFramingCache(
    PKSALLOCATOR_FRAMING_EX* FramingEx,
    PFRAMING_PROP FramingProp,
    FRAMING_CACHE_OPS Option
    )
/*++

Routine Description:

    Implement the IKsPinPipe::KsGetPinFramingCache method. This is used to
    retrieve the extended framing for this pin.

Arguments:

    FramingEx -
        The buffer in which to return the extended framing requested.

    FramingProp -
        The buffer in which to return state of the framing requirements
        structure.

    Option -
        Indicates which extended framing to return. This is one of
        Framing_Cache_ReadOrig, Framing_Cache_ReadLast, or
        Framing_Cache_Write.

Return Value:

    Returns S_OK.

--*/
{
    ASSERT( Option >= Framing_Cache_ReadLast);
    ASSERT( Option <= Framing_Cache_Write );
    if ((Option < Framing_Cache_ReadLast) || (Option > Framing_Cache_Write)) {
        return E_INVALIDARG;
    }
    *FramingEx = m_AllocatorFramingEx[Option - 1];
    *FramingProp = m_FramingProp[Option - 1];
    return S_OK;
}


STDMETHODIMP
CKsOutputPin::KsSetPinFramingCache(
    PKSALLOCATOR_FRAMING_EX FramingEx,
    PFRAMING_PROP FramingProp,
    FRAMING_CACHE_OPS Option
)
/*++

Routine Description:

    Implement the IKsPinPipe::KsSetPinFramingCache method. This is used to
    set the extended framing for this pin.

Arguments:

    FramingEx -
        Contains the new extended framing to set.

    FramingProp -
        Contains the new state to set on the extended framing type passed.

    Option -
        Indicates which extended framing to set. This is one of
        Framing_Cache_ReadOrig, Framing_Cache_ReadLast, or
        Framing_Cache_Write.

Return Value:

    Returns S_OK.

--*/
{
    //
    // The same pointer may be used for multiple items, so ensure that it
    // is not being used elsewhere before deleting it.
    //
    if (m_AllocatorFramingEx[Option - 1]) {
        ULONG PointerUseCount = 0;
        for (ULONG Options = 0; Options < SIZEOF_ARRAY(m_AllocatorFramingEx); Options++) {
            if (m_AllocatorFramingEx[Options] == m_AllocatorFramingEx[Option - 1]) {
                PointerUseCount++;
            }
        }
        //
        // This pointer is only used once, so it can be deleted. This
        // assumes that no client has acquired the pointer which is about
        // to be deleted.
        //
        if (PointerUseCount == 1) {
            delete m_AllocatorFramingEx[Option - 1];
        }
    }
    m_AllocatorFramingEx[Option - 1] = FramingEx;
    m_FramingProp[Option - 1] = *FramingProp;
    return S_OK;
}


STDMETHODIMP_(IKsAllocatorEx*)
CKsOutputPin::KsGetPipe(
    KSPEEKOPERATION Operation
    )
/*++

Routine Description:
    Returns the assigned KS allocator for this pin and optionally
    AddRef()'s the interface.

Arguments:
    Operation -
        If KsPeekOperation_AddRef is specified, the m_pKsAllocator is
        AddRef()'d (if not NULL) before returning.

Return Value:
    The value of m_pAllocator

--*/
{
    if ((Operation == KsPeekOperation_AddRef) && (m_pKsAllocator)) {
        m_pKsAllocator->AddRef();
    }
    return m_pKsAllocator;
}


STDMETHODIMP
CKsOutputPin::KsSetPipe(
    IKsAllocatorEx *KsAllocator
    )

/*++

Routine Description:
    Borrowed from CTransInPlaceOutputPin.

Arguments:
    None.

Return Value:
    S_OK or an appropriate failure code.

--*/

{
    DbgLog(( 
        LOG_CUSTOM1, 
        1, 
        TEXT("PIPES ATTN %s(%s)::KsSetPipe , m_pKsAllocator == 0x%08X, KsAllocator == 0x%08x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        m_pKsAllocator,
        KsAllocator ));

    if (NULL != KsAllocator) {
        KsAllocator->AddRef();
    }
    SAFERELEASE( m_pKsAllocator );
    m_pKsAllocator = KsAllocator;
    return (S_OK);
}    


STDMETHODIMP
CKsOutputPin::KsSetPipeAllocatorFlag(
    ULONG Flag
    )
{
    m_fPipeAllocator = Flag;
    return (S_OK);
}


STDMETHODIMP_(ULONG)
CKsOutputPin::KsGetPipeAllocatorFlag(
    )
{
    return m_fPipeAllocator;
}


STDMETHODIMP_(PWCHAR)
CKsOutputPin::KsGetPinName(
    )
{
    return m_pName;
}


STDMETHODIMP_(PWCHAR)
CKsOutputPin::KsGetFilterName(
    )
{
    return (static_cast<CKsProxy*>(m_pFilter)->GetFilterName() );
}


STDMETHODIMP_(GUID)
CKsOutputPin::KsGetPinBusCache(
    )
{
    //
    // When we read the Pin bus cache for the first time,
    // we set the cache. 
    //
    if (! m_PinBusCacheInit) {
        ::GetBusForKsPin(static_cast<IKsPin*>(this), &m_BusOrig);
        m_PinBusCacheInit = TRUE;
    }

    return m_BusOrig;
}


STDMETHODIMP
CKsOutputPin::KsSetPinBusCache(
    GUID Bus
    )
{
    m_BusOrig = Bus;
    return (S_OK);
}


STDMETHODIMP
CKsOutputPin::KsAddAggregate(
    IN REFGUID Aggregate
    )
/*++

Routine Description:

    Implement the IKsAggregateControl::KsAddAggregate method. This is used to
    load a COM server with zero or more interfaces to aggregate on the object.

Arguments:

    Aggregate -
        Contains the Aggregate reference to translate into a COM server which
        is to be aggregated on the object.

Return Value:

    Returns S_OK if the Aggregate was added.

--*/
{
    return ::AddAggregate(&m_MarshalerList, static_cast<IKsPin*>(this), Aggregate);
}


STDMETHODIMP
CKsOutputPin::KsRemoveAggregate(
    IN REFGUID Aggregate
    )
/*++

Routine Description:

    Implement the IKsAggregateControl::KsRemoveAggregate method. This is used to
    unload a previously loaded COM server which is aggregating interfaces.

Arguments:

    Aggregate -
        Contains the Aggregate reference to look up and unload.

Return Value:

    Returns S_OK if the Aggregate was removed.

--*/
{
    return ::RemoveAggregate(&m_MarshalerList, Aggregate);
}


VOID
CKsOutputPin::OutputPinBufferHandler( ASYNC_ITEM_STATUS status, PASYNC_ITEM pItem )
{
    PBUFFER_CONTEXT pCtxt = (PBUFFER_CONTEXT) pItem->context;
    
    pCtxt->streamSegment->KsInterfaceHandler->KsCompleteIo( pCtxt->streamSegment );
    CloseHandle( pItem->event );
    delete pCtxt;
    delete pItem;
}

VOID
CKsOutputPin::EOSEventHandler( ASYNC_ITEM_STATUS status, PASYNC_ITEM pItem )
{
    if (EVENT_SIGNALLED == status) {
        ((CKsOutputPin *) pItem->context)->CBaseOutputPin::DeliverEndOfStream();
        // Reset the event
        ((CKsOutputPin *) pItem->context)->m_pAsyncItemHandler->QueueAsyncItem( pItem );
    }
    else {
        CloseHandle( pItem->event );
        delete pItem;
    }
}

VOID
CKsOutputPin::MarshalRoutine( ASYNC_ITEM_STATUS status, PASYNC_ITEM pItem )
{
    CKsOutputPin *pThis = reinterpret_cast<CKsOutputPin *> (pItem->context);

    if (EVENT_SIGNALLED == status) {
        //
        // The return code gets notified to the graph in QueueBuffersToDevice
        // via a KsNotifyError code.
        //
        HRESULT hr = pThis -> QueueBuffersToDevice ();

    } else {
        CloseHandle( pItem->event );
        delete pItem;
    }

}

VOID
CKsOutputPin::SynchronizeFlushRoutine( 
    IN ASYNC_ITEM_STATUS status, 
    IN PASYNC_ITEM pItem 
    )

/*++

Routine Description:

    Synchronize end flush.  What can happen is that buffers which were 
    signaled prior to the kernel filter receiving IOCTL_KS_RESET_STATE can
    still be sitting around waiting to be picked up by the I/O thread.  The
    I/O thread is asynchronous with respect to the flush.  It may be the case
    that the I/O thread does not finish picking up these buffers by the time
    EndFlush comes along.  If that's the case, we must wait in DeliverEndFlush
    before we send to flush downstream.  Otherwise, we risk getting a bad
    sample downstream.

    Since the wait cannot be easily satisfied, this routine is used to
    simply complete any signaled buffers and unblock the flush thread.


Arguments:

    status -

        Informs us whether our event was signalled or is to be closed.

    pItem -
        
        The async item queued for the flush synchronize notification

Return Value:

    None

--*/

{

    CKsOutputPin *pThis = reinterpret_cast<CKsOutputPin *> (pItem->context);

    POSITION pos = pThis->m_IoQueue.GetHeadPosition();
    POSITION top = pos;
    PASYNC_ITEM Item, Head = NULL;

    //
    // If we were cancelled (due to async shutdown), clean up.
    //
    if (status != EVENT_SIGNALLED) {
        CloseHandle (pItem->event);
        delete pItem;
        return;
    }

    //
    // This is as opposed to having a separate event.  This routine is called
    // twice.  The first signal indicates a synchronize attempt.  The second
    // indicates synchronization is complete and the original thread can
    // be unblocked.
    //
    if (pThis->m_FlushMode == FLUSH_SIGNAL) {
        SetEvent (pThis->m_hFlushCompleteEvent);
        pThis->m_FlushMode = FLUSH_NONE;
    } else {

        ASSERT (pThis->m_FlushMode == FLUSH_NONE);

        //
        // Ordering of the I/O queue is ignored when this flag is set.  This
        // allows us to synchronize correctly if a flush comes in when some
        // kernel filter has completed buffers out of order.
        //
        pThis->m_FlushMode = FLUSH_SYNCHRONIZE;

        while (pos) {

            Item = pThis->m_IoQueue.Get (pos);
    
            //
            // These events should be manual resets.  Checking their state
            // via a 0 wait is safe.
            //
            if (WaitForSingleObjectEx (Item->event, 0, FALSE) == 
                WAIT_OBJECT_0) {
    
                //
                // The head of the queue is in the I/O thread and must be dealt
                // with specially instead of simply throwing it out.
                //
                if (pos != top) {
    
                    POSITION curpos = pos;
                    pos = pThis->m_IoQueue.Next (pos);
                    pThis->m_IoQueue.Remove (curpos);
    
                    CKsOutputPin::OutputPinBufferHandler (
                        EVENT_SIGNALLED,
                        Item
                        );
    
                } else {

                    //
                    // Save the head position for later (after we've dealt
                    // with everything else)
                    //
                    Head = Item;
                    pos = pThis->m_IoQueue.Next (pos);

                }
            
            } else {

                //
                // If the head is in a non-signaled state, we can signal
                // completion once we're done in the loop.
                //
                pos = pThis->m_IoQueue.Next (pos);

            }

        }

        //
        // If the head was signaled, we have to deal with it separately, since
        // it happens to be in the async handler.  We can't just rip it out.
        //
        if (Head) {

            //
            // Since the removal has precedence over us getting called back
            // from our event signal, the async handler will remove the item
            // and then call us back.
            //
            pThis->m_IoQueue.Remove (top);
            pThis->m_FlushMode = FLUSH_SIGNAL;
            pThis->m_pAsyncItemHandler->RemoveAsyncItem (
                Head->event
                );
            SetEvent(pThis->m_hFlushEvent);

        } else {
            
            //
            // If the head was not signaled, we're safe to signal completion.
            // All buffers that needed to be flushed were flushed.  EndFlush
            // is safe to go downstream.
            //
            SetEvent(pThis->m_hFlushCompleteEvent);
            pThis->m_FlushMode = FLUSH_NONE; 

        }

    }

}


STDMETHODIMP
CKsOutputPin::NotifyRelease(
    )
/*++

Routine Description:

    Implement the IKsProxyMediaNotify/IMemAllocatorNotify::NotifyRelease method.
    This is used to notify when a sample has been released by the downstream
    filter, which may differ from when it returns from the Receive() call,
    whether or not it declares itself to block. This is to handle the situation
    of a downstream filter holding onto samples, and releasing them asynchronous
    from the actual Receive call.

Arguments:

    None

Return Value:

    Returns S_OK.

--*/

{
    if (!IsStopped()) {
        //
        // Do **NOT** queue buffers at this point.  We do not want to call
        // GetBuffer in the context of this thread.  Instead, wake up the I/O
        // thread and tell it to queue buffers into the kernel.
        //
        SetEvent (m_hMarshalEvent);

    }

    return S_OK;

}


HRESULT
CKsOutputPin::InitializeAsyncThread (
    )

/*++

Routine Description:

    Initialize the Async handler thread.  Create an event for marshaller
    notification and place it in the list.

Arguments:

    None

Return Value:

    S_OK or appropriate error.

--*/

{

    HRESULT hr = S_OK;

    PASYNC_ITEM pMarshalItem = new ASYNC_ITEM;
    PASYNC_ITEM pFlushItem = new ASYNC_ITEM;
    DWORD Status = 0;
    m_pAsyncItemHandler = new CAsyncItemHandler (&Status);

    //
    // If we failed to create the async item handler successfully, return
    // error.
    //
    if (Status != 0) {
        delete m_pAsyncItemHandler;
        delete pMarshalItem;
        delete pFlushItem;
        m_pAsyncItemHandler = NULL;
        return HRESULT_FROM_WIN32 (Status);
    }

    //
    // Create the marshaler event.  This is an auto-reset event used to notify
    // the I/O thread to wake up and marshal buffers into the kernel. 
    //
    m_hMarshalEvent = CreateEvent( 
        NULL,
        FALSE,
        FALSE,
        NULL 
        );

    //
    // Create the flush event.  This is an auto-reset event used to notify
    // the I/O thread that it needs to synchronize the kernel buffers with
    // a subsequent delivery of EndFlush to the downstream pin.
    //
    m_hFlushEvent = CreateEvent(
        NULL,
        FALSE,
        FALSE,
        NULL
        );

    //
    // Create the flush complete event.  This is used by the I/O thread to
    // unblock an end flush attempt such that it synchronizes kernel buffers
    // with the delivery of end flush downstream.
    //
    m_hFlushCompleteEvent = CreateEvent (
        NULL,
        FALSE,
        FALSE,
        NULL
        );

    //
    // If we didn't get any required resource, return E_OUTOFMEMORY and 
    // clean everything up.
    //
    if (NULL == m_pAsyncItemHandler || 
        NULL == pMarshalItem || NULL == pFlushItem ||
        NULL == m_hMarshalEvent || 
        NULL == m_hFlushEvent || NULL == m_hFlushCompleteEvent) {

        hr = E_OUTOFMEMORY;
        delete pMarshalItem;
        delete pFlushItem;
        delete m_pAsyncItemHandler;
        m_pAsyncItemHandler = NULL;

        if (m_hMarshalEvent) {
            CloseHandle (m_hMarshalEvent);
            m_hMarshalEvent = NULL;
        }
        if (m_hFlushEvent) {
            CloseHandle (m_hFlushEvent);
            m_hFlushEvent = NULL;
        }
        if (m_hFlushCompleteEvent) {
            CloseHandle (m_hFlushCompleteEvent);
            m_hFlushCompleteEvent = NULL;
        }

    } else {
        //
        // Initialize the async items for flush synchronize and marshaler
        // notification and queue them in the async handler thread.
        //
        InitializeAsyncItem (
            pFlushItem, 
            FALSE, 
            m_hFlushEvent, 
            (PASYNC_ITEM_ROUTINE)SynchronizeFlushRoutine, 
            (PVOID) this 
            );
    
        InitializeAsyncItem ( 
            pMarshalItem, 
            FALSE, 
            m_hMarshalEvent, 
            (PASYNC_ITEM_ROUTINE)MarshalRoutine, 
            (PVOID) this 
            );

        m_pAsyncItemHandler->QueueAsyncItem (pFlushItem);
        m_pAsyncItemHandler->QueueAsyncItem (pMarshalItem);
    }

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksolay\example.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       example.c
//
//--------------------------------------------------------------------------


DEFINE_KSPROPERTY_TABLE(OverlayUpdateProperties) {
    DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_INTERESTS(OverlayUpdateInterests),
    DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_PALETTE(OverlayUpdatePalette),
    DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORKEY(OverlayUpdateColorKey),
    DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_CLIPLIST(OverlayUpdateClipList),
    DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_VIDEOPOSITION(OverlayUpdateVideoPosition)
};

DEFINE_KSPROPERTY_SET_TABLE(PropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_OverlayUpdate,
        SIZEOF_ARRAY(OverlayUpdateProperties),
        OverlayUpdateProperties,
        0,
        NULL)
};


NTSTATUS
OverlayUpdateInterests(
    IN PIRP Irp,
    OUT PULONG Interests
    )
/*++

Routine Description:

    Returns the update interests this driver has.

Arguments:

    Irp -
        Property Irp.

    Interests -
        The place in which to return the interests flags.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    //
    // This driver is interested in all types of updates, so set all the
    // flags.
    //
    *Interests =
        (KSPROPERTY_OVERLAYUPDATE_PALETTE |
        KSPROPERTY_OVERLAYUPDATE_COLORKEY |
        KSPROPERTY_OVERLAYUPDATE_CLIPLIST |
        KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION);
    Irp->IoStatus.Information = sizeof(*Interests);
    return STATUS_SUCCESS;
}


NTSTATUS
OverlayUpdatePalette(
    IN PIRP Irp,
    IN PALETTEENTRY* Palette
    )
/*++

Routine Description:

    Receives notifications of palette changes.

Arguments:

    Irp -
        Property Irp.

    Palette -
        Contains the new palette entries.

Return Values:

    Returns STATUS_SUCCESS, else STATUS_INVALID_BUFFER_SIZE.

--*/
{
    //
    // Validate that the property parameter length is acceptable.
    //
    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength % sizeof(*Palette)) {
        return STATUS_INVALID_BUFFER_SIZE;
    }
    //
    // Deal with the new palette.
    //
    return STATUS_SUCCESS;
}


NTSTATUS
OverlayUpdateColorKey(
    IN PIRP Irp,
    IN COLORKEY* ColorKey
    )
/*++

Routine Description:

    Receives notifications of color key changes.

Arguments:

    Irp -
        Property Irp.

    ColorKey -
        Contains the new color key.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    //
    // Deal with the new color key.
    //
    return STATUS_SUCCESS;
}


NTSTATUS
OverlayUpdateClipList(
    IN PIRP Irp,
    IN PVOID ClipInfo
    )
/*++

Routine Description:

    Receives notifications of clipping changes.

Arguments:

    Irp -
        Property Irp.

    ClipInfo -
        Contains the new source and destination rectangles, followed by the
        clipping list.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PRECT           Source;
    PRECT           Destination;
    PRGNDATAHEADER  Region;

    Source = (PRECT)ClipInfo;
    Destination = Source + 1;
    Region = (PRGNDATAHEADER)(Destination + 1);
    //
    // Deal with the new clipping list.
    //
    return STATUS_SUCCESS;
}


NTSTATUS
OverlayUpdateVideoPosition(
    IN PIRP Irp,
    IN PRECT Positions
    )
/*++

Routine Description:

    Receives notifications of video position changes.

Arguments:

    Irp -
        Property Irp.

    Positions -
        Contains the new source and destination rectangles.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PRECT           Source;
    PRECT           Destination;

    Source = Positions;
    Destination = Positions + 1;
    //
    // Deal with the new position.
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksproxy\ksinpin.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksinpin.cpp

Abstract:

    Provides a generic Active Movie wrapper for a kernel mode filter (WDM-CSA).

Author(s):

    Thomas O'Rourke (tomor) 2-Feb-1996
    George Shaw (gshaw)
    Bryan A. Woodruff (bryanw)

--*/

#include <windows.h>
#ifdef WIN9X_KS
#include <comdef.h>
#endif // WIN9X_KS
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>
#include "ksiproxy.h"


CKsInputPin::CKsInputPin(
    TCHAR*      ObjectName,
    int         PinFactoryId,
    CLSID       ClassId,
    CKsProxy*   KsProxy,
    HRESULT*    hr,
    WCHAR*      PinName
    ) :
        CBaseInputPin(
            ObjectName,
            KsProxy,
            KsProxy,
            hr,
            PinName),
        m_PinHandle(NULL),
        m_DataTypeHandler(NULL),
        m_UnkInner(NULL),
        m_InterfaceHandler(NULL),
        m_MarshalData(TRUE),
        m_PinFactoryId(PinFactoryId),
        m_PropagatingAcquire(FALSE),
        m_PendingIoCount(0),
        m_PendingIoCompletedEvent(NULL),
        m_MarshalerList(
            NAME("Marshaler list"),
            DEFAULTCACHE,
            FALSE,
            FALSE),
        m_QualitySupport(FALSE),
        m_RelativeRefCount(1),
        m_pKsAllocator( NULL ),
        m_PinBusCacheInit(FALSE),
        m_fPipeAllocator (0),
        m_DeliveryError(FALSE)
/*++

Routine Description:

    The constructor for a pin. This function is passed an error return
    parameter so that initialization errors can be passed back. It calls the
    base class implementation constructor to initialize it's data memebers.

Arguments:

    ObjectName -
        This identifies the object for debugging purposes.

    PinFactoryId -
        Contains the pin factory identifier on the kernel filter that this
        pin instance represents.

    KsProxy -
        Contains the proxy on which this pin exists.

    hr -
        The place in which to put any error return.

    PinName -
        Contains the name of the pin to present to any query.

Return Value:

    Nothing.

--*/
{
    RtlZeroMemory(m_FramingProp, sizeof(m_FramingProp));
    RtlZeroMemory(m_AllocatorFramingEx, sizeof(m_AllocatorFramingEx));
    
    if (SUCCEEDED( *hr )) {
        TCHAR       RegistryPath[64];

        DECLARE_KSDEBUG_NAME(EventName);

        BUILD_KSDEBUG_NAME(EventName, _T("EvInPendingIo#%p"), this);
        m_PendingIoCompletedEvent =
            CreateEvent( 
                NULL,       // LPSECURITY_ATTRIBUTES lpEventAttributes
                FALSE,      // BOOL bManualReset
                FALSE,      // BOOL bInitialState
                KSDEBUG_NAME(EventName) );     // LPCTSTR lpName
        ASSERT(KSDEBUG_UNIQUE_NAME());

        if (m_PendingIoCompletedEvent) {
            *hr = KsProxy->GetPinFactoryCommunication(m_PinFactoryId, &m_OriginalCommunication);
            //
            // This is always initialized so that it can be queried, and changes
            // on actual device handle creation.
            //
            m_CurrentCommunication = m_OriginalCommunication;
            //
            // This type of pin will never actually be connected to, but should
            // have a media type selected.
            //
            if (m_CurrentCommunication == KSPIN_COMMUNICATION_NONE) {
                CMediaType      MediaType;

                *hr = GetMediaType(0, &MediaType);
                if (SUCCEEDED(*hr)) {
                    SetMediaType(&MediaType);
                }
            }
            //
            // Load any extra interfaces on the proxy that have been specified in
            // this pin factory id entry.
            //
            _stprintf(RegistryPath, TEXT("PinFactory\\%u\\Interfaces"), PinFactoryId);
            ::AggregateMarshalers(
                KsProxy->QueryDeviceRegKey(),
                RegistryPath,
                &m_MarshalerList,
                static_cast<IKsPin*>(this));
        } else {
            DWORD LastError = GetLastError();
            *hr = HRESULT_FROM_WIN32( LastError );
        }
    }
}

CKsInputPin::~CKsInputPin(
    )
/*++

Routine Description:

    The destructor for the pin instance. Cleans up any outstanding resources.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    //
    // Protect against a spurious delete because of aggregation. No need to
    // use an interlocking increment, as the object is being destroyed.
    //
    if (m_PinHandle) {
        //
        // Unload any extra interfaces based on the Property/Method/Event sets
        // supported by this object.
        //
        ::UnloadVolatileInterfaces(&m_MarshalerList, TRUE);
        if (m_QualitySupport) {
            //
            // Reset this first to stop any further quality messages from
            // being acted on.
            //
            m_QualitySupport = FALSE;
            //
            // Remove previously established quality support.
            //
            ::EstablishQualitySupport(NULL, m_PinHandle, NULL);
            //
            // Ensure that the quality management forwarder flushes any
            // notifications.
            //
            static_cast<CKsProxy*>(m_pFilter)->QueryQualityForwarder()->KsFlushClient(static_cast<IKsPin*>(this));
        }
        
        //
        // Terminate any previous EOS notification that may have been started.
        //
        static_cast<CKsProxy*>(m_pFilter)->TerminateEndOfStreamNotification(
            m_PinHandle);
        ::SetSyncSource( m_PinHandle, NULL );
        CloseHandle(m_PinHandle);
    }
    if (m_PendingIoCompletedEvent) {
        CloseHandle(m_PendingIoCompletedEvent);
    }
    if (m_DataTypeHandler) {
        m_DataTypeHandler = NULL;
        SAFERELEASE( m_UnkInner );
    }
    if (m_InterfaceHandler) {
        m_InterfaceHandler->Release();
    }
    ::FreeMarshalers(&m_MarshalerList);

    SAFERELEASE( m_pKsAllocator );
    SAFERELEASE( m_pAllocator );

    for (ULONG Count = 0; Count < SIZEOF_ARRAY(m_AllocatorFramingEx); Count++) {
        if (m_AllocatorFramingEx[Count]) {
            for (ULONG Remainder = Count + 1; Remainder < SIZEOF_ARRAY(m_AllocatorFramingEx); Remainder++) {
                if (m_AllocatorFramingEx[Count] == m_AllocatorFramingEx[Remainder]) {
                    m_AllocatorFramingEx[Remainder] = NULL;
                }
            }
            delete m_AllocatorFramingEx[Count];
            m_AllocatorFramingEx[Count] = NULL;
        }
    }
}


STDMETHODIMP_(HANDLE)
CKsInputPin::KsGetObjectHandle(
    )
/*++

Routine Description:

    Implements the IKsObject::KsGetObjectHandle method. Returns the current device
    handle to the actual kernel pin this instance represents, if any such handle
    is open.

Arguments:

    None.

Return Value:

    Returns a handle, or NULL if no device handle has been opened, meaning this
    is an unconnected pin.

--*/
{
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    return m_PinHandle;
}


STDMETHODIMP
CKsInputPin::KsQueryMediums(
    PKSMULTIPLE_ITEM* MediumList
    )
/*++

Routine Description:

    Implements the IKsPin::KsQueryMediums method. Returns a list of Mediums
    which must be freed with CoTaskMemFree.

Arguments:

    MediumList -
        Points to the place in which to put the pointer to the list of
        Mediums. This must be freed with CoTaskMemFree if the function
        succeeds.

Return Value:

    Returns NOERROR if the list was retrieved, else an error.

--*/
{
    return ::KsGetMultiplePinFactoryItems(
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        KSPROPERTY_PIN_MEDIUMS,
        reinterpret_cast<PVOID*>(MediumList));
}


STDMETHODIMP
CKsInputPin::KsQueryInterfaces(
    PKSMULTIPLE_ITEM* InterfaceList
    )
/*++

Routine Description:

    Implements the IKsPin::KsQueryInterfaces method. Returns a list of
    Interfaces which must be freed with CoTaskMemFree.

Arguments:

    InterfaceList -
        Points to the place in which to put the pointer to the list of
        Interfaces. This must be freed with CoTaskMemFree if the function
        succeeds.

Return Value:

    Returns NOERROR if the list was retrieved, else an error.

--*/
{
    return ::KsGetMultiplePinFactoryItems(
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        KSPROPERTY_PIN_INTERFACES,
        reinterpret_cast<PVOID*>(InterfaceList));
}


STDMETHODIMP
CKsInputPin::KsCreateSinkPinHandle(
    KSPIN_INTERFACE&    Interface,
    KSPIN_MEDIUM&       Medium
    )
/*++

Routine Description:

    Implements the IKsPin::KsCreateSinkPinHandle method. This may be called from
    another pin in ProcessCompleteConnect, which is called from CompleteConnect.
    This allows a handle for a communications sink to always be created before a
    handle for a communications source, no matter which direction the data flow
    is going.

Arguments:

    Interface -
        Specifies the interface which has been negotiated.

    Medium -
        Specifies the medium which has been negotiated.

Return Value:

    Returns NOERROR if the handle was created, else some error.

--*/
{
    HRESULT     hr;

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // This may have already been created if this end of the connection was
    // completed first because of data flow direction. This is not an error.
    //

    //
    // This connection uses a kernel mode data transfer, by definition.
    //
    m_MarshalData = FALSE;

    if (m_PinHandle) {
        return NOERROR;
    }
    hr = ::CreatePinHandle(
        Interface,
        Medium,
        NULL,
        &m_mt,
        static_cast<CKsProxy*>(m_pFilter),
        m_PinFactoryId,
        GENERIC_WRITE,
        &m_PinHandle);
    if (SUCCEEDED(hr)) {
        //
        // Assumes the caller knows what they are doing, and assigns
        // the communications type to this pin.
        //
        m_CurrentCommunication = KSPIN_COMMUNICATION_SINK;
        //
        // Save the current interface/medium
        //
        m_CurrentInterface = Interface;
        m_CurrentMedium = Medium;
        //
        // Load any extra interfaces based on the Property/Method/Event sets
        // supported by this object.
        //
        ::AggregateSets(
            m_PinHandle,
            static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
            &m_MarshalerList,
            static_cast<IKsPin*>(this));
        //
        // Establish the user mode quality manager support.
        //
        m_QualitySupport = ::EstablishQualitySupport(static_cast<IKsPin*>(this), m_PinHandle, (CKsProxy*)m_pFilter);
    }
    return hr;
}


STDMETHODIMP
CKsInputPin::KsGetCurrentCommunication(
    KSPIN_COMMUNICATION *Communication,
    KSPIN_INTERFACE *Interface,
    KSPIN_MEDIUM *Medium
    )
/*++

Routine Description:

    Implements the IKsPin::KsGetCurrentCommunication method. Returns the
    currently selected communications method, Interface, and Medium for this
    pin. These are a subset of the possible methods available to this pin,
    and is selected when the pin handle is being created.

Arguments:

    Communication -
        Optionally points to the place in which to put the current communications.

    Interface -
        Optionally points to the place in which to put the current Interface.

    Medium -
        Optionally points to the place in which to put the current Medium.

Return Value:

    Returns NOERROR if the pin handle has been created, else VFW_E_NOT_CONNECTED.
    Always returns current communication.

--*/
{
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    if (Communication) {
        *Communication = m_CurrentCommunication;
    }
    if (Interface) {
        if (!m_PinHandle) {
            return VFW_E_NOT_CONNECTED;
        }
        *Interface = m_CurrentInterface;
    }
    if (Medium) {
        if (!m_PinHandle) {
            return VFW_E_NOT_CONNECTED;
        }
        *Medium = m_CurrentMedium;
    }
    return NOERROR;
}


STDMETHODIMP
CKsInputPin::KsPropagateAcquire(
    )
/*++

Routine Description:

    Implements the IKsPin::KsPropagateAcquire method. Directs all the pins on
    the filter to attain the Acquire state, not just this pin. This is provided
    so that a Communication Source pin can direct the sink it is connected to to
    change state before the Source does. This forces the entire filter to which
    the sink belongs to change state so that any Acquire can be further
    propagated along if needed.

Arguments:

    None.

Return Value:

    Returns NOERROR if all pins could attain the Acquire state, else
    an error.

--*/
{
    HRESULT hr;
    //
    // Access is serialized within this call.
    //
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE CKsInputPin::KsPropagateAcquire entry KsPin=%x"), static_cast<IKsPin*>(this) ));

    ::FixupPipe( static_cast<IKsPin*>(this), Pin_Input);

    hr = static_cast<CKsProxy*>(m_pFilter)->PropagateAcquire(static_cast<IKsPin*>(this), FALSE);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE CKsInputPin::KsPropagateAcquire exit KsPin=%x hr=%x"), 
            static_cast<IKsPin*>(this), hr ));

    return hr;
}   

STDMETHODIMP
CKsInputPin::ProcessCompleteConnect(
    IPin* ReceivePin
    )
/*++

Routine Description:

    Completes the processing necessary to create a device handle on the
    underlying pin factory. This is called from CompleteConnect in order
    to negotiate a compatible Communication, Interface, and Medium, then
    create the device handle. The handle may have already been created if
    this was a Communication Sink.

    This can also be called from the NonDelegatingQueryInteface method in
    order to ensure that a partially complete connection has a device
    handle before returning an interface which has been aggregated.

Arguments:

    ReceivePin -
        The pin which is to receive the other end of this connection.

Return Value:

    Returns NOERROR if the pin could complete the connection request, else
    an error.

--*/
{
    HRESULT         hr;

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // The pin handle may have been created if this is a Communication Sink.
    // This is not an error.
    //

    if (!m_PinHandle) {
        IKsPin*         KsPin;
        KSPIN_INTERFACE Interface;
        KSPIN_MEDIUM    Medium;
        HANDLE          PeerPinHandle;

        //
        // Determine if the other end of the connection is also a proxy. If so,
        // then a compatible Communication, Interface, and Medium must be
        // determined, plus the other pin handle needs to be created first if
        // this side will be a Communication Source.
        //
        if (SUCCEEDED(ReceivePin->QueryInterface(__uuidof(IKsPin), reinterpret_cast<PVOID*>(&KsPin)))) {
            //
            // The only confusion is when this end can be both a Source and a
            // Sink. Note that this does not handle the case wherein a pin can
            // also be a Bridge at the same time. That is probably an invalid
            // and confusing possibility. It is also mostly the same as a Sink.
            //
            if (m_OriginalCommunication == KSPIN_COMMUNICATION_BOTH) {
                m_CurrentCommunication = ::ChooseCommunicationMethod(static_cast<CBasePin*>(this), KsPin);
            }
            //
            // Run through the list of Interfaces and Mediums each pin supports,
            // choosing the first one that is found compatible. This in no way
            // attempts to preserve the use of Interfaces and Mediums, and
            // relies on kernel filters to present them in best order first.
            //
            if (SUCCEEDED(hr = ::FindCompatibleInterface(static_cast<IKsPin*>(this), KsPin, &Interface))) {
                hr = ::FindCompatibleMedium(static_cast<IKsPin*>(this), KsPin, &Medium);
            }
            if (SUCCEEDED(hr)) {
                if (hr == S_FALSE) {
                    //
                    // This is a usermode filter, but needs to support mediums
                    // because it wants to connect with a non-ActiveMovie
                    // medium. This should really be a kernelmode filter.
                    //
                    PeerPinHandle = NULL;
                    m_MarshalData = TRUE;
                } else {
                    //
                    // If this is a Communication Source, the Sink pin handle must
                    // be created first. Else the Sink handle is NULL (meaning that
                    // this is the Sink pin).
                    //
                    if (m_CurrentCommunication == KSPIN_COMMUNICATION_SOURCE) {
                        IKsObject*      KsObject;

                        hr = KsPin->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&KsObject));
                        if (SUCCEEDED(hr)) {
                            hr = KsPin->KsCreateSinkPinHandle(Interface, Medium);
                            PeerPinHandle = KsObject->KsGetObjectHandle();
                            KsObject->Release();
                        }
                    } else {
                        PeerPinHandle = NULL;
                    }
                    m_MarshalData = FALSE;
                }
            }
            KsPin->Release();
            if (FAILED(hr)) {
                return hr;
            }
        } else {
            //
            // If the other end of the connection is not a proxy, then this pin
            // must be a Communication Sink. It must also use the default
            // Interface and Dev I/O Medium.
            //
            m_CurrentCommunication = KSPIN_COMMUNICATION_SINK;
            if (FAILED(hr = FindCompatibleInterface(static_cast<IKsPin*>(this), NULL, &Interface))) {
                return hr;
            }
            SetDevIoMedium(static_cast<IKsPin*>(this), &Medium);
            PeerPinHandle = NULL;
        }
        hr = ::CreatePinHandle(
            Interface,
            Medium,
            PeerPinHandle,
            &m_mt,
            static_cast<CKsProxy*>(m_pFilter),
            m_PinFactoryId,
            GENERIC_WRITE,
            &m_PinHandle);
        if (SUCCEEDED(hr)) {
            //
            // Save the current interface/medium
            //
            m_CurrentInterface = Interface;
            m_CurrentMedium = Medium;
            //
            // Load any extra interfaces based on the Property/Method/Event sets
            // supported by this object.
            //
            ::AggregateSets(
                m_PinHandle,
                static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
                &m_MarshalerList,
                static_cast<IKsPin*>(this));
            //
            // Establish the user mode quality manager support.
            //
            m_QualitySupport = ::EstablishQualitySupport(static_cast<IKsPin*>(this), m_PinHandle, static_cast<CKsProxy*>(m_pFilter));
        }
    } else {
        hr = NOERROR;
    }

    //
    // Create an instance of the interface handler.
    //

    if (SUCCEEDED(hr) &&
        (NULL == m_InterfaceHandler) &&
        (m_CurrentCommunication != KSPIN_COMMUNICATION_BRIDGE)) {

        //
        // We must create an interface handler, if not, then
        // return the error.
        //

        hr =
            CoCreateInstance(
                m_CurrentInterface.Set,
                NULL,
#ifdef WIN9X_KS
                CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
                __uuidof(IKsInterfaceHandler),
                reinterpret_cast<PVOID*>(&m_InterfaceHandler));

        if (m_InterfaceHandler) {
            m_InterfaceHandler->KsSetPin( static_cast<IKsPin*>(this) );
        } else {
            DbgLog((
                LOG_TRACE,
                0,
                TEXT("%s(%s)::ProcessCompleteConnect failed to create interface handler"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName ));
        }
    }
    
    //
    // Finally, if we're marshalling data and if everything has succeeded
    // up to this point, then create the filter's I/O thread if necessary.
    //
    
    if (SUCCEEDED(hr) && m_MarshalData) {
        hr = static_cast<CKsProxy*>(m_pFilter)->StartIoThread();
    }
    if (SUCCEEDED(hr)) {
        //
        // This pin may generate EOS notifications, which must be
        // monitored so that they can be collected and used to
        // generate an EC_COMPLETE graph notification.
        //
        hr = static_cast<CKsProxy*>(m_pFilter)->InitiateEndOfStreamNotification(
            m_PinHandle);
    }
    
    return hr;
}


STDMETHODIMP
CKsInputPin::QueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    Implement the IUnknown::QueryInterface method. This just passes the query
    to the owner IUnknown object, which may pass it to the nondelegating
    method implemented on this object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE.

--*/
{
    HRESULT hr;

    hr = GetOwner()->QueryInterface(riid, ppv);
    return hr;
}


STDMETHODIMP_(ULONG)
CKsInputPin::AddRef(
    )
/*++

Routine Description:

    Implement the IUnknown::AddRef method. This just passes the AddRef
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    InterlockedIncrement((PLONG)&m_RelativeRefCount);
    return GetOwner()->AddRef();
}


STDMETHODIMP_(ULONG)
CKsInputPin::Release(
    )
/*++

Routine Description:

    Implement the IUnknown::Release method. This just passes the Release
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    ULONG   RefCount;

    RefCount = GetOwner()->Release();
    //
    // Ensure that the proxy was not just deleted before trying to
    // delete this pin.
    //
    if (RefCount && !InterlockedDecrement((PLONG)&m_RelativeRefCount)) {
        //
        // This was a connection release from a pin already destined
        // for destruction. The filter had decremented the relative
        // refcount in order to delete it, and found that there was
        // still an outstanding interface being used. So this delayed
        // deletion occurs.
        //
        delete this;
    }
    return RefCount;
}


STDMETHODIMP
CKsInputPin::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    Implement the CUnknown::NonDelegatingQueryInterface method. This
    returns interfaces supported by this object, or by the underlying
    pin class object. This includes any interface aggregated by the
    pin.

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE, or possibly some memory error.

--*/
{
    if (riid == __uuidof(ISpecifyPropertyPages)) {
        return GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv);
    } else if (riid == __uuidof(IKsObject)) {
        return GetInterface(static_cast<IKsObject*>(this), ppv);
    } else if (riid == __uuidof(IKsPin) || riid == __uuidof(IKsPinEx)) {
        return GetInterface(static_cast<IKsPinEx*>(this), ppv);
    } else if (riid == __uuidof(IKsPinPipe)) {
        return GetInterface(static_cast<IKsPinPipe*>(this), ppv);
    } else if (riid == __uuidof(IKsAggregateControl)) {
        return GetInterface(static_cast<IKsAggregateControl*>(this), ppv);
    } else if (riid == __uuidof(IKsPropertySet)) {
        //
        // In order to allow another filter to access information on the
        // underlying device handle during its CompleteConnect processing,
        // force the connection to be completed now if possible.
        //
        if (m_Connected && !m_PinHandle) {
            ProcessCompleteConnect(m_Connected);
        }
        return GetInterface(static_cast<IKsPropertySet*>(this), ppv);
    } else if (riid == __uuidof(IKsControl)) {
        if (m_Connected && !m_PinHandle) {
            ProcessCompleteConnect(m_Connected);
        }
        return GetInterface(static_cast<IKsControl*>(this), ppv);
    } else if (riid == __uuidof(IKsPinFactory)) {
        return GetInterface(static_cast<IKsPinFactory*>(this), ppv);
    } else if (riid == __uuidof(IStreamBuilder)) {
        //
        // Sink & Source pins are normally forced to be rendered, unless
        // there are already enough instances.
        //
        if ((m_CurrentCommunication & KSPIN_COMMUNICATION_BOTH) &&
            static_cast<CKsProxy*>(m_pFilter)->DetermineNecessaryInstances(m_PinFactoryId)) {
            return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
        }
        //
        // Returning this interface allows a Bridge and None pin to be
        // left alone by the graph builder.
        //
        return GetInterface(static_cast<IStreamBuilder*>(this), ppv);
    } else {
        HRESULT hr;
        
        hr = CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
        if (SUCCEEDED(hr)) {
            return hr;
        }
    }
    //
    // In order to allow another filter to access information on the
    // underlying device handle during its CompleteConnect processing,
    // force the connection to be completed now if possible. The
    // assumption is that if there is a Connected pin, but no device
    // handle yet, then this pin is part way through the connection
    // process, and should force completion in case the aggregated
    // interface wants to interact with the device. This must be done
    // before searching the list, since a volatile interface is only
    // added to the list when the the connection is completed.
    //
    if (m_Connected && !m_PinHandle) {
        ProcessCompleteConnect(m_Connected);
    }
    for (POSITION Position = m_MarshalerList.GetHeadPosition(); Position;) {
        CAggregateMarshaler*    Aggregate;

        Aggregate = m_MarshalerList.GetNext(Position);
        if ((Aggregate->m_iid == riid) || (Aggregate->m_iid == GUID_NULL)) {
            HRESULT hr;

            hr = Aggregate->m_Unknown->QueryInterface(riid, ppv);
            if (SUCCEEDED(hr)) {
                return hr;
            }
        }
    }
    return E_NOINTERFACE;
}


STDMETHODIMP
CKsInputPin::Disconnect(
    )
/*++

Routine Description:

    Override the CBaseInput::Disconnect method. This does not call the base
    class implementation. It disconnects both Source and Sink pins, in
    addition to Bridge pins, which only have handles, and not connected pin
    interfaces, which traditionally is how connection is indicated. It
    specifically does not release the connected pin, since a Bridge may not
    have a connected pin. This is always done in BreakConnect.

Arguments:

    None.

Return Value:

    Returns S_OK, or S_FALSE if the pin was not connected or VFW_E_NOT_STOPPED
    if the filter is not in a Stop state.

--*/
{
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsInputPin(%s)::Disconnect"), m_pName ));
    //
    // A disconnection can only occur if the filter is in a Stop state.
    //
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }
    //
    // A Bridge pin can be connected if it just has a device handle. It can't
    // actually report to ActiveMovie this connection, but it can still be
    // connected (with a NULL ReceivePin) and disconnected.
    //
    if (m_Connected || m_PinHandle) {
        //
        // Note that this does not release the connected pin, as that is done
        // in BreakConnect. This is because there may not be a pin in the case
        // of a Bridge.
        //
        BreakConnect();
        SAFERELEASE( m_pAllocator );
        return S_OK;
    }
    return S_FALSE;
}


STDMETHODIMP
CKsInputPin::ConnectionMediaType(
    AM_MEDIA_TYPE* AmMediaType
    )
/*++

Routine Description:

    Override the CBasePin::ConnectionMediaType method. Returns the
    current media type, if connected. The reason for overriding this
    is because IsConnected() is not a virtual function, and is used
    in the base classes to determine if a media type should be returned.

Arguments:

    AmMediaType -
        The place in which to return the media type.

Return Value:

    Returns NOERROR if the type was returned, else a memory or connection
    error.

--*/
{
    CAutoLock AutoLock(m_pLock);

    if (IsConnected()) {
        CopyMediaType(AmMediaType, &m_mt);
        return S_OK;
    }
    static_cast<CMediaType*>(AmMediaType)->InitMediaType();
    return VFW_E_NOT_CONNECTED;
}


STDMETHODIMP
CKsInputPin::Connect(
    IPin*                   ReceivePin,
    const AM_MEDIA_TYPE*    AmMediaType
    )
/*++

Routine Description:

    Override the CBaseInput::Connect method. Intercepts a connection
    request in order to perform special processing for a Bridge pin. A
    Bridge has no ReceivePin, and uses the first available Interface
    and a Dev I/O Medium. A normal connection request is just passed
    through to the base class.

Arguments:

    ReceivePin -
        Contains the pin on the other end of the proposed connection.
        This is NULL for a Bridge pin.

    AmMediaType -
        Contains the media type for the connection, else NULL if the
        media type is to be negotiated.

Return Value:

    Returns NOERROR if the connection was made, else some error.

--*/
{
#ifdef DEBUG
    PIN_INFO    pinInfo;
    ReceivePin->QueryPinInfo( &pinInfo );
    FILTER_INFO filterInfo;
    filterInfo.achName[0] = 0;
    if (pinInfo.pFilter) {
        pinInfo.pFilter->QueryFilterInfo( &filterInfo );
        if (filterInfo.pGraph) {
            filterInfo.pGraph->Release();
        }
        pinInfo.pFilter->Release();
    }
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsInputPin(%s)::Connect( %s(%s) )"), m_pName, filterInfo.achName, pinInfo.achName ));
#endif // DEBUG

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // The only reason to intercept the base class implementation is to
    // deal with a Bridge pin.
    //
    if (m_CurrentCommunication == KSPIN_COMMUNICATION_BRIDGE) {
        KSPIN_INTERFACE Interface;
        KSPIN_MEDIUM    Medium;
        HRESULT         hr;

        //
        // A Bridge pin does not have any other end to the connection.
        //
        if (ReceivePin) {
            return E_FAIL;
        }
        //
        // Normally this would check m_Connected, but since there is no
        // connection pin, it must check for a device handle.
        //
        if (m_PinHandle) {
            return VFW_E_ALREADY_CONNECTED;
        }
        if (!IsStopped()) {
            return VFW_E_NOT_STOPPED;
        }
        //
        // Find the first Interface and Medium.
        //
        if (SUCCEEDED(hr = ::FindCompatibleInterface(static_cast<IKsPin*>(this), NULL, &Interface))) {
            hr = ::FindCompatibleMedium(static_cast<IKsPin*>(this), NULL, &Medium);
        }
        if (FAILED(hr)) {
            return hr;
        }
        //
        // If there is no media type, just acquire the first one.
        //
        if (!AmMediaType) {
            CMediaType      MediaType;

            if (SUCCEEDED(hr = GetMediaType(0, &MediaType))) {
                hr = SetMediaType(&MediaType);
            }
        } else {
            hr = SetMediaType(static_cast<const CMediaType*>(AmMediaType));
        }
        if (SUCCEEDED(hr)) {
            hr = ::CreatePinHandle(
                Interface,
                Medium,
                NULL,
                &m_mt,
                static_cast<CKsProxy*>(m_pFilter),
                m_PinFactoryId,
                GENERIC_WRITE,
                &m_PinHandle);
            if (SUCCEEDED(hr)) {
                //
                // Load any extra interfaces based on the Property/Method/Event sets
                // supported by this object.
                //
                ::AggregateSets(
                    m_PinHandle,
                    static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
                    &m_MarshalerList,
                    static_cast<IKsPin*>(this));
                //
                // Establish the user mode quality manager support.
                //
                m_QualitySupport = ::EstablishQualitySupport(static_cast<IKsPin*>(this), m_PinHandle, static_cast<CKsProxy*>(m_pFilter));
                //
                // Create a new instance of this pin if necessary.
                //
                static_cast<CKsProxy*>(m_pFilter)->GeneratePinInstances();
            }
        }
        return hr;
    }
    HRESULT hr = CBasePin::Connect(ReceivePin, AmMediaType);
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsInputPin(%s)::Connect() returns 0x%p"), m_pName, hr ));
    return hr;
}


STDMETHODIMP
CKsInputPin::QueryInternalConnections(
    IPin**  PinList,
    ULONG*  PinCount
    )
/*++

Routine Description:

    Override the CBasePin::QueryInternalConnections method. Returns a list of
    pins which are related to this pin through topology.

Arguments:

    PinList -
        Contains a list of slots in which to place all pins related to this
        pin through topology. Each pin returned must be reference counted. This
        may be NULL if PinCount is zero.

    PinCount -
        Contains the number of slots available in PinList, and should be set to
        the number of slots filled or neccessary.

Return Value:

    Returns E_NOTIMPL to specify that all inputs go to all outputs and vice versa,
    S_FALSE if there is not enough slots in PinList, or NOERROR if the mapping was
    placed into PinList and PinCount adjusted.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->QueryInternalConnections(m_PinFactoryId, m_dir, PinList, PinCount);
}


HRESULT
CKsInputPin::Active(
    )
/*++

Routine Description:

    Override the CBasePin::Active method. Propagate activation to Communication
    Sinks before applying it to this pin. Also guard against re-entrancy caused
    by a cycle in a graph.

Arguments:

    None.

Return Value:

    Returns NOERROR if the transition was made, else some error.

--*/
{
    HRESULT     hr;
    CAutoLock   AutoLock(m_pLock);
#ifdef DEBUG
    if (m_PinHandle) {
        KSPROPERTY  Property;
        ULONG       BasicSupport;
        ULONG       BytesReturned;

        //
        // Ensure that if a pin supports a clock, that it also supports State changes.
        // This appears to currently be a common broken item.
        //
        Property.Set = KSPROPSETID_Stream;
        Property.Id = KSPROPERTY_STREAM_MASTERCLOCK;
        Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
        hr = ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            &BasicSupport,
            sizeof(BasicSupport),
            &BytesReturned);
        if (SUCCEEDED(hr) && (BasicSupport & KSPROPERTY_TYPE_GET)) {
            Property.Set = KSPROPSETID_Connection;
            Property.Id = KSPROPERTY_CONNECTION_STATE;
            hr = ::KsSynchronousDeviceControl(
                m_PinHandle,
                IOCTL_KS_PROPERTY,
                &Property,
                sizeof(Property),
                &BasicSupport,
                sizeof(BasicSupport),
                &BytesReturned);
            if (FAILED(hr) || !(BasicSupport & KSPROPERTY_TYPE_SET)) {
                DbgLog((
                    LOG_ERROR, 
                    0, 
                    TEXT("%s(%s)::Active - Pin supports a clock but not State"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName ));
            }
        }
    }
#endif // DBG
    //
    // If this is re-entered while it is propagating the state change, then
    // it implies a cycle in the graph, and therefore is complete. This is
    // translated as either a transition from Stop through Acquire to Pause
    // (where the filter pins may already be in an Acquire state), or Run to
    // Pause.
    //
    if (m_PropagatingAcquire) {
        return NOERROR;
    }
    m_PropagatingAcquire = TRUE;
    //
    // This event is used when inactivating the pin, and may be needed to
    // wait for outstanding I/O to be completed. It must be reset, because
    // a previous transition may not have waited on it, and it will always
    // be set when the state is Stop, and the last I/O has been completed.
    //
    // Note that the filter state has been set to Pause before the Active
    // method is called, so I/O which is started and completes will not
    // accidentally set the event again.
    //
    ResetEvent(m_PendingIoCompletedEvent);
    //
    // Change any Sink first, then pass the state change to the device handle.
    //

    //
    // No need to call the base class here, it does nothing.
    //

    hr = ::Active(static_cast<IKsPin*>(this), Pin_Input, m_PinHandle, m_CurrentCommunication,
                  m_Connected, &m_MarshalerList, static_cast<CKsProxy*>(m_pFilter) );
    
    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s(%s)::Active returning %08x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        hr ));

    m_PropagatingAcquire = FALSE;
    return hr;
}


HRESULT
CKsInputPin::Run(
    REFERENCE_TIME  tStart
    )
/*++

Routine Description:

    Override the CBasePin::Run method. This is translated as a transition
    from Pause to Run. The base classes already ensure that an Active is sent
    before a Run.

Arguments:

    None.

Return Value:

    Returns NOERROR if the transition was made, else some error.

--*/
{
    HRESULT     hr;
    CAutoLock   AutoLock(m_pLock);

    //
    // Pass the state change to the device handle.
    //
    if (SUCCEEDED(hr = ::Run(m_PinHandle, tStart, &m_MarshalerList))) {
        hr = CBasePin::Run(tStart);
    }
    return hr;
}


HRESULT
CKsInputPin::Inactive(
    )
/*++

Routine Description:

    Override the CBasePin::Inactive method. This is translated as a transition
    from Run to Stop or Pause to Stop. There does not appear to be a method of
    directly setting the state from Run to Pause though.

Arguments:

    None.

Return Value:

    Returns NOERROR if the transition was made, else some error.

--*/
{
    HRESULT     hr;

    //
    // Pass the state change to the device handle.
    //
    hr = ::Inactive(m_PinHandle, &m_MarshalerList);
    {
        //
        // If there is pending I/O, then the state transition must wait
        // for it to complete. The event is signalled when m_PendingIoCount
        // transitions to zero, and when IsStopped() is TRUE.
        //
        // Note that the filter state has been set to Stopped before the
        // Inactive method is called.
        //
        // This critical section will force synchronization with any
        // outstanding ReceiveMultiple call, such that it will have
        // looked at the filter state and exited.
        //
        m_IoCriticalSection.Lock();
        m_IoCriticalSection.Unlock();
        if (m_PendingIoCount) {
            WaitForSingleObjectEx(m_PendingIoCompletedEvent, INFINITE, FALSE);
        }
        ::UnfixupPipe(static_cast<IKsPin*>(this), Pin_Input);
        hr = CBaseInputPin::Inactive();
    }
    //
    // Reset the state of any previous delivery error.
    //
    m_DeliveryError = FALSE;
    return hr;
}


STDMETHODIMP
CKsInputPin::QueryAccept(
    const AM_MEDIA_TYPE*    AmMediaType
    )
/*++

Routine Description:

    Implement the CBasePin::QueryAccept method. Determines if the proposed
    media type is currently acceptable to the pin. If currently streaming,
    this implies that a change of media types will occur in the stream.
    Note that this function does not lock the object, as it is expected
    to be called asynchronously by a knowledgeable client at a point in
    which the connection will not be broken. If IAMStreamConfig::SetFormat
    has been used to set a specific media type, then QueryAccept will only
    accept the type set.

Arguments:

    AmMediatype -
        The media type to check.

Return Value:

    Returns S_OK if the media type can currently be accepted, else S_FALSE.

--*/
{
    //
    // If this is called before connecting pins, or the pin is stopped,
    // then just check the media type. The function definition does not
    // contain any guidance as to what to do if the pin is not connected.
    //
    if (!m_PinHandle || IsStopped()) {
        return CheckMediaType(static_cast<const CMediaType*>(AmMediaType));
    }
    return ::QueryAccept(m_PinHandle, NULL, AmMediaType);
}


STDMETHODIMP
CKsInputPin::NewSegment(
    REFERENCE_TIME  Start,
    REFERENCE_TIME  Stop,
    double          Rate
    )
/*++

Routine Description:

    Temporary function!!

--*/
{
    KSRATE_CAPABILITY   RateCapability;
    KSRATE              PossibleRate;
    ULONG               BytesReturned;
    HRESULT             hr;

    RateCapability.Property.Set = KSPROPSETID_Stream;
    RateCapability.Property.Id  = KSPROPERTY_STREAM_RATECAPABILITY;
    RateCapability.Property.Flags = KSPROPERTY_TYPE_GET;
    // supposed to be Start == 0 && Stop == -1
    if (Start > Stop) {
        RateCapability.Rate.Flags = KSRATE_NOPRESENTATIONSTART | KSRATE_NOPRESENTATIONDURATION;
    } else {
        RateCapability.Rate.Flags = 0;
        RateCapability.Rate.PresentationStart = Start;
        RateCapability.Rate.Duration = Stop - Start;
    }
    //
    // This only works for the standard streaming interface.
    //
    ASSERT(m_CurrentInterface.Set == KSINTERFACESETID_Standard);
    ASSERT(m_CurrentInterface.Id == KSINTERFACE_STANDARD_STREAMING);
    RateCapability.Rate.Interface.Set = KSINTERFACESETID_Standard;
    RateCapability.Rate.Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    //
    // + 0.5 for rounding.
    //
    RateCapability.Rate.Rate = (LONG)(Rate * 1000 + 0.5);
    RateCapability.Rate.Interface.Flags = 0;
    hr = ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_PROPERTY,
        &RateCapability,
        sizeof(RateCapability),
        &PossibleRate,
        sizeof(PossibleRate),
        &BytesReturned);
    if (SUCCEEDED(hr)) {
        ASSERT(BytesReturned == sizeof(PossibleRate));
        //
        // Some drivers do not seem to be able to return the actual data.
        //
        if (BytesReturned != sizeof(PossibleRate)) {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }
        if (PossibleRate.Rate != 1000) {
            //
            // This should also pass this downstream if != 1000. However,
            // except for topology, there is no way to determine where to
            // send the request.
            //
            DbgLog((
                LOG_TRACE,
                0,
                TEXT("%s(%s)::NewSegment: Rate change is only partially supported: %d"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName,
                PossibleRate.Rate));
        }
        RateCapability.Property.Id  = KSPROPERTY_STREAM_RATE;
        RateCapability.Property.Flags = KSPROPERTY_TYPE_SET;
        //
        // Ask only for what the filter claimed it could do.
        //
        PossibleRate.Rate = 1000 + (RateCapability.Rate.Rate - PossibleRate.Rate);
        hr = ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_PROPERTY,
            &RateCapability.Property,
            sizeof(RateCapability.Property),
            &PossibleRate,
            sizeof(PossibleRate),
            &BytesReturned);
    }
    if (hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) ||
        hr == HRESULT_FROM_WIN32( ERROR_SET_NOT_FOUND )) {
        hr = S_OK;        
    }
    return hr;
}


STDMETHODIMP
CKsInputPin::QueryId(
    LPWSTR* Id
    )
/*++

Routine Description:

    Override the CBasePin::QueryAccept method. This returns a unique identifier
    for a particular pin. This identifier is equivalent to the pin name in the
    base class implementation, but does not work if the kernel filter does not
    explicitly name pins, since multiple pins will have duplicate names, and
    graph save/load will not be able to rebuild a graph. The IBaseFilter::FindPin
    method is also implemented by the proxy to return the proper pin based on
    the same method here. This is based on the factory identifier. If multiple
    instances of a pin exist, then there will be duplicates. But new pins are
    inserted at the front of the pin list, so they will be found first, and
    graph building will still work.

Arguments:

    Id -
        The place in which to return a pointer to an allocated string containing
        the unique pin identifier.

Return Value:

    Returns NOERROR if the string was returned, else an allocation error.

--*/
{
    *Id = reinterpret_cast<WCHAR*>(CoTaskMemAlloc(8*sizeof(**Id)));
    if (*Id) {
        swprintf(*Id, L"%u", m_PinFactoryId);
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}


HRESULT
CKsInputPin::CheckMediaType(
    const CMediaType*   MediaType
    )
/*++

Routine Description:

    Implement the CBasePin::CheckMediaType method. Just uses the common method
    on the filter with the Pin Factory Identifier.

Arguments:

    Mediatype -
        The media type to check.

Return Value:

    Returns NOERROR if the media type was valid, else some error.

--*/
{
    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s(%s)::CheckMediaType"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName ));
    return static_cast<CKsProxy*>(m_pFilter)->CheckMediaType(static_cast<IPin*>(this), m_PinFactoryId, MediaType);
}

STDMETHODIMP
CKsInputPin::SetStreamMediaType(
    const CMediaType *MediaType
    )

/*++

Routine Description:
    Sets the current stream media type.  This function is used by the
    SetMediaType() method and by the Receive() method via. the 
    ReceiveMultiple() method.
    
    Loads a media type handler corresponding to the subtype or type 
    of the media and sets the current stream media type member.  

Arguments:
    const CMediaType *MediaType - pointer to a media type

Return:

--*/

{
    //
    // Set the current stream media type.  Note that initially this
    // type is the same as the pin type, however, this member will change
    // for in-stream data format changes on filters that include such 
    // support.
    //
    
    //
    // Discard any previous data type handler.
    //
    if (m_DataTypeHandler) {
        m_DataTypeHandler = NULL;
        SAFERELEASE( m_UnkInner );
    }

    ::OpenDataHandler(MediaType, static_cast<IPin*>(this), &m_DataTypeHandler, &m_UnkInner);

    return S_OK;
}


HRESULT
CKsInputPin::SetMediaType(
    const CMediaType*   MediaType
    )
/*++

Routine Description:

    Override the CBasePin::SetMediaType method. This may be set either 
    before a connection is established, to indicate the media type to use 
    in the connection, or after the connection has been established in 
    order to change the current media type (which is done after a 
    QueryAccept of the media type).

    If the connection has already been made, then the call is directed at 
    the device handle in an attempt to change the current media type. 
    This method then calls the SetStreamMediaType() method which will set 
    the  media type for the kernel pin handle (if connected) and sets the 
    data  handler.  Finally, it calls the base class to actually modify the 
    media type, which does not actually fail, unless there is no memory.
    

Arguments:

    Mediatype -
        The media type to use on the pin.

Return Value:

    Returns NOERROR if the media type was validly set, else some error. If
    there is no pin handle yet, the function will likely succeed.

--*/
{
    HRESULT  hr;
    
    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s(%s)::SetMediaType"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName ));

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // Only pass this request to the device if there is actually a connection
    // currently.
    //
    if (m_PinHandle) {
        if (FAILED(hr = ::SetMediaType(m_PinHandle, MediaType))) {
            return hr;
        }
    }

    if (FAILED( hr = SetStreamMediaType( MediaType ) )) {
        return hr;        
    } else {
        return CBasePin::SetMediaType(MediaType);
    }
}


HRESULT
CKsInputPin::CheckConnect(
    IPin* Pin
    )
/*++

Routine Description:

    Override the CBasePin::CheckConnect method. First check data flow with
    the base class, then check compatible Communication types.

Arguments:

    Pin -
        The pin which is being checked for compatibility to connect to this
        pin.

Return Value:

    Returns NOERROR if the pin in compatible, else some error.

--*/
{
    HRESULT hr;

    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s(%s)::CheckConnect"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName ));

    if (SUCCEEDED(hr = CBasePin::CheckConnect(Pin))) {
        hr = ::CheckConnect(Pin, m_CurrentCommunication);
    }
    return hr;
}


HRESULT
CKsInputPin::CompleteConnect(
    IPin* ReceivePin
    )
/*++

Routine Description:

    Override the CBasePin::Complete method. First try to create the device
    handle, which possibly tries to create a Sink handle on the receiving
    pin, then call the base class. If this all succeeds, generate a new
    unconnected pin instance if necessary.

Arguments:

    ReceivePin -
        The pin to complete connection on.

Return Value:

    Returns NOERROR if the connection was completed, else some error.

--*/
{
    HRESULT     hr;

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // Create devices handles first, then allow the base class to complete
    // the operation.
    //
    if (SUCCEEDED(hr = ProcessCompleteConnect(ReceivePin))) {
        hr = CBasePin::CompleteConnect(ReceivePin);
        if (SUCCEEDED(hr)) {
            //
            // Generate a new unconnected instance of this pin if there
            // are more possible instances available.
            //
            static_cast<CKsProxy*>(m_pFilter)->GeneratePinInstances();
        }
    }
    return hr;
}


HRESULT
CKsInputPin::BreakConnect(
    )
/*++

Routine Description:

    Override the CBasePin::BreakConnect method. Does not call the base class
    because it does not do anything. Releases any device handle. Also note that
    the connected pin is released here. This means that Disconnect must also
    be overridden in order to not release a connected pin.

Arguments:

    None.

Return Value:

    Returns NOERROR.

--*/
{
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsInputPin(%s)::BreakConnect"), m_pName ));
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // Update pipes.
    //
    
    //
    // Update the system of pipes - reflect disconnect.
    //
    BOOL    FlagBypassBaseAllocators = FALSE;

    if ( KsGetPipe(KsPeekOperation_PeekOnly) ) {
        ::DisconnectPins(static_cast<IKsPin*>(this), Pin_Input, &FlagBypassBaseAllocators);
    }
    
    // Close the device handle if it happened to be open. This is called at
    // various times, and may not have actually opened a handle yet.
    //
    if (m_PinHandle) {
        if (m_QualitySupport) {
            //
            // Reset this first to stop any further quality messages from
            // being acted on.
            //
            m_QualitySupport = FALSE;
            //
            // Remove previously established quality support.
            //
            ::EstablishQualitySupport(NULL, m_PinHandle, NULL);
            //
            // Ensure that the quality management forwarder flushes any
            // notifications.
            //
            static_cast<CKsProxy*>(m_pFilter)->QueryQualityForwarder()->KsFlushClient(static_cast<IKsPin*>(this));
        }
        //
        // Terminate any previous EOS notification that may have been started.
        //
        static_cast<CKsProxy*>(m_pFilter)->TerminateEndOfStreamNotification(
            m_PinHandle);
        ::SetSyncSource( m_PinHandle, NULL );
        CloseHandle(m_PinHandle);
        m_PinHandle = NULL;
        //
        // Mark all volatile interfaces as reset. Only Static interfaces,
        // and those Volatile interfaces found again will be set. Also
        // notify all interfaces of graph change.
        //
        ResetInterfaces(&m_MarshalerList);
    }
    m_MarshalData = TRUE;
    
    //
    // Reset the current Communication for the case of a Both.
    //
    m_CurrentCommunication = m_OriginalCommunication;
    //
    // There may not actually be a connection pin, such as when a connection
    // was not completed, or when this is a Bridge.
    //
    if (m_Connected) {
        m_Connected->Release();
        m_Connected = NULL;
    }
    //
    // If an interface handler was instantiated, release it.
    //
    if (m_InterfaceHandler) {
        m_InterfaceHandler->Release();
        m_InterfaceHandler = NULL;
    }
    //
    // If an data handler was instantiated, release it.
    //
    if (m_DataTypeHandler) {
        m_DataTypeHandler = NULL;
        SAFERELEASE( m_UnkInner );
    }
    //
    // Remove this pin instance if there is already an unconnected pin of
    // this type.
    //
    static_cast<CKsProxy*>(m_pFilter)->GeneratePinInstances();
    return NOERROR;
}


HRESULT
CKsInputPin::GetMediaType(
    int         Position,
    CMediaType* MediaType
    )
/*++

Routine Description:

    Override the CBasePin::GetMediaType method. Returns the specified media
    type on the Pin Factory Id.

Arguments:

    Position -
        The zero-based position to return. This corresponds to the data range
        item.

    MediaType -
        The media type to initialize.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s(%s)::GetMediaType"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName ));

    return ::KsGetMediaType(
        Position,
        static_cast<AM_MEDIA_TYPE*>(MediaType),
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId);
}


STDMETHODIMP_(IMemAllocator *)
CKsInputPin::KsPeekAllocator(
    KSPEEKOPERATION Operation
    )

/*++

Routine Description:
    Returns the assigned allocator for this pin and optionally
    AddRef()'s the interface.

Arguments:
    KSPEEKOPERATION Operation -
        if KsPeekOperation_AddRef is specified, the m_pAllocator is
        AddRef()'d (if not NULL) before returning.

Return:
    the value of m_pAllocator

--*/

{
    if ((Operation == KsPeekOperation_AddRef) && (m_pAllocator)) {
        m_pAllocator->AddRef();
    }
    return m_pAllocator;
}


STDMETHODIMP
CKsInputPin::KsRenegotiateAllocator(
    )

/*++

Routine Description:
    This method is not valid for input pins.

Arguments:
    None.

Return:
    E_FAIL

--*/

{
    DbgLog((
        LOG_TRACE,
        0,
        TEXT("KsRenegotiateAllocator method is only valid for output pins.")));
    return E_FAIL;
}


STDMETHODIMP
CKsInputPin::KsReceiveAllocator(
    IMemAllocator *MemAllocator
    )

/*++

Routine Description:
    This routine is defined for all pins but is only valid for output pins.

Arguments:
    IMemAllocator *MemAllocator -
        Ignored.

Return:
    E_FAIL

--*/

{
    if (MemAllocator) {
        MemAllocator->AddRef();
    }
    // Do this after the AddRef() above in case MemAllocator == m_pAllocator
    SAFERELEASE( m_pAllocator );
    m_pAllocator = MemAllocator;
    return (S_OK);
}



STDMETHODIMP
CKsInputPin::NotifyAllocator(
    IMemAllocator *Allocator,
    BOOL ReadOnly
    )
/*++

Routine Description:

    Override the CBaseInputPin::NotifyAllocator method.

Arguments:

    Allocator -
        The new allocator to use.

    ReadOnly -
        Specifies whether the buffers are read-only.

            
NOTE:

    With new pipe-based allocators design, the only connection that
    should be handled here - is from user mode output pin to a kernel mode pin.
    
    Also, the old design expected that Allocator is assigned by User mode pin.
    We are not changing that until User mode components are upgraded to use new
    pipes design.
            
Return Value:

    Returns NOERROR.

--*/
{
    HRESULT                    hr;
    IKsAllocatorEx*            InKsAllocator;
    PALLOCATOR_PROPERTIES_EX   InAllocEx;
    ALLOCATOR_PROPERTIES       Properties, ActualProperties;
    PKSALLOCATOR_FRAMING_EX    InFramingEx;
    FRAMING_PROP               InFramingProp;
    KS_FRAMING_FIXED           InFramingExFixed;
    ULONG                      NumPinsInPipe;
    GUID                       Bus;
    ULONG                      FlagChange;
    ULONG                      PropertyPinType;
    BOOL                       IsSpecialOutputRequest;
    IKsPin*                    OutKsPin;
    ULONG                      OutSize, InSize;

    ASSERT( IsConnected() );
    
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN NotifyAllocator entry InKsPin=%x, Allocator=%x, ReadOnly=%d"),
            static_cast<IKsPin*>(this), Allocator, ReadOnly)); 

    //
    // sanity check - the only possible connection to user mode is via HOST_BUS
    //
    ::GetBusForKsPin(static_cast<IKsPin*>(this) , &Bus);

    if (! ::IsHostSystemBus(Bus) ) {
        //
        // Don't fail, as there are some weird user-mode filters that use medium to identify devices (JayBo).
        //
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FILTERS: NotifyAllocator. BUS is not HOST_BUS.") ));
    }
   
    InKsAllocator = KsGetPipe(KsPeekOperation_PeekOnly );
   
    if (! InKsAllocator) {
        hr = ::MakePipesBasedOnFilter(static_cast<IKsPin*>(this), Pin_Input);
        if ( ! SUCCEEDED( hr )) {
            DbgLog((
                LOG_MEMORY,
                2,
                TEXT("%s(%s)::NotifyAllocator() returning %08x"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName,
                hr ));
            return hr;
       }
    }
       
    //
    // Process any changes on input pin. 
    //
    hr = ::ResolvePipeOnConnection(static_cast<IKsPin*>(this), Pin_Input, FALSE, &FlagChange);
   
    //
    // see if input kernel pin can connect to user mode.
    //
    
    ::GetPinFramingFromCache( static_cast<IKsPin*>(this), &InFramingEx, &InFramingProp, Framing_Cache_ReadLast);
    
    //
    // Don't enforce this yet.
    //
    if (0) {
        if (InFramingProp != FramingProp_None) {
            if (! ::GetFramingFixedFromFramingByLogicalMemoryType(InFramingEx, KS_MemoryTypeUser, &InFramingExFixed) ) {
                if (! ::GetFramingFixedFromFramingByLogicalMemoryType(InFramingEx, KS_MemoryTypeDontCare, &InFramingExFixed) ) {
                    DbgLog((LOG_MEMORY, 0,
                        TEXT("PIPES ERROR FILTERS: CKsInputPin::NotifyAllocator - doesn't support USER mode memory. Connection impossible.") ));
                    return E_FAIL;
                }
            }
        }
    }

    //
    // Connection is possible. 
    //
    ::ComputeNumPinsInPipe( static_cast<IKsPin*>(this), Pin_Input, &NumPinsInPipe);
   
    InKsAllocator = KsGetPipe(KsPeekOperation_PeekOnly);

    if (NumPinsInPipe > 1) {
        //
        // In intermediate version we split the pipe: so the pipe leading to(from) user mode pin
        // will always have just 1 kernel pin.
        //
        ::CreateSeparatePipe( static_cast<IKsPin*>(this), Pin_Input);
        
        InKsAllocator = KsGetPipe(KsPeekOperation_PeekOnly);
    }
   
    //
    // Here we have a single input pin on its pipe.
    //
    InAllocEx = InKsAllocator->KsGetProperties();
   
    //
    // Get upstream allocator properties.
    //
    hr = Allocator->GetProperties( &Properties);
    if ( ! SUCCEEDED( hr )) {
        DbgLog((LOG_MEMORY, 0, TEXT("PIPES ERROR FILTERS: CKsInputPin::NotifyAllocator - NO PROPERTIES.") ));
        return hr;
    }
   
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN NotifyAllocator. Prop=%d, %d, %d"),
        Properties.cBuffers, Properties.cbBuffer, Properties.cbAlign));

    //
    // User mode pin will be an allocator unconditionally.
    // Decide which pin will determine base allocator properties.
    //
    if (InFramingProp != FramingProp_None) {
        PropertyPinType = Pin_All;
    }
    else {
        PropertyPinType = Pin_User;
    }

    //
    // See if connecting kernel-mode filter requires KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO (e.g. MsTee)
    //
    if ( ! (IsSpecialOutputRequest = IsSpecialOutputReqs(static_cast<IKsPin*>(this), Pin_Input, &OutKsPin, &InSize, &OutSize ) )) {
        //
        // Lets try to adjust the user-mode connection first, since we are negotiating it anyway.
        //
        OutSize = 0;
    }

    hr = ::SetUserModePipe( static_cast<IKsPin*>(this), Pin_Input, &Properties, PropertyPinType, OutSize);
    
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CKsInputPin::NotifyAllocator PinType=%d. Wanted Prop=%d, %d, %d"),
            PropertyPinType, Properties.cBuffers, Properties.cbBuffer, Properties.cbAlign));

    hr = Allocator->SetProperties(&Properties, &ActualProperties);
    if (FAILED(hr)) {
        // If SetProperties failed, let's get some realistic values into ActualProperties because we'll use them later.
        hr = Allocator->GetProperties( &ActualProperties );
        ASSERT( SUCCEEDED(hr) );
    }
    
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CKsInputPin::NotifyAllocator ActualProperties=%d, %d, %d hr=%x"),
            ActualProperties.cBuffers, ActualProperties.cbBuffer, ActualProperties.cbAlign, hr));

    //
    // Don't fail if SetProperties() above failed - we will have to live with the original allocator,
    // to not break existing clients.
    //

    hr = KsReceiveAllocator(Allocator);
   
    if (SUCCEEDED( hr )) {        
        //
        // CBaseInputPin::NotifyAllocator() releases the old interface, if any
        // and sets the m_ReadOnly and m_pAllocator members.
        //
        hr = CBaseInputPin::NotifyAllocator( Allocator, ReadOnly );
    }

    if (SUCCEEDED( hr ) && IsSpecialOutputRequest && (ActualProperties.cbBuffer > (long) OutSize ) ) {        
        //
        // We haven't succeeded sizing the input user-mode pipe. Lets try to resize the output pipe (WRT this k.m. filter).
        //
        if (! CanResizePipe(OutKsPin, Pin_Output, ActualProperties.cbBuffer) ) {
            //
            // Don't fail. Just log.
            //
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR ConnectPipeToUserModePin. Couldn't resize pipes OutKsPin=%x"), OutKsPin));
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES NotifyAllocator rets %x"), hr ));

    DbgLog((
        LOG_MEMORY,
        2,
        TEXT("%s(%s)::NotifyAllocator() returning %08x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        hr ));
    
    return hr;
}



STDMETHODIMP
CKsInputPin::GetAllocator(
    IMemAllocator **MemAllocator
    )

/*++

Routine Description:
    Queries downstream pin for connected allocators.


Arguments:
    IMemAllocator **MemAllocator -
        pointer to received an AddRef()'d pointer to the allocator

Return:
    S_OK if successful or VFW_E_NO_ALLOCATOR on error.

--*/

{
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN %s(%s) CKsInputPin::GetAllocator KsPin=%x"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName,
            static_cast<IKsPin*>(this) ));

    return VFW_E_NO_ALLOCATOR;
} // GetAllocator


STDMETHODIMP
CKsInputPin::GetAllocatorRequirements(
    ALLOCATOR_PROPERTIES *AllocatorRequirements
    )

/*++

Routine Description:
    Calls the kernel filter to obtain the allocation requirements and
    fills the provided structure.

Arguments:
    ALLOCATOR_PROPERTIES *AllocatorRequirements -
        pointer to structure to receive the properties


Return:
    S_OK or result from CBaseInputPin::GetAllocatorRequirements()

--*/

{
    HRESULT             hr;
    KSALLOCATOR_FRAMING Framing;

    hr = ::GetAllocatorFraming(m_PinHandle, &Framing);
    if (SUCCEEDED(hr)) {
        AllocatorRequirements->cBuffers =
            Framing.Frames;
        AllocatorRequirements->cbBuffer =
            Framing.FrameSize;
        AllocatorRequirements->cbAlign =
            Framing.FileAlignment + 1;
        AllocatorRequirements->cbPrefix = 0;

        return hr;
    } else {
        return CBaseInputPin::GetAllocatorRequirements( AllocatorRequirements );
    }
}


STDMETHODIMP
CKsInputPin::BeginFlush(
    )
/*++

Routine Description:

    Override the CBaseInputPin::BeginFlush method. Forwards Begin-Flush
    notification to Topology-related output pins, if any, after first
    notifying the kernel pin.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    //
    // Wrap this in the I/O critical section.  This prevents us from marshaling
    // buffers in the middle of a flush.  It synchronizes the marshaler (in
    // particular on output pins) with the flush thread.
    //
    // NOTE: Per request, AVStream effectually issues a reset on topologically
    // related output pins when getting one on an input pin.  This means it
    // will reject marshalled buffers on the output pins in a flush state.
    // The proxy must understand that.  This is what the synchronization is
    // for (any such filter or kernel level client).
    //
    // The input pin's I/O critical section is also taken to guard against
    // a flush happening between the time m_bFlushing is set and the time we
    // marshal buffers.  The interface handler gets VERY cranky if a buffer
    // comes back DEVICE_NOT_READY (marshal in flush).  It will halt the entire
    // graph with EC_ERRORABORT.
    //
    static_cast<CKsProxy*>(m_pFilter)->EnterIoCriticalSection ();
    m_IoCriticalSection.Lock();
    m_DeliveryError = FALSE;
    CBaseInputPin::BeginFlush();
    if (m_PinHandle) {
        ULONG   BytesReturned;
        KSRESET ResetType;

        ResetType = KSRESET_BEGIN;
        ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_RESET_STATE,
            &ResetType,
            sizeof(ResetType),
            NULL,
            0,
            &BytesReturned);
    }
    m_IoCriticalSection.Unlock();
    static_cast<CKsProxy*>(m_pFilter)->DeliverBeginFlush(m_PinFactoryId);
    static_cast<CKsProxy*>(m_pFilter)->LeaveIoCriticalSection ();
    return S_OK;
}


STDMETHODIMP
CKsInputPin::EndFlush(
    )
/*++

Routine Description:

    Override the CBaseInputPin::EndFlush method. Forwards End-Flush
    notification to Topology-related output pins, if any, after first
    notifying the kernel pin.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    CBaseInputPin::EndFlush();
    if (m_PinHandle) {
        ULONG   BytesReturned;
        KSRESET ResetType;

        ResetType = KSRESET_END;
        ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_RESET_STATE,
            &ResetType,
            sizeof(ResetType),
            NULL,
            0,
            &BytesReturned);
    }
    static_cast<CKsProxy*>(m_pFilter)->DeliverEndFlush(m_PinFactoryId);
    return S_OK;
}


STDMETHODIMP
CKsInputPin::ReceiveCanBlock(
    )
/*++

Routine Description:

    Override the CBaseInputPin::ReceiveCanBlock method. 

Arguments:

    None.

Return Value:

    S_FALSE.

--*/
{
    //
    // Although we may block if all of the asynchronous I/O slots are filled
    // for this filter, this is not the normal case and we want to avoid
    // additional thread overhead.
    //
    
    //
    // Also note that the processing in CKsOutputPin::KsDeliver() will avoid 
    // blocking on downstream connected input pins by queueing the I/O to a 
    // worker thread.
    //
    return S_FALSE;
}


STDMETHODIMP
CKsInputPin::Receive(
    IMediaSample *MediaSample
    )
/*++

Routine Description:

    Override the CBaseInputPin::Receive method. Just passes control off to
    the ReceiveMultiple method.

Arguments:

    MediaSample -
        The single media sample to process.

Return Value:

    Returns the value of the ReceiveMultiple.

--*/
{
    LONG  SamplesProcessed;

    return ReceiveMultiple(
                &MediaSample,
                1,
                &SamplesProcessed );
}


STDMETHODIMP
CKsInputPin::ReceiveMultiple(
    IMediaSample **MediaSamples,
    LONG TotalSamples,
    LONG *SamplesProcessed
    )
/*++

Routine Description:

    Override the CBaseInputPin::ReceiveMultiple method.

Arguments:

    MediaSamples -
        The list of media samples to process.

    TotalSamples -
        The count of samples in the MediaSamples list.

    SamplesProcessed -
        The place in which to put the count of media samples actually processed.

Return Value:

    Returns S_OK if the media samples were queued to the device, else E_FAIL if
    a notification error occurred, or a sample could not be inserted into the
    stream (likely out of memory).

--*/
{
    int                 SubmittedSamples, CurrentSample;
    CKsProxy            *KsProxy = static_cast<CKsProxy*>(m_pFilter);
    AM_MEDIA_TYPE       *NewMediaType;
    BOOL                SkipNextFormatChange;
    HRESULT             hr;
    LONG                i;
    PKSSTREAM_SEGMENT   StreamSegment;

    *SamplesProcessed = 0;

    //
    // Make sure that we are in a streaming state.
    //   
    hr = CheckStreaming();
    if (hr != S_OK) {
        //
        // Note that if we are processing a flush, CheckStreaming()
        // returns S_FALSE.
        //
        return hr;
    }
    
    if (!m_MarshalData) {
        DbgLog((
            LOG_TRACE,
            2,
            TEXT("%s(%s)::ReceiveMultiple, m_MarshalData == FALSE"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName));
        return E_FAIL;
    }

    CurrentSample = SubmittedSamples = 0;
    SkipNextFormatChange = FALSE;
    
    while (SubmittedSamples < TotalSamples) {

        NewMediaType = NULL;	
    
        //
        // Handle the in-stream data format changes, if any.
        //
        // Walk the sample list, check for the media type changed bit
        // and submit only those samples up to the media type change.
        //
        
        for (i = SubmittedSamples; i < TotalSamples; i++) {
            hr = 
                MediaSamples[ i ]->GetMediaType( &NewMediaType );
            if (S_FALSE == hr) {
                continue;
            }
            
            if (SUCCEEDED( hr )) {

                //
                // Yuck. Need to find another solution to "SkipNextFormatChange".
                //
                if (SkipNextFormatChange) {
                    SkipNextFormatChange = FALSE;
                    DeleteMediaType( NewMediaType );
                    NewMediaType = NULL;
                    continue;
                }
                
                //
                // A media type change is detected, NewMediaType contains 
                // the new media type.
                //

                DbgLog((
                    LOG_TRACE, 
                    2, 
                    TEXT("%s(%s)::ReceiveMultiple, media change detected"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName ));
                SkipNextFormatChange = TRUE;
            }
            break;
        }
        
        if (FAILED( hr )) {
            //
            // While processing the media sample list, we experienced
            // a failure.  This is considered fatal and we notify the
            // filter graph of this condition.
            //
            DbgLog((
                LOG_TRACE,
                2,
                TEXT("%s(%s)::ReceiveMultiple, failure during MediaType scan: %08x"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName,
                hr));
            break;        
        }
        
        //
        // Submit the samples associated with the current media type.
        //
        
        SubmittedSamples = i;

        //
        // Only submit the number of samples before the media type change.
        //
        
        i -= CurrentSample;

        if (i) {
            //
            // Synchronize with Inactive().
            //
            m_IoCriticalSection.Lock();
            if (IsStopped() || ((hr = CheckStreaming()) != S_OK)) {
                m_IoCriticalSection.Unlock();
                break;
            }
            hr = m_InterfaceHandler->KsProcessMediaSamples(
                m_DataTypeHandler,
                &MediaSamples[ CurrentSample ],
                &i,
                KsIoOperation_Write,
                &StreamSegment );
            m_IoCriticalSection.Unlock();
            if (!SUCCEEDED( hr )) {
                //
                // An error occurred while sending the packet to the
                // kernel-mode filter.
                //
                
                DbgLog((
                    LOG_TRACE,
                    0,
                    TEXT("%s(%s)::ReceiveMultiple, I/O failed: %08x"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName,
                    hr));
                    
                KsNotifyError( MediaSamples[ CurrentSample ], hr );
            } 
            
            //
            // We succeeded to at least submit this information
            // to kernel-mode, increment samples processed counter.
            //
            *SamplesProcessed += i;
            CurrentSample = SubmittedSamples;
        
            while (!SUCCEEDED( KsProxy->InsertIoSlot( StreamSegment ) )) {
                //
                // Note that we're not really concerned with 
                // reentrancy in WaitForIoSlot() -- these threads will
                // be signalled when appropriate.  The assumption
                // is that Quartz will not get tripped up by this
                // condition.
                //
                KsProxy->WaitForIoSlot();
            }
        }
    
        //
        // Change to the new data type handler, if any.  To do so,
        // submit a packet with the format change information and then 
        // send the remaining data.
        //
        
        if (NewMediaType) {
            CFormatChangeHandler    *FormatChangeHandler;
        
            hr = SetStreamMediaType( static_cast<CMediaType*>(NewMediaType) );
            DeleteMediaType( NewMediaType );
            if (FAILED( hr )) {
                DbgLog((
                    LOG_TRACE,
                    0,
                    TEXT("%s(%s)::ReceiveMultiple, SetStreamMediaType failed"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName));
                break;
            }
            
            //
            // The format change handler is a special interface
            // handler for in-stream data changes.  
            // Note that the IMediaSample** parameter contains the
            // pointer to the sample with the new media type.
            //
            
            FormatChangeHandler = 
                new CFormatChangeHandler(
                    NULL,
                    NAME("Data Format Change Handler"),
                    &hr );
            
            if (!FormatChangeHandler) {
                hr = E_OUTOFMEMORY;
                break;
            }
            if (FAILED( hr )) {
                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("%s(%s)::ReceiveMultiple, CFormatChangeHandler()"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName));
                break;
            }        
            
            //
            // Force the AddRef() for the interface and notify the
            // interface handler of the pin interface.  Note that
            // the interface handler is AddRef()'d/Release()'d during 
            // the processing of an I/O operation -- this interface
            // will be cleaned up when the I/O is completed.
            //
            //
            
            FormatChangeHandler->AddRef();
            FormatChangeHandler->KsSetPin( static_cast<IKsPin*>(this) );
        
            i = 1;
            //
            // Synchronize with Inactive().
            //
            KsProxy->EnterIoCriticalSection();
            if (IsStopped()) {
                KsProxy->LeaveIoCriticalSection();
                FormatChangeHandler->Release();
                break;
            }
            hr =
                FormatChangeHandler->KsProcessMediaSamples(
                    NULL,
                    &MediaSamples[ CurrentSample ],
                    &i,
                    KsIoOperation_Write,
                    &StreamSegment );
            KsProxy->LeaveIoCriticalSection();
            FormatChangeHandler->Release();
            
            if (SUCCEEDED( hr )) {
                while (!SUCCEEDED( KsProxy->InsertIoSlot( StreamSegment ) )) {
                    KsProxy->WaitForIoSlot();
                }
            } else {
                DbgLog((
                    LOG_TRACE,
                    0,
                    TEXT("%s(%s)::ReceiveMultiple, fc I/O failed: %08x"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName,
                    hr));
                    
                KsNotifyError( MediaSamples[ CurrentSample ], hr );
            
                break;
            }
        }
    }
    
    return hr;
}


STDMETHODIMP_(LONG)
CKsInputPin::KsIncrementPendingIoCount(
    )
/*++

Routine Description:

    Implement the IKsPin::KsIncrementPendingIoCount method. Increments the
    count of outstanding pending I/O on the pin, and is called from an
    Interface handler.

Arguments:

    None.

Return Value:

    Returns the current outstanding count.

--*/
{
    return InterlockedIncrement( &m_PendingIoCount );
}


STDMETHODIMP_(LONG)
CKsInputPin::KsDecrementPendingIoCount(
    )
/*++

Routine Description:

    Implement the IKsPin::KsDecrementPendingIoCount method. Decrements the
    count of outstanding pending I/O on the pin, and is called from an
    Interface handler.

Arguments:

    None.

Return Value:

    Returns the current outstanding count.

--*/
{
    LONG PendingIoCount;
    
    if (0 == (PendingIoCount = InterlockedDecrement( &m_PendingIoCount ))) {
        //
        // The filter is in a stopped state, and this is the last I/O to
        // complete. At this point the Inactive method may be waiting on
        // all the I/O to be completed, so it needs to be signalled.
        //
        if (IsStopped()) {
            SetEvent( m_PendingIoCompletedEvent );
        }            
    }
    return PendingIoCount;
}


STDMETHODIMP_( VOID )
CKsInputPin::KsNotifyError(
    IMediaSample* Sample, 
    HRESULT hr
    )
/*++

Routine Description:
    Raises an error in the graph, if this has not already occurred.

Arguments:
    IMediaSample* Sample -
    
    HRESULT hr -

Return Value:
    None

--*/
{
    //
    // Don't raise an error if the I/O was cancelled.
    //
    if (hr == HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED)) {
        return;
    }       
    //
    // Notify the filter graph that we have an error. Ensure this
    // happens only once during a run, and that nothing further
    // is queued up.
    //
    m_DeliveryError = TRUE;
    m_pFilter->NotifyEvent( EC_ERRORABORT, hr, 0 );
}    
    

STDMETHODIMP
CKsInputPin::KsDeliver(
    IMediaSample* Sample,
    ULONG Flags
    )
/*++

Routine Description:
    Implements the IKsPin::KsDeliver method.  For input pins, this is an invalid
    entry point, just return E_FAIL.

Arguments:

    Sample -
        Pointer to a media sample.

    Flags -
        Sample flags.

Return:
    E_FAIL

--*/
{
    //
    // This is an unexpected call for an input pin.
    //
    return E_FAIL;
}


STDMETHODIMP 
CKsInputPin::KsMediaSamplesCompleted(
    PKSSTREAM_SEGMENT StreamSegment
    )

/*++

Routine Description:
    Notification handler for stream segment completed.  We don't care
    for input pins.

Arguments:
    PKSSTREAM_SEGMENT StreamSegment -
        segment completed

Return:
    Nothing.

--*/

{
    return S_OK;
}



STDMETHODIMP
CKsInputPin::KsQualityNotify(
    ULONG           Proportion,
    REFERENCE_TIME  TimeDelta
    )
/*++

Routine Description:

    Implementes the IKsPin::KsQualityNotify method. Receives quality
    management reports from the kernel mode pin which this Active
    Movie pin represents.

Arguments:

    Proportion -
        The proportion of data rendered.

    TimeDelta -
        The delta from nominal time at which the data is being received.

Return Value:

    Returns the result of forwarding the quality management report, else E_FAIL
    if the pin is not connected.

--*/
{
    Quality             q;
    IReferenceClock*    RefClock;

    //
    // This is reset when removing quality support, and just makes a quick
    // way out. This works because when a KsFlushClient() is done for this
    // pin on the quality forwarder, it synchronizes with the thread
    // delivering these messages.
    //
    if (!m_QualitySupport) {
        return NOERROR;
    }
    if (TimeDelta < 0) {
        q.Type = Famine;
    } else {
        q.Type = Flood;
    }
    q.Proportion = Proportion;
    q.Late = TimeDelta;
    if (SUCCEEDED(m_pFilter->GetSyncSource(&RefClock)) && RefClock) {
        RefClock->GetTime(&q.TimeStamp);
        RefClock->Release();
    } else {
        q.TimeStamp = 0;
    }
    if (m_pQSink) {
        return m_pQSink->Notify(m_pFilter, q);
    }
    if (m_Connected) {
        IQualityControl*    QualityControl;

        m_Connected->QueryInterface(__uuidof(IQualityControl), reinterpret_cast<PVOID*>(&QualityControl));
        if (QualityControl) {
            HRESULT hr;

            hr = QualityControl->Notify(m_pFilter, q);
            QualityControl->Release();
            return hr;
        }
    }
    return E_FAIL;
}


STDMETHODIMP
CKsInputPin::EndOfStream(
    )
/*++

Routine Description:

    Override the CBasePin::EndOfStream method. Forwards End-Of-Stream
    notification to Topology-related output pins, if any, else to the
    filter.

Arguments:

    None.

Return Value:

    Returns NOERROR.

--*/
{
    DbgLog((
        LOG_TRACE,
        2,
        TEXT("%s(%s)::EndOfStream"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName));
    //
    // Apparently this can be received when the filter is stopped, but
    // should be ignored.
    //
    if (static_cast<CKsProxy*>(m_pFilter)->IsStopped()) {
        return NOERROR;
    }
    //
    // Notification from any upstream filter is ignored, since the EOS
    // flag will be looked at by the marshaling code and sent when the
    // last I/O has completed.
    //
    if (m_MarshalData) {
        CMicroMediaSample*  MediaSample;
        HRESULT             hr;
        LONG                SamplesProcessed;
        IMediaSample*       MediaSamples;

        //
        // Generate a sample with an EOS flag set. AM does not set the
        // EOS flag within the stream.
        //
        MediaSample = new CMicroMediaSample(AM_SAMPLE_ENDOFSTREAM);
        if (!MediaSample) {
            DbgLog((
                LOG_TRACE,
                0,
                TEXT("%s(%s)::EndOfStream, failed to allocate EOS sample!"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName));
            return E_OUTOFMEMORY;
        }
        MediaSamples = static_cast<IMediaSample*>(MediaSample);
        hr = ReceiveMultiple(
            &MediaSamples,
            1,
            &SamplesProcessed);
        if (FAILED(hr)) {
            return hr;
        }
    }
    //
    // End-Of-Stream notification is ignored for non-Marshaling pins. This
    // is because a proxy instance will have registered with EOS notification
    // downstream.
    //
    return S_FALSE;
}


STDMETHODIMP
CKsInputPin::GetPages(
    CAUUID* Pages
    )
/*++

Routine Description:

    Implement the ISpecifyPropertyPages::GetPages method. This adds any
    Specifier handlers to the property pages if the pin instances is still
    unconnected and it is a Bridge pin. Else it adds none.

Arguments:

    Pages -
        The structure to fill in with the page list.

Return Value:

    Returns NOERROR, else a memory allocation error. Fills in the list of pages
    and page count.

--*/
{
    return ::GetPages(
        static_cast<IKsObject*>(this),
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        m_CurrentCommunication,
        static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
        Pages);
}


STDMETHODIMP
CKsInputPin::Render(
    IPin*           PinOut,
    IGraphBuilder*  Graph
    )
/*++

Routine Description:

    Implement the IStreamBuilder::Render method. This is only exposed on Bridge
    and None pins in order to make the graph builder ignore these pins.

Arguments:

    PinOut -
        The pin which this pin should attempt to render to.

    Graph -
        The graph builder making the call.

Return Value:

    Returns S_OK so that the graph builder will ignore this pin.

--*/
{
    return S_OK;
}


STDMETHODIMP
CKsInputPin::Backout(
    IPin*           PinOut,
    IGraphBuilder*  Graph
    )
/*++

Routine Description:

    Implement the IStreamBuilder::Backout method. This is only exposed on Bridge
    and None pins in order to make the graph builder ignore these pins.

Arguments:

    PinOut -
        The pin which this pin should back out from.

    Graph -
        The graph builder making the call.

Return Value:

    Returns S_OK so that the graph builder will ignore this pin.

--*/
{
    return S_OK;
}


STDMETHODIMP
CKsInputPin::Set(
    REFGUID PropSet,
    ULONG Id,
    LPVOID InstanceData,
    ULONG InstanceLength,
    LPVOID PropertyData,
    ULONG DataLength
    )
/*++

Routine Description:

    Implement the IKsPropertySet::Set method. This sets a property on the
    underlying kernel pin.

Arguments:

    PropSet -
        The GUID of the set to use.

    Id -
        The property identifier within the set.

    InstanceData -
        Points to the instance data passed to the property.

    InstanceLength -
        Contains the length of the instance data passed.

    PropertyData -
        Points to the data to pass to the property.

    DataLength -
        Contains the length of the data passed.

Return Value:

    Returns NOERROR if the property was set.

--*/
{
    ULONG   BytesReturned;

    if (InstanceLength) {
        PKSPROPERTY Property;
        HRESULT     hr;

        Property = reinterpret_cast<PKSPROPERTY>(new BYTE[sizeof(*Property) + InstanceLength]);
        if (!Property) {
            return E_OUTOFMEMORY;
        }
        Property->Set = PropSet;
        Property->Id = Id;
        Property->Flags = KSPROPERTY_TYPE_SET;
        memcpy(Property + 1, InstanceData, InstanceLength);
        hr = KsProperty(
            Property,
            sizeof(*Property) + InstanceLength,
            PropertyData,
            DataLength,
            &BytesReturned);
        delete [] (PBYTE)Property;
        return hr;
    } else {
        KSPROPERTY  Property;

        Property.Set = PropSet;
        Property.Id = Id;
        Property.Flags = KSPROPERTY_TYPE_SET;
        return KsProperty(
            &Property,
            sizeof(Property),
            PropertyData,
            DataLength,
            &BytesReturned);
    }
}


STDMETHODIMP
CKsInputPin::Get(
    REFGUID PropSet,
    ULONG Id,
    LPVOID InstanceData,
    ULONG InstanceLength,
    LPVOID PropertyData,
    ULONG DataLength,
    ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsPropertySet::Get method. This gets a property on the
    underlying kernel pin.

Arguments:

    PropSet -
        The GUID of the set to use.

    Id -
        The property identifier within the set.

    InstanceData -
        Points to the instance data passed to the property.

    InstanceLength -
        Contains the length of the instance data passed.

    PropertyData -
        Points to the place in which to return the data for the property.

    DataLength -
        Contains the length of the data buffer passed.

    BytesReturned -
        The place in which to put the number of bytes actually returned.

Return Value:

    Returns NOERROR if the property was retrieved.

--*/
{
    if (InstanceLength) {
        PKSPROPERTY Property;
        HRESULT     hr;

        Property = reinterpret_cast<PKSPROPERTY>(new BYTE[sizeof(*Property) + InstanceLength]);
        if (!Property) {
            return E_OUTOFMEMORY;
        }
        Property->Set = PropSet;
        Property->Id = Id;
        Property->Flags = KSPROPERTY_TYPE_GET;
        memcpy(Property + 1, InstanceData, InstanceLength);
        hr = KsProperty(
            Property,
            sizeof(*Property) + InstanceLength,
            PropertyData,
            DataLength,
            BytesReturned);
        delete [] (PBYTE)Property;
        return hr;
    } else if (PropSet == AMPROPSETID_Pin) {
        KSP_PIN Pin;

        switch (Id) {
        case AMPROPERTY_PIN_CATEGORY:
            Pin.Property.Set = KSPROPSETID_Pin;
            Pin.Property.Id = KSPROPERTY_PIN_CATEGORY;
            Pin.Property.Flags = KSPROPERTY_TYPE_GET;
            Pin.PinId = m_PinFactoryId;
            Pin.Reserved = 0;
            return static_cast<CKsProxy*>(m_pFilter)->KsProperty(
                reinterpret_cast<PKSPROPERTY>(&Pin),
                sizeof(Pin),
                PropertyData,
                DataLength,
                BytesReturned);
        default:
            return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }
    } else {
        KSPROPERTY  Property;

        Property.Set = PropSet;
        Property.Id = Id;
        Property.Flags = KSPROPERTY_TYPE_GET;
        return KsProperty(
            &Property,
            sizeof(Property),
            PropertyData,
            DataLength,
            BytesReturned);
    }
}


STDMETHODIMP
CKsInputPin::QuerySupported(
    REFGUID PropSet,
    ULONG Id,
    ULONG* TypeSupport
    )
/*++

Routine Description:

    Implement the IKsPropertySet::QuerySupported method. Return the type of
    support is provided for this property.

Arguments:

    PropSet -
        The GUID of the set to query.

    Id -
        The property identifier within the set.

    TypeSupport
        Optionally the place in which to put the type of support. If NULL, the
        query returns whether or not the property set as a whole is supported.
        In this case the Id parameter is not used and must be zero.

Return Value:

    Returns NOERROR if the property support was retrieved.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = PropSet;
    Property.Id = Id;
    Property.Flags = TypeSupport ? KSPROPERTY_TYPE_BASICSUPPORT : KSPROPERTY_TYPE_SETSUPPORT;
    return KsProperty(
        &Property,
        sizeof(Property),
        TypeSupport,
        TypeSupport ? sizeof(*TypeSupport) : 0,
        &BytesReturned);
}


STDMETHODIMP
CKsInputPin::KsPinFactory(
    ULONG* PinFactory
    )
/*++

Routine Description:

    Implement the IKsPinFactory::KsPinFactory method. Return the pin factory
    identifier.

Arguments:

    PinFactory -
        The place in which to put the pin factory identifier.

Return Value:

    Returns NOERROR.

--*/
{
    *PinFactory = m_PinFactoryId;
    return NOERROR;
}


STDMETHODIMP
CKsInputPin::KsProperty(
    IN PKSPROPERTY Property,
    IN ULONG PropertyLength,
    IN OUT LPVOID PropertyData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsProperty method. This is used to query and
    manipulate property sets on an object. It can perform a Get, Set, and
    various Support queries.

Arguments:

    Property -
        Contains the property set identification for the query.

    PropertyLength -
        Contains the length of the Property parameter. Normally this is
        the size of the KSPROPERTY structure.

    PropertyData -
        Contains either the data to apply to a property on a Set, the
        place in which to return the current property data on a Get, or the
        place in which to return property set information on a Support
        query.

    DataLength -
        Contains the size of the PropertyData buffer.

    BytesReturned -
        On a Get or Support query, returns the number of bytes actually
        used in the PropertyData buffer. This is not used on a Set, and
        is returned as zero.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    return ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_PROPERTY,
        Property,
        PropertyLength,
        PropertyData,
        DataLength,
        BytesReturned);
}


STDMETHODIMP
CKsInputPin::KsMethod(
    IN PKSMETHOD Method,
    IN ULONG MethodLength,
    IN OUT LPVOID MethodData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsMethod method. This is used to query and
    manipulate method sets on an object. It can perform an Execute and
    various Support queries.

Arguments:

    Method -
        Contains the method set identification for the query.

    MethodLength -
        Contains the length of the Method parameter. Normally this is
        the size of the KSMETHOD structure.

    MethodData -
        Contains either the IN and OUT parameters to the method, or the
        place in which to return method set information on a Support
        query.

    DataLength -
        Contains the size of the MethodData buffer.

    BytesReturned -
        Returns the number of bytes actually used in the MethodData buffer.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    return ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_METHOD,
        Method,
        MethodLength,
        MethodData,
        DataLength,
        BytesReturned);
}


STDMETHODIMP
CKsInputPin::KsEvent(
    IN PKSEVENT Event OPTIONAL,
    IN ULONG EventLength,
    IN OUT LPVOID EventData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsEvent method. This is used to set and
    query events sets on an object. It can perform an Enable, Disable and
    various Support queries.

Arguments:

    Event -
        Contains the event set identification for the enable, disable, or
        query. To disable an event, this parameter must be set to NULL, and
        EventLength set to zero. The EventData must be passed the original
        KSEVENTDATA pointer.

    EventLength -
        Contains the length of the Event parameter. Normally this is
        the size of the KSEVENT structure for an Enable. This would be set
        to zero for a Disable.

    EventData -
        Contains either the KSEVENTDATA to apply to a event on an Enable,
        or the place in which to return event set information on a Support
        query.

    DataLength -
        Contains the size of the EventData buffer. For an Enable or Disable
        this would normally be the size of a KSEVENTDATA, structure plus
        event specific data.

    BytesReturned -
        On a Support query, returns the number of bytes actually used in
        the EventData buffer. This is not used on an Enable or Disable, and
        is returned as zero.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    //
    // If an event structure is present, this must either be an Enable or
    // or a Support query.
    //
    if (EventLength) {
        return ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_ENABLE_EVENT,
            Event,
            EventLength,
            EventData,
            DataLength,
            BytesReturned);
    }
    //
    // Otherwise this must be a Disable.
    //
    return ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_DISABLE_EVENT,
        EventData,
        DataLength,
        NULL,
        0,
        BytesReturned);
}


STDMETHODIMP
CKsInputPin::KsGetPinFramingCache(
    PKSALLOCATOR_FRAMING_EX* FramingEx,
    PFRAMING_PROP FramingProp,
    FRAMING_CACHE_OPS Option
    )
/*++

Routine Description:

    Implement the IKsPinPipe::KsGetPinFramingCache method. This is used to
    retrieve the extended framing for this pin.

Arguments:

    FramingEx -
        The buffer in which to return the extended framing requested.

    FramingProp -
        The buffer in which to return state of the framing requirements
        structure.

    Option -
        Indicates which extended framing to return. This is one of
        Framing_Cache_ReadOrig, Framing_Cache_ReadLast, or
        Framing_Cache_Write.

Return Value:

    Returns S_OK.

--*/
{
    ASSERT( Option >= Framing_Cache_ReadLast);
    ASSERT( Option <= Framing_Cache_Write );
    if ((Option < Framing_Cache_ReadLast) || (Option > Framing_Cache_Write)) {
        return E_INVALIDARG;
    }
    *FramingEx = m_AllocatorFramingEx[Option - 1];
    *FramingProp = m_FramingProp[Option - 1];
    return S_OK;
}


STDMETHODIMP
CKsInputPin::KsSetPinFramingCache(
    PKSALLOCATOR_FRAMING_EX FramingEx,
    PFRAMING_PROP FramingProp,
    FRAMING_CACHE_OPS Option
    )
/*++

Routine Description:

    Implement the IKsPinPipe::KsSetPinFramingCache method. This is used to
    set the extended framing for this pin.

Arguments:

    FramingEx -
        Contains the new extended framing to set.

    FramingProp -
        Contains the new state to set on the extended framing type passed.

    Option -
        Indicates which extended framing to set. This is one of
        Framing_Cache_ReadOrig, Framing_Cache_ReadLast, or
        Framing_Cache_Write.

Return Value:

    Returns S_OK.

--*/
{
    //
    // The same pointer may be used for multiple items, so ensure that it
    // is not being used elsewhere before deleting it.
    //
    if (m_AllocatorFramingEx[Option - 1]) {
        ULONG PointerUseCount = 0;
        for (ULONG Options = 0; Options < SIZEOF_ARRAY(m_AllocatorFramingEx); Options++) {
            if (m_AllocatorFramingEx[Options] == m_AllocatorFramingEx[Option - 1]) {
                PointerUseCount++;
            }
        }
        //
        // This pointer is only used once, so it can be deleted. This
        // assumes that no client has acquired the pointer which is about
        // to be deleted.
        //
        if (PointerUseCount == 1) {
            delete m_AllocatorFramingEx[Option - 1];
        }
    }
    m_AllocatorFramingEx[Option - 1] = FramingEx;
    m_FramingProp[Option - 1] = *FramingProp;
    return S_OK;
}


STDMETHODIMP_(IKsAllocatorEx*)
CKsInputPin::KsGetPipe(
    KSPEEKOPERATION Operation
    )

/*++

Routine Description:
    Returns the assigned KS allocator for this pin and optionally
    AddRef()'s the interface.

Arguments:
    KSPEEKOPERATION Operation -
        if KsPeekOperation_AddRef is specified, the m_pKsAllocator is
        AddRef()'d (if not NULL) before returning.

Return Value:
    the value of m_pKsAllocator

--*/

{
    if ((Operation == KsPeekOperation_AddRef) && (m_pKsAllocator)) {
        m_pKsAllocator->AddRef();
    }
    return m_pKsAllocator;
}



STDMETHODIMP
CKsInputPin::KsSetPipe(
    IKsAllocatorEx *KsAllocator
    )

{
    DbgLog(( 
        LOG_CUSTOM1, 
        1, 
        TEXT("PIPES ATTN %s(%s)::KsSetPipe , m_pKsAllocator == 0x%08X, KsAllocator == 0x%08x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        m_pKsAllocator,
        KsAllocator ));

    if (KsAllocator) {
        KsAllocator->AddRef();
    }
    SAFERELEASE( m_pKsAllocator );
    m_pKsAllocator = KsAllocator;
    return (S_OK);

}    


STDMETHODIMP
CKsInputPin::KsSetPipeAllocatorFlag(
    ULONG   Flag
    )
{
    m_fPipeAllocator = Flag;
    return (S_OK);
}


STDMETHODIMP_(ULONG)
CKsInputPin::KsGetPipeAllocatorFlag(
    )
{
    return m_fPipeAllocator;
}


STDMETHODIMP_(PWCHAR)
CKsInputPin::KsGetPinName(
    )
{
    return m_pName;
}

STDMETHODIMP_(PWCHAR)
CKsInputPin::KsGetFilterName(
    )
{
    return (static_cast<CKsProxy*>(m_pFilter)->GetFilterName() );
}

STDMETHODIMP_(GUID)
CKsInputPin::KsGetPinBusCache(
    )
{
    //
    // When we read the Pin bus cache for the first time,
    // we set the cache. 
    //
    if (! m_PinBusCacheInit) {
        ::GetBusForKsPin(static_cast<IKsPin*>(this), &m_BusOrig);
        m_PinBusCacheInit = TRUE;
    }

    return m_BusOrig;
}


STDMETHODIMP
CKsInputPin::KsSetPinBusCache(
    GUID    Bus
    )
{
    m_BusOrig = Bus;
    return (S_OK);
}


STDMETHODIMP
CKsInputPin::KsAddAggregate(
    IN REFGUID Aggregate
    )
/*++

Routine Description:

    Implement the IKsAggregateControl::KsAddAggregate method. This is used to
    load a COM server with zero or more interfaces to aggregate on the object.

Arguments:

    Aggregate -
        Contains the Aggregate reference to translate into a COM server which
        is to be aggregated on the object.

Return Value:

    Returns S_OK if the Aggregate was added.

--*/
{
    return ::AddAggregate(&m_MarshalerList, static_cast<IKsPin*>(this), Aggregate);
}


STDMETHODIMP
CKsInputPin::KsRemoveAggregate(
    IN REFGUID Aggregate
    )
/*++

Routine Description:

    Implement the IKsAggregateControl::KsRemoveAggregate method. This is used to
    unload a previously loaded COM server which is aggregating interfaces.

Arguments:

    Aggregate -
        Contains the Aggregate reference to look up and unload.

Return Value:

    Returns S_OK if the Aggregate was removed.

--*/
{
    return ::RemoveAggregate(&m_MarshalerList, Aggregate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksproxy\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ksproxy.rc
//
#define IDD_VOLPROP                     101
#define IDS_NAME                        102
#define IDD_ROUTEDIALOG                 103
#define IDD_NAMEDIALOG                  106
#define IDD_PINDIALOG                   199
#define IDC_FORMATLIST                  1003
#define IDC_FORMATTREE                  1005
#define IDC_DATAROUTE                   1006
#define IDC_DEVICENAME                  1007
#define IDS_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters.ks\ksproxy\ksproxy.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksproxy.cpp

Abstract:

    Provides a generic Active Movie wrapper for a kernel mode filter (WDM-CSA).

Author(s):

    Thomas O'Rourke (tomor) 2-Feb-1996
    George Shaw (gshaw)
    Bryan A. Woodruff (bryanw) 
    
--*/

#include <windows.h>
#ifdef WIN9X_KS
#include <comdef.h>
#endif // WIN9X_KS
#include <setupapi.h>
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <devioctl.h>
#include <ks.h>
#include <ksi.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>
#include "ksiproxy.h"

// When building a combied ksproxy with all the kids, include the following
//#ifdef FILTER_DLL
#include "..\ksdata\ksdata.h"
#include "..\ksinterf\ksinterf.h"
#include "..\ksclockf\ksclockf.h"
#include "..\ksqmf\ksqmf.h"
#include "..\ksbasaud\ksbasaud.h"
//#include "dvp.h"
#include "vptype.h"
#include "vpconfig.h"
#include "vpnotify.h"
#include "..\ksvpintf\ksvpintf.h"

//from ksclockf.cpp, ksqmf.cpp, ksbasaud.cpp
struct DECLSPEC_UUID("877e4351-6fea-11d0-b863-00aa00a216a1") CLSID_KsClockF;
struct DECLSPEC_UUID("E05592E4-C0B5-11D0-A439-00A0C9223196") CLSID_KsQualityF;
// struct DECLSPEC_UUID("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d") CLSID_KsIBasicAudioInterfaceHandler;  // in ksproxy.h
//#endif // FILTER_DLL

CFactoryTemplate g_Templates[] = {
    {
        L"Proxy Filter",
        &CLSID_Proxy,
        CKsProxy::CreateInstance,
        NULL,
        NULL
    },

//#ifdef FILTER_DLL
    {   // ksdata
        L"KsDataTypeHandler", 
        &KSDATAFORMAT_TYPE_AUDIO,
        CStandardDataTypeHandler::CreateInstance,
        NULL,
        NULL
    },
    {   // ksinterf
        L"StandardInterfaceHandler", 
        &KSINTERFACESETID_Standard,
        CStandardInterfaceHandler::CreateInstance,
        NULL,
        NULL
    },
    {   // ksclockf
        L"KS Clock Forwarder", 
        &__uuidof(CLSID_KsClockF), 
        CKsClockF::CreateInstance, 
        NULL, 
        NULL
    },
    {   // ksclockf
        L"KS Quality Forwarder", 
        &__uuidof(CLSID_KsQualityF), 
        CKsQualityF::CreateInstance, 
        NULL, 
        NULL
    },
    {
        L"VPConfigPropSet", 
        &KSPROPSETID_VPConfig, 
        CVPVideoInterfaceHandler::CreateInstance,
        NULL,
        NULL
    },
    {
        L"VPVBIConfigPropSet", 
        &KSPROPSETID_VPVBIConfig, 
        CVPVBIInterfaceHandler::CreateInstance,
        NULL,
        NULL
    },
    {   // ksbasaud
        L"Ks IBasicAudio Interface Handler", 
        &CLSID_KsIBasicAudioInterfaceHandler,  // &__uuidof(CLSID_KsIBasicAudioInterfaceHandler), 
        CKsIBasicAudioInterfaceHandler::CreateInstance, 
        NULL, 
        NULL
    },

//#endif // FILTER_LIB

};
int g_cTemplates = SIZEOF_ARRAY(g_Templates);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}


CUnknown*
CALLBACK
CKsProxy::CreateInstance(
    LPUNKNOWN UnkOuter,
    HRESULT* hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a proxy filter.
    It is referred to in the g_Tamplates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{   
    CUnknown *Unknown;

    Unknown = new CKsProxy(UnkOuter, hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
}


DWORD 
CKsProxy::IoThread(
    CKsProxy* KsProxy
    ) 
/*++

Routine Description:

    This is the I/O thread created for each filter.

Arguments:

    KsProxy -
        Context pointer which is a pointer to the instance of the proxy
        filter.
        
Return Value:

    Return value is always 0

--*/
{
    DWORD   WaitResult;

        DbgLog((
        LOG_TRACE,
        2,
        TEXT("%s::IoThread() startup"),
        KsProxy->m_pName ));
    
    for (;;) {
        WaitResult = 
            WaitForMultipleObjectsEx( 
                KsProxy->m_ActiveIoEventCount,
                KsProxy->m_IoEvents,
                FALSE,      // BOOL bWaitAll
                INFINITE,   // DWORD dwMilliseconds
                FALSE );

        switch (WaitResult) {

        case WAIT_FAILED:
            //
            // Shouldn't happen, but if it does...  just try the wait again.
            // If we exit this thread (even notification of EC_ERRORABORT),
            // we hang the app needing to end task it....  The interface
            // handler needs to decrement pending I/O's ...  but if the
            // interface handler is called on non-signalled events we will
            // blow up (deleting the overlapped structure for the I/O)
            //
            continue;
            
        //
        // The m_IoEvents array has been updated, grab the 
        // critical section and check the status of the filter,
        // if we are shutting down, then return.
        //

        case WAIT_OBJECT_0:

            KsProxy->EnterIoCriticalSection();
            if (KsProxy->m_IoThreadShutdown) {
                KsProxy->LeaveIoCriticalSection();
                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("%s::IoThread() shutdown"),
                    KsProxy->m_pName ));
                return 0;
            }
            KsProxy->LeaveIoCriticalSection();
            break;
            
        default:
            
            //
            // An I/O operation completed.
            //
            
            WaitResult -= WAIT_OBJECT_0;
            if (WaitResult > (MAXIMUM_WAIT_OBJECTS - 1)) {
                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("invalid return from WaitForMultipleObjectsEx")));
                break;        
            }

            KsProxy->m_IoSegments[ WaitResult ]->KsInterfaceHandler->KsCompleteIo(
                KsProxy->m_IoSegments[ WaitResult ]);

            CloseHandle( KsProxy->m_IoEvents[ WaitResult ] );

            KsProxy->EnterIoCriticalSection();

            KsProxy->m_ActiveIoEventCount--;
            
            ASSERT( KsProxy->m_ActiveIoEventCount >= 1 );

            //
            // If we are leaving a gap in the array, then fill the
            // empty slot by sliding higher elements down.
            //

            if ((KsProxy->m_ActiveIoEventCount > 1) &&
                (static_cast<LONG>(WaitResult) != KsProxy->m_ActiveIoEventCount)) {
                  ASSERT( static_cast<LONG>(WaitResult) < KsProxy->m_ActiveIoEventCount );
                  MoveMemory( (void *) (KsProxy->m_IoEvents + WaitResult),
                           (void *) (KsProxy->m_IoEvents + WaitResult + 1),
                           (KsProxy->m_ActiveIoEventCount - WaitResult) * sizeof(KsProxy->m_IoEvents[0]) );
                  MoveMemory( (void *) (KsProxy->m_IoSegments + WaitResult),
                           (void *) (KsProxy->m_IoSegments + WaitResult + 1),
                           (KsProxy->m_ActiveIoEventCount - WaitResult) * sizeof(KsProxy->m_IoSegments[0]) );
            }
            
            KsProxy->LeaveIoCriticalSection();
            
            //
            // Release the free slot semaphore to free up any waiters.
            //
            
            ReleaseSemaphore( KsProxy->m_IoFreeSlotSemaphore, 1, NULL );
            
            break;
        }
    }
}


DWORD 
CKsProxy::WaitThread(
    CKsProxy* KsProxy
    ) 
/*++

Routine Description:

    This is the EOS wait thread created optionally created for a filter.

Arguments:

    KsProxy -
        Context pointer which is a pointer to the instance of the proxy
        filter.
        
Return Value:

    Return value is always 0

--*/
{
    for (;;) {
        DWORD   WaitResult;

        WaitResult = WaitForMultipleObjectsEx(
            KsProxy->m_ActiveWaitEventCount,
            KsProxy->m_WaitEvents,
            FALSE,
            INFINITE,
            FALSE);
        switch (WaitResult) {
        case WAIT_OBJECT_0:
            switch (KsProxy->m_WaitMessage.Message) {
            case STOP_EOS:
                //
                // Shutting down the thread.
                //
                ASSERT(KsProxy->m_ActiveWaitEventCount == 1);
                return 0;
            case ENABLE_EOS:
            {
                KSEVENT     Event;
                KSEVENTDATA EventData;
                ULONG       BytesReturned;
                HRESULT     hr;
                DECLARE_KSDEBUG_NAME(EventName);

                //
                // Enable an event for this pin. Just use the local
                // stack for the data, since it won't be referenced
                // again in disable. Status is returned through the
                // Param of the message.
                //
                Event.Set = KSEVENTSETID_Connection;
                Event.Id = KSEVENT_CONNECTION_ENDOFSTREAM;
                Event.Flags = KSEVENT_TYPE_ENABLE;
                EventData.NotificationType = KSEVENTF_EVENT_HANDLE;
                BUILD_KSDEBUG_NAME2(EventName, _T("EOS#%p%p"), KsProxy, (ULONG_PTR)InterlockedIncrement(&KsProxy->m_EventNameIndex));
                EventData.EventHandle.Event = CreateEvent( 
                    NULL,
                    FALSE,
                    FALSE,
                    KSDEBUG_NAME(EventName));
                ASSERT(KSDEBUG_UNIQUE_NAME());
                if (!EventData.EventHandle.Event) {
                    DWORD   LastError;

                    LastError = GetLastError();
                    KsProxy->m_WaitMessage.Param = reinterpret_cast<PVOID>(UIntToPtr(HRESULT_FROM_WIN32(LastError)));
                    break;
                }
                KsProxy->m_WaitEvents[KsProxy->m_ActiveWaitEventCount] = EventData.EventHandle.Event;
                EventData.EventHandle.Reserved[0] = 0;
                EventData.EventHandle.Reserved[1] = 0;
                hr = ::KsSynchronousDeviceControl(
                    reinterpret_cast<HANDLE>(KsProxy->m_WaitMessage.Param),
                    IOCTL_KS_ENABLE_EVENT,
                    &Event,
                    sizeof(Event),
                    &EventData,
                    sizeof(EventData),
                    &BytesReturned);
                if (SUCCEEDED(hr)) {
                    KsProxy->m_WaitPins[KsProxy->m_ActiveWaitEventCount] = reinterpret_cast<HANDLE>(KsProxy->m_WaitMessage.Param);
                    KsProxy->m_ActiveWaitEventCount++;
                } else {
                    //
                    // Enable failed, so delete the event created above,
                    // since no disable will happen to delete it.
                    //
                    CloseHandle(EventData.EventHandle.Event);
                }
                KsProxy->m_WaitMessage.Param = reinterpret_cast<PVOID>(UIntToPtr(hr));
                break;
            }
            case DISABLE_EOS:
            {
                ULONG   Pin;

                //
                // Look for the pin passed in on the message and remove
                // it's item from the list. This would only be done when
                // the pin is going away, so all events can be disabled
                // on the pin. Note that the message sender has the filter
                // lock, so this array cannot be changed by another thread.
                // Skip the first slot, as it is not used to correspond to
                // the message signalling event.
                //
                for (Pin = 1; Pin < KsProxy->m_ActiveWaitEventCount; Pin++) {
                    if (KsProxy->m_WaitPins[Pin] == reinterpret_cast<HANDLE>(KsProxy->m_WaitMessage.Param)) {
                        ULONG   BytesReturned;

                        //
                        // Found the item, so delete it.
                        //
                        KsProxy->m_ActiveWaitEventCount--;
                        CloseHandle(KsProxy->m_WaitEvents[Pin]);
                        ::KsSynchronousDeviceControl(
                            KsProxy->m_WaitPins[Pin],
                            IOCTL_KS_DISABLE_EVENT,
                            NULL,
                            0,
                            NULL,
                            0,
                            &BytesReturned);
                        //
                        // Move the last item down to fill this spot if
                        // necessary.
                        //
                        if (Pin < KsProxy->m_ActiveWaitEventCount) {
                            KsProxy->m_WaitEvents[Pin] = KsProxy->m_WaitEvents[KsProxy->m_ActiveWaitEventCount];
                            KsProxy->m_WaitPins[Pin] = KsProxy->m_WaitPins[KsProxy->m_ActiveWaitEventCount];
                        }
                        break;
                    }
                }
                break;
            }
            }
            //
            // Signal the caller that the operation is complete.
            //
            SetEvent(KsProxy->m_WaitReplyHandle);
            break;
        default:
            //
            // An EOS notification has occurred on a pin. Increment
            // the count and see if it is enough to trigger EC_COMPLETE.
            //
            KsProxy->m_EndOfStreamCount++;
            //
            // Subtract off the base signalling handle from the
            // comparison. If enough pins have signalled EOS,
            // then send the EC_COMPLETE.
            //
            if (KsProxy->m_EndOfStreamCount == KsProxy->m_ActiveWaitEventCount - 1) {
                KsProxy->NotifyEvent(EC_COMPLETE, S_OK, 0);
            }
            break;
        }
    }
}

#pragma warning(disable:4355)

CKsProxy::CKsProxy(
    LPUNKNOWN UnkOuter,
    HRESULT* hr
    ) :
    CBaseFilter(
        NAME("KsProxy filter"),
        UnkOuter,
        static_cast<CCritSec*>(this),
        CLSID_Proxy),
    CPersistStream(UnkOuter, hr),
    m_PinList(
        NAME("Pin list"),
        DEFAULTCACHE,
        FALSE,
        FALSE),
    m_MarshalerList(
        NAME("Marshaler list"),
        DEFAULTCACHE,
        FALSE,
        FALSE),
    m_FilterHandle(NULL),
    m_ExternalClockHandle(NULL),
    m_PinClockHandle(NULL),
    m_PinClockSource(NULL),
    m_IoThreadHandle(NULL),
    m_IoThreadShutdown(FALSE),
    m_IoSegments(NULL),
    m_ActiveIoEventCount(0) ,
    m_IoFreeSlotSemaphore(NULL),
    m_IoEvents(NULL),
    m_QualityForwarder(NULL),
    m_MediaSeekingRecursion(FALSE),
    m_DeviceRegKey(NULL),
    m_PersistStreamDevice(NULL),
    m_WaitThreadHandle(NULL),
    m_WaitEvents(NULL),
    m_WaitPins(NULL),
    m_ActiveWaitEventCount(0),
    m_WaitReplyHandle(NULL),
    m_EndOfStreamCount(0),
    m_PropagatingAcquire(FALSE),
    m_SymbolicLink(NULL),
    m_EventNameIndex(0)
/*++

Routine Description:

    The constructor for the Filter object. Does base class initialization for
    object.
    
Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    DbgLog(( LOG_TRACE, 0, TEXT("KsProxy, debug version, built ") TEXT(__DATE__) TEXT(" @ ") TEXT(__TIME__) ));

    DECLARE_KSDEBUG_NAME(EventName);
    DECLARE_KSDEBUG_NAME(SemName);

    InitializeCriticalSection( &m_IoThreadCriticalSection );
    
    //
    // Create the I/O event and stream segment queue.
    //
    
    if (NULL == (m_IoSegments = new PKSSTREAM_SEGMENT[ MAXIMUM_WAIT_OBJECTS ])) {
        *hr = E_OUTOFMEMORY;           
        return;
    }
    
    if (NULL == (m_IoEvents = new HANDLE[ MAXIMUM_WAIT_OBJECTS ])) {
        *hr = E_OUTOFMEMORY;           
        return;
    }
    
    BUILD_KSDEBUG_NAME2(EventName, _T("EvActiveIo#%p%p"), this, (ULONG_PTR)InterlockedIncrement(&m_EventNameIndex));
    m_IoEvents[ m_ActiveIoEventCount ] =
        CreateEvent( 
            NULL,       // LPSECURITY_ATTRIBUTES lpEventAttributes
            FALSE,      // BOOL bManualReset
            FALSE,      // BOOL bInitialState
            KSDEBUG_NAME(EventName));     // LPCTSTR lpName
    ASSERT(KSDEBUG_UNIQUE_NAME());
    
    if (NULL == m_IoEvents[ m_ActiveIoEventCount ]) {
        DWORD   LastError;

        LastError = GetLastError();
        *hr = HRESULT_FROM_WIN32(LastError);
        return;
    }   
    m_ActiveIoEventCount++;
    
    //
    // The free slot semaphore is used when waiting for a free slot
    // in the queue.
    //
    
    BUILD_KSDEBUG_NAME(SemName, _T("SemIoFreeSlot#%p"), &m_IoFreeSlotSemaphore);
    m_IoFreeSlotSemaphore =
        CreateSemaphore( 
            NULL,                       // LPSECURITY_ATTRIBUTES lpEventAttributes
            MAXIMUM_WAIT_OBJECTS - 1,   // LONG lInitialCount
            MAXIMUM_WAIT_OBJECTS - 1,   // LONG lMaximumCount
            KSDEBUG_NAME(SemName) );    // LPCTSTR lpName
    ASSERT(KSDEBUG_UNIQUE_NAME());
            
    if (NULL == m_IoFreeSlotSemaphore) {
        DWORD   LastError;

        LastError = GetLastError();
        *hr = HRESULT_FROM_WIN32(LastError);
        return;
    }

    //
    // The waiter list is used for EOS notification.
    //
    if (!(m_WaitEvents = new HANDLE[MAXIMUM_WAIT_OBJECTS])) {
        *hr = E_OUTOFMEMORY;
        return;
    }
    if (!(m_WaitPins = new HANDLE[MAXIMUM_WAIT_OBJECTS])) {
        *hr = E_OUTOFMEMORY;
        return;
    }
    BUILD_KSDEBUG_NAME2(EventName, _T("EvActiveWait#%p%p"), this, (ULONG_PTR)InterlockedIncrement(&m_EventNameIndex));
    m_WaitEvents[m_ActiveWaitEventCount] = CreateEvent(NULL, FALSE, FALSE, KSDEBUG_NAME(EventName));
    ASSERT(KSDEBUG_UNIQUE_NAME());
    if (!m_WaitEvents[m_ActiveWaitEventCount]) {
        DWORD   LastError;

        LastError = GetLastError();
        *hr = HRESULT_FROM_WIN32(LastError);
        return;
    }
    m_ActiveWaitEventCount++;

    //
    // This event is used to reply to messages.
    //
    BUILD_KSDEBUG_NAME(EventName, _T("EvWaitReply#%p"), &m_WaitReplyHandle);
    m_WaitReplyHandle = CreateEvent(NULL, FALSE, FALSE, KSDEBUG_NAME(EventName));
    ASSERT(KSDEBUG_UNIQUE_NAME());
    if (!m_WaitReplyHandle) {
        DWORD   LastError;

        LastError = GetLastError();
        *hr = HRESULT_FROM_WIN32(LastError);
    }
}


CKsProxy::~CKsProxy(
    )
/*++

Routine Description:

    The destructor for the proxy filter instance. This protects the COM Release
    function from accidentally calling delete again on the object by incrementing
    the reference count. After that, all outstanding resources are cleaned up.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    //
    // Protect against a spurious delete because of aggregation. No need to
    // use an interlocking increment, as the object is being destroyed.
    //
    m_cRef++;
    
    //
    // Destroy I/O thread and related objects
    //
    
    if (m_IoThreadHandle) {
        //
        // Signal a reset to the I/O thread which will cause a shutdown.
        //
    
        EnterCriticalSection( &m_IoThreadCriticalSection );
        m_IoThreadShutdown = TRUE;
        SetEvent( m_IoEvents[ 0 ] );
        LeaveCriticalSection( &m_IoThreadCriticalSection );
        
        //
        // Wait for the thread to shutdown, then close the handle.
        //
        WaitForSingleObjectEx( m_IoThreadHandle, INFINITE, FALSE );
        CloseHandle( m_IoThreadHandle );
        m_IoThreadHandle = NULL;
    }
    
    if (m_IoEvents) {
        if (m_ActiveIoEventCount) {
        
            //
            // All I/O should have been completed during the shutdown
            // of the thread, the only remaining event must be the
            // reset event (m_IoEvents[ 0 ]).
            //
            
            ASSERT( m_ActiveIoEventCount == 1 );
            CloseHandle( m_IoEvents[ 0 ] );
        }
        delete [] m_IoEvents;
        m_IoEvents = NULL;
    }
    
    if (m_IoFreeSlotSemaphore) {
        CloseHandle( m_IoFreeSlotSemaphore );
        m_IoFreeSlotSemaphore = NULL;
    }
    
    //
    // The same condition applies, all I/O was completed during the
    // shutdown, there should not be any outstanding stream segments.
    //
    
    if (m_IoSegments) {
        delete [] m_IoSegments;
        m_IoSegments = NULL;
    }
    
    //
    // This may contain a handle to a clock on some pin in this filter, which
    // would have been used as a master clock.
    //
    if (m_PinClockHandle) {
        CloseHandle(m_PinClockHandle);
    }
    //
    // This may contain the handle to the filter driver, unless the object
    // could not open the driver in the first place in the constructor.
    //
    if (m_FilterHandle){
        CloseHandle(m_FilterHandle);
    }
    //
    // Destroy the list of pins. The list will be destroyed when the
    // filter object is destroyed.
    //
    for (POSITION Position = m_PinList.GetHeadPosition(); Position; Position = m_PinList.Next(Position)) {
        delete m_PinList.Get(Position);
    }
    ::FreeMarshalers(&m_MarshalerList);

    if (m_DeviceRegKey) {
        RegCloseKey(m_DeviceRegKey);
    }

    if (m_PersistStreamDevice) {
        m_PersistStreamDevice->Release();
    }

    if (m_SymbolicLink) {
        SysFreeString(m_SymbolicLink);
    }

    //
    // Close down any EOS wait thread. This is done after shutting down
    // pins.
    //
    if (m_WaitThreadHandle) {
        m_WaitMessage.Message = STOP_EOS;
        SetEvent(m_WaitEvents[0]);
        //
        // Wait for the thread to shutdown, then close the handle.
        //
        WaitForSingleObjectEx(m_WaitThreadHandle, INFINITE, FALSE);
        CloseHandle(m_WaitThreadHandle);
        m_WaitThreadHandle = NULL;
    }
    //
    // Remove the waiter event list.
    //
    if (m_WaitEvents) {
        if (m_ActiveWaitEventCount) {
            //
            // The pins should have removed their events.
            //
            ASSERT(m_ActiveWaitEventCount == 1);
            CloseHandle(m_WaitEvents[0]);
        }
        delete [] m_WaitEvents;
        m_WaitEvents = NULL;
    }

    if (m_WaitPins) {
        delete [] m_WaitPins;
        m_WaitPins = NULL;
    }

    if (m_WaitReplyHandle) {
        CloseHandle(m_WaitReplyHandle);
    }

    DeleteCriticalSection(&m_IoThreadCriticalSection);

    //
    // Avoid an ASSERT() in the base object destructor
    //
    m_cRef = 0;
}


CBasePin*
CKsProxy::GetPin(
    int PinId
    )
/*++

Routine Description:

    Implements the CBaseFilter::GetPin method. Returns an unreferenced CBasePin
    object corresponding to the requested pin. This will only correspond to the
    Pin Factory Id on the filter driver if there is only a single instance
    of each pin which can be made, otherwise they will not. So essentially they
    have nothing to do with each other.

Arguments:

    PinId -
        The pin to retrieve, where the identifier is zero..(n-1), where n is
        the current number of pins provided by this proxy. The proxy creates
        a new instance each time a pin is connected, as long as the underlying
        filter driver supports more instances of that Pin Factory Id.

Return Value:

    Returns a CBasePin object pointer, else NULL if the range was invalid.

--*/
{
    POSITION    Position;

    //
    // Note that the Next and Get methods of the list template just start
    // returning NULL when the entries run out, so no special code is added
    // to check for this case.
    //
    // This is not guarded by a critical section since the interface
    // returned is not referenced. It is assumed the caller is synchronizing
    // with other access to the filter.
    //
    for (Position = m_PinList.GetHeadPosition(); PinId--;) {
        Position = m_PinList.Next(Position);
    }
    return m_PinList.Get(Position);
}


int
CKsProxy::GetPinCount(
    )
/*++

Routine Description:

    Implements the CBaseFilter::GetPinCount method. Returns the current number
    of pins on the filter proxy. This is the number of pins actually created on
    the underlying filter driver, plus an extra unconnected instance of each
    pin (as long as a new instance of that Pin Factory Id could possibly be
    created).

Arguments:

    None.

Return Value:

    Returns the number of pins. This is just the count of items in the list
    template used to store the list of pins.

--*/
{
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter.
    //
    return m_PinList.GetCount();
}


STDMETHODIMP_(HANDLE)
CKsProxy::KsGetObjectHandle(
    )
/*++

Routine Description:

    Implements the IKsObject::KsGetObjectHandle method. This is used both within
    this filter instance, and across filter instances in order to connect pins
    of two filter drivers together. It is the only interface which need be
    supported by another filter implementation to allow it to act as another
    proxy.

Arguments:

    None.

Return Value:

    Returns the handle to the underlying filter driver. This presumably is not
    NULL, as the instance was successfully created.

--*/
{
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter.
    //
    return m_FilterHandle;
}


STDMETHODIMP_(HANDLE)
CKsProxy::KsGetClockHandle(
    )
/*++

Routine Description:

    Implements the IKsClock::KsGetClockHandle method. This is used as a
    substitute for IKsObject::KsGetObjectHandle on the clock object. This is
    because both the filter and the clock each present the same interface,
    yet both are within this same object.

Arguments:

    None.

Return Value:

    Returns the handle to the clock.

--*/
{
    return m_PinClockHandle;
}



STDMETHODIMP
CKsProxy::StartIoThread(
    )

/*++

Routine Description:

    Creates the I/O thread.

Arguments:

    None.

Return Value:

    Returns S_OK or HRESULT of Win32 error.

--*/

{
    DWORD   LastError;

    //
    // Create the I/O thread for the filter.
    //
    
    if (m_IoThreadHandle) {
        return S_OK;
    }
    
    m_IoThreadHandle = 
        CreateThread( 
            NULL,               // LPSECURITY_ATTRIBUTES lpThreadAttributes
            0,                  // DWORD dwStackSize
            reinterpret_cast<LPTHREAD_START_ROUTINE>(IoThread),// LPTHREAD_START_ROUTINE lpStartAddress
            reinterpret_cast<LPVOID>(this),// LPVOID lpParameter
            0,                  // DWORD dwCreationFlags
            &m_IoThreadId );    // LPDWORD lpThreadId
            
    LastError = GetLastError();
    return (NULL == m_IoThreadHandle) ? HRESULT_FROM_WIN32( LastError ) : S_OK;
}    


STDMETHODIMP_(VOID) 
CKsProxy::EnterIoCriticalSection(
    )

/*++

Routine Description:

    Acquires the I/O thread's critical section.

Arguments:

    None.

Return Value:

    Nothing, I/O critical section is held.

--*/

{
    EnterCriticalSection(&m_IoThreadCriticalSection);
}


STDMETHODIMP_(VOID) 
CKsProxy::LeaveIoCriticalSection(
    )

/*++

Routine Description:

    Releases the I/O thread's critical section.

Arguments:

    None.

Return Value:

    Nothing, I/O critical section is released.

--*/

{
    LeaveCriticalSection(&m_IoThreadCriticalSection);
}

STDMETHODIMP_(ULONG) 
CKsProxy::GetFreeIoSlotCount(
    )

/*++

Routine Description:

    Returns the current count of free I/O slots.

Arguments:

    None.

Return Value:

    The count of free I/O slots.

--*/

{
    return MAXIMUM_WAIT_OBJECTS - m_ActiveIoEventCount;
}

STDMETHODIMP
CKsProxy::InsertIoSlot(
    IN PKSSTREAM_SEGMENT StreamSegment        
)

/*++

Routine Description:

    Inserts the stream segment and associated event handle in
    the I/O waiter queue. The m_pLock for the calling pin cannot be taken
    when calling this method.

Arguments:

    StreamSegment -
        pointer to the stream segment

Return Value:

    S_OK if inserted, otherwise E_FAIL.

--*/

{
    HRESULT hr;

    EnterIoCriticalSection();
    if (m_ActiveIoEventCount < MAXIMUM_WAIT_OBJECTS) {
        //
        // Add the segment to the event list.
        //
        m_IoSegments[ m_ActiveIoEventCount ] = StreamSegment;
        m_IoEvents[ m_ActiveIoEventCount ] = StreamSegment->CompletionEvent;
        m_ActiveIoEventCount++;
        //
        // Force the thread to wait for this new event.
        //
        SetEvent( m_IoEvents[ 0 ] );
        hr = S_OK;
    } else {
        //
        // There was no room, return failure.
        //
        hr = E_FAIL;
    }
    LeaveIoCriticalSection();
    return hr;
}

STDMETHODIMP_(VOID)
CKsProxy::WaitForIoSlot(
    )

/*++

Routine Description:
    Waits for a free I/O slot by checking the count of slots (in case
    a slot was freed during the call to this function) and then 
    waiting for the free slot event if no free slots are available.

Arguments:

    None.

Return Value:

    Nothing.

--*/

{
    //
    // Use a semaphore to maintain the active count.
    //    
    
    WaitForSingleObjectEx( m_IoFreeSlotSemaphore, INFINITE, FALSE );
}    


STDMETHODIMP
CKsProxy::SetSyncSource(
    IReferenceClock* RefClock
    )
/*++

Routine Description:

    Override the CBaseFilter::SetSyncSource method. This eventually calls
    CBaseFilter::SetSyncSource after determining if the clock source is a proxy
    for a kernel mode clock. If so, a handle on the actual clock is retrieved.
    If not, a kernel mode proxy for the clock is opened through the registered
    user mode clock forwarder. The forwarder supports the IKsClock interface,
    which is used to retrieve a handle on the kernel mode proxy.

    In either case, the handle is sent to each connected pin that cares about
    having a clock. If the reference clock was NULL, then a NULL is sent down
    so that all the pins now have no clock. When a new pin is connected, it
    gets any current clock set on it also. So the clock can be set before doing
    all the connections.

Arguments:

    RefClock -
        The interface pointer on the new clock source, else NULL if any current
        clock source is being abandoned.

Return Value:

    Returns S_OK if the clock could be used, else an error.

--*/
{
    HRESULT     hr;
    CAutoLock   AutoLock(m_pLock);

    //
    // If there is a new reference clock being set, then see if it supports the
    // IKsClock interface. This is the clue that this is somehow related to a
    // kernel mode implementation, whose handle can be given to other filter
    // drivers.
    //
    if (RefClock) {
        IKsObject*  ClockForwarder;
        HANDLE      ClockHandle;

        //
        // Check for the interface.
        //
        if (FAILED(hr = RefClock->QueryInterface(__uuidof(IKsClock), reinterpret_cast<PVOID*>(&ClockForwarder)))) {
            //
            // If it did not support the interface, then have a clock forwarder
            // loaded by the filter graph as a distributor. The graph will
            // instantiate a single instance of this object, and return an interface
            // to all those who query. An error must be returned on failure, as
            // the clock is then useless.
            //
            // There is no need to tell the clock what the sync source is, since
            // that will be done by the filter graph after notifying the filters.
            //
            if (FAILED(hr = GetFilterGraph()->QueryInterface(__uuidof(IKsClock), reinterpret_cast<PVOID*>(&ClockForwarder)))) {
                return hr;
            }
        }
        //
        // In either case, get the underlying clock handle. This will be sent to
        // each connected pin.
        //
        ClockHandle = ClockForwarder->KsGetObjectHandle();
        //
        // The interface to the distributor must be released immediately
        // so as to remove any circular reference count on the filter graph.
        // The interface is valid while the filter graph itself is valid.
        // Also, the interface is no longer needed.
        //
        ClockForwarder->Release();
        //
        // Don't worry about above failure in KsSetSyncSource until after trying to
        // get the handle and releasing the interface. Less code, and it won't do
        // any harm.
        //
        if (FAILED(hr)) {
            return hr;
        }
        
        //
        // This is now the external clock handle, which will be passed to any new
        // pin which is connected in the future.
        //
        m_ExternalClockHandle = ClockHandle;
    } else {
        //
        // Any previous reference clock is being abandoned, so pass a NULL down
        // to all the connected pins.
        //
        m_ExternalClockHandle = NULL;
    }
    for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
        HANDLE          PinHandle;
        PIN_DIRECTION   PinDirection;
        CBasePin*       Pin;

        //
        // If the pin is connected, then try to set the master clock handle on
        // it. If the pin does not care about the clock handle, this is OK.
        //
        Pin = m_PinList.Get(Position);
        Position = m_PinList.Next(Position);
        PinHandle = GetPinHandle(Pin);
        if (PinHandle && FAILED(hr = ::SetSyncSource(PinHandle, m_ExternalClockHandle))) {
            //
            // This leaves things in a halfway state, but ActiveMovie won't
            // allow things to be run anyway, since a failure was returned.
            //
            return hr;
        }
        //
        // Determine the type of object base on the data flow, and notify all
        // aggregated interfaces on the pin.
        //
        Pin->QueryDirection(&PinDirection);
        switch (PinDirection) {
        case PINDIR_INPUT:
            ::DistributeSetSyncSource(static_cast<CKsInputPin*>(Pin)->MarshalerList(), RefClock);
            break;
        case PINDIR_OUTPUT:
            static_cast<CKsOutputPin*>(Pin)->SetSyncSource(RefClock);
            ::DistributeSetSyncSource(static_cast<CKsOutputPin*>(Pin)->MarshalerList(), RefClock);
            break;
        }
    }
    //
    // Notify all aggregated interfaces on the filter.
    //
    ::DistributeSetSyncSource(&m_MarshalerList, RefClock);
    //
    // Let the base classes store the reference clock and increment the reference
    // count. This won't really fail.
    //
    return CBaseFilter::SetSyncSource(RefClock);
}


STDMETHODIMP
CKsProxy::Stop(
    )
/*++

Routine Description:

    Implement the IMediaFilter::Stop method. Distributes the Stop state to any
    aggregated interfaces on the filter before setting the state of the filter
    itself.

Arguments:

    None.

Return Value:

    Returns NOERROR.

--*/
{
    ::DistributeStop(&m_MarshalerList);
    CAutoLock cObjectLock(m_pLock);
    //
    // Do not call CBaseFilter::Stop() because it sets the actual filter state
    // after calling Inactive() on all the pins. This means that the filter
    // won't start rejecting data until after deactivating the pins, so any
    // flushing of queues that are done would not work. So instead just
    // do the base classes code, but set the state first.
    //
    // Notify all pins of the change to deactive state.
    //
    if (m_State != State_Stopped) {
        m_State = State_Stopped;
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin* Pin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            //
            // Bridge pins are not set to active state because the marshaling
            // flag is set to TRUE for them, and it would confuse things.
            //
            if (Pin->IsConnected()) {
                //
                // Disconnected pins are not Inactivated - this saves pins
                // worrying about this state themselves
                //
                Pin->Inactive();
            }
        }
    }
    return S_OK;
}


STDMETHODIMP
CKsProxy::Pause(
    )
/*++

Routine Description:

    Implement the IMediaFilter::Pause method. Distributes the Pause state to any
    aggregated interfaces on the filter before setting the state of the filter
    itself. This also sets the state on the pins to Pause if this is a transition
    from Run --> Pause.

Arguments:

    None.

Return Value:

    Returns NOERROR.

--*/
{

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Pause") ));

    ::DistributePause(&m_MarshalerList);
    if (m_State == State_Running) {
        //
        // Transition all the connected pins back to a Pause state.
        // They already are transitioned from Stop --> Pause when
        // the Active method is called, and from Pause or Run to
        // Stop when the Inactive method is called.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin* Pin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            HANDLE PinHandle = GetPinHandle(Pin);
            if (PinHandle) {
                PIN_DIRECTION   PinDirection;

                //
                // A transition from Run --> Pause cannot fail.
                //
                ::SetState(PinHandle, KSSTATE_PAUSE);
                //
                // Determine if this is an output pin, and therefore may
                // need the CBaseStreamControl notified.
                //
                Pin->QueryDirection(&PinDirection);
                if (PinDirection == PINDIR_OUTPUT) {
                    static_cast<CKsOutputPin*>(Pin)->NotifyFilterState(State_Paused);
                }
            }
        }
    }
    CAutoLock cObjectLock(m_pLock);
    //
    // Do not call CBaseFilter::Pause() because it sets the actual filter state
    // after calling Active() on all the pins. This means a call to IsStopped()
    // in QueueBuffersToDevice() will report TRUE, and data will not be queued.
    // Since IsStopped() is not a virtual function, it cannot be correctly
    // overridden where it is used from within the base classes. So instead just
    // do the base classes code, but set the state first.
    //
    // Notify all pins of the change to active state
    //
    FILTER_STATE OldState = m_State;
    m_State = State_Paused;
    if (OldState == State_Stopped) {
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin* Pin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            //
            // Bridge pins are not set to active state because the marshaling
            // flag is set to TRUE for them, and it would confuse things.
            //
            if (Pin->IsConnected()) {
                //
                // Disconnected pins are not activated - this saves pins
                // worrying about this state themselves
                //
                HRESULT hr = Pin->Active();
                if (FAILED(hr) || (S_FALSE == hr)) {
                    //
                    // The filter is in an odd state, but will be cleaned
                    // up when the Stop is received.
                    //
                    return hr;
                }
            }
        }
    }
    return S_OK;
}


STDMETHODIMP
CKsProxy::Run(
    REFERENCE_TIME Start
    )
/*++

Routine Description:

    Implement the IMediaFilter::Run method. Distributes the Run state to any
    aggregated interfaces on the filter before setting the state of the filter
    itself.

Arguments:

    None.

Return Value:

    Returns NOERROR.

--*/
{
    m_EndOfStreamCount = 0;
    ::DistributeRun(&m_MarshalerList, Start);
    return CBaseFilter::Run(Start);
}


STDMETHODIMP
CKsProxy::GetState(
    DWORD MSecs,
    FILTER_STATE* State
    )
/*++

Routine Description:

    Implement the IMediaFilter::GetState method. This allows a filter to
    indicate that it cannot pause.

Arguments:

    MSecs -
        Not used.

    State -
        The place in which to put the current state.

Return Value:

    Returns NOERROR, or VFW_S_CANT_CUE, E_POINTER

--*/
{
    HRESULT     hr;

    CheckPointer(State, E_POINTER);

    hr = NOERROR;
    //
    // If the filter is paused, then it may have to return the fact that it
    // cannot queue data.
    //
    if (m_State == State_Paused) {
        //
        // Enumerate the connected pins, asking each for it's current state.
        // Each pin has a chance to indicate that it cannot queue data, and
        // thus return VFW_S_CANT_CUE to the caller.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            HANDLE          PinHandle;

            PinHandle = GetPinHandle(m_PinList.Get(Position));
            Position = m_PinList.Next(Position);
            if (PinHandle) {
                KSSTATE     PinState;

                //
                // If one fails, then exit the loop after possibly translating
                // the error.
                //
                if (FAILED(hr = ::GetState(PinHandle, &PinState))) {
                    switch (hr) {
                    case HRESULT_FROM_WIN32(ERROR_NO_DATA_DETECTED):
                        hr = VFW_S_CANT_CUE;
                        break;

                    case HRESULT_FROM_WIN32(ERROR_NOT_READY):
                        hr = VFW_S_STATE_INTERMEDIATE;
                        break;

                    default:
                        break;
                    }
                    break;
                }
            }
        }
    }
    //
    // The state is always returned, no matter what error may have occurred.
    //
    *State = m_State;
    return hr;
}


STDMETHODIMP
CKsProxy::JoinFilterGraph(
    IFilterGraph* Graph,
    LPCWSTR Name
    )
/*++

Routine Description:

    Implement the IBaseFilter::JoinFilterGraph method. Intercepts graph changes
    so that the quality forwarder can be loaded if needed.

Arguments:

    Graph -
        Contains either the new graph to join, or NULL.

    Name -
        Contains the name the filter will use in the context of this graph.

Return Value:

    Returns the results of CBaseFilter::JoinFilterGraph.

--*/
{
    HRESULT hr;

    if (m_QualityForwarder) {
        m_QualityForwarder = NULL;
    }
    hr = CBaseFilter::JoinFilterGraph(Graph, Name);
    if (SUCCEEDED(hr)) {
        if (Graph) {
            //
            // Notify the CBaseStreamControl of the graph.
            //
            for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
                PIN_DIRECTION   PinDirection;
                CBasePin*       Pin;

                Pin = m_PinList.Get(Position);
                Position = m_PinList.Next(Position);
                Pin->QueryDirection(&PinDirection);
                if (PinDirection == PINDIR_OUTPUT) {
                    static_cast<CKsOutputPin*>(Pin)->SetFilterGraph(m_pSink);
                }
            }
            //
            // Use the filter graph to load the quality manager proxy as a distributor.
            // The graph will instantiate a single instance of this object, and return
            // an interface to all those who query. If there is no proxy registered,
            // then the filter pins cannot generate quality management complaints. The
            // pin may still be able to accept quality management control though.
            //
            if (SUCCEEDED(GetFilterGraph()->QueryInterface(__uuidof(IKsQualityForwarder), reinterpret_cast<PVOID*>(&m_QualityForwarder)))) {
                //
                // The interface to the distributor must be released immediately
                // so as to remove any circular reference count on the filter graph.
                // The interface is valid while the filter graph itself is valid.
                //
                m_QualityForwarder->Release();
            }
        }
    }
    return hr;
}


STDMETHODIMP
CKsProxy::FindPin(
    LPCWSTR Id,
    IPin** Pin
    )
/*++

Routine Description:

    Implement the IBaseFilter::FindPin method. This overrides CBaseFilter::FindPin.
    The base class implementation assumes that the pin identifier is equivalent
    to the pin name. This means that for kernel filters which do not expose
    explicit pin names, and have a single topology node, the save/load of graphs
    will not work properly, since the wrong pins will attempt to be connected
    because the pins will have the same name, and thus the same identifier.

Arguments:

    Id -
        The unique pin identifier to find.

    Pin -
        The place in which to return the referenced IPin interface, if found.

Return Value:

    Returns NOERROR, VFW_E_NOT_FOUND, E_POINTER

--*/
{
    CAutoLock AutoLock(m_pLock);
    ULONG PinId;
    ULONG ScannedItems;

    CheckPointer( Pin, E_POINTER ); // #318075

    //
    // The pin identifier should be an unsigned integer, which is a pin factory.
    // The CRT function appears to be broken, and traps if the string does not
    // contain a number, rather than just not scanning.
    //
    _try {
        ScannedItems = swscanf(Id, L"%u", &PinId);
    } _except (EXCEPTION_EXECUTE_HANDLER) {
        ScannedItems = 0;
    }
    if (ScannedItems == 1) {
        //
        // Enumerate through the list of pins. If multiple instances of a
        // particular pin factory exist, then there will be duplicates, and
        // only the first will be returned. This is OK for graph building,
        // since new instances are inserted on the front of the list, and
        // they will be found first.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin* BasePin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            if (GetPinFactoryId(BasePin) == PinId) {
                //
                // The caller expects that the returned pin has been referenced.
                //
                BasePin->AddRef();
                *Pin = BasePin;
                return S_OK;
            }
        }
    }
    //
    // The identifier did not match any pin, or was not constructed properly.
    //
    *Pin = NULL;
    return VFW_E_NOT_FOUND;
}


STDMETHODIMP
CKsProxy::GetPages(
    CAUUID* Pages
    ) 
/*++

Routine Description:

    Implement the ISpecifyPropertyPages::GetPages method. This adds property
    pages based on the interface class of the device.

Arguments:

    Pages -
        The structure to fill in with the page list.

Return Value:

    Returns NOERROR, else a memory allocation error. Fills in the list of pages
    and page count.

--*/
{
    ULONG       SetDataSize;
    GUID*       GuidList;

	CheckPointer( Pages, E_POINTER); //#318075
	
    Pages->cElems = 0; 
    Pages->pElems = NULL;
    ::CollectAllSets(m_FilterHandle, &GuidList, &SetDataSize);
    if (!SetDataSize) {
        return NOERROR;
    }
    ::AppendSpecificPropertyPages(
        Pages,
        SetDataSize,
        GuidList,
        TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaSets"),
        m_DeviceRegKey);
    delete [] GuidList;
    return NOERROR;
} 


STDMETHODIMP
CKsProxy::QueryInterface(
    REFIID riid,
    PVOID* ppv
    )
/*++

Routine Description:

    Implement the IUnknown::QueryInterface method. This just passes the query
    to the owner IUnknown object, which may pass it to the nondelegating
    method implemented on this object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE.

--*/
{
    return GetOwner()->QueryInterface(riid, ppv);
}


STDMETHODIMP_(ULONG)
CKsProxy::AddRef(
    )
/*++

Routine Description:

    Implement the IUnknown::AddRef method. This just passes the AddRef
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    return GetOwner()->AddRef();
}


STDMETHODIMP_(ULONG)
CKsProxy::Release(
    )
/*++

Routine Description:

    Implement the IUnknown::Release method. This just passes the Release
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    return GetOwner()->Release();
}


STDMETHODIMP
CKsProxy::NonDelegatingQueryInterface(
    REFIID riid,
    PVOID* ppv
    )
/*++

Routine Description:

    Implement the CUnknown::NonDelegatingQueryInterface method. This
    returns interfaces supported by this object, or by the underlying
    filter class object. This includes any interface aggregated by the
    filter.

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE, or possibly some memory error.

--*/
{
	CheckPointer( ppv, E_POINTER ); // #318075
	
    if (riid == __uuidof(ISpecifyPropertyPages)) {
        return GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv);
    } else if (riid == __uuidof(IMediaSeeking)) {
        return GetInterface(static_cast<IMediaSeeking*>(this), ppv);
    } else if (riid == __uuidof(IKsObject)) {
        return GetInterface(static_cast<IKsObject*>(this), ppv);
    } else if (riid == __uuidof(IKsPropertySet)) {
        return GetInterface(static_cast<IKsPropertySet*>(this), ppv);
    } else if (riid == __uuidof(IKsControl)) {
        return GetInterface(static_cast<IKsControl*>(this), ppv);
    } else if (riid == __uuidof(IKsAggregateControl)) {
        return GetInterface(static_cast<IKsAggregateControl*>(this), ppv);
    } else if (riid == __uuidof(IKsTopology)) {
        return GetInterface(static_cast<IKsTopology*>(this), ppv);
    } else if (riid == __uuidof(IAMFilterMiscFlags)) {
        return GetInterface(static_cast<IAMFilterMiscFlags*>(this), ppv);
#ifdef DEVICE_REMOVAL
    } else if (riid == __uuidof(IAMDeviceRemoval)) {
        return GetInterface(static_cast<IAMDeviceRemoval*>(this), ppv);
#endif // DEVICE_REMOVAL
    } else if (m_PinClockSource && ((riid == __uuidof(IReferenceClock)) || (riid == __uuidof(IKsClockPropertySet)))) {
        CAutoLock   AutoLock(m_pLock);

        //
        // If there is a clock supported by some pin on this filter, then
        // try to return the interface. The interface can only be returned
        // if the pin is actually connected at this time. The best
        // candidate will have already been selected by this point, so if
        // this pin is not connected, then no other pin will work either.
        //
        // This needs to be serialized so that parallel queries do not
        // generate multiple instances.
        //
        if (!m_PinClockHandle) {
            if (FAILED(CreateClockHandle())) {
                return E_NOINTERFACE;
            }
        }
        //
        // The interface will automatically stop working if the pin is
        // disconnected. It will start working again if some other pin
        // which supports a clock is later connected.
        //
        if (riid == __uuidof(IReferenceClock)) {
            return GetInterface(static_cast<IReferenceClock*>(this), ppv);
        } else {
            return GetInterface(static_cast<IKsClockPropertySet*>(this), ppv);
        }
    } else if (m_PinClockHandle && (riid == __uuidof(IKsClock))) {
        //
        // Note that this is really an alias for IKsObject interface for
        // the clock object.
        //
        return GetInterface(static_cast<IKsClock*>(this), ppv);
    } else if (riid == __uuidof(IPersistPropertyBag)) {
        return GetInterface(static_cast<IPersistPropertyBag*>(this), ppv);
    } else if (riid == __uuidof(IPersist)) {
        return GetInterface(static_cast<IPersist*>(static_cast<IBaseFilter*>(this)), ppv);
    } else if (riid == __uuidof(IPersistStream)) {
        return GetInterface(static_cast<IPersistStream*>(this), ppv);
    } else {
        HRESULT hr;

        hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
        if (SUCCEEDED(hr)) {
            return hr;
        }
    }
    //
    // Search the list of aggregated objects.
    //
    for (POSITION Position = m_MarshalerList.GetHeadPosition(); Position;) {
        CAggregateMarshaler*    Aggregate;

        Aggregate = m_MarshalerList.Get(Position);
        Position = m_MarshalerList.Next(Position);
        if ((Aggregate->m_iid == riid) || (Aggregate->m_iid == GUID_NULL)) {
            HRESULT hr;

            hr = Aggregate->m_Unknown->QueryInterface(riid, ppv);
            if (SUCCEEDED(hr)) {
                return hr;
            }
        }
    }
    return E_NOINTERFACE;
}
        

STDMETHODIMP
CKsProxy::CreateClockHandle(
    )
/*++

Routine Description:

    Implement the CKsProxy::CreateClockHandle method. This attempts to
    create a clock handle on the currently selected pin clock source.
    This assumes that no clock handle is currently open, as it writes
    over the current clock handle member. It does however check to see
    if the pin is connected by checking for a pin handle. A clock handle
    cannot be created on a pin unless the pin is connected.

Arguments:

    None.

Return Value:

    Returns NOERROR or E_FAIL.

--*/
{
    HRESULT     hr;
    HANDLE      PinHandle;

    //
    // The clock may have gone away while the IReferenceClock interface
    // was being held, so a new query would attempt to create the clock
    // again. Fail this.
    //
    if (!m_PinClockSource) {
        return E_NOTIMPL;
    }
    PinHandle = GetPinHandle(m_PinClockSource);
    //
    // Only allow a creation attempt if the pin is connected, since
    // there would not otherwise be a handle to send the creation request
    // to.
    //
    if (PinHandle) {
        KSCLOCK_CREATE  ClockCreate;
        DWORD           Error;

        ClockCreate.CreateFlags = 0;

        if ( m_PinClockHandle ) {
        	//
        	// #318077.  should probably reuse this handle. but to be on safe
        	// side of regression, close the old one so we are running the same
        	// code as before. Inside ksproxy, we always make sure
        	// m_PinCLockHandle is null before calling this Create function.
        	// The concerns are calls from external and future new codes.
        	//
        	ASSERT( 0 && "This would have been a leak without this new code" );
        	CloseHandle(m_PinClockHandle);
        }
        
        Error = KsCreateClock(PinHandle, &ClockCreate, &m_PinClockHandle);
        hr = HRESULT_FROM_WIN32(Error);
        if (FAILED(hr)) {
            m_PinClockHandle = NULL;
        }
    } else {
        hr = E_NOTIMPL;
    }
    return hr;
}


STDMETHODIMP
CKsProxy::DetermineClockSource(
    )
/*++

Routine Description:

    Implement the CKsProxy::DetermineClockSource method. This attempts to
    find a pin on this filter which will support a clock. It looks for pins
    which are connected, since those are the only pins which can be queried.
    It then makes Bridge pins higher preference over any other pins. Presumably
    a filter graph would work better synchronizing to some endpoint rather than
    a random point inbetween.

    This function will only have been called if an actual clock handle has not
    already been created on a clock source. This means that the underlying
    clock is free to be changed. In specific, this is currently only being
    called when pin instances are regenerated.

Arguments:

    None.

Return Value:

    Returns NOERROR.

--*/
{
    KSPROPERTY  Property;
    ULONG       BasicSupport;
    ULONG       BytesReturned;

    //
    // Initialize this once.
    //
    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_MASTERCLOCK;
    Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
    //
    // By default there is no clock supported.
    //
    m_PinClockSource = NULL;
    for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
        CBasePin*           Pin;
        ULONG               PinFactoryId;
        HANDLE              PinHandle;
        KSPIN_COMMUNICATION Communication;

        //
        // Enumerate each pin, figuring out which type of class it is based
        // on the data direction. Store the Pin Factory Id to query the
        // communications type with, and the pin handle, if any.
        //
        Pin = m_PinList.Get(Position);
        Position = m_PinList.Next(Position);
        PinFactoryId = GetPinFactoryId(Pin);
        PinHandle = GetPinHandle(Pin);
        if (SUCCEEDED(GetPinFactoryCommunication(PinFactoryId, &Communication))) {
            //
            // If this pin is connected, then query this as a clock source if
            // there is not already a clock source selected, or if this is a Bridge
            // (a Bridge takes precedence).
            //
            if (PinHandle && (!m_PinClockSource || (Communication & KSPIN_COMMUNICATION_BRIDGE))) {
                HRESULT hr;

                //
                // Support of a Get on the MasterClock property indicates that
                // a pin can support providing a clock handle, and thus be used
                // to synchronize the filter graph.
                //
                hr = ::KsSynchronousDeviceControl(
                    PinHandle,
                    IOCTL_KS_PROPERTY,
                    &Property,
                    sizeof(Property),
                    &BasicSupport,
                    sizeof(BasicSupport),
                    &BytesReturned);
                if (SUCCEEDED(hr) && (BasicSupport & KSPROPERTY_TYPE_GET)) {
                    m_PinClockSource = Pin;
                }
            }
        }
    }
    return NOERROR;
}


STDMETHODIMP
CKsProxy::GetPinFactoryCount(
    PULONG PinFactoryCount
    )
/*++

Routine Description:

    Implement the CKsProxy::GetPinFactoryCount method. This queries the filter
    driver for the number of Pin Factory Id's supported.

Arguments:

    PinFactoryCount -
        The place in which to put the count of Pin Factory Id's supported by
        the filter driver.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Pin;
    Property.Id = KSPROPERTY_PIN_CTYPES;
    Property.Flags = KSPROPERTY_TYPE_GET;
    return ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        PinFactoryCount,
        sizeof(*PinFactoryCount),
        &BytesReturned);
}


STDMETHODIMP
CKsProxy::GetPinFactoryDataFlow(
    ULONG PinFactoryId,
    PKSPIN_DATAFLOW DataFlow
    )
/*++

Routine Description:

    Implement the CKsProxy::GetPinFactoryDataFlow method. This queries the
    filter driver for the data flow of a specific Pin Factory Id.

Arguments:

    PinFactoryId -
        Contains the Pin Factory Id to use in the query.

    DataFlow -
        The place in which to put the Data Flow.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSP_PIN     Pin;
    ULONG       BytesReturned;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_DATAFLOW;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinFactoryId;
    Pin.Reserved = 0;
    return ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Pin,
        sizeof(Pin),
        DataFlow,
        sizeof(*DataFlow),
        &BytesReturned);
}
    

STDMETHODIMP
CKsProxy::GetPinFactoryInstances(
    ULONG PinFactoryId,
    PKSPIN_CINSTANCES Instances
    )
/*++

Routine Description:

    Implement the CKsProxy::GetPinFactoryInstances method. This queries the
    filter driver for the instances of a specific Pin Factory Id.

Arguments:

    PinFactoryId -
        Contains the Pin Factory Id to use in the query.

    Instances -
        The place in which to put the Instances.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    return ::GetPinFactoryInstances(m_FilterHandle, PinFactoryId, Instances);
}


STDMETHODIMP
CKsProxy::GetPinFactoryCommunication(
    ULONG PinFactoryId,
    PKSPIN_COMMUNICATION Communication
    )
/*++

Routine Description:

    Implement the CKsProxy::GetPinFactoryCommunication method. This queries
    the filter driver for the communication of a specific Pin Factory Id.

Arguments:

    PinFactoryId -
        Contains the Pin Factory Id to use in the query.

    Communication -
        The place in which to put the Communication.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSP_PIN     Pin;
    ULONG       BytesReturned;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_COMMUNICATION;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinFactoryId;
    Pin.Reserved = 0;
    return ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Pin,
        sizeof(Pin),
        Communication,
        sizeof(*Communication),
        &BytesReturned);
}


STDMETHODIMP
CKsProxy::GeneratePinInstances(
    )
/*++

Routine Description:

    Implement the CKsProxy::GeneratePinInstances method. This determines when
    to create a new instance of a pin on the proxy. This is based on the
    current instances representing a particular Pin Factory Id, if there is
    more than one unconnected instance, and how many more instances the filter
    driver reports that it can support. This allows pins to come into being
    on the fly as actual connections are made, and to be removed as pins are
    disconnected.

    It first enumerates the list of pins to determine if there are any extra
    unconnected instances. This would happen if a pin was just disconnected,
    and there was already an unconnected instance present. In that case one
    of them is destroyed. This is also where any pins whose Pin Factory has
    disappeared are removed (for the case of dynamic Pin Factories).

    It then determines if any new instance of a particular Pin Factory Id
    needs to be created. This would need to be done if no unconnected instance
    existed, and the filter driver reported that it could support more
    instances of that Pin Factory Id. A special case is that of a pin which
    reports zero allowable instances. In this case a single pin is still
    create so that is can be seen.

    Lastly the source for the clock is recalculated, if any.

Arguments:

    None.

Return Value:

    Returns NOERROR, else E_FAIL if the factory count could not be obtained.

--*/
{
    HRESULT     hr;
    ULONG       PinFactoryCount;
    ULONG       TotalPinFactories;
    BOOL        ClockHandleWasClosed;

    //
    // This is really the only fatal error which can happen. Others are ignored
    // so that at least something is created.
    //
    if (FAILED(hr = GetPinFactoryCount(&TotalPinFactories))) {
        return hr;
    }
    ClockHandleWasClosed = FALSE;
    //
    // For each Pin Factory Id, destroy any extra pin instances, then determine
    // if any new instance should be created.
    //
    for (PinFactoryCount = TotalPinFactories; PinFactoryCount--;) {
        POSITION            UnconnectedPosition;
        KSPIN_CINSTANCES    Instances;
        ULONG               InstanceCount;

        //
        // Default this to zero in case it fails for some unknown reason
        // so that the pins can be cleaned up.
        //
        if (FAILED(GetPinFactoryInstances(PinFactoryCount, &Instances))) {
            ASSERT(FALSE);
            Instances.PossibleCount = 0;
            // Instances.CurrentCount = 0; <-- This is not used.
        }
        //
        // Keep track of the number of instances of this pin factory so
        // that the number can be compared against the maximum allowed,
        // and extra unconnected items can be destroyed.
        //
        InstanceCount = 0;
        //
        // This will be used to determine if any unconnected instance already
        // exists.
        //
        UnconnectedPosition = NULL;
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin*       Pin;
            ULONG           PinFactoryId;
            HANDLE          PinHandle;

            //
            // Enumerate the list of pins, looking for this particular
            // Pin Factory Id.
            //
            Pin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            PinFactoryId = GetPinFactoryId(Pin);
            PinHandle = GetPinHandle(Pin);
            //
            // This is the count of total items found, whether or not they
            // are connected.
            //
            if (PinFactoryId == PinFactoryCount) {
                InstanceCount++;
            }
            //
            // The only way to check for actual connection is by looking
            // at the pin handle, since a Bridge may be connected, but
            // does not have an associated Pin it is connected to.
            //
            if (!PinHandle) {
                //
                // If this pin had been providing the clock source, but
                // it got closed, then ensure that the clock handle is
                // closed too. This is done whether or not the pin will
                // be destroyed. The m_PinClockSource is left as is,
                // since it will be recalculated later anyway. This means
                // that the function only exits at the bottom.
                //
                if (m_PinClockHandle && (m_PinClockSource == Pin)) {
                    CloseHandle(m_PinClockHandle);
                    m_PinClockHandle = NULL;
                    //
                    // Make a new clock source be chosen at the end of pin
                    // generation.
                    //
                    ClockHandleWasClosed = TRUE;
                }
                //
                // If this pin is an instance of the current Pin Factory
                // Id, then determine if it is an extra.
                //
                if (PinFactoryId == PinFactoryCount) {
                    if (UnconnectedPosition) {
                        PIN_DIRECTION   PinDirection;
                        ULONG           RefCount;

                        //
                        // First obtain the relative reference count on the
                        // pin. This has been kept separate from the normal
                        // reference count, which is actually a count on the
                        // filter itself. This can be used to determine if
                        // a pin interface is actually in use. This is
                        // initially set to 1, and is decremented when the
                        // pin is expected to be destroyed. The pin destroys
                        // itself when the decrement happens.
                        //
                        Pin->QueryDirection(&PinDirection);
                        switch (PinDirection) {
                        case PINDIR_INPUT:
                            RefCount = static_cast<CKsInputPin*>(Pin)->m_RelativeRefCount;
                            break;
                        case PINDIR_OUTPUT:
                            RefCount = static_cast<CKsOutputPin*>(Pin)->m_RelativeRefCount;
                            break;
                        }
                        //
                        // An unconnected instance was already found,
                        // so this one must be deleted, or the one already
                        // found must be deleted. The reason there could
                        // be two unconnected instances is that one is
                        // currently being disconnected, but another
                        // unconnected instance was already created. Since
                        // the first one still may be reference counted, don't
                        // delete it. This would happen with a TryMediaTypes.
                        //
                        if (RefCount > 1) {
                            //
                            // This is the real unconnected instance to save,
                            // so delete any other one found. This should
                            // not happen again for this pin.
                            //
                            Pin = m_PinList.Remove(UnconnectedPosition);
                            UnconnectedPosition = m_PinList.Prev(Position);
                        } else {
                            Pin = m_PinList.Remove(m_PinList.Prev(Position));
                        }
                        //
                        // Reduce the instances found of this pin factory.
                        //
                        InstanceCount--;
                    } else {
                        UnconnectedPosition = m_PinList.Prev(Position);
                        //
                        // Indicate a pin is not to be removed.
                        //
                        Pin = NULL;
                    }
                } else if (PinFactoryId >= TotalPinFactories) {
                    //
                    // Remove any pins whose Pin Factory has disappeared.
                    // The assumption is that this code will always be
                    // reached, because a filter will always have at least
                    // one pin, and therefore old pins can be found and
                    // removed.
                    //
                    m_PinList.Remove(m_PinList.Prev(Position));
                } else {
                    //
                    // Indicate a pin is not to be removed.
                    //
                    Pin = NULL;
                }
                //
                // This is set to NULL if a pin is not to be removed, else
                // it contains the pin to dereference, and possibly delete.
                //
                if (Pin) {
                    PIN_DIRECTION   PinDirection;

                    //
                    // This pin should only be deleted if it has been disconnected.
                    // An initial refcount of 1 was placed on each pin, and removed
                    // here on removal from the pin list. This is check in IUnknown
                    // for later deletion if not deleted here.
                    //
                    Pin->QueryDirection(&PinDirection);
                    switch (PinDirection) {
                    case PINDIR_INPUT:
	                    if (InterlockedDecrement((PLONG)&(static_cast<CKsInputPin*>(Pin)
                        		->m_RelativeRefCount)) == 0) {
                            delete Pin;
                        }
                        else {
                            ::DerefPipeFromPin(static_cast<IPin*>(Pin) );
                        }
                        break;
                    case PINDIR_OUTPUT:
                        if (InterlockedDecrement((PLONG)&(static_cast<CKsOutputPin*>(Pin)
                        		->m_RelativeRefCount)) == 0) {
                            delete Pin;
                        }
                        else {
                            ::DerefPipeFromPin(static_cast<IPin*>(Pin) );
                        }
                        break;
                    }
                }
            }
        }
        //
        // If there is no unconnected instance, and more instances can be
        // supported by this Pin Factory Id, then make one. Note that
        // KSINSTANCE_INDETERMINATE == ((ULONG)-1), so this comparison
        // works for the indeterminate case also. Note the special case for
        // a pin which does not allow any instances. Another pin is only
        // created if there is not already a connected instance.
        //
        // Do not rely on Instances.CurrentCount to reflect the number of
        // connected pins in this instance, as in badly constructed filters
        // it appears to represent all instances.
        //
        if (((InstanceCount < Instances.PossibleCount) || !(InstanceCount | Instances.PossibleCount)) && !UnconnectedPosition) {
            CBasePin*       Pin;
            KSPIN_DATAFLOW  DataFlow;
            WCHAR*          PinName;

            if (FAILED(GetPinFactoryDataFlow(PinFactoryCount, &DataFlow))) {
                continue;
            }
            //
            // The displayed name of the pin be registered based on the Topology
            // connection.
            //
            if (FAILED(ConstructPinName(PinFactoryCount, DataFlow, &PinName))) {
                continue;
            }
            
            //
            // The type of object created depends on the data flow. Full duplex
            // is not supported.
            //
            
            hr = S_OK;
            switch (DataFlow) {
            case KSPIN_DATAFLOW_IN:
                Pin = new CKsInputPin(TEXT("InputProxyPin"), PinFactoryCount, m_clsid, static_cast<CKsProxy*>(this), &hr, PinName);
                break;
            case KSPIN_DATAFLOW_OUT:
                Pin = new CKsOutputPin(TEXT("OutputProxyPin"), PinFactoryCount, m_clsid, static_cast<CKsProxy*>(this), &hr, PinName);
                break;
            default:
                Pin = NULL;
                break;
            }
            delete [] PinName;
            if (Pin) {
                if (SUCCEEDED(hr)) {
                    m_PinList.AddHead(Pin);
                } else {
                    delete Pin;
                }
            }
        } else if ((InstanceCount > Instances.PossibleCount) && Instances.PossibleCount && UnconnectedPosition) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            //
            // Delete the unconnected instance present if it pushes the limit
            // of possible pin instances for this pin factory. This could happen
            // for dynamically changing limits. However, an exception is made
            // for pins which report that they can create no instances at all.
            //
            Pin = m_PinList.Remove(UnconnectedPosition);
            Pin->QueryDirection(&PinDirection);
            switch (PinDirection) {
            case PINDIR_INPUT:
                if (InterlockedDecrement((PLONG)&(static_cast<CKsInputPin*>(Pin)
                		->m_RelativeRefCount)) == 0) {
                    delete Pin;
                }
                else {
                    ::DerefPipeFromPin(static_cast<IPin*>(Pin) );
                }
                break;
            case PINDIR_OUTPUT:
                if (InterlockedDecrement((PLONG)&(static_cast<CKsOutputPin*>(Pin)
                		->m_RelativeRefCount)) == 0) {
                    delete Pin;
                }
                else {
                    ::DerefPipeFromPin(static_cast<IPin*>(Pin) );
                }
                break;
            }
        }
    }
    //
    // Only if there is not already a handle can the clock source be recalculated.
    // If there is still a handle, it means the pin is still connected, and could have
    // events enabled, though that is doubtful. DetermineClockSource also expects
    // that any old clock handle has been closed already.
    //
    if (!m_PinClockHandle) {
        DetermineClockSource();
    }
    //
    // If the clock handle was closed during this time, then ensure the graph
    // picks a new source. This does not set the source back to this filter
    // again if the pin is reconnected, but by then it may have been explicitly
    // set to another filter anyway.
    //
    if (ClockHandleWasClosed) {
        NotifyEvent( EC_CLOCK_UNSET, 0, 0 );
    }
    //
    // Send a change notification to all the aggregates so that they
    // can load interfaces on pins, now that the pins exist.
    //
    ::DistributeNotifyGraphChange(&m_MarshalerList);
    return NOERROR;
}


STDMETHODIMP
CKsProxy::ConstructPinName(
    ULONG PinFactoryId,
    KSPIN_DATAFLOW DataFlow,
    WCHAR** PinName
    )
/*++

Routine Description:

    Implement the CKsProxy::ConstructPinName method. Constructs the name for
    a pin based on either the name returned by the Pin Factory, or the Topology
    of the filter, and the names registered for the Topology. Returns a default
    name if no Pin, Topology or registered name exists.

Arguments:

    PinFactoryId -
        The Pin Factory Identifier which a name is to be returned for. This
        is the pin whose name or Topology connection is to be determined in
        order to look up a name.

    DataFlow -
        Data flow of the Pin Factory, which is used in the default naming
        case where a specific Topology-based name is not available.

    PinName -
        The place in which to put a pointer to allocated memory containing
        the pin name. This is only valid if the function succeeds, and must
        be deleted.

Return Value:

    Returns NOERROR if the names were constructed, else E_OUTOFMEMORY or E_POINTER

--*/
{
    HRESULT             hr;
    PKSMULTIPLE_ITEM    MultipleItem = NULL;
    KSP_PIN             PinProp;
    ULONG               BytesReturned;

	CheckPointer( PinName, E_POINTER ); // #318075
    //
    // Try to find a name value for this pin based on the pin factory.
    // Query for the length of the name, then the name.
    //
    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = KSPROPERTY_PIN_NAME;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = PinFactoryId;
    PinProp.Reserved = 0;
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        NULL,
        0,
        &BytesReturned);
    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        *PinName = new WCHAR[BytesReturned / sizeof(**PinName)];
        if (*PinName) {
            hr = ::KsSynchronousDeviceControl(
                m_FilterHandle,
                IOCTL_KS_PROPERTY,
                &PinProp,
                sizeof(PinProp),
                *PinName,
                BytesReturned,
                &BytesReturned);
            if (FAILED(hr)) {
                delete [] *PinName;
            } else {
                return NOERROR;
            }
        }
    }
    //
    // If finding the pin name from the pin itself fails, then find it
    // from the topology.
    //
    if (SUCCEEDED(hr = QueryTopologyItems(KSPROPERTY_TOPOLOGY_CONNECTIONS, &MultipleItem))) {
        PKSTOPOLOGY_CONNECTION  Connection;
        ULONG                   ConnectionItem;

        // MultipleItem could be NULL only in the pathological case where the
        // driver underlying the filter/pin returned a success code to 
        // KsSynchronousDeviceControl() (called by QueryTopologyItems()) when
        // passed a size 0 buffer.
        ASSERT( NULL != MultipleItem );

        //
        // After exiting this loop, failure is checked to determine if default
        // names should be constructed when locating a valid topology did
        // not work out.
        //
        hr = E_FAIL;
        Connection = reinterpret_cast<PKSTOPOLOGY_CONNECTION>(MultipleItem + 1);
        //
        // Enumerate all the topology connections to find one that refers to
        // this pin factory. If one is found, then look up any associated
        // name for the pin on the category node. If that fails, then move
        // on to the next connection in the list, as there may be multiple
        // connections to this pin factory. This means the first connection
        // found with a named pin in a category node will be the one returned.
        //
        
        for (ConnectionItem = 0; ConnectionItem < MultipleItem->Count; ConnectionItem++) {
            ULONG   TopologyNode;

            //
            // The inner loop just enumerates each connection, looking for
            // either an input or output pin on a category node which is
            // connected to this pin factory.
            //
            for (; ConnectionItem < MultipleItem->Count; ConnectionItem++) {
                //
                // Only look at connections which flow in the correct direction.
                //
                if (DataFlow == KSPIN_DATAFLOW_IN) {
                    //
                    // If this is a connection to this pin factory, and the
                    // connection is not just to another pin factory, then
                    // check this connection.
                    //
                    if ((Connection[ConnectionItem].FromNode == KSFILTER_NODE) &&
                        (Connection[ConnectionItem].FromNodePin == PinFactoryId) &&
                        (Connection[ConnectionItem].ToNode != KSFILTER_NODE)) {
                        //
                        // Save the item found, and exit the inner loop.
                        //
                        TopologyNode = Connection[ConnectionItem].ToNode;
                        break;
                    }
                } else if (DataFlow == KSPIN_DATAFLOW_OUT) {
                    if ((Connection[ConnectionItem].ToNode == KSFILTER_NODE) &&
                        (Connection[ConnectionItem].ToNodePin == PinFactoryId) &&
                        (Connection[ConnectionItem].FromNode != KSFILTER_NODE)) {
                        //
                        // Save the item found, and exit the inner loop.
                        //
                        TopologyNode = Connection[ConnectionItem].FromNode;
                        break;
                    }
                }
            }
            //
            // Determine if the inner loop was exited early with a candidate
            // connection structure.
            //
            if (ConnectionItem < MultipleItem->Count) {
                KSP_NODE    NameProp;

                //
                // Try to find a name value for this pin based on the node.
                // Query for the length of the name, then the name.
                //
                NameProp.Property.Set = KSPROPSETID_Topology;
                NameProp.Property.Id = KSPROPERTY_TOPOLOGY_NAME;
                NameProp.Property.Flags = KSPROPERTY_TYPE_GET;
                NameProp.NodeId = TopologyNode;
                NameProp.Reserved = 0;
                hr = ::KsSynchronousDeviceControl(
                    m_FilterHandle,
                    IOCTL_KS_PROPERTY,
                    &NameProp,
                    sizeof(NameProp),
                    NULL,
                    0,
                    &BytesReturned);
                //
                // A zero length name does not work.
                //
                if (SUCCEEDED(hr)) {
                    continue;
                }
                if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
                    *PinName = new WCHAR[BytesReturned / sizeof(**PinName)];
                    if (*PinName) {
                        hr = ::KsSynchronousDeviceControl(
                            m_FilterHandle,
                            IOCTL_KS_PROPERTY,
                            &NameProp,
                            sizeof(NameProp),
                            *PinName,
                            BytesReturned,
                            &BytesReturned);
                        if (FAILED(hr)) {
                            delete [] *PinName;
                        }
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                }
                //
                // Since the name was found, exit the outer loop, rather than
                // continuing on with the next connection node.
                //
                if (SUCCEEDED(hr)) {
                    break;
                }
            }
        }
        delete [] reinterpret_cast<BYTE*>(MultipleItem);
    }
    //
    // If the above attempt failed, then construct a default name.
    // This is just based on the data flow of the pin factory. Note that
    // these defaults are not localized.
    //
    if (FAILED(hr)) {
        *PinName = new WCHAR[32];

        if (!*PinName) {
            return E_OUTOFMEMORY;
        }
        switch (DataFlow) {
        case KSPIN_DATAFLOW_IN:
            swprintf(*PinName, L"Input%u", PinFactoryId);
            break;
        case KSPIN_DATAFLOW_OUT:
            swprintf(*PinName, L"Output%u", PinFactoryId);
            break;
        }
    }
    return NOERROR;
}


STDMETHODIMP
CKsProxy::PropagateAcquire(
    IKsPin* KsPin,
    ULONG FlagStarted
    )
/*++

Routine Description:

    Implement the CKsProxy::PropagateAcquire method. This propagates an
    Acquire state change to all the pins in all the connected kernel-mode
    filters, and is only done when moving out of a Stop state. 

    Goal: for every Source->Sink connected couple in a graph, put the Sink 
    into Acquire before putting Source into Acquire.                
                   
    If there is a loop in a graph, then strictly speaking, there is no 
    unique starting point for the IRP-stacks ordering. So we can only 
    guarantee that no Source pin will be put into Acquire state before 
    the connected sink pin, but we don't care about the starting point.
                    
    The state transition rules are as follows:
    - enumerate all Source pins. For each source pin that is connected to
      another filter's pin, call the connected pin to propagate Acquire.
      After propagation is done, put current Source pin into Acquire.
      
    - enumerate and put into Acquire all bridge pins.
    
    - at this point only sink pins are left. Since sink pins should be put
      into Acquire before connected Source pins, we need to put the current
      sink pin into Acquire and then call connected Source pin to propagate
      Acquire further.
      
    - this process may lead to the cycle: when we are coming back to the 
      filter that we have visited before. To manage the cycles, we mark 
      all the encountered filters and we NEVER return from any filter 
      propagation routine until we are done with all pins on this filter.
      
    If we ever need not only to put the pins into Acquire according to the 
    IRP flow, but to also walk the graph based on the contiguous IRP chains, 
    then we can modify the rules above as follows:
    - enumerate all Source pins. For each source pin that is connected to
      another filter's pin, call the connected pin to propagate Acquire.
      After propagation is done, put current Source pin into Acquire.
      
    - at some point we are either done with propagation, or we reach the 
      filter that does not have any unused source pins. If such a filter
      does not have any unused sink pins, then we return to the caller and
      continue Source-based chains. Otherwise, we originate the Sink-based 
      chain until there are no more unused connected sinks. Then we are 
      reversing the chain direction and continueing with Source-based chains,
      until all the pins are processed.
    

Arguments:

    KsPin - 
            Pin on this filter that initiated propagation.
            
    FlagStarted - 
            TRUE only when the propagation process is started by the first
            pin going to Acquire.   

Return Value:

    Returns NOERROR

--*/
{
    CAutoLock           AutoLock(m_pLock);
    HANDLE              CurrentPinHandle;
    HRESULT             hr;
    IKsObject*          KsObject;
    CBasePin*           CurrentPin;
    IKsPin*             CurrentKsPin;
    IKsPinPipe*         CurrentKsPinPipe;
    IPin*               ConnectedPin;
    IKsPin*             ConnectedKsPin;
    KSPIN_COMMUNICATION CurrentCommunication;
    POSITION            Position;
    KSSTATE             State;

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Proxy PropagateAcquire KsPin=%x, FlagStarted=%d "), KsPin, FlagStarted ));

	CheckPointer( KsPin, NOERROR ); // no error on the safe side of regresssion.
	
    //
    // check to see if there is a loop in a graph.
    //
    if (m_PropagatingAcquire) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE WARN PropagateAcquire cycle") )) ;
    }
    else {
        //
        // Mark this filter in transition to Acquire.
        //
        m_PropagatingAcquire = TRUE;

        // 
        // 1. Walk all the source pins in this filter.
        //
        for (Position = m_PinList.GetHeadPosition(); Position;) {
            CurrentPin = m_PinList.Get(Position);
            
            Position = m_PinList.Next(Position);

            //
            // If we are not called the very first time, then we can't use KsPin to propagate Acquire.
            //
            GetInterfacePointerNoLockWithAssert(CurrentPin, __uuidof(IKsPin), CurrentKsPin, hr);
            if ( (! FlagStarted) && (CurrentKsPin == KsPin ) ) { // automatically checking NULL
                continue;
            }

            //
            // Check CurrentPin communication.
            //
            CurrentKsPin->KsGetCurrentCommunication(&CurrentCommunication, NULL, NULL);
            if ( ! (CurrentCommunication & KSPIN_COMMUNICATION_SOURCE) ) {
                continue;
            }

            //
            // Check if CurrentPin is connected.
            //
            GetInterfacePointerNoLockWithAssert(CurrentPin, __uuidof(IKsPinPipe), CurrentKsPinPipe, hr);
            if ( NULL == CurrentKsPinPipe ) {	//#318075
            	ASSERT( 0 && "GetInterfacePointerNoLockWithAssert CurrentKsPinPipe NULL" );
            	continue;
            }
            ConnectedPin = CurrentKsPinPipe->KsGetConnectedPin();
            if (! ConnectedPin) {
                continue;
            }

            //
            // Sanity check for user-mode connection.
            //
            if (! IsKernelPin(ConnectedPin) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE ERROR PropagateAcquire SOURCE CurrentKsPin=%x is connected to user-mode"), CurrentKsPin));
                continue;
            }

            GetInterfacePointerNoLockWithAssert(ConnectedPin, __uuidof(IKsPin), ConnectedKsPin, hr);
            if ( NULL == ConnectedKsPin ) {	//#318075
            	ASSERT( 0 && "GetInterfacePointerNoLockWithAssert CConnectedKsPin NULL" );
            	continue;
            }

            //
            // Ask the next filter to propagate Acquire, building the chain of SOURCE pins.
            //
            ConnectedKsPin->KsPropagateAcquire();

            //
            // Since all dependent sinks went to Acquire during previous call (and consequent propagation process),
            // we can set CurrentPin into Acquire.
            //
            CurrentPinHandle = GetPinHandle(CurrentPin);
            if (SUCCEEDED(hr = ::GetState(CurrentPinHandle, &State))) {
                if (State == KSSTATE_STOP) {
                    hr = ::SetState(CurrentPinHandle, KSSTATE_ACQUIRE);
                }
            }
            else if ((hr == HRESULT_FROM_WIN32(ERROR_NO_DATA_DETECTED)) &&
                      (State == KSSTATE_PAUSE)) {
                //
                // In case the graph is confused as to the pin states,
                // at least ignore this.
                //
                hr = NOERROR;
            }
        }

        //
        // 2. Walk all the bridges in this filter.
        //
        for (Position = m_PinList.GetHeadPosition(); Position;) {
            CurrentPin = m_PinList.Get(Position);

            Position = m_PinList.Next(Position);
            
            GetInterfacePointerNoLockWithAssert(CurrentPin, __uuidof(IKsPin), CurrentKsPin, hr);
            if ( (! FlagStarted) && (CurrentKsPin == KsPin) ) { // automatically check NULL
                continue;
            }

            CurrentKsPin->KsGetCurrentCommunication(&CurrentCommunication, NULL, NULL);
            if (CurrentCommunication & KSPIN_COMMUNICATION_BRIDGE)  {
                CurrentPinHandle = GetPinHandle(CurrentPin);
                if (SUCCEEDED(hr = ::GetState(CurrentPinHandle, &State))) {
                    if (State == KSSTATE_STOP) {
                        hr = ::SetState(CurrentPinHandle, KSSTATE_ACQUIRE);
                    }
                }
                else if ((hr == HRESULT_FROM_WIN32(ERROR_NO_DATA_DETECTED)) &&
                          (State == KSSTATE_PAUSE)) {
                    //
                    // In case the graph is confused as to the pin states,
                    // at least ignore this.
                    //
                    hr = NOERROR;
                }
            }
        }

        //
        // 3. Walk all sink pins on this filter.
        //
        for (Position = m_PinList.GetHeadPosition(); Position;) {
            CurrentPin = m_PinList.Get(Position);

            Position = m_PinList.Next(Position);

            GetInterfacePointerNoLockWithAssert(CurrentPin, __uuidof(IKsPin), CurrentKsPin, hr);
            if ( (! FlagStarted) && (CurrentKsPin == KsPin) ) { // automatically check NULL
                continue;
            }

            //
            // Check CurrentPin communication.
            //
            CurrentKsPin->KsGetCurrentCommunication(&CurrentCommunication, NULL, NULL);
            if ( ! (CurrentCommunication & KSPIN_COMMUNICATION_SINK) ) {
                continue;
            }

            //
            // Check if CurrentPin is connected.
            //
            GetInterfacePointerNoLockWithAssert(CurrentPin, __uuidof(IKsPinPipe), CurrentKsPinPipe, hr);
            if ( NULL == CurrentKsPinPipe ) {	//#318075
            	ASSERT( 0 && "GetInterfacePointerNoLockWithAssert CurrentKsPinPipe NULL" );
            	continue;
            }            
            ConnectedPin = CurrentKsPinPipe->KsGetConnectedPin();
            if (! ConnectedPin) {
                continue;
            }

            //
            // Since all dependent sinks went to Acquire before (we have processed the all related chains of Source pins by now),
            // we can set CurrentPin into Acquire.
            //
            CurrentPinHandle = GetPinHandle(CurrentPin);
            if (SUCCEEDED(hr = ::GetState(CurrentPinHandle, &State))) {
                if (State == KSSTATE_STOP) {
                    hr = ::SetState(CurrentPinHandle, KSSTATE_ACQUIRE);
                }
            }
            else if ((hr == HRESULT_FROM_WIN32(ERROR_NO_DATA_DETECTED)) &&
                      (State == KSSTATE_PAUSE)) {
                //
                // In case the graph is confused as to the pin states,
                // at least ignore this.
                //
                hr = NOERROR;
            }

            //
            // Check for user-mode connection.
            //
            if (! IsKernelPin(ConnectedPin) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE ATTN PropagateAcquire CurrentKsPin=%x is connected to user-mode"), CurrentKsPin));
                continue;
            }

            //
            // Ask the next filter to propagate Acquire, building the chain of SOURCE pins.
            //
            GetInterfacePointerNoLockWithAssert(ConnectedPin, __uuidof(IKsPin), ConnectedKsPin, hr);
            if ( NULL == ConnectedKsPin ) {	//#318075
            	ASSERT( 0 && "GetInterfacePointerNoLockWithAssert CConnectedKsPin NULL" );
            	continue;
            }

            ConnectedKsPin->KsPropagateAcquire();
        }

        //
        // 4. We are done with this filter. Take care of KsPin now.
        //
        if (! FlagStarted) {
            GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsObject), KsObject, hr);
			if ( NULL == KsObject ) {
				//
				// this is not a ks pin at all.
				//
				ASSERT( 0 && "PropagateAcquire() calls with non-kspin" );
			} else {

	            CurrentPinHandle = KsObject->KsGetObjectHandle();
	        
	            if (SUCCEEDED(hr = ::GetState(CurrentPinHandle, &State))) {
    	            if (State == KSSTATE_STOP) {
        	            hr = ::SetState(CurrentPinHandle, KSSTATE_ACQUIRE);
            	    }
            	}
            	else if ((hr == HRESULT_FROM_WIN32(ERROR_NO_DATA_DETECTED)) &&
                      (State == KSSTATE_PAUSE)) {
                	//
                	// In case the graph is confused as to the pin states,
                	// at least ignore this.
                	//
                	hr = NOERROR;
            	}
            }
        }

        m_PropagatingAcquire = FALSE;
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Proxy PropagateAcquire exit KsPin=%x, FlagStarted=%d hr=NOERROR=%x"), KsPin, FlagStarted, hr ));
    return NOERROR;
}


STDMETHODIMP_(HANDLE)
CKsProxy::GetPinHandle(
    CBasePin* Pin
    )
/*++

Routine Description:

    Implement the CKsProxy::GetPinHandle method. Retrieve the
    pin handle based on the type of pin object.

Arguments:

    Pin -
        Contains the pin to retrieve the handle of, if any.

Return Value:

    Returns the handle, if any of the specified pin.

--*/
{
    PIN_DIRECTION   PinDirection;

    CheckPointer( Pin, NULL ); //#318075

    //
    // Determine the type of object base on the data flow.
    //
    Pin->QueryDirection(&PinDirection);
    switch (PinDirection) {
    case PINDIR_INPUT:
        return static_cast<CKsInputPin*>(Pin)->KsGetObjectHandle();
    case PINDIR_OUTPUT:
        return static_cast<CKsOutputPin*>(Pin)->KsGetObjectHandle();
    }
    //
    // The compiler really wants a return here, even though the
    // parameter is an enumeration, and all items in the enumeration
    // are covered.
    //
    return NULL;
}


STDMETHODIMP_(ULONG)
CKsProxy::GetPinFactoryId(
    CBasePin* Pin
    )
/*++

Routine Description:

    Implement the CKsProxy::GetPinFactoryId method. Retrieve the
    Pin Factory Identifier based on the type of pin object.

Arguments:

    Pin -
        Contains the pin to retrieve the factory identifier of.

Return Value:

    Returns the factory identifier, of the specified pin.

--*/
{
    PIN_DIRECTION   PinDirection;

    CheckPointer( Pin, static_cast<ULONG>(-1)); //#322883

    //
    // Determine the type of object base on the data flow.
    //
    Pin->QueryDirection(&PinDirection);
    switch (PinDirection) {
    case PINDIR_INPUT:
        return static_cast<CKsInputPin*>(Pin)->PinFactoryId();
    case PINDIR_OUTPUT:
        return static_cast<CKsOutputPin*>(Pin)->PinFactoryId();
    }
    //
    // The compiler really wants a return here, even though the
    // parameter is an enumeration, and all items in the enumeration
    // are covered.
    //
    return static_cast<ULONG>(-1);
}


STDMETHODIMP
CKsProxy::GetPinFactoryDataRanges(
    ULONG PinFactoryId,
    PVOID* DataRanges
    )
/*++

Routine Description:

    Implement the CKsProxy::GetPinDataRanges method. Allocate memory
    enough to hold all the data ranges, and return a pointer to that
    memory. This must be deleted as an array.

Arguments:

    PinFactoryId -
        Contains the Pin Factory Id to use in the query.

    DataRanges -
        The place in which to put the pointer to the list of data ranges.

Return Value:

    Returns NOERROR, else E_FAIL or some memory error.

--*/
{
    HRESULT hr;

    //
    // Just call the generic method for retrieving any variable sized
    // property in the Pin property set
    //
    hr = ::KsGetMultiplePinFactoryItems(
        m_FilterHandle,
        PinFactoryId,
        KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
        DataRanges);
    if (FAILED(hr)) {
        hr = ::KsGetMultiplePinFactoryItems(
            m_FilterHandle,
            PinFactoryId,
            KSPROPERTY_PIN_DATARANGES,
            DataRanges);
    }
    return hr;
}


STDMETHODIMP
CKsProxy::CheckMediaType(
    IUnknown* UnkOuter,
    ULONG PinFactoryId,
    const CMediaType* MediaType
    )
/*++

Routine Description:

    Implement the CKsProxy::CheckMediaType method. Validates that the
    specified media type can be used on this Pin Factory Id, at least
    as far as can be determined without actually making the connection.

    This is done by retrieving the data ranges supported by the Pin
    Factory Id, and either using a Media Type handler to check if the
    media type is within range, or performs a general check of the Major
    Format, Sub Format, and Specifier if there is no Media Type handler
    available.

    This might be useful to implement in filters in the Pin property set.

Arguments:

    UnkOuter -
        The IUnknown of the requesting pin. This is used in opening the
        data handler.

    PinFactoryId -
        Contains the Pin Factory Id to use in the query.

    MediaType -
        Contains the media type to validate.

Return Value:

    Returns NOERROR, else E_FAIL or some memory error.

--*/
{
    HRESULT             hr;
    IKsDataTypeHandler* DataTypeHandler;
    IUnknown*           UnkInner;
    PKSMULTIPLE_ITEM    MultipleItem = NULL;

    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s::CheckMediaType"),
        m_pName ));

	CheckPointer( MediaType, E_POINTER ); // #322894
	CheckPointer( UnkOuter, E_POINTER );
    
    ::OpenDataHandler(MediaType, UnkOuter, &DataTypeHandler, &UnkInner);
    if (DataTypeHandler) {
        DbgLog((
            LOG_TRACE, 
            2, 
            TEXT("%s::CheckMediaType, retrieved data type handler"),
            m_pName ));
    }
    
    hr = GetPinFactoryDataRanges(PinFactoryId, reinterpret_cast<PVOID*>(&MultipleItem));
    if (SUCCEEDED(hr)) {
        IMediaTypeAttributes* MediaTypeAttributes;

        /* NULL == MultipleItem is a pathological case where a driver returns a success code
           in KsGetMultiplePinFactoryItems() (below GetPinFactoryDataRanges) when passed a
           size 0 buffer.  We'll just do with an assert since we're in ring 3. */
        ASSERT( NULL != MultipleItem );

        //
        // Either feed the media type and data ranges to the Media Type
        // handler, or do a simple manual check.
        //
        if (DataTypeHandler) {
            //
            // Returns S_OK if the previously specified type is within the
            // given ranges, S_FALSE if it is not within the ranges, else
            // an error result if the given ranges are not valid.
            //
            hr = DataTypeHandler->KsIsMediaTypeInRanges(reinterpret_cast<PVOID>(MultipleItem));
            //
            // If the call did not produce an error, but the media type is not
            // in range, change the return value to a failure result.
            //
            if (hr == S_FALSE) {
                hr = E_FAIL;
            }
            if ( UnkInner ) { //#322905
	            UnkInner->Release();
	        } else {
	        	ASSERT( 0 && "Null UnkInner");
	        }
        } else {
            PKSMULTIPLE_ITEM Attributes;

            if (MediaType->pUnk && SUCCEEDED(MediaType->pUnk->QueryInterface(__uuidof(IMediaTypeAttributes), reinterpret_cast<PVOID*>(&MediaTypeAttributes)))) {

                MediaTypeAttributes->GetMediaAttributes(&Attributes);
                MediaTypeAttributes->Release();
            } else {
                Attributes = NULL;
            }
            PKSDATARANGE DataRange = reinterpret_cast<PKSDATARANGE>(MultipleItem + 1);
            hr = E_FAIL;
            for (; MultipleItem->Count--;) {
                //
                // Wildcards can be used for the Major Format or Sub Format,
                // in which case the rest of the format does not matter.
                // All required attributes in the data range must be resolved,
                // and all attributes in the media type must be resolved.
                //
                if (((DataRange->MajorFormat == KSDATAFORMAT_TYPE_WILDCARD) ||
                    ((*MediaType->Type() == DataRange->MajorFormat) &&
                    ((DataRange->SubFormat == KSDATAFORMAT_SUBTYPE_WILDCARD) ||
                    ((*MediaType->Subtype() == DataRange->SubFormat) &&
                    ((DataRange->Specifier == KSDATAFORMAT_SPECIFIER_WILDCARD) ||
                    (*MediaType->FormatType() == DataRange->Specifier)))))) &&
                    SUCCEEDED(::KsResolveRequiredAttributes(DataRange, Attributes))) {
                    hr = NOERROR;
                    break;
                }
                //
                // Increment to the next quad word aligned data range.
                // If there are associated attributes, increment past the
                // range first, then the attributes, as if it was another
                // range.
                //
                if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
                    DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
                    MultipleItem->Count--;
                }
                DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            }
        }
        //
        // This was allocated by querying for the list of data ranges.
        //
        CoTaskMemFree(MultipleItem);
    }
    return hr;
}


STDMETHODIMP
CKsProxy::SetPinSyncSource(
    HANDLE PinHandle
    )
/*++

Routine Description:

    Implement the CKsProxy::SetPinSyncSource method. Ensures that the
    object is locked while setting the sync source on a pin handle. This
    is called when a pin is newly connected after a clock source has
    been set on the filter.

Arguments:

    PinHandle -
        Contains the handle of the pin to set the sync source on.

Return Value:

    Returns NOERROR, else E_FAIL if the clock could not be set.

--*/
{
    //
    // Only set the source on this new pin if a clock has been set.
    //
    if (m_ExternalClockHandle) {
        return ::SetSyncSource(PinHandle, m_ExternalClockHandle);
    }
    return NOERROR;
}


STDMETHODIMP
CKsProxy::QueryTopologyItems(
    ULONG PropertyId,
    PKSMULTIPLE_ITEM* MultipleItem
    )
/*++

Routine Description:

    Implement the CKsProxy::QueryTopologyItems method. Retrieves the
    topology property specified.

Arguments:

    PropertyId -
        The property in the set to query.

    MultipleItem -
        The place in which to put the buffer containing the connections. This
        must be deleted as an array.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT     hr;
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Topology;
    Property.Id = PropertyId;
    Property.Flags = KSPROPERTY_TYPE_GET;
    //
    // Query for the size of the data.
    //
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        NULL,
        0,
        &BytesReturned);
    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        //
        // Allocate a buffer and query for the data.
        //
        *MultipleItem = reinterpret_cast<PKSMULTIPLE_ITEM>(new BYTE[BytesReturned]);
        if (!*MultipleItem) {
            return E_OUTOFMEMORY;
        }
        hr = ::KsSynchronousDeviceControl(
            m_FilterHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            *MultipleItem,
            BytesReturned,
            &BytesReturned);
        if (FAILED(hr)) {
            delete [] reinterpret_cast<BYTE*>(*MultipleItem);
        }
    }
    return hr;
}


STDMETHODIMP
CKsProxy::QueryInternalConnections(
    ULONG PinFactoryId,
    PIN_DIRECTION PinDirection,
    IPin** PinList,
    ULONG* PinCount
    )
/*++

Routine Description:

    Implement the CKsProxy::QueryInternalConnections method. Returns a list of
    pins which are related to this Pin Factory through topology. This is called
    from each pin with its Pin Factory Identifier in response to a
    QueryInternalConnections.

Arguments:

    PinFactoryId -
        The Pin Factory Identifier of the calling pin.

    PinDirection -
        Specifies the data flow of the pin. This determines which direction the
        topology connection list is followed.

    PinList -
        Contains a list of slots in which to place all pins related to this
        pin through topology. Each pin returned must be reference counted. This
        may be NULL if PinCount is zero.

    PinCount -
        Contains the number of slots available in PinList, and should be set to
        the number of slots filled or neccessary.

Return Value:

    Returns E_NOTIMPL to specify that all inputs go to all outputs and vice versa,
    S_FALSE if there is not enough slots in PinList, or S_OK if the mapping was
    placed into PinList and PinCount adjusted.


--*/
{
    ULONG               PinFactoryCount;
    PULONG              PinFactoryIdList;
    HRESULT             hr;
    PKSMULTIPLE_ITEM    MultipleItem;

	CheckPointer( PinCount, E_POINTER );
	if ( *PinCount ) {
		CheckPointer( PinList, E_POINTER ); // #322911
	}
	
    //
    // This will normally succeed, but any failure just returns the case for
    // E_NOTIMPL mapping, which might be more useful than S_FALSE.
    //
    if (FAILED(GetPinFactoryCount(&PinFactoryCount))) {
        return E_NOTIMPL;
    }
    //
    // If there is only one Pin Factory, then there can't be much of a topology.
    //
    if (PinFactoryCount < 2) {
        *PinCount = 0;
        return S_OK;
    }
    //
    // Each Pin Factory that this Pin Factory eventually is connected to is
    // kept track of. After recursing through the topology connection list,
    // each Pin Factory encountered has its pin instances counted so that
    // a total count of pins can be generated. Each pin could have more than
    // a single instance.
    //
    PinFactoryIdList = new ULONG[PinFactoryCount];
    if (!PinFactoryIdList) {
        return E_NOTIMPL;
    }
    //
    // Default to all inputs to all outputs if Topology is not supported.
    //
    hr = E_NOTIMPL;
    //
    // Query for the size of the data.
    //
    if (SUCCEEDED(QueryTopologyItems(KSPROPERTY_TOPOLOGY_CONNECTIONS, &MultipleItem))) {
        PKSTOPOLOGY_CONNECTION  Connection;
        ULONG                   ConnectionItem;
        ULONG                   PinInstanceCount;

        //
        // Initially there are no related Pin Factories.
        //
        memset(PinFactoryIdList, 0, PinFactoryCount * sizeof(*PinFactoryIdList));
        Connection = (PKSTOPOLOGY_CONNECTION)(MultipleItem + 1);
        //
        // If this is an Input pin, then the FromNode is followed to the
        // ToNode. Node connections are data flow dependent in this way.
        //
        if (PinDirection == PINDIR_INPUT) {
            for (ConnectionItem = 0; ConnectionItem < MultipleItem->Count; ConnectionItem++) {
                //
                // If this connection is from the Pin Factory in question
                // then follow the connection path to another Pin Factory.
                // The FollowFromTopology function modifies FromNodePin
                // elements of connection nodes so that paths which have
                // already been recursed on are not followed again.
                //
                if ((Connection[ConnectionItem].FromNode == KSFILTER_NODE) &&
                    (Connection[ConnectionItem].FromNodePin == PinFactoryId)) {
                    ::FollowFromTopology(
                        Connection,
                        MultipleItem->Count,
                        PinFactoryId,
                        &Connection[ConnectionItem],
                        PinFactoryIdList);
                }
            }
        } else {
            //
            // This is an Output pin, and the ToNode is followed to the
            // FromNode, in the reverse data flow.
            //
            for (ConnectionItem = 0; ConnectionItem < MultipleItem->Count; ConnectionItem++) {
                //
                // If this connection is from the Pin Factory in question
                // then follow the connection path to another Pin Factory.
                // The FollowToTopology function modifies ToNodePin
                // elements of connection nodes so that paths which have
                // already been recursed on are not followed again.
                //
                if ((Connection[ConnectionItem].ToNode == KSFILTER_NODE) &&
                    (Connection[ConnectionItem].ToNodePin == PinFactoryId)) {
                    ::FollowToTopology(
                        Connection,
                        MultipleItem->Count,
                        PinFactoryId,
                        &Connection[ConnectionItem],
                        PinFactoryIdList);
                }
            }
        }
        //
        // Now count all the instances of pins in the collected list of
        // Pin Factories which are related to the Pin Factory in question.
        // This was kept track of by marking the PinFactoryIdList postions.
        //
        PinInstanceCount = 0;
        for (ConnectionItem = 0; ConnectionItem < PinFactoryCount; ConnectionItem++) {
            if ((ConnectionItem != PinFactoryId) && PinFactoryIdList[ConnectionItem]) {
                for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
                    CBasePin*       Pin;

                    Pin = m_PinList.Get(Position);
                    Position = m_PinList.Next(Position);
                    if (GetPinFactoryId(Pin) == ConnectionItem) {
                        PinInstanceCount++;
                    }
                }
            }
        }
        //
        // Only if there is enough room should the list of pins actually
        // be returned. Else any error is returned. There could be zero
        // related pins at this point, and S_OK needs to returned in that
        // case.
        //
        if (!*PinCount || (PinInstanceCount > *PinCount)) {
            *PinCount = PinInstanceCount;
            hr = PinInstanceCount ? S_FALSE : S_OK;
        } else {
            hr = S_OK;
            *PinCount = 0;
            //
            // Actually put each related pin instance in the array
            // provided, reference counting the interface.
            //
            for (ConnectionItem = 0; ConnectionItem < PinFactoryCount; ConnectionItem++) {
                if ((ConnectionItem != PinFactoryId) && PinFactoryIdList[ConnectionItem]) {
                    for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
                        CBasePin*       Pin;

                        Pin = m_PinList.Get(Position);
                        Position = m_PinList.Next(Position);
                        if (GetPinFactoryId(Pin) == ConnectionItem) {
                            PinList[*PinCount] = Pin;
                            Pin->AddRef();
                            (*PinCount)++;
                        }
                    }
                }
            }
        }
        delete [] reinterpret_cast<BYTE*>(MultipleItem);
    }
    delete [] PinFactoryIdList;
    return hr;
}


STDMETHODIMP_(VOID)
CKsProxy::DeliverBeginFlush(
    ULONG PinFactoryId
    )
/*++

Routine Description:

    Implement the CKsProxy::DeliverBeginFlush method. Propagates the 
    BeginFlush call from an Input pin to all Output pins related by 
    Topology. If no Topology is present defaults to propogating to all 
    Output pins. If there are no output pins, then no flush is delivered.

Arguments:

    PinFactoryId -
        The Pin Factory Identifier of the calling Input pin.

Return Value:

    Nothing.

--*/
{
    BOOL        PinWasNotified;
    ULONG       PinFactoryCount;

    m_EndOfStreamCount = 0;
    //
    // Initially specify that no notification has happened yet. This will only
    // be set if a pin is actually called with DeliverBeginFlush().
    // 
    PinWasNotified = FALSE;
    if (SUCCEEDED(GetPinFactoryCount(&PinFactoryCount))) {
        PULONG      PinFactoryIdList;

        //
        // Each Pin Factory that this Pin Factory eventually is connected to is
        // kept track of. After recursing through the topology connection list,
        // each Pin Factory encountered has its pin instances counted so that
        // a total count of pins can be generated. Each pin could have more than
        // a single instance.
        //
        PinFactoryIdList = new ULONG[PinFactoryCount];
        if (PinFactoryIdList) {
            PKSMULTIPLE_ITEM        MultipleItem;

            if (SUCCEEDED(QueryTopologyItems(KSPROPERTY_TOPOLOGY_CONNECTIONS, &MultipleItem))) {
                PKSTOPOLOGY_CONNECTION  Connection;
                ULONG                   ConnectionItem;

                //
                // Initially there are no related Pin Factories.
                //
                memset(PinFactoryIdList, 0, PinFactoryCount * sizeof(*PinFactoryIdList));
                Connection = reinterpret_cast<PKSTOPOLOGY_CONNECTION>(MultipleItem + 1);
                for (ConnectionItem = 0; ConnectionItem < MultipleItem->Count; ConnectionItem++) {
                    //
                    // If this connection is from the Pin Factory in question
                    // then follow the connection path to another Pin Factory.
                    // The FollowFromTopology function modifies FromNodePin
                    // elements of connection nodes so that paths which have
                    // already been recursed on are not followed again.
                    //
                    if ((Connection[ConnectionItem].FromNode == KSFILTER_NODE) &&
                        (Connection[ConnectionItem].FromNodePin == PinFactoryId)) {
                        ::FollowFromTopology(
                            Connection,
                            MultipleItem->Count,
                            PinFactoryId,
                            &Connection[ConnectionItem],
                            PinFactoryIdList);
                    }
                }
                //
                // Now notify all the instances of pins in the collected list of
                // Pin Factories which are related to the Pin Factory in question.
                // This was kept track of by marking the PinFactoryIdList postions.
                //
                for (ConnectionItem = 0; ConnectionItem < PinFactoryCount; ConnectionItem++) {
                    if ((ConnectionItem != PinFactoryId) && PinFactoryIdList[ConnectionItem]) {
                        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
                            CBasePin*       Pin;

                            Pin = m_PinList.Get(Position);
                            Position = m_PinList.Next(Position);
                            if (GetPinFactoryId(Pin) == ConnectionItem) {
                                ((CKsOutputPin*)Pin)->DeliverBeginFlush();
                                PinWasNotified = TRUE;
                            }
                        }
                    }
                }
                delete [] reinterpret_cast<BYTE*>(MultipleItem);
            }
            delete [] PinFactoryIdList;
        }
    }
    //
    // Either some error happened, like no Topology, or this pin did not
    // connect to an Output pin.
    //
    if (!PinWasNotified) {
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            Pin->QueryDirection(&PinDirection);
            if (PinDirection == PINDIR_OUTPUT) {
                static_cast<CKsOutputPin*>(Pin)->DeliverBeginFlush();
                PinWasNotified = TRUE;
            }
        }
    }
}


STDMETHODIMP_(VOID)
CKsProxy::DeliverEndFlush(
    ULONG PinFactoryId
    )
/*++

Routine Description:

    Implement the CKsProxy::DeliverEndFlush method. Propagates the 
    BeginFlush call from an Input pin to all Output pins related by 
    Topology. If no Topology is present defaults to propogating to all 
    Output pins. If there are no output pins, then no flush is delivered.

Arguments:

    PinFactoryId -
        The Pin Factory Identifier of the calling Input pin.

Return Value:

    Nothing.

--*/
{
    BOOL        PinWasNotified;
    ULONG       PinFactoryCount;

    //
    // Initially specify that no notification has happened yet. This will only
    // be set if a pin is actually called with DeliverBeginFlush().
    // 
    PinWasNotified = FALSE;
    if (SUCCEEDED(GetPinFactoryCount(&PinFactoryCount))) {
        PULONG      PinFactoryIdList;

        //
        // Each Pin Factory that this Pin Factory eventually is connected to is
        // kept track of. After recursing through the topology connection list,
        // each Pin Factory encountered has its pin instances counted so that
        // a total count of pins can be generated. Each pin could have more than
        // a single instance.
        //
        PinFactoryIdList = new ULONG[PinFactoryCount];
        if (PinFactoryIdList) {
            PKSMULTIPLE_ITEM        MultipleItem;

            if (SUCCEEDED(QueryTopologyItems(KSPROPERTY_TOPOLOGY_CONNECTIONS, &MultipleItem))) {
                PKSTOPOLOGY_CONNECTION  Connection;
                ULONG                   ConnectionItem;

                //
                // Initially there are no related Pin Factories.
                //
                memset(PinFactoryIdList, 0, PinFactoryCount * sizeof(*PinFactoryIdList));
                Connection = reinterpret_cast<PKSTOPOLOGY_CONNECTION>(MultipleItem + 1);
                for (ConnectionItem = 0; ConnectionItem < MultipleItem->Count; ConnectionItem++) {
                    //
                    // If this connection is from the Pin Factory in question
                    // then follow the connection path to another Pin Factory.
                    // The FollowFromTopology function modifies FromNodePin
                    // elements of connection nodes so that paths which have
                    // already been recursed on are not followed again.
                    //
                    if ((Connection[ConnectionItem].FromNode == KSFILTER_NODE) &&
                        (Connection[ConnectionItem].FromNodePin == PinFactoryId)) {
                        ::FollowFromTopology(
                            Connection,
                            MultipleItem->Count,
                            PinFactoryId,
                            &Connection[ConnectionItem],
                            PinFactoryIdList);
                    }
                }
                //
                // Now notify all the instances of pins in the collected list of
                // Pin Factories which are related to the Pin Factory in question.
                // This was kept track of by marking the PinFactoryIdList postions.
                //
                for (ConnectionItem = 0; ConnectionItem < PinFactoryCount; ConnectionItem++) {
                    if ((ConnectionItem != PinFactoryId) && PinFactoryIdList[ConnectionItem]) {
                        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
                            CBasePin*       Pin;

                            Pin = m_PinList.Get(Position);
                            Position = m_PinList.Next(Position);
                            if (GetPinFactoryId(Pin) == ConnectionItem) {
                                static_cast<CKsOutputPin*>(Pin)->DeliverEndFlush();
                                PinWasNotified = TRUE;
                            }
                        }
                    }
                }
                delete [] reinterpret_cast<BYTE*>(MultipleItem);
            }
            delete [] PinFactoryIdList;
        }
    }
    //
    // Either some error happened, like no Topology, or this pin did not
    // connect to an Output pin.
    //
    if (!PinWasNotified) {
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            Pin->QueryDirection(&PinDirection);
            if (PinDirection == PINDIR_OUTPUT) {
                static_cast<CKsOutputPin*>(Pin)->DeliverEndFlush();
                PinWasNotified = TRUE;
            }
        }
    }
}


STDMETHODIMP_(VOID)
CKsProxy::PositionEOS(
    )
/*++

Routine Description:

    Implement the CKsProxy::PositionEOS method. Sets the start and end
    of the media time to the current position so that the end of stream
    is known to have been reached. This takes care of any rounding errors.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    LONGLONG    CurrentPosition;

    if (SUCCEEDED(GetCurrentPosition(&CurrentPosition))) {
        if (SUCCEEDED(SetPositions(
            NULL,
            AM_SEEKING_NoPositioning,
            &CurrentPosition,
            AM_SEEKING_AbsolutePositioning))) {
        } else {
            DbgLog((LOG_TRACE, 2, TEXT("%s::PositionEOS: SetPositions failed"), m_pName));
        }
    } else {
        DbgLog((LOG_TRACE, 2, TEXT("%s::PositionEOS: GetCurrentPosition failed"), m_pName));
    }
}


STDMETHODIMP
CKsProxy::GetTime(
    REFERENCE_TIME* Time
    )
/*++

Routine Description:

    Implement the IReferenceClock::GetTime method. Queries the current
    clock time from the kernel implementation. If a clock handle has
    not been created already, then it is now created. This may fail
    because the interface could have been queried, and later the pin
    disconnected, with no successor which supports a clock. In this
    case just return failure.

Arguments:

    Time -
        The place in which to put the reference time.

Return Value:

    Returns NOERROR, else E_FAIL if the time could not be retrieved.

--*/
{
    HRESULT     hr;

	CheckPointer( Time, E_FAIL ); // #322919
    
    CAutoLock   AutoLock(m_pLock);

    if (m_PinClockHandle || SUCCEEDED(hr = CreateClockHandle())) {
        KSPROPERTY  Property;
        ULONG       BytesReturned;

        Property.Set = KSPROPSETID_Clock;
        Property.Id = KSPROPERTY_CLOCK_TIME;
        Property.Flags = KSPROPERTY_TYPE_GET;
        hr = ::KsSynchronousDeviceControl(
            m_PinClockHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            Time,
            sizeof(*Time),
            &BytesReturned);
        if (SUCCEEDED(hr)) {
            //
            // Add the starting offset, since the kernel mode clock
            // does not add such an offset to current time.
            //
            *Time += m_tStart;
        }
    }
    return hr;
}


STDMETHODIMP
CKsProxy::AdviseTime(
    REFERENCE_TIME BaseTime,
    REFERENCE_TIME StreamTime,
    HEVENT EventHandle,
    DWORD_PTR* AdviseCookie
    )
/*++

Routine Description:

    Implement the IReferenceClock::AdviseTime method. Enables a
    Mark event on the kernel implementation. If a clock handle has
    not been created already, then it is now created. This may fail
    because the interface could have been queried, and later the pin
    disconnected, with no successor which supports a clock. In this
    case just return failure.

Arguments:

    BaseTime -
        The base time in milliseconds to which the stream time offset
        is added.

    StreamTime -
        The offset in milliseconds from the base time at which the Mark
        event is to be set.

    EventHandle -
        The handle to signal.

    AdviseCookie -
        The place in which to put the cookie for later disabling. This is
        actually just a pointer to an allocated structure. It is possible
        that ActiveMovie expects this to be automatically destroyed in the
        case of a Mark event, but it is not in this implementation.

Return Value:

    Returns NOERROR, else E_FAIL if the event could not be enabled.

--*/
{
    HRESULT     hr;

	CheckPointer( AdviseCookie, E_FAIL ); //#322940
    
    CAutoLock   AutoLock(m_pLock);

    if (m_PinClockHandle || SUCCEEDED(hr = CreateClockHandle())) {
        KSEVENT             Event;
        PKSEVENT_TIME_MARK  EventTime;
        ULONG               BytesReturned;

        Event.Set = KSEVENTSETID_Clock;
        Event.Id = KSEVENT_CLOCK_POSITION_MARK;
        Event.Flags = KSEVENT_TYPE_ONESHOT;
        EventTime = new KSEVENT_TIME_MARK;
        if (!EventTime) {
            return E_OUTOFMEMORY;
        }
        EventTime->EventData.NotificationType = KSEVENTF_EVENT_HANDLE;
        EventTime->EventData.EventHandle.Event = reinterpret_cast<HANDLE>(EventHandle);
        EventTime->EventData.EventHandle.Reserved[0] = 0;
        EventTime->EventData.EventHandle.Reserved[1] = 0;
        EventTime->MarkTime = BaseTime + StreamTime;
        hr = ::KsSynchronousDeviceControl(
            m_PinClockHandle,
            IOCTL_KS_ENABLE_EVENT,
            &Event,
            sizeof(Event),
            EventTime,
            sizeof(*EventTime),
            &BytesReturned);
        if (SUCCEEDED(hr)) {
            //
            // Save the type of event this was for use in Unadvise.
            // This leaks a small amount of memory (sizeof(KSEVENT_TIME_MARK),
            // since clients need not Unadvise a single shot event.
            //
            EventTime->EventData.EventHandle.Reserved[0] = Event.Id;
            *AdviseCookie = reinterpret_cast<DWORD_PTR>(EventTime);
        } else {
            delete EventTime;
        }
    }
    return hr;
}


STDMETHODIMP
CKsProxy::AdvisePeriodic(
    REFERENCE_TIME StartTime,
    REFERENCE_TIME PeriodTime,
    HSEMAPHORE SemaphoreHandle,
    DWORD_PTR* AdviseCookie
    )
/*++

Routine Description:

    Implement the IReferenceClock::AdvisePeriodic method. Enables a
    Interval Mark event on the kernel implementation. If a clock handle
    has not been created already, then it is now created. This may fail
    because the interface could have been queried, and later the pin
    disconnected, with no successor which supports a clock. In this
    case just return failure.

Arguments:

    StartTime -
        The start time in milliseconds to at which the semaphore should be
        signalled.

    PeriodTime -
        The period in milliseconds at which the semaphore should be signalled.

    SemaphoreHandle -
        The handle to signal.

    AdviseCookie -
        The place in which to put the cookie for later disabling. This is
        actually just a pointer to an allocated structure.

Return Value:

    Returns NOERROR, else E_FAIL if the event could not be enabled.

--*/
{
    HRESULT     hr;

	CheckPointer( AdviseCookie, E_FAIL ); //#322955
    
    CAutoLock   AutoLock(m_pLock);

    if (m_PinClockHandle || SUCCEEDED(hr = CreateClockHandle())) {
        KSEVENT             Event;
        PKSEVENT_TIME_INTERVAL EventTime;
        ULONG               BytesReturned;

        Event.Set = KSEVENTSETID_Clock;
        Event.Id = KSEVENT_CLOCK_INTERVAL_MARK;
        Event.Flags = KSEVENT_TYPE_ENABLE;
        EventTime = new KSEVENT_TIME_INTERVAL;
        if (!EventTime) {
            return E_OUTOFMEMORY;
        }
        EventTime->EventData.NotificationType = KSEVENTF_SEMAPHORE_HANDLE;
        EventTime->EventData.SemaphoreHandle.Semaphore = 
            reinterpret_cast<HANDLE>(SemaphoreHandle);
        EventTime->EventData.SemaphoreHandle.Reserved = 0;
        EventTime->EventData.SemaphoreHandle.Adjustment = 1;
        EventTime->TimeBase = StartTime;
        EventTime->Interval = PeriodTime;
        hr = ::KsSynchronousDeviceControl(
            m_PinClockHandle,
            IOCTL_KS_ENABLE_EVENT,
            &Event,
            sizeof(Event),
            EventTime,
            sizeof(*EventTime),
            &BytesReturned);
        if (SUCCEEDED(hr)) {
            //
            // Save the type of event this was for use in Unadvise.
            //
            EventTime->EventData.SemaphoreHandle.Reserved = Event.Id;
            *AdviseCookie = reinterpret_cast<DWORD_PTR>(EventTime);
        } else {
            delete EventTime;
        }
    }
    return hr;
}


STDMETHODIMP
CKsProxy::Unadvise(
    DWORD_PTR AdviseCookie
    )
/*++

Routine Description:

    Implement the IReferenceClock::Unadvise method. Disables a previously
    enabled event on the kernel implementation. If a clock handle
    has not been created already the function fails.

Arguments:

    AdviseCookie -
        The cookie to return for later disabling. This is actually
        just a pointer to an allocated structure.

Return Value:

    Returns NOERROR, else E_FAIL if the event could not be disabled.

--*/
{
    HRESULT     hr;

	CheckPointer( AdviseCookie, E_FAIL ); //#322955
    
    CAutoLock   AutoLock(m_pLock);

    //
    // If the handle was not already created, then there can't be anything
    // to Unadvise.
    //
    if (m_PinClockHandle) {
        ULONG               BytesReturned;

        //
        // The advise cookie is just a pointer to the original data structure.
        //
        hr = ::KsSynchronousDeviceControl(
            m_PinClockHandle,
            IOCTL_KS_DISABLE_EVENT,
            reinterpret_cast<PVOID>(AdviseCookie),
            sizeof(KSEVENTDATA),
            NULL,
            0,
            &BytesReturned);
        if (SUCCEEDED(hr)) {
            //
            // The actual type of event was stored in the reserved field
            // after enabling the event. The only reason for keeping this
            // data structure around is that the address is the unique key
            // used to look up the event.
            //
            if (reinterpret_cast<PKSEVENTDATA>(AdviseCookie)->EventHandle.Reserved[0] == KSEVENT_CLOCK_POSITION_MARK) {
                delete reinterpret_cast<PKSEVENT_TIME_MARK>(AdviseCookie);
            } else {
                delete reinterpret_cast<PKSEVENT_TIME_INTERVAL>(AdviseCookie);
            }
        }
    } else {
        hr = E_FAIL;
    }
    return hr;
}


STDMETHODIMP
CKsProxy::GetCapabilities(
    DWORD* Capabilities
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetCapabilities method. Queries the
    underlying filter for its seeking capabilities, then restricts
    those capabilities based on what all connected upstream filters.
    Additionally ensures the function returns immediately on recursion.

Arguments:

    Capabilities -
        The place in which to return the capabilities of the underlying
        filter, limited by the upstream connections.

Return Value:

    Returns NOERROR if the query succeeded, else some critical error.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    HRESULT     hr;

	CheckPointer( Capabilities, E_POINTER ); //#322955
    
    CAutoLock   AutoLock(m_pLock);

    *Capabilities =
        AM_SEEKING_CanSeekAbsolute |
        AM_SEEKING_CanSeekForwards |
        AM_SEEKING_CanSeekBackwards |
        AM_SEEKING_CanGetCurrentPos |
        AM_SEEKING_CanGetStopPos |
        AM_SEEKING_CanGetDuration |
        AM_SEEKING_CanPlayBackwards;
    //
    // Take the filter lock when querying to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with all capabilities. Also stops
    // the pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Just return that the filter can do everything, which is
        // then limited by what has already been discovered by the
        // caller. Note that this assumes no two IMediaSeeking
        // recursions are occuring at once.
        //
        return NOERROR;
    }
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    Property.Set = KSPROPSETID_MediaSeeking;
    Property.Id = KSPROPERTY_MEDIASEEKING_CAPABILITIES;
    Property.Flags = KSPROPERTY_TYPE_GET;
    //
    // The parameter has already been initialized in case of error.
    // If the filter is not interested, then it supports everything.
    //
    ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Capabilities,
        sizeof(*Capabilities),
        &BytesReturned);
    hr = NOERROR;
    //
    // Enumerate all the connected input pins, querying the connected
    // pin for seeking capabilities.
    //
    for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
        CBasePin*       Pin;
        PIN_DIRECTION   PinDirection;

        Pin = m_PinList.Get(Position);
        Position = m_PinList.Next(Position);
        Pin->QueryDirection(&PinDirection);
        if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
            IPin*           ConnectedPin;
            IMediaSeeking*  MediaSeeking;

            ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
            //
            // Query the connected pin, rather than the filter, for
            // IMediaSeeking support.
            //
            hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
            if (SUCCEEDED(hr)) {
                DWORD   UpstreamCapabilities;

                //
                // Pass the query upstream, and limit results based on the
                // upstream limits.
                //
                if (SUCCEEDED(MediaSeeking->GetCapabilities(&UpstreamCapabilities))) {
                    *Capabilities &= UpstreamCapabilities;
                }
                MediaSeeking->Release();
            } else {
                //
                // Can't do any sort of seeking if the interface is not
                // supported, so just exit.
                //
                *Capabilities = 0;
                hr = NOERROR;
                break;
            }
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
CKsProxy::CheckCapabilities(
    DWORD* Capabilities
    )
/*++

Routine Description:

    Implement the IMediaSeeking::CheckCapabilities method. Determines
    if the set of capabilities passed are supported. Modifies the
    parameter to indicate what subset within the set given are supported,
    and returns a value indicating if all, some, or none are supported.

Arguments:

    Capabilities -
        The place containing the original set of capabilities being
        queried, and in which to return the subset of capabilities
        actually supported.

Return Value:

    Returns S_OK if all capabilities are supported, else S_FALSE if only
    some are supported, or E_FAIL if none are supported.

--*/
{
    HRESULT hr;
    DWORD   RealCapabilities;

   	CheckPointer( Capabilities, E_FAIL ); //#322955

    hr = GetCapabilities(&RealCapabilities);
    if (SUCCEEDED(hr)) {
        if ((RealCapabilities | *Capabilities) != RealCapabilities) {
            if (RealCapabilities & *Capabilities) {
                hr = S_FALSE;
                *Capabilities &= RealCapabilities;
            } else {
                hr = E_FAIL;
                *Capabilities = 0;
            }
        }
    } else {
        *Capabilities = 0;
    }
    return hr;
}


STDMETHODIMP
CKsProxy::IsFormatSupported(
    const GUID* Format
    )
/*++

Routine Description:

    Implement the IMediaSeeking::IsFormatSupported method. Queries the
    filter for time formats supported, and tries to find a match. If
    this is not supported by the filter, attempts to query upstream.

Arguments:

    Format -
        Contains the time format to to compare against.

Return Value:

    Returns S_OK if the format is supported, else S_FALSE, or a critical
    error.

--*/
{
    PKSMULTIPLE_ITEM    MultipleItem = NULL;

   	CheckPointer( Format, E_POINTER ); //#322955
    
    HRESULT             hr;
    CAutoLock           AutoLock(m_pLock);

    //
    // Take the filter lock when querying to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once.
        //
        return S_FALSE;
    }
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    hr = QueryMediaSeekingFormats(&MultipleItem);
    if (SUCCEEDED(hr)) {
        GUID*   CurrentFormat;

        /* NULL == MultipleItem is a pathological case where a driver returns
           a success code in QueryMediaSeekingFormats() when passed a size 0
           buffer.  We'll just do with an assert since we're in ring 3. */
        ASSERT( NULL != MultipleItem );

        //
        // Unless direct support is found, allow the function to proceed
        // on to the upstream connections by setting the error correctly.
        //
        hr = ERROR_SET_NOT_FOUND;
        for (CurrentFormat = reinterpret_cast<GUID*>(MultipleItem + 1); MultipleItem->Count--; CurrentFormat++) {
            if (*CurrentFormat == *Format) {
                //
                // Found a match, so exist successfully.
                //
                hr = S_OK;
                break;
            }
        }
        delete [] (PBYTE)MultipleItem;
    }
    //
    // If the current filter does not support the property, or the format
    // is not supported, then search upstream.
    //
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        hr = S_FALSE;
        //
        // Enumerate all the connected input pins, querying the connected
        // pin to ensure that all the pins support the requested format.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                if (SUCCEEDED(hr)) {
                    //
                    // Pass the query upstream, exiting if the format
                    // is not supported by any one connected pin.
                    //
                    hr = MediaSeeking->IsFormatSupported(Format);
                    MediaSeeking->Release();
                    if (FAILED(hr) || (hr == S_FALSE)) {
                        break;
                    }
                } else {
                    //
                    // Can't do any sort of seeking if the interface is not
                    // supported, so just exit.
                    //
                    hr = S_FALSE;
                    break;
                }
            }
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
CKsProxy::QueryPreferredFormat(
    GUID* Format
    )
/*++

Routine Description:

    Implement the IMediaSeeking::QueryPreferredFormat method. Queries
    the filter for the preferred time format. If the property is not
    supported by the filter, attempts to query upstream.

Arguments:

    Format -
        The place in which to put the preferred format.

Return Value:

    Returns S_OK if the preferred format is returned, else some failure
    if this property is not supported.

--*/
{
    PKSMULTIPLE_ITEM    MultipleItem = NULL;

   	CheckPointer( Format, E_POINTER ); //#322955

    HRESULT             hr;
    CAutoLock           AutoLock(m_pLock);

    //
    // Take the filter lock when querying to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once. This return error will instruct
        // the enumeration below to continue rather than stop.
        //
        return S_FALSE;
    }
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    hr = QueryMediaSeekingFormats(&MultipleItem);
    if (SUCCEEDED(hr)) {

        /* NULL == MultipleItem is a pathological case where a driver returns
           a success code in QueryMediaSeekingFormats() when passed a size 0
           buffer.  We'll just do with an assert since we're in ring 3. */
        ASSERT( NULL != MultipleItem );

        //
        // The first format in the list is assumed to be the preferred
        // format.
        //
        *Format = *reinterpret_cast<GUID*>(MultipleItem + 1);
        delete [] reinterpret_cast<BYTE*>(MultipleItem);
    } else if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        //
        // Enumerate all the connected input pins, returning the
        // preferred format of the first pin which responds.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position; Position = m_PinList.Next(Position)) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                if (SUCCEEDED(hr)) {
                    //
                    // Pass the query upstream. The first connected
                    // pin wins when returning a preferred format. If
                    // a connected pin does not support seeking, then
                    // things will work themselves out later.
                    //
                    hr = MediaSeeking->QueryPreferredFormat(Format);
                    MediaSeeking->Release();
                    if (hr != S_FALSE) {
                        //
                        // Only exit if recursion has not happened.
                        //
                        break;
                    }
                }
            }
        }
        if (!Position) {
            //
            // No pin supported the media seeking interface, therefore
            // there is no preferred time format.
            //
            hr = S_FALSE;
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
CKsProxy::GetTimeFormat(
    GUID* Format
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetTimeFormat method. Queries the
    current time format being used by the filter. If the filter does
    not support the query, the first connected pin to respond to the
    query is the format returned.

Arguments:

    Format -
        The place in which to put the current format.

Return Value:

    Returns S_OK if the current format is returned, else some failure
    if this property is not supported.

--*/
{
    HRESULT     hr;
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    CAutoLock   AutoLock(m_pLock);

    //
    // Take the filter lock when querying to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once. This return error will instruct
        // the enumeration below to continue rather than stop.
        //
        return S_FALSE;
    }
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    Property.Set = KSPROPSETID_MediaSeeking;
    Property.Id = KSPROPERTY_MEDIASEEKING_TIMEFORMAT;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Format,
        sizeof(*Format),
        &BytesReturned);
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        //
        // Enumerate all the connected input pins, returning the
        // time format of the first pin which responds.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position; Position = m_PinList.Next(Position)) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                if (SUCCEEDED(hr)) {
                    //
                    // Pass the query upstream. The first connected
                    // pin wins when returning a current format. If
                    // a connected pin does not support seeking, then
                    // things will work themselves out later.
                    //
                    hr = MediaSeeking->GetTimeFormat(Format);
                    MediaSeeking->Release();
                    if (hr != S_FALSE) {
                        //
                        // Only exit if recursion has not happened.
                        //
                        break;
                    }
                }
            }
        }
        if (!Position) {
            //
            // No connected pin supported media seeking, therefore
            // seeking is not implemented.
            //
            hr = E_NOTIMPL;
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
CKsProxy::IsUsingTimeFormat(
    const GUID* Format
    )
/*++

Routine Description:

    Implement the IMediaSeeking::IsUsingTimeFormat method. Compares the
    given time format to the current format.

Arguments:

    Format -
        Contains the time format to compare against the current time
        format.

Return Value:

    Returns S_OK if the given time format is the same as the current
    time format, else S_FALSE.

--*/
{
    GUID    CurrentFormat;

    if (SUCCEEDED(GetTimeFormat(&CurrentFormat))) {
        if (*Format == CurrentFormat) {
            return S_OK;
        }
    }
    return S_FALSE;
}


STDMETHODIMP
CKsProxy::SetTimeFormat(
    const GUID* Format
    )
/*++

Routine Description:

    Implement the IMediaSeeking::SetTimeFormat method. Sets the current
    time format being used for seeking. If the filter does not support
    this property, then the connected upstream pins are notified of the
    time format change. If a filter does not support the seeking interface,
    the call is aborted as is. The assumption is that the caller would have
    queried for support beforehand.

Arguments:

    Format -
        Contains the new time format to use.

Return Value:

    Returns S_OK if the new time format was set, else some critical
    error.

--*/
{
    HRESULT     hr;
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    CAutoLock   AutoLock(m_pLock);

    //
    // Take the filter lock when setting to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once. This error forces the enumeration
        // below to abort.
        //
        return E_NOTIMPL;
    }
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    Property.Set = KSPROPSETID_MediaSeeking;
    Property.Id = KSPROPERTY_MEDIASEEKING_TIMEFORMAT;
    Property.Flags = KSPROPERTY_TYPE_SET;
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        const_cast<GUID*>(Format),
        sizeof(*Format),
        &BytesReturned);
    //
    // Besides the problem of not being supported by the filter, the
    // time format may also need to be set on upstream filters. So
    // allow this by looking for an ERROR_SOME_NOT_MAPPED error
    // return.
    //
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_SOME_NOT_MAPPED))) {
        hr = S_OK;
        //
        // Enumerate all the connected input pins, setting the
        // time format of each pin, aborting if one does not respond.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                if (SUCCEEDED(hr)) {
                    //
                    // Pass the query upstream. All pins must respond
                    // for the format change to be effective.
                    //
                    hr = MediaSeeking->SetTimeFormat(Format);
                    MediaSeeking->Release();
                }
                if (FAILED(hr)) {
                    //
                    // Either the interface was not supported, or
                    // the call failed. Either way abort the call.
                    //
                    break;
                }
            }
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
CKsProxy::GetDuration(
    LONGLONG* Duration
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetDuration method. Queries the total
    duration from the filter. If the filter does not support the query,
    the first connected pin to respond to the query is the duration
    returned.

Arguments:

    Duration -
        The place in which to put the total duration of the longest
        stream.

Return Value:

    Returns S_OK if the duration is returned, else some failure
    if this property is not supported.

--*/
{
    HRESULT     hr;
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    CAutoLock   AutoLock(m_pLock);

    //
    // Take the filter lock when querying to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once. This return error will instruct
        // the enumeration below to continue rather than stop.
        //
        return S_FALSE;
    }
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    Property.Set = KSPROPSETID_MediaSeeking;
    Property.Id = KSPROPERTY_MEDIASEEKING_DURATION;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Duration,
        sizeof(*Duration),
        &BytesReturned);
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        //
        // Enumerate all the connected input pins, returning the
        // duration of the first pin which responds.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position; Position = m_PinList.Next(Position)) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                if (SUCCEEDED(hr)) {
                    //
                    // Pass the query upstream. The first connected
                    // pin wins when returning a duration.
                    //
                    hr = MediaSeeking->GetDuration(Duration);
                    MediaSeeking->Release();
                    if (hr != S_FALSE) {
                        //
                        // Only exit if recursion has not happened.
                        //
                        break;
                    }
                }
            }
        }
        if (!Position) {
            //
            // No connected pin supported media seeking, therefore
            // seeking is not implemented.
            //
            hr = E_NOTIMPL;
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
CKsProxy::GetStopPosition(
    LONGLONG* Stop
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetStopPosition method. Queries the
    current stop position from the filter. If the filter does not
    support the query, the first connected pin to respond to the
    query is the stop position returned.

Arguments:

    Stop -
        The place in which to put the current stop position.

Return Value:

    Returns S_OK if the current stop position is returned, else some
    failure if this property is not supported.

--*/
{
    HRESULT     hr;
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    CAutoLock   AutoLock(m_pLock);

    //
    // Take the filter lock when querying to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once. This return error will instruct
        // the enumeration below to continue rather than stop.
        //
        return S_FALSE;
    }
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    Property.Set = KSPROPSETID_MediaSeeking;
    Property.Id = KSPROPERTY_MEDIASEEKING_STOPPOSITION;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Stop,
        sizeof(*Stop),
        &BytesReturned);
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        //
        // Enumerate all the connected input pins, returning the
        // stop position of the first pin which responds.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position; Position = m_PinList.Next(Position)) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                if (SUCCEEDED(hr)) {
                    //
                    // Pass the query upstream. The first connected
                    // pin wins when returning a stop position.
                    //
                    hr = MediaSeeking->GetStopPosition(Stop);
                    MediaSeeking->Release();
                    if (hr != S_FALSE) {
                        //
                        // Only exit if recursion has not happened.
                        //
                        break;
                    }
                }
            }
        }
        if (!Position) {
            //
            // No connected pin supported media seeking, therefore
            // seeking is not implemented.
            //
            hr = E_NOTIMPL;
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
CKsProxy::GetCurrentPosition(
    LONGLONG* Current
    )
/*++

Routine Description:

    Implement the IMediaSeeking::GetCurrentPosition method. Queries
    the current position from the filter. If the filter does not
    support the query, the first connected pin to respond to the
    query is the position returned.

Arguments:

    Current -
        The place in which to put the current position.

Return Value:

    Returns S_OK if the current position is returned, else some
    failure if this property is not supported.

--*/
{
    HRESULT     hr;
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    CAutoLock   AutoLock(m_pLock);

    //
    // Take the filter lock when querying to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once. This return error will instruct
        // the enumeration below to continue rather than stop.
        //
        return S_FALSE;
    }
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    Property.Set = KSPROPSETID_MediaSeeking;
    Property.Id = KSPROPERTY_MEDIASEEKING_POSITION;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Current,
        sizeof(*Current),
        &BytesReturned);
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        //
        // Enumerate all the connected input pins, returning the
        // current position of the first pin which responds.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position; Position = m_PinList.Next(Position)) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                if (SUCCEEDED(hr)) {
                    //
                    // Pass the query upstream. The first connected
                    // pin wins when returning a current position.
                    //
                    hr = MediaSeeking->GetCurrentPosition(Current);
                    MediaSeeking->Release();
                    if (hr != S_FALSE) {
                        //
                        // Only exit if recursion has not happened.
                        //
                        break;
                    }
                }
            }
        }
        if (!Position) {
            //
            // No connected pin supported media seeking, therefore
            // seeking is not implemented.
            //
            hr = E_NOTIMPL;
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
CKsProxy::ConvertTimeFormat(
    LONGLONG* Target,
    const GUID* TargetFormat,
    LONGLONG Source,
    const GUID* SourceFormat
    )
/*++

Routine Description:

    Implement the IMediaSeeking::ConvertTimeFormat method. Attempts
    to convert the given time format to the specified time format
    using the filter. If the filter does not support the query, each
    connected input pin is queried for the conversion.

Arguments:

    Target -
        The place in which to put the converted time.

    TargetFormat -
        Contains the target time format.

    Source -
        Contains the source time to convert.

    SourceFormat -
        Contains the source time format.

Return Value:

    Returns S_OK if the conversion was successful, else some
    failure if this property is not supported.

--*/
{
    HRESULT         hr;
    KSP_TIMEFORMAT  TimeProperty;
    ULONG           BytesReturned;
    GUID            LocalSourceFormat;
    GUID            LocalTargetFormat;
    CAutoLock       AutoLock(m_pLock);

    //
    // Take the filter lock when querying to guard against recursion.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    if (m_MediaSeekingRecursion) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once. This return error will instruct
        // the enumeration below to continue rather than stop.
        //
        return S_FALSE;
    }

    // Millen / Neptune fix:  Handle NULL pointers for Source and Target formats
    if ((!SourceFormat) && FAILED(GetTimeFormat(&LocalSourceFormat))) {
        return E_NOTIMPL;
    }
    else {
       LocalSourceFormat = *SourceFormat;
    }

    if ((!TargetFormat) && FAILED(GetTimeFormat(&LocalTargetFormat))) {
        return E_NOTIMPL;
    }
    else {
       LocalTargetFormat = *TargetFormat;
    }

    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    m_MediaSeekingRecursion = TRUE;
    TimeProperty.Property.Set = KSPROPSETID_MediaSeeking;
    TimeProperty.Property.Id = KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT;
    TimeProperty.Property.Flags = KSPROPERTY_TYPE_GET;
    TimeProperty.SourceFormat = LocalSourceFormat;
    TimeProperty.TargetFormat = LocalTargetFormat;
    TimeProperty.Time = Source;
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &TimeProperty,
        sizeof(TimeProperty),
        Target,
        sizeof(*Target),
        &BytesReturned);
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        //
        // Enumerate all the connected input pins, returning the
        // conversion from the first pin which responds.
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position; Position = m_PinList.Next(Position)) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                if (SUCCEEDED(hr)) {
                    //
                    // Pass the query upstream. The first connected
                    // pin wins when returning a conversion.
                    //
                    hr = MediaSeeking->ConvertTimeFormat(Target, &LocalTargetFormat, Source, &LocalSourceFormat);
                    MediaSeeking->Release();
                    if (hr != S_FALSE) {
                        //
                        // Only exit if recursion has not happened.
                        //
                        break;
                    }
                }
            }
        }
        if (!Position) {
            //
            // No connected pin supported media seeking, therefore
            // seeking is not implemented.
            //
            hr = E_NOTIMPL;
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
CKsProxy::SetPositions(
    LONGLONG* Current,
    DWORD CurrentFlags,
    LONGLONG* Stop,
    DWORD StopFlags
    )
/*++

Routine Description:

    Implement the IMediaSeeking::SetPositions method. Attempts to
    set the current and/or stop positions on the filter, and/or on
    each connected input pin.

Arguments:

    Current -
        Optionally contains the current position to set.

    CurrentFlags -
        Contains flags pertaining to the Current parameter.

    Stop -
        Optionally contains the stop position to set.

    StopFlags -
        Contains flags pertaining to the Stop parameter.

Return Value:

    Returns S_OK if the positions where set successfully, else some
    failure if this property is not supported.

--*/
{
    HRESULT                 hr;
    KSPROPERTY              Property;
    KSPROPERTY_POSITIONS    Positions;
    ULONG                   BytesReturned;

    //
    // Don't take the filter lock, since passing this request upstream
    // may generate calls back to the filter.
    // Only the recursing thread will be allowed through, and it can
    // then be returned immediately with failure. Also stops the
    // pins from being messed with while enumerating them.
    //
    // After checking for recursion, stop recursion from the same
    // thread.
    //
    if (InterlockedExchange(reinterpret_cast<LONG*>(&m_MediaSeekingRecursion), TRUE)) {
        //
        // Since this query has returned to the filter, reject it.
        // Note that this assumes no two IMediaSeeking recursions
        // are occuring at once. This return error will instruct
        // the enumeration below to exit.
        //
        return E_NOTIMPL;
    }
    Property.Set = KSPROPSETID_MediaSeeking;
    Property.Id = KSPROPERTY_MEDIASEEKING_POSITIONS;
    Property.Flags = KSPROPERTY_TYPE_SET;
    Positions.Current = *Current;
    Positions.CurrentFlags = (KS_SEEKING_FLAGS)CurrentFlags;
    Positions.Stop = *Stop;
    Positions.StopFlags = (KS_SEEKING_FLAGS)StopFlags;
    hr = ::KsSynchronousDeviceControl(
        m_FilterHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &Positions,
        sizeof(Positions),
        &BytesReturned);
    if (SUCCEEDED(hr)) {
        //
        // Returns the actual numbers set. Allow recursion back into
        // these functions.
        //
        m_MediaSeekingRecursion = FALSE;
        if (CurrentFlags & AM_SEEKING_ReturnTime) {
            hr = GetCurrentPosition(Current);
        }
        if (SUCCEEDED(hr) && (StopFlags & AM_SEEKING_ReturnTime)) {
            hr = GetStopPosition(Stop);
        }
        return hr;
    } else if (hr == HRESULT_FROM_WIN32(ERROR_SOME_NOT_MAPPED)) {
        //
        // The set needs to be passed upstream to the connected
        // pins. However, this filter may respond to one or both
        // of the return value queries.
        //
        if ((CurrentFlags & AM_SEEKING_ReturnTime) && SUCCEEDED(GetCurrentPosition(Current))) {
            CurrentFlags &= ~AM_SEEKING_ReturnTime;
        }
        if ((StopFlags & AM_SEEKING_ReturnTime) && SUCCEEDED(GetStopPosition(Stop))) {
            StopFlags &= ~AM_SEEKING_ReturnTime;
        }
    }
    //
    // Besides the problem of not being supported by the filter, the
    // positions may also need to be set on upstream filters. So
    // allow this by looking for an ERROR_SOME_NOT_MAPPED error
    // return.
    //
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_SOME_NOT_MAPPED))) {
        //
        // The upstream pins must respond to the query.
        //
        hr = E_NOTIMPL;
        //
        // Enumerate all the connected input pins, setting the
        // positions on all pins.
        //
        // Keep recursion lock so that setting the positions
        // on this filter will return S_FALSE, and the query
        // will continue with another pin.
        //
        //
        for (POSITION Position = m_PinList.GetHeadPosition(); Position;) {
            CBasePin*       Pin;
            PIN_DIRECTION   PinDirection;

            Pin = m_PinList.Get(Position);
            Position = m_PinList.Next(Position);
            Pin->QueryDirection(&PinDirection);
            if ((PinDirection == PINDIR_INPUT) && Pin->IsConnected()) {
                IPin*           ConnectedPin;
                IMediaSeeking*  MediaSeeking;

                ConnectedPin = static_cast<CBasePin*>(Pin)->GetConnected();
                //
                // Query the connected pin, rather than the filter, for
                // IMediaSeeking support.
                //
                hr = ConnectedPin->QueryInterface(__uuidof(IMediaSeeking), reinterpret_cast<PVOID*>(&MediaSeeking));
                //
                // Can't do any sort of seeking if the interface is not
                // supported, so just exit.
                //
                if (FAILED(hr)) {
                    break;
                }
                //
                // Pass the query upstream. The first connected
                // pin wins when returning updated positions.
                //
                hr = MediaSeeking->SetPositions(Current, CurrentFlags, Stop, StopFlags);
                MediaSeeking->Release();
                if (SUCCEEDED(hr)) {
                    //
                    // Remove these flags for any subsequent query. This
                    // also indicates that the positions have actually
                    // been retrieved.
                    //
                    CurrentFlags &= ~AM_SEEKING_ReturnTime;
                    StopFlags &= ~AM_SEEKING_ReturnTime;
                } else {
                    //
                    // Can't do any sort of seeking if one pin fails,
                    // so just exit.
                    //
                    break;
                }
            }
        }
    }
    m_MediaSeekingRecursion = FALSE;
    return hr;
}


STDMETHODIMP
